- en: 7 Logging Data from Power BI to External Sources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 从 Power BI 记录数据到外部源
- en: 'As you''ve learned from previous chapters, **Power BI** uses **Power Query**
    as a tool for **extract transform load** (**ETL**) operations. The tool in question
    is really very powerful – it allows you to extract data from a wide variety of
    data sources and then easily transform it with very user-friendly options in order
    to persist it into the Power BI data model. It is a tool that is only able to
    read information from the outside. In fact, the most stringent limitation of Power
    Query is its inability to write information outside of Power BI. However, thanks
    to the integration of analytical languages such as **Python** and **R**, you''ll
    be able to persist information about Power Query loading and transformation processes
    to external files or systems. In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前几章所学，**Power BI** 使用 **Power Query** 作为 **提取、转换、加载** （**ETL**）操作的工具。这个工具实际上非常强大——它允许您从各种数据源中提取数据，然后通过非常用户友好的选项轻松转换它，以便将其持久化到
    Power BI 数据模型中。这是一个只能从外部读取信息的工具。实际上，Power Query 最严格的限制是其无法将信息写入 Power BI 之外。然而，由于与
    **Python** 和 **R** 等分析语言的集成，您将能够将 Power Query 加载和转换过程的信息持久化到外部文件或系统中。在本章中，您将学习以下主题：
- en: Logging to **CSV** files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到 **CSV** 文件
- en: Logging to **Excel** files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到 **Excel** 文件
- en: Logging to **Azure** **SQL Server**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录到 **Azure** **SQL Server**
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires you to have a working Internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2*, *Configuring R with
    Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您拥有一个正常工作的互联网连接，并且您的机器上已经安装了 **Power BI Desktop**。您必须已按照 *第 2 章*、*配置 Power
    BI 中的 R* 和 *第 3 章*、*配置 Power BI 中的 Python* 中概述的方式正确配置了 R 和 Python 引擎和 IDE。
- en: Logging to CSV files
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录到 CSV 文件
- en: One of the most widely used formats for logging tabular structured information
    to files is **comma-separated value** (**CSV**). Since a CSV file is still a flat
    text file, CSV is the most popular format for exchanging information between heterogeneous
    applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将表格结构化信息记录到文件的格式中，最广泛使用的一种是 **逗号分隔值** （**CSV**）。由于 CSV 文件仍然是平面文本文件，CSV 是在异构应用程序之间交换信息最流行的格式。
- en: 'A CSV file is a representation of a rectangular dataset (**matrix**), containing
    numeric or string columns. Each row of the matrix is represented by a list of
    values (one for each column), separated by a comma, and should have the same number
    of values. Sometimes, other value delimiters could be used, like tab (`\t`), colon
    (`:`), and semi-colon (`;`) characters. The first row could contain the column
    header names. Usually, a **line break**, made by **CRLF** (**Carriage Return Line
    Feed**)characters (usually entered as `\r\n`), or simply by **LF** (`\n`) in Unix
    systems, is used as a **row delimiter**. So, an example of CSV file content could
    be the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件是矩形数据集（**矩阵**）的表示，包含数字或字符串列。矩阵的每一行由一系列值（每列一个）表示，这些值由逗号分隔，并且应该有相同数量的值。有时，可以使用其他值分隔符，如制表符（`\t`）、冒号（`:`）和分号（`;`）字符。第一行可能包含列标题名称。通常，使用由
    **CRLF** （**回车换行符**）字符（通常输入为 `\r\n`）或简单地使用 Unix 系统中的 **LF** （`\n`）创建的 **换行符**
    作为 **行分隔符**。因此，CSV 文件内容的示例可能如下所示：
- en: '![Figure 7.1 – Example of CSV file content](img/file174.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – CSV 文件内容的示例](img/file174.png)'
- en: Figure 7.1 – Example of CSV file content
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – CSV 文件内容的示例
- en: Note the spaces as they become part of a string value! For example, the second
    value of the `V1, V2` row will be `[space]V2`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意空格，因为它们成为字符串值的一部分！例如，`V1, V2` 行的第二个值将是 `[空格]V2`。
- en: 'It may happen that a string value contains line breaks (`CRLF`), double-quotes,
    or commas (as usually happens with free text fields like “Notes”). In this case,
    the value should be enclosed in double-quotes and any literal double quote has
    to be escaped using another double quote. For example, the values `"` `C,D"`,
    “`E""F`” and `"G[CRLF]H"` for the column `Col1` are formatted in the following
    way in a CSV file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生字符串值包含换行符（`CRLF`）、双引号或逗号（如通常在“注释”等自由文本字段中发生的情况）。在这种情况下，值应该用双引号括起来，并且任何字面双引号必须使用另一个双引号进行转义。例如，对于
    `Col1` 列的值 `"` `C,D"`、“`E""F`” 和 `"G[CRLF]H"` 在 CSV 文件中的格式如下所示：
- en: '![Figure 7.2 – Example of CSV values containing commas, double quotes, or CRLF](img/file175.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 包含逗号、双引号或 CRLF 的 CSV 值的示例](img/file175.png)'
- en: Figure 7.2 – Example of CSV values containing commas, double quotes, or CRLF
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 包含逗号、双引号或CRLF的CSV值示例
- en: '**Important Note**'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is important to keep in mind that a CSV file doesn’t have any size limits
    per se.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要记住，CSV文件本身没有大小限制。
- en: Since it is a flat text file, the maximum size is determined by the limits imposed
    by the filesystem. For example, the default filesystem for Windows is the **New
    Technology File System** (**NTFS**) and it allows a maximum file size of *16 TB*
    as its current implementation. However, its designed theoretical limit is *16
    EB* (16 × 2^(64) bytes) minus *1 KB*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个平面文本文件，其最大大小由文件系统施加的限制决定。例如，Windows的默认文件系统是**新技术文件系统**（**NTFS**），其当前实现允许的最大文件大小为*16
    TB*。然而，其设计的理论极限是*16 EB*（16 × 2^(64)字节）减去*1 KB*。
- en: However, the old **File Allocation Table** filesystem, in its variant of 32
    bits (**FAT32**), can only handle a maximum size of *4 GB*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，旧的**文件分配表**文件系统，在其32位（**FAT32**）变体中，只能处理最大大小为*4 GB*。
- en: '**Important Note**'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keep in mind that handling large CSV files leads to memory and/or CPU bottlenecks.
    You are very likely to get an `OutOfMemory` error if the CSV file to be loaded
    is larger than the RAM you have available and if your libraries don’t use parallelism/distribution/lazy
    loading mechanisms. You'll learn how to handle such large CSV files in *Chapter
    8*, *Loading Large Datasets Beyond the Available RAM in Power BI*.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，处理大型CSV文件会导致内存和/或CPU瓶颈。如果待加载的CSV文件大小超过您可用的RAM，并且您的库不使用并行性/分布式/延迟加载机制，那么您很可能遇到`OutOfMemory`错误。您将在*第8章*，*在Power
    BI中加载超过可用RAM的大型数据集*中学习如何处理这样的大型CSV文件。
- en: Let's see how to read and write CSV files with Python.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Python读取和写入CSV文件。
- en: Logging to CSV files with Python
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Python记录到CSV文件
- en: Python has a built-in CSV module that provides some functions to read and write
    CSV files. Very often, however, you will have to import a CSV file whose content
    will then be transformed through Pandas functions, or you must export in a CSV
    format a DataFrame previously processed through Pandas. That's why, in these cases,
    it is much more convenient to directly use the built-in pandas functions with
    DataFrame objects. You will find the `01-read-csv-file-in-python.py` and `02-write-csv-file-in-python.py`
    files in the `Chapter07/Python` folder that will show you how to use the CSV module.
    In the following section, we will focus exclusively on the functionality provided
    by pandas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内置的CSV模块，它提供了一些读取和写入CSV文件的功能。然而，非常常见的情况是，您需要导入一个CSV文件，其内容将通过Pandas函数进行转换，或者您必须将之前通过Pandas处理过的DataFrame以CSV格式导出。这就是为什么在这些情况下，直接使用内置的pandas函数与DataFrame对象一起使用要方便得多。您可以在`Chapter07/Python`文件夹中找到`01-read-csv-file-in-python.py`和`02-write-csv-file-in-python.py`文件，这些文件将向您展示如何使用CSV模块。在下一节中，我们将专注于pandas提供的功能。
- en: Let's look in detail at the pandas functions available to work with CSV files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看可用于处理CSV文件的pandas函数。
- en: Using the pandas module
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用pandas模块
- en: 'The functions that the `pandas` module provides to read and write a CSV file
    are very simple and straightforward. You can use the `read_csv()` function to
    read data from a CSV file. The following is the code that allows you to load the
    content of the `example.csv` file in a DataFrame:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas`模块提供的用于读取和写入CSV文件的功能非常简单直接。您可以使用`read_csv()`函数从CSV文件中读取数据。以下是可以将`example.csv`文件的内容加载到DataFrame中的代码：'
- en: '`Chapter07\Python\03-read-csv-file-with-pandas.py`'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Chapter07\Python\03-read-csv-file-with-pandas.py`'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the output using the **VS Code** **Interactive Window**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用**VS Code** **交互窗口**的输出：
- en: '![Figure 7.3 – Output of the pandas DataFrame loaded with the example CSV file’s
    content](img/file176.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 使用示例CSV文件内容加载的pandas DataFrame的输出](img/file176.png)'
- en: Figure 7.3 – Output of the pandas DataFrame loaded with the example CSV file’s
    content
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 使用示例CSV文件内容加载的pandas DataFrame的输出
- en: The `read_csv` function also allows you to pass the `sep` parameter to define
    the value separator to be used when reading the file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_csv`函数还允许您传递`sep`参数来定义在读取文件时使用的值分隔符。'
- en: 'If, on the other hand, you need to write a CSV file from the contents of a
    DataFrame, you can use the `to_csv()` function. The following is an example of
    the code you could use:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要从DataFrame的内容中写入CSV文件，则可以使用`to_csv()`函数。以下是一个您可能使用的代码示例：
- en: '`Chapter07\Python\04-write-csv-file-with-pandas.py`'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Chapter07\Python\04-write-csv-file-with-pandas.py`'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `to_csv()` function also allows you to pass the `sep` parameter in order
    to define the value separator you intend to use in the file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_csv()` 函数还允许您传递 `sep` 参数，以便定义您在文件中打算使用的值分隔符。'
- en: As you can see, working with CSV files in Python is very easy. In the next section,
    you'll put this into practice in Power BI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 Python 中处理 CSV 文件非常简单。在下一节中，您将在 Power BI 中将其付诸实践。
- en: Logging emails to CSV files in Power BI with Python
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Python 在 Power BI 中将电子邮件记录到 CSV 文件中
- en: 'As an example of generating a CSV file, we will use the same scenario provided
    in *Chapter 5*, *Using Regular Expressions in Power BI*, in which you needed to
    validate email addresses and ban dates. The goal is to export the rows of the
    dataset containing an incorrect email to a CSV file and to filter them out of
    the dataset so that only valid emails remain in Power BI. We will use the `to_csv()`
    function that pandas provides. The necessary steps are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 作为生成 CSV 文件的示例，我们将使用第 5 章，“使用正则表达式在 Power BI 中”中提供的相同场景，其中您需要验证电子邮件地址和禁用日期。目标是导出包含不正确电子邮件的行到
    CSV 文件，并从数据集中过滤它们，以便在 Power BI 中只保留有效的电子邮件。我们将使用 pandas 提供的 `to_csv()` 函数。必要的步骤如下：
- en: Follow all the steps in the *Using regex in Power BI to validate emails with
    Python* section of *Chapter 5*, *Using Regular Expressions in Power BI* to the
    end, but do not click on **Close & Apply**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 5 章，“使用正则表达式在 Power BI 中验证电子邮件”中“使用 regex 在 Power BI 中验证电子邮件的 Python”部分的步骤进行，但不要点击
    **关闭并应用**。
- en: 'Then, click on **Run Python Script**, enter the following script, and click
    **OK**:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **运行 Python 脚本**，输入以下脚本，然后点击 **确定**：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find this Python script also in the `Python\05-log-wrong-emails-csv-in-power-bi.py`
    file. Note the `~` character that in this case is a negation of the Boolean condition
    defined by the `filter` variable.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在 `Python\05-log-wrong-emails-csv-in-power-bi.py` 文件中找到此 Python 脚本。注意，这里的
    `~` 字符在这种情况下是 `filter` 变量定义的布尔条件的否定。
- en: 'Click on the `df` dataset’s **Table** value:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `df` 数据集的 **表** 值：
- en: '![Figure 7.4 – Selecting the df dataset as a result of the Python script transformation](img/file177.png)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.4 – 选择 Python 脚本转换后的 df 数据集](img/file177.png)'
- en: Figure 7.4 – Selecting the df dataset as a result of the Python script transformation
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.4 – 选择 Python 脚本转换后的 df 数据集
- en: 'Only rows containing valid emails will be kept:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅保留包含有效电子邮件的行：
- en: '![Figure 7.5 – A table containing only valid emails](img/file178.png)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.5 – 仅包含有效电子邮件的表格](img/file178.png)'
- en: Figure 7.5 – A table containing only valid emails
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.5 – 仅包含有效电子邮件的表格
- en: Moreover, the `wrong-emails.csv` file has been created in your `Chapter07\Python`
    folder.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`wrong-emails.csv` 文件已创建在您的 `Chapter07\Python` 文件夹中。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **主页** 菜单，然后点击 **关闭并应用**。
- en: 'If you go and check the contents of the created CSV file, it matches the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查创建的 CSV 文件的内容，它将与以下内容匹配：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the emails in the CSV file are all the invalid ones. At this
    point, you can share the previous file with your colleagues so that they can correct
    invalid emails.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，CSV 文件中的电子邮件都是无效的。在此阶段，您可以与同事分享之前的文件，以便他们可以纠正无效的电子邮件。
- en: Well done! You just learned how to log information to a CSV file from Power
    BI using Python. Now, let's see how you can do the same thing using R.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您刚刚学会了如何使用 Python 从 Power BI 将信息记录到 CSV 文件中。现在，让我们看看您如何使用 R 做同样的事情。
- en: Logging to CSV files with R
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 将日志记录到 CSV 文件中
- en: The basic R language provides some out-of-the-box functions for working with
    CSV files. However, there is also the `readr` package, included in the **Tidyverse**
    ecosystem, which provides similar functions, but is faster in loading larger CSV
    files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 R 语言提供了一些现成的函数用于处理 CSV 文件。然而，还有 `readr` 包，它是 **Tidyverse** 生态系统的一部分，提供了类似的功能，但在加载较大的
    CSV 文件时速度更快。
- en: Let's see how to use them in detail.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看如何使用它们。
- en: Using the Tidyverse functions
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Tidyverse 函数
- en: The `readr` package provides some functions mirroring those seen for reading
    and writing CSV files with R base. The advantage of these functions is that, in
    addition to respecting the common interface provided by the functions of the Tidyverse
    world, they are up to five times faster than standard functions and also progress
    meters. Make sure you have at least version 1.4.0 of the package installed, otherwise,
    update it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`readr` 包提供了一些与使用 R 基础读取和写入 CSV 文件时看到的函数相似的函数。这些函数的优势在于，除了尊重 Tidyverse 世界中函数提供的通用接口外，它们的速度比标准函数快五倍，并且还有进度条。请确保你已经安装了至少版本
    1.4.0 的包，否则请更新它。'
- en: 'Always using the usual `example.csv` file, similarly to what we did in the
    previous section, you can load the data through the `read_csv()` function of the
    `readr` package in this way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 像上一节中做的那样，始终使用 `example.csv` 文件，你可以通过以下方式使用 `readr` 包的 `read_csv()` 函数加载数据：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As output, you can see the following specification:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出，你可以看到以下规范：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides the fact that the `read_csv()` function outputs a **tibble** instead
    of a DataFrame, there is one point that is important to note:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `read_csv()` 函数输出的是 **tibble** 而不是 DataFrame 之外，还有一个重要点需要注意：
- en: '**Important Note**'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The interesting thing is that the `read_csv()` function correctly imports the
    carriage return character by default.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有趣的是，`read_csv()` 函数默认正确地导入换行符。
- en: 'If you check the newly imported tibble, you have the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查新导入的 tibble，你将看到以下内容：
- en: '![Figure 7.6– Characters \r\n correctly imported by read_csv](img/file179.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6– read_csv 正确导入字符 \r\n](img/file179.png)'
- en: Figure 7.6– Characters \r\n correctly imported by read_csv
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6– read_csv 正确导入字符 \r\n
- en: Just as with R base, the `readr` package also provides the same functions, `read_csv2()`,
    `read_tsv()`, and `read_delim()`, to ensure a similar interface and thus easy
    usability.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 R 基础一样，`readr` 包也提供了相同的函数，`read_csv2()`、`read_tsv()` 和 `read_delim()`，以确保类似的接口，从而易于使用。
- en: 'To persist data toa CSV file, the `readr` package provides the `write_csv()`
    function with its whole family of functions, similarly to R base (`write_csv2`,
    `write_tsv`, and `write_delim`). Unlike `write.csv()`, these functions do not
    include row names as a column in the written file. Moreover, the default end-of-line
    separator is just a new line (`\n`). So, if you want to export your data using
    the `\r\n` characters as a line separator, you have to pass them through the `eol`
    parameter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据持久化到 CSV 文件，`readr` 包提供了 `write_csv()` 函数及其整个函数家族（类似于 R 基础的 `write_csv2`、`write_tsv`
    和 `write_delim`）。与 `write.csv()` 不同，这些函数不包括行名作为文件中的列。此外，默认的行结束分隔符只是一个新行（`\n`）。因此，如果你想使用
    `\r\n` 字符作为行分隔符来导出你的数据，你必须通过 `eol` 参数传递它们：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Observe that, in this case, you have to use both characters (`\r\n`) in your
    data if you want to extract them in exactly the same way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，如果你想以完全相同的方式提取它们，你必须在你的数据中使用这两个字符（`\r\n`）。
- en: As you can see, working with CSV files in R is as simple as it was in Python.
    In the next section, you will log emails and dates with R in Power BI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在 R 中处理 CSV 文件与在 Python 中一样简单。在下一节中，你将使用 R 在 Power BI 中记录电子邮件和日期。
- en: Logging dates to CSV files in Power BI with R
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Power BI 中使用 R 将日期记录到 CSV 文件中
- en: 'We will always use the scenario presented in *Chapter 5*, *Using Regular Expressions
    in Power BI*, where it was necessary to validate both email addresses and ban
    dates. This time, we will use R to export invalid ban dates to a CSV file. The
    necessary steps are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将始终使用 *第五章* 中介绍的情景，即 *在 Power BI 中使用正则表达式*，其中需要验证电子邮件地址和禁止日期。这次，我们将使用 R 将无效的禁止日期导出到
    CSV 文件。必要的步骤如下：
- en: Follow all the steps in the *Using regex in Power BI to validate dates with
    R* section of *Chapter 5*, *Using Regular Expressions in Power BI* to the end,
    but do not click on **Close & Apply**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 5 章 *在 Power BI 中使用正则表达式* 中 *使用 regex 在 Power BI 中用 R 验证日期* 部分的所有步骤进行操作，但不要点击
    **关闭并应用**。
- en: 'Then click on **Run R Script**, enter the following script, and click **OK**:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **运行 R 脚本**，输入以下脚本，然后点击 **确定**：
- en: '[PRE7]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can find this R script also in the `R\01-log-wrong-emails-in-r.R` file.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在 `R\01-log-wrong-emails-in-r.R` 文件中找到这个 R 脚本。
- en: 'Click on the `df` dataset’s **Table** value:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `df` 数据集的 **表** 值：
- en: '![Figure 7.7 – Selecting the df dataset as a result of the R script transformation](img/file180.png)'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.7 – 选择 R 脚本转换后的 df 数据集](img/file180.png)'
- en: Figure 7.7 – Selecting the df dataset as a result of the R script transformation
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.7 – 选择 R 脚本转换后的 df 数据集
- en: 'Only rows containing valid emails will be kept:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有包含有效电子邮件的行将被保留：
- en: '![Figure 7.8 – A table containing only valid emails](img/file181.png)'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.8 – 仅包含有效电子邮件的表格](img/file181.png)'
- en: Figure 7.8 – A table containing only valid emails
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.8 – 仅包含有效电子邮件的表格
- en: Moreover, the `wrong-dates.csv` file has been created in your `Chapter07\R`
    folder.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`wrong-dates.csv` 文件已创建在您的 `Chapter07\R` 文件夹中。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 **主页** 菜单，然后点击 **关闭并应用**。
- en: At this point, you can share the just created `wrong-emails.csv` file with your
    colleagues so that they can correct invalid emails.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，您可以与同事分享刚刚创建的 `wrong-emails.csv` 文件，以便他们可以纠正无效的电子邮件。
- en: Awesome! You just learned how to log information to a CSV file from Power BI
    using R. Let's now see how to use Excel files to log your information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何使用R从Power BI将信息记录到CSV文件中。现在让我们看看如何使用Excel文件来记录您的信息。
- en: Logging to Excel files
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将日志记录到Excel文件中
- en: As you probably already know, Microsoft Excel is **spreadsheet** software available
    in the **Microsoft** **Office** suite. It’s one of the most widely used tools
    in the world for storing and organizing data in a table format. It is very popular
    in companies because it allows business data to be shared between departments
    and enables individual users to do their own data analysis directly and quickly
    without the help of the IT department.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道，Microsoft Excel 是 **电子表格** 软件，可在 **Microsoft** **办公套件** 中使用。它是世界上用于以表格格式存储和组织数据的工具之一，应用非常广泛。它在公司中非常受欢迎，因为它允许业务数据在部门之间共享，并使个人用户能够直接快速地进行数据分析，而无需IT部门帮助。
- en: Early versions of Excel stored information in files of the **Excel Sheet** (**XLS**)
    format. This is a proprietary Microsoft format, based on the **Binary Interchange
    File Format** (**BIFF**). It has been the default format for versions from v7.0
    (Excel 95) to v11.0 (Excel 2003). From version 8.0 to 11.0 the XLS format can
    handle *64K (2^(16) = 65,536) rows* and *256 columns (2⁸)*. Starting with version
    v12.0 (Excel 2007), the default format has changed to **Excel Open XML Spreadsheet**
    (**XLSX**). This is based on the **Office Open XML** format, and it is based on
    text files that use XML to define all its parameters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Excel的早期版本以 **Excel工作表**（**XLS**）格式存储信息。这是一个专有的Microsoft格式，基于 **二进制交换文件格式**（**BIFF**）。它一直是v7.0（Excel
    95）到v11.0（Excel 2003）版本的标准格式。从v8.0到v11.0，XLS格式可以处理 *64K（2^(16) = 65,536) 行* 和
    *256 列（2⁸）*。从v12.0（Excel 2007）版本开始，默认格式已更改为 **Excel Open XML电子表格**（**XLSX**）。这是基于
    **Office Open XML** 格式，它基于使用XML定义所有参数的文本文件。
- en: '**Note**'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you know that an XLSX file contains data in multiple XML files compressed
    in the **ZIP** format? If you want to verify this, simply rename one of your XLSX
    files, for example, `example.xlsx`, adding the `.zip` extension to it (for example,
    `example.xlsx.zip`). Then, extract its content using the **File Explorer** or
    any other Zip client (like **7-Zip**).
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您知道吗？XLSX文件包含在 **ZIP** 格式压缩的多个XML文件中的数据？如果您想验证这一点，只需将您的XLSX文件重命名，例如，将 `example.xlsx`
    改名为添加 `.zip` 扩展名（例如，`example.xlsx.zip`）。然后，使用 **文件资源管理器** 或任何其他Zip客户端（如 **7-Zip**）提取其内容。
- en: The XLSX format can handle *1024K (2^(20) = 1,048,576) rows and 16,384 (2^(14))
    columns*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: XLSX格式可以处理 *1024K（2^(20) = 1,048,576) 行和 16,384（2^(14)）列*。
- en: Since **Power Pivot** (starting with Excel 2013) and **Power Query** (starting
    with Excel 2016) were introduced, most of the data ingestion and data analysis
    activities for the purpose of generating a prototype data model are often performed
    by power-users thanks to Microsoft Excel. Power Query gives you a set of rich
    tools for transforming data all in one place. Power Pivot gives you the ability
    to work with large volumes of data by overcoming Excel's limitation of 1,048,576
    rows. Once imported, you can use pivot tables and the **DAX** formula language
    on them, since the engine behind the scenes is the same as **Analysis Service
    Tabular** and Power BI. That's why Excel and Power BI are the premier tools for
    self-service BI on the **Microsoft** **Data Platform**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 **Power Pivot**（从Excel 2013开始）和 **Power Query**（从Excel 2016开始）被引入以来，大多数用于生成原型数据模型的数据摄取和分析活动通常由高级用户通过Microsoft
    Excel完成。Power Query为您提供了一个丰富的工具集，用于在一个地方转换数据。Power Pivot通过克服Excel的1,048,576行限制，使您能够处理大量数据。一旦导入，您可以使用数据透视表和
    **DAX** 公式语言对它们进行操作，因为后台引擎与 **分析服务表格** 和 Power BI 相同。这就是为什么Excel和Power BI是 **Microsoft**
    **数据平台** 上自助BI的顶级工具。
- en: Now, let's see how to interact with Excel files in Python. We will use the latest
    XLSX format from now on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 Python 中与 Excel 文件交互。从现在开始，我们将使用最新的 XLSX 格式。
- en: Logging to Excel files with Python
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 将日志记录到 Excel 文件
- en: 'The fastest way to interact with Excel files in Python is to use the functions
    that pandas provides. However, you need to install the `openpyxl` package in your
    `pbi_powerquery_env` environment. If you remember correctly, you already installed
    this package in the environment dedicated to **Presidio** (`presidio_env`) in
    *Chapter 6*, *Anonymizing and Pseudonymizing your Data in Power BI*. In order
    to install this package, also in the `pbi_powerquery_env` environment, simply
    follow these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中与 Excel 文件交互最快的方法是使用 pandas 提供的函数。然而，你需要在 `pbi_powerquery_env` 环境中安装
    `openpyxl` 包。如果你记得正确，你已经在 *第 6 章* 中安装了此包，即在 *Power BI 中的数据匿名化和假名化* 环境中。为了在 `pbi_powerquery_env`
    环境中安装此包，只需按照以下步骤操作：
- en: Open your **Anaconda** **Prompt**
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 **Anaconda** **提示符**
- en: 'Set your current environment to `pbi_powerquery_env`, entering the following
    command and pressing **Enter**:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前环境设置为 `pbi_powerquery_env`，输入以下命令并按**Enter**键：
- en: '[PRE8]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Enter the following command and press **Enter**:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令并按**Enter**键：
- en: '[PRE9]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As an example, you will find the `example.xlsx` file in the `Chapter07` folder.
    Let’s see how to import its content with Python.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你将在 `Chapter07` 文件夹中找到 `example.xlsx` 文件。让我们看看如何使用 Python 导入其内容。
- en: Using the pandas module
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 pandas 模块
- en: 'You can easily import your data into a pandas DataFrame using this code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用此代码轻松地将数据导入到 pandas DataFrame 中：
- en: '`Chapter07\Python\06-read-excel-file-with-pandas.py`'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Chapter07\Python\06-read-excel-file-with-pandas.py`'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you visualize the DataFrame in VS Code, you’ll see something like the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 VS Code 中可视化 DataFrame，你会看到如下内容：
- en: '![Figure 7.9 – Output of the pandas DataFrame loaded with the example.xlsx
    file’s content](img/file182.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 加载 example.xlsx 文件内容的 pandas DataFrame 的输出](img/file182.png)'
- en: Figure 7.9 – Output of the pandas DataFrame loaded with the example.xlsx file’s
    content
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 加载 example.xlsx 文件内容的 pandas DataFrame 的输出
- en: In this case, if an Excel cell contains a string with the `\r\n` characters,
    the carriage return (`\r`) is lost after import, as you can see in *Figure 7.11*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 Excel 单元格包含带有 `\r\n` 字符的字符串，导入后换行符（`\r`）会丢失，正如你在 *图 7.11* 中可以看到的。
- en: 'As you probably already know, an Excel file (**workbook**) can contain one
    or more sheets (**worksheets**) in which there is data. If you need to import
    data from a specific worksheet, you can use this code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经知道，Excel 文件（**工作簿**）可以包含一个或多个工作表（**工作表**），其中包含数据。如果你需要从特定工作表导入数据，你可以使用此代码：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, you can write the contents of a DataFrame to Excel files using this
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用此代码将 DataFrame 的内容写入 Excel 文件：
- en: '`Chapter07\Python\07-write-excel-file-with-pandas.py`'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Chapter07\Python\07-write-excel-file-with-pandas.py`'
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting Excel file will have a default `Sheet1` worksheet, and its content
    will look like the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 Excel 文件将有一个默认的 `Sheet1` 工作表，其内容如下所示：
- en: '![Figure 7.10 – The content of the Excel file created using pandas functions](img/file183.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 使用 pandas 函数创建的 Excel 文件的内容](img/file183.png)'
- en: Figure 7.10 – The content of the Excel file created using pandas functions
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 使用 pandas 函数创建的 Excel 文件的内容
- en: If you copy the contents of cell `A6` into an advanced editor, you can verify
    that the `\r\n` characters are kept.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将单元格 `A6` 的内容复制到一个高级编辑器中，你可以验证 `\r\n` 字符是否被保留。
- en: 'If you want to write the content of your dataset to a specific named worksheet
    in *a new Excel file*, then you can use the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将数据集的内容写入到一个新的 Excel 文件中的特定命名工作表，你可以使用以下代码：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result will be the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是以下内容：
- en: '![Figure 7.11 – The content is now written into a named worksheet](img/file184.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 内容现在已写入到命名工作表中](img/file184.png)'
- en: Figure 7.11 – The content is now written into a named worksheet
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 内容现在已写入到命名工作表中
- en: 'If instead you want to write the content of your dataset to a specific named
    worksheet in *an existing Excel file*, then you have to use the pandas `ExcelWriter`
    class in the following way:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将数据集的内容写入到一个现有的 Excel 文件中的特定命名工作表，你必须使用 pandas 的 `ExcelWriter` 类，如下所示：
- en: '`Chapter07\Python\08-write-excel-file-named-sheet-with-pandas.py`'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Chapter07\Python\08-write-excel-file-named-sheet-with-pandas.py`'
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note, that the `mode='a'` is for *“append”*. Let's now look at an example of
    logging in Power BI using the previous pandas functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`mode='a'`是用于*“追加”*。现在，让我们看看如何使用之前提到的pandas函数在Power BI中登录的一个例子。
- en: Logging emails and dates to Excel files in Power BI with Python
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python在Power BI中记录电子邮件和日期到Excel文件
- en: Let's go back to the same scenario used in the previous sections, namely, the
    one we already analyzed in *Chapter 5*, *Using Regular Expressions in Power BI*,
    in which you needed to validate email addresses and ban dates. This time, however,
    the goal is to export invalid emails and invalid dates to two separate worksheets
    in an Excel file and then share it with the team.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到前面章节中使用的相同场景，即我们在*第5章*，*在Power BI中使用正则表达式*中已经分析过的场景，其中你需要验证电子邮件地址和禁止日期。然而，这次的目标是将无效的电子邮件和无效的日期导出到Excel文件中的两个单独的工作表，然后与团队共享。
- en: 'Now, open your Power BI Desktop, make sure the Python environment to use is
    `pbi_powerquery_env`, and let''s get started:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的Power BI桌面版，确保要使用的Python环境是`pbi_powerquery_env`，然后我们开始吧：
- en: From the ribbon, click on the **Excel** icon to import data from Excel.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从功能区点击**Excel**图标以从Excel导入数据。
- en: From the **Open** dialog box, select the `Users.xlsx` file you can find in the
    `Chapter05` folder.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**打开**对话框中选择你可以在`Chapter05`文件夹中找到的`Users.xlsx`文件。
- en: From the **Navigator** window, select the **Users** sheet and then click on
    **Transform Data**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**导航器**窗口中选择**用户**表单，然后点击**转换数据**。
- en: Click on the **Transform** menu, and then click on **Run Python Script**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**转换**菜单，然后点击**运行Python脚本**。
- en: Copy the code you can find in the `09-validate-emails-dates-with-regex-in-power-bi.py`
    file in the `Chapter07/Python` folder, and paste it into the Python script editor.
    This code is just a merging of the scripts you already used to validate emails
    and dates separately. Then, click **OK**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制你可以在`Chapter07/Python`文件夹中的`09-validate-emails-dates-with-regex-in-power-bi.py`文件中找到的代码，并将其粘贴到Python脚本编辑器中。这段代码只是你之前用来分别验证电子邮件和日期的脚本的合并。然后，点击**确定**。
- en: 'Select just the **Table** value related to the `df` table name and you will
    see something like this:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择与`df`表名相关的**表**值，你将看到类似以下内容：
- en: '![Figure 7.11 – The transformed data contains both the flags for valid emails
    and dates](img/file185.png)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.11 – 转换后的数据包含有效电子邮件和日期的标志](img/file185.png)'
- en: Figure 7.11 – The transformed data contains both the flags for valid emails
    and dates
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11 – 转换后的数据包含有效电子邮件和日期的标志
- en: Now, you have both the `isEmailValidFromRegex` and `isValidDateFromRegex` flags
    that allow you to select emails and correct dates.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你有了`isEmailValidFromRegex`和`isValidDateFromRegex`这两个标志，它们允许你选择电子邮件和正确的日期。
- en: Click again on **Run Python Script**, enter the script you can find in the `10-log-wrong-emails-dates-excel-in-power-bi.py`
    file, and click **OK**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**运行Python脚本**，输入你可以在`10-log-wrong-emails-dates-excel-in-power-bi.py`文件中找到的脚本，然后点击**确定**。
- en: 'Select just the **Table** value related to the `df` table name and you will
    see a table where only rows containing valid emails and dates will be kept:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择与`df`表名相关的**表**值，你将看到一个只保留包含有效电子邮件和日期的行的表格：
- en: '![Figure 7.12 – The output data contains rows containing valid emails and dates](img/file186.png)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.12 – 输出数据包含包含有效电子邮件和日期的行](img/file186.png)'
- en: Figure 7.12 – The output data contains rows containing valid emails and dates
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12 – 输出数据包含包含有效电子邮件和日期的行
- en: 'Moreover, the `wrong-data.xlsx` file has been created in your `Chapter07/Python`
    folder and it contains two worksheets: `Wrong emails` and `Wrong dates`.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`wrong-data.xlsx`文件已经创建在你的`Chapter07/Python`文件夹中，它包含两个工作表：`Wrong emails`和`Wrong
    dates`。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**主页**菜单，然后点击**关闭并应用**。
- en: Amazing! You just learned how to log information to an Excel file in multiple
    sheets from Power BI using Python. Now, let's see how you can do the same thing
    using R.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚学会了如何使用Python从Power BI将信息记录到多个工作表的Excel文件中。现在，让我们看看如何使用R做同样的事情。
- en: Logging to Excel files with R
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用R记录到Excel文件
- en: 'To be able to read and write Excel files in R, we recommend the use of two
    separate packages:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要在R中读取和写入Excel文件，我们建议使用两个独立的包：
- en: '**readxl**: This is a package that is part of the Tidyverse world and allows
    you to read the information contained in an Excel file in the simplest and most
    flexible way.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readxl**：这是一个属于Tidyverse世界的包，允许你以最简单和最灵活的方式读取Excel文件中的信息。'
- en: '**openxlsx**: This is a package that provides a high-level interface for creating
    and editing Excel files. Compared to other packages that do the same thing, `openxlsx`
    removes the dependency on **Java** behind the scenes.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**openxlsx**：这是一个提供创建和编辑Excel文件高级界面的包。与其他执行相同任务的包相比，`openxlsx`消除了背后对**Java**的依赖。'
- en: 'First, you need to install the `openxlsx` package:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装`openxlsx`包：
- en: Open **RStudio**, and make sure your latest **MRO** engine is selected in the
    **Global Options** (in our case, MRO 4.0.2).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**RStudio**，确保你的最新**MRO**引擎在**全局选项**（在我们的案例中，MRO 4.0.2）中被选中。
- en: Enter the `install.packages("openxlsx")` command in the console. Remember that
    it installs the package at the version corresponding to the **CRAN** snapshot
    defined by your MRO installation.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中输入`install.packages("openxlsx")`命令。请记住，它会安装与你的MRO安装定义的**CRAN**快照对应的版本。
- en: Now you are ready to learn how to read and write data to Excel files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好学习如何读取和写入Excel文件中的数据了。
- en: Using the readxl and openxlsx packages
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用readxl和openxlsx包
- en: 'The `readxl` package provides two separate functions – `read_xls()`, to read
    Excel files in an XLS format, and `read_xlsx()`, to read those in an XLSX format.
    If you want to read the contents of the `example.xlsx` file located in the `Chapter07`
    folder, you can use the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`readxl`包提供了两个独立的函数——`read_xls()`，用于读取XLS格式的Excel文件，以及`read_xlsx()`，用于读取XLSX格式的文件。如果你想读取位于`Chapter07`文件夹中的`example.xlsx`文件的内容，你可以使用以下代码：'
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result will be a tibble:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个tibble：
- en: '![Figure 7.13 – Excel data read using the read_xlsx function](img/file187.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图7.13 – 使用read_xlsx函数读取的Excel数据](img/file187.png)'
- en: Figure 7.13 – Excel data read using the read_xlsx function
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 使用read_xlsx函数读取的Excel数据
- en: 'As you can see, the carriage returns and the line feed characters (`\r\n`)
    are kept. If you want to read data from a specific worksheet instead, you can
    use this code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，回车和换行字符（`\r\n`）被保留。如果你想从特定的工作表读取数据，你可以使用以下代码：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To write your data into Excel files, you can use the `write.xlsx()` function
    of the `openxlsx` package, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的数据写入到Excel文件中，你可以使用`openxlsx`包的`write.xlsx()`函数，如下所示：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Observe how, in this case, you have to use the “Unix convention” regarding the
    new lines, and that is to use only the `\n` character in the strings of your data
    to have the standard Windows characters `\r\n` in Excel.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 观察在这种情况下，你必须使用“Unix约定”来处理换行，即只使用字符串中的`\n`字符，以便在Excel中拥有标准的Windows字符`\r\n`。
- en: 'If you want to write the content of your dataset to a specific named worksheet
    in *a new Excel file*, then you can use the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将数据集的内容写入到一个新的Excel文件中的特定命名工作表中，你可以使用以下代码：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If, on the other hand, you need to add a worksheet to *an existing Excel file*,
    you have to use a named list of DataFrames/tibbles as the input of the `write.xlsx`
    function. This is the code to use if you can manually assign a string name to
    each sheet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，相反，你需要向一个现有的Excel文件中添加一个工作表，你必须使用命名列表的DataFrame/tibbles作为`write.xlsx`函数的输入。如果你可以手动为每个工作表分配一个字符串名称，以下是你可以使用的代码：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Keep in mind that if you need to use a list of DataFrames/tibbles (`df_lst`)
    and a list of worksheet names (`names_lst`) separately, you can use the following
    code to write all your data in one Excel workbook:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你需要分别使用DataFrame/tibbles的列表（`df_lst`）和工作表名称的列表（`names_lst`），你可以使用以下代码将所有数据写入一个Excel工作簿中：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's now look at an example of logging in Power BI using the previous R functions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看使用之前R函数在Power BI中登录的示例。
- en: Logging emails and dates to Excel in Power BI with R
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Power BI中使用R将电子邮件和日期记录到Excel中
- en: The example we will use is still the one from *Chapter 5*, *Using Regular Expressions
    in Power BI*, in which you needed to validate email addresses and ban dates. The
    ultimate goal will always be to export invalid emails and invalid dates to two
    separate worksheets in an Excel file and then share it with the team.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的示例仍然是来自*第五章*，*在Power BI中使用正则表达式*的示例，其中你需要验证电子邮件地址和禁止日期。最终目标始终是将无效的电子邮件和无效的日期导出到Excel文件中的两个单独的工作表中，然后与团队共享。
- en: 'Now open your Power BI Desktop, make sure your latest MRO is referenced in
    the options, and let''s get started:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的Power BI Desktop，确保你的最新MRO在选项中被引用，然后我们开始吧：
- en: From the ribbon, click on the **Excel** icon to import data from Excel.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从功能区点击**Excel**图标以从Excel导入数据。
- en: From the **Open** dialog box, select the `Users.xlsx` file you can find in the
    `Chapter05` folder.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**打开**对话框中，选择你可以在`Chapter05`文件夹中找到的`Users.xlsx`文件。
- en: From the **Navigator** window, select the **Users** sheet and then click on
    **Transform Data**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**导航器**窗口中，选择**用户**工作表，然后点击**转换数据**。
- en: Click on the **Transform** menu, and then click on **Run R Script**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**转换**菜单，然后点击**运行 R 脚本**。
- en: Copy the code you can find in the `02-validate-emails-dates-with-regex-in-power-bi.R`
    file in the `Chapter07/R` folder, and paste it into the R script editor. This
    code is just a merging of the scripts you already used to validate emails and
    dates separately. Then click **OK**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你可以在 `Chapter07/R` 文件夹中的 `02-validate-emails-dates-with-regex-in-power-bi.R`
    文件中找到的代码复制到 R 脚本编辑器中。这段代码只是将你之前用来分别验证电子邮件和日期的脚本合并在一起。然后点击**确定**。
- en: 'Select just the **Table** value related to the `df` table name and you will
    see something like this:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择与 `df` 表名相关的**表格**值，你将看到类似以下内容：
- en: '![Figure 7.14 – The transformed data contains both the flags for valid emails
    and dates](img/file188.png)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.14 – 转换后的数据包含有效电子邮件和日期的标志](img/file188.png)'
- en: Figure 7.14 – The transformed data contains both the flags for valid emails
    and dates
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.14 – 转换后的数据包含有效电子邮件和日期的标志
- en: Now you have both the `isEmailValidFromRegex` and `isDateValidFromRegex` flags
    that allow you to select correct emails and dates.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你有了 `isEmailValidFromRegex` 和 `isDateValidFromRegex` 标志，允许你选择正确的电子邮件和日期。
- en: Click again on **Run R Script**, enter the script you can find in the `03-log-wrong-emails-dates-excel-in-power-bi.R`
    file, and click **OK**. Remember to change the paths in the code.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**运行 R 脚本**，输入你可以在 `03-log-wrong-emails-dates-excel-in-power-bi.R` 文件中找到的脚本，然后点击**确定**。请记住在代码中更改路径。
- en: 'Select just the **Table** value related to the `df` table name and you will
    see a table where only rows containing valid emails and dates will be kept:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅选择与 `df` 表名相关的**表格**值，你将看到一个表格，其中只保留包含有效电子邮件和日期的行：
- en: '![Figure 7.15 – The output data contains rows containing valid emails and dates](img/file189.png)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.15 – 输出数据包含包含有效电子邮件和日期的行](img/file189.png)'
- en: Figure 7.15 – The output data contains rows containing valid emails and dates
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.15 – 输出数据包含包含有效电子邮件和日期的行
- en: 'Moreover, the `wrong-data.xlsx` file has been created in your `Chapter07/R`
    folder and it contains two worksheets: `Wrong emails` and `Wrong dates`.'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，`wrong-data.xlsx` 文件已创建在你的 `Chapter07/R` 文件夹中，它包含两个工作表：`错误的电子邮件`和`错误的日期`。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**主页**菜单，然后点击**关闭并应用**。
- en: Awesome! You just learned how to log information to an Excel file in multiple
    sheets from Power BI using R.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你刚刚学会了如何使用 R 从 Power BI 将信息记录到多个工作表的 Excel 文件中。
- en: In the next section, you will learn how to log information from Power BI to
    either an **on-premises** **SQL Server**, or to an **Azure** **SQL Server**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何将信息从 Power BI 记录到**本地** **SQL 服务器**或**Azure** **SQL 服务器**。
- en: Logging to an Azure SQL Server
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录到 Azure SQL 服务器
- en: In the vast majority of companies, business information is persisted in a **Relational
    Database Management System** (**RDBMS**). Microsoft's quintessential relational
    database is **SQL Server** in its on-premises version if the company adopts the
    Microsoft Data Platform. Otherwise it is **Azure SQL Server** which is a **Platform
    as a Service** (**PaaS**), cloud-hosted database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝大多数公司中，业务信息持久化在**关系数据库管理系统**（**RDBMS**）中。如果公司采用 Microsoft 数据平台，Microsoft 的典型关系数据库是其本地版本的
    **SQL Server**。否则，它是**Azure SQL Server**，这是一个**平台即服务**（**PaaS**）的云托管数据库。
- en: Generally, it is a good idea to centralize all of a company's key information
    in a single repository. That's why it might be useful to know how to log information
    from within a Power BI process into a SQL Server database or an Azure SQL database.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将一个公司的所有关键信息集中在一个单一存储库中是一个好主意。这就是为什么了解如何将信息从 Power BI 流程中记录到 SQL 服务器数据库或
    Azure SQL 数据库中可能很有用。
- en: If you have the option to already access an instance of SQL Server on-premises
    or an Azure SQL Server, you just need to make sure that the **ODBC Driver for
    SQL Server** is installed on your machine. In fact, both Python and R will connect
    to (Azure) SQL Server via an ODBC connection. You have the option to install the
    driver on your machine directly (via the link [http://bit.ly/ODBC-SQLServer](http://bit.ly/ODBC-SQLServer)),
    but more often this driver is installed indirectly when installing the ultimate
    client for managing any SQL infrastructure, which is **SQL Server Management Studio**
    (**SSMS**).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经可以访问本地或Azure SQL服务器上的SQL Server实例，您只需确保您的机器上已安装**SQL Server ODBC驱动程序**。实际上，Python和R将通过ODBC连接连接到(Azure)
    SQL Server。您可以选择直接在您的机器上安装驱动程序（通过链接[http://bit.ly/ODBC-SQLServer](http://bit.ly/ODBC-SQLServer)），但更常见的情况是在安装管理任何SQL基础设施的最终客户端时间接安装此驱动程序，即**SQL
    Server Management Studio**（**SSMS**）。
- en: 'On the other hand, if you don''t have access to either an on-premises SQL Server
    instance or an Azure SQL database, then you have two options for testing the examples
    in this section:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您无法访问本地SQL Server实例或Azure SQL数据库，那么您在本节中测试示例有两个选择：
- en: Install a free instance of **SQL Server Express Edition** (or **Developer**).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个免费的**SQL Server Express Edition**（或**开发者版**）实例。
- en: Create an Azure SQL database from the Azure portal using your account.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的账户从Azure门户创建一个Azure SQL数据库。
- en: Let's see in detail how to proceed for each of these options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看如何为这些选项中的每一个进行操作。
- en: Installing SQL Server Express
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装SQL Server Express
- en: 'In this section, we will show how to install the Express Edition of SQL Server.
    This is the free version of Microsoft''s database engine that can also be used
    in production for desktop and small server data-driven applications. Obviously,
    the Express Edition has limitations that distinguish it from the top-of-the-line
    **Enterprise Edition**. Here are a few examples:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何安装SQL Server的Express版。这是Microsoft数据库引擎的免费版本，也可以用于桌面和小型服务器数据驱动应用程序的生产。显然，Express版有一些限制，使其与高端**企业版**区分开来。以下是一些例子：
- en: A maximum memory of 1,410 MB is used by an instance of the database engine.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库引擎实例使用的最大内存为1,410 MB。
- en: A maximum size of 10 GB for a single database.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个数据库的最大大小为10 GB。
- en: Compute capacity used by a single instance limited to the lesser of one socket
    or four cores.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个实例使用的计算能力限制在单个插槽或四个核心中的较小者。
- en: Despite these limitations, SQL Server Express remains an excellent solution
    to use in production for small applications. If, on the other hand, you need to
    be able to test the more advanced features of the engine because you know that
    your application will use a more complete edition in production (Standard or Enterprise),
    you can install the **Developer Edition** on your machine. This edition allows
    you to test all the features of the Enterprise Edition while not paying for an
    Enterprise license. The most stringent limitation is, of course, that the Developer
    Edition cannot be used in production.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，SQL Server Express仍然是一个用于生产小型应用程序的优秀解决方案。另一方面，如果您需要能够测试引擎的更高级功能，因为您知道您的应用程序在生产中将使用更完整的版本（标准版或企业版），您可以在您的机器上安装**开发者版**。这个版本允许您在不支付企业版许可证的情况下测试企业版的所有功能。当然，最严格的限制是开发者版不能用于生产。
- en: 'That said, there are tons of tutorials about how to install the latest version
    of SQL Server Express available to date (2019). One of the many that we suggest
    you follow for installation is this one:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，目前有大量关于如何安装SQL Server Express最新版本（2019）的教程。我们建议您遵循以下教程进行安装：
- en: '[https://www.sqlshack.com/how-to-install-sql-server-express-edition](https://www.sqlshack.com/how-to-install-sql-server-express-edition)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlshack.com/how-to-install-sql-server-express-edition](https://www.sqlshack.com/how-to-install-sql-server-express-edition)'
- en: 'Just keep these observations in mind:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将这些观察结果记在心里：
- en: 'The **Feature Selection** screen suggests also installing the **SQL Server
    Replication**. If you would also like to test Machine Learning Services separately
    with R, Python and Full-Text available in SQL Server, we suggest selecting the
    following, leaving out the Replication and Java options:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**功能选择**屏幕还建议安装**SQL Server复制**。如果您还想单独测试R、Python和SQL Server中可用的全文搜索，我们建议选择以下选项，排除复制和Java选项：'
- en: '![Figure 7.16 – Suggested instance features](img/file190.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.16 – 建议的实例特征](img/file190.png)'
- en: Figure 7.16 – Suggested instance features
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.16 – 建议的实例特征
- en: The important thing is to keep the **Shared Features** selected by default so
    that the ODBC drivers needed to connect to the instance are also installed.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要保持**共享功能**默认选中，以便安装连接到实例所需的ODBC驱动程序。
- en: Remember to save the password for the `sa` (system administrator) user in a
    safe place, because it provides access to the instance you are installing as an
    administrator.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住将`sa`（系统管理员）用户的密码保存在安全的地方，因为它提供了作为管理员安装实例的访问权限。
- en: The tutorial will ask you to install SSMS in *Step 5*. If you haven't already
    installed it, do it now.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 教程会在**步骤5**中要求你安装SSMS。如果你还没有安装，现在就安装它。
- en: In order to connect to your SQL Server Express instance with SSMS, instead of
    the computer name and then the instance name, you can also use `.\SQLExpress`
    as the **Server name**. That said, the tutorial suggests testing your connection
    using the **SQL Server Authentication** with the **sa** account credentials. Remember
    that you can also connect to your instance directly using the **Windows authentication**,
    as your user is automatically added to the **SQL Server Administrators** group.
    As the tutorial says, if the login window closes without any issues after clicking
    **Connect**, this means the connection works properly.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用SSMS连接到你的SQL Server Express实例，而不是计算机名和实例名，你也可以使用`.\SQLExpress`作为**服务器名**。话虽如此，教程建议使用**SQL
    Server身份验证**和**sa**账户凭证测试你的连接。记住，你也可以直接使用**Windows身份验证**连接到你的实例，因为你的用户会被自动添加到**SQL
    Server管理员**组。正如教程所说，如果在点击**连接**后登录窗口没有任何问题地关闭，这意味着连接工作正常。
- en: 'Just stop at the *For the Windows authentication* section. The following applies:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 只需停在**Windows身份验证**部分。以下适用：
- en: '**Important Note**'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is important that the connection to the new `SQLExpress` instance works properly
    from SSMS. This confirms the correct installation of the instance.
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保从SSMS到新的`SQLExpress`实例的连接工作正常非常重要。这确认了实例安装正确。
- en: 'After the installation is complete, you can verify that the ODBC drivers have
    been installed by following these steps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过以下步骤验证ODBC驱动程序是否已安装：
- en: 'Click the Windows **Start** button, and start entering the string `ODBC`. You
    will see something like this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Windows**开始**按钮，并开始输入字符串`ODBC`。你会看到类似以下的内容：
- en: '![Figure 7.17 – The Windows ODBC Data Sources configuration tools](img/file191.png)'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.17 – Windows ODBC数据源配置工具](img/file191.png)'
- en: Figure 7.17 – The Windows ODBC Data Sources configuration tools
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17 – Windows ODBC数据源配置工具
- en: 'Click on the 32-bit app or the 64-bit app, and then click on the **Drivers**
    tab. You’ll see the **ODBC Driver 17 for SQL Server** installed:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击32位应用程序或64位应用程序，然后点击**驱动程序**选项卡。你会看到已安装的**ODBC Driver 17 for SQL Server**：
- en: '![Figure 7.18 – The ODBC Driver 17 for SQL Server correctly installed](img/file192.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图7.18 – 正确安装的ODBC Driver 17 for SQL Server](img/file192.png)'
- en: Figure 7.18 – The ODBC Driver 17 for SQL Server correctly installed
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – 正确安装的ODBC Driver 17 for SQL Server
- en: Fantastic! Now your `SQLExpress` instance is working properly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你的`SQLExpress`实例工作正常。
- en: Let's also see how to configure an Azure SQL database through the Azure portal.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过Azure门户配置Azure SQL数据库。
- en: Creating an Azure SQL database
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Azure SQL数据库
- en: 'In order to create an Azure SQL database, you must be subscribed to Azure services.
    This gives you the ability to access the **Azure portal** ([https://portal.azure.com/](https://portal.azure.com/))
    to manage all of your tenant''s Azure resources. Once you have accessed the portal,
    follow these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建Azure SQL数据库，你必须订阅Azure服务。这让你能够访问**Azure门户**([https://portal.azure.com/](https://portal.azure.com/))来管理你租户的所有Azure资源。一旦你访问了门户，请按照以下步骤操作：
- en: 'Search for `SQL databases` in the main search box and click on it:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主搜索框中搜索`SQL数据库`并点击它：
- en: '![Figure 7.19 – Selecting SQL databases in the Azure portal](img/file193.png)'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.19 – 在Azure门户中选择SQL数据库](img/file193.png)'
- en: Figure 7.19 – Selecting SQL databases in the Azure portal
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.19 – 在Azure门户中选择SQL数据库
- en: 'Click on **Create SQL database** in the middle of the page:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面中间的**创建SQL数据库**：
- en: '![Figure 7.20 – Clicking on Create SQL database](img/file194.png)'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.20 – 点击创建SQL数据库](img/file194.png)'
- en: Figure 7.20 – Clicking on Create SQL database
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.20 – 点击创建SQL数据库
- en: You need to select a **Subscription** associated with your account (usually,
    the selected default one is ok if you have just one subscription associated) and
    then a **Resource group** to collect all the resources you want to create under
    a name (like a virtual folder). Select one if you have already created it, or
    create a new one if needed.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要选择与你的账户关联的**订阅**（通常，如果你只有一个订阅，则选中的默认订阅即可）。然后选择一个**资源组**来收集你想要创建的所有资源（例如，一个虚拟文件夹）。如果你已经创建了一个，就选择它；如果需要，就创建一个新的。
- en: 'You must also provide the **Database name** and **Server**. As the database
    name, use `SystemsLogging`. If this is your first time creating an Azure SQL database,
    you need to create a new server too. So, click on **Create new** and provide a
    server name, a login, the related password, and the location you prefer. After
    clicking **OK**, you’ll see something like this:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还必须提供**数据库名称**和**服务器**。作为数据库名称，使用`SystemsLogging`。如果你是第一次创建Azure SQL数据库，你还需要创建一个新的服务器。因此，点击**创建新服务器**并提供一个服务器名称、登录名、相关的密码以及你偏好的位置。点击**确定**后，你会看到类似以下的内容：
- en: '![Figure 7.21 – Entering the database name and the new server](img/file195.png)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.21 – 输入数据库名称和新服务器](img/file195.png)'
- en: Figure 7.21 – Entering the database name and the new server
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.21 – 输入数据库名称和新服务器
- en: 'As we’re creating an Azure SQL database for testing purposes, we can choose
    a **Standard** **Database Transaction Unit** (**DTU**) workload. So, click on
    **Configure database** under **Compute + storage**:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个用于测试目的的Azure SQL数据库，我们可以选择一个**标准**数据库事务单元（**DTU**）工作负载。因此，点击**计算+存储**下的**配置数据库**：
- en: '![Figure 7.22 – Configuring the compute](img/file196.png)'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.22 – 配置计算](img/file196.png)'
- en: Figure 7.22 – Configuring the compute
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.22 – 配置计算
- en: The **General Purpose** option is selected by default. So, click on the **Looking
    for basic, standard, premium?** link on the top-left and then click on the **Standard**
    workload option. Then, click on the **Apply** button.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认选择**通用用途**选项。因此，点击左上角的**寻找基本、标准、高级？**链接，然后点击**标准**工作负载选项。然后，点击**应用**按钮。
- en: 'Select also to install sample data (from the demo **AdventureWorkLT** database)
    in the **Additional settings** tab by clicking on **Sample**:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**附加设置**选项卡中，通过点击**示例**来选择安装示例数据（来自演示**AdventureWorkLT**数据库）：
- en: '![Figure 7.2 – Choosing to install a sample database](img/file197.png)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.2 – 选择安装示例数据库](img/file197.png)'
- en: Figure 7.2 – Choosing to install a sample database
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.2 – 选择安装示例数据库
- en: Click on **Review + create**, and then on **Create** to deploy your brand-new
    Azure SQL database.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**审查+创建**，然后点击**创建**以部署你全新的Azure SQL数据库。
- en: 'After the deployment is complete, click on **Go to resource** to access the
    general dashboard of the newly created resource. In the top-right corner, you
    will notice that the server’s name takes the following form:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署完成后，点击**转到资源**以访问新创建资源的通用仪表板。在右上角，你会注意到服务器的名称采用以下形式：
- en: '[PRE21]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In order to access your Azure SQL database from any client, you must declare
    the client''s IP address in the server firewall rules. To do this, click on **Set
    server firewall** at the top of the dashboard:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从任何客户端访问你的Azure SQL数据库，你必须声明客户端的IP地址在服务器防火墙规则中。为此，点击仪表板顶部的**设置服务器防火墙**：
- en: '![Figure 7.24 – Setting rules on the Azure SQL server firewall](img/file198.png)'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.24 – 在Azure SQL服务器防火墙上设置规则](img/file198.png)'
- en: Figure 7.24 – Setting rules on the Azure SQL server firewall
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.24 – 在Azure SQL服务器防火墙上设置规则
- en: 'In addition to other options, you''ll see textboxes to enter the **Rule name**,
    the **Start IP**, and the **End IP**. Additionally, the portal also shows you
    the IP address from which you are currently connected:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了其他选项外，你还会看到用于输入**规则名称**、**起始IP**和**结束IP**的文本框。此外，门户还会显示你当前连接的IP地址：
- en: '![Figure 7.25 – Copying your current IP address and using it in your rule](img/file199.png)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.25 – 复制当前IP地址并在规则中使用它](img/file199.png)'
- en: Figure 7.25 – Copying your current IP address and using it in your rule
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.25 – 复制当前IP地址并在规则中使用它
- en: You can then enter your Client IP address as the Start and End IP if you will
    be connecting to the Azure SQL database from that same machine. Keep in mind that
    if your machine's public IP address is not static, it will assume a new IP address
    on its next reboot that is different from the previous one. Therefore, if you
    need to connect to your Azure SQL database from your machine often, make sure
    to create a **static public IP address**. If you have just created a new Azure
    Virtual Machine, Azure will ask you if you want to make its current public IP
    address static when you stop it for the first time. If you decide yes, Azure will
    do everything automatically. Otherwise, you can easily configure it later by following
    this tutorial:[http://bit.ly/AzureVM-assign-static-ip](http://bit.ly/AzureVM-assign-static-ip)Click
    **Save** to keep your changes in the firewall settings.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您将从同一台机器连接到 Azure SQL 数据库，可以将您的客户端 IP 地址作为起始和结束 IP 地址输入。请注意，如果您的机器的公共 IP 地址不是静态的，它将在下一次重启时假设一个新的
    IP 地址，与之前的地址不同。因此，如果您需要经常从您的机器连接到 Azure SQL 数据库，请确保创建一个 **静态公共 IP 地址**。如果您刚刚创建了一个新的
    Azure 虚拟机，Azure 将在您第一次停止它时询问您是否想要将其当前公共 IP 地址设置为静态。如果您选择是，Azure 将自动完成所有操作。否则，您可以通过遵循以下教程轻松地在以后配置它：[http://bit.ly/AzureVM-assign-static-ip](http://bit.ly/AzureVM-assign-static-ip)
    点击 **保存** 以保留防火墙设置中的更改。
- en: 'At this point, you can test the connection to your new Azure SQL database using
    SSMS. If you haven''t installed it yet, do so now by downloading the installer
    from the link [http://aka.ms/ssms](http://aka.ms/ssms). Once installed, open the
    **Microsoft SQL Server Management Studio** app from the **Start** menu (you can
    find it under the **Microsoft SQL Server Tools XX** folder). Use the server name
    in the `<your-server-name>.database.windows.net` format, choose **SQL Server Authentication**
    as the authentication method, and then enter the login and password you used during
    the creation of your Azure SQL database. Then click **Connect**:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这一步，您可以使用 SSMS 测试到您新 Azure SQL 数据库的连接。如果您还没有安装它，请现在通过从链接 [http://aka.ms/ssms](http://aka.ms/ssms)
    下载安装程序进行安装。安装完成后，从 **开始** 菜单打开 **Microsoft SQL Server Management Studio** 应用程序（您可以在
    **Microsoft SQL Server 工具 XX** 文件夹下找到它）。使用 `<your-server-name>.database.windows.net`
    格式的服务器名称，选择 **SQL Server 身份验证** 作为身份验证方法，然后输入您在创建 Azure SQL 数据库时使用的登录名和密码。然后点击
    **连接**：
- en: '![Figure 7.26 – Connecting to your Azure SQL database with SSMS](img/file200.png)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.26 – 使用 SSMS 连接到您的 Azure SQL 数据库](img/file200.png)'
- en: Figure 7.26 – Connecting to your Azure SQL database with SSMS
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.26 – 使用 SSMS 连接到您的 Azure SQL 数据库
- en: 'If the **Connect to Server** window disappears, then you are connected to your
    server. In fact, if you open the **Databases** node in the **Object Explorer**
    on the left, you can see your `SystemsLogging` database containing the `AdventureWorkLT`
    tables:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **连接到服务器** 窗口消失了，那么您已经连接到您的服务器。实际上，如果您在左侧的 **对象资源管理器** 中打开 **数据库** 节点，您可以看到包含
    `AdventureWorkLT` 表的 `SystemsLogging` 数据库：
- en: '![Figure 7.27 – You are connected to your Azure SQL database](img/file201.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.27 – 您已连接到您的 Azure SQL 数据库](img/file201.png)'
- en: Figure 7.27 – You are connected to your Azure SQL database
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27 – 您已连接到您的 Azure SQL 数据库
- en: Awesome! Your Azure SQL database is running and ready to be used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您的 Azure SQL 数据库正在运行，并准备好使用。
- en: Let’s try now to read and write data into a SQL Server or an Azure SQL database
    using Python.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试使用 Python 读取和写入 SQL Server 或 Azure SQL 数据库中的数据。
- en: Logging to an Azure SQL server with Python
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 记录到 Azure SQL 服务器
- en: 'The most widely used Python module for connecting to databases to which you
    can connect via ODBC drivers is **pyodbc**. So, first you need to install this
    package in the `pbi_powerquery_env` environment:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**pyodbc** 是最广泛使用的 Python 模块，用于连接通过 ODBC 驱动程序可以连接的数据库。因此，首先您需要在 `pbi_powerquery_env`
    环境中安装此包：'
- en: Open your Anaconda Prompt.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Anaconda Prompt。
- en: 'Switch to the `pbi_powerquery_env` environment by entering this command:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令切换到 `pbi_powerquery_env` 环境：
- en: '[PRE22]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Install the new package by entering this command:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令安装新包：
- en: '[PRE23]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, you can start interacting with your database instances using
    Python.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，您可以使用 Python 与您的数据库实例进行交互。
- en: Using the pyodbc module
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 pyodbc 模块
- en: First, you need to *create a connection* to your database instance. You can
    do this with the `connect()` function, which accepts a *connection string* as
    an argument. Depending on whether you need to connect to an instance of a SQL
    server on-premises or an Azure SQL database, the connection string varies only
    in its server parameter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要*创建一个连接*到你的数据库实例。你可以通过`connect()`函数来完成，该函数接受一个*连接字符串*作为参数。根据你是否需要连接到本地SQL服务器实例或Azure
    SQL数据库，连接字符串仅在服务器参数上有所不同。
- en: 'You can establish a connection to your on-premises instance using the Windows
    authentication with this code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码使用Windows认证建立与本地实例的连接：
- en: '[PRE24]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can also find the code snippets used here in the `11-read-write-on-azure-sql-server-with-python.py`
    file in the `Chapter07\Python` folder. In contrast to the other Python script
    you found in the repository, in this one you can find comments like `# %%`. They
    are placeholders that VS Code recognizes as **Jupyter-like code cells**. When
    VS Code identifies a cell, it automatically adds commands to execute its contents
    in the Interactive Window, making it easier for the user to interact with the
    code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`Chapter07\Python`文件夹中的`11-read-write-on-azure-sql-server-with-python.py`文件中找到这里使用的代码片段。与存储库中找到的其他Python脚本不同，在这个脚本中你可以找到像`#
    %%`这样的注释。它们是VS Code识别为**Jupyter-like代码单元**的占位符。当VS Code识别到一个单元时，它会自动添加命令以在交互窗口中执行其内容，这使得用户与代码的交互更加容易。
- en: 'If you want to connect to the same instance using the SQL authentication instead,
    you can use this code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用SQL认证而不是Windows认证来连接到相同的实例，你可以使用以下代码：
- en: '[PRE25]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The format of the previous connection strings remains the same even when you
    want to connect to an Azure SQL database. You must use the format `<your-server-name>.database.windows.net`
    as the server name. The authentication mode must necessarily be the SQL authentication
    mode. Therefore, the code to connect to your Azure SQL database is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你想连接到Azure SQL数据库，之前的连接字符串格式仍然保持不变。你必须使用 `<your-server-name>.database.windows.net`
    作为服务器名称。认证模式必须是SQL认证模式。因此，连接到你的Azure SQL数据库的代码如下：
- en: '[PRE26]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once you have established a connection to an instance of your choice, you can
    read data from tables or views via the pandas `read_sql()` function, which accepts
    a query in SQL (in our case, in **T-SQL** for SQL Server) as a parameter. For
    example, regardless of whether you are connected to your on-premises instance
    or on Azure, you can run the following code to read the database information available
    in the instance:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你连接到了你选择的实例，你可以通过pandas的`read_sql()`函数从表或视图中读取数据，该函数接受一个SQL查询（在我们的案例中，是SQL
    Server的**T-SQL**）作为参数。例如，无论你连接到的是本地实例还是Azure，你都可以运行以下代码来读取实例中可用的数据库信息：
- en: '[PRE27]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the case of Azure SQL, you will see this result:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure SQL的情况下，你会看到以下结果：
- en: '![Figure 7.28 – Result of a query in Azure SQL database](img/file202.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图7.28 – Azure SQL数据库中的查询结果](img/file202.png)'
- en: Figure 7.28 – Result of a query in Azure SQL database
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 – Azure SQL数据库中的查询结果
- en: 'Let''s try writing something to a database instead. First, in the case of your
    on-premises instance, you need to create a new database to write your data to.
    You can do that in SSMS following these steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将一些内容写入数据库。首先，在你的本地实例的情况下，你需要创建一个新的数据库来写入你的数据。你可以在SSMS中按照以下步骤完成：
- en: 'Click on **Connect**, and then on **Database Engine…**:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**连接**，然后点击**数据库引擎…**：
- en: '![Figure 7.29 – Connecting to a database engine in SSMS](img/file203.png)'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.29 – 在SSMS中连接到数据库引擎](img/file203.png)'
- en: Figure 7.29 – Connecting to a database engine in SSMS
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.29 – 在SSMS中连接到数据库引擎
- en: 'Connect to your `SQLExpress` instance using the Windows authentication with
    the string `.\SQLExpress` as the server name. Then, click on **Connect**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Windows认证，并以字符串`.\SQLExpress`作为服务器名称连接到你的`SQLExpress`实例。然后，点击**连接**：
- en: '![Figure 7.30 – Connecting to your SQLExpress instance](img/file204.png)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.30 – 连接到你的SQLExpress实例](img/file204.png)'
- en: Figure 7.30 – Connecting to your SQLExpress instance
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.30 – 连接到你的SQLExpress实例
- en: 'Click on **New Query** on the toolbar at the top:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏顶部的**新建查询**：
- en: '![Figure 7.31– Opening a new query editor](img/file205.png)'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.31– 打开新的查询编辑器](img/file205.png)'
- en: Figure 7.31– Opening a new query editor
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.31– 打开新的查询编辑器
- en: Enter the `CREATE DATABASE SystemsLogging` script and then click on the **Execute**
    button with the green arrow (or just press **F5**).
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `CREATE DATABASE SystemsLogging` 脚本，然后点击带有绿色箭头的**执行**按钮（或者直接按**F5**键）。
- en: 'Open the **Databases** node in the **Object Explorer** and you can now see
    the brand-new `SystemsLogging` database:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象资源管理器**中打开**数据库**节点，你现在可以看到全新的`SystemsLogging`数据库：
- en: '![Figure 7.32 – The new SystemsLogging database in your SQLExpress instance](img/file206.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图7.32 – 你的SQLExpress实例中的新SystemsLogging数据库](img/file206.png)'
- en: Figure 7.32 – The new SystemsLogging database in your SQLExpress instance
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.32 – 你的SQLExpress实例中的新SystemsLogging数据库
- en: 'Now you can create the new `WrongEmails` table in the `SystemsLogging` database.
    It is usually preferable to run **Data Definition Language** (**DDL**) commands
    (like `CREATE`) directly in SSMS. In this case, we''ll do it through Python to
    show you some special commands. You will first create a `cursor` object from the
    `conn` connection and then call its `execute()` method, passing it a `CREATE TABLE`
    query:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建`SystemsLogging`数据库中的新`WrongEmails`表。通常，直接在SSMS中运行**数据定义语言**（**DDL**）（如`CREATE`）命令（如`CREATE`）更可取。在这种情况下，我们将通过Python来展示一些特殊的命令。你首先从`conn`连接创建一个`cursor`对象，然后调用它的`execute()`方法，传递给它一个`CREATE
    TABLE`查询：
- en: '[PRE28]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Keep in mind that an Azure SQL Server database collects its objects (tables,
    views, and so on) in **SQL schemas**. Usually, when you create a database object,
    you also specify the schema in the `CREATE` statement. For a table, you generally
    use the `CREATE TABLE <your-schema>.<table-name>` script. The `WrongEmails` table
    was created without specifying any schema. Therefore, it assumes the default schema,
    which is `dbo`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Azure SQL Server数据库将其对象（表、视图等）收集在**SQL模式**中。通常，当你创建数据库对象时，你也会在`CREATE`语句中指定模式。对于一个表，你通常使用`CREATE
    TABLE <your-schema>.<table-name>`脚本。`WrongEmails`表是在没有指定任何模式的情况下创建的。因此，它假定默认模式，即`dbo`。
- en: 'Make sure to create the same table in your Azure SQL database:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你的Azure SQL数据库中创建相同的表：
- en: '[PRE29]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At this point, you can *write pandas DataFrame content* in the `WrongEmails`
    table row by row, using the `cursor.execute()` method, passing to it an `INSERT
    INTO` query. We will use the Azure SQL database in the example since there is
    also the `SalesLT.Customer` table there (note the `SalesLT` schema) from which
    to read some customer data to write to the `WrongEmails` table:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以使用`cursor.execute()`方法，逐行在`WrongEmails`表内写入*pandas DataFrame内容*，传递给它一个`INSERT
    INTO`查询。在示例中，我们将使用Azure SQL数据库，因为那里也有`SalesLT.Customer`表（注意`SalesLT`模式），我们可以从中读取一些客户数据写入到`WrongEmails`表：
- en: '[PRE30]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `iterrows()` function iterates over the DataFrame columns, and it will return
    a tuple with the column name and content in the form of series. Keep in mind that
    if you want to write to a SQL server on-premises, you only need to change the
    connection string, and the syntax you just saw remains valid. You can't run the
    code exactly as it is written in your `SQLExpress` instance simply because there
    is no `AdventureWorksLT` example data there, so it will give you an error.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterrows()`函数遍历DataFrame的列，并返回一个包含列名和以series形式的内容的元组。请记住，如果你想要写入到本地SQL服务器，你只需要更改连接字符串，而你刚才看到的语法仍然有效。你无法直接在你的`SQLExpress`实例中运行代码，因为那里没有`AdventureWorksLT`示例数据，所以它会给你一个错误。'
- en: 'To display the first rows of the `WrongEmails` table, you can use this code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示`WrongEmails`表的前几行，你可以使用以下代码：
- en: '[PRE31]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will see something like this in VS Code:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你在VS Code中会看到类似的内容：
- en: '![Figure 7.33 – The content of the WrongEmails table](img/file207.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图7.33 – WrongEmails表的内容](img/file207.png)'
- en: Figure 7.33 – The content of the WrongEmails table
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.33 – WrongEmails表的内容
- en: 'Now, make sure to empty the `WrongEmails` table with the following command
    so that it can be ready to be used later:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保使用以下命令清空`WrongEmails`表，以便它可以准备用于后续使用：
- en: '[PRE32]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When you have finished all read and write operations on the database instance,
    remember to close the connection as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在数据库实例上完成所有读写操作后，记得按照以下方式关闭连接：
- en: '[PRE33]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Hey! You just learned how to read and write data from a SQL Server or Azure
    SQL database via Python. Simple, isn't it? Let's apply what you've learned in
    Power BI.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！你刚刚学会了如何通过Python从SQL Server或Azure SQL数据库读取和写入数据。简单，不是吗？让我们将你学到的知识应用到Power
    BI中。
- en: Logging emails and dates to an Azure SQL database in Power BI with Python
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Python在Power BI中将电子邮件和日期记录到Azure SQL数据库
- en: In this section, we will use the same scenario provided in *Chapter 5*, *Using
    Regular Expressions in Power BI*, in which you validated email addresses and ban
    dates. The goal is to log the rows of the dataset containing incorrect emails
    to an Azure SQL database and to filter them out of the dataset so that only valid
    emails remain in Power BI. In order to properly execute the following Python code,
    you need to make sure you have created both the Azure SQL `SystemsLogging` database
    and the `WrongEmails` table as discussed in the previous section. If you prefer,
    you can also use your on-premises SQL Server instance by appropriately changing
    the server name in the connection string. In this case, make sure that the `SystemsLogging`
    database and the `WrongEmails` table are there.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 *第 5 章* 中提供的相同场景，即 *在 Power BI 中使用正则表达式*，其中您验证了电子邮件地址和禁用日期。目标是记录包含不正确电子邮件的数据集的行到
    Azure SQL 数据库，并从数据集中过滤它们，以便在 Power BI 中只保留有效的电子邮件。为了正确执行以下 Python 代码，您需要确保您已创建了前面部分讨论的
    Azure SQL `SystemsLogging` 数据库和 `WrongEmails` 表。如果您愿意，您也可以使用您本地的 SQL Server 实例，只需在连接字符串中适当更改服务器名称。在这种情况下，请确保
    `SystemsLogging` 数据库和 `WrongEmails` 表存在。
- en: 'The necessary steps are as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的步骤如下：
- en: Follow all the steps in the *Using regex in Power BI to validate emails with
    Python* section of *Chapter 5*, *Using Regular Expressions in Power BI*, to the
    end, but do not click on **Close & Apply**.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 5 章 *在 Power BI 中使用正则表达式* 的 *使用 regex 在 Power BI 中验证电子邮件的 Python 部分* 中的所有步骤进行操作，但不要点击
    **关闭并应用**。
- en: Then click on **Run Python Script**, enter the script you can find in the `Python\12-log-wrong-emails-azure-sql-in-power-bi.py`
    file, and click **OK**.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击 **运行 Python 脚本**，输入您可以在 `Python\12-log-wrong-emails-azure-sql-in-power-bi.py`
    文件中找到的脚本，然后点击 **确定**。
- en: Click on the `df` dataset’s **Table** value.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `df` 数据集的 **表** 值。
- en: 'Only rows containing valid emails will be kept:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只会保留包含有效电子邮件的行：
- en: '![Figure 7.34 – A table containing only valid emails](img/file208.png)'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.34 – 仅包含有效电子邮件的表](img/file208.png)'
- en: Figure 7.34 – A table containing only valid emails
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.34 – 仅包含有效电子邮件的表
- en: Moreover, the invalid emails have been written into the `WrongEmails` table
    of your `SystemsLogging` Azure SQL database.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，无效的电子邮件已经写入您的 `SystemsLogging` Azure SQL 数据库的 `WrongEmails` 表中。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **主页** 菜单，然后点击 **关闭并应用**。
- en: 'To verify that invalid emails were indeed written to the previous table, you
    can do this with SSMS:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证无效的电子邮件确实已写入前面的表，您可以使用 SSMS 进行以下操作：
- en: Connect with SSMS to your Azure SQL database using the `<your-server-name>.database.windows.net`
    string as **Server name** and the SQL authentication.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `<your-server-name>.database.windows.net` 字符串作为 **服务器名称** 和 SQL 身份验证连接到 SSMS
    的 Azure SQL 数据库。
- en: 'Open the **Databases** node, then open the **Tables** node, right-click on
    the **dbo.WrongEmails** table, and click on **Select Top 1000 Rows**:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **数据库** 节点，然后打开 **表** 节点，右键单击 **dbo.WrongEmails** 表，然后点击 **选择前 1000 行**：
- en: '![Figure 7.35 – Querying the WrongEmails table in SSMS](img/file209.png)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.35 – 在 SSMS 中查询 WrongEmails 表](img/file209.png)'
- en: Figure 7.35 – Querying the WrongEmails table in SSMS
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.35 – 在 SSMS 中查询 WrongEmails 表
- en: 'You’ll see the following output:'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![Figure 7.36 – The content of the WrongEmails table in SSMS](img/file210.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.36 – SSMS 中 WrongEmails 表的内容](img/file210.png)'
- en: Figure 7.36 – The content of the WrongEmails table in SSMS
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.36 – SSMS 中 WrongEmails 表的内容
- en: Now, third-party systems can simply access your Azure SQL database (even simply
    with Excel, see the *References* section) to read invalid emails and mobilize
    the appropriate team to correct them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第三方系统可以简单地访问您的 Azure SQL 数据库（甚至可以使用 Excel，参见 *参考文献* 部分）来读取无效的电子邮件并动员适当的团队进行纠正。
- en: Well done! You just learned how to log information to an Azure SQL database
    from Power BI using Python (you can do the same writing into an on-premises SQL
    Server database just by changing the connection string). Now, let's see how you
    can do the same using R.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您刚刚学会了如何使用 Python 从 Power BI 将信息记录到 Azure SQL 数据库（您只需更改连接字符串即可将相同的内容写入本地
    SQL Server 数据库）。现在，让我们看看如何使用 R 来完成同样的操作。
- en: Logging to an Azure SQL server with R
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 R 记录到 Azure SQL 服务器
- en: 'To connect to a database via ODBC drivers in R, we will use two packages: `DBI`
    and `odbc`. The `DBI` package has the task of separating the connectivity to the
    database into a *frontend* and a *backend*. The R code you’ll write will use only
    the exposed frontend API. The backend will take care of communicating with the
    specific DBMS through special drivers provided by the installation of other packages.
    In our case, the `odbc` package will allow us to interface with SQL Server instances,
    both on-premises and on Azure. So, first you need to install these packages in
    your most recent MRO engine:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 R 中的 ODBC 驱动程序连接到数据库，我们将使用两个包：`DBI` 和 `odbc`。`DBI` 包的任务是将数据库连接分为一个 *前端*
    和一个 *后端*。您将要编写的 R 代码将仅使用公开的前端 API。后端将通过其他包安装提供的特殊驱动程序与特定的 DBMS 进行通信。在我们的例子中，`odbc`
    包将使我们能够与 SQL Server 实例进行接口，无论是在本地还是在 Azure 上。因此，首先您需要在这些最新的 MRO 引擎中安装这些包：
- en: Open RStudio, and make sure it is referencing your latest MRO in the **Global
    Options**.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 RStudio，并确保它在 **全局选项** 中引用您最新的 MRO。
- en: 'Enter this command into the console:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此命令输入到控制台：
- en: '[PRE34]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, you can start interacting with your database instances using
    R.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以使用 R 与您的数据库实例进行交互。
- en: Using the DBI and odbc packages
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 DBI 和 odbc 包
- en: Also, in this case, you need to *create a connection* to your database instance.
    You can do this with the `dbConnect()` function of the DBI package, which accepts
    a *driver object* (in our case the `odbc()` one from the `odbc` package) and a
    *connection string* as arguments.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，您需要 *创建一个连接* 到您的数据库实例。您可以使用 DBI 包的 `dbConnect()` 函数来完成此操作，该函数接受一个
    *驱动对象*（在我们的例子中是来自 `odbc` 包的 `odbc()`）和一个 *连接字符串* 作为参数。
- en: 'You can establish a connection to your `SQLExpress` on-premises instance using
    the Windows authentication with this code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码使用 Windows 认证建立与本地 `SQLExpress` 实例的连接：
- en: '`R\04-read-write-on-azure-sql-server-with-r.R`'
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`R\04-read-write-on-azure-sql-server-with-r.R`'
- en: '[PRE35]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to connect to the same instance using the SQL authentication instead,
    you can use this code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用 SQL 认证而不是使用相同的实例，可以使用以下代码：
- en: '[PRE36]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The format of the previous connection strings remains the same even when you
    want to connect to an Azure SQL database. You just need to use the `<your-server-name>.database.windows.net`
    format as the server name. In this case, the authentication mode must necessarily
    be the SQL authentication one. Therefore, the code to connect to your Azure SQL
    database is as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您想要连接到 Azure SQL 数据库，之前的连接字符串格式仍然保持不变。您只需使用 `<your-server-name>.database.windows.net`
    格式作为服务器名称。在这种情况下，认证模式必须是 SQL 认证。因此，连接到您的 Azure SQL 数据库的代码如下：
- en: '[PRE37]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An interesting thing is that, as soon as the connection is established, RStudio
    allows you to browse the databases inside your server through the **Connections**
    tab at the top right. For example, *Figure 7.37* displays the contents of the
    `SystemLogging` database of the `SQLExpress` instance, going down to the detail
    of individual columns in a table:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事情是，一旦建立了连接，RStudio 允许您通过右上角的 **连接** 选项卡浏览服务器内的数据库。例如，*图 7.37* 显示了 `SQLExpress`
    实例的 `SystemLogging` 数据库的内容，包括表中的各个列的详细信息：
- en: '![Figure 7.37 – RStudio’s object explorer of the connection established](img/file211.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.37 – RStudio 的连接对象浏览器](img/file211.png)'
- en: Figure 7.37 – RStudio’s object explorer of the connection established
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.37 – RStudio 的连接对象浏览器
- en: Remember that the `WrongEmails` table was created in the previous section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`WrongEmails` 表是在前面的部分创建的。
- en: 'Once you have established a connection to an instance of your choice, you can
    easily read data from tables or views via the `DBI`’s `dbGetQuery()` function,
    which accepts a SQL query (in our case, T-SQL for SQL Server) as a parameter.
    For example, in the same way as with Python, you can run the following code to
    read the database information available on both on-premises instances and Azure
    SQL servers:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已连接到所选实例，您就可以轻松地通过 `DBI` 的 `dbGetQuery()` 函数从表或视图中读取数据，该函数接受一个 SQL 查询（在我们的例子中是
    SQL Server 的 T-SQL）作为参数。例如，与 Python 一样，您可以运行以下代码来读取本地实例和 Azure SQL 服务器上可用的数据库信息：
- en: '[PRE38]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the case of Azure SQL, you will see this result:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure SQL 的情况下，您将看到以下结果：
- en: '![Figure 7.38 – Result of a query on Azure SQL database](img/file212.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.38 – Azure SQL 数据库查询的结果](img/file212.png)'
- en: Figure 7.38 – Result of a query on Azure SQL database
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.38 – Azure SQL 数据库查询的结果
- en: 'Let''s try writing something to a database instead. For example, you can *write
    a R DataFrame content* into the `WrongEmails` table using the `dbAppendTable()`
    method. It simply accepts the connection object, the name of the target table,
    and the DataFrame containing the source data. You just need to be careful to properly
    rename the source data columns using aliases in the SQL query (using the `AS`
    keyword) when reading from the database, so that the names match those of the
    target table columns. We will use an Azure SQL database in the example since there
    is also the `SalesLT.Customer` table from which to take the source data:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将一些内容写入数据库。例如，你可以使用 `dbAppendTable()` 方法将 R DataFrame 内容写入 `WrongEmails`
    表。它简单地接受连接对象、目标表名称以及包含源数据的 DataFrame。你只需在从数据库读取时，使用别名在 SQL 查询中（使用 `AS` 关键字）正确重命名源数据列，以确保名称与目标表列匹配。我们将使用
    Azure SQL 数据库作为示例，因为还有一个 `SalesLT.Customer` 表，可以从其中获取源数据：
- en: '[PRE39]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Keep in mind that if you need to create the target table and fill it, you can
    use the one-shot `dbCreateTable()` method that get the same parameters of the
    `dbAppendTable()` method. To display the first rows of the `WrongEmails` table,
    you can use this code:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你需要创建目标表并填充它，可以使用一次性的 `dbCreateTable()` 方法，该方法获取与 `dbAppendTable()` 方法相同的参数。要显示
    `WrongEmails` 表的前几行，你可以使用以下代码：
- en: '[PRE40]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You will see something like this in VS Code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 VS Code 中会看到类似的内容：
- en: '![Figure 7.39 – The content of the WrongEmails table](img/file213.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.39 – WrongEmails 表的内容](img/file213.png)'
- en: Figure 7.39 – The content of the WrongEmails table
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.39 – WrongEmails 表的内容
- en: 'Now make sure to empty the `WrongEmails` table with the `TRUNCATE TABLE` SQL
    command inside the `dbSendQuery()` method (which just executes a query without
    retrieving any data), so that it is ready to be used:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请确保使用 `dbSendQuery()` 方法中的 `TRUNCATE TABLE` SQL 命令清空 `WrongEmails` 表（该方法仅执行查询而不检索任何数据），以便它可以准备使用：
- en: '[PRE41]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When you have finished all read and write operations on the database instance,
    remember to close the connection, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成对数据库实例的所有读取和写入操作后，请记住按照以下方式关闭连接：
- en: '[PRE42]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Wow! You just learned how to read and write data from a SQL server or Azure
    SQL database with R! Let's apply what you've learned in Power BI.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你刚刚学会了如何使用 R 读取和写入 SQL 服务器或 Azure SQL 数据库中的数据！让我们将你所学应用到 Power BI 中。
- en: Logging emails and dates to an Azure SQL database in Power BI with R
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 R 在 Power BI 中记录电子邮件和日期
- en: 'In this section, we will use the same scenario already used to show how to
    log data to Azure SQL from Power BI. In order to properly execute the following
    R code, you need to make sure you have created the Azure SQL `SystemsLogging`
    database and the `WrongEmails` table as discussed in the *Logging to an Azure
    SQL server with Python* section. If you prefer, you can also use your on-premises
    SQL Server instance by appropriately changing the server name in the connection
    string. In this case, make sure that the `SystemsLogging` database and the `WrongEmails`
    table are there. The necessary steps are as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用之前用于展示如何从 Power BI 记录到 Azure SQL 的相同场景。为了正确执行以下 R 代码，你需要确保你已经创建了 Azure
    SQL 的 `SystemsLogging` 数据库和 `WrongEmails` 表，正如在 *使用 Python 记录到 Azure SQL 服务器*
    部分中讨论的那样。如果你愿意，你也可以使用你的本地 SQL Server 实例，只需适当地更改连接字符串中的服务器名称。在这种情况下，请确保 `SystemsLogging`
    数据库和 `WrongEmails` 表存在。必要的步骤如下：
- en: Follow all the steps in the *Using regex in Power BI to validate emails with
    R* section of *Chapter 5*, *Using Regular Expressions in Power BI*, to the end,
    but do not click on **Close & Apply**.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照第 5 章 *在 Power BI 中使用正则表达式* 的 *使用正则表达式在 Power BI 中使用 regex 验证电子邮件* 部分的所有步骤进行操作，直到结束，但不要点击
    **Close & Apply**。
- en: Then, click on **Run R Script**, enter the script you can find in the `R\05-log-wrong-emails-azure-sql-in-power-bi.R`
    file, and click **OK**. Remember to edit the server’s name and your credentials
    in the code.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **Run R Script**，输入你可以在 `R\05-log-wrong-emails-azure-sql-in-power-bi.R`
    文件中找到的脚本，然后点击 **OK**。请记住在代码中编辑服务器的名称和你的凭据。
- en: Click on the `df` dataset’s **Table** value.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `df` 数据集的 **Table** 值。
- en: 'Only rows containing valid emails will be kept:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有包含有效电子邮件的行将被保留：
- en: '![Figure 7.40 – A table containing only valid emails](img/file214.png)'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.40 – 仅包含有效电子邮件的表](img/file214.png)'
- en: Figure 7.40 – A table containing only valid emails
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.40 – 仅包含有效电子邮件的表
- en: Moreover, the invalid emails have been written into the `WrongEmails` table
    in your Azure SQL database.
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，无效的电子邮件已经写入你的 Azure SQL 数据库中的 `WrongEmails` 表。
- en: Go back to the **Home** menu, and then click **Close & Apply**.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回**主页**菜单，然后点击**关闭并应用**。
- en: 'As done before, you can verify that invalid emails were written to the previous
    table with SSMS. You’ll see the following output:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以使用 SSMS 验证无效的电子邮件是否已写入上一个表。您将看到以下输出：
- en: '![Figure 7.41 – The content of the WrongEmails table in SSMS](img/file215.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.41 – SSMS 中 WrongEmails 表的内容](img/file215.png)'
- en: Figure 7.41 – The content of the WrongEmails table in SSMS
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.41 – SSMS 中 WrongEmails 表的内容
- en: Awesome! You’ve just logged your wrong emails to your (Azure) SQL Server database
    using R from Power BI.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您已使用 R 从 Power BI 将错误的电子邮件记录到您的 (Azure) SQL Server 数据库中。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to log some information processed in Power
    Query to CSV files, Excel, on-premises SQL Servers, and Azure SQL, in both Python
    and R, using very simple and straightforward commands.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用非常简单直接命令，在 Python 和 R 中将 Power Query 处理的一些信息记录到 CSV 文件、Excel、本地
    SQL 服务器和 Azure SQL 中。
- en: In the next chapter, you will see how to handle very large CSV files that cannot
    be loaded from Power BI Desktop due to the RAM size of your machine not being
    sufficient.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何处理由于您的机器 RAM 大小不足而无法从 Power BI Desktop 加载的非常大的 CSV 文件。
- en: References
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'For additional reading, check out the following books and articles:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如需进一步阅读，请查看以下书籍和文章：
- en: '*Common Format and MIME Type for Comma-Separated Values (CSV) Files* ([https://tools.ietf.org/html/rfc4180](https://tools.ietf.org/html/rfc4180))'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*逗号分隔值 (CSV) 文件的常见格式和 MIME 类型* ([https://tools.ietf.org/html/rfc4180](https://tools.ietf.org/html/rfc4180))'
- en: '*Excel (.xlsx) Extensions to the Office Open XML SpreadsheetML File Format*
    ([https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/](https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/))'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Excel (.xlsx) 扩展 Office Open XML 电子表格文件格式* ([https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/](https://docs.microsoft.com/en-us/openspecs/office_standards/ms-xlsx/))'
- en: '*Connect Excel to a database in Azure SQL Database* ([https://docs.microsoft.com/en-us/azure/azure-sql/database/connect-excel](https://docs.microsoft.com/en-us/azure/azure-sql/database/connect-excel))'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*将 Excel 连接到 Azure SQL 数据库中的数据库* ([https://docs.microsoft.com/en-us/azure/azure-sql/database/connect-excel](https://docs.microsoft.com/en-us/azure/azure-sql/database/connect-excel))'
