- en: Chapter 2. Be Selective
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：选择之道
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Selecting a single element
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择单个元素
- en: Selecting multiple elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择多个元素
- en: Iterating through a selection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历选择集
- en: Performing subselection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行子选择
- en: Function chaining
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数链式调用
- en: Manipulating raw selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作原始选择集
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most fundamental tasks that you need to perform with any data visualization
    project using D3 is selection. Selection helps you target certain visual elements
    on the page. If you are already familiar with the W3C standardized CSS selector
    or other similar selector APIs provided by popular JavaScript libraries, such
    as jQuery and Zepto.js, then you will find yourself right at home with D3's selection
    API. Don't worry if you haven't used selector API before, this chapter is designed
    to cover this topic in steps with the help of some very visual recipes; it will
    cover pretty much all common use cases for your data visualization needs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 D3 的任何数据可视化项目中，你需要执行的最基本任务之一就是选择。选择可以帮助你定位页面上的某些视觉元素。如果你已经熟悉 W3C 标准化的 CSS
    选择器或由流行的 JavaScript 库（如 jQuery 和 Zepto.js）提供的其他类似选择器 API，那么你将发现自己在 D3 的选择器 API
    中如鱼得水。如果你之前没有使用选择器 API，请不要担心，本章旨在通过一些非常直观的食谱分步骤介绍这个主题；它将涵盖你数据可视化需求的所有常见用例。
- en: '**Introducing selection**: Selector support has been standardized by W3C so
    all modern web browsers have built-in support for the selector API. However the
    basic W3C selector API has its limitations when it comes to web development, especially
    in the data visualization realm. The standard W3C selector API only provides selector
    but not selection. What this means is that the selector API helps you to select
    element(s) in your document, however, to manipulate the selected element(s) you
    still need to loop through each element, in order to manipulate the selected element(s).
    Consider the following code snippet using the standard selector API:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**引入选择集**：选择器支持已被 W3C 标准化，因此所有现代网络浏览器都内置了对选择器 API 的支持。然而，当涉及到网络开发时，尤其是在数据可视化领域，基本的
    W3C 选择器 API 存在局限性。标准的 W3C 选择器 API 只提供选择器，而不提供选择集。这意味着选择器 API 帮助你在文档中选择元素，但是，要操作所选元素，你仍然需要遍历每个元素，以便操作所选元素。考虑以下使用标准选择器
    API 的代码片段：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code essentially selects all `<p>` elements in the document and
    then iterates through each element to perform some task. This can obviously get
    tedious quickly, especially when you have to manipulate many different elements
    on the page constantly, which is what we usually do in data visualization projects.
    This is why D3 introduced its own selection API, making development less of a
    chore. For the rest of this chapter we will cover how D3's selection API works
    as well as some of its powerful features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实际上选择了文档中的所有 `<p>` 元素，然后遍历每个元素以执行某些任务。这显然会很快变得繁琐，尤其是在你需要在页面上不断操作许多不同元素时，这是我们通常在数据可视化项目中做的事情。这就是为什么
    D3 引入了它自己的选择器 API，使得开发工作不再那么枯燥。在本章的剩余部分，我们将介绍 D3 的选择器 API 的工作原理以及一些其强大的功能。
- en: '**CSS3 selector basics**: Before we dive into D3''s selection API, some basic
    introduction on the W3C level-3 selector API is required. If you are already comfortable
    with CSS3 selectors, feel free to skip this section. D3''s selection API is built
    based on the level-3 selector or more commonly known as the CSS3 selector support.
    In this section, we plan to go through some of the most common CSS3 selector syntax
    that are required to understand D3 selection API.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**CSS3 选择器基础**：在我们深入 D3 的选择器 API 之前，需要对 W3C 第 3 级选择器 API 进行一些基本介绍。如果你已经熟悉 CSS3
    选择器，请随意跳过本节。D3 的选择器 API 是基于第 3 级选择器构建的，或者更常见的是 CSS3 选择器支持。在本节中，我们计划介绍一些必须了解 D3
    选择器 API 的最常见 CSS3 选择器语法。'
- en: '`#foo`: select element with `foo` as the value of `id`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#foo`：选择 `id` 值为 `foo` 的元素'
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`foo`: select element `foo`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`：选择元素 `foo`'
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`.foo`: select elements with `foo` as the value of `class`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.foo`：选择 `class` 值为 `foo` 的元素'
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`[foo=goo]`: select elements with the `foo` attribute value and set it to `goo`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[foo=goo]`：选择具有 `foo` 属性值并将其设置为 `goo` 的元素'
- en: '[PRE4]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`foo goo`: select the `goo` element inside the `foo` element'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo goo`：选择 `foo` 元素内部的 `goo` 元素'
- en: '[PRE5]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`foo#goo`: select the `foo` element set `goo` as the value of `id`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo#goo`：选择 `id` 值为 `goo` 的 `foo` 元素'
- en: '[PRE6]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`foo.goo`: select the `foo` element with `goo` as the value of `class`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo.goo`：选择 `class` 值为 `goo` 的 `foo` 元素'
- en: '[PRE7]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`foo:first-child`: select the first child of the `foo` elements'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo:first-child`：选择 `foo` 元素的第一个子元素'
- en: '[PRE8]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`foo:nth-child(n)`: select the nth child of the `foo` elements'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo:nth-child(n)`: 选择`foo`元素的第n个子元素'
- en: '[PRE9]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: CSS3 selector is a pretty complex topic. Here we have only listed some of the
    most common selectors that you will need to understand and to be effective when
    working with D3\. For more information on this topic please visit the W3C level-3
    selector API document [http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CSS3选择器是一个相当复杂的话题。在这里，我们只列出了一些你需要理解和掌握的、在用D3工作时最常用的选择器。有关这个主题的更多信息，请访问W3C的3级选择器API文档[http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are targeting an older browser that does not support selector natively,
    you can include Sizzle before D3 for backwards-compatibility. You can find Sizzle
    at [http://sizzlejs.com/](http://sizzlejs.com/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在针对不支持选择器的旧浏览器，你可以在D3之前包含Sizzle以实现向后兼容性。你可以在[http://sizzlejs.com/](http://sizzlejs.com/)找到Sizzle。
- en: Currently the next generation selector API level-4 is in draft stage with W3C.
    You can have a peek at what it has to offer and its current draft here at [http://dev.w3.org/csswg/selectors4/](http://dev.w3.org/csswg/selectors4/)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，下一代选择器API的4级在W3C处于草案阶段。你可以在[http://dev.w3.org/csswg/selectors4/](http://dev.w3.org/csswg/selectors4/)查看它提供的内容及其当前草案。
- en: Major browser vendors have already started implementing some of the level-4
    selectors if you are interested to find out the level of support in your browser,
    try out this handy website [http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主要浏览器厂商已经开始实现一些4级选择器，如果你想知道浏览器支持的程度，可以尝试这个实用的网站[http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/)。
- en: Selecting a single element
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择单个元素
- en: It is very common that sometimes you need to select a single element on a page
    to perform some visual manipulation. This recipe will show you how to perform
    a targeted single element selection in D3 using CSS selector.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要在一个页面上选择单个元素以执行一些视觉操作。这个示例将向你展示如何使用CSS选择器在D3中执行有针对性的单个元素选择。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html)'
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's select something (a paragraph element perhaps) and produce the classic
    "hello world" on screen.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一些内容（比如一个段落元素）并在屏幕上生成经典的“hello world”。
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This recipe simply produces a **Hello world!** on your screen.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例简单地在你的屏幕上显示一个**Hello world!**。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `d3.select` command is used to perform a single element selection in D3\.
    This method accepts a string representing a valid CSS3 selector or an element
    object if you already have a reference to the element you want to select. The
    `d3.select` command returns a D3 selection object on which you can chain modifier
    functions to manipulate the attribute, content or inner HTML of this element.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.select`命令用于在D3中执行单个元素选择。此方法接受一个表示有效CSS3选择器的字符串，或者如果你已经有了要选择的元素的引用，则可以接受一个元素对象。`d3.select`命令返回一个D3选择对象，你可以在此对象上链式调用修改函数来操作此元素的属性、内容或内部HTML。'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: More than one element can be selected using the selector provided only the first
    element is returned in the selection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的选择器可以选择多个元素，但只返回选择集中的第一个元素。
- en: 'In this example, we simply select the paragraph element with `target` as the
    value of `id` at line B, and then set its textual content to `Hello world!` on
    line C. All D3 selections support a set of standard modifier functions. The `text`
    function we have shown here is one of them. The following are some of the most
    common modifier functions you will encounter throughout this book:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在B行选择具有`target`作为`id`值的段落元素，然后在C行将其文本内容设置为`Hello world!`。所有D3选择都支持一组标准修改函数。我们在这里展示的`text`函数就是其中之一。以下是在本书中你将遇到的一些最常见的修改函数：
- en: 'The `selection.attr` function: This function allows you to retrieve or modify
    a given attribute on the selected element(s)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.attr`函数：此函数允许你检索或修改所选元素上的给定属性。'
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `selection.classed` function: This function allows you to add or remove
    CSS classes on the selected element(s).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.classed`函数：此函数允许你在所选元素上添加或删除CSS类。'
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `selection.style` function: This function lets you set the CSS style with
    a specific name to the specific value on the selected element(s).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.style` 函数：此函数允许你将具有特定名称的 CSS 样式设置为选定的元素（们）的特定值。'
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `selection.text` function: This function allows you access and set the
    text content of the selected element(s).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.text` 函数：此函数允许你访问和设置选定的元素（们）的文本内容。'
- en: '[PRE14]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `selection.html` function: This function lets you modify the element''s
    inner HTML content.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selection.html` 函数：此函数允许你修改元素的内部 HTML 内容。'
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These modifier functions work on both single-element and multi-element selection
    results. When applied to multi-element selections, these modifications will be
    applied to each and every selected element. We will see them in action in other,
    more complex recipes covered in the rest of this chapter.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些修饰函数适用于单元素和多元素选择结果。当应用于多元素选择时，这些修改将应用于每个选定的元素。我们将在本章剩余部分的其他更复杂的食谱中看到它们的应用。
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a function is used as a value in these modifier functions, there are actually
    some built-in parameters being passed to these functions to enable data-driven
    calculation. This data-driven approach is what gives D3 its power and its name
    (Data-Driven Document) and will be discussed in detail in the next chapter.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当一个函数在这些修饰函数中用作值时，实际上有一些内置参数被传递给这些函数，以启用数据驱动的计算。这种数据驱动的方法赋予了 D3 其力量和其名称（数据驱动文档），将在下一章中详细讨论。
- en: Selecting multiple elements
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择多个元素
- en: Often selecting a single element is not good enough, but rather you want to
    apply certain change to a set of elements on the page simultaneously. In this
    recipe, we will play with D3 multi-element selector and its selection API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常选择单个元素是不够的，你更希望同时对页面上的元素集应用某些更改。在这个食谱中，我们将使用 D3 多元素选择器和其选择 API 进行操作。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html)'
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This is what the `d3.selectAll` function is designed for. In this code snippet,
    we will select three different `div` elements and enhance them with some CSS classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 `d3.selectAll` 函数的设计目的。在这个代码片段中，我们将选择三个不同的 `div` 元素，并使用一些 CSS 类增强它们。
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code snippet produces the following visual:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段生成了以下视觉效果：
- en: '![How to do it...](img/2162OS_02_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2162OS_02_01.jpg)'
- en: Multi-element selection
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 多元素选择
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First thing you probably would notice in this example is how similar the usage
    of D3 selection API is when compared to the single-element version. This is one
    of the powerful design choices of the D3 selection API. No matter how many elements
    you are targeting, whether one or many, the modifier functions are exactly the
    same. All modifier functions we mentioned in the previous section can be applied
    directly to multi-element selection, in other words D3 selection is set-based.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可能会首先注意到 D3 选择 API 的使用与单元素版本是多么相似。这是 D3 选择 API 强大的设计选择之一。无论你针对多少个元素，无论是单个还是多个，修饰函数都是一样的。我们之前章节中提到的所有修饰函数都可以直接应用于多元素选择，换句话说，D3
    选择是基于集合的。
- en: Now with that being said, let's take a closer look at the code example shown
    in this section, though it is generally pretty simple and self-descriptive. At
    line A, the `d3.selectAll` function is used to select all the `div` elements on
    the page. The return of this function call is a D3 selection object that contains
    all three `div` elements. Immediately after that, on line B, the `attr` function
    was called on this selection to set the `class` attribute to `red box` for all
    three `div` elements. As shown in this example, the selection and manipulation
    code is very generic, and will not change if now we have more than three `div`
    elements on the page. This seems to be an insignificant convenience for now, but
    in later chapters we will show how this convenience can make your visualization
    code simpler and easier to maintain.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然已经说了这些，让我们更仔细地看看本节中展示的代码示例，尽管它通常很简单且具有自我描述性。在第A行，使用了`d3.selectAll`函数来选择页面上的所有`div`元素。这个函数调用的返回值是一个包含所有三个`div`元素的D3选择对象。紧接着，在第B行，对这个选择对象调用了`attr`函数，将所有三个`div`元素的`class`属性设置为`red
    box`。正如这个例子所示，选择和操作代码非常通用，如果现在页面上有超过三个`div`元素，代码也不会改变。这看起来现在似乎是一个微不足道的便利，但在后面的章节中，我们将展示这种便利如何使您的可视化代码更简单、更容易维护。
- en: Iterating through a selection
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代选择
- en: Sometimes it is handy to be able to iterate through each element within a selection
    and modify each element differently according to their position. In this recipe,
    we will show you how this can be achieved using D3 selection iteration API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时能够迭代选择中的每个元素并根据它们的位置不同地修改每个元素是非常方便的。在这个菜谱中，我们将向您展示如何使用D3选择迭代API实现这一点。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html)'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: D3 selection object provides simple iterator interface to perform iteration
    in a similar fashion as how you will iterate through a JavaScript array. In this
    example we will iterate through three selected `div` elements we worked with in
    the previous recipe and annotate them with an index number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: D3选择对象提供了一个简单的迭代接口，以类似于迭代JavaScript数组的方式执行迭代。在这个例子中，我们将迭代我们在前一个菜谱中使用的三个选中的`div`元素，并用索引号标注它们。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Selections are essentially arrays albeit with some enhancement. We will explore
    raw selection in its array form and how to work with it in later sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 选择本质上是一种数组，尽管有一些增强。我们将在后面的章节中探索原始选择及其数组形式，以及如何处理它。
- en: 'The preceding code snippet produces the following visual:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段产生了以下视觉效果：
- en: '![How to do it...](img/2162OS_02_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_02_02.jpg)'
- en: Selection iteration
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 选择迭代
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This example is built on top of what we have already seen in the previous section.
    Additional to selecting all the `div` elements on the page at line A and setting
    their class attributes at line B, in this example we call the `each` function
    on the selection to demonstrate how you can iterate through a multi-element selection
    and process each element respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是在我们之前章节中看到的内容的基础上构建的。除了在第A行选择页面上的所有`div`元素并在第B行设置它们的类属性之外，在这个例子中我们还对选择调用了`each`函数，以展示您如何迭代一个多元素选择并分别处理每个元素。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This form of calling a function on another function's return is called **Function
    Chaining**. If you are unfamiliar with this kind of invocation pattern, please
    review [Chapter 1,](ch01.html "Chapter 1. Getting Started with D3.js") *Getting
    Started with D3.js*, where the topic was explained.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在另一个函数的返回值上调用函数的形式被称为**函数链式调用**。如果您不熟悉这种调用模式，请参阅[第1章](ch01.html "第1章. 使用D3.js入门")
    *使用D3.js入门*，其中解释了该主题。
- en: '**The selection.each(function) function**: The `each` function takes an iterator
    function as its parameter. The given iterator function can receive two optional
    parameters `d` and `i` with one more hidden parameter passed in as the `this`
    reference which points to the current DOM element object. The first parameter
    `d` represents the datum bound to this particular element (if this sounds confusing
    to you, don''t worry we will cover data binding in depth in the next chapter).
    The second parameter `i` is the index number for the current element object being
    iterated through. This index is zero-based meaning it starts from zero and increments
    each time a new element is encountered.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器.each(function) 函数**：`each` 函数接受一个迭代器函数作为其参数。给定的迭代器函数可以接收两个可选参数 `d` 和
    `i`，以及一个作为 `this` 引用传递的隐藏参数，该引用指向当前 DOM 元素对象。第一个参数 `d` 代表绑定到该特定元素的数值（如果您觉得这很困惑，不要担心，我们将在下一章深入讲解数据绑定）。第二个参数
    `i` 是正在迭代的当前元素对象的索引号。这个索引是从零开始的，意味着它从零开始，每次遇到新元素时增加。'
- en: '**The selection.append(name) function**: Another new function introduced in
    this example is the `append` function. This function creates a new element with
    the given name and appends it as the last child of each element in the current
    selection. It returns a new selection containing the newly appended element. Now
    with this knowledge, let''s take a closer look at the code example in this recipe.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器.append(name) 函数**：在本例中引入的另一个新函数是 `append` 函数。该函数创建一个具有给定名称的新元素，并将其追加到当前选择中每个元素的最后一个子元素。它返回一个包含新追加元素的新选择。现在，有了这些知识，让我们更仔细地看看本例中的代码示例。'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The iterator function is defined on line C with both `d` and `i` parameters.
    Line D is a little bit more interesting. At the beginning of line D, the `this`
    reference is wrapped by the `d3.select` function. This wrapping essentially produces
    a single element selection containing the current DOM Element. Once wrapped, the
    standard D3 selection manipulation API can then be used on `d3.select(this)`.
    After that the `append("h1")` function is called on the current element selection
    which appends a newly created `h1` element to the current element. Then it simply
    sets the textual content of this newly created `h1` element to the index number
    of the current element. This produces the visual of numbered boxes as shown in
    this recipe. Again you should notice that the index starts from 0 and increments
    1 for each element.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器函数定义在第 C 行，包含 `d` 和 `i` 参数。第 D 行稍微有趣一些。在第 D 行的开始处，`this` 引用被 `d3.select`
    函数包裹。这种包裹实际上产生了一个包含当前 DOM 元素的单个元素选择。一旦被包裹，就可以在 `d3.select(this)` 上使用标准的 D3 选择操作
    API。之后，在当前元素选择上调用 `append("h1")` 函数，将新创建的 `h1` 元素追加到当前元素。然后它简单地设置这个新创建的 `h1` 元素的文本内容为当前元素的索引号。这产生了如图所示编号框的视觉效果。再次提醒，索引从
    0 开始，每次遇到新元素时增加 1。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The DOM element object itself has a very rich interface. If you are interested
    to know more about what it can do in an iterator function, please refer to the
    DOM element API at [https://developer.mozilla.org/en-US/docs/DOM/element](https://developer.mozilla.org/en-US/docs/DOM/element).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 元素对象本身具有非常丰富的接口。如果您想了解在迭代器函数中它能做什么，请参阅 [https://developer.mozilla.org/en-US/docs/DOM/element](https://developer.mozilla.org/en-US/docs/DOM/element)
    的 DOM 元素 API。
- en: Performing subselection
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行子选择
- en: It is quite common that you will need to perform scoped selection when working
    on visualization. For example, selecting all `div` elements within a particular
    `section` element is one use case of such scoped selection. In this recipe, we
    will demonstrate how this can be achieved with different approaches and their
    advantages and disadvantages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理可视化时，执行范围选择是很常见的。例如，选择特定 `section` 元素内的所有 `div` 元素是这种范围选择的一个用例。在本例中，我们将展示如何通过不同的方法和它们的优缺点来实现这一点。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html)'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The following code example selects two different `div` elements using two different
    styles of subselection supported by D3.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例使用 D3 支持的两种不同的子选择样式选择了两个不同的 `div` 元素。
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code generates the following visual output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了以下视觉输出：
- en: '![How to do it...](img/2162OS_02_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2162OS_02_03.jpg)'
- en: Subselection
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 子选择
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Though producing the same visual effect, this example demonstrates two very
    different subselection techniques. We will discuss them separately here so you
    can understand their pros and cons as well as when to use one versus the other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然产生相同的效果，但这个例子展示了两种非常不同的子选择技术。我们将分别在这里讨论它们，以便您了解它们的优缺点以及何时使用一种而不是另一种。
- en: '**Selector level-3 combinators**: On line A, `d3.select` is used with a special
    looking string which consists of one tag name connected with another one using
    a greater-than sign (U+003E, >). This syntax is called **combinators** (the greater-than
    sign here indicates it is a child combinator). Level-3 selector supports a few
    different kinds of structural combinators. Here we are going to give a quick introduction
    to the most common ones.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择器第三级组合器**：在行A中，`d3.select` 使用了一个看起来特殊的字符串，该字符串由一个标签名通过大于号（U+003E，>）连接到另一个标签名。这种语法被称为**组合器**（这里的大于号表示它是一个子组合器）。第三级选择器支持几种不同的结构组合器。在这里，我们将快速介绍其中最常见的一些。'
- en: '**The descendant combinator:** This combinator has the syntax like `selector
    selector`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**后代组合器**：这个组合器的语法类似于`selector selector`。'
- en: The descendant combinator, as suggested by its name, is used to describe a loose
    parent-child relationship between two selections. The reason why it is called
    loose parent-child relationship is that the descendant combinatory does not care
    if the second selection is a child or a grandchild or a great-grandchild of the
    parent selection. Let's look at some examples to illustrate this loose relationship
    concept.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，后代组合器用于描述两个选择器之间松散的父子关系。之所以称为松散的父子关系，是因为后代组合器不关心第二个选择器是否是父选择器的子、孙子或曾孙。让我们通过一些例子来说明这种松散关系概念。
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using the following selector:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下选择器：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It will select the `em` element since `div` is the ancestor of the `em` element
    and `em` is a descendent of the `div` element.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它将选择`em`元素，因为`div`是`em`元素的祖先，而`em`是`div`元素的子代。
- en: '**Child combinator**: This combinator has the syntax like `selector > selector`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**子组合器**：这个组合器的语法类似于`selector > selector`。'
- en: The child combinator offers a more restrictive way to describe a parent-child
    relationship between two elements. A child combinator is defined using a greater-than
    sign (U+003E, >) character separating two selectors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 子组合器提供了一种更严格的方式来描述两个元素之间的父子关系。子组合器是通过使用大于号（U+003E，>）字符分隔两个选择器来定义的。
- en: 'The following selector:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选择器：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will select the `em` element since `em` is a direct child of the `span` element
    in our example. While the selector `div > em` will not produce any valid selection
    since `em` is not a direct child of the `div` element.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它将选择`em`元素，因为在我们例子中`em`是`span`元素的直接子代。而选择器`div > em`将不会产生任何有效选择，因为`em`不是`div`元素的直接子代。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The level-3 selector also supports sibling combinators however since it is less
    common we are not going to cover it here; interested readers can refer to W3C
    level-3 selector documentation [http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第三级选择器也支持兄弟组合器，但由于它不太常见，我们在这里不进行介绍；感兴趣的读者可以参考 W3C 第三级选择器文档[http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)。
- en: The W3C level-4 selector offers some interesting additional combinators, that
    is, following-sibling and reference combinators that can yield some very powerful
    target selection capability; see [http://dev.w3.org/csswg/selectors4/#combinators](http://dev.w3.org/csswg/selectors4/#combinators)
    for more details.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: W3C 第四级选择器提供了一些有趣的附加组合器，即跟随兄弟和引用组合器，这些组合器可以提供一些非常强大的目标选择能力；更多详情请参阅[http://dev.w3.org/csswg/selectors4/#combinators](http://dev.w3.org/csswg/selectors4/#combinators)。
- en: '**The D3 subselection**: On line B and C, a different kind of subselection
    technique was used. In this case a simple D3 selection was made first on line
    B selecting `section #section2` element. Immediately afterwards another `select`
    was chained to select a `div` element on line C. This kind of chained selection
    defines a scoped selection. In plain English, this basically means to select a
    `div` element that is nested under `#section2`. In semantics, this is essentially
    similar to using a descendant combinator `#section2 div`. However, the advantage
    of this form of subselection is that since the parent element is separately selected
    therefore it allows you to handle the parent element before selecting the child
    element. To demonstrate this, let''s take a look at the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**D3子选择**：在行B和C上，使用了不同类型的子选择技术。在这种情况下，首先在行B上对`section #section2`元素进行了简单的D3选择。紧接着，另一个`select`被链式调用，以选择行C上的`div`元素。这种链式选择定义了一个范围选择。用简单的话说，这基本上意味着选择一个嵌套在`#section2`下的`div`元素。在语义上，这本质上类似于使用后代组合器`#section2
    div`。然而，这种子选择形式的优势在于，由于父元素是单独选择的，因此它允许你在选择子元素之前处理父元素。为了演示这一点，让我们看一下以下代码片段：'
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As shown in the preceding code snippet, now you can see before we select the
    `div` element, we can apply a modifier function to `#section2` on line B-1\. This
    flexibility will be further explored in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，现在在我们选择`div`元素之前，我们可以在行B-1上对`#section2`应用一个修改器函数。这种灵活性将在下一节进一步探讨。
- en: Function chaining
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数链
- en: As we have seen so far, the D3 API is completely designed around the idea of
    function chaining. Therefore it almost forms a Domain Specific Language (DSL)
    for building HTML/SVG elements dynamically. In this code example, we will take
    a look at how the entire body structure of the previous example can be constructed
    using D3 alone.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，D3 API完全围绕函数链的概念设计。因此，它几乎形成了一个用于动态构建HTML/SVG元素的领域特定语言（DSL）。在这个代码示例中，我们将看看如何仅使用D3构建上一个示例的整个主体结构。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If DSL is a new concept for you, I highly recommend checking out this excellent
    explanation on DSL by Martin Fowler in the form of an excerpt from his book *Domain-Specific
    Languages*. The excerpt can be found at [http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果领域特定语言（DSL）对你来说是一个新概念，我强烈推荐查看Martin Fowler在其书籍《领域特定语言》（*Domain-Specific Languages*）中的精彩解释摘录。摘录可以在[http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379)找到。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html)'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's see how function chain can be used to produce concise and readable code
    that produces dynamic visual content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用函数链来生成简洁且易于阅读的代码，从而产生动态视觉内容。
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code generates the following visual output (similar to what we saw in
    the previous chapter):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成以下视觉输出（与我们之前章节中看到的内容相似）：
- en: '![How to do it...](img/2162OS_02_04.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_02_04.jpg)'
- en: Function chain
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数链
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Despite the visual similarity to the previous example, the construction process
    of the DOM elements is significantly different in this example. As demonstrated
    by the code example there is no static HTML element on the page contrary to the
    previous recipe where both the `section` and `div` elements existed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与上一个示例在视觉上相似，但在这个示例中DOM元素的构建过程与上一个示例有显著不同。正如代码示例所示，与上一个食谱中存在的`section`和`div`元素不同，页面上没有静态HTML元素。
- en: Let's examine closely how these elements were dynamically created. On line A,
    a general selection was made to the top level `body` element. The `body` selection
    result was cached using a local variable called `body`. Then at line B, a new
    element `section` was appended to the body. Remember that the `append` function
    returns a new selection that contains the newly appended element therefore on
    line C the `id` attribute can then be set on a newly created section element to
    `section1`. Afterwards on line D a new `div` element was created and appended
    to `#section1` with its CSS class set to `blue box` on line E. Next step, similarly
    on line F a `paragraph` element was appended to the `div` element with its textual
    content set to `dynamic blue box` on line G.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看这些元素是如何动态创建的。在第 A 行，对顶级 `body` 元素进行了通用选择。使用名为 `body` 的局部变量缓存了 `body`
    选择结果。然后在第 B 行，将一个新的 `section` 元素附加到 `body` 上。记住，`append` 函数返回一个包含新附加元素的新选择，因此在第
    C 行，可以将新创建的 `section` 元素的 `id` 属性设置为 `section1`。之后在第 D 行，创建了一个新的 `div` 元素并将其附加到
    `#section1` 上，其 CSS 类在第 E 行设置为 `blue box`。下一步，同样在第 F 行，将一个 `paragraph` 元素附加到 `div`
    元素上，其文本内容在第 G 行设置为 `dynamic blue box`。
- en: As illustrated by this example, this chaining process can continue to create
    any structure of arbitrary complexity. As a matter of fact, this is how typically
    D3 based data visualization structure was created. Many visualization projects
    simply contain only a HTML skeleton while relying on D3 to create the rest. Getting
    comfortable with this way of function chaining is critical if you want to become
    efficient with the D3 library.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，此链式过程可以继续创建任意复杂度的结构。实际上，这就是通常基于 D3 的数据可视化结构是如何创建的。许多可视化项目仅包含一个 HTML 骨架，而依赖于
    D3 创建其余部分。如果你想要高效地使用 D3 库，熟悉这种函数链式方法至关重要。
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some of D3's modifier functions return a new selection, such as the `select`,
    `append`, and `insert` functions. It is a good practice to use different levels
    of indentation to differentiate which selection your function chain is being applied
    on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 D3 的修改函数返回一个新的选择，例如 `select`、`append` 和 `insert` 函数。使用不同级别的缩进区分函数链应用于哪个选择是一个好习惯。
- en: Manipulating the raw selection
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作原始选择
- en: Sometimes, though not very often, having access to D3 raw selection array might
    be beneficial in development whether it's for debugging purposes or for integrating
    with other JavaScript libraries which require access to raw DOM elements; in this
    recipe, we will show you ways to do that. We will also see some internal structure
    of a D3 selection object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，尽管不经常，访问 D3 原始选择数组在开发中可能有益，无论是用于调试目的还是与其他需要访问原始 DOM 元素的 JavaScript 库集成；在这个配方中，我们将向您展示如何做到这一点。我们还将看到
    D3 选择对象的一些内部结构。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html)'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Of course you can achieve this by using the `nth-child` selector or selection
    iterator function via `each`, but there are cases where these options are just
    too cumbersome and inconvenient. This is when you might find dealing with raw
    selection array as a more convenient approach. In this example, we will see how
    raw selection array can be accessed and leveraged.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过使用 `nth-child` 选择器或通过 `each` 的选择器迭代函数来实现这一点，但在某些情况下，这些选项可能过于繁琐和不方便。这就是您可能会发现处理原始选择数组作为更方便的方法的时候。在这个例子中，我们将看到如何访问和利用原始选择数组。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This recipe generates the following visual output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方生成以下视觉输出：
- en: '![How to do it...](img/2162OS_02_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/2162OS_02_05.jpg)'
- en: Raw selection manipulation
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 原始选择操作
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we went through an existing HTML table to color the table.
    This is not intended to be a good example of how you would color odd versus even
    rows in a table using D3\. Instead, this example is designed to show how raw selection
    array can be accessed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过现有的 HTML 表格来着色表格。这并不是一个很好的例子，说明您如何使用 D3 着色表格的奇数和偶数行。相反，这个例子旨在展示如何访问原始选择数组。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A much better way to color odd and even rows in a table would be using the `each`
    function and then relying on the index parameter `i` to do the job.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格中为奇数和偶数行着色的一个更好的方法是使用 `each` 函数，然后依赖于索引参数 `i` 来完成这项工作。
- en: On line A, we select all rows and store the selection in the `rows` variable.
    D3 selection is stored in a two-dimensional JavaScript array. The selected elements
    are stored in an array then wrapped in a single element array. Thus in order to
    access the first selected element, you need to use `rows[0][0]` and the second
    element can be accessed with `rows[0][1]`. As we can see on line B, the table
    header element can be accessed using `rows[0][0]` and this will return a DOM element
    object. Again as we have demonstrated in previous sections, any DOM element can
    then be selected directly using `d3.select` as shown on line C. Line D, E, and
    F demonstrate how each element in selection can be directly indexed and accessed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 A 中，我们选择了所有行并将选择存储在 `rows` 变量中。D3 选择存储在一个二维 JavaScript 数组中。选中的元素存储在一个数组中，然后被包裹在一个单元素数组中。因此，为了访问第一个选中的元素，你需要使用
    `rows[0][0]`，而第二个元素可以通过 `rows[0][1]` 访问。正如我们在行 B 中看到的，表头元素可以通过 `rows[0][0]` 访问，这将返回一个
    DOM 元素对象。同样，正如我们在前面的章节中演示的那样，任何 DOM 元素都可以通过 `d3.select` 直接选择，如行 C 所示。行 D、E 和 F
    展示了如何直接索引和访问选择中的每个元素。
- en: Raw selection access could be handy in some cases; however since it relies on
    direct access to D3 selection array it creates a structural dependency in your
    code. In other words, if in future releases of D3 this structure ever changes,
    it will break your code that relies on it. Hence, it is advised to avoid raw selection
    manipulation unless absolutely necessary.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，原始选择访问可能很有用；然而，由于它依赖于直接访问 D3 选择数组，它会在你的代码中创建一个结构依赖。换句话说，如果在 D3 的未来版本中这个结构发生了变化，那么依赖于它的代码将会被破坏。因此，除非绝对必要，否则建议避免使用原始选择操作。
- en: Tip
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This approach is usually not necessary however it might become handy under certain
    circumstances such as in your unit-test cases when knowing the absolute index
    for each element quickly and gaining a reference to them could be convenient.
    We will cover unit-tests in a later chapter in more details.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常不是必要的，但在某些情况下可能会很有用，例如在你的单元测试用例中，当你需要快速知道每个元素的绝对索引并获得它们的引用时。我们将在后面的章节中更详细地介绍单元测试。
