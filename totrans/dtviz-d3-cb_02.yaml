- en: Chapter 2. Be Selective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting multiple elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing subselection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating raw selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental tasks that you need to perform with any data visualization
    project using D3 is selection. Selection helps you target certain visual elements
    on the page. If you are already familiar with the W3C standardized CSS selector
    or other similar selector APIs provided by popular JavaScript libraries, such
    as jQuery and Zepto.js, then you will find yourself right at home with D3's selection
    API. Don't worry if you haven't used selector API before, this chapter is designed
    to cover this topic in steps with the help of some very visual recipes; it will
    cover pretty much all common use cases for your data visualization needs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing selection**: Selector support has been standardized by W3C so
    all modern web browsers have built-in support for the selector API. However the
    basic W3C selector API has its limitations when it comes to web development, especially
    in the data visualization realm. The standard W3C selector API only provides selector
    but not selection. What this means is that the selector API helps you to select
    element(s) in your document, however, to manipulate the selected element(s) you
    still need to loop through each element, in order to manipulate the selected element(s).
    Consider the following code snippet using the standard selector API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code essentially selects all `<p>` elements in the document and
    then iterates through each element to perform some task. This can obviously get
    tedious quickly, especially when you have to manipulate many different elements
    on the page constantly, which is what we usually do in data visualization projects.
    This is why D3 introduced its own selection API, making development less of a
    chore. For the rest of this chapter we will cover how D3's selection API works
    as well as some of its powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: '**CSS3 selector basics**: Before we dive into D3''s selection API, some basic
    introduction on the W3C level-3 selector API is required. If you are already comfortable
    with CSS3 selectors, feel free to skip this section. D3''s selection API is built
    based on the level-3 selector or more commonly known as the CSS3 selector support.
    In this section, we plan to go through some of the most common CSS3 selector syntax
    that are required to understand D3 selection API.'
  prefs: []
  type: TYPE_NORMAL
- en: '`#foo`: select element with `foo` as the value of `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo`: select element `foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`.foo`: select elements with `foo` as the value of `class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`[foo=goo]`: select elements with the `foo` attribute value and set it to `goo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo goo`: select the `goo` element inside the `foo` element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo#goo`: select the `foo` element set `goo` as the value of `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo.goo`: select the `foo` element with `goo` as the value of `class`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo:first-child`: select the first child of the `foo` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`foo:nth-child(n)`: select the nth child of the `foo` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: CSS3 selector is a pretty complex topic. Here we have only listed some of the
    most common selectors that you will need to understand and to be effective when
    working with D3\. For more information on this topic please visit the W3C level-3
    selector API document [http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are targeting an older browser that does not support selector natively,
    you can include Sizzle before D3 for backwards-compatibility. You can find Sizzle
    at [http://sizzlejs.com/](http://sizzlejs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Currently the next generation selector API level-4 is in draft stage with W3C.
    You can have a peek at what it has to offer and its current draft here at [http://dev.w3.org/csswg/selectors4/](http://dev.w3.org/csswg/selectors4/)
  prefs: []
  type: TYPE_NORMAL
- en: Major browser vendors have already started implementing some of the level-4
    selectors if you are interested to find out the level of support in your browser,
    try out this handy website [http://css4-selectors.com/browser-selector-test/](http://css4-selectors.com/browser-selector-test/).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a single element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common that sometimes you need to select a single element on a page
    to perform some visual manipulation. This recipe will show you how to perform
    a targeted single element selection in D3 using CSS selector.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/single-selection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's select something (a paragraph element perhaps) and produce the classic
    "hello world" on screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This recipe simply produces a **Hello world!** on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `d3.select` command is used to perform a single element selection in D3\.
    This method accepts a string representing a valid CSS3 selector or an element
    object if you already have a reference to the element you want to select. The
    `d3.select` command returns a D3 selection object on which you can chain modifier
    functions to manipulate the attribute, content or inner HTML of this element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More than one element can be selected using the selector provided only the first
    element is returned in the selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we simply select the paragraph element with `target` as the
    value of `id` at line B, and then set its textual content to `Hello world!` on
    line C. All D3 selections support a set of standard modifier functions. The `text`
    function we have shown here is one of them. The following are some of the most
    common modifier functions you will encounter throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `selection.attr` function: This function allows you to retrieve or modify
    a given attribute on the selected element(s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selection.classed` function: This function allows you to add or remove
    CSS classes on the selected element(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selection.style` function: This function lets you set the CSS style with
    a specific name to the specific value on the selected element(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selection.text` function: This function allows you access and set the
    text content of the selected element(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `selection.html` function: This function lets you modify the element''s
    inner HTML content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These modifier functions work on both single-element and multi-element selection
    results. When applied to multi-element selections, these modifications will be
    applied to each and every selected element. We will see them in action in other,
    more complex recipes covered in the rest of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When a function is used as a value in these modifier functions, there are actually
    some built-in parameters being passed to these functions to enable data-driven
    calculation. This data-driven approach is what gives D3 its power and its name
    (Data-Driven Document) and will be discussed in detail in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Selecting multiple elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often selecting a single element is not good enough, but rather you want to
    apply certain change to a set of elements on the page simultaneously. In this
    recipe, we will play with D3 multi-element selector and its selection API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/multiple-selection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is what the `d3.selectAll` function is designed for. In this code snippet,
    we will select three different `div` elements and enhance them with some CSS classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet produces the following visual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-element selection
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First thing you probably would notice in this example is how similar the usage
    of D3 selection API is when compared to the single-element version. This is one
    of the powerful design choices of the D3 selection API. No matter how many elements
    you are targeting, whether one or many, the modifier functions are exactly the
    same. All modifier functions we mentioned in the previous section can be applied
    directly to multi-element selection, in other words D3 selection is set-based.
  prefs: []
  type: TYPE_NORMAL
- en: Now with that being said, let's take a closer look at the code example shown
    in this section, though it is generally pretty simple and self-descriptive. At
    line A, the `d3.selectAll` function is used to select all the `div` elements on
    the page. The return of this function call is a D3 selection object that contains
    all three `div` elements. Immediately after that, on line B, the `attr` function
    was called on this selection to set the `class` attribute to `red box` for all
    three `div` elements. As shown in this example, the selection and manipulation
    code is very generic, and will not change if now we have more than three `div`
    elements on the page. This seems to be an insignificant convenience for now, but
    in later chapters we will show how this convenience can make your visualization
    code simpler and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through a selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is handy to be able to iterate through each element within a selection
    and modify each element differently according to their position. In this recipe,
    we will show you how this can be achieved using D3 selection iteration API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/selection-iteration.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 selection object provides simple iterator interface to perform iteration
    in a similar fashion as how you will iterate through a JavaScript array. In this
    example we will iterate through three selected `div` elements we worked with in
    the previous recipe and annotate them with an index number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selections are essentially arrays albeit with some enhancement. We will explore
    raw selection in its array form and how to work with it in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code snippet produces the following visual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selection iteration
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is built on top of what we have already seen in the previous section.
    Additional to selecting all the `div` elements on the page at line A and setting
    their class attributes at line B, in this example we call the `each` function
    on the selection to demonstrate how you can iterate through a multi-element selection
    and process each element respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This form of calling a function on another function's return is called **Function
    Chaining**. If you are unfamiliar with this kind of invocation pattern, please
    review [Chapter 1,](ch01.html "Chapter 1. Getting Started with D3.js") *Getting
    Started with D3.js*, where the topic was explained.
  prefs: []
  type: TYPE_NORMAL
- en: '**The selection.each(function) function**: The `each` function takes an iterator
    function as its parameter. The given iterator function can receive two optional
    parameters `d` and `i` with one more hidden parameter passed in as the `this`
    reference which points to the current DOM element object. The first parameter
    `d` represents the datum bound to this particular element (if this sounds confusing
    to you, don''t worry we will cover data binding in depth in the next chapter).
    The second parameter `i` is the index number for the current element object being
    iterated through. This index is zero-based meaning it starts from zero and increments
    each time a new element is encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The selection.append(name) function**: Another new function introduced in
    this example is the `append` function. This function creates a new element with
    the given name and appends it as the last child of each element in the current
    selection. It returns a new selection containing the newly appended element. Now
    with this knowledge, let''s take a closer look at the code example in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The iterator function is defined on line C with both `d` and `i` parameters.
    Line D is a little bit more interesting. At the beginning of line D, the `this`
    reference is wrapped by the `d3.select` function. This wrapping essentially produces
    a single element selection containing the current DOM Element. Once wrapped, the
    standard D3 selection manipulation API can then be used on `d3.select(this)`.
    After that the `append("h1")` function is called on the current element selection
    which appends a newly created `h1` element to the current element. Then it simply
    sets the textual content of this newly created `h1` element to the index number
    of the current element. This produces the visual of numbered boxes as shown in
    this recipe. Again you should notice that the index starts from 0 and increments
    1 for each element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DOM element object itself has a very rich interface. If you are interested
    to know more about what it can do in an iterator function, please refer to the
    DOM element API at [https://developer.mozilla.org/en-US/docs/DOM/element](https://developer.mozilla.org/en-US/docs/DOM/element).
  prefs: []
  type: TYPE_NORMAL
- en: Performing subselection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite common that you will need to perform scoped selection when working
    on visualization. For example, selecting all `div` elements within a particular
    `section` element is one use case of such scoped selection. In this recipe, we
    will demonstrate how this can be achieved with different approaches and their
    advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/sub-selection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code example selects two different `div` elements using two different
    styles of subselection supported by D3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Subselection
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though producing the same visual effect, this example demonstrates two very
    different subselection techniques. We will discuss them separately here so you
    can understand their pros and cons as well as when to use one versus the other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector level-3 combinators**: On line A, `d3.select` is used with a special
    looking string which consists of one tag name connected with another one using
    a greater-than sign (U+003E, >). This syntax is called **combinators** (the greater-than
    sign here indicates it is a child combinator). Level-3 selector supports a few
    different kinds of structural combinators. Here we are going to give a quick introduction
    to the most common ones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The descendant combinator:** This combinator has the syntax like `selector
    selector`.'
  prefs: []
  type: TYPE_NORMAL
- en: The descendant combinator, as suggested by its name, is used to describe a loose
    parent-child relationship between two selections. The reason why it is called
    loose parent-child relationship is that the descendant combinatory does not care
    if the second selection is a child or a grandchild or a great-grandchild of the
    parent selection. Let's look at some examples to illustrate this loose relationship
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the following selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It will select the `em` element since `div` is the ancestor of the `em` element
    and `em` is a descendent of the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: '**Child combinator**: This combinator has the syntax like `selector > selector`.'
  prefs: []
  type: TYPE_NORMAL
- en: The child combinator offers a more restrictive way to describe a parent-child
    relationship between two elements. A child combinator is defined using a greater-than
    sign (U+003E, >) character separating two selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It will select the `em` element since `em` is a direct child of the `span` element
    in our example. While the selector `div > em` will not produce any valid selection
    since `em` is not a direct child of the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The level-3 selector also supports sibling combinators however since it is less
    common we are not going to cover it here; interested readers can refer to W3C
    level-3 selector documentation [http://www.w3.org/TR/css3-selectors/#sibling-combinators](http://www.w3.org/TR/css3-selectors/#sibling-combinators)
  prefs: []
  type: TYPE_NORMAL
- en: The W3C level-4 selector offers some interesting additional combinators, that
    is, following-sibling and reference combinators that can yield some very powerful
    target selection capability; see [http://dev.w3.org/csswg/selectors4/#combinators](http://dev.w3.org/csswg/selectors4/#combinators)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**The D3 subselection**: On line B and C, a different kind of subselection
    technique was used. In this case a simple D3 selection was made first on line
    B selecting `section #section2` element. Immediately afterwards another `select`
    was chained to select a `div` element on line C. This kind of chained selection
    defines a scoped selection. In plain English, this basically means to select a
    `div` element that is nested under `#section2`. In semantics, this is essentially
    similar to using a descendant combinator `#section2 div`. However, the advantage
    of this form of subselection is that since the parent element is separately selected
    therefore it allows you to handle the parent element before selecting the child
    element. To demonstrate this, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, now you can see before we select the
    `div` element, we can apply a modifier function to `#section2` on line B-1\. This
    flexibility will be further explored in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, the D3 API is completely designed around the idea of
    function chaining. Therefore it almost forms a Domain Specific Language (DSL)
    for building HTML/SVG elements dynamically. In this code example, we will take
    a look at how the entire body structure of the previous example can be constructed
    using D3 alone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If DSL is a new concept for you, I highly recommend checking out this excellent
    explanation on DSL by Martin Fowler in the form of an excerpt from his book *Domain-Specific
    Languages*. The excerpt can be found at [http://www.informit.com/articles/article.aspx?p=1592379](http://www.informit.com/articles/article.aspx?p=1592379).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/function-chain.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how function chain can be used to produce concise and readable code
    that produces dynamic visual content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates the following visual output (similar to what we saw in
    the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Function chain
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the visual similarity to the previous example, the construction process
    of the DOM elements is significantly different in this example. As demonstrated
    by the code example there is no static HTML element on the page contrary to the
    previous recipe where both the `section` and `div` elements existed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine closely how these elements were dynamically created. On line A,
    a general selection was made to the top level `body` element. The `body` selection
    result was cached using a local variable called `body`. Then at line B, a new
    element `section` was appended to the body. Remember that the `append` function
    returns a new selection that contains the newly appended element therefore on
    line C the `id` attribute can then be set on a newly created section element to
    `section1`. Afterwards on line D a new `div` element was created and appended
    to `#section1` with its CSS class set to `blue box` on line E. Next step, similarly
    on line F a `paragraph` element was appended to the `div` element with its textual
    content set to `dynamic blue box` on line G.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated by this example, this chaining process can continue to create
    any structure of arbitrary complexity. As a matter of fact, this is how typically
    D3 based data visualization structure was created. Many visualization projects
    simply contain only a HTML skeleton while relying on D3 to create the rest. Getting
    comfortable with this way of function chaining is critical if you want to become
    efficient with the D3 library.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of D3's modifier functions return a new selection, such as the `select`,
    `append`, and `insert` functions. It is a good practice to use different levels
    of indentation to differentiate which selection your function chain is being applied
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the raw selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, though not very often, having access to D3 raw selection array might
    be beneficial in development whether it's for debugging purposes or for integrating
    with other JavaScript libraries which require access to raw DOM elements; in this
    recipe, we will show you ways to do that. We will also see some internal structure
    of a D3 selection object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter2/raw-selection.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course you can achieve this by using the `nth-child` selector or selection
    iterator function via `each`, but there are cases where these options are just
    too cumbersome and inconvenient. This is when you might find dealing with raw
    selection array as a more convenient approach. In this example, we will see how
    raw selection array can be accessed and leveraged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visual output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Raw selection manipulation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we went through an existing HTML table to color the table.
    This is not intended to be a good example of how you would color odd versus even
    rows in a table using D3\. Instead, this example is designed to show how raw selection
    array can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A much better way to color odd and even rows in a table would be using the `each`
    function and then relying on the index parameter `i` to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: On line A, we select all rows and store the selection in the `rows` variable.
    D3 selection is stored in a two-dimensional JavaScript array. The selected elements
    are stored in an array then wrapped in a single element array. Thus in order to
    access the first selected element, you need to use `rows[0][0]` and the second
    element can be accessed with `rows[0][1]`. As we can see on line B, the table
    header element can be accessed using `rows[0][0]` and this will return a DOM element
    object. Again as we have demonstrated in previous sections, any DOM element can
    then be selected directly using `d3.select` as shown on line C. Line D, E, and
    F demonstrate how each element in selection can be directly indexed and accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Raw selection access could be handy in some cases; however since it relies on
    direct access to D3 selection array it creates a structural dependency in your
    code. In other words, if in future releases of D3 this structure ever changes,
    it will break your code that relies on it. Hence, it is advised to avoid raw selection
    manipulation unless absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach is usually not necessary however it might become handy under certain
    circumstances such as in your unit-test cases when knowing the absolute index
    for each element quickly and gaining a reference to them could be convenient.
    We will cover unit-tests in a later chapter in more details.
  prefs: []
  type: TYPE_NORMAL
