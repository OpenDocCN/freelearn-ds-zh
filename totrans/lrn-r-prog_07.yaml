- en: Chapter 7. Working with Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。处理数据
- en: In the previous chapters, you learned the most commonly used object types and
    functions to work in R. We know how to create and modify vectors, lists, and data
    frames, how to define our own functions and how to use proper expressions to translate
    our logic in mind to R code in the editor. With these objects, functions, and
    expressions, we can start working with data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了在R中工作的最常用的对象类型和函数。我们知道如何创建和修改向量、列表和数据框，如何定义我们自己的函数以及如何使用适当的表达式将我们心中的逻辑翻译成编辑器中的R代码。有了这些对象、函数和表达式，我们可以开始处理数据。
- en: 'In this chapter, we will set out on a journey of working with data and cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一段处理数据之旅，并涵盖以下主题：
- en: Reading and writing data in a file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中读取和写入数据
- en: Visualizing data with plot functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绘图函数可视化数据
- en: Analyzing data with simple statistical models and data mining tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的统计模型和数据挖掘工具分析数据
- en: Reading and writing data
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入数据
- en: The first step in any kind of data analysis in R is to load data, that is, to
    import a dataset into the environment. Before that, we have to figure out the
    type of data file and choose appropriate tools to read the data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中任何类型的数据分析的第一步是加载数据，即导入一个数据集到环境中。在此之前，我们必须确定数据文件的类型并选择合适的工具来读取数据。
- en: Reading and writing text-format data in a file
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件中读取和写入文本格式数据
- en: 'Among all the file types used to store data, perhaps the most widely used one
    is CSV. In a typical CSV file, the first line is the header of columns, and each
    subsequent line represents a data record with columns separated by commas. Here
    is an example of student records written in this format:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用于存储数据的文件类型中，可能最广泛使用的是CSV。在一个典型的CSV文件中，第一行是列标题，每一行后续的行代表一个数据记录，列之间由逗号分隔。以下是一个以这种格式编写的学生记录示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Importing data via RStudio IDE
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过RStudio IDE导入数据
- en: 'RStudio provides an interactive way to import data. You can navigate to **Tools**
    | **Import Dataset** | **From Local File** and choose a local file in a text format,
    such as `.csv` and `.txt`. Then, you can adjust the parameters and preview the
    resulting data frame:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio提供了一个交互式的方式来导入数据。你可以导航到**工具** | **导入数据集** | **从本地文件**，并选择一个本地文件，如`.csv`和`.txt`格式的文本文件。然后，你可以调整参数并预览结果数据框：
- en: '![Importing data via RStudio IDE](img/image_07_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![通过RStudio IDE导入数据](img/image_07_001.jpg)'
- en: Note that you should check **Strings as factors** only if you intend to convert
    string columns to factors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有当你打算将字符串列转换为因子时，才应该检查**字符串作为因子**。
- en: The file importer is not magic, but translates the file path and options to
    R code. Once you set up the data importing parameters and click on **Import**,
    it will execute a call to `read.csv()`. Using this interactive tool to import
    data is very handy and will help you avoid many mistakes when you import a data
    file for the first time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件导入器并非魔法，它将文件路径和选项转换为R代码。一旦你设置了数据导入参数并点击**导入**，它将执行对`read.csv()`的调用。使用这个交互式工具导入数据非常方便，并有助于你在第一次导入数据文件时避免许多错误。
- en: Importing data using built-in functions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置函数导入数据
- en: When you write a script, you can't expect the user to interact with the file
    importer every time. You can copy the generated code to your script so that it
    will automatically work each time you run the script. Therefore, it is useful
    to know how to use built-in functions to import data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写脚本时，你不能期望用户每次都与文件导入器交互。你可以将生成的代码复制到你的脚本中，这样每次运行脚本时它都会自动工作。因此，了解如何使用内置函数导入数据是有用的。
- en: 'The simplest built-in function to import data is `readLines()`, as we mentioned
    in previous chapters. This function reads a text file and returns a number of
    lines as a character vector:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最简单的内置函数是`readLines()`，它读取一个文本文件并返回一个字符向量作为多行：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, it will read all the lines of the file. To preview the first two
    lines, run the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将读取文件的所有行。要预览前两行，请运行以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For practical data importing, `readLines()` is too simple in most cases. It
    works by reading lines as strings rather than parsing them into a data frame.
    If you want to import data from a CSV file like the preceding code, directly call `read.csv()`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的数据导入，`readLines()`在大多数情况下太简单了。它通过读取字符串行而不是将它们解析成数据框来工作。如果你想导入类似于前面代码的CSV文件中的数据，直接调用`read.csv()`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we want to keep the string value as it is, so we set `stringsAsFactors
    = FALSE` in the function call to avoid converting the strings to factors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们希望字符串值保持不变，因此在函数调用中设置 `stringsAsFactors = FALSE` 以避免将字符串转换为因子。
- en: 'The function provides many useful arguments to customize importing. For example,
    we can use `colClasses` to explicitly specify the types of columns and use `col.names`
    to replace the original column names in the data file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数提供了许多有用的参数来定制导入。例如，我们可以使用 `colClasses` 来显式指定列的类型，并使用 `col.names` 来替换数据文件中的原始列名：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that CSV is a special case of the delimited data format. Technically, the
    CSV format is a delimited data format that uses a comma (,) to separate columns
    and a new line to separate rows. More generally speaking, any character can be
    the column separator and row separator. Many datasets are stored in the tab-delimited
    format, that is, they use tab character to separate columns. In this case, you
    may try using `read.table()`, a more general version, based on which `read.csv()`
    is implemented.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CSV 是分隔数据格式的一个特例。技术上讲，CSV 格式是一种使用逗号 (,) 分隔列和换行符分隔行的分隔数据格式。更普遍地说，任何字符都可以作为列分隔符和行分隔符。许多数据集以制表符分隔的格式存储，即它们使用制表符字符来分隔列。在这种情况下，您可能尝试使用基于此的更通用版本
    `read.table()`，`read.csv()` 就是基于它实现的。
- en: Importing data using the readr package
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `readr` 包导入数据
- en: For historical reasons, `read.*` functions have some inconsistencies and are
    not very friendly in some situations. The `readr` package is a good choice to
    import tabular data in a fast and consistent manner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，`read.*` 函数存在一些不一致性，在某些情况下不太友好。`readr` 包是快速且一致地导入表格数据的良好选择。
- en: 'To install the package, run `install.packages("readr")`. You can then use a
    family of `read_*` functions to import tabular data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装该包，请运行 `install.packages("readr")`。然后您可以使用一系列 `read_*` 函数导入表格数据：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we use `readr::read_csv` instead of `library(readr)` first and then directly
    call `read_csv` because it is easy to confuse `read_csv` with the built-in `read.csv` file since
    they have slightly different behaviors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `readr::read_csv` 而不是先使用 `library(readr)`，然后直接调用 `read_csv`，因为它们的行为略有不同，容易混淆
    `read_csv` 与内置的 `read.csv`：
- en: 'Also, note that the default behavior of `read_csv` is smart enough to handle
    most situations. To make a contrast with built-in functions, let''s import a data
    file (`data/persons.txt`) in an irregular format:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`read_csv` 的默认行为足够智能，可以处理大多数情况。为了与内置函数进行对比，让我们导入一个格式不规则的数据文件（`data/persons.txt`）：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The file content looks quite standard and tabular, but the number of spaces
    between each column is unequal across rows, which fails to let `read.table()` work
    with `sep = " "`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容看起来非常标准且表格化，但每列之间的空格数量在行之间不等，这使得 `read.table()` 无法使用 `sep = " "`：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you insist on using `read.table()` to import data, you may waste a lot of
    time trying to figure out the right argument to control the behavior. However,
    with the same input, the default behavior of `read_table` in `readr` is smart
    enough and thus helps you save time:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您坚持使用 `read.table()` 导入数据，您可能会浪费大量时间试图找出控制行为的正确参数。然而，对于相同的输入，`readr` 中的 `read_table`
    默认行为足够智能，因此可以帮助您节省时间：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's why I strongly recommend that you use the functions in `readr` to import
    tabular data into R. The functions in `readr` are fast, smart, and consistent
    and support the features of the built-in functions which are much easier to use.
    To learn more about the `readr` package, visit [https://github.com/hadley/readr](https://github.com/hadley/readr).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我强烈建议您使用 `readr` 中的函数将表格数据导入 R。`readr` 中的函数速度快、智能且一致，并支持内置函数的功能，这些内置函数更容易使用。要了解更多关于
    `readr` 包的信息，请访问 [https://github.com/hadley/readr](https://github.com/hadley/readr)。
- en: Writing a data frame to a file
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据框写入文件
- en: A typical procedure in data analysis is importing data from a data source, transforming
    the data, applying appropriate tools and models, and finally creating some new
    data to be stored for decision making. The interface for writing data to file
    is very similar to that for reading data—we use `write.*` functions to export
    a data frame to a file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析中的一个典型程序是从数据源导入数据，转换数据，应用适当的工具和模型，最后创建一些新的数据以供决策存储。将数据写入文件的接口与读取数据的接口非常相似——我们使用
    `write.*` 函数将数据框导出到文件。
- en: 'For example, we can create an arbitrary data frame and store it in a CSV file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个任意的数据框并将其存储在 CSV 文件中：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To check whether the CSV file correctly preserves the missing values and dates,
    we can read the output file in raw text:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 CSV 文件是否正确保留了缺失值和日期，我们可以以纯文本格式读取输出文件：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although the data is correct, sometimes we may have different standards for storing
    such data. The `write.csv()` function allows us to modify the writing behavior.
    From the preceding output, we might think there are some unnecessary components
    in it. For example, we don''t usually want the row names to be exported because
    they seem a bit redundant, since id already does its job. We don''t need the quotation
    marks around string values. We want the missing values to be represented by `-`
    instead of `NA`. To proceed, we can run the following code to export the same
    data frame with the behavior and standard we want:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据是正确的，有时我们可能对存储此类数据有不同的标准。`write.csv()` 函数允许我们修改写入行为。从前面的输出中，我们可能会认为其中有一些不必要的组件。例如，我们通常不希望导出行名，因为它们似乎有点冗余，因为
    id 已经完成了它的任务。我们不需要字符串值周围的引号。我们希望缺失值用 `-` 而不是 `NA` 表示。为了进行下一步，我们可以运行以下代码以以我们想要的特性和标准导出相同的数据框：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, the output data is a simplified CSV file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出数据是一个简化的 CSV 文件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use `readr::read_csv()` to import such a CSV file with customized missing
    values and a date column:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `readr::read_csv()` 导入具有自定义缺失值和日期列的此类 CSV 文件：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that `-` are correctly translated to missing values and the date column
    is correctly imported as date objects too:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`-` 被正确转换为缺失值，日期列也被正确导入为日期对象：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Reading and writing Excel worksheets
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读和编写 Excel 工作表
- en: An import advantage of text-format data such as CSV is software neutrality,
    that is, you don't have to rely on certain software to read the data and the file
    is directly readable by a human. However, its disadvantage is obvious too—we can't
    directly perform calculations on the data represented in a text editor because
    the contents are pure text.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式数据（如 CSV）的一个导入优势是软件中立性，也就是说，你不需要依赖特定的软件来读取数据，文件可以直接由人类阅读。然而，其缺点也很明显——我们无法直接在文本编辑器中对表示在文本编辑器中的数据进行计算，因为内容是纯文本。
- en: Another popular format for storing tabular data is the Excel workbook. An Excel
    workbook contains one or more worksheets. Each worksheet is a grid where you can
    fill in texts and values to make tables. With the tables, you can easily perform
    calculations within a table, between tables, or even across worksheets. Microsoft
    Excel is a powerful software, but its data format (`.xls` for Excel 97-2003 and `.xlsx`
    since Excel 2007) is not directly readable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 存储表格数据的另一种流行格式是 Excel 工作簿。Excel 工作簿包含一个或多个工作表。每个工作表是一个网格，你可以在其中填写文本和值来制作表格。有了表格，你可以在表格内、表格之间，甚至跨工作表轻松地进行计算。Microsoft
    Excel 是一款功能强大的软件，但它的数据格式（`.xls` 用于 Excel 97-2003 和 `.xlsx` 自 Excel 2007 以来）不能直接读取。
- en: 'For example, `data/prices.xlsx` is a simple Excel workbook as shown in the
    following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`data/prices.xlsx` 是一个简单的 Excel 工作簿，如下面的截图所示：
- en: '![Reading and writing Excel worksheets](img/image_07_002.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![阅读和编写 Excel 工作表](img/image_07_002.jpg)'
- en: 'Although no built-in function is provided to read an Excel workbook, several
    R packages are designed to work with it. The simplest one is readxl ([https://github.com/hadley/readxl](https://github.com/hadley/readxl)),
    which makes it much easier to extract the table stored in a single sheet of an
    Excel workbook. To install the package from CRAN, use `install.package("readxl")`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有内置函数可以读取 Excel 工作簿，但有几个 R 包被设计用来与之配合工作。最简单的一个是 readxl ([https://github.com/hadley/readxl](https://github.com/hadley/readxl))，它使得从
    Excel 工作簿的单个工作表中提取表格变得容易得多。要从 CRAN 安装此包，使用 `install.package("readxl")`：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the preceding data frame, it is obvious that `read_excel()` automatically
    translates the dates in Excel to dates in R and correctly preserves the missing
    value in the `Growth` column.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的数据框中可以看出，`read_excel()` 自动将 Excel 中的日期转换为 R 中的日期，并正确保留了 `Growth` 列中的缺失值。
- en: Another package for working with an Excel workbook is `openxlsx`. This package
    can read, write, and edit XLSX files, which is more comprehensive than what `readr`
    is designed for. To install the package, run `install.package("openxlsx")`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于处理 Excel 工作簿的包是 `openxlsx`。此包可以读取、写入和编辑 XLSX 文件，比 `readr` 设计的功能更全面。要安装此包，运行
    `install.package("openxlsx")`。
- en: 'With `openxlsx`, we can call `read.xlsx` to read data from a specified workbook
    into a data frame, just like `readr::read_excel()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `openxlsx`，我们可以调用 `read.xlsx` 从指定的工作簿中读取数据到数据框中，就像 `readr::read_excel()`
    一样：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To ensure that the date values are correctly imported, we need to specify `detectDates
    = TRUE`; otherwise, the dates will be left as numbers as you may try. In addition
    to reading data, `openxlsx` is also able to create a workbook with an existing
    data frame:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保日期值被正确导入，我们需要指定 `detectDates = TRUE`；否则，日期将保留为数字，就像你可能尝试的那样。除了读取数据外，`openxlsx`
    还能够创建包含现有数据框的工作簿：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The package supports more advanced features such as editing an existing workbook
    by creating styles and inserting plots, but these features are beyond the scope
    of this book. For more details, please read the documentation of the package.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该包支持更高级的功能，例如通过创建样式和插入图表来编辑现有工作簿，但这些功能超出了本书的范围。更多详情，请参阅该包的文档。
- en: There are other packages designed for working with Excel workbooks. XLConnect
    ([http://cran.r-project.org/web/packages/XLConnect](http://cran.r-project.org/web/packages/XLConnect))
    is another Excel connector which is cross-platform and does not depend on an existing
    installation of Microsoft Excel, but it does rely on an existing installation
    of Java Runtime Environment (JRE). RODBC ([http://cran.r-project.org/web/packages/RODBC](http://cran.r-project.org/web/packages/RODBC))
    is a more general database connector that is able to connect to Access databases
    and Excel workbooks with properly installed ODBC drivers on Windows. Since these
    two packages have heavier dependencies, we won't introduce them in this session.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他包是为处理 Excel 工作簿而设计的。XLConnect ([http://cran.r-project.org/web/packages/XLConnect](http://cran.r-project.org/web/packages/XLConnect))
    是另一个跨平台的 Excel 连接器，它不依赖于现有的 Microsoft Excel 安装，但确实依赖于现有的 Java 运行时环境 (JRE)。RODBC
    ([http://cran.r-project.org/web/packages/RODBC](http://cran.r-project.org/web/packages/RODBC))
    是一个更通用的数据库连接器，能够在 Windows 上安装了适当的 ODBC 驱动程序后连接到 Access 数据库和 Excel 工作簿。由于这两个包有更重的依赖性，我们不会在本节中介绍它们。
- en: Reading and writing native data files
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入原生数据文件
- en: In the previous sections, we introduced the reader and writer functions of CSV
    files and Excel workbooks. These are non-native data formats to R, that is, there
    is a gap between the original data object and the output file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了 CSV 文件和 Excel 工作簿的读取器和写入器函数。这些是非原生数据格式，即 R 与原始数据对象和输出文件之间存在差距。
- en: For example, if we export a data frame with many columns of different types
    to a CSV file, the information on the column types is discarded. Whether the column
    is numeric, string, or date, it is always represented in text format This certainly
    makes it easier for a human to read the data directly from the output file, but
    we will have to rely on how a computer would guess the type of each column. In
    other words, it is sometimes hard for the reader functions to recover the data
    in CSV format to exactly the same data frame as the original one, since the writing
    process throws the column types away in exchange for portability (for example, other
    software can read the data too).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将具有许多不同类型列的数据框导出到 CSV 文件中，列类型的信息将被丢弃。无论列是数值型、字符串型还是日期型，它总是以文本格式表示。这当然使得人类可以直接从输出文件中读取数据变得更容易，但我们将不得不依赖于计算机如何猜测每列的类型。换句话说，有时读取器函数很难将
    CSV 格式的数据恢复成与原始数据框完全相同的数据，因为写入过程会丢弃列类型以换取可移植性（例如，其他软件也可以读取数据）。
- en: If you do not care for portability and only use R to work with the data, you
    can use the native formats to read and write data. You can no longer uses an arbitrary
    text editor to read the data, nor can you read the data from other software, but
    it is easy to write and read a single object or even the whole environment with
    high efficiency and no data losses. In other words, the native format allows you
    to save objects in file and recover exactly the same data without worrying about
    issues like the symbols of missing values and the types, classes and attributes
    of columns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎可移植性，并且仅使用 R 处理数据，你可以使用原生格式来读取和写入数据。你不能再使用任意文本编辑器来读取数据，也不能从其他软件中读取数据，但可以高效地读写单个对象，甚至整个环境，而不会丢失数据。换句话说，原生格式允许你将对象保存到文件中，并恢复完全相同的数据，无需担心诸如缺失值的符号、列的类型、类和属性等问题。
- en: Reading and writing a single object in native format
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以原生格式读取和写入单个对象
- en: There are two groups of functions related to working with the native data format.
    One group is designed to write a single object to an RDS file or read a single
    object from an RDS file, a file format to store a single R object in serialized
    form. The other group works with multiple R objects, which we will cover in the
    next section. In the following example, we write `some_data` to an RDS file and
    read it from the same file and see whether two data frames are exactly identical.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生数据格式相关的有两组函数。一组是设计用来将单个对象写入 RDS 文件或从 RDS 文件中读取单个对象，这是一种以序列化形式存储单个 R 对象的文件格式。另一组与多个
    R 对象一起工作，我们将在下一节中介绍。在以下示例中，我们将 `some_data` 写入 RDS 文件，并从同一文件中读取它，以查看两个数据框是否完全相同。
- en: 'First, we use `saveRDS` to save `some_data` to `data/some_data.rds`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `saveRDS` 将 `some_data` 保存到 `data/some_data.rds`：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we read the data from the same file and store the data frame in `some_data2`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从同一文件中读取数据，并将数据框存储在 `some_data2` 中：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we use `identical()` to test whether two data frames are exactly the
    same:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `identical()` 测试两个数据框是否完全相同：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two data frames are exactly the same, as supposed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数据框完全相同，正如预期的那样。
- en: 'The native format has two notable advantages: space efficiency and time efficiency.
    In the following example, we will create a large data frame with 200,000 rows
    of random data. Then, we time the process for saving the data frame to a CSV file
    and an RDS file, respectively:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 原生格式有两个显著优点：空间效率和时间效率。在以下示例中，我们将创建一个包含 200,000 行随机数据的大型数据框。然后，我们分别计时将数据框保存到
    CSV 文件和 RDS 文件的过程：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is obvious that `saveRDS` has much higher writing efficiency than `write.csv`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`saveRDS` 的写入效率比 `write.csv` 高得多。
- en: 'Then we use `file.info()` to see the size of the two output files:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `file.info()` 来查看两个输出文件的大小：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The gap between the two file sizes is large—the size of the CSV file is almost
    three times that of the RDS file, indicating that the native format has higher
    storage or space efficiency.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 两个文件大小之间的差距很大——CSV 文件的大小几乎是 RDS 文件的三倍，这表明原生格式具有更高的存储或空间效率。
- en: 'Finally, we read the CSV and RDS files and see how much time both formats consume.
    To read the CSV file, we use both the built-in function `read.csv` and the faster
    implementation, `read_csv()`, provided by the `readr` package:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们读取 CSV 和 RDS 文件，看看这两种格式消耗了多少时间。为了读取 CSV 文件，我们使用了内置函数 `read.csv` 和由 `readr`
    包提供的更快实现 `read_csv()`：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It may be surprising to see that `read_csv()` is almost four times faster than
    the built-in `read.csv()` in this case. But with the native format, the performance
    of both CSV reader functions is not comparable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，看到 `read_csv()` 的速度几乎比内置的 `read.csv()` 快四倍可能会令人惊讶。但使用原生格式，这两个 CSV 读取函数的性能是不可比的：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The native format clearly has much higher writing efficiency.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 原生格式显然具有更高的写入效率。
- en: 'In addition, `saveRDS` and `readRDS` work not only with data frames but also
    with any R object. For example, we create a numeric vector with a missing value
    and a list with a nested structure. Then, we save them in separate RDS files:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`saveRDS` 和 `readRDS` 不仅与数据框一起工作，还可以与任何 R 对象一起工作。例如，我们创建了一个包含缺失值的数值向量和具有嵌套结构的列表。然后，我们将它们分别保存到单独的
    RDS 文件中：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we read the RDS files, and these two objects are exactly recovered, respectively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们读取 RDS 文件，这两个对象分别被完全恢复：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Saving and restoring the working environment
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和恢复工作环境
- en: 'While the RDS format is used to store a single R object, the RData format is
    used to store multiple R objects. We can call `save()` to store `some_data`, `nums`,
    and `list1` together in a single RData file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RDS 格式用于存储单个 R 对象时，RData 格式用于存储多个 R 对象。我们可以调用 `save()` 将 `some_data`、`nums`
    和 `list1` 一起保存到单个 RData 文件中：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To verify that the three objects are stored and can be recovered, we remove
    them first and call `load()` to recover the objects from the file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证三个对象是否已存储并可恢复，我们首先将它们移除，然后调用 `load()` 从文件中恢复对象：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, the three objects are fully recovered:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，三个对象已完全恢复：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Loading built-in datasets
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载内置数据集
- en: In R, there are already a great number of built-in datasets. They can be easily
    loaded and put into use, mostly for demonstration and test purposes. The built-in
    datasets are mostly data frames and come with detailed specifications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，已经存在大量内置数据集。它们可以轻松加载并投入使用，主要用于演示和测试目的。内置数据集大多是数据框，并附带详细说明。
- en: For example, iris and mtcars are probably among the most famous datasets in
    R. You can read the description of the datasets with `? iris` and `? mtcars`,
    respectively. Typically, the description is quite specific—it not only tells you
    what is in the data, how was it collected and formatted, and what each column
    means, but it also provides related sources and references. Reading the description
    helps you know more about the dataset.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，爱丽丝和 mtcars 可能是R中最著名的两个数据集之一。你可以使用 `? iris` 和 `? mtcars` 分别读取数据集的描述。通常，描述非常具体——它不仅告诉你数据中有什么，如何收集和格式化，以及每一列的含义，还提供了相关的来源和参考。阅读描述有助于你更多地了解数据集。
- en: It is extremely handy to conduct experiments on data analysis tools with built-in
    datasets because these datasets are immediately available once R is ready. For
    example, you can directly use iris and mtcars without explicitly loading them
    from somewhere.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在内置数据集上对数据分析工具进行实验非常方便，因为这些数据集一旦R准备好就可以立即使用。例如，你可以直接使用爱丽丝和 mtcars，而无需从某处显式加载它们。
- en: 'The following is the view of the first six rows of iris:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是爱丽丝的前六行视图：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following code shows its structure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了其结构：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The structure of iris is straightforward. You can either print `iris` to see
    the whole data frame in the console or use `View(iris)` in a grid pane or window.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝的结构很简单。你可以通过打印 `iris` 来在控制台查看整个数据框，或者在一个网格面板或窗口中使用 `View(iris)`。
- en: 'To view the first six rows of mtcars and see its structure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 mtcars 的前六行并查看其结构：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, iris and mtcars are small and simple. In fact, most built-in
    datasets only have tens or hundreds of rows and a few columns. They are often
    used to demonstrate the usage of particular data analysis tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，爱丽丝和 mtcars 都很小且简单。实际上，大多数内置数据集只有几十行或几百行，以及几列。它们通常用于演示特定数据分析工具的使用。
- en: If you want to experiment with larger data, you may turn to some R packages
    that come along with datasets. For example, the most famous data visualization
    package, `ggplot2`, provides a dataset called diamonds, which contains the prices
    and other attributes of a large number of diamonds. Use?ggplot2::diamonds to know
    more about the data specification. If you don't have the package installed, run `install.package("ggplot2")`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实验更大的数据，你可以转向一些附带数据集的R包。例如，最著名的数据可视化包 `ggplot2` 提供了一个名为 `diamonds` 的数据集，其中包含大量钻石的价格和其他属性。使用
    `?ggplot2::diamonds` 来了解数据规范。如果你还没有安装该包，运行 `install.package("ggplot2")`。
- en: 'To load the data in the package, we can use `data()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要在包中加载数据，我们可以使用 `data()`：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output shows that diamonds has `53940` rows and `10` columns. Here is a
    preview:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 diamonds 有 `53940` 行和 `10` 列。这里是一个预览：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Besides packages that provide useful functions, there are also packages that
    only provide datasets. For example, nycflights13 and babynames each only contains
    several datasets. The method to load the data in them is exactly the same as the
    previous example. To install the two packages, run `install.package(c("nycflights13",
    "babynames"))`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供有用函数的包之外，还有一些只提供数据集的包。例如，nycflights13 和 babynames 每个都只包含几个数据集。在其中加载数据的方法与前面的例子完全相同。要安装这两个包，运行
    `install.package(c("nycflights13", "babynames"))`。
- en: In the next few sections, we will use these datasets to demonstrate basic graphic
    tools and data analysis tools.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将使用这些数据集来演示基本的图形工具和数据分析工具。
- en: Visualizing data
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据可视化
- en: In the previous section, we introduced a number of functions to import data,
    the first step in most data analysis. It is usually a good practice to look at
    the data before pouring it into a model, so that is what we will do in the next
    step. The reason is simple—different models have different strengths, and no model
    is universally the best choice for all cases since they have a different set of
    assumptions. Arbitrarily applying a model without checking the data against its
    assumptions usually results in misleading conclusions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了一些导入数据的函数，这是大多数数据分析的第一步。通常，在将数据倒入模型之前查看数据是一个好的做法，这就是我们下一步要做的。原因很简单——不同的模型有不同的优势，而且没有哪个模型是所有情况下都最佳的选择，因为它们有不同的假设集。在没有检查数据是否符合其假设的情况下任意应用模型通常会导致误导性的结论。
- en: An initial way to choose a model and perform such checks is to just visually
    examine the data by looking at its boundaries and patterns. In other words, we
    need to visualize the data first. In this section, you will learn the basic graphic
    functions to produce simple charts to visualize a given dataset.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个模型并进行此类检查的一种初始方法是通过观察数据的边界和模式来直观地检查数据。换句话说，我们首先需要可视化数据。在本节中，你将学习基本图形函数来生成简单的图表以可视化给定的数据集。
- en: 'We will use the datasets in the `nycflights13` and `babynames` packages. If
    you don''t have them installed, run the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nycflights13`和`babynames`包中的数据集。如果您还没有安装它们，请运行以下代码：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating scatter plots
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建散点图
- en: 'In R, the basic function to visualize data is `plot()`. If we simply provide
    a numeric or integer vector to `plot()`, it will produce a scatter plot of value
    by index. For example, the following code creates a scatter plot of 10 points
    in the increasing order:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，可视化数据的基本函数是`plot()`。如果我们仅仅向`plot()`提供一个数值或整数向量，它将根据索引生成值的散点图。例如，以下代码创建了一个按递增顺序排列的10个点的散点图：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The plot generated is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating scatter plots](img/image_07_003.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![创建散点图](img/image_07_003.jpg)'
- en: 'We can create a more realistic scatter plot by generating two linearly correlated
    random numeric vectors:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过生成两个线性相关的随机数值向量来创建一个更逼真的散点图：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The plot generated is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating scatter plots](img/image_07_004.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![创建散点图](img/image_07_004.jpg)'
- en: Customizing chart elements
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义图表元素
- en: 'In a plot, there are numerous chart elements that can be customized. The most
    common elements to be specified are the title (main or `title()`), the label of
    the *x* axis (`xlab`), the label of the *y* axis (`ylab`), the range of the *x*
    axis (`xlim`), and the range of the *y* axis (`ylim`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表中，有许多可以自定义的图表元素。最常见的是标题（主标题或`title()`）、`x`轴的标签（`xlab`）、`y`轴的标签（`ylab`）、`x`轴的范围（`xlim`）和`y`轴的范围（`ylim`）：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The plot generated is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Customizing chart elements](img/image_07_005.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![自定义图表元素](img/image_07_005.jpg)'
- en: 'The chart title can be specified by either the main argument or a separate `title()`
    function call. Therefore, the preceding code is equivalent to the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图表标题可以通过`main`参数或单独的`title()`函数调用来指定。因此，前面的代码等同于以下代码：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Customizing point styles
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义点样式
- en: 'The default point style of a scatter plot is a circle. By specifying the `pch`
    argument (plotting character), we can change the point style. There are 26 point
    styles available:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图默认的点样式是圆圈。通过指定`pch`参数（绘图字符），我们可以更改点样式。共有26种点样式可供选择：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Customizing point styles](img/image_07_006.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点样式](img/image_07_006.jpg)'
- en: The preceding code produces a scatter plot of all point styles available with
    the corresponding `pch` numbers printed beside. First, `plot()` creates a simple
    scatter plot, and then `text()` prints the `pch` numbers on the right side of
    each point.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了一个包含所有可用点样式及其相应`pch`编号的散点图。首先，`plot()`创建了一个简单的散点图，然后`text()`在每个点的右侧打印`pch`编号。
- en: 'Like many other built-in functions, `plot()` is vectorized with respect to `pch`
    and several other arguments. It makes it possible to customize the style of each
    point in the scatter plot. For example, the simplest case is that we use only
    one non-default point style for all points by setting `pch = 16`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他内置函数一样，`plot()`在`pch`和几个其他参数上进行了向量化。这使得我们可以自定义散点图中每个点的样式。例如，最简单的情况是我们通过设置`pch
    = 16`为所有点使用一个非默认的点样式：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The plot generated is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Customizing point styles](img/image_07_007.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点样式](img/image_07_007.jpg)'
- en: 'Sometimes, we need to distinguish two groups of points by a logical condition.
    Knowing that `pch` is vectorized, we can use `ifelse()` to specify the point style
    of each observation by examining whether a point satisfies the condition. In the
    following example, we want to apply `pch = 16` to the points satisfying `x * y
    > 1` otherwise, `pch = 1`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要通过逻辑条件来区分两组点。知道`pch`是向量化的，我们可以使用`ifelse()`函数通过检查一个点是否满足条件来指定每个观察值的点样式。在下面的例子中，我们希望将`pch
    = 16`应用于满足`x * y > 1`条件的点，否则使用`pch = 1`：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The plot generated is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Customizing point styles](img/image_07_009.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点样式](img/image_07_009.jpg)'
- en: 'We can also draw the points in two separate datasets that share the same x
    axis using `plot()` and `points()`. In the previous example, we generated a normally
    distributed random vector `x` and a linearly correlated random vector `y`. Now,
    we generate another random vector `z` that has a non-linear relationship with `x`
    and plot both `y` and `z` against `x` but with different point styles:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `plot()` 和 `points()` 在两个共享相同x轴的不同数据集中绘制点。在先前的例子中，我们生成了一个正态分布的随机向量 `x`
    和一个线性相关的随机向量 `y`。现在，我们生成另一个与 `x` 具有非线性关系的随机向量 `z`，并将 `y` 和 `z` 分别与 `x` 绘制，但使用不同的点样式：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The plot generated is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Customizing point styles](img/image_07_010.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点样式](img/image_07_010.jpg)'
- en: After we generate `z`, we create a plot of `x` and `y` first, and then add another
    group of points `z` with a different `pch`. Note that if we don't specify `ylim
    = range(y, z)`, the plot builder will only consider the range of `y`, and the
    *y* axis may have a range narrower than the range of `z`. Unfortunately, `points()`
    does not automatically lengthen the axes created by `plot()`, therefore any point
    beyond the axes' range will disappear. The preceding code sets an appropriate
    range of *y* axis so that all points in `y` and `z` can be shown in the plot area.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成 `z` 后，首先创建 `x` 和 `y` 的图形，然后添加另一组具有不同 `pch` 的点 `z`。请注意，如果我们不指定 `ylim =
    range(y, z)`，绘图构建器将只考虑 `y` 的范围，因此 *y* 轴的范围可能比 `z` 的范围窄。不幸的是，`points()` 并不会自动扩展由
    `plot()` 创建的轴，因此任何超出轴范围的点将消失。前面的代码设置了一个合适的 *y* 轴范围，以便在绘图区域内显示 `y` 和 `z` 中的所有点。
- en: Customizing point colors
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义点颜色
- en: 'If the graphics are not limited to gray-scale printing, we may also use different
    point colors by setting the column of `plot()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图形不受灰度打印的限制，我们还可以通过设置 `plot()` 的列来使用不同的点颜色：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The plot generated is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Customizing point colors](img/image_07_011.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点颜色](img/image_07_011.jpg)'
- en: 'Like `pch`, `col` is also a vectorized argument. With the same method, we can
    apply different colors to separate points into two different categories depending
    on whether they satisfy a certain condition:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `pch` 一样，`col` 也是一个向量化参数。使用相同的方法，我们可以根据是否满足某个条件，将不同的颜色应用到不同的点上，将它们分为两个不同的类别：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The plot generated is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Customizing point colors](img/image_07_012.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点颜色](img/image_07_012.jpg)'
- en: Note that if the scatter plot is printed grayscale, the colors can only be viewed
    as different intensities of grayness.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果散点图以灰度打印，颜色只能以不同灰度的强度来查看。
- en: 'Also, we can use `plot()` and `points()` again, but with different `col` to
    distinguish different groups of points:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以再次使用 `plot()` 和 `points()`，但使用不同的 `col` 来区分不同组别的点：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The plot generated is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Customizing point colors](img/image_07_013.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![自定义点颜色](img/image_07_013.jpg)'
- en: R supports commonly used color names and many others (657 in total). Call `colors()`
    to get a full list of colors supported by R.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: R支持常用的颜色名称以及许多其他颜色（总共657种）。通过调用 `colors()` 获取R支持的所有颜色列表。
- en: Creating line plots
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建线图
- en: 'For time series data, line plots are more useful to demonstrate the trend and
    variation across time. To create line plots, we only need to set `type = "l"`
    when calling `plot()`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间序列数据，线图更有助于展示随时间的变化趋势和变化。要创建线图，我们只需要在调用 `plot()` 时设置 `type = "l"`：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The plot generated is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Creating line plots](img/image_07_014.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![创建线图](img/image_07_014.jpg)'
- en: Customizing line type and width
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义线型和宽度
- en: 'Just like `pch` for scatter plot, `lty` is used to specify the line type of
    a line plot. The following shows a preview of six line types supported by R:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就像散点图的 `pch` 一样，`lty` 用于指定线图的线型。以下展示了R支持的六种线型预览：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The plot generated is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图形如下：
- en: '![Customizing line type and width](img/image_07_015.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![自定义线型和宽度](img/image_07_015.jpg)'
- en: The preceding code creates an empty canvas with `type = "n"` with proper axes
    ranges and turns off axes, and another label `elements.abline()` is used to draw
    the horizontal lines with different line types but of equal line width (`lwd =
    2`). The `mtext()` function is used to draw the text on the margin. Note that `abline()`
    and `mtext()` are vectorized with respect to their arguments so that we don't
    need a `for` loop  to draw each line and margin text in turn.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个带有`type = "n"`的空画布，具有适当的坐标轴范围，并关闭了坐标轴，另一个标签`elements.abline()`用于绘制具有不同线型但相同线宽（`lwd
    = 2`）的水平线。`mtext()`函数用于在边缘绘制文本。请注意，`abline()`和`mtext()`在它们的参数上是向量化的，因此我们不需要使用`for`循环依次绘制每条线和边缘文本。
- en: 'The following example demonstrates how `abline()` can be useful to draw auxiliary
    lines in a plot. First, we create a line plot of `y` with time, `t`, which we
    defined before we created the first line plot a moment ago. Suppose we also want
    the plot to show the mean value and the range of `y` along with the time at which
    the maximal and minimal values appear. With `abline()`, we can easily draw these
    auxiliary lines with different line types and colors to avoid ambiguity:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了`abline()`如何有助于在图表中绘制辅助线。首先，我们创建了一个`y`与时间`t`的线图，这是我们之前创建第一个线图时定义的。假设我们还想让图表显示`y`的均值和范围，以及最大值和最小值出现的时间。使用`abline()`，我们可以轻松地用不同类型和颜色的线绘制这些辅助线，以避免歧义：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The plot generated is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Customizing line type and width](img/image_07_016.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![自定义线型和宽度](img/image_07_016.jpg)'
- en: Plotting lines in multiple periods
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多周期折线图绘制
- en: 'Another kind of line plot in which different line types are mixed is a multi-period
    line plot. A typical form is that the first period is historic data and the second
    period is predictions. Suppose the first period of `y` includes the first 40 observations
    and the remaining points are predictions based on the historic data. We want to
    use solid lines to represent the historic data and dashed lines for the predictions.
    Here, we plot the data in the first period and add dashed `lines()` for the data
    in the second period of the plot. Note that `lines()` is to a line plot as `points()`
    is to a scatter plot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种混合不同线型的折线图是多周期折线图。典型形式是第一个周期是历史数据，第二个周期是预测数据。假设`y`的第一个周期包含前40个观测值，其余点是基于历史数据的预测。我们希望用实线表示历史数据，用虚线表示预测。在这里，我们绘制第一个周期的数据，并为图表的第二周期添加虚线`lines()`。请注意，`lines()`对于折线图就像`points()`对于散点图：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The plot generated is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Plotting lines in multiple periods](img/image_07_017.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![多周期折线图绘制](img/image_07_017.jpg)'
- en: Plotting lines with points
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用点和线绘制折线图
- en: 'Sometimes, it is useful to plot both lines and points in the same chart to
    emphasize that the observations are discrete or simply make the chart clearer.
    The method is simple, just plot a line chart and add `points()` of the same data
    to the plot again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在同一张图表中绘制线和点很有用，以强调观测值是离散的，或者简单地使图表更清晰。方法是简单的，只需绘制一个折线图，并将相同数据的`points()`再次添加到图表中：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The plot generated is shown as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Plotting lines with points](img/image_07_018.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![带有点的折线图绘制](img/image_07_018.jpg)'
- en: 'An equivalent way to do this is to plot a scatter chart first using the `plot()`
    function and then add lines using the `lines()` function of the same data to the
    plot again. Therefore, the following code should produce exactly the same graphics
    as the previous example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作的另一种方法是首先使用`plot()`函数绘制散点图，然后使用相同数据的`lines()`函数再次将线添加到图表中。因此，以下代码应产生与上一个示例完全相同的图形：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Plotting a multi-series chart with a legend
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制带有图例的多序列图表
- en: The full version of a multi-series chart should include multiple series represented
    by lines and points, and a legend to illustrate the series in the chart.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的多序列图表应包括由线和点表示的多个序列，以及一个图例来说明图表中的序列。
- en: 'The following code randomly generates two series, `y` and `z`, with time, `x`,
    and creates a chart with these put together:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码随机生成两个时间序列`y`和`z`，以及时间`x`，并将这些数据组合在一起创建图表：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The plot generated is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Plotting a multi-series chart with a legend](img/image_07_019.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![带有图例的多序列图表绘制](img/image_07_019.jpg)'
- en: The preceding code uses `plot()` to create the line-point chart of `y` and adds
    the `lines()` and `points()` of `z`. In the end, we add a `legend()` on the top
    left to demonstrate the line and point styles of `y` and `z`, respectively. Note
    that `cex` is used to scale the font sizes of the legend and `x.intersp` and `y.intersp`
    are used for minor adjustments to the legend.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `plot()` 创建 `y` 的线点图，并添加了 `z` 的 `lines()` 和 `points()`。最后，我们在左上角添加了一个
    `legend()` 来展示 `y` 和 `z` 的线条和点样式，注意 `cex` 用于调整图例的字体大小，而 `x.intersp` 和 `y.intersp`
    用于对图例进行细微调整。
- en: 'Another useful type of line plot is step-lines. We use `type = "s"` in `plot()` and `lines()`
    to create a step-line plot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的折线图类型是阶梯线图。我们在 `plot()` 和 `lines()` 中使用 `type = "s"` 来创建阶梯线图：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The plot generated is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Plotting a multi-series chart with a legend](img/image_07_020.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![绘制带有图例的多系列图表](img/image_07_020.jpg)'
- en: Creating bar charts
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建条形图
- en: In the previous sections, you learned how to create scatter plots and line plots.
    There are several other types of charts that are useful and worth mentioning.
    Bar charts are among the most commonly used ones. The height of bars in a bar
    chart can make a constrast quantitatively between different categories.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何创建散点图和折线图。还有一些其他类型的图表很有用，值得提及。条形图是最常用的之一。条形图的高度可以在不同类别之间进行定量的对比。
- en: 'The simplest bar chart we can create is the following one. Here, we use `barplot()`
    instead of `plot()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的最简单的条形图如下。在这里，我们使用 `barplot()` 而不是 `plot()`：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The plot generated is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating bar charts](img/image_07_021.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![创建条形图](img/image_07_021.jpg)'
- en: 'If the numeric vector has names, the names will automatically be the names
    on the *x* axis. Therefore, the following code will produce exactly the same bar
    chart as the previous one:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数值向量有名称，则名称将自动成为 *x* 轴上的名称。因此，以下代码将产生与上一个图表完全相同的条形图：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The making of a bar chart looks so easy. Now that we have the flights dataset
    in `nycflights13`, we can create a bar plot of the top eight carriers with the
    most flights in the record:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 制作条形图看起来很简单。现在我们有了 `nycflights13` 中的航班数据集，我们可以创建记录中最常飞行的前八个承运人的条形图：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code, `table()` is used to count the number of flights in
    the record for each carrier:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`table()` 用于计算每个承运人在记录中的航班数量：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As shown in the preceding code, the carriers are sorted in descending order.
    We can take the first `8` elements out of the table and make a bar plot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，承运人按降序排列。我们可以从表中取出前 `8` 个元素，并制作一个条形图：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The plot generated is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating bar charts](img/image_07_022.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![创建条形图](img/image_07_022.jpg)'
- en: Creating pie charts
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建饼图
- en: 'Another useful chart is the pie chart. The function to create a pie chart,
    `pie()`, works in a way similar to `barplot()`. It works with a numeric vector
    with labels specified; it also works directly with a named numeric vector. The
    following code is a simple example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的图表是饼图。创建饼图的函数 `pie()` 的工作方式与 `barplot()` 类似。它使用带有标签的数值向量；它也可以直接与命名数值向量一起使用。以下是一个简单的示例：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The plot generated is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating pie charts](img/image_07_023.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![创建饼图](img/image_07_023.jpg)'
- en: Creating histogram and density plots
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建直方图和密度图
- en: Previously, you learned how to create several different types of charts. Scatter
    plots and line plots are direct illustrations of the observations in a dataset.
    Bar charts and pie charts are usually used to show a rough summary of data points
    in different categories.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了如何创建几种不同类型的图表。散点图和折线图是数据集中观察的直接展示。条形图和饼图通常用于展示不同类别数据点的粗略总结。
- en: 'They are two limitations to plots: scatter plots and line plots convey too
    much information and are difficult to draw insights from, while bar charts and
    pie charts drop too much information, so with these too it can be difficult to
    make a conclusive judgement with confidence.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图表有两个限制：散点图和折线图传达了过多的信息，难以从中得出见解，而条形图和饼图则丢失了过多的信息，因此使用这些图表时也难以自信地得出结论。
- en: 'A histogram shows the distribution of a numeric vector, and it summarizes the
    information in the data without dropping too much and thus can be easier to make
    use of. The following example demonstrates how to use `hist()` to produce a histogram
    of a normally distributed random numeric vector and the density function of normal
    distribution:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图显示了数值向量的分布，它总结了数据中的信息，而没有丢失太多，因此更容易使用。以下示例演示了如何使用 `hist()` 生成正态分布的随机数值向量的直方图和正态分布的密度函数：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The plot generated is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating histogram and density plots](img/image_07_024.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![创建直方图和密度图](img/image_07_024.jpg)'
- en: 'By default, the *y* axis of a histogram is the frequency of the value in the
    data. We can verify that the histogram is quite close to the standard normal distribution
    from which `random_normal` was generated. To overlay the curve of a probability
    density function of the standard normal distribution, `dnorm()`, we need to ensure
    that the *y* axis of the histogram is a probability and the curve is to be added
    to the histogram:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，直方图的 *y* 轴是数据中值的频率。我们可以验证直方图与从 `random_normal` 生成的标准正态分布非常接近。为了叠加标准正态分布概率密度函数的曲线
    `dnorm()`，我们需要确保直方图的 *y* 轴是概率，并且曲线要添加到直方图上：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The plot generated is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating histogram and density plots](img/image_07_025.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: 生成的图表如下：
- en: 'Now, let''s make a histogram of the speed of an aircraft in flight. Basically,
    the average speed of an aircraft in a trip is the distance of the trip (`distance`)
    divided by the air time (`air_time`):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制飞行中飞机速度的直方图。基本上，飞机在旅行中的平均速度是旅行距离（`distance`）除以飞行时间（`air_time`）：
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The plot generated is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建直方图和密度图](img/image_07_025.jpg)'
- en: '![Creating histogram and density plots](img/image_07_026.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: 生成的图表如下：
- en: 'The histogram seems a bit different from a normal distribution. In this case,
    we use `density()` to estimate an empirical distribution of the speed, plot a
    pretty smooth probability distribution curve out of it, and add a vertical line
    to indicate the global average of all observations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图似乎与正态分布略有不同。在这种情况下，我们使用 `density()` 来估计速度的经验分布，从中绘制出平滑的概率分布曲线，并添加一条垂直线来指示所有观察值的全局平均值：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The plot generated is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating histogram and density plots](img/image_07_027.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![创建直方图和密度图](img/image_07_027.jpg)'
- en: 'Just like the first histogram and curve example, we can combine the two graphics
    together to get a better view of the data:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第一个直方图和曲线示例一样，我们可以将两个图形结合起来，以获得更好的数据视图：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The plot generated is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating histogram and density plots](img/image_07_028.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![创建直方图和密度图](img/image_07_028.jpg)'
- en: Creating box plots
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建箱线图
- en: 'Histograms and density plots are two ways to demonstrate the distribution of
    data. Usually, we only need several critical quantiles to get an impression of
    the whole distribution. The box plot (or box-and-whisker plot) is a simple way
    to do this. For a randomly generated numeric vector, we can call `boxplot()` to
    draw a box plot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图和密度图是展示数据分布的两种方式。通常，我们只需要几个关键分位数就能对整个分布有一个印象。箱线图（或箱线图）是一种简单的方法来做这件事。对于随机生成的数值向量，我们可以调用
    `boxplot()` 来绘制箱线图：
- en: '[PRE66]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The plot generated is as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating box plots](img/image_07_029.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![创建箱线图](img/image_07_029.jpg)'
- en: 'A box plot contains several components to show critical quartile levels of
    data as well as outliers. The following image clearly explains what a box plot
    means:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图包含几个组成部分，用于显示数据的临界四分位数水平和异常值。以下图像清楚地解释了箱线图的意义：
- en: '![Creating box plots](img/image_07_030.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![创建箱线图](img/image_07_030.jpg)'
- en: 'The following code draws a box plot of the flight speed for each carrier. There
    will be 16 boxes in one chart, making it easier to roughly compare the distribution
    of different carriers. To proceed, we use the formula *distance /air_time ~carrier*
    to indicate that the *y* axis denotes the flight speed computed from *distance
    / air_time*, and the *x *axis denotes the carrier. With this representation, we
    have the following box plot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码绘制了每个航空公司的飞行速度箱线图。一张图表中将有16个箱子，这使得粗略比较不同航空公司的分布变得更容易。为了进行，我们使用公式 *distance
    / air_time ~carrier* 来表示 *y* 轴表示从 *distance / air_time* 计算出的飞行速度，而 *x* 轴表示航空公司。通过这种表示，我们得到以下箱线图：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The plot generated is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Creating box plots](img/image_07_031.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![创建箱线图](img/image_07_031.jpg)'
- en: Note that we use the formula interface of creating graphics in `boxplot()`.
    Here, *distance / air_time ~ carrier* basically means the *y* axis should represent
    the values of *distance / air_time*, that is, flight speed, and the *x* axis should
    represent different carriers. *data = flights* tells *boxplot()* where to find
    the symbols in the formula we specify. As a result, the box plot of flight speed
    is created and grouped by carrier.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`boxplot()`中使用创建图形的公式界面。在这里，`distance / air_time ~ carrier`基本上意味着*y*轴应该表示`distance
    / air_time`的值，即飞行速度，而*x*轴应该表示不同的运营商。`data = flights`告诉`boxplot()`在哪里找到我们指定的公式中的符号。因此，飞行速度的箱线图被创建并按运营商分组。
- en: The formula interface of visualizing and analyzing data is very expressive and
    powerful. In the next section, we will introduce some basic tools and models to
    analyze data. Behind the functions that implement these tools and models are not
    only algorithms but also a user-friendly interface (formula) to make it easier
    to specify relationships for the model to fit.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化和分析公式界面非常表达性和强大。在下一节中，我们将介绍一些基本工具和模型来分析数据。实现这些工具和模型的函数背后不仅包含算法，还有一个用户友好的界面（公式），以便更容易地指定模型拟合的关系。
- en: 'There are also other packages that are specially tailored for data visualization.
    One great example is `ggplot2`, which implements a very powerful grammar of graphics
    to create, compose, and customize different types of charts. However, it is beyond
    the scope of this book. To know more, I recommend that you read *ggplot2: Elegant
    Graphics for Data Analysis* by Hadley Wickham.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '还有其他专门针对数据可视化的包。一个很好的例子是`ggplot2`，它实现了一种非常强大的图形语法，用于创建、组合和自定义不同类型的图表。然而，这超出了本书的范围。要了解更多信息，我建议您阅读Hadley
    Wickham的《ggplot2: Elegant Graphics for Data Analysis》。'
- en: Analyzing data
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析
- en: In practical data analysis, most time is spent on data cleansing, that is, to
    filter and transform the original data (or raw data) to a form that is easier
    to analyze. The filtering and transforming process is also called data manipulation.
    We will dedicate an entire chapter to this topic.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际数据分析中，大部分时间都花在数据清洗上，即过滤和转换原始数据（或原始数据）到一个更容易分析的形式。过滤和转换过程也称为数据处理。我们将专门用一章来介绍这个主题。
- en: In this section, we directly assume that the data is ready for analysis. We
    won't go deep into the models, but will apply some simple models to leave you
    an impression of how to fit a model with data, how to interact with fitted models,
    and how to apply a fitted model to make predictions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们直接假设数据已经准备好进行分析。我们不会深入探讨模型，而是应用一些简单的模型，让您了解如何用数据拟合模型，如何与拟合的模型交互，以及如何将拟合的模型应用于预测。
- en: Fitting a linear model
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拟合线性模型
- en: 'The simplest model in R is the linear model, that is, we use a linear function
    to describe the relationship between two random variables under a certain set
    of assumptions. In the following example, we will create a linear function that
    maps *x*to *3 + 2 * x*. Then we generate a normally-distributed random numeric
    vector `x`, and generate `y` by `f(x)` plus some independent noise:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: R中最简单的模型是线性模型，即我们使用线性函数来描述在一定假设下两个随机变量之间的关系。在以下示例中，我们将创建一个将*x*映射到`3 + 2 * x`的线性函数。然后我们生成一个正态分布的随机数值向量`x`，并通过`f(x)`加上一些独立噪声生成`y`：
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we pretend not to know how `y` is generated by `x`, can we use a linear
    model to recover their relationship, that is, to recover the coefficient of the
    linear function? The following code uses `slm()` to fit `x` and `y` with a linear
    model. Note that a formula *y ~ x* is an accessible representation to tell `m()`
    that the linear regression is between the dependent variable `y` and a single
    regressor `x`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假装不知道`y`是如何由`x`生成的，我们能否使用线性模型来恢复它们之间的关系，即恢复线性函数的系数？以下代码使用`slm()`拟合`x`和`y`的线性模型。请注意，公式`y
    ~ x`是向`m()`传达线性回归是因变量`y`和单个回归变量`x`之间关系的一种可访问表示：
- en: '[PRE69]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The true coefficients are 3 (intercept) and 2 (slope), and with the sample data
    `x` and `y`, the fitted model has coefficients `2.9692146` (intercept) and `1.9716588`
    (slope), which are quite close to the true coefficients.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的系数是3（截距）和2（斜率），并且使用样本数据`x`和`y`，拟合的模型具有系数`2.9692146`（截距）和`1.9716588`（斜率），这两个系数非常接近真实的系数。
- en: 'We store the model in `model1`. To access the coefficients of the model, we
    can use the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模型存储在`model1`中。要访问模型的系数，我们可以使用以下代码：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Alternatively, we can use the `model1$` coefficients, since `model1` is essentially
    a list.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`model1$`系数，因为`model1`本质上是一个列表。
- en: 'Then, we can call `summary()` to know more about the statistical properties
    of the linear model:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`summary()`来了解更多关于线性模型的统计特性：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To interpret the summary, you had better review the chapter on linear regression
    in one or two textbooks of statistics. The following plot puts the data and the
    fitted model together:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要解释摘要，你最好复习一下统计学教材中关于线性回归的章节。下面的图表将数据和拟合模型放在一起：
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The plot generated is shown as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![Fitting a linear model](img/image_07_032.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![拟合线性模型](img/image_07_032.jpg)'
- en: In the preceding code, we directly supply a two-element numeric vector of estimated
    regression coefficients to `abline()`, so it smartly draws the regression line
    as supposed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们直接向`abline()`提供一个包含估计回归系数的两个元素的数值向量，因此它智能地绘制了回归线。
- en: 'Then, we can call `predict()` to use the fitted model to make predictions.
    To predict `y` with standard errors when `x = -1` and `x = 0.5`, run the following
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`predict()`来使用拟合的模型进行预测。当`x = -1`和`x = 0.5`时，预测`y`并带有标准误差，请运行以下代码：
- en: '[PRE73]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The prediction result is a list of predicted values of `y` (`$fit`), the standard
    errors of the fitted values (`$se.fit`), the degree of freedom (`$df`), and `$residual.scale`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 预测结果是`y`的预测值列表（`$fit`）、拟合值的标准误差（`$se.fit`）、自由度（`$df`）和`$residual.scale`。
- en: Now that you know the basics of how to fit a linear model given some data, it
    is time to look at some real-world data. In the following examples, we try to
    predict the air time of a flight using linear models of different complexity.
    The most obvious variable that should be helpful to predict air time is distance.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何根据一些数据拟合线性模型的基本方法，是时候看看一些现实世界的数据了。在下面的例子中，我们尝试使用不同复杂度的线性模型来预测航班的飞行时间。对于预测飞行时间来说，最明显的有帮助的变量是距离。
- en: 'First, we load the dataset and make a scatter plot of distance and `air_time`.
    We use `pch = "."` to make each point very small, since the number of records
    in the dataset is large:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载数据集并绘制距离和`飞行时间`的散点图。我们使用`pch = "."`来使每个点非常小，因为数据集中的记录数量很大：
- en: '[PRE74]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The plot generated is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Fitting a linear model](img/image_07_033.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![拟合线性模型](img/image_07_033.jpg)'
- en: The plot clearly suggests that distance and `air_time` has a positive correlation.
    So, it is reasonable to fit a linear model between the two variables.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图表清楚地表明距离和`飞行时间`之间存在正相关关系。因此，在两个变量之间拟合线性模型是合理的。
- en: 'Before pouring the whole dataset into a linear model, we divide the dataset
    into two parts: a training set and a testing set. The purpose of dividing the
    dataset is that we want to perform not only sample evaluation but also out-of-sample
    evaluation of the model. More specifically, we put 75% of the data to the training
    set, and the remaining 25% of data to the testing set. In the following code,
    we use `sample()` to draw a random sample of 75% records from the original data
    and use `setdiff()` to get the rest of the records:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在将整个数据集放入线性模型之前，我们将数据集分为两部分：一个训练集和一个测试集。划分数据集的目的是我们不仅想要进行样本评估，还想要进行模型的外部样本评估。更具体地说，我们将75%的数据放入训练集，剩余的25%数据放入测试集。在下面的代码中，我们使用`sample()`从原始数据中抽取75%的随机样本，并使用`setdiff()`获取剩余的记录：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note that `setdiff(rows_id, sample_id)` returns the indices in `rows_id` but
    not in `sample_id`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setdiff(rows_id, sample_id)`返回`rows_id`中但不在`sample_id`中的索引。
- en: 'Now `flights_train` is the training set and `flights_test` is the testing set.
    With the divided datasets, the procedure of model fitting and model evaluation
    is straightforward. First, use the training set to fit the model, then make an
    in-sample prediction to see the magnitude of the in-sample errors:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`flights_train`是训练集，而`flights_test`是测试集。有了划分的数据集，模型拟合和模型评估的过程就变得简单直接。首先，使用训练集来拟合模型，然后进行样本预测以查看样本误差的大小：
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To evaluate the magnitude of the errors, we define a function named `evaluate_error()`
    to calculate the mean absolute errors and the standard deviation of errors:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估误差的大小，我们定义了一个名为`evaluate_error()`的函数来计算平均绝对误差和误差的标准差：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Using this function, we can evaluate the errors of the in-sample predictions
    of `model2`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以评估`model2`的样本预测误差：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The absolute mean errors indicate that on average the prediction deviates from
    the correct value by around 9.45 minutes in absolute value and has a standard
    deviation of 12.8 minutes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对平均误差表明，平均而言，预测值与正确值在绝对值上偏差约为9.45分钟，标准差为12.8分钟。
- en: 'Then, we perform a simple out-of-sample evaluation by using the model to predict
    on the testing set:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用模型对测试集进行预测来执行一个简单的样本外评估：
- en: '[PRE79]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The prediction results in a numeric vector of predicted values. Both the absolute
    mean errors and the standard deviation of errors go up slightly, which suggests
    that the quality of the out-of-sample prediction does not get significantly worse,
    indicating that `model2` does not seem to be a result of overfitting.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 预测结果是一个包含预测值的数值向量。绝对平均误差和误差的标准差略有上升，这表明样本外预测的质量没有显著变差，表明`model2`似乎不是过拟合的结果。
- en: 'Since `model2` has only one regressor, `distance`, it is natural to consider
    whether more regressors would improve the prediction. The following code fits
    a new linear model with not only distance but also `carrier`, `month` and departure
    time (`dep_time`) as regressors:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`model2`只有一个回归器，即`distance`，因此考虑是否更多的回归器会提高预测质量是自然的。以下代码拟合了一个新的线性模型，不仅包括距离，还包括`carrier`、`month`和出发时间(`dep_time`)作为回归器：
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The in-sample errors are slightly lower in both magnitude and variation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 样本内误差在幅度和变化上都有所降低：
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Also, the out-of-sample errors looks slightly better than `model2`. To compare
    the distribution of out-of-sample errors before and after adding new regressors
    to the linear model, we overlay the two density curves:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，样本外误差看起来略好于`model2`。为了比较在将新回归器添加到线性模型之前和之后样本外误差的分布，我们叠加了两个密度曲线：
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The plot generated is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下：
- en: '![Fitting a linear model](img/image_07_034.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![拟合线性模型](img/image_07_034.jpg)'
- en: From the preceding density plot, the improvement from `model2` to `model3` is
    too small to notice, that is, there's no significant improvement at all.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的密度图中可以看出，从`model2`到`model3`的改进非常小，几乎无法察觉，也就是说，没有任何显著的改进。
- en: Fitting a regression tree
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拟合回归树
- en: In this section, we try another model to fit the data. The model is called a **regression
    tree** ([https://en.wikipedia.org/wiki/Decision_tree_learning](https://en.wikipedia.org/wiki/Decision_tree_learning))
    and is one of the machine learning models. It is not a simple linear regression,
    but uses a decision tree to fit the data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们尝试使用另一个模型来拟合数据。该模型被称为**回归树** ([https://en.wikipedia.org/wiki/Decision_tree_learning](https://en.wikipedia.org/wiki/Decision_tree_learning))，是机器学习模型之一。它不是简单的线性回归，而是使用决策树来拟合数据。
- en: 'Suppose we want to predict the daily air quality (`Ozone`) according to solar
    radiation (`Solar.R`), average wind speed (`Wind`), and maximum daily temperature
    (`Temp`), the built-in dataset `airquality` being the training set. The following
    graph illustrates how a fitted regression tree works:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要根据太阳辐射(`Solar.R`)、平均风速(`Wind`)和最高日温度(`Temp`)预测每日空气质量(`Ozone`)，内置数据集`airquality`作为训练集。以下图表说明了拟合回归树的工作原理：
- en: '![Fitting a regression tree](img/image_07_035.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![拟合回归树](img/image_07_035.jpg)'
- en: In the tree, each circle represents a question which has two possible answers.
    To predict `Ozone`, we need to ask questions along the tree from top to bottom
    where each observation lies in one of the bottom cases. Each node at the bottom
    has a distribution different from the others, which is illustrated by a box plot.
    The median or mean in each box should be reasonable predictions for each case.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中，每个圆圈代表一个问题，有两个可能的答案。为了预测`Ozone`，我们需要从上到下沿着树提问，每个观测值位于底部的某个案例中。每个底部的节点都有一个与其他节点不同的分布，这通过箱线图表示。每个箱子中的中位数或平均值应该是每个案例的合理预测。
- en: There are a number of packages that implement decision tree learning algorithms.
    In this section, we use a simple package called party ([https://cran.r-project.org/web/packages/party](https://cran.r-project.org/web/packages/party)).
    If you don't have it installed yet, run `install.package("party")`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多软件包实现了决策树学习算法。在本节中，我们使用一个名为 party ([https://cran.r-project.org/web/packages/party](https://cran.r-project.org/web/packages/party))
    的简单软件包。如果您还没有安装它，请运行 `install.package("party")`。
- en: 'Now we use the same formula and data to train a regression tree model. Note
    that we took a subset of the data where there is no missing value of `air_time` because `ctree`
    does not accept missing values in a response variable:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用相同的公式和数据来训练一个回归树模型。请注意，我们选取了没有`air_time`缺失值的数据子集，因为`ctree`不接受响应变量中的缺失值：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'It looks like `model4` performs better than `model3`. Then, we take a look
    at its out-of-sample performance:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`model4`的表现优于`model3`。然后，我们来看看它的样本外表现：
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding output suggests that the regression tree, on average, can make
    better predictions for this problem. The following density plots make a contrast
    between the distributions of the out-of-sample prediction errors of `model3` and `model4`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出表明，回归树平均来说可以更好地预测这个问题。以下密度图对比了`model3`和`model4`的样本外预测误差分布：
- en: '[PRE85]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The plot generated is as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的情节如下：
- en: '![Fitting a regression tree](img/image_07_036.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![拟合回归树](img/image_07_036.jpg)'
- en: For the preceding plot, we can see that the variance of the prediction errors
    of `model4` is lower than that of `model3`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的图，我们可以看到`model4`的预测误差的方差低于`model3`。
- en: The preceding examples may suffer from many problems because we apply the linear
    models and machine learning models without any serious checking of the data. The
    point of these sections is not about the models but to demonstrate a common procedure
    and interface of fitting models in R. For a real-world problem, you need more
    careful analysis of the data rather than directly pouring them into an arbitrary
    model and making conclusions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可能存在许多问题，因为我们应用线性模型和机器学习模型时没有对数据进行任何严肃的检查。这些章节的目的不在于模型，而是为了展示在R中拟合模型的常见过程和界面。对于现实世界的问题，您需要对数据进行更仔细的分析，而不是直接将它们倒入任意模型并得出结论。
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to read and write data in various formats,
    how to visualize data with plot functions, and how to apply basic models on the
    data. Now, you know the basic tools and interface of working with data. However, you
    may learn more data analysis tools from other sources.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何以各种格式读取和写入数据，如何使用绘图函数可视化数据，以及如何将基本模型应用于数据。现在，您已经了解了与数据工作相关的基本工具和界面。然而，您可能需要从其他来源学习更多的数据分析工具。
- en: 'For statistical and econometric models, I recommend that you read not only
    text books of statistics and econometrics but also R books that focus on statistical
    analysis. For machine learning models such as artificial neural networks, support
    vector machines, and random forests, I recommend that you read machine learning
    books and go to *CRAN Task View: Machine Learning & Statistical Learning* ([https://cran.r-project.org/web/views/MachineLearning.html](https://cran.r-project.org/web/views/MachineLearning.html)).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于统计和计量经济学模型，我建议您不仅阅读统计学和计量经济学的教科书，还要阅读专注于统计分析的R语言书籍。对于如人工神经网络、支持向量机和随机森林等机器学习模型，我建议您阅读机器学习书籍并访问
    *CRAN任务视图：机器学习与统计学习* ([https://cran.r-project.org/web/views/MachineLearning.html](https://cran.r-project.org/web/views/MachineLearning.html))。
- en: Since this book is focused on the R programming language rather than any specific
    model, we will continue our journey in the next chapter by going deeper into R.
    If you are not familiar with how R code works, you can hardly predict what will
    happen, which slows down your coding, and a small issue can waste a lot of your
    time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书专注于R编程语言而不是任何特定模型，我们将在下一章继续我们的旅程，深入探讨R。如果您不熟悉R代码的工作方式，您几乎无法预测会发生什么，这会减慢您的编码速度，一个小问题可能会浪费您很多时间。
- en: The next few chapters will help you build a concrete understanding of R's evaluation
    model, metaprogramming facilities, object-oriented systems, and several other
    mechanisms R chose to facilitate data analysis, which enables you to use more
    advanced packages of data manipulation and to work on more complicated tasks.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将帮助您建立对R的评估模型、元编程设施、面向对象系统和R选择以促进数据分析的几个其他机制的直观理解，这使您能够使用更高级的数据操作包，并处理更复杂的任务。
