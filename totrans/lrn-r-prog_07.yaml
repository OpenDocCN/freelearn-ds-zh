- en: Chapter 7. Working with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned the most commonly used object types and
    functions to work in R. We know how to create and modify vectors, lists, and data
    frames, how to define our own functions and how to use proper expressions to translate
    our logic in mind to R code in the editor. With these objects, functions, and
    expressions, we can start working with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will set out on a journey of working with data and cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing data in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing data with plot functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing data with simple statistical models and data mining tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in any kind of data analysis in R is to load data, that is, to
    import a dataset into the environment. Before that, we have to figure out the
    type of data file and choose appropriate tools to read the data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing text-format data in a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among all the file types used to store data, perhaps the most widely used one
    is CSV. In a typical CSV file, the first line is the header of columns, and each
    subsequent line represents a data record with columns separated by commas. Here
    is an example of student records written in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Importing data via RStudio IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RStudio provides an interactive way to import data. You can navigate to **Tools**
    | **Import Dataset** | **From Local File** and choose a local file in a text format,
    such as `.csv` and `.txt`. Then, you can adjust the parameters and preview the
    resulting data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Importing data via RStudio IDE](img/image_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that you should check **Strings as factors** only if you intend to convert
    string columns to factors.
  prefs: []
  type: TYPE_NORMAL
- en: The file importer is not magic, but translates the file path and options to
    R code. Once you set up the data importing parameters and click on **Import**,
    it will execute a call to `read.csv()`. Using this interactive tool to import
    data is very handy and will help you avoid many mistakes when you import a data
    file for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Importing data using built-in functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you write a script, you can't expect the user to interact with the file
    importer every time. You can copy the generated code to your script so that it
    will automatically work each time you run the script. Therefore, it is useful
    to know how to use built-in functions to import data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest built-in function to import data is `readLines()`, as we mentioned
    in previous chapters. This function reads a text file and returns a number of
    lines as a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, it will read all the lines of the file. To preview the first two
    lines, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For practical data importing, `readLines()` is too simple in most cases. It
    works by reading lines as strings rather than parsing them into a data frame.
    If you want to import data from a CSV file like the preceding code, directly call `read.csv()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we want to keep the string value as it is, so we set `stringsAsFactors
    = FALSE` in the function call to avoid converting the strings to factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function provides many useful arguments to customize importing. For example,
    we can use `colClasses` to explicitly specify the types of columns and use `col.names`
    to replace the original column names in the data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that CSV is a special case of the delimited data format. Technically, the
    CSV format is a delimited data format that uses a comma (,) to separate columns
    and a new line to separate rows. More generally speaking, any character can be
    the column separator and row separator. Many datasets are stored in the tab-delimited
    format, that is, they use tab character to separate columns. In this case, you
    may try using `read.table()`, a more general version, based on which `read.csv()`
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Importing data using the readr package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For historical reasons, `read.*` functions have some inconsistencies and are
    not very friendly in some situations. The `readr` package is a good choice to
    import tabular data in a fast and consistent manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the package, run `install.packages("readr")`. You can then use a
    family of `read_*` functions to import tabular data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `readr::read_csv` instead of `library(readr)` first and then directly
    call `read_csv` because it is easy to confuse `read_csv` with the built-in `read.csv` file since
    they have slightly different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that the default behavior of `read_csv` is smart enough to handle
    most situations. To make a contrast with built-in functions, let''s import a data
    file (`data/persons.txt`) in an irregular format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The file content looks quite standard and tabular, but the number of spaces
    between each column is unequal across rows, which fails to let `read.table()` work
    with `sep = " "`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you insist on using `read.table()` to import data, you may waste a lot of
    time trying to figure out the right argument to control the behavior. However,
    with the same input, the default behavior of `read_table` in `readr` is smart
    enough and thus helps you save time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's why I strongly recommend that you use the functions in `readr` to import
    tabular data into R. The functions in `readr` are fast, smart, and consistent
    and support the features of the built-in functions which are much easier to use.
    To learn more about the `readr` package, visit [https://github.com/hadley/readr](https://github.com/hadley/readr).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a data frame to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical procedure in data analysis is importing data from a data source, transforming
    the data, applying appropriate tools and models, and finally creating some new
    data to be stored for decision making. The interface for writing data to file
    is very similar to that for reading data—we use `write.*` functions to export
    a data frame to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create an arbitrary data frame and store it in a CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the CSV file correctly preserves the missing values and dates,
    we can read the output file in raw text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the data is correct, sometimes we may have different standards for storing
    such data. The `write.csv()` function allows us to modify the writing behavior.
    From the preceding output, we might think there are some unnecessary components
    in it. For example, we don''t usually want the row names to be exported because
    they seem a bit redundant, since id already does its job. We don''t need the quotation
    marks around string values. We want the missing values to be represented by `-`
    instead of `NA`. To proceed, we can run the following code to export the same
    data frame with the behavior and standard we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output data is a simplified CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `readr::read_csv()` to import such a CSV file with customized missing
    values and a date column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `-` are correctly translated to missing values and the date column
    is correctly imported as date objects too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing Excel worksheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An import advantage of text-format data such as CSV is software neutrality,
    that is, you don't have to rely on certain software to read the data and the file
    is directly readable by a human. However, its disadvantage is obvious too—we can't
    directly perform calculations on the data represented in a text editor because
    the contents are pure text.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular format for storing tabular data is the Excel workbook. An Excel
    workbook contains one or more worksheets. Each worksheet is a grid where you can
    fill in texts and values to make tables. With the tables, you can easily perform
    calculations within a table, between tables, or even across worksheets. Microsoft
    Excel is a powerful software, but its data format (`.xls` for Excel 97-2003 and `.xlsx`
    since Excel 2007) is not directly readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `data/prices.xlsx` is a simple Excel workbook as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading and writing Excel worksheets](img/image_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although no built-in function is provided to read an Excel workbook, several
    R packages are designed to work with it. The simplest one is readxl ([https://github.com/hadley/readxl](https://github.com/hadley/readxl)),
    which makes it much easier to extract the table stored in a single sheet of an
    Excel workbook. To install the package from CRAN, use `install.package("readxl")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding data frame, it is obvious that `read_excel()` automatically
    translates the dates in Excel to dates in R and correctly preserves the missing
    value in the `Growth` column.
  prefs: []
  type: TYPE_NORMAL
- en: Another package for working with an Excel workbook is `openxlsx`. This package
    can read, write, and edit XLSX files, which is more comprehensive than what `readr`
    is designed for. To install the package, run `install.package("openxlsx")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `openxlsx`, we can call `read.xlsx` to read data from a specified workbook
    into a data frame, just like `readr::read_excel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the date values are correctly imported, we need to specify `detectDates
    = TRUE`; otherwise, the dates will be left as numbers as you may try. In addition
    to reading data, `openxlsx` is also able to create a workbook with an existing
    data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The package supports more advanced features such as editing an existing workbook
    by creating styles and inserting plots, but these features are beyond the scope
    of this book. For more details, please read the documentation of the package.
  prefs: []
  type: TYPE_NORMAL
- en: There are other packages designed for working with Excel workbooks. XLConnect
    ([http://cran.r-project.org/web/packages/XLConnect](http://cran.r-project.org/web/packages/XLConnect))
    is another Excel connector which is cross-platform and does not depend on an existing
    installation of Microsoft Excel, but it does rely on an existing installation
    of Java Runtime Environment (JRE). RODBC ([http://cran.r-project.org/web/packages/RODBC](http://cran.r-project.org/web/packages/RODBC))
    is a more general database connector that is able to connect to Access databases
    and Excel workbooks with properly installed ODBC drivers on Windows. Since these
    two packages have heavier dependencies, we won't introduce them in this session.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing native data files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we introduced the reader and writer functions of CSV
    files and Excel workbooks. These are non-native data formats to R, that is, there
    is a gap between the original data object and the output file.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we export a data frame with many columns of different types
    to a CSV file, the information on the column types is discarded. Whether the column
    is numeric, string, or date, it is always represented in text format This certainly
    makes it easier for a human to read the data directly from the output file, but
    we will have to rely on how a computer would guess the type of each column. In
    other words, it is sometimes hard for the reader functions to recover the data
    in CSV format to exactly the same data frame as the original one, since the writing
    process throws the column types away in exchange for portability (for example, other
    software can read the data too).
  prefs: []
  type: TYPE_NORMAL
- en: If you do not care for portability and only use R to work with the data, you
    can use the native formats to read and write data. You can no longer uses an arbitrary
    text editor to read the data, nor can you read the data from other software, but
    it is easy to write and read a single object or even the whole environment with
    high efficiency and no data losses. In other words, the native format allows you
    to save objects in file and recover exactly the same data without worrying about
    issues like the symbols of missing values and the types, classes and attributes
    of columns.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing a single object in native format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two groups of functions related to working with the native data format.
    One group is designed to write a single object to an RDS file or read a single
    object from an RDS file, a file format to store a single R object in serialized
    form. The other group works with multiple R objects, which we will cover in the
    next section. In the following example, we write `some_data` to an RDS file and
    read it from the same file and see whether two data frames are exactly identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we use `saveRDS` to save `some_data` to `data/some_data.rds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we read the data from the same file and store the data frame in `some_data2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use `identical()` to test whether two data frames are exactly the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The two data frames are exactly the same, as supposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The native format has two notable advantages: space efficiency and time efficiency.
    In the following example, we will create a large data frame with 200,000 rows
    of random data. Then, we time the process for saving the data frame to a CSV file
    and an RDS file, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is obvious that `saveRDS` has much higher writing efficiency than `write.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we use `file.info()` to see the size of the two output files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The gap between the two file sizes is large—the size of the CSV file is almost
    three times that of the RDS file, indicating that the native format has higher
    storage or space efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we read the CSV and RDS files and see how much time both formats consume.
    To read the CSV file, we use both the built-in function `read.csv` and the faster
    implementation, `read_csv()`, provided by the `readr` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be surprising to see that `read_csv()` is almost four times faster than
    the built-in `read.csv()` in this case. But with the native format, the performance
    of both CSV reader functions is not comparable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The native format clearly has much higher writing efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, `saveRDS` and `readRDS` work not only with data frames but also
    with any R object. For example, we create a numeric vector with a missing value
    and a list with a nested structure. Then, we save them in separate RDS files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we read the RDS files, and these two objects are exactly recovered, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Saving and restoring the working environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the RDS format is used to store a single R object, the RData format is
    used to store multiple R objects. We can call `save()` to store `some_data`, `nums`,
    and `list1` together in a single RData file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the three objects are stored and can be recovered, we remove
    them first and call `load()` to recover the objects from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the three objects are fully recovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Loading built-in datasets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In R, there are already a great number of built-in datasets. They can be easily
    loaded and put into use, mostly for demonstration and test purposes. The built-in
    datasets are mostly data frames and come with detailed specifications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, iris and mtcars are probably among the most famous datasets in
    R. You can read the description of the datasets with `? iris` and `? mtcars`,
    respectively. Typically, the description is quite specific—it not only tells you
    what is in the data, how was it collected and formatted, and what each column
    means, but it also provides related sources and references. Reading the description
    helps you know more about the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: It is extremely handy to conduct experiments on data analysis tools with built-in
    datasets because these datasets are immediately available once R is ready. For
    example, you can directly use iris and mtcars without explicitly loading them
    from somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the view of the first six rows of iris:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The structure of iris is straightforward. You can either print `iris` to see
    the whole data frame in the console or use `View(iris)` in a grid pane or window.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the first six rows of mtcars and see its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, iris and mtcars are small and simple. In fact, most built-in
    datasets only have tens or hundreds of rows and a few columns. They are often
    used to demonstrate the usage of particular data analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to experiment with larger data, you may turn to some R packages
    that come along with datasets. For example, the most famous data visualization
    package, `ggplot2`, provides a dataset called diamonds, which contains the prices
    and other attributes of a large number of diamonds. Use?ggplot2::diamonds to know
    more about the data specification. If you don't have the package installed, run `install.package("ggplot2")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the data in the package, we can use `data()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that diamonds has `53940` rows and `10` columns. Here is a
    preview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Besides packages that provide useful functions, there are also packages that
    only provide datasets. For example, nycflights13 and babynames each only contains
    several datasets. The method to load the data in them is exactly the same as the
    previous example. To install the two packages, run `install.package(c("nycflights13",
    "babynames"))`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will use these datasets to demonstrate basic graphic
    tools and data analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced a number of functions to import data,
    the first step in most data analysis. It is usually a good practice to look at
    the data before pouring it into a model, so that is what we will do in the next
    step. The reason is simple—different models have different strengths, and no model
    is universally the best choice for all cases since they have a different set of
    assumptions. Arbitrarily applying a model without checking the data against its
    assumptions usually results in misleading conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: An initial way to choose a model and perform such checks is to just visually
    examine the data by looking at its boundaries and patterns. In other words, we
    need to visualize the data first. In this section, you will learn the basic graphic
    functions to produce simple charts to visualize a given dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the datasets in the `nycflights13` and `babynames` packages. If
    you don''t have them installed, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating scatter plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In R, the basic function to visualize data is `plot()`. If we simply provide
    a numeric or integer vector to `plot()`, it will produce a scatter plot of value
    by index. For example, the following code creates a scatter plot of 10 points
    in the increasing order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating scatter plots](img/image_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create a more realistic scatter plot by generating two linearly correlated
    random numeric vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating scatter plots](img/image_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customizing chart elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a plot, there are numerous chart elements that can be customized. The most
    common elements to be specified are the title (main or `title()`), the label of
    the *x* axis (`xlab`), the label of the *y* axis (`ylab`), the range of the *x*
    axis (`xlim`), and the range of the *y* axis (`ylim`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing chart elements](img/image_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The chart title can be specified by either the main argument or a separate `title()`
    function call. Therefore, the preceding code is equivalent to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Customizing point styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default point style of a scatter plot is a circle. By specifying the `pch`
    argument (plotting character), we can change the point style. There are 26 point
    styles available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Customizing point styles](img/image_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code produces a scatter plot of all point styles available with
    the corresponding `pch` numbers printed beside. First, `plot()` creates a simple
    scatter plot, and then `text()` prints the `pch` numbers on the right side of
    each point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other built-in functions, `plot()` is vectorized with respect to `pch`
    and several other arguments. It makes it possible to customize the style of each
    point in the scatter plot. For example, the simplest case is that we use only
    one non-default point style for all points by setting `pch = 16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point styles](img/image_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, we need to distinguish two groups of points by a logical condition.
    Knowing that `pch` is vectorized, we can use `ifelse()` to specify the point style
    of each observation by examining whether a point satisfies the condition. In the
    following example, we want to apply `pch = 16` to the points satisfying `x * y
    > 1` otherwise, `pch = 1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point styles](img/image_07_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also draw the points in two separate datasets that share the same x
    axis using `plot()` and `points()`. In the previous example, we generated a normally
    distributed random vector `x` and a linearly correlated random vector `y`. Now,
    we generate another random vector `z` that has a non-linear relationship with `x`
    and plot both `y` and `z` against `x` but with different point styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point styles](img/image_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After we generate `z`, we create a plot of `x` and `y` first, and then add another
    group of points `z` with a different `pch`. Note that if we don't specify `ylim
    = range(y, z)`, the plot builder will only consider the range of `y`, and the
    *y* axis may have a range narrower than the range of `z`. Unfortunately, `points()`
    does not automatically lengthen the axes created by `plot()`, therefore any point
    beyond the axes' range will disappear. The preceding code sets an appropriate
    range of *y* axis so that all points in `y` and `z` can be shown in the plot area.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing point colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the graphics are not limited to gray-scale printing, we may also use different
    point colors by setting the column of `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point colors](img/image_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Like `pch`, `col` is also a vectorized argument. With the same method, we can
    apply different colors to separate points into two different categories depending
    on whether they satisfy a certain condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point colors](img/image_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that if the scatter plot is printed grayscale, the colors can only be viewed
    as different intensities of grayness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can use `plot()` and `points()` again, but with different `col` to
    distinguish different groups of points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing point colors](img/image_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: R supports commonly used color names and many others (657 in total). Call `colors()`
    to get a full list of colors supported by R.
  prefs: []
  type: TYPE_NORMAL
- en: Creating line plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For time series data, line plots are more useful to demonstrate the trend and
    variation across time. To create line plots, we only need to set `type = "l"`
    when calling `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating line plots](img/image_07_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customizing line type and width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like `pch` for scatter plot, `lty` is used to specify the line type of
    a line plot. The following shows a preview of six line types supported by R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing line type and width](img/image_07_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code creates an empty canvas with `type = "n"` with proper axes
    ranges and turns off axes, and another label `elements.abline()` is used to draw
    the horizontal lines with different line types but of equal line width (`lwd =
    2`). The `mtext()` function is used to draw the text on the margin. Note that `abline()`
    and `mtext()` are vectorized with respect to their arguments so that we don't
    need a `for` loop  to draw each line and margin text in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how `abline()` can be useful to draw auxiliary
    lines in a plot. First, we create a line plot of `y` with time, `t`, which we
    defined before we created the first line plot a moment ago. Suppose we also want
    the plot to show the mean value and the range of `y` along with the time at which
    the maximal and minimal values appear. With `abline()`, we can easily draw these
    auxiliary lines with different line types and colors to avoid ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing line type and width](img/image_07_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting lines in multiple periods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another kind of line plot in which different line types are mixed is a multi-period
    line plot. A typical form is that the first period is historic data and the second
    period is predictions. Suppose the first period of `y` includes the first 40 observations
    and the remaining points are predictions based on the historic data. We want to
    use solid lines to represent the historic data and dashed lines for the predictions.
    Here, we plot the data in the first period and add dashed `lines()` for the data
    in the second period of the plot. Note that `lines()` is to a line plot as `points()`
    is to a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting lines in multiple periods](img/image_07_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plotting lines with points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to plot both lines and points in the same chart to
    emphasize that the observations are discrete or simply make the chart clearer.
    The method is simple, just plot a line chart and add `points()` of the same data
    to the plot again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting lines with points](img/image_07_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An equivalent way to do this is to plot a scatter chart first using the `plot()`
    function and then add lines using the `lines()` function of the same data to the
    plot again. Therefore, the following code should produce exactly the same graphics
    as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Plotting a multi-series chart with a legend
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full version of a multi-series chart should include multiple series represented
    by lines and points, and a legend to illustrate the series in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code randomly generates two series, `y` and `z`, with time, `x`,
    and creates a chart with these put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting a multi-series chart with a legend](img/image_07_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code uses `plot()` to create the line-point chart of `y` and adds
    the `lines()` and `points()` of `z`. In the end, we add a `legend()` on the top
    left to demonstrate the line and point styles of `y` and `z`, respectively. Note
    that `cex` is used to scale the font sizes of the legend and `x.intersp` and `y.intersp`
    are used for minor adjustments to the legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful type of line plot is step-lines. We use `type = "s"` in `plot()` and `lines()`
    to create a step-line plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plotting a multi-series chart with a legend](img/image_07_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating bar charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to create scatter plots and line plots.
    There are several other types of charts that are useful and worth mentioning.
    Bar charts are among the most commonly used ones. The height of bars in a bar
    chart can make a constrast quantitatively between different categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest bar chart we can create is the following one. Here, we use `barplot()`
    instead of `plot()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating bar charts](img/image_07_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the numeric vector has names, the names will automatically be the names
    on the *x* axis. Therefore, the following code will produce exactly the same bar
    chart as the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The making of a bar chart looks so easy. Now that we have the flights dataset
    in `nycflights13`, we can create a bar plot of the top eight carriers with the
    most flights in the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `table()` is used to count the number of flights in
    the record for each carrier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the carriers are sorted in descending order.
    We can take the first `8` elements out of the table and make a bar plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating bar charts](img/image_07_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating pie charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another useful chart is the pie chart. The function to create a pie chart,
    `pie()`, works in a way similar to `barplot()`. It works with a numeric vector
    with labels specified; it also works directly with a named numeric vector. The
    following code is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating pie charts](img/image_07_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating histogram and density plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, you learned how to create several different types of charts. Scatter
    plots and line plots are direct illustrations of the observations in a dataset.
    Bar charts and pie charts are usually used to show a rough summary of data points
    in different categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are two limitations to plots: scatter plots and line plots convey too
    much information and are difficult to draw insights from, while bar charts and
    pie charts drop too much information, so with these too it can be difficult to
    make a conclusive judgement with confidence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A histogram shows the distribution of a numeric vector, and it summarizes the
    information in the data without dropping too much and thus can be easier to make
    use of. The following example demonstrates how to use `hist()` to produce a histogram
    of a normally distributed random numeric vector and the density function of normal
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating histogram and density plots](img/image_07_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the *y* axis of a histogram is the frequency of the value in the
    data. We can verify that the histogram is quite close to the standard normal distribution
    from which `random_normal` was generated. To overlay the curve of a probability
    density function of the standard normal distribution, `dnorm()`, we need to ensure
    that the *y* axis of the histogram is a probability and the curve is to be added
    to the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating histogram and density plots](img/image_07_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make a histogram of the speed of an aircraft in flight. Basically,
    the average speed of an aircraft in a trip is the distance of the trip (`distance`)
    divided by the air time (`air_time`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating histogram and density plots](img/image_07_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The histogram seems a bit different from a normal distribution. In this case,
    we use `density()` to estimate an empirical distribution of the speed, plot a
    pretty smooth probability distribution curve out of it, and add a vertical line
    to indicate the global average of all observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating histogram and density plots](img/image_07_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like the first histogram and curve example, we can combine the two graphics
    together to get a better view of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating histogram and density plots](img/image_07_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating box plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Histograms and density plots are two ways to demonstrate the distribution of
    data. Usually, we only need several critical quantiles to get an impression of
    the whole distribution. The box plot (or box-and-whisker plot) is a simple way
    to do this. For a randomly generated numeric vector, we can call `boxplot()` to
    draw a box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating box plots](img/image_07_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A box plot contains several components to show critical quartile levels of
    data as well as outliers. The following image clearly explains what a box plot
    means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating box plots](img/image_07_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code draws a box plot of the flight speed for each carrier. There
    will be 16 boxes in one chart, making it easier to roughly compare the distribution
    of different carriers. To proceed, we use the formula *distance /air_time ~carrier*
    to indicate that the *y* axis denotes the flight speed computed from *distance
    / air_time*, and the *x *axis denotes the carrier. With this representation, we
    have the following box plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating box plots](img/image_07_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that we use the formula interface of creating graphics in `boxplot()`.
    Here, *distance / air_time ~ carrier* basically means the *y* axis should represent
    the values of *distance / air_time*, that is, flight speed, and the *x* axis should
    represent different carriers. *data = flights* tells *boxplot()* where to find
    the symbols in the formula we specify. As a result, the box plot of flight speed
    is created and grouped by carrier.
  prefs: []
  type: TYPE_NORMAL
- en: The formula interface of visualizing and analyzing data is very expressive and
    powerful. In the next section, we will introduce some basic tools and models to
    analyze data. Behind the functions that implement these tools and models are not
    only algorithms but also a user-friendly interface (formula) to make it easier
    to specify relationships for the model to fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also other packages that are specially tailored for data visualization.
    One great example is `ggplot2`, which implements a very powerful grammar of graphics
    to create, compose, and customize different types of charts. However, it is beyond
    the scope of this book. To know more, I recommend that you read *ggplot2: Elegant
    Graphics for Data Analysis* by Hadley Wickham.'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In practical data analysis, most time is spent on data cleansing, that is, to
    filter and transform the original data (or raw data) to a form that is easier
    to analyze. The filtering and transforming process is also called data manipulation.
    We will dedicate an entire chapter to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we directly assume that the data is ready for analysis. We
    won't go deep into the models, but will apply some simple models to leave you
    an impression of how to fit a model with data, how to interact with fitted models,
    and how to apply a fitted model to make predictions.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting a linear model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest model in R is the linear model, that is, we use a linear function
    to describe the relationship between two random variables under a certain set
    of assumptions. In the following example, we will create a linear function that
    maps *x*to *3 + 2 * x*. Then we generate a normally-distributed random numeric
    vector `x`, and generate `y` by `f(x)` plus some independent noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pretend not to know how `y` is generated by `x`, can we use a linear
    model to recover their relationship, that is, to recover the coefficient of the
    linear function? The following code uses `slm()` to fit `x` and `y` with a linear
    model. Note that a formula *y ~ x* is an accessible representation to tell `m()`
    that the linear regression is between the dependent variable `y` and a single
    regressor `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The true coefficients are 3 (intercept) and 2 (slope), and with the sample data
    `x` and `y`, the fitted model has coefficients `2.9692146` (intercept) and `1.9716588`
    (slope), which are quite close to the true coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the model in `model1`. To access the coefficients of the model, we
    can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can use the `model1$` coefficients, since `model1` is essentially
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can call `summary()` to know more about the statistical properties
    of the linear model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpret the summary, you had better review the chapter on linear regression
    in one or two textbooks of statistics. The following plot puts the data and the
    fitted model together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting a linear model](img/image_07_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we directly supply a two-element numeric vector of estimated
    regression coefficients to `abline()`, so it smartly draws the regression line
    as supposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can call `predict()` to use the fitted model to make predictions.
    To predict `y` with standard errors when `x = -1` and `x = 0.5`, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The prediction result is a list of predicted values of `y` (`$fit`), the standard
    errors of the fitted values (`$se.fit`), the degree of freedom (`$df`), and `$residual.scale`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basics of how to fit a linear model given some data, it
    is time to look at some real-world data. In the following examples, we try to
    predict the air time of a flight using linear models of different complexity.
    The most obvious variable that should be helpful to predict air time is distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the dataset and make a scatter plot of distance and `air_time`.
    We use `pch = "."` to make each point very small, since the number of records
    in the dataset is large:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting a linear model](img/image_07_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The plot clearly suggests that distance and `air_time` has a positive correlation.
    So, it is reasonable to fit a linear model between the two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before pouring the whole dataset into a linear model, we divide the dataset
    into two parts: a training set and a testing set. The purpose of dividing the
    dataset is that we want to perform not only sample evaluation but also out-of-sample
    evaluation of the model. More specifically, we put 75% of the data to the training
    set, and the remaining 25% of data to the testing set. In the following code,
    we use `sample()` to draw a random sample of 75% records from the original data
    and use `setdiff()` to get the rest of the records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note that `setdiff(rows_id, sample_id)` returns the indices in `rows_id` but
    not in `sample_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `flights_train` is the training set and `flights_test` is the testing set.
    With the divided datasets, the procedure of model fitting and model evaluation
    is straightforward. First, use the training set to fit the model, then make an
    in-sample prediction to see the magnitude of the in-sample errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To evaluate the magnitude of the errors, we define a function named `evaluate_error()`
    to calculate the mean absolute errors and the standard deviation of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this function, we can evaluate the errors of the in-sample predictions
    of `model2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The absolute mean errors indicate that on average the prediction deviates from
    the correct value by around 9.45 minutes in absolute value and has a standard
    deviation of 12.8 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we perform a simple out-of-sample evaluation by using the model to predict
    on the testing set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The prediction results in a numeric vector of predicted values. Both the absolute
    mean errors and the standard deviation of errors go up slightly, which suggests
    that the quality of the out-of-sample prediction does not get significantly worse,
    indicating that `model2` does not seem to be a result of overfitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `model2` has only one regressor, `distance`, it is natural to consider
    whether more regressors would improve the prediction. The following code fits
    a new linear model with not only distance but also `carrier`, `month` and departure
    time (`dep_time`) as regressors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The in-sample errors are slightly lower in both magnitude and variation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the out-of-sample errors looks slightly better than `model2`. To compare
    the distribution of out-of-sample errors before and after adding new regressors
    to the linear model, we overlay the two density curves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting a linear model](img/image_07_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding density plot, the improvement from `model2` to `model3` is
    too small to notice, that is, there's no significant improvement at all.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting a regression tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we try another model to fit the data. The model is called a **regression
    tree** ([https://en.wikipedia.org/wiki/Decision_tree_learning](https://en.wikipedia.org/wiki/Decision_tree_learning))
    and is one of the machine learning models. It is not a simple linear regression,
    but uses a decision tree to fit the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to predict the daily air quality (`Ozone`) according to solar
    radiation (`Solar.R`), average wind speed (`Wind`), and maximum daily temperature
    (`Temp`), the built-in dataset `airquality` being the training set. The following
    graph illustrates how a fitted regression tree works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting a regression tree](img/image_07_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the tree, each circle represents a question which has two possible answers.
    To predict `Ozone`, we need to ask questions along the tree from top to bottom
    where each observation lies in one of the bottom cases. Each node at the bottom
    has a distribution different from the others, which is illustrated by a box plot.
    The median or mean in each box should be reasonable predictions for each case.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of packages that implement decision tree learning algorithms.
    In this section, we use a simple package called party ([https://cran.r-project.org/web/packages/party](https://cran.r-project.org/web/packages/party)).
    If you don't have it installed yet, run `install.package("party")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we use the same formula and data to train a regression tree model. Note
    that we took a subset of the data where there is no missing value of `air_time` because `ctree`
    does not accept missing values in a response variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like `model4` performs better than `model3`. Then, we take a look
    at its out-of-sample performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output suggests that the regression tree, on average, can make
    better predictions for this problem. The following density plots make a contrast
    between the distributions of the out-of-sample prediction errors of `model3` and `model4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fitting a regression tree](img/image_07_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the preceding plot, we can see that the variance of the prediction errors
    of `model4` is lower than that of `model3`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding examples may suffer from many problems because we apply the linear
    models and machine learning models without any serious checking of the data. The
    point of these sections is not about the models but to demonstrate a common procedure
    and interface of fitting models in R. For a real-world problem, you need more
    careful analysis of the data rather than directly pouring them into an arbitrary
    model and making conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to read and write data in various formats,
    how to visualize data with plot functions, and how to apply basic models on the
    data. Now, you know the basic tools and interface of working with data. However, you
    may learn more data analysis tools from other sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For statistical and econometric models, I recommend that you read not only
    text books of statistics and econometrics but also R books that focus on statistical
    analysis. For machine learning models such as artificial neural networks, support
    vector machines, and random forests, I recommend that you read machine learning
    books and go to *CRAN Task View: Machine Learning & Statistical Learning* ([https://cran.r-project.org/web/views/MachineLearning.html](https://cran.r-project.org/web/views/MachineLearning.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Since this book is focused on the R programming language rather than any specific
    model, we will continue our journey in the next chapter by going deeper into R.
    If you are not familiar with how R code works, you can hardly predict what will
    happen, which slows down your coding, and a small issue can waste a lot of your
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The next few chapters will help you build a concrete understanding of R's evaluation
    model, metaprogramming facilities, object-oriented systems, and several other
    mechanisms R chose to facilitate data analysis, which enables you to use more
    advanced packages of data manipulation and to work on more complicated tasks.
  prefs: []
  type: TYPE_NORMAL
