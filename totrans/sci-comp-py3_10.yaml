- en: Chapter 10. Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover errors, exceptions, and how to find and fix them.
    Handling exceptions is an important part of writing reliable and usable code.
    We will introduce the basic built-in exceptions and show how to use and treat
    exceptions. We'll introduce debugging and show you how to use the built-in Python
    debugger.
  prefs: []
  type: TYPE_NORMAL
- en: What are exceptions?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One error programmers (even experienced ones) find is when code has incorrect
    syntax, meaning that the code instructions are not correctly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example of Syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The error occurs because of a missing colon at the end of the `for` declaration.
    This is an example of an exception being raised. In the case of `SyntaxError`,
    it tells the programmer that the code has incorrect syntax and also prints the
    line where the error occurred, with an arrow pointing to where in that line the
    problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in Python are derived (inherited) from a base class called `Exception`. Python
    comes with a number of built-in exceptions. Some common exception types are listed
    in *Table 10.1,* (for full list of built-in exceptions refer to *[[38]](apa.html
    "Appendix . References")*).
  prefs: []
  type: TYPE_NORMAL
- en: Here are two common examples of exceptions. As you might expect, `ZeroDivisionError`
    is raised when you try to divide by zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| **Exception** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `IndexError` | Index is out of bounds, for example, `v[10]` when v only has
    5 elements |'
  prefs: []
  type: TYPE_TB
- en: '| `KeyError` | A reference to an undefined dictionary key |'
  prefs: []
  type: TYPE_TB
- en: '| `NameError` | A name not found, for example, an undefined variable |'
  prefs: []
  type: TYPE_TB
- en: '| `LinAlgError` | Errors in the `linalg` module, for example, when solving
    a system with a singular matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `ValueError` | Incompatible data value, for example, when using `dot` with
    incompatible arrays |'
  prefs: []
  type: TYPE_TB
- en: '| `IOError` | I/O operation fails, for example, "file not found" |'
  prefs: []
  type: TYPE_TB
- en: '| `ImportError` | A module or name is not found on import |'
  prefs: []
  type: TYPE_TB
- en: 'Table10.1: Some frequently used built-in exceptions and their meaning'
  prefs: []
  type: TYPE_NORMAL
- en: A division with zero raises `ZeroDivisionError` and prints out the file, line,
    and function name where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen before, arrays can only contain elements of the same data type.
    If you try to assign a value of an incompatible type, a `ValueError` is raised.
    An example, of a value error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ValueError` is raised because the array contains floats and an element
    cannot be assigned a string value.
  prefs: []
  type: TYPE_NORMAL
- en: Basic principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the basic principles on how to use exceptions by raising them
    with `raise` and catching them with `try` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating an error is referred to as raising an exception. You saw some examples
    of exceptions in the previous section. You can also define your own exceptions,
    of a predefined type or type-less. Raising an exception is done with the command
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be tempting to print out error messages when something goes wrong,
    for example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is not recommended for a number of reasons. Firstly, printouts are easy
    to miss, especially if the message is buried in many other messages being printed
    to your console. Secondly, and more importantly, it renders your code unusable
    by other code. The calling code will have no way of knowing that an error occurred
    and therefore have no way of taking care of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these reasons, it is always better to raise an exception instead. Exceptions
    should always contain a descriptive message, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This message will stand out clearly for the user. It also gives the opportunity
    for the calling code to know that an error occurred, and to possibly find a remedy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical example of checking the input inside a function to make sure
    it is usable before continuing. For an example, a simple check for negative values
    and the correct data type ensures the intended input of a function to compute
    factorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The user of the function will immediately know what the error is, if an incorrect
    input is given, and it is the user's responsibility to handle the exception. Note
    the use of the exception name when raising a predefined exception type, in this
    case `ValueError` followed by the message. By specifying the type of the exception,
    the calling code can decide to handle errors differently depending on what type
    of error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up, it is always better to raise exceptions than to print error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dealing with an exception is referred to as catching an exception. Checking
    for exceptions is done with the `try` and `except` commands.
  prefs: []
  type: TYPE_NORMAL
- en: An exception stops the program execution flow and looks for the closest `try`
    enclosing block. If the exception is not caught, the program unit is left and
    it continues searching for the next enclosing `try` block in a program unit higher
    up in the calling stack. If no block is found and the exception is not handled,
    execution stops entirely; the standard traceback information is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example for the `try` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the code inside the `try` block raises an error of type `ValueError`,
    the exception will be caught and the message in the `except` block printed. If
    no exception occurs inside the `try` block, the `except` block is skipped entirely
    and execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `except` statement can catch multiple exceptions. This is done by simply
    grouping them in a tuple, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try` block can also have multiple `except` statements. This makes it possible
    to handle exceptions differently depending on the type. Let''s see an example
    of multiple exception types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here an `OSError` will be caught if, for example, the file does not exist; and
    a `ValueError` will be caught if, for example, the data in the first line of the
    file is not compatible with the float data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example we assigned the `OSError` to a variable `oe` by the keyword
    `as`. This allows to access more details when handling this exception. Here we
    printed the error string `oe.strerror` and the name of the related file `oe.filename`.
    Each error type can have its own set of variables depending on the type. If the
    file does not exist, in the preceding example, the message will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if the file exists but you don’t have permission to open
    it, the message will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful way to format the output when catching exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `try`  -  `except` combination can be extended with optional `else` and
    `finally` blocks. An example of using `else` can be seen in section *Testing the
    bisection algorithm* of [Chapter 13](ch13.html "Chapter 13. Testing"), *Testing*.
    Combining `try` with `finally` gives a useful construction when cleanup work needs
    to happen at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example for making sure a file is closed properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure that the file is closed at the end no matter what exceptions
    are thrown while processing the file data. Exceptions that are not handled inside
    the `try` statement are saved and raised after the `finally` block. This combination
    is used in the `with` statement; see section *Context Managers - the with statement*.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the built-in Python exceptions, it is also possible to define your own
    exceptions. Such user-defined exceptions should inherit from the `Exception` base
    class. This can be useful when you define your own classes like the polynomial
    class in section *Polynomials* of [Chapter 14](ch14.html "Chapter 14. Comprehensive
    Examples"), *Comprehensive Examples*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this small example of a simple user-defined exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A random number is generated. If the number is below 0.5, an exception is thrown
    and a message that the value is too small is printed. If no exception is raised,
    the number is printed.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you also saw a case of using `else` in a `try` statement. The
    block under `else` will be executed if no exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you define your exceptions with names that end in `Error`,
    like the naming of the standard built-in exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Context managers - the with statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a very useful construction in Python for simplifying exception handling
    when working with contexts, such as files or databases. The statement encapsulates
    the `try ... finally` structure in one simple command. Here is an example of using
    `with` to read a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will try to open the file, run the specified operations on the file (for
    example, reading), and close the file. If anything goes wrong during the execution
    of `process_file_data`, the file is closed properly and then the exception is
    raised. This is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will use this option in section *File handling* of [Chapter 12](ch12.html
    "Chapter 12. Input and Output"), *Input and Output*, when reading and writing
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding file reading example is an example of using context managers.
    Context managers are Python objects with two special methods, `_ _enter_ _` and
    `_ _exit_ _`. Any object of a class that implements these two methods can be used
    as a context manager. In this example, the file object `f`  is a context manager
    as there are `f._ _enter_ _` and `f._ _exit_ _` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `_ _enter_ _` method should implement the initialization instructions, for
    example, opening a file or a database connection. If this method has a return
    statement, the returned object is accessed using the `as` construct. Otherwise,
    the `as` keyword is omitted. The `_ _exit_ _` method contains the cleanup instructions,
    for example, closing a file or committing transactions and closing a database
    connection. For more explanations and an example of a self-written context manager, see
    the section *Timing with a context manager* of [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: There are NumPy functions that can be used as context managers. For example,
    the `load` function supports context manager for some file formats. NumPy's function
    `errstate` can be used as a context manager to specify floating-point error handling
    behavior within a block of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of working with errstate and a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Refer section *Infinite and Not a Number* of [Chapter 2](ch02.html "Chapter 2. Variables
    and Basic Types"), *Variables and Basic Types*, for more details on this example
    and section *Timing with a context manager* of [Chapter 13](ch13.html "Chapter 13. Testing"),
    *Testing *for another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding Errors: Debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors in software code are sometimes referred to as *bugs*. Debugging is the
    process of finding and fixing bugs in code. This process can be performed at varying
    degrees of sophistication. The most efficient way is to use a tool called debugger.
    Having unittests in place is a good way to identify errors early, refer section
    *Using unittest* of [Chapter 13](ch13.html "Chapter 13. Testing"), *Testing*.
    When it is not obvious where or what the problem is, a debugger is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are typically two kinds of bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: An exception is raised and not caught.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code does not function properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first case is usually easier to fix. The second can be more difficult as
    the problem can be a faulty idea or solution, a faulty implementation, or a combination
    of the two.
  prefs: []
  type: TYPE_NORMAL
- en: We are only concerned with the first case in what follows, but the same tools
    can be used to help find why the code does not do what it is supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an exception is raised, you see the call stack. The call stack contains
    the trace of all the functions that called the code where the exception was raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple stack example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The stack in this case is `f`, `g`, and `h`. The output generated by running
    this piece of code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The error is printed. The sequence of functions leading up to the error is shown.
    The function  `f`  on line 11 was called, which in turn called `g` and then `h`.
    This caused the `ZeroDivisionError`.
  prefs: []
  type: TYPE_NORMAL
- en: A stack trace reports on the active stack certain point in the execution of
    a program. A stack trace lets you track the sequence of functions called up to
    a given point. Often this is after an uncaught exception has been raised. This
    is sometimes called post-mortem analysis, and the stack trace point is then the
    place where the exception occurred. Another option is to invoke a stack trace
    manually to analyze a piece of code where you suspect there is an error, perhaps
    before the exception occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The Python debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python comes with its own built-in debugger called pdb. Some development environments
    come with the debugger integrated. The following process still holds in most of
    these cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to use the debugger is to enable stack tracing at the point
    in your code that you want to investigate. Here is a simple example of triggering
    the debugger based on the example mentioned in section *Return values* of [Chapter
    7](ch07.html "Chapter 7. Functions"), *Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pdb.set_trace()` command starts the debugger and enables tracing of subsequent
    commands. The preceding code will show this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The debugger prompt is indicated with (Pdb). The debugger stops the program
    execution and gives you a prompt that lets you inspect variables, modify variables,
    step through commands, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current line is printed at each step, so you can follow where you are and
    what will happen next. Stepping through commands is done with the command `n`
    (next), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `n` (next)  will continue to the next line and print the line.
    If you need to see more than one line at the time, the list command `l` (list)
    shows the current line with surrounding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing surrounding code in the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspection of variables can be done by printing their values to the console
    using the command `p` (print) followed by the variable name. An example of printing
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `p` (print) command will print the variable; command `c` (continue) continues
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a variable in mid-execution is useful. Simply assign the new value
    at the debugger prompt and step or continue the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of changing variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here the variable `z` is assigned a new value to be used throughout the remaining
    code. Note that the final printout has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Overview - debug commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Table 10.2*, the most common debug commands are shown. For a full listing
    and description of commands, (see the documentation [[25]](apa.html "Appendix . References")
    for more information). Note that any Python command also works, for example, assigning
    values to variables.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Short variable names**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to inspect a variable with a name that coincides with any of the
    debugger's short commands, for example, `h`, you must use `!h` to display the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Help (without arguments, it prints available commands) |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | List the code around the current line |'
  prefs: []
  type: TYPE_TB
- en: '| `q` | Quit (exits the debugger and the execution stops) |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | Continue execution |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | Continue execution until the current function returns |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | Continue execution until the next line |'
  prefs: []
  type: TYPE_TB
- en: '| `p <expression>` | Evaluate and print the expression in the current context
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table10.2: The most common debug commands for the debugger.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPython comes with a version of the debugger called `ipdb`. At the time of writing
    this book, the differences are very minor but this may change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a command in IPython that automatically turns on the debugger in case
    of an exception. This is very useful when experimenting with new ideas or code.
    An example of how to automatically turn on the debugger in IPython:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The IPython magic command `%pdb` at the IPython prompt automatically enables
    the debugger when exceptions are raised. Here the debugger prompt shows `ipdb` instead
    to indicate that the debugger is running.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key concepts in this chapter were exceptions and errors. We showed how an
    exception is raised to be later in another program unit caught. You can define
    your own exceptions and equip them with messages and current values of given variables.
  prefs: []
  type: TYPE_NORMAL
- en: Code may return unexpected results without throwing an exception. The technique
    to localize the source of the erroneous result is called debugging. We introduced
    debugging methods and hopefully encouraged you to train them so that you have
    them readily available when needed. The need for serious debugging comes sooner
    than you might expect.
  prefs: []
  type: TYPE_NORMAL
