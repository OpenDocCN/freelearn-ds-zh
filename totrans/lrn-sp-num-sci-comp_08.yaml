- en: Chapter 8. Interaction with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to incorporate into our workflow some code written in different
    languages; mostly C/C++ or Fortran, and also from R, MATLAB, or Octave. Python
    excels at allowing code from all these other sources to run from within; care
    must be taken to convert different numerical types to something that Python understands,
    but this is pretty much the only issue we encounter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with SciPy, it is because your Python ecosystem has available
    compilers for C and Fortran programs. Otherwise, SciPy could have not been installed
    on your system. Also, given its popularity, it is highly probably that your computer
    environment has MATLAB/Octave available. Accordingly, this has driven the selection
    of topics listed later in this chapter. We left to the interested reader to find
    out how interface with R and many other software is available out there for numerical
    computing. Two alternatives to do that with R are the packages **PypeR** ([http://bioinfo.ihb.ac.cn/softwares/PypeR/](http://bioinfo.ihb.ac.cn/softwares/PypeR/))
    and **rpy2** ([http://rpy.sourceforge.net/](http://rpy.sourceforge.net/)). Additional
    alternatives can be found at [http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language](http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: A brief discussion on how Python can be used to run codes from Fortran, C/C++,
    and MATLAB/Octave
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first see the basic functionality of the utility `f2py` to handle the
    inclusion of Fortran codes in Python via SciPy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic usage to include C/C++ code within Python code using the tools provided
    by the the `scipy.weav``e` module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routines will be illustrated via simple examples that can be enriched by
    you modifying the IPython Notebook corresponding to this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with Fortran
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SciPy provides a simple way of including Fortran code—`f2py`. This is a utility
    shipped with the NumPy libraries, which is operative when `distutils` from SciPy
    are available. This is always the case when we install SciPy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The `f2py` utility is supposed to run outside Python, and it is used to create
    from any Fortran file a Python module that can be easily called in our sessions.
    Under any `*nix` system, we call it from the terminal. Under Windows, we recommend
    you run it in the native terminal, or even better, through a `cygwin` session.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Before being compiled with `f2py`, any Fortran code needs to undergo three
    basic changes, which are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Removal of all allocations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation of the whole program into a subroutine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If anything special needs to be passed to `f2py`, we must add it with the comment
    string `"!f2py"` or `"cf2py"`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s illustrate the process with a simple example. The following naive subroutine,
    which we store in the `primefactors.f90` file, performs a factorization in prime
    numbers for any given integer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since no allocation was made in the code, and we receive a subroutine directly,
    we may skip to the third step, but for the moment we will not tamper with `f2py`
    commands, and are content with trying to create a python module from it. The fastest
    way to wrap this `primefactors` subroutine is by issuing the following command
    (at the shell or terminal prompt indicated by `%`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If everything is correct, an extension module with the name `primefactors.so`
    is created. We can then access the `primefactors` routine in Python from the `primefactors`
    module:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Interaction with C/C++
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, `f2py` can also wrap a C code for us, but there are more efficient
    ways to perform this task. For instance, if we need to interface a very large
    library of C functions, the preferred method for doing this is **Simplified Wrapper
    and Interface Generator** (**SWIG**) ([http://www.swig.org/](http://www.swig.org/)).
    To wrap C++ code, depending on the features required and the method of interacting
    with Python, we have several methods such as SWIG or `f2py` again, but also **PyCXX**,
    **Boost.Python**, **Cython**, or the SciPy module: `weave`. When C compilers are
    not available (and thus linking extensive libraries is not possible in the usual
    way), we use `ctypes`. Whenever we will use NumPy/SciPy code, and want fast solutions
    to our wrapping/binding, the two most common ways to interact with C/C++ are usually
    through the Python/C API and `weave` packages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'All the methods briefly enumerated here would require an entire monograph to
    describe, at length, the methodology of binding the nuisances of the wrapping,
    depending on systems and requirements, and the caveats of their implementations.
    The method we would like to cover in more detail in this chapter is the `weave`
    package, more concretely by means of the `inline` routine. This command receives
    a string (raw or otherwise) containing a sequence of commands, and runs it in
    Python by calling your C/C++ compiler. The syntax is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s go over the different parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The `code` parameter is the string that holds the code to be run. Note that
    this code must not specify any kind of `return` statement. Instead, it should
    assign some result that can be returned to Python.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `arg_names` parameter is a list of strings containing the Python variable
    names that are to be sent to the C/C++ code.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `local_dict` parameter is optional, and must be a Python dictionary containing
    the values used as local scope for the C/C++ code.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `global_dict` parameter is also optional, and must be another Python dictionary
    containing the values that should be used as the global scope for the C/C++ code.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `force` parameter is used only for debugging purposes. It is also optional,
    and can take only two values—0 (by default) or 1\. If its value is set to 1, the
    C/C++ code is compiled every time `inline` is called.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may specify the compiler that takes over the C/C++ code with the `compiler`
    option. It must be a string containing the name of the C/C++ compiler.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take an example of the `inline` routine in which we use the following
    method to employ `cout` for text displaying purposes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is shown as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That was a very simple example, in which no external header declarations were
    needed. If we wish to do so, those go into the `support_code` option. For instance,
    if we wish to include math functions from R in our C/C++ code and pass it with
    `inline`, we need to perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the C functions as a shared library. In the folder, holding the R
    release in a terminal session, issue the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change to the `standalone` folder at `src/nmath` and finish the installation
    of the libraries. At the end, we should have a file named `libRmath.so`, which
    needs to be pointed to from the `libpath` string back into our Python session:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Back in our Python session, we prepare the `inline` call with the proper options.
    For instance, if we wish to call the R routine `pbinom`, we proceed as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is shown as:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the function declaration is passed in `support_code`, not in code.
    Also, note that this option needs to start with `extern "C"` whenever we are not
    using C++.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If extra headers need to be passed, we do so with the `header` option, rather
    than `support_code` or `code`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have a word of advice. Care must be taken while converting the different
    variable types from their original C/C++ format to something that Python understands.
    This requires modifying the original C/C++ code in certain cases. But by default,
    we do not have to worry about the following C/C++ types, as SciPy automatically
    turns them into the indicated Python formats, as shown in the following table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | `int` | `float` | `complex` | `string` | `list` | `dict` | `tuple`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| **C/C++** | `int` | `double` | `std::complex` | `py::string` | `py::list`
    | `py:dict` | `py::tuple` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: File types `FILE*` are sent to Python files. Python callables and instances
    are both obtained from `py::object`. NumPy ndarrays are constructed from `PyArrayObject*`.
    For any other Python type to be used, the corresponding C/C++ types must be carefully
    turned into combinations of the previous.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: And that should be all. To go beyond trivial uses of the inline function, we
    usually create extension modules and catalog the functions within for future use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with MATLAB/Octave
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since both numerical computing environments are provide with a fourth-generation
    programming language, we discourage the straightforward inclusion of code from
    any of these two. There is no gain in terms of speed, resource usage, or coding
    power. In the extreme and rare cases, in which a specific routine is not available
    in SciPy, the preferred way to bring it to our session is by generating C code
    from the MATLAB/Octave code, and then wrap it with any of the methods suggested
    in the *Interaction with C/C++* section of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个数值计算环境都提供了第四代编程语言，我们不建议直接包含这两个环境中的任何代码。在速度、资源使用或编码能力方面都没有任何优势。在极端且罕见的情况下，如果SciPy中没有特定的例程，将例程带到我们的会话中的首选方式是从MATLAB/Octave代码生成C代码，然后使用本章中*与C/C++交互*部分中建议的任何方法进行封装。
- en: There is a different story when we receive data created from within MATLAB or
    Octave. SciPy has a dedicated module to deal with this situation—`scipy.io`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收由MATLAB或Octave创建的数据时，情况会有所不同。SciPy有一个专门的模块来处理这种情况——`scipy.io`。
- en: Let's show you by example. We start with Octave, where we generate a **Delaunay
    triangulation** of a random set of 10 points in the plane.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例来展示。我们从Octave开始，在平面上生成一个由10个随机点组成的**Delaunay三角剖分**。
- en: 'We save the coordinates of these points, as well as the pointers to the triangles
    in the triangulation, to a MATLAB-style file (version 7) called data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些点的坐标以及三角剖分中三角形的指针保存到一个名为data的MATLAB风格文件（版本7）中：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are done here. We then go to our Python session, where we recover the file
    data:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里完成了。然后我们转到我们的Python会话，在那里我们恢复文件数据：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `datadict` variable holds a Python dictionary with the names of the variables
    as `keys` and the loaded matrices as their corresponding values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`datadict`变量包含一个Python字典，其中变量的名称作为`keys`，加载的矩阵作为它们对应的值：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is shown as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s issue the `datadict` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发出`datadict`命令：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is shown as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at following `datadict` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的`datadict`命令：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is possible to save data from our sessions to a format that MATLAB and Octave
    will understand. We do so with the `savemat` command, from the same module. The
    syntax is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将会话中的数据保存为MATLAB和Octave可以理解的格式。我们使用来自同一模块的`savemat`命令来完成此操作。其语法如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `file_name` parameter contains the name of the MATLAB-type file where the
    data will be written. The Python dictionary `mdict` contains the names (as keys)
    of the variables, and their corresponding array values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_name`参数包含将要写入数据的MATLAB类型文件的名称。Python字典`mdict`包含变量名称（作为键）及其对应的数组值。'
- en: If we wish to append `.mat` at the end of the file, we may do so in the `file_name`
    variable, or by setting `appendmat` to `True`. In case we need to provide long
    names for the files (which not all versions of MATLAB accept), we need to indicate
    so by setting the `long_field_names` option to `True`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在文件末尾附加`.mat`扩展名，我们可以在`file_name`变量中这样做，或者通过将`appendmat`设置为`True`。如果我们需要为文件提供长名称（并非所有MATLAB版本都接受），我们需要通过将`long_field_names`选项设置为`True`来表示这一点。
- en: We may indicate the version of MATLAB with the `format` option. We set it to
    the string `'5'` for versions 5 and later, or to the string `'4'` for version
    4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`format`选项来指定MATLAB的版本。对于5.0及以后的版本，我们将其设置为字符串`'5'`，对于4.0版本，则设置为字符串`'4'`。
- en: It is possible to compress the matrices we send, and we indicate so by setting
    the `do_compression` option to `True`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以压缩我们发送的矩阵，并且通过将`do_compression`选项设置为`True`来表示这一点。
- en: The last option is very interesting. It allows us to indicate to MATLAB/Octave
    whether our arrays are to be read column by column, or row by row. Setting the
    `oned_as` parameter to the string `'column'` will send our data into a collection
    of column vectors. If we set it to the string `'row'`, it will send the data as
    collections of row vectors. If set to `None`, the format in which the data was
    written is respected.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项非常有趣。它允许我们向MATLAB/Octave指示我们的数组是按列读取还是按行读取。将`oned_as`参数设置为字符串`'column'`将我们的数据发送到一列向量集合中。如果我们将其设置为字符串`'row'`，它将数据作为行向量集合发送。如果设置为`None`，则尊重数据写入的格式。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced one of the main strengths of SciPy—the ability to interact
    with other languages such as C/C++, Fortran, R, and MATLAB/Octave. To go in depth
    into interfacing Python with other languages, you might want to read more specialized
    literature like *Learning Cython Programming*, *Philip Herron*, *Packt Publishing*
    or the in-depth coverage of F2PY at [http://docs.scipy.org/doc/numpy/f2py/](http://docs.scipy.org/doc/numpy/f2py/)
    and [http://www.f2py.com/home/references](http://www.f2py.com/home/references).
    Additional help can be found at [https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages](https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 SciPy 的一个主要优势——能够与其他语言如 C/C++、Fortran、R 和 MATLAB/Octave 交互。要深入了解 Python
    与其他语言的接口，您可能需要阅读更多专门的文献，如 *《Cython 编程学习》*，作者 *Philip Herron*，出版社 *Packt Publishing*，或者深入了解
    F2PY 的资料，可在 [http://docs.scipy.org/doc/numpy/f2py/](http://docs.scipy.org/doc/numpy/f2py/)
    和 [http://www.f2py.com/home/references](http://www.f2py.com/home/references) 找到。更多帮助信息可在
    [https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages](https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages)
    找到。
- en: If you have reached this chapter and have been reading from the first one, you
    should be aware that many topics were left out in this introductory chapter on
    SciPy. This book has given you enough background to further strengthen your skills
    and ability to work with SciPy. To proceed studying, refer to the SciPy Reference
    Guide ([http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/))
    and other documentation guides available at ([http://docs.scipy.org/doc/](http://docs.scipy.org/doc/)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读到这一章，并且是从第一章开始阅读的，那么您应该知道在本章关于 SciPy 的简介中省略了许多主题。本书已经为您提供了足够的背景知识，以进一步强化您使用
    SciPy 的技能和能力。要继续学习，请参考 SciPy 参考指南 ([http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/))
    和其他可用的文档指南 ([http://docs.scipy.org/doc/](http://docs.scipy.org/doc/))。
- en: In addition, we recommend you regularly read and also subscribe to the SciPy
    mailing list ([http://mail.scipy.org/mailman/listinfo/scipy-user](http://mail.scipy.org/mailman/listinfo/scipy-user))
    where you can interact with users of SciPy all over the world, not only by asking/answering
    questions about SciPy, but also to find out current trends on SciPy and even jobs
    related to it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们建议您定期阅读并订阅 SciPy 邮件列表 ([http://mail.scipy.org/mailman/listinfo/scipy-user](http://mail.scipy.org/mailman/listinfo/scipy-user))，在那里您可以与世界各地的
    SciPy 用户互动，不仅可以通过提问/回答有关 SciPy 的问题，还可以了解 SciPy 的当前趋势，甚至找到与之相关的职位。
- en: You can peruse the historical archive of the collection of postings to the list,
    [http://mail.scipy.org/pipermail/scipy-user/](http://mail.scipy.org/pipermail/scipy-user/).
    Also, you should know that there is a SciPy conference held every year ([http://conference.scipy.org/](http://conference.scipy.org/))
    which, to quote them, allows participants from academic, commercial, and governmental
    organizations to showcase their latest Scientific Python projects, learn from
    skilled users and developers, and collaborate on code development.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以浏览该列表历史存档的帖子集合，[http://mail.scipy.org/pipermail/scipy-user/](http://mail.scipy.org/pipermail/scipy-user/)。此外，您应该知道每年都会举办
    SciPy 会议 ([http://conference.scipy.org/](http://conference.scipy.org/))，正如他们所说，这允许来自学术、商业和政府机构的参与者展示他们最新的科学
    Python 项目，从熟练的用户和开发者那里学习，并在代码开发上进行合作。
