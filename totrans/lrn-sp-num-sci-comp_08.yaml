- en: Chapter 8. Interaction with Other Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。与其他语言的交互
- en: We often need to incorporate into our workflow some code written in different
    languages; mostly C/C++ or Fortran, and also from R, MATLAB, or Octave. Python
    excels at allowing code from all these other sources to run from within; care
    must be taken to convert different numerical types to something that Python understands,
    but this is pretty much the only issue we encounter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要将不同语言的代码整合到我们的工作流程中；主要是 C/C++ 或 Fortran，以及来自 R、MATLAB 或 Octave 的代码。Python
    优秀地允许所有这些其他来源的代码在内部运行；必须注意将不同的数值类型转换为 Python 可以理解的形式，但这几乎是我们遇到唯一的难题。
- en: If you are working with SciPy, it is because your Python ecosystem has available
    compilers for C and Fortran programs. Otherwise, SciPy could have not been installed
    on your system. Also, given its popularity, it is highly probably that your computer
    environment has MATLAB/Octave available. Accordingly, this has driven the selection
    of topics listed later in this chapter. We left to the interested reader to find
    out how interface with R and many other software is available out there for numerical
    computing. Two alternatives to do that with R are the packages **PypeR** ([http://bioinfo.ihb.ac.cn/softwares/PypeR/](http://bioinfo.ihb.ac.cn/softwares/PypeR/))
    and **rpy2** ([http://rpy.sourceforge.net/](http://rpy.sourceforge.net/)). Additional
    alternatives can be found at [http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language](http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用 SciPy，那是因为您的 Python 生态系统中有可用的 C 和 Fortran 程序编译器。否则，SciPy 就无法安装到您的系统上。鉴于其流行程度，您的计算机环境很可能有
    MATLAB/Octave。因此，这导致了本章后面列出主题的选择。我们将留给感兴趣的读者去了解如何与 R 和许多其他软件进行接口，这些软件可用于数值计算。使用
    R 的两种替代方案是包 **PypeR** ([http://bioinfo.ihb.ac.cn/softwares/PypeR/](http://bioinfo.ihb.ac.cn/softwares/PypeR/))
    和 **rpy2** ([http://rpy.sourceforge.net/](http://rpy.sourceforge.net/))。其他替代方案可以在
    [http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language](http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language)
    找到。
- en: 'In this chapter, we will cover the following things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: A brief discussion on how Python can be used to run codes from Fortran, C/C++,
    and MATLAB/Octave
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要讨论如何使用 Python 运行 Fortran、C/C++ 和 MATLAB/Octave 的代码
- en: We will first see the basic functionality of the utility `f2py` to handle the
    inclusion of Fortran codes in Python via SciPy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先了解实用程序 `f2py` 的基本功能，以通过 SciPy 处理在 Python 中包含 Fortran 代码。
- en: A basic usage to include C/C++ code within Python code using the tools provided
    by the the `scipy.weav``e` module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `scipy.weave` 模块提供的工具在 Python 代码中包含 C/C++ 代码的基本用法
- en: The routines will be illustrated via simple examples that can be enriched by
    you modifying the IPython Notebook corresponding to this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的示例来展示这些例程，您可以通过修改与本章对应的 IPython Notebook 来丰富这些示例。
- en: Interaction with Fortran
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Fortran 的交互
- en: SciPy provides a simple way of including Fortran code—`f2py`. This is a utility
    shipped with the NumPy libraries, which is operative when `distutils` from SciPy
    are available. This is always the case when we install SciPy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 提供了一种简单的方法来包含 Fortran 代码——`f2py`。这是一个与 NumPy 库一起提供的实用程序，当 SciPy 的 `distutils`
    可用时才会生效。当我们安装 SciPy 时，这总是成立的。
- en: The `f2py` utility is supposed to run outside Python, and it is used to create
    from any Fortran file a Python module that can be easily called in our sessions.
    Under any `*nix` system, we call it from the terminal. Under Windows, we recommend
    you run it in the native terminal, or even better, through a `cygwin` session.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`f2py` 实用程序应该在 Python 之外运行，它用于从任何 Fortran 文件创建一个可以在我们的会话中轻松调用的 Python 模块。在任何
    `*nix` 系统中，我们从终端调用它。在 Windows 上，我们建议您在原生终端中运行它，或者更好的是，通过 `cygwin` 会话运行。'
- en: 'Before being compiled with `f2py`, any Fortran code needs to undergo three
    basic changes, which are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `f2py` 编译之前，任何 Fortran 代码都需要进行以下三个基本更改：
- en: Removal of all allocations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除所有分配
- en: Transformation of the whole program into a subroutine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整个程序转换为一个子程序
- en: If anything special needs to be passed to `f2py`, we must add it with the comment
    string `"!f2py"` or `"cf2py"`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将任何特殊内容传递给 `f2py`，我们必须使用注释字符串 `"!f2py"` 或 `"cf2py"` 来添加它。
- en: 'Let''s illustrate the process with a simple example. The following naive subroutine,
    which we store in the `primefactors.f90` file, performs a factorization in prime
    numbers for any given integer:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明这个过程。以下存储在 `primefactors.f90` 文件中的简单子程序，对任何给定的整数进行质因数分解：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since no allocation was made in the code, and we receive a subroutine directly,
    we may skip to the third step, but for the moment we will not tamper with `f2py`
    commands, and are content with trying to create a python module from it. The fastest
    way to wrap this `primefactors` subroutine is by issuing the following command
    (at the shell or terminal prompt indicated by `%`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码中没有进行任何分配，并且我们直接收到一个子例程，我们可以跳到第三步，但暂时我们不会修改 `f2py` 命令，我们满足于尝试从它创建一个 Python
    模块。将此 `primefactors` 子例程包装起来的最快方式是发出以下命令（在由 `%` 指示的 shell 或终端提示符处）：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If everything is correct, an extension module with the name `primefactors.so`
    is created. We can then access the `primefactors` routine in Python from the `primefactors`
    module:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，将创建一个名为 `primefactors.so` 的扩展模块。然后我们可以从 `primefactors` 模块中访问 `primefactors`
    例程：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Interaction with C/C++
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 C/C++ 的交互
- en: 'Technically, `f2py` can also wrap a C code for us, but there are more efficient
    ways to perform this task. For instance, if we need to interface a very large
    library of C functions, the preferred method for doing this is **Simplified Wrapper
    and Interface Generator** (**SWIG**) ([http://www.swig.org/](http://www.swig.org/)).
    To wrap C++ code, depending on the features required and the method of interacting
    with Python, we have several methods such as SWIG or `f2py` again, but also **PyCXX**,
    **Boost.Python**, **Cython**, or the SciPy module: `weave`. When C compilers are
    not available (and thus linking extensive libraries is not possible in the usual
    way), we use `ctypes`. Whenever we will use NumPy/SciPy code, and want fast solutions
    to our wrapping/binding, the two most common ways to interact with C/C++ are usually
    through the Python/C API and `weave` packages.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`f2py` 也可以为我们包装 C 代码，但还有更有效的方法来完成这项任务。例如，如果我们需要接口一个非常大的 C 函数库，完成此任务的首选方法是
    **简化包装和接口生成器**（**SWIG**）（[http://www.swig.org/](http://www.swig.org/)）。要包装 C++
    代码，根据所需功能和与 Python 交互的方法，我们有几种方法，如 SWIG 或再次使用 `f2py`，但还有 **PyCXX**、**Boost.Python**、**Cython**
    或 SciPy 模块：`weave`。当 C 编译器不可用（因此无法以通常的方式链接大量库）时，我们使用 `ctypes`。每当我们将使用 NumPy/SciPy
    代码，并且想要快速解决我们的包装/绑定问题时，与 C/C++ 交互的两种最常见方式通常是 Python/C API 和 `weave` 包。
- en: 'All the methods briefly enumerated here would require an entire monograph to
    describe, at length, the methodology of binding the nuisances of the wrapping,
    depending on systems and requirements, and the caveats of their implementations.
    The method we would like to cover in more detail in this chapter is the `weave`
    package, more concretely by means of the `inline` routine. This command receives
    a string (raw or otherwise) containing a sequence of commands, and runs it in
    Python by calling your C/C++ compiler. The syntax is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要列举的所有方法都需要一本专著来详细描述，具体来说，就是根据系统和需求绑定包装的繁琐之处的方法，以及它们实现时的注意事项。在本章中，我们想更详细地介绍的是
    `weave` 包，更具体地说，是通过 `inline` 例程。此命令接收一个包含一系列命令的字符串（原始或非原始），并通过调用您的 C/C++ 编译器在
    Python 中运行它。语法如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s go over the different parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同的参数：
- en: The `code` parameter is the string that holds the code to be run. Note that
    this code must not specify any kind of `return` statement. Instead, it should
    assign some result that can be returned to Python.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`code` 参数是包含要运行的代码的字符串。请注意，此代码不得指定任何类型的 `return` 语句。相反，它应分配一些可以返回给 Python 的结果。'
- en: The `arg_names` parameter is a list of strings containing the Python variable
    names that are to be sent to the C/C++ code.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg_names` 参数是一个包含要发送到 C/C++ 代码的 Python 变量名的字符串列表。'
- en: The `local_dict` parameter is optional, and must be a Python dictionary containing
    the values used as local scope for the C/C++ code.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_dict` 参数是可选的，它必须是一个包含用作 C/C++ 代码局部作用域的值的 Python 字典。'
- en: The `global_dict` parameter is also optional, and must be another Python dictionary
    containing the values that should be used as the global scope for the C/C++ code.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`global_dict` 参数也是可选的，它必须是一个包含应作为 C/C++ 代码全局作用域的值的另一个 Python 字典。'
- en: The `force` parameter is used only for debugging purposes. It is also optional,
    and can take only two values—0 (by default) or 1\. If its value is set to 1, the
    C/C++ code is compiled every time `inline` is called.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force` 参数仅用于调试目的。它也是可选的，只能取两个值——0（默认值）或 1。如果其值设置为 1，则每次调用 `inline` 时都会编译 C/C++
    代码。'
- en: We may specify the compiler that takes over the C/C++ code with the `compiler`
    option. It must be a string containing the name of the C/C++ compiler.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`compiler`选项指定接管C/C++代码的编译器。它必须是一个包含C/C++编译器名称的字符串。
- en: 'Let''s take an example of the `inline` routine in which we use the following
    method to employ `cout` for text displaying purposes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`inline`例程为例，其中我们使用以下方法来使用`cout`进行文本显示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is shown as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That was a very simple example, in which no external header declarations were
    needed. If we wish to do so, those go into the `support_code` option. For instance,
    if we wish to include math functions from R in our C/C++ code and pass it with
    `inline`, we need to perform the following steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，其中不需要外部头文件声明。如果我们希望这样做，那些将放入`support_code`选项中。例如，如果我们希望在C/C++代码中包含R的数学函数并通过`inline`传递，我们需要执行以下步骤：
- en: 'Configure the C functions as a shared library. In the folder, holding the R
    release in a terminal session, issue the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C函数配置为共享库。在终端会话中，在包含R发布的文件夹中，输入以下命令：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change to the `standalone` folder at `src/nmath` and finish the installation
    of the libraries. At the end, we should have a file named `libRmath.so`, which
    needs to be pointed to from the `libpath` string back into our Python session:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`src/nmath`中的`standalone`文件夹，完成库的安装。最后，我们应该有一个名为`libRmath.so`的文件，需要从`libpath`字符串指向我们的Python会话：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Back in our Python session, we prepare the `inline` call with the proper options.
    For instance, if we wish to call the R routine `pbinom`, we proceed as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Python会话中，我们使用适当的选项准备`inline`调用。例如，如果我们想调用R例程`pbinom`，我们按以下步骤进行：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is shown as:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how the function declaration is passed in `support_code`, not in code.
    Also, note that this option needs to start with `extern "C"` whenever we are not
    using C++.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意函数声明是在`support_code`中传递的，而不是在代码中。还要注意，每次我们不使用C++时，此选项都需要以`extern "C"`开头。
- en: 'If extra headers need to be passed, we do so with the `header` option, rather
    than `support_code` or `code`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要传递额外的头文件，我们使用`header`选项，而不是`support_code`或`code`：
- en: '[PRE11]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have a word of advice. Care must be taken while converting the different
    variable types from their original C/C++ format to something that Python understands.
    This requires modifying the original C/C++ code in certain cases. But by default,
    we do not have to worry about the following C/C++ types, as SciPy automatically
    turns them into the indicated Python formats, as shown in the following table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些建议。在将不同变量类型从其原始C/C++格式转换为Python理解的形式时，必须小心谨慎。在某些情况下，这需要修改原始的C/C++代码。但默认情况下，我们不必担心以下C/C++类型，因为SciPy会自动将它们转换为以下表所示的Python格式：
- en: '| **Python** | `int` | `float` | `complex` | `string` | `list` | `dict` | `tuple`
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **Python** | `int` | `float` | `complex` | `string` | `list` | `dict` | `tuple`
    |'
- en: '| **C/C++** | `int` | `double` | `std::complex` | `py::string` | `py::list`
    | `py:dict` | `py::tuple` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **C/C++** | `int` | `double` | `std::complex` | `py::string` | `py::list`
    | `py:dict` | `py::tuple` |'
- en: File types `FILE*` are sent to Python files. Python callables and instances
    are both obtained from `py::object`. NumPy ndarrays are constructed from `PyArrayObject*`.
    For any other Python type to be used, the corresponding C/C++ types must be carefully
    turned into combinations of the previous.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型`FILE*`被发送到Python文件。Python的可调用对象和实例都来自`py::object`。NumPy ndarrays是从`PyArrayObject*`构建的。对于任何其他要使用的Python类型，相应的C/C++类型必须仔细转换为前面的组合。
- en: And that should be all. To go beyond trivial uses of the inline function, we
    usually create extension modules and catalog the functions within for future use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就足够了。要超越内联函数的简单使用，我们通常创建扩展模块，并将其中的函数编目以供将来使用。
- en: Interaction with MATLAB/Octave
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与MATLAB/Octave的交互
- en: Since both numerical computing environments are provide with a fourth-generation
    programming language, we discourage the straightforward inclusion of code from
    any of these two. There is no gain in terms of speed, resource usage, or coding
    power. In the extreme and rare cases, in which a specific routine is not available
    in SciPy, the preferred way to bring it to our session is by generating C code
    from the MATLAB/Octave code, and then wrap it with any of the methods suggested
    in the *Interaction with C/C++* section of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个数值计算环境都提供了第四代编程语言，我们不建议直接包含这两个环境中的任何代码。在速度、资源使用或编码能力方面都没有任何优势。在极端且罕见的情况下，如果SciPy中没有特定的例程，将例程带到我们的会话中的首选方式是从MATLAB/Octave代码生成C代码，然后使用本章中*与C/C++交互*部分中建议的任何方法进行封装。
- en: There is a different story when we receive data created from within MATLAB or
    Octave. SciPy has a dedicated module to deal with this situation—`scipy.io`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收由MATLAB或Octave创建的数据时，情况会有所不同。SciPy有一个专门的模块来处理这种情况——`scipy.io`。
- en: Let's show you by example. We start with Octave, where we generate a **Delaunay
    triangulation** of a random set of 10 points in the plane.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例来展示。我们从Octave开始，在平面上生成一个由10个随机点组成的**Delaunay三角剖分**。
- en: 'We save the coordinates of these points, as well as the pointers to the triangles
    in the triangulation, to a MATLAB-style file (version 7) called data:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些点的坐标以及三角剖分中三角形的指针保存到一个名为data的MATLAB风格文件（版本7）中：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are done here. We then go to our Python session, where we recover the file
    data:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里完成了。然后我们转到我们的Python会话，在那里我们恢复文件数据：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `datadict` variable holds a Python dictionary with the names of the variables
    as `keys` and the loaded matrices as their corresponding values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`datadict`变量包含一个Python字典，其中变量的名称作为`keys`，加载的矩阵作为它们对应的值：'
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is shown as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s issue the `datadict` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发出`datadict`命令：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is shown as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at following `datadict` command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的`datadict`命令：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is possible to save data from our sessions to a format that MATLAB and Octave
    will understand. We do so with the `savemat` command, from the same module. The
    syntax is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将会话中的数据保存为MATLAB和Octave可以理解的格式。我们使用来自同一模块的`savemat`命令来完成此操作。其语法如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `file_name` parameter contains the name of the MATLAB-type file where the
    data will be written. The Python dictionary `mdict` contains the names (as keys)
    of the variables, and their corresponding array values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_name`参数包含将要写入数据的MATLAB类型文件的名称。Python字典`mdict`包含变量名称（作为键）及其对应的数组值。'
- en: If we wish to append `.mat` at the end of the file, we may do so in the `file_name`
    variable, or by setting `appendmat` to `True`. In case we need to provide long
    names for the files (which not all versions of MATLAB accept), we need to indicate
    so by setting the `long_field_names` option to `True`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在文件末尾附加`.mat`扩展名，我们可以在`file_name`变量中这样做，或者通过将`appendmat`设置为`True`。如果我们需要为文件提供长名称（并非所有MATLAB版本都接受），我们需要通过将`long_field_names`选项设置为`True`来表示这一点。
- en: We may indicate the version of MATLAB with the `format` option. We set it to
    the string `'5'` for versions 5 and later, or to the string `'4'` for version
    4.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`format`选项来指定MATLAB的版本。对于5.0及以后的版本，我们将其设置为字符串`'5'`，对于4.0版本，则设置为字符串`'4'`。
- en: It is possible to compress the matrices we send, and we indicate so by setting
    the `do_compression` option to `True`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以压缩我们发送的矩阵，并且通过将`do_compression`选项设置为`True`来表示这一点。
- en: The last option is very interesting. It allows us to indicate to MATLAB/Octave
    whether our arrays are to be read column by column, or row by row. Setting the
    `oned_as` parameter to the string `'column'` will send our data into a collection
    of column vectors. If we set it to the string `'row'`, it will send the data as
    collections of row vectors. If set to `None`, the format in which the data was
    written is respected.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项非常有趣。它允许我们向MATLAB/Octave指示我们的数组是按列读取还是按行读取。将`oned_as`参数设置为字符串`'column'`将我们的数据发送到一列向量集合中。如果我们将其设置为字符串`'row'`，它将数据作为行向量集合发送。如果设置为`None`，则尊重数据写入的格式。
- en: Summary
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced one of the main strengths of SciPy—the ability to interact
    with other languages such as C/C++, Fortran, R, and MATLAB/Octave. To go in depth
    into interfacing Python with other languages, you might want to read more specialized
    literature like *Learning Cython Programming*, *Philip Herron*, *Packt Publishing*
    or the in-depth coverage of F2PY at [http://docs.scipy.org/doc/numpy/f2py/](http://docs.scipy.org/doc/numpy/f2py/)
    and [http://www.f2py.com/home/references](http://www.f2py.com/home/references).
    Additional help can be found at [https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages](https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 SciPy 的一个主要优势——能够与其他语言如 C/C++、Fortran、R 和 MATLAB/Octave 交互。要深入了解 Python
    与其他语言的接口，您可能需要阅读更多专门的文献，如 *《Cython 编程学习》*，作者 *Philip Herron*，出版社 *Packt Publishing*，或者深入了解
    F2PY 的资料，可在 [http://docs.scipy.org/doc/numpy/f2py/](http://docs.scipy.org/doc/numpy/f2py/)
    和 [http://www.f2py.com/home/references](http://www.f2py.com/home/references) 找到。更多帮助信息可在
    [https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages](https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages)
    找到。
- en: If you have reached this chapter and have been reading from the first one, you
    should be aware that many topics were left out in this introductory chapter on
    SciPy. This book has given you enough background to further strengthen your skills
    and ability to work with SciPy. To proceed studying, refer to the SciPy Reference
    Guide ([http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/))
    and other documentation guides available at ([http://docs.scipy.org/doc/](http://docs.scipy.org/doc/)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读到这一章，并且是从第一章开始阅读的，那么您应该知道在本章关于 SciPy 的简介中省略了许多主题。本书已经为您提供了足够的背景知识，以进一步强化您使用
    SciPy 的技能和能力。要继续学习，请参考 SciPy 参考指南 ([http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/))
    和其他可用的文档指南 ([http://docs.scipy.org/doc/](http://docs.scipy.org/doc/))。
- en: In addition, we recommend you regularly read and also subscribe to the SciPy
    mailing list ([http://mail.scipy.org/mailman/listinfo/scipy-user](http://mail.scipy.org/mailman/listinfo/scipy-user))
    where you can interact with users of SciPy all over the world, not only by asking/answering
    questions about SciPy, but also to find out current trends on SciPy and even jobs
    related to it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们建议您定期阅读并订阅 SciPy 邮件列表 ([http://mail.scipy.org/mailman/listinfo/scipy-user](http://mail.scipy.org/mailman/listinfo/scipy-user))，在那里您可以与世界各地的
    SciPy 用户互动，不仅可以通过提问/回答有关 SciPy 的问题，还可以了解 SciPy 的当前趋势，甚至找到与之相关的职位。
- en: You can peruse the historical archive of the collection of postings to the list,
    [http://mail.scipy.org/pipermail/scipy-user/](http://mail.scipy.org/pipermail/scipy-user/).
    Also, you should know that there is a SciPy conference held every year ([http://conference.scipy.org/](http://conference.scipy.org/))
    which, to quote them, allows participants from academic, commercial, and governmental
    organizations to showcase their latest Scientific Python projects, learn from
    skilled users and developers, and collaborate on code development.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以浏览该列表历史存档的帖子集合，[http://mail.scipy.org/pipermail/scipy-user/](http://mail.scipy.org/pipermail/scipy-user/)。此外，您应该知道每年都会举办
    SciPy 会议 ([http://conference.scipy.org/](http://conference.scipy.org/))，正如他们所说，这允许来自学术、商业和政府机构的参与者展示他们最新的科学
    Python 项目，从熟练的用户和开发者那里学习，并在代码开发上进行合作。
