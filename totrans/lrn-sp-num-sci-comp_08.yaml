- en: Chapter 8. Interaction with Other Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to incorporate into our workflow some code written in different
    languages; mostly C/C++ or Fortran, and also from R, MATLAB, or Octave. Python
    excels at allowing code from all these other sources to run from within; care
    must be taken to convert different numerical types to something that Python understands,
    but this is pretty much the only issue we encounter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with SciPy, it is because your Python ecosystem has available
    compilers for C and Fortran programs. Otherwise, SciPy could have not been installed
    on your system. Also, given its popularity, it is highly probably that your computer
    environment has MATLAB/Octave available. Accordingly, this has driven the selection
    of topics listed later in this chapter. We left to the interested reader to find
    out how interface with R and many other software is available out there for numerical
    computing. Two alternatives to do that with R are the packages **PypeR** ([http://bioinfo.ihb.ac.cn/softwares/PypeR/](http://bioinfo.ihb.ac.cn/softwares/PypeR/))
    and **rpy2** ([http://rpy.sourceforge.net/](http://rpy.sourceforge.net/)). Additional
    alternatives can be found at [http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language](http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief discussion on how Python can be used to run codes from Fortran, C/C++,
    and MATLAB/Octave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first see the basic functionality of the utility `f2py` to handle the
    inclusion of Fortran codes in Python via SciPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic usage to include C/C++ code within Python code using the tools provided
    by the the `scipy.weav``e` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The routines will be illustrated via simple examples that can be enriched by
    you modifying the IPython Notebook corresponding to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with Fortran
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SciPy provides a simple way of including Fortran code—`f2py`. This is a utility
    shipped with the NumPy libraries, which is operative when `distutils` from SciPy
    are available. This is always the case when we install SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: The `f2py` utility is supposed to run outside Python, and it is used to create
    from any Fortran file a Python module that can be easily called in our sessions.
    Under any `*nix` system, we call it from the terminal. Under Windows, we recommend
    you run it in the native terminal, or even better, through a `cygwin` session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before being compiled with `f2py`, any Fortran code needs to undergo three
    basic changes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of all allocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformation of the whole program into a subroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If anything special needs to be passed to `f2py`, we must add it with the comment
    string `"!f2py"` or `"cf2py"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s illustrate the process with a simple example. The following naive subroutine,
    which we store in the `primefactors.f90` file, performs a factorization in prime
    numbers for any given integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since no allocation was made in the code, and we receive a subroutine directly,
    we may skip to the third step, but for the moment we will not tamper with `f2py`
    commands, and are content with trying to create a python module from it. The fastest
    way to wrap this `primefactors` subroutine is by issuing the following command
    (at the shell or terminal prompt indicated by `%`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correct, an extension module with the name `primefactors.so`
    is created. We can then access the `primefactors` routine in Python from the `primefactors`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Interaction with C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, `f2py` can also wrap a C code for us, but there are more efficient
    ways to perform this task. For instance, if we need to interface a very large
    library of C functions, the preferred method for doing this is **Simplified Wrapper
    and Interface Generator** (**SWIG**) ([http://www.swig.org/](http://www.swig.org/)).
    To wrap C++ code, depending on the features required and the method of interacting
    with Python, we have several methods such as SWIG or `f2py` again, but also **PyCXX**,
    **Boost.Python**, **Cython**, or the SciPy module: `weave`. When C compilers are
    not available (and thus linking extensive libraries is not possible in the usual
    way), we use `ctypes`. Whenever we will use NumPy/SciPy code, and want fast solutions
    to our wrapping/binding, the two most common ways to interact with C/C++ are usually
    through the Python/C API and `weave` packages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the methods briefly enumerated here would require an entire monograph to
    describe, at length, the methodology of binding the nuisances of the wrapping,
    depending on systems and requirements, and the caveats of their implementations.
    The method we would like to cover in more detail in this chapter is the `weave`
    package, more concretely by means of the `inline` routine. This command receives
    a string (raw or otherwise) containing a sequence of commands, and runs it in
    Python by calling your C/C++ compiler. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over the different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `code` parameter is the string that holds the code to be run. Note that
    this code must not specify any kind of `return` statement. Instead, it should
    assign some result that can be returned to Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `arg_names` parameter is a list of strings containing the Python variable
    names that are to be sent to the C/C++ code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `local_dict` parameter is optional, and must be a Python dictionary containing
    the values used as local scope for the C/C++ code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `global_dict` parameter is also optional, and must be another Python dictionary
    containing the values that should be used as the global scope for the C/C++ code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `force` parameter is used only for debugging purposes. It is also optional,
    and can take only two values—0 (by default) or 1\. If its value is set to 1, the
    C/C++ code is compiled every time `inline` is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We may specify the compiler that takes over the C/C++ code with the `compiler`
    option. It must be a string containing the name of the C/C++ compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take an example of the `inline` routine in which we use the following
    method to employ `cout` for text displaying purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That was a very simple example, in which no external header declarations were
    needed. If we wish to do so, those go into the `support_code` option. For instance,
    if we wish to include math functions from R in our C/C++ code and pass it with
    `inline`, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the C functions as a shared library. In the folder, holding the R
    release in a terminal session, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change to the `standalone` folder at `src/nmath` and finish the installation
    of the libraries. At the end, we should have a file named `libRmath.so`, which
    needs to be pointed to from the `libpath` string back into our Python session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in our Python session, we prepare the `inline` call with the proper options.
    For instance, if we wish to call the R routine `pbinom`, we proceed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is shown as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note how the function declaration is passed in `support_code`, not in code.
    Also, note that this option needs to start with `extern "C"` whenever we are not
    using C++.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If extra headers need to be passed, we do so with the `header` option, rather
    than `support_code` or `code`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a word of advice. Care must be taken while converting the different
    variable types from their original C/C++ format to something that Python understands.
    This requires modifying the original C/C++ code in certain cases. But by default,
    we do not have to worry about the following C/C++ types, as SciPy automatically
    turns them into the indicated Python formats, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Python** | `int` | `float` | `complex` | `string` | `list` | `dict` | `tuple`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **C/C++** | `int` | `double` | `std::complex` | `py::string` | `py::list`
    | `py:dict` | `py::tuple` |'
  prefs: []
  type: TYPE_TB
- en: File types `FILE*` are sent to Python files. Python callables and instances
    are both obtained from `py::object`. NumPy ndarrays are constructed from `PyArrayObject*`.
    For any other Python type to be used, the corresponding C/C++ types must be carefully
    turned into combinations of the previous.
  prefs: []
  type: TYPE_NORMAL
- en: And that should be all. To go beyond trivial uses of the inline function, we
    usually create extension modules and catalog the functions within for future use.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with MATLAB/Octave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since both numerical computing environments are provide with a fourth-generation
    programming language, we discourage the straightforward inclusion of code from
    any of these two. There is no gain in terms of speed, resource usage, or coding
    power. In the extreme and rare cases, in which a specific routine is not available
    in SciPy, the preferred way to bring it to our session is by generating C code
    from the MATLAB/Octave code, and then wrap it with any of the methods suggested
    in the *Interaction with C/C++* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is a different story when we receive data created from within MATLAB or
    Octave. SciPy has a dedicated module to deal with this situation—`scipy.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's show you by example. We start with Octave, where we generate a **Delaunay
    triangulation** of a random set of 10 points in the plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'We save the coordinates of these points, as well as the pointers to the triangles
    in the triangulation, to a MATLAB-style file (version 7) called data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done here. We then go to our Python session, where we recover the file
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `datadict` variable holds a Python dictionary with the names of the variables
    as `keys` and the loaded matrices as their corresponding values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s issue the `datadict` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at following `datadict` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to save data from our sessions to a format that MATLAB and Octave
    will understand. We do so with the `savemat` command, from the same module. The
    syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `file_name` parameter contains the name of the MATLAB-type file where the
    data will be written. The Python dictionary `mdict` contains the names (as keys)
    of the variables, and their corresponding array values.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to append `.mat` at the end of the file, we may do so in the `file_name`
    variable, or by setting `appendmat` to `True`. In case we need to provide long
    names for the files (which not all versions of MATLAB accept), we need to indicate
    so by setting the `long_field_names` option to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: We may indicate the version of MATLAB with the `format` option. We set it to
    the string `'5'` for versions 5 and later, or to the string `'4'` for version
    4.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to compress the matrices we send, and we indicate so by setting
    the `do_compression` option to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The last option is very interesting. It allows us to indicate to MATLAB/Octave
    whether our arrays are to be read column by column, or row by row. Setting the
    `oned_as` parameter to the string `'column'` will send our data into a collection
    of column vectors. If we set it to the string `'row'`, it will send the data as
    collections of row vectors. If set to `None`, the format in which the data was
    written is respected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced one of the main strengths of SciPy—the ability to interact
    with other languages such as C/C++, Fortran, R, and MATLAB/Octave. To go in depth
    into interfacing Python with other languages, you might want to read more specialized
    literature like *Learning Cython Programming*, *Philip Herron*, *Packt Publishing*
    or the in-depth coverage of F2PY at [http://docs.scipy.org/doc/numpy/f2py/](http://docs.scipy.org/doc/numpy/f2py/)
    and [http://www.f2py.com/home/references](http://www.f2py.com/home/references).
    Additional help can be found at [https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages](https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages).
  prefs: []
  type: TYPE_NORMAL
- en: If you have reached this chapter and have been reading from the first one, you
    should be aware that many topics were left out in this introductory chapter on
    SciPy. This book has given you enough background to further strengthen your skills
    and ability to work with SciPy. To proceed studying, refer to the SciPy Reference
    Guide ([http://docs.scipy.org/doc/scipy/reference/](http://docs.scipy.org/doc/scipy/reference/))
    and other documentation guides available at ([http://docs.scipy.org/doc/](http://docs.scipy.org/doc/)).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we recommend you regularly read and also subscribe to the SciPy
    mailing list ([http://mail.scipy.org/mailman/listinfo/scipy-user](http://mail.scipy.org/mailman/listinfo/scipy-user))
    where you can interact with users of SciPy all over the world, not only by asking/answering
    questions about SciPy, but also to find out current trends on SciPy and even jobs
    related to it.
  prefs: []
  type: TYPE_NORMAL
- en: You can peruse the historical archive of the collection of postings to the list,
    [http://mail.scipy.org/pipermail/scipy-user/](http://mail.scipy.org/pipermail/scipy-user/).
    Also, you should know that there is a SciPy conference held every year ([http://conference.scipy.org/](http://conference.scipy.org/))
    which, to quote them, allows participants from academic, commercial, and governmental
    organizations to showcase their latest Scientific Python projects, learn from
    skilled users and developers, and collaborate on code development.
  prefs: []
  type: TYPE_NORMAL
