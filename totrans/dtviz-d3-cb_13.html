<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Test Drive your Visualization"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Test Drive your Visualization</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting Jasmine and setting up the test environment</li><li class="listitem" style="list-style-type: disc">Test driving your visualization – chart creation</li><li class="listitem" style="list-style-type: disc">Test driving your visualization – SVG rendering</li><li class="listitem" style="list-style-type: disc">Test driving your visualization – pixel-perfect bar rendering</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec87"/>Introduction</h1></div></div></div><p>Whenever we program as a professional programmer it is always important to test the program we write in order to make sure it functions as designed and produces the expected outcome. D3 data visualization mainly consists of JavaScript programs hence just like any other program we write, data visualization needs to be tested to make sure it represents the underlying data accurately. Obviously, we can perform our validation through visual examination and manual testing, which is always a critical part of the process of building data visualization since visual observation gives us a chance to verify not only the correctness, but also the aesthetics, usability, and many other useful aspects. However, manual visual inspection can be quite subjective, therefore, in this chapter we will focus our effort on automated unit testing. Visualization well covered by unit tests can free the creator from the manual labor of verifying correctness by hand additionally, allowing him/her to focus more on the aesthetics, usability, and other important aspects where it is hard to automate with machine.</p><div class="section" title="Introduction to unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec258"/>Introduction to unit testing</h2></div></div></div><p>Unit testing<a id="id674" class="indexterm"/> is a method in which a smallest unit of the program is tested and verified by another program called the test case. The logic behind unit testing is that at unit level the program is typically simpler and more testable. If we can verify if every unit in the program is correct then putting these correct units together will give us a higher confidence that the integrated program is also correct. Furthermore, since unit tests are typically cheap and fast to execute, a group of unit test cases can be quickly and frequently executed to provide feedback whether our program is performing correctly or not.</p><p>Software testing <a id="id675" class="indexterm"/>is a complex topic and so far we have only scratched the surface; however, due to limited scope in this chapter, we will have to stop our introduction now and dive into developing unit tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>For more information on testing please check out the following links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit test: <a class="ulink" href="http://en.wikipedia.org/wiki/Unit_testing">http://en.wikipedia.org/wiki/Unit_testing</a></li></ul></div><p>Test driven development: <a class="ulink" href="http://en.wikipedia.org/wiki/Test-driven_development">http://en.wikipedia.org/wiki/Test-driven_development</a>
</p><p>Code coverage: <a class="ulink" href="http://en.wikipedia.org/wiki/Code_coverage">http://en.wikipedia.org/wiki/Code_coverage</a>
</p></div></div></div></div></div>
<div class="section" title="Getting Jasmine and setting up the test environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec88"/>Getting Jasmine and setting up the test environment</h1></div></div></div><p>Before we start writing our unit test cases we need to set up an environment where our test cases can be executed to verify our implementation. In this recipe, we will show how this environment and necessary libraries can be set up for a visualization project.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec259"/>Getting ready</h2></div></div></div><p>Jasmine<a id="id676" class="indexterm"/> (<a class="ulink" href="http://pivotal.github.io/jasmine/">http://pivotal.github.io/jasmine/</a>) is a <a id="id677" class="indexterm"/>
<span class="strong"><strong>behavior-driven development</strong></span> (<span class="strong"><strong>BDD</strong></span>) framework for testing JavaScript code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>BDD is a software development technique that combines <span class="strong"><strong>Test Driven Development</strong></span> (<span class="strong"><strong>TDD</strong></span>)<a id="id678" class="indexterm"/> with domain driven design.</p></div></div><p>We chose Jasmine<a id="id679" class="indexterm"/> as our testing framework because of its popularity in JavaScript community as well as its nice BDD syntax. You can download the Jasmine library from:</p><p>
<a class="ulink" href="https://github.com/pivotal/jasmine/downloads">https://github.com/pivotal/jasmine/downloads</a>
</p><p>Once downloaded you need to unzip it into the <code class="literal">lib</code> folder. Besides the <code class="literal">lib</code> folder we also need to create the <code class="literal">src</code> and <code class="literal">spec</code> folders for storing source files as well as test cases (in BDD terminology test cases are called specification). See the following screenshot for the folder structure:</p><div class="mediaobject"><img src="graphics/2162OS_13_01.jpg" alt="Getting ready"/><div class="caption"><p>Testing Directory Structure</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec260"/>How to do it...</h2></div></div></div><p>Now, we have<a id="id680" class="indexterm"/> Jasmine in our library, next thing to do is to set up an HTML page that will include Jasmine library as well as our source code plus test cases so they can be executed to verify our program. This file is called <code class="literal">SpecRunner.html</code> in our setup which includes the following code:</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Jasmine Spec Runner&lt;/title&gt;

    &lt;link rel="stylesheet" type="text/css" href="lib/jasmine-1.3.1/jasmine.css"&gt;
    &lt;script type="text/javascript" src="lib/jasmine-1.3.1/jasmine.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="lib/jasmine-1.3.1/jasmine-html.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../../lib/d3.js"&gt;&lt;/script&gt;

    &lt;!-- include source files here... --&gt;
    &lt;script type="text/javascript" src="src/bar_chart.js"&gt;&lt;/script&gt;
    &lt;!-- include spec files here... --&gt;
    &lt;script type="text/javascript" src="spec/spec_helper.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="spec/bar_chart_spec.js"&gt;&lt;/script&gt;

    &lt;script type="text/javascript"&gt;
        (function () {
            var jasmineEnv = jasmine.getEnv();
            jasmineEnv.updateInterval = 1000;

            var htmlReporter = new jasmine.HtmlReporter();

            jasmineEnv.addReporter(htmlReporter);

            jasmineEnv.specFilter = function (spec) {
                return htmlReporter.specFilter(spec);
            };

            var currentWindowOnload = window.onload;

            window.onload = function () {
                if (currentWindowOnload) {
                    currentWindowOnload();
                }
                execJasmine();
            };

            function execJasmine() {
                jasmineEnv.execute();
            }

        })();
    &lt;/script&gt;

&lt;/head&gt;</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec261"/>How it works...</h2></div></div></div><p>This code follows<a id="id681" class="indexterm"/> standard Jasmine spec runner structure and generates execution report directly into our HTML page. Now, you have a fully functional test environment set up for your visualization development. If you open the <code class="literal">SpecRunner.html</code> file with your browser you will see a blank page at this point; however, if you<a id="id682" class="indexterm"/> check out our code sample you will see the following report:</p><div class="mediaobject"><img src="graphics/2162OS_13_02.jpg" alt="How it works..."/><div class="caption"><p>Jasmine Report</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec262"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Jasmine Reference <a id="id683" class="indexterm"/>Document: <a class="ulink" href="http://pivotal.github.io/jasmine/">http://pivotal.github.io/jasmine/</a></li></ul></div></div></div>
<div class="section" title="Test driving your visualization &#x2013; chart creation"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec89"/>Test driving your visualization – chart creation</h1></div></div></div><p>With test environment ready, we<a id="id684" class="indexterm"/> can move on and develop a simple bar chart very similar to what we have done in the <span class="emphasis"><em>Creating a bar chart</em></span> recipe in <a class="link" href="ch08.html" title="Chapter 8. Chart Them Up">Chapter 8</a>, <span class="emphasis"><em>Chart Them Up</em></span>, though this time in a test-driven fashion. You can see how the bar chart looks if you open the <code class="literal">tdd-bar-chart.html</code> page:</p><div class="mediaobject"><img src="graphics/2162OS_13_03.jpg" alt="Test driving your visualization – chart creation"/><div class="caption"><p>Test Driven Bar Chart</p></div></div><p>By now we all know very <a id="id685" class="indexterm"/>well how to implement a bar chart using D3; however, building a bar chart is not the focus of this recipe. Instead, we want to show how we can build test cases every step of the way and verify automatically that our bar chart implementation is doing what it is supposed to do. The source code of this recipe was built using test driven development method; however, we will not show you every step in the TDD process due to limited scope in this book. Instead, we have grouped multiple steps into three larger sections with different focuses in this chapter and this recipe is the first step we take.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec263"/>How to do it...</h2></div></div></div><p>First step we need to take is to make sure our bar chart implementation exists and can receive the data. The starting point of our development could be arbitrary and we decide to drive from this simplest function to set up the skeleton for our object. Here is what the test case looks like:</p><div class="informalexample"><pre class="programlisting">describe('BarChart', function () {
    var div,
        chart,
        data = [
            {x: 0, y: 0},
            {x: 1, y: 3},
            {x: 2, y: 6}
        ];

    beforeEach(function () {
        div = d3.select('body').append('div');
        chart = BarChart(div);
    });

    afterEach(function () {
        div.remove();
    });

    describe('.data', function () {
        it('should allow setting and retrieve chart data', function () {
            expect(chart.data(data).data()).toBe(data);
        });
});
});</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec264"/>How it works...</h2></div></div></div><p>In this first test case we used a few<a id="id686" class="indexterm"/> Jasmine constructs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">describe</code>: This<a id="id687" class="indexterm"/> function defines a suite of test cases; within describe a sub-suite can be nested and test cases can be defined</li><li class="listitem" style="list-style-type: disc"><code class="literal">it</code>: This <a id="id688" class="indexterm"/>function defines a test case</li><li class="listitem" style="list-style-type: disc"><code class="literal">beforeEach</code>: This <a id="id689" class="indexterm"/>function defines a pre-execution hook which will execute the given function before the execution of each test case</li><li class="listitem" style="list-style-type: disc"><code class="literal">afterEach</code>: This <a id="id690" class="indexterm"/>function defines a post-execution hook which will execute the given function after the execution of each test case</li><li class="listitem" style="list-style-type: disc"><code class="literal">expect</code>: This <a id="id691" class="indexterm"/>function defines an expectation in your test case which can then be chained with matchers (for example, <code class="literal">toBe</code> and <code class="literal">toBeEmpty</code>) to perform assertion in your test case</li></ul></div><p>In our example we use the <code class="literal">beforeEach</code> hook to set up a <code class="literal">div</code> container for each test case and then remove <code class="literal">div</code> after execution in <code class="literal">afterEach</code> hook to improve the isolation between different test cases. The test case itself is almost trivial; it checks if the bar chart can take data and also return data attribute correctly. At this point if we run our SpecRunner, it will display a red message complaining there is no <code class="literal">BarChart</code> object, so let's create our object and function:</p><div class="informalexample"><pre class="programlisting">function BarChart(p) {
var that = {};
var _parent = p, data;
that.data = function (d) {
        if (!arguments.length) return _data;
        _data = d;
        return that;
};

return that;
}</pre></div><p>Now, if you run <code class="literal">SpecRunner.html</code> again <a id="id692" class="indexterm"/>it will give you a happy green message showing our only test case is passing.</p></div></div>
<div class="section" title="Test driving your visualization &#x2013; SVG rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec90"/>Test driving your visualization – SVG rendering</h1></div></div></div><p>Now we have the basic skeleton of our bar chart object created, and we feel that we are ready to try to render something, so in this<a id="id693" class="indexterm"/> second iteration we will try to generate the <code class="literal">svg:svg</code> element.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec265"/>How to do it...</h2></div></div></div><p>Rendering the <code class="literal">svg:svg</code> element should not only simply add the <code class="literal">svg:svg</code> element to the HTML body, but also translate the width and height setting on our chart object to proper SVG attributes. Here is how we express our expectation in our test cases:</p><div class="informalexample"><pre class="programlisting">describe('.render', function () {
        describe('svg', function () {
            it('should generate svg', function () {
                chart.render();
                expect(svg()).not.toBeEmpty();
            });

            it('should set default svg height and width', 
              function () {
                chart.render();
                expect(svg().attr('width')).toBe('500');
                expect(svg().attr('height')).toBe('350');
            });

            it('should allow changing svg height and width', 
              function () {
                chart.width(200).height(150).render();
                expect(svg().attr('width')).toBe('200');
                expect(svg().attr('height')).toBe('150');
            });
        });
});

function svg() {
    return div.select('svg');
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec266"/>How it works...</h2></div></div></div><p>At this point, all of these tests will fail since we don't even have the render function; however, it clearly articulates that we expect the render function to generate the <code class="literal">svg:svg</code> element and setting the <code class="literal">width</code> and <code class="literal">height</code> attributes correctly. The second test case also makes sure that if the user does not provide the <code class="literal">height</code> and <code class="literal">width</code> attributes we will supply a set of default values. Here is how <a id="id694" class="indexterm"/>we will implement the render method to satisfy these expectations:</p><div class="informalexample"><pre class="programlisting">...
var _parent = p, _width = 500, _height = 350
        _data;

    that.render = function () {
        var svg = _parent
            .append("svg")
            .attr("height", _height)
            .attr("width", _width);
    };

    that.width = function (w) {
        if (!arguments.length) return _width;
        _width = w;
        return that;
    };

    that.height = function (h) {
        if (!arguments.length) return _height;
        _height = h;
        return that;
};
...</pre></div><p>At this point our <code class="literal">SpecRunner.html</code> is once again all green and happy. However, it's still not doing much since all it does is generate an empty <code class="literal">svg element</code> on the page and not even use the data at all.</p></div></div>
<div class="section" title="Test driving your visualization &#x2013; pixel-perfect bar rendering"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec91"/>Test driving your visualization – pixel-perfect bar rendering</h1></div></div></div><p>In this iteration we will finally generate the bars using the data we have. Through our test cases we will make sure all <a id="id695" class="indexterm"/>bars are not only rendered but rendered with pixel-perfect precision.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec267"/>How to do it...</h2></div></div></div><p>Let's see how we test it:</p><div class="informalexample"><pre class="programlisting">describe('chart body', function () {
        it('should create body g', function () {
            chart.render();
            expect(chartBody()).not.toBeEmpty();
        });

        it('should translate to (left, top)', function () {
            chart.render();
             expect(chartBody().attr('transform')).toBe('translate(30,10)')
        });
    });

    describe('bars', function () {
        beforeEach(function () {
            chart.data(data).width(100).height(100)
                .x(d3.scale.linear().domain([0, 3]))
                .y(d3.scale.linear().domain([0, 6]))
                .render();
        });

        it('should create 3 svg:rect elements', function () {
            expect(bars().size()).toBe(3);
        });

        it('should calculate bar width automatically', 
          function () {
            bars().each(function () {expect(d3.select(this).attr('width')).toBe('18');
            });
        });

       it('should map bar x using x-scale', function () {expect(d3.select(bars()[0][0]).attr('x')).toBe('0');expect(d3.select(bars()[0][1]).attr('x')).toBe('20');expect(d3.select(bars()[0][2]).attr('x')).toBe('40');
       });

       it('should map bar y using y-scale', function () {expect(d3.select(bars()[0][0]).attr('y')).toBe('60');expect(d3.select(bars()[0][1]).attr('y')).toBe('30');expect(d3.select(bars()[0][2]).attr('y')).toBe('0');
       });

       it('should calculate bar height based on y', 
          function () {expect(d3.select(bars()[0][0]).
            attr('height')).toBe('10');expect(d3.select(bars()[0][1]).attr('height')).toBe('40');expect(d3.select(bars()[0][2]).attr('height')).toBe('70');
        });
    });

 	 function chartBody() {
        return svg().select('g.body');
    }

    function bars() {
        return chartBody().selectAll('rect.bar');
}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec268"/>How it works...</h2></div></div></div><p>In the preceding test suite<a id="id696" class="indexterm"/> we describe our expectations of having the chart body <code class="literal">svg:g</code> element correctly transform and correct number of bars with appropriate attributes (<code class="literal">width</code>, <code class="literal">x</code>, <code class="literal">y</code>, <code class="literal">height</code>) set. The implementation is actually going to be shorter than our test case which is quite common in well tested implementation:</p><div class="informalexample"><pre class="programlisting">...
var _parent = p, _width = 500, _height = 350,
        _margins = {top: 10, left: 30, right: 10, bottom: 30},
        _data,
        _x = d3.scale.linear(),
        _y = d3.scale.linear();

that.render = function () {
        var svg = _parent
            .append("svg")
            .attr("height", _height)
            .attr("width", _width);

        var body = svg.append("g")
            .attr("class", 'body')
            .attr("transform", "translate(" + _margins.left + "," + _margins.top + ")")

        if (_data) {
            _x.range([0, quadrantWidth()]);
            _y.range([quadrantHeight(), 0]);

            body.selectAll('rect.bar')
                .data(_data).enter()
                .append('rect')
                .attr("class", 'bar')
                .attr("width", function () {
                    return quadrantWidth() / _data.length - BAR_PADDING;
                })
                .attr("x", function (d) {return _x(d.x); })
                .attr("y", function (d) {return _y(d.y); })
                .attr("height", function (d) {
                    return _height - _margins.bottom - _y(d.y);
                });
        }
};
...</pre></div><p>I think you are<a id="id697" class="indexterm"/> getting the picture and now you can repeat this cycle over and over to drive your implementation. D3 visualization is built on HTML and SVG and both are simple mark-up languages that can be verified easily. Well thought-out test suite can make sure your visualization is pixel-perfect even sub-pixel perfect.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec269"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Test driven development: <a class="ulink" href="http://en.wikipedia.org/wiki/Test-driven_development">http://en.wikipedia.org/wiki/Test-driven_development</a></li></ul></div></div></div></body></html>