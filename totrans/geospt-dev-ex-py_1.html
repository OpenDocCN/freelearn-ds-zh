<html><head></head><body>
<p class="calibre1">gpx_dict = xmltodict.parse(gpx_file.read())</p>
<p class="calibre1">print("Waypoint:")</p>
<p class="calibre1">print(gpx_dict['gpx']['wpt'][0].keys())</p>
<p class="calibre1">print("Geocache:")</p>
<p class="calibre1">print(gpx_dict['gpx']['wpt'][0]['geocache'].keys())</p>
<p class="calibre1">3.  Now, edit the if __name__ == '__main__': block to test the code: if __name__ == "__main__":</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">read_gpx_file("../../data/geocaching.gpx")</p>
<p class="calibre1">4.  Run the code again with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and look at the results: Waypoint:</p>
<p class="calibre1">[u'@lat', u'@lon', u'time', u'name', u'desc', u'src', u'url', u'urlname', u'sym', u'type', u'geocache']</p>
<p class="calibre1">Geocache:</p>
<p class="calibre1">[u'@status', u'@xmlns', u'name', u'owner', u'locale', u'state', u'country', u'type', u'container', u'difficulty', u'terrain', u'summary', u'description', u'hints', u'licence', u'logs', u'geokrety']</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">With the print(gpx_dict['gpx']['wpt'][0].keys())statement, we obtained the value of gpx and then that of wpt, which is a list. Then, we got the keys of the first element on this list and printed it. </p>
<p class="calibre1">Next, through print(gpx_dict['gpx']['wpt'][0]['geocache'].keys()), we got the value of geocache and also printed its keys. </p>
<p class="calibre1">Look at the output and note that it’s the same thing that we did when we were exploring the GPX file structure in PyCharm. The structure is now available as a dictionary, including the tag’s properties, which are represented in the dictionary with an @ symbol. </p>
<p class="calibre1">Now that we have a nice and easy way to handle the dictionary of the GPX file, let’s extract and flatten the relevant information and make the function return it. Edit the read_gpx_file function, as follows:</p>
<p class="calibre1">def read_gpx_file(file_path):</p>
<p class="calibre1">"""Reads a GPX file containing geocaching points. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">with open(file_path) as gpx_file:</p>
<p class="calibre1">gpx_dict = xmltodict.parse(gpx_file.read())</p>
<p class="calibre1">output = []</p>
<p class="calibre1"><a id="p162"/>    for wpt in gpx_dict['gpx']['wpt']:</p>
<p class="calibre1">geometry = [wpt.pop('@lat'), wpt.pop('@lon')]</p>
<p class="calibre1"># If geocache is not on the dict, skip this wpt. </p>
<p class="calibre1">try:</p>
<p class="calibre1">geocache = wpt.pop('geocache')</p>
<p class="calibre1">except KeyError:</p>
<p class="calibre1">continue</p>
<p class="calibre1">attributes = {'status': geocache.pop('@status')}</p>
<p class="calibre1"># Merge the dictionaries. </p>
<p class="calibre1">attributes.update(wpt)</p>
<p class="calibre1">attributes.update(geocache)</p>
<p class="calibre1"># Construct a GeoJSON feature and append to the list. </p>
<p class="calibre1">feature = {</p>
<p class="calibre1">"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Point", </p>
<p class="calibre1">"coordinates": geometry}, </p>
<p class="calibre1">"properties": attributes}</p>
<p class="calibre1">output.append(feature)    </p>
<p class="calibre1">return output</p>
<p class="calibre1">Note that here, we used the dictionary’s pop method; this method returns the value of a given key and removes the key from the dictionary. The objective is to have two dictionaries only with attributes (properties) that can be merged into a single dictionary of attributes; the merging is done with the update method. </p>
<p class="calibre1">Some waypoints doesn’t have the geocache key, when this happens, we catch the exception and skip this point. </p>
<p class="calibre1">Finally, the information is combined in a dictionary with a GeoJSON-like structure. You can do this as follows:</p>
<p class="calibre1">1.  Edit the if __name__ == '__main__': block using the following code: if __name__ == "__main__":</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">points = read_gpx_file("../../data/geocaching.gpx") print points[0]['properties'].keys()</p>
<p class="calibre1">2.  Run the code, and you will see the following output:</p>
<p class="calibre1">['status', u'logs', u'locale', u'terrain', u'sym', u'geokrety', u'difficulty', u'licence', u'owner', u'urlname', u'desc', u'@xmlns', u'src', u'container', u'name', u'url', u'country', u'description', u'summary', u'state', u'time', u'hints', u'type']</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">That’s great! Now, all the geocache attributes are contained inside the  <i class="calibre4">properties</i> of the feature. </p>
<p class="calibre1"><a id="p163"/><b class="calibre3">Returning the homogeneous data</b></p>
<p class="calibre1">We have a read_gpx_file function that returns a list of features in a dictionary and an open_vector_file function that returns an OGR datasource. We also have a get_datasource_information function that returns the information that we need about the file. </p>
<p class="calibre1">Now, it’s time to combine these functions in order to be able to read multiple types of data (GPX, Shapefiles, and many more). To do this, we will change the open_vector_file function so that it can make decisions depending on the file format and convert the data in order to always return the same structure. Perform the following steps: 1.  First, make sure that the functions inside geo_function.py are in the correct order; if not, rearrange them to be in this order:</p>
<p class="calibre1">def read_gpx_file(file_path):</p>
<p class="calibre1">def get_datasource_information(datasource, print_results=False): def open_vector_file(file_path):</p>
<p class="calibre1">def create_transform(src_epsg, dst_epsg):</p>
<p class="calibre1">def transform_geometries(datasource, src_epsg, dst_epsg):</p>
<p class="calibre1">def transform_points(points, src_epsg=4326, dst_epsg=3395): 2.  Now, add a new function to transform OGR features into dictionaries as we did with the GPX file. This function can be inserted anywhere before open_vector_file, as follows:</p>
<p class="calibre1">def read_ogr_features(layer):</p>
<p class="calibre1">"""Convert OGR features from a layer into dictionaries. </p>
<p class="calibre1">:param layer: OGR layer. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features = []</p>
<p class="calibre1">layer_defn = layer.GetLayerDefn()</p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">type = ogr.GeometryTypeToName(layer.GetGeomType())</p>
<p class="calibre1">for item in layer:</p>
<p class="calibre1">attributes = {}</p>
<p class="calibre1">for index in range(layer_defn.GetFieldCount()):</p>
<p class="calibre1">field_defn = layer_defn.GetFieldDefn(index)</p>
<p class="calibre1">key = field_defn.GetName()</p>
<p class="calibre1">value = item.GetFieldAsString(index)</p>
<p class="calibre1">attributes[key] = value</p>
<p class="calibre1">feature = {</p>
<p class="calibre1">"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": type, </p>
<p class="calibre1">"coordinates": item.GetGeometryRef().ExportToWkt()}, </p>
<p class="calibre1">"properties": attributes}</p>
<p class="calibre1">features.append(feature)</p>
<p class="calibre1"><a id="p164"/>    return features</p>
<p class="calibre1">3.  Now, edit the open_vector_file function via the following code: def open_vector_file(file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR or a GPX file. </p>
<p class="calibre1">Returns a list of features and informations about the file. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1"># Check if the file was opened. </p>
<p class="calibre1">if not datasource:</p>
<p class="calibre1">if not os.path.isfile(file_path):</p>
<p class="calibre1">message = "Wrong path." </p>
<p class="calibre1">else:</p>
<p class="calibre1">message = "File format is invalid." </p>
<p class="calibre1">raise IOError('Error opening the file {}\n{}'.format(</p>
<p class="calibre1">file_path, message))</p>
<p class="calibre1">metadata = get_datasource_information(datasource)</p>
<p class="calibre1">file_name, file_extension = os.path.splitext(file_path)</p>
<p class="calibre1"># Check if it's a GPX and read it if so. </p>
<p class="calibre1">if file_extension in ['.gpx', '.GPX']:</p>
<p class="calibre1">features = read_gpx_file(file_path)</p>
<p class="calibre1"># If not, use OGR to get the features. </p>
<p class="calibre1">else:</p>
<p class="calibre1">features = read_ogr_features(</p>
<p class="calibre1">datasource.GetLayerByIndex(0))</p>
<p class="calibre1">return features, metadata</p>
<p class="calibre1">4.  Just to make sure that everything is fine, let’s test the code by opening two different file types. Edit the if __name__ == '__main__': block, as follows: if __name__ == "__main__":</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">points, metadata = open_vector_file(</p>
<p class="calibre1">"../../data/geocaching.shp")</p>
<p class="calibre1">print points[0]['properties'].keys()</p>
<p class="calibre1">points, metadata = open_vector_file(</p>
<p class="calibre1">"../../data/geocaching.gpx")</p>
<p class="calibre1">print points[0]['properties'].keys()</p>
<p class="calibre1">5.  Run the code and take a look at the following output:</p>
<p class="calibre1">['src', 'dgpsid', 'vdop', 'sat', 'name', 'hdop', 'url', 'fix', 'pdop', </p>
<p class="calibre1">'sym', 'ele', 'ageofdgpsd', 'time', 'urlname', 'magvar', 'cmt', 'type', </p>
<p class="calibre1">'geoidheigh', 'desc']</p>
<p class="calibre1">['status', u'logs', u'locale', u'terrain', u'sym', u'geokrety', u'difficulty', u'licence', u'owner', u'urlname', u'desc', u'@xmlns', u'src', u'container', u'name', u'url', u'country', u'description', u'summary', u'state', u'time', u'hints', u'type']</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p165"/><b class="calibre3">Converting the data into Geocache objects</b> So far, we have defined the Geocache class; it has the latitude and longitude properties and a method to return this pair of coordinates. PointCollection is a collection of geocaches. </p>
<p class="calibre1">We also have the open_vector_file function that returns a list of dictionaries representing features. </p>
<p class="calibre1">Now, we will reach a higher level of abstraction by implementing the process of importing data into the PointCollection class by making use of the open_vector_file function. </p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  Open your models.py file and edit the imports at the beginning of the file by executing the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">Import gdal</p>
<p class="calibre1">import os</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">2.  Now, let’s make PointCollection automatically import a file when it’s instantiated. </p>
<p class="calibre1">Go to the models.py file, change your class __init__ method, and add the import_data and _parse_data methods. Run this script:</p>
<p class="calibre1">class PointCollection(object):</p>
<p class="calibre1">def __init__(self, file_path=None):</p>
<p class="calibre1">"""This class represents a group of vector data.""" </p>
<p class="calibre1">self.data = []</p>
<p class="calibre1">self.epsg = None</p>
<p class="calibre1">if file_path:</p>
<p class="calibre1">self.import_data(file_path)</p>
<p class="calibre1">def import_data(self, file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features, metadata = open_vector_file(file_path)</p>
<p class="calibre1">self._parse_data(features)</p>
<p class="calibre1">self.epsg = metadata['epsg']</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">"""Transforms the data into Geocache objects. </p>
<p class="calibre1">:param features: A list of features. </p>
<p class="calibre1">""" </p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">cache_point = Geocache(geom[0], geom[1], </p>
<p class="calibre1"><a id="p166"/>                                   attributes = attributes) self.data.append(cache_point)</p>
<p class="calibre1">3.  Now, we will just need to adapt the Geocache class to receive and store the attributes. </p>
<p class="calibre1">Replace it with the following code:</p>
<p class="calibre1">class Geocache(object):</p>
<p class="calibre1">"""This class represents a single geocaching point.""" </p>
<p class="calibre1">def __init__(self, lat, lon, attributes=None):</p>
<p class="calibre1">self.lat = lat</p>
<p class="calibre1">self.lon = lon</p>
<p class="calibre1">self.attributes = attributes      </p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">return self.lat, self.lon</p>
<p class="calibre1">The attribute arguments are called <b class="calibre3">keyword arguments</b>. Keyword arguments are optional, and the default value is the value defined after the equal symbol. </p>
<p class="calibre1">As at this moment there is no standardization in data format for geocaching, we will store all the attributes that are read from the source file unchanged. </p>
<p class="calibre1">In Python, you are not obliged to define which properties a class instance will have in advance; the properties can be added during the code’s execution. However, it’s good practice to define them in the __init __ method because it avoids mistakes, such as trying to access undefined properties. PyCharm can track these properties and warn you about typos. It also serves as documentation. </p>
<p class="calibre1">1.  Before we test the code, edit the PointCollection class and add a method that shows some information for us, as follows:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def describe(self):</p>
<p class="calibre1">print("SRS EPSG code: {}".format(self.epsg))</p>
<p class="calibre1">print("Number of features: {}".format(len(self.data))) 2.  In order to test your code, edit the if __name__ == '__main__' block via the following lines of code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1"><b class="calibre3">    vector_data = PointCollection("../data/geocaching.gpx")</b> vector_data.print_information()</p>
<p class="calibre1">3.  Now, run the code. You should see the following output: File imported: ../data/geocaching.gpx</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 112</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p167"/><b class="calibre3">Merging multiple sources of data</b></p>
<p class="calibre1">Now that our data is in the form of PointCollection containing Geocache objects, merging data from multiple files or multiple PointCollection data should be easy. </p>
<p class="calibre1">Perform the following steps:</p>
<p class="calibre1">1.  Make another test. First, we will see whether we can import multiple files and edit the if __name__ == '__main__' block of the models.py file. Execute the following code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">vector_data = PointCollection("../data/geocaching.gpx") vector_data.describe()</p>
<p class="calibre1">vector_data.import_data("../data/geocaching.shp") vector_data.describe()</p>
<p class="calibre1">2.  Run the code again. Now, you should see the number of features double after you import another file, as follows:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 112</p>
<p class="calibre1">File imported: ../data/geocaching.shp</p>
<p class="calibre1">SRS EPSG code: None</p>
<p class="calibre1">Number of features: 242</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">3.  Let’s implement something very elegant. We will add a magic method to our PointCollection class so that we can merge the content of two instances. </p>
<p class="calibre1">4.  Edit the PointCollection class and add the __add__ method just after the __init__</p>
<p class="calibre1">method via the following code:</p>
<p class="calibre1">class PointCollection(object):</p>
<p class="calibre1">def __init__(self, file_path=None):</p>
<p class="calibre1">"""This class represents a group of vector data.""" </p>
<p class="calibre1">self.data = []</p>
<p class="calibre1">self.epsg = None</p>
<p class="calibre1">if file_path:</p>
<p class="calibre1">self.import_data(file_path)</p>
<p class="calibre1"/>
<p class="calibre1">def __add__(self, other):</p>
<p class="calibre1">self.data += other.data</p>
<p class="calibre1">return self</p>
<p class="calibre1">Similar to the __init__ method, the __add__ method is one of Python’s  <i class="calibre4">magic methods</i>. </p>
<p class="calibre1">These methods are not called directly; they are automatically called when something specific happens. The __init__ method is called when the class is instantiated, and the __add__ method is called when the plus (+) operator is used. So, to merge the data of two PointCollection instances, we just need to sum them. Here’s what we need to do for this:</p>
<p class="calibre1"><a id="p168"/>1.  Edit the if __name__ == '__main__': block, as follows: if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1"/>
<p class="calibre1">my_data = PointCollection("../data/geocaching.gpx") my_other_data = PointCollection("../data/geocaching.shp") merged_data = my_data + my_other_data    </p>
<p class="calibre1">merged_data.describe()</p>
<p class="calibre1">2.  Then, run the code and take a look at the results:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">File imported: ../data/geocaching.shp</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 242</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p169"/>
<a id="p170"/><b class="calibre3">Integrating new functionality into the</b></p>
<p class="calibre1"><b class="calibre3">application</b></p>
<p class="calibre1">In<a href="index_split_000.html#p103"> Chapter 2, </a>  <i class="calibre4">The Geocaching App</i>, we developed the application so that it could find points close to your location. However, the data was organized differently inside the application; although it was a very efficient way of handling data, it became very hard for us to understand how to perform operations on this data. </p>
<p class="calibre1">Through abstraction, we implemented a new form of data representation—one that is very intuitive and easy to use. </p>
<p class="calibre1">Now, we will change the application so that it can use this new type of data to perform its functions and also to aggregate the new capability of combining multiple sources of data. </p>
<p class="calibre1">Take a look at the GeocachingApp and PointCollection classes; you may notice that they have some parts that look similar to each other. Both of them store data and have methods to open data. </p>
<p class="calibre1">At this point, with little modification, if we transfer methods from one class to another, we could end up with a functional application, and that’s what we will do. However, instead of copying and pasting, we will use Python’s class inheritance. We will take the GeocachingApp class and make it inherit all the functionality of the PointCollection class. </p>
<p class="calibre1">For a complete understanding, we will go through the processes one method at a time. </p>
<p class="calibre1">Open your geocaching_app.py file, and now, let’s focus on the class declarations and __init__ method. Make the following changes on the imports section, and in the class, you can keep the other methods as they are; don’t delete them:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">import math</p>
<p class="calibre1">from utils.geo_functions import transform_geometries</p>
<p class="calibre1">from utils.geo_functions import transform_points</p>
<p class="calibre1">from models import Geocache, PointCollection</p>
<p class="calibre1">class GeocachingApp(PointCollection):</p>
<p class="calibre1">def __init__(self, data_file=None, my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">:param my_location: Coordinates of your location. </p>
<p class="calibre1">""" </p>
<p class="calibre1">super(GeocachingApp, self).__init__(file_path=data_file)</p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1"><a id="p171"/>        self._transformed_geoms = None</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">self.distances = None</p>
<p class="calibre1"/>
<p class="calibre1">#Delete the code containing "if data_file…" </p>
<p class="calibre1"/>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">In the class declaration (class GeocachingApp(PointCollection)), we added GeocachingClass, which tells Python that the GeocachingApp class should inherit methods and properties from PointCollection. However, as both classes have an __init__ method, unless we do something, the Geocaching app’s __init__ method will completely overwrite the PointCollection method. </p>
<p class="calibre1">We want both of the __init__ methods called, so we will use the super() function. This tells Python to call the __init__ method of the inherited class. Also, as the PointCollection class handles the files importing now, we will pass the data_file argument to it. Perform the following steps:</p>
<p class="calibre1">1.  Let’s test it and check whether the inheritance works. Go to the if __name__ ==</p>
<p class="calibre1">'__main__': block at the end of the file and edit it as follows: if __name__ == "__main__":    </p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')    </p>
<p class="calibre1"># Create the application:</p>
<p class="calibre1">my_app = GeocachingApp()</p>
<p class="calibre1"># Now we will call a method from the PointCollection class: my_app.import_data("../data/geocaching.gpx")</p>
<p class="calibre1">2.  In fact, as you type the code, you may notice that PyCharm’s auto-completion feature now includes methods and properties from the inherited class. </p>
<p class="calibre1">3.  Run the code, and you should see this output:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Congratulations! You have just used class inheritance with success. This is a very powerful and handy feature of Python. </p>
<p class="calibre1"><a id="p172"/>
<a id="p173"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, the challenge was to find a way to combine data from multiple sources. </p>
<p class="calibre1">The solution for this is to make code that can take different types of data and transform it into a common type of object. </p>
<p class="calibre1">In order to achieve this, we first created two new Python classes. The first was the Geocache class, which represents a single geocache location and contains its coordinates, a name, and a description. The second was the PointCollection class, which represents a collection of Geocache objects. This class has the ability to import and convert the information from as many files as needed. </p>
<p class="calibre1">This technique that we used is called <b class="calibre3">abstraction</b>; its foundations reside in hiding complex procedures behind objects that can be easily understood by humans. </p>
<p class="calibre1">Finally, we integrated this new layer of abstraction into the application using class inheritance. The GeocachingApp class inherited the PointCollection, and in the end, it could behave similarly to any and both of them at the same time. </p>
<p class="calibre1">In the next chapter, while we will improve the application’s capability to search for points, you will also learn other ways of combining classes. </p>
<p class="calibre1"><a id="p174"/>
<a id="p175"/><b class="calibre3">Chapter 4. Improving the App Search</b></p>
<p class="calibre1"><b class="calibre3">Capabilities</b></p>
<p class="calibre1">So far, our app is capable of simply searching points that are close to a defined location. In this chapter, we are going to make a huge steep and make our app filter the data by geographic boundaries and by any field in the data. </p>
<p class="calibre1">By the end of this chapter, you will be able to search geocaching points that are inside a given city, state, country, or any boundary defined by you. In addition, you will be able to search points by any of its properties such as difficult levels, name, user, and so on. It will also be possible to combine multiple filters. </p>
<p class="calibre1">In the process, we will see how to work with polygons and how the relations between geometries can be analyzed in a geoprocessing application. </p>
<p class="calibre1">To achieve these goals, we will go through the following topics: How to describe polygons using well-known text</p>
<p class="calibre1">Using the Shapely package to handle geometries</p>
<p class="calibre1">Importing polygon data</p>
<p class="calibre1">Importing line data</p>
<p class="calibre1">The use of base classes and inheritance</p>
<p class="calibre1">The types of geometry relationships</p>
<p class="calibre1">Filtering by multiple properties and method chaining</p>
<p class="calibre1"><a id="p176"/><img src="index-176_1.jpg" alt="Image 19" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Working with polygons</b></p>
<p class="calibre1">Supposing we want to filter our data by a given region, it’s possible to assume that this region is represented by a polygon. </p>
<p class="calibre1">For example, the following image represents the world counties’ borders, it was rendered from a Shapefile where each feature is a country and it’s geometry is a polygon. </p>
<p class="calibre1">Differently from the geocaching point, whose geometries are only a pair of coordinates, a polygon is a sequence of at least three-point coordinates beginning and ending at the same point. </p>
<p class="calibre1">By now, you can assume that we won’t be able to store the polygon’s coordinates with the same structure that we had with the geocaching point. We will need to store the whole OGR geometry or store something that can be transformed from or to it. </p>
<p class="calibre1">How these polygons are represented is an important subject, because mastering it allows you to manipulate them any way you need to do any kind of work. It also allows you to build polygons from point coordinates (from a GPS for example) or form shapes such as a rectangle. </p>
<p class="calibre1"><a id="p177"/><img src="index-177_1.jpg" alt="Image 20" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Knowing well-known text</b></p>
<p class="calibre1"><b class="calibre3">Well-known text</b> (<b class="calibre3">WKT</b>) is a human readable markup language to represent geometries in a spatial application. It was originally defined by the <b class="calibre3">Open Geospatial Consortium</b> (<b class="calibre3">OGC</b>) and is accepted by many software as a form of data exchange. The WKT has a binary equivalent called <b class="calibre3">well-known binary</b> (<b class="calibre3">WKB</b>). It is used for data storage and transfer where human readability is not required. </p>
<p class="calibre1">Let’s go through some examples to see how WKT works. First, we will create an OGR</p>
<p class="calibre1">geometry of the polygon shown in the following image:</p>
<p class="calibre1">1.  Make a copy of your Chapter3 folder inside the geopy project and rename it to Chapter4. </p>
<p class="calibre1">2.  Locate the Chapter4\experiments directory and delete the files inside it. If you don’t have this directory, create it. </p>
<p class="calibre1">3.  Inside the Chapter4\experiments folder, create a new Python file. To do this in PyCharm, right-click on the folder and choose <b class="calibre3">New</b> | <b class="calibre3">Python File</b>. Name this file wkt_experiments.py. </p>
<p class="calibre1">4.  Type the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))" </p>
<p class="calibre1">geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)</p>
<p class="calibre1">print(geometry.__class__)</p>
<p class="calibre1">print(geometry.Area())</p>
<p class="calibre1">print(8*7)</p>
<p class="calibre1">5.  Now run it ( <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and choose wkt_experiments). You should see the following output:</p>
<p class="calibre1">&lt;class 'osgeo.ogr.Geometry'&gt; </p>
<p class="calibre1">56.0</p>
<p class="calibre1">56</p>
<p class="calibre1"><a id="p178"/><img src="index-178_1.jpg" alt="Image 21" class="calibre2"/></p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">What we did here was to define the WKT representation of a polygon in a Python string. Note that it started from coordinate 1.1 and listed all the coordinates clockwise ending at 1.1 again (the direction is not important; it could also be counter clockwise). </p>
<p class="calibre1">In the next line, we called OGR’s CreateGeometryFromWkt function that passed the string as a parameter. Internally, it converted the string into a OGR geometry object. </p>
<p class="calibre1">To make sure that everything went fine in the next three lines, we printed the class name of the object, the area calculated by OGR, and the manually calculated area. </p>
<p class="calibre1">Now, a more complicated polygon, one with a hole in the middle or an  <i class="calibre4">island</i>. </p>
<p class="calibre1">6.  Edit your code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import ogr</p>
<p class="calibre1">wkt_rectangle = "POLYGON ((1 1, 1 9, 8 9, 8 1, 1 1))" </p>
<p class="calibre1">geometry = ogr.CreateGeometryFromWkt(wkt_rectangle)</p>
<p class="calibre1">print(geometry.__class__)</p>
<p class="calibre1">print(geometry.Area())</p>
<p class="calibre1">print(8*7)</p>
<p class="calibre1">wkt_rectangle2 = "POLYGON ((1 1, 8 1, 8 9, 1 9, 1 1)," \</p>
<p class="calibre1">"(4 2, 4 5, 7 5, 7 2, 4 2))" </p>
<p class="calibre1">geometry2 = ogr.CreateGeometryFromWkt(wkt_rectangle2)</p>
<p class="calibre1">print(geometry.__class__)</p>
<p class="calibre1">print(geometry2.Area())</p>
<p class="calibre1">print((8*7) - (3*3))</p>
<p class="calibre1">7.  Now run it again ( <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>). You should see the following output:</p>
<p class="calibre1">&lt;class 'osgeo.ogr.Geometry'&gt; </p>
<p class="calibre1">56.0</p>
<p class="calibre1">56</p>
<p class="calibre1">&lt;class 'osgeo.ogr.Geometry'&gt; </p>
<p class="calibre1"><a id="p179"/>47.0</p>
<p class="calibre1">47</p>
<p class="calibre1">Every polygon ring comes inside the parenthesis separated by commas. The exterior ring should be described first, then all the interior rings. </p>
<p class="calibre1">Managing geometries with WKT gets complicated as the complexity and the number of coordinates increase. To solve this and other problems, we will use another package that will make things a lot easier for us. </p>
<p class="calibre1"><a id="p180"/>
<a id="p181"/><b class="calibre3">Using Shapely to handle geometries</b></p>
<p class="calibre1">Shapely is a Python package for the analysis of planar features. It uses functions from the GEOS library and a port of the <b class="calibre3">Java Topology Suite</b> (<b class="calibre3">JTS</b>). </p>
<p class="calibre1">It has mainly the same classes and functions as OGR while dealing with geometries. </p>
<p class="calibre1">Although it’s not a replacement for OGR, it has a more  <i class="calibre4">pythonic</i> and a very intuitive interface, it is better optimized, and it has a well-developed documentation. </p>
<p class="calibre1">To make things clear, Shapely is intended to analyze geometries and only geometries. It does not handle features’ attributes, neither is it capable of reading and writing geospatial files. </p>
<p class="calibre1">For a direct comparison of Shapely and OGR, we are going to rewrite the previous examples:</p>
<p class="calibre1">1.  Add the following lines to the wkt_experiments.py file (you can keep or remove the previous code, it’s up to you):</p>
<p class="calibre1">from shapely.geometry import Polygon</p>
<p class="calibre1">print('Examples with Shapely')</p>
<p class="calibre1">polygon1 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)]) print(polygon1.__class__)</p>
<p class="calibre1">print(polygon1.area)</p>
<p class="calibre1">polygon2 = Polygon([(1, 1), (1, 9), (8, 9), (8, 1), (1, 1)], [[(4, 2), (4, 5),(7, 5), (7, 2), (4, 2)]])</p>
<p class="calibre1">print(polygon2.__class__)</p>
<p class="calibre1">print(polygon2.area)</p>
<p class="calibre1">2.  Now run the code again and look at the output:</p>
<p class="calibre1">Examples with Shapely</p>
<p class="calibre1">&lt;class 'shapely.geometry.polygon.Polygon'&gt; </p>
<p class="calibre1">56.0</p>
<p class="calibre1">&lt;class 'shapely.geometry.polygon.Polygon'&gt; </p>
<p class="calibre1">47.0</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Everything worked as expected, but you may notice a few differences. First, in order to create the polygon, we passed a list of tuples (it could be a list of lists) where each tuple is a point coordinate. This small change makes a big difference; lists are much easier to manipulate than strings. </p>
<p class="calibre1">Secondly, when we print the name of the class of the object created by Shapely, we see that it’s a Polygon class and not a Geometry as it was with OGR. This represents a higher level of abstraction as explained in <a href="index_split_000.html#p142">Chapter 3</a>,  <i class="calibre4">Combining Multiple Data Sources</i>. With it comes all the goodies of abstraction and less worries about the internal functionality. </p>
<p class="calibre1">As you typed the code, specifically print(polygon1.area), PyCharm showed you a list</p>
<p class="calibre1"><a id="p182"/>of methods for the Polygon class. This is another feature of Shapely, it is a well-written and IDE-friendly Python package. The consequence is that it allows you to take autocompletion, code inspections, refactoring, and a lot of the other features that come with modern IDEs. </p>
<p class="calibre1"><a id="p183"/>
<a id="p184"/><b class="calibre3">Importing polygons</b></p>
<p class="calibre1">Now that we have the basics on how to work with polygons and we know how to represent and store them, we will go back to our app and add the ability to import geospatial files containing polygons. As we did with the points, we will abstract the features into the Python objects and we will also use class inheritance. </p>
<p class="calibre1">First, let’s look at the code we already wrote. In the models.py file, we have the PointCollection class:</p>
<p class="calibre1">class PointCollection(object):</p>
<p class="calibre1">def __init__(self, file_path=None):</p>
<p class="calibre1">"""This class represents a group of vector data.""" </p>
<p class="calibre1">self.data = []</p>
<p class="calibre1">self.epsg = None</p>
<p class="calibre1">if file_path:</p>
<p class="calibre1">self.import_data(file_path)</p>
<p class="calibre1">def __add__(self, other):</p>
<p class="calibre1">self.data += other.data</p>
<p class="calibre1">return self</p>
<p class="calibre1">def import_data(self, file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features, metadata = open_vector_file(file_path)</p>
<p class="calibre1">self._parse_data(features)</p>
<p class="calibre1">self.epsg = metadata['epsg']</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">"""Transforms the data into Geocache objects. </p>
<p class="calibre1">:param features: A list of features. </p>
<p class="calibre1">""" </p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">cache_point = Geocache(geom[0], geom[1], </p>
<p class="calibre1">attributes = attributes)</p>
<p class="calibre1">self.data.append(cache_point)</p>
<p class="calibre1">def describe(self):</p>
<p class="calibre1">print("SRS EPSG code: {}".format(self.epsg))</p>
<p class="calibre1">print("Number of features: {}".format(len(self.data))) This class represents a collection of geocaching points and is responsible for importing these points and converting and storing them. These are exactly the same functionality that we want to implement to import polygons. </p>
<p class="calibre1"><a id="p185"/>In the previous chapter, you saw how it’s possible, through inheritance, to make a class inherit functionalities from other classes. We will use this same technique to use what we already have to import the polygons. </p>
<p class="calibre1">Since the processing of geocaching points and polygons may have its particularities, it will need some of the things to be specific for each one. A specific example is the _parse_data method that, for now, converts features into geocaching points. </p>
<p class="calibre1">So, it’s not a good idea to make the class that represents polygons to inherit directly from the PointCollection class. Instead, the idea is to have two base classes, one that represents a single object and other that represents a collection of that object. These base classes will contain methods that are common to the points and the polygons, then the child classes will contain methods specific for each case. </p>
<p class="calibre1">The polygons that we will import could be countries, boundaries, states, or provinces of a country, city, district regions, and so on. Since it’s not clear yet, let’s call it  <i class="calibre4">boundaries</i>. </p>
<p class="calibre1">This is explained in the following steps:</p>
<p class="calibre1">1.  We will start creating the BaseGeoObject object and adapting from the Geocache class. Open the models.py file in the Chapter4 folder. </p>
<p class="calibre1">2.  Make a copy of the Geocache class with all its methods (copy and paste). </p>
<p class="calibre1">3.  Rename the first copy to BaseGeoObject and change docstring to something like</p>
<p class="calibre1">"Base class for single geo objects.". You should have this: class BaseGeoObject(object):</p>
<p class="calibre1">"""Base class for a single geo object.""" </p>
<p class="calibre1">def __init__(self, lat, lon, attributes=None):</p>
<p class="calibre1">self.lat = lat</p>
<p class="calibre1">self.lon = lon</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">return self.lat, self.lon</p>
<p class="calibre1">class Geocache(object):</p>
<p class="calibre1">"""This class represents a single geocaching point.""" </p>
<p class="calibre1">def __init__(self, lat, lon, attributes=None):</p>
<p class="calibre1">self.lat = lat</p>
<p class="calibre1">self.lon = lon</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">return self.lat, self.lon</p>
<p class="calibre1">Now try to think, looking at both of the classes, what is specific for the Geocache, what doesn’t belong to a generic GeoObject or what belongs to it, and what properties and methods every type of geospatial object could have. </p>
<p class="calibre1">This separation could lead to some debate, and sometimes, depending on the complexity of the project and the nature of what you are dealing with, it may be hard to reach a final</p>
<p class="calibre1"><a id="p186"/>state in the first iteration through the code. In your projects, you may need to come back and change how the classes are organized more than once. </p>
<p class="calibre1">For now, I’m going to propose the following logic:</p>
<p class="calibre1"><b class="calibre3">Lat, lon</b>: These properties are for the Geocache only. As we saw, we may have other types of geometries and we want to generalize how the geometries are stored. </p>
<p class="calibre1"><b class="calibre3">Attributes</b>: All the objects should have this property. </p>
<p class="calibre1"><b class="calibre3">A __repr__ method</b>: This is another  <i class="calibre4">magic method</i> like __init__ and __add__ that we had in the previous chapter. __repr__ is called when you use the print() function on an object. We will add it and set it to not be implemented on the base class, because every type of object should have its own representation. </p>
<p class="calibre1"><b class="calibre3">Coordinates property</b>: All geo objects should have coordinates, but how it is implemented here is specific to the Geocache. We will change that to a generic form: a geom property that will contain the object geometry. </p>
<p class="calibre1">Let’s make the first changes to these classes. Edit your code to be as follows: class BaseGeoObject(object):</p>
<p class="calibre1">"""Base class for a single geo object.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">self.geom = geometry</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">class Geocache(BaseGeoObject):</p>
<p class="calibre1">"""This class represents a single geocaching point.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">super(Geocache, self).__init__(geometry, attributes)</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">name = self.attributes.get('name', 'Unnamed')</p>
<p class="calibre1">return "{} {}  -  {}".format(self.geom.x, </p>
<p class="calibre1">self.geom.y, name)</p>
<p class="calibre1">A geom property was added to the class as a required argument while instantiating it. In this property, we will store the Shapely object. The lat and lon properties were removed; they can be accessed directly from the Shapely object (geom) and we will adapt PointCollection to do this. </p>
<p class="calibre1">The __repr__ method of the Geocache class returns a string containing the coordinates of the point and the name attribute when it’s available or Unnamed. </p>
<p class="calibre1">Now add the Boundary class:</p>
<p class="calibre1">class Boundary(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single political Boundary.""" </p>
<p class="calibre1"><a id="p187"/>    def __repr__(self):</p>
<p class="calibre1">return self.name </p>
<p class="calibre1">For now, the Boundary class is almost the same as the BaseGeoObject class, so we only change the __repr__ method, so it returns only the name of the boundary. </p>
<p class="calibre1">The next step is to edit the collection classes. Our PointCollection class is almost compatible with the new organization. We only need to make a few changes to the _parse_data method, transform this class into a base class, and create the classes that will inherit from it:</p>
<p class="calibre1">1.  First, like we did earlier, make a copy of the PointCollection class. </p>
<p class="calibre1">2.  Now, rename the first occurrence of this class and change its docstring: class BaseGeoCollection(object):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">... </p>
<p class="calibre1">3.  Go to the _parse_data method and alter it to be as follows:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">raise NotImplementedError    </p>
<p class="calibre1">What we did here was we explicitly told that this method is not implemented in the base class. This is a good practice for two reasons: first it is a hint for the programmer that this method needs to be implemented when this class is inherited and it also states the <i class="calibre4">signature</i> for the method (the arguments that it should receive). Secondly, if it is not implemented, Python will raise NotImplementedError instead of AttributeError, leading to a better debugging experience. </p>
<p class="calibre1">1.  Before we continue, edit the imported modules at the beginning of the file to match the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">from shapely.geometry import Point</p>
<p class="calibre1">from shapely import wkb, wkt</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">2.  The base class is ready and now we are going to edit the PointCollection class. </p>
<p class="calibre1">Firstly, you can remove all the methods from this class. Leave only the docstring and the _parse_data method. </p>
<p class="calibre1">3.  Edit the class declaration and make it inherit from BaseGeoCollection. </p>
<p class="calibre1">4.  Finally, edit the _parse_data method to be compliant with the geometry represented by Shapely objects. Your code should be as follows:</p>
<p class="calibre1">class PointCollection(BaseGeoCollection):</p>
<p class="calibre1">"""This class represents a collection of</p>
<p class="calibre1">geocaching points. </p>
<p class="calibre1">""" </p>
<p class="calibre1"><a id="p188"/>    def _parse_data(self, features):</p>
<p class="calibre1">"""Transforms the data into Geocache objects. </p>
<p class="calibre1">:param features: A list of features. </p>
<p class="calibre1">""" </p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">coords = feature['geometry']['coordinates']</p>
<p class="calibre1">point = Point(float(coords[1]), float(coords[0]))</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">cache_point = Geocache(point, attributes = attributes)</p>
<p class="calibre1">self.data.append(cache_point)</p>
<p class="calibre1">Note that the difference is that while instancing the Geocache, instead of passing the coordinates, we are now passing a Point object, which is an instance of the Point class provided by Shapely. </p>
<p class="calibre1">5.  Next we are going to create the BoundaryCollection class. Insert this code anywhere after the base classes:</p>
<p class="calibre1">class BoundaryCollection(BaseGeoCollection):</p>
<p class="calibre1">"""This class represents a collection of</p>
<p class="calibre1">geographic boundaries. </p>
<p class="calibre1">""" </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">polygon = wkt.loads(geom)</p>
<p class="calibre1">boundary = Boundary(geometry=polygon, </p>
<p class="calibre1">attributes=attributes)</p>
<p class="calibre1">self.data.append(boundary)</p>
<p class="calibre1">The difference from PointCollection is that we are now creating polygons and instances of the Boundary class. Note how the polygon is created with the statement wkt.loads(geom). </p>
<p class="calibre1">6.  We are almost done. Check whether everything is correct. The complete models.py file should contain the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">from shapely.geometry import Point</p>
<p class="calibre1">from shapely import wkb, wkt</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">class BaseGeoObject(object):</p>
<p class="calibre1">"""Base class for a single geo object.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">self.geom = geometry</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1"><a id="p189"/>        raise NotImplementedError</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">class Geocache(BaseGeoObject):</p>
<p class="calibre1">"""This class represents a single geocaching point.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">super(Geocache, self).__init__(geometry, attributes)</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">name = self.attributes.get('name', 'Unnamed')</p>
<p class="calibre1">return "{} {}  -  {}".format(self.geom.x, </p>
<p class="calibre1">self.geom.y, name)</p>
<p class="calibre1">class Boundary(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single geographic boundary.""" </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">return self.attributes.get('name', 'Unnamed')</p>
<p class="calibre1">class BaseGeoCollection(object):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def __init__(self, file_path=None):</p>
<p class="calibre1">self.data = []</p>
<p class="calibre1">self.epsg = None</p>
<p class="calibre1">if file_path:</p>
<p class="calibre1">self.import_data(file_path)</p>
<p class="calibre1">def __add__(self, other):</p>
<p class="calibre1">self.data += other.data</p>
<p class="calibre1">return self</p>
<p class="calibre1">def import_data(self, file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features, metadata = open_vector_file(file_path)</p>
<p class="calibre1">self._parse_data(features)</p>
<p class="calibre1">self.epsg = metadata['epsg']</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">def describe(self):</p>
<p class="calibre1">print("SRS EPSG code: {}".format(self.epsg))</p>
<p class="calibre1">print("Number of features: {}".format(len(self.data))) class PointCollection(BaseGeoCollection):</p>
<p class="calibre1">"""This class represents a collection of</p>
<p class="calibre1">geocaching points. </p>
<p class="calibre1"><a id="p190"/>    """ </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">"""Transforms the data into Geocache objects. </p>
<p class="calibre1">:param features: A list of features. </p>
<p class="calibre1">""" </p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">coords = feature['geometry']['coordinates']</p>
<p class="calibre1">point = Point(coords)</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">cache_point = Geocache(point, attributes=attributes)</p>
<p class="calibre1">self.data.append(cache_point)</p>
<p class="calibre1">class BoundaryCollection(BaseGeoCollection):</p>
<p class="calibre1">"""This class represents a collection of</p>
<p class="calibre1">geographic boundaries. </p>
<p class="calibre1">""" </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">polygon = wkt.loads(geom)</p>
<p class="calibre1">boundary = Boundary(geometry=polygon, </p>
<p class="calibre1">attributes=attributes)</p>
<p class="calibre1">self.data.append(boundary)</p>
<p class="calibre1">7.  Now, in order to test it, go to the end of the file and edit the if __name__ ==</p>
<p class="calibre1">'__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">world = BoundaryCollection("../data/world_borders_simple.shp") for item in world.data:</p>
<p class="calibre1">print(item)</p>
<p class="calibre1">8.  Now run it, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>, and select models. If everything is OK, you should see a long list of the unnamed countries:</p>
<p class="calibre1">File imported: ../data/world_borders_simple.shp</p>
<p class="calibre1">Unnamed</p>
<p class="calibre1">Unnamed</p>
<p class="calibre1">Unnamed</p>
<p class="calibre1">Unnamed…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">This is disappointing. We expected to see the names of the countries, but for some reason, the program failed to get it from the attributes. We will solve this problem in the next topic. </p>
<p class="calibre1"><a id="p191"/>
<a id="p192"/><b class="calibre3">Getting the attributes’ values</b></p>
<p class="calibre1">Let’s explore the attributes of the world borders to find out why we were unable to get the names. </p>
<p class="calibre1">1.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">world = BoundaryCollection("../data/world_borders_simple.shp") print(world.data[0].attributes.keys())</p>
<p class="calibre1">2.  Run the code and look at the output:</p>
<p class="calibre1">File imported: ../data/world_borders_simple.shp</p>
<p class="calibre1">['SUBREGION', 'POP2005', 'REGION', 'ISO3', 'ISO2', 'FIPS', 'UN', </p>
<p class="calibre1">'NAME']</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">What we did was we got the first item in world.data and then printed its attribute keys. The list shown in the output has a NAME key, but it is all in the uppercase. This is very common for Shapefiles whose data is contained in the DBF files. </p>
<p class="calibre1">Since we don’t want to worry if the attributes’ names are in the uppercase or lowercase, we have two possible solutions: convert the names at the moment of the import or convert the names on the fly when the attribute value is requested. </p>
<p class="calibre1">Depending on your application, you may achieve better performance with one or the other method. Here, for didactic purposes, we will opt for the on-the-fly conversion and add a little spice to it. </p>
<p class="calibre1">3.  Instead of accessing the attributes directly, let’s make a method that will do it for us. </p>
<p class="calibre1">Edit the BaseGeoObject class’ __init__ method and also add a get_attribute method:</p>
<p class="calibre1">class BaseGeoObject(object):</p>
<p class="calibre1">"""Base class for a single geo object.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">self.geom = geometry</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1"><b class="calibre3">        # Makes a lookup table of case insensitive attributes. </b></p>
<p class="calibre1"><b class="calibre3">        self._attributes_lowercase = {}</b></p>
<p class="calibre1"><b class="calibre3">        for key in self.attributes.keys():</b></p>
<p class="calibre1"><b class="calibre3">            self._attributes_lowercase[key.lower()] = key</b></p>
<p class="calibre1">@property</p>
<p class="calibre1">def coordinates(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">def get_attribute(self, attr_name, case_sensitive=False):</p>
<p class="calibre1">"""Gets an attribute by its name. </p>
<p class="calibre1">:param attr_name: The name of the attribute. </p>
<p class="calibre1"><a id="p193"/>        :param case_sensitive: True or False. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if not case_sensitive:</p>
<p class="calibre1">attr_name = attr_name.lower()</p>
<p class="calibre1">attr_name = self._attributes_lowercase[attr_name]</p>
<p class="calibre1">return self.attributes[attr_name]</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">In the __init__ method, we made a dictionary that contains the equivalence between lowercase attribute names and the original names. If you search the Internet, there is a number of techniques to implement case-insensitive dictionaries. But the one we implemented here allows us to preserve the original names, giving the user the option to choose whether he wants the search to be case-sensitive or not. </p>
<p class="calibre1">4.  Now, edit the Boundary class to use the new method:</p>
<p class="calibre1">class Boundary(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single geographic boundary.""" </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">return self.get_attribute('name')</p>
<p class="calibre1">5.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':    </p>
<p class="calibre1">world = BoundaryCollection("../data/world_borders_simple.shp") for item in world.data:</p>
<p class="calibre1">print(item)</p>
<p class="calibre1">6.  Run the code again. Now, you should have a beautiful list of country names: File imported: ../data/world_borders_simple.shp</p>
<p class="calibre1">Antigua and Barbuda</p>
<p class="calibre1">Algeria</p>
<p class="calibre1">Azerbaijan</p>
<p class="calibre1">Albania</p>
<p class="calibre1">Armenia…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p194"/>
<a id="p195"/><b class="calibre3">Importing lines</b></p>
<p class="calibre1">As we did with the geocaching points and political boundaries, we will implement the ability of the program to import lines (that is, linestrings). These lines can represent roads, rivers, power lines, and so on. With this kind of features, we will be able to search for points that are close to a given road for example. </p>
<p class="calibre1">The lines and the collection of lines will also be the subclasses of BaseGeoObject and BaseGeoCollection. Let’s start by making a LineString and a LineStringCollection class, as follows:</p>
<p class="calibre1">1.  Insert this new class into the models.py file. It could be anywhere after the base classes’ definition:</p>
<p class="calibre1">class LineString(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single linestring.""" </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">return self.get_attribute('name')</p>
<p class="calibre1">Again, we only implement the __repr__ method. The other functionalities are inherited from the BaseGeoObject class. </p>
<p class="calibre1">2.  Now, add the class representing a collection of linestrings and its _parse_data method:</p>
<p class="calibre1">class LineStringCollection(BaseGeoCollection):</p>
<p class="calibre1">"""Represents a collection of linestrings.""" </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">line = wkt.loads(geom)</p>
<p class="calibre1">linestring = LineString(geometry=line, </p>
<p class="calibre1">attributes=attributes)</p>
<p class="calibre1">self.data.append(linestring)</p>
<p class="calibre1">In order to test our new classes, we are going to use a shapefile containing USA’s main roads. </p>
<p class="calibre1"><a id="p196"/><img src="index-196_1.jpg" alt="Image 22" class="calibre2"/></p>
<p class="calibre1">3.  Edit the if __name__ == '__main__': block at the end of the file. You can comment the previous code if you wish instead of deleting it:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">usa_roads = LineStringCollection('../data/roads.shp')</p>
<p class="calibre1">for item in usa_roads.data:</p>
<p class="calibre1">print(item)</p>
<p class="calibre1">4.  Run the code. You should get a big list of the road names in the output console: File imported: ../data/roads.shp</p>
<p class="calibre1">State Route 131</p>
<p class="calibre1">State Route 3</p>
<p class="calibre1">State Route 3</p>
<p class="calibre1">State Route 3</p>
<p class="calibre1">State Route 411</p>
<p class="calibre1">State Route 3</p>
<p class="calibre1">State Route 3</p>
<p class="calibre1">State Route 5, State Route 786…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">In order to make our output more meaningful, we can change how each LineString class is printed. Remember that the special method named __repr__ is called when you use the print() function on an object, and it should return a string to be printed. </p>
<p class="calibre1">Let’s return more information when LineString is printed. </p>
<p class="calibre1">5.  Edit your LineString class and change the __repr__ method, so it returns the road name and length:</p>
<p class="calibre1">class LineString(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single linestring.""" </p>
<p class="calibre1">def __repr__(self):        </p>
<p class="calibre1">length = self.geom.length</p>
<p class="calibre1">return "{} - {}".format(self.get_attribute('name'), length)</p>
<p class="calibre1"><a id="p197"/>Here, we used Python’s string formatting to compose a string that can be returned by this method. </p>
<p class="calibre1">6.  Run the code and see the new output:</p>
<p class="calibre1">File imported: ../data/roads.shp</p>
<p class="calibre1">US Route 395-0.16619770512</p>
<p class="calibre1">US Route 30-0.0432070790491</p>
<p class="calibre1">State Route 84-0.0256320861143</p>
<p class="calibre1">US Route 6-0.336460513878</p>
<p class="calibre1">US Route 40-0.107844768871</p>
<p class="calibre1">State Route 272-0.0264889614357…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Although it’s much better than before, it still has a problem. The length is in degrees, and it means little or nothing to us because we are used to meters, miles, or any other linear unity. So, we need to convert the unity before we print the length. </p>
<p class="calibre1"><a id="p198"/>
<a id="p199"/><b class="calibre3">Converting the spatial reference system</b></p>
<p class="calibre1"><b class="calibre3">and units</b></p>
<p class="calibre1">Fortunately, we already did this kind of operation before and now we are going to adapt it to our data model. </p>
<p class="calibre1">We will transform the coordinates of the geometries only when they are needed. To perform the transformation, we will create a new utility function, as follows: 1.  Open geo_functions.py in our utils folder and create a new function: def transform_geometry(geom, src_epsg=4326, dst_epsg=3395):</p>
<p class="calibre1">"""Transforms a single wkb geometry. </p>
<p class="calibre1">:param geom: wkb geom. </p>
<p class="calibre1">:param src_epsg: EPSG code for the source geometry. </p>
<p class="calibre1">:param dst_epsg: EPSG code for the destination geometry. </p>
<p class="calibre1">""" </p>
<p class="calibre1">ogr_geom = ogr.CreateGeometryFromWkb(geom)</p>
<p class="calibre1">ogr_transformation = create_transform(src_epsg, dst_epsg)</p>
<p class="calibre1">ogr_geom.Transform(ogr_transformation)</p>
<p class="calibre1">return ogr_geom.ExportToWkb()</p>
<p class="calibre1">It takes as arguments geometries in the WKB format, its EPSG code, and the EPSG</p>
<p class="calibre1">code for the desired coordinate system for the output. It performs the transformation and returns a WKB geometry again. </p>
<p class="calibre1">Now back to the models; let’s import this function and use it. </p>
<p class="calibre1">2.  Edit the import at the beginning of the models.py file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">from shapely.geometry import Point</p>
<p class="calibre1">from shapely import wkb, wkt</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1"><b class="calibre3">from utils.geo_functions import transform_geometry</b></p>
<p class="calibre1">3.  Now, edit BaseGeoObject, so our classes can inherit this new functionality: class BaseGeoObject(object):</p>
<p class="calibre1">"""Base class for a single geo object.""" </p>
<p class="calibre1">def __init__(self, geometry, attributes=None):</p>
<p class="calibre1">self.geom = geometry</p>
<p class="calibre1">self.attributes = attributes</p>
<p class="calibre1"><b class="calibre3">        self.wm_geom = None</b></p>
<p class="calibre1"># Makes a lookup table of case insensitive attributes. </p>
<p class="calibre1">self._attributes_lowercase = {}</p>
<p class="calibre1">for key in self.attributes.keys():</p>
<p class="calibre1">self._attributes_lowercase[key.lower()] = key</p>
<p class="calibre1"><a id="p200"/><b class="calibre3">    def transformed_geom(self):</b></p>
<p class="calibre1"><b class="calibre3">        """Returns the geometry transformed into WorldMercator</b> <b class="calibre3">        coordinate system. </b></p>
<p class="calibre1"><b class="calibre3">        """ </b></p>
<p class="calibre1"><b class="calibre3">        if not self.wm_geom:</b></p>
<p class="calibre1"><b class="calibre3">            geom = transform_geometry(self.geom.wkb)</b></p>
<p class="calibre1"><b class="calibre3">            self.wm_geom = wkb.loads(geom)</b></p>
<p class="calibre1"><b class="calibre3">        return self.wm_geom</b></p>
<p class="calibre1">def get_attribute(self, attr_name, case_sensitive=False):</p>
<p class="calibre1">"""Gets an attribute by its name. </p>
<p class="calibre1">:param attr_name: The name of the attribute. </p>
<p class="calibre1">:param case_sensitive: True or False. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if not case_sensitive:</p>
<p class="calibre1">attr_name = attr_name.lower()</p>
<p class="calibre1">attr_name = self._attributes_lowercase[attr_name]</p>
<p class="calibre1">return self.attributes[attr_name]</p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">Note that we opted to keep the geometries in both the coordinate systems. The geometry in WorldMercator is stored in the wm_geom property the first time the transformation occurs. The next time transformed_geom is called, it will only get the property value. This is called <b class="calibre3">memorization</b> and we will see more of this technique later in the book. </p>
<p class="calibre1">Depending on your application, this may be a good practice because you may want to use different coordinate systems for specific purposes. For example, to draw a map, you may want to use lat/lon and, to perform calculation, you would need the coordinates in meters. The downside is that the memory consumption is higher, because you will be storing two sets of geometry. </p>
<p class="calibre1">4.  Finally, we go back to the LineString class and change its __repr__ method to use transformed_geom to calculate the length:</p>
<p class="calibre1">class LineString(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single linestring.""" </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">return "{}-{}".format(self.get_attribute('name'), <b class="calibre3">                              self.transformed_geom().length)</b> 5.  Run the code and see the new output:</p>
<p class="calibre1">File imported: ../data/roads.shp</p>
<p class="calibre1">State Route 3-100928.690515</p>
<p class="calibre1">State Route 411-3262.29448315</p>
<p class="calibre1">State Route 3-331878.76971</p>
<p class="calibre1">State Route 3-56013.8246795.73…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">It’s much better now as we can see the road lengths in meters. But it is still not perfect</p>
<p class="calibre1"><a id="p201"/>because, normally, we would want the lengths in kilometres or miles. So, we need to convert the unit. </p>
<p class="calibre1">In<a href="index_split_000.html#p45"> Chapter 1, </a>  <i class="calibre4">Preparing the Work Environment</i>, we made a beautiful function capable of performing these transformations; we used it to convert area units. Using it as a template, we are going to implement it to convert length units. </p>
<p class="calibre1">Since it’s a function that can be used in other parts of any application, we are going to put it into the geo_functions.py module in the utils package (that is, directory). </p>
<p class="calibre1">1.  Edit the geo_functions.py files and copy and paste the function that we used in</p>
<p class="calibre1"><a href="index_split_000.html#p45">Chapter 1, </a>  <i class="calibre4">Preparing the Work Environment</i>, to calculate and transform area units. </p>
<p class="calibre1">We will keep it there for later use:</p>
<p class="calibre1">def calculate_areas(geometries, unity='km2'):</p>
<p class="calibre1">"""Calculate the area for a list of ogr geometries.""" </p>
<p class="calibre1">conversion_factor = {</p>
<p class="calibre1">'sqmi': 2589988.11, </p>
<p class="calibre1">'km2': 1000000, </p>
<p class="calibre1">'m': 1}</p>
<p class="calibre1">if unity not in conversion_factor:</p>
<p class="calibre1">raise ValueError(</p>
<p class="calibre1">"This unity is not defined: {}".format(unity))</p>
<p class="calibre1">areas = []</p>
<p class="calibre1">for geom in geometries:</p>
<p class="calibre1">area = geom.Area()</p>
<p class="calibre1">areas.append(area / conversion_factor[unity])</p>
<p class="calibre1">return areas</p>
<p class="calibre1">2.  Duplicate this function (copy and paste) and edit it to make it like the following code: def convert_length_unit(value, unit='km', decimal_places=2):</p>
<p class="calibre1">"""Convert the leng unit of a given value. </p>
<p class="calibre1">The input is in meters and the output is set by the unity</p>
<p class="calibre1">argument. </p>
<p class="calibre1">:param value: Input value in meters. </p>
<p class="calibre1">:param unit: The desired output unit. </p>
<p class="calibre1">:param decimal_places: Number of decimal places of the output. </p>
<p class="calibre1">""" </p>
<p class="calibre1">conversion_factor = {</p>
<p class="calibre1">'mi': 0.000621371192, </p>
<p class="calibre1">'km': 0.001, </p>
<p class="calibre1">'m': 1.0}</p>
<p class="calibre1">if unit not in conversion_factor:</p>
<p class="calibre1">raise ValueError(</p>
<p class="calibre1">"This unit is not defined: {}".format(unit))</p>
<p class="calibre1">return round(value * conversion_factor[unit], decimal_places) Again, it’s a very versatile function because you can easily change its code to add more conversion factors to it. Here, we also introduced the round() function, so we can see a more readable result. By default, it will round the result to two decimal places, which in most cases, is enough for a good representation of length. </p>
<p class="calibre1"><a id="p202"/>3.  Go back to the models and import this new function after the other imports:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">from shapely.geometry import Point</p>
<p class="calibre1">from shapely import wkb, wkt</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">from utils.geo_functions import transform_geometry</p>
<p class="calibre1"><b class="calibre3">from utils.geo_functions import convert_length_unit</b></p>
<p class="calibre1">4.  Now edit the LineString class. We will add a  <i class="calibre4">convenience method</i> (we will see more about this later in the chapter) that will return the length in a converted unit, change the __repr__ value to use it, and also improve the string formatting to display the unit and get a better output:</p>
<p class="calibre1">class LineString(BaseGeoObject):</p>
<p class="calibre1">"""Represents a single linestring.""" </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1"><b class="calibre3">        unit = 'km' </b></p>
<p class="calibre1"><b class="calibre3">        return "{}  ({}{})".format(self.get_attribute('name'),</b> <b class="calibre3">                                   self.length(unit), unit)         </b></p>
<p class="calibre1"><b class="calibre3">    </b></p>
<p class="calibre1"><b class="calibre3">    def length(self, unit='km'):</b></p>
<p class="calibre1"><b class="calibre3">        """Convenience method that returns the length of the</b> <b class="calibre3">        linestring in a given unit. </b></p>
<p class="calibre1"><b class="calibre3">        :param unit: The desired output unit. </b></p>
<p class="calibre1"><b class="calibre3">        """ </b></p>
<p class="calibre1"><b class="calibre3">        return convert_length_unit(self.transformed_geom().length,</b> <b class="calibre3">                                   unit)</b></p>
<p class="calibre1">5.  Run the code again and see what we have accomplished:</p>
<p class="calibre1">File imported: ../data/roads.shp</p>
<p class="calibre1">State Route 146  (10.77km)</p>
<p class="calibre1">US Route 7, US Route 20  (5.81km)</p>
<p class="calibre1">State Route 295  (13.67km)</p>
<p class="calibre1">Interstate Route 90  (3.55km)</p>
<p class="calibre1">State Route 152  (18.22km)</p>
<p class="calibre1">State Route 73  (65.19km)</p>
<p class="calibre1">State Route 20  (53.89km)</p>
<p class="calibre1">State Route 95  (10.38km)</p>
<p class="calibre1">... </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p203"/>
<a id="p204"/><b class="calibre3">Geometry relationships</b></p>
<p class="calibre1">We want to filter the geocaching points that fall inside a given boundary (a country, state, city, and so on.). In order to perform this kind of filtering, we need to verify every point and see whether it’s inside the polygon representing the boundary. </p>
<p class="calibre1">In geoprocessing, the relations between the two geometries are described by a set of known predicates. These relationships are very important because they allow conditions to be made, so one can perform operations and calculations. </p>
<p class="calibre1">Shapely comes with a complete set of predicates that analyze the relation of the two geometries. Before we go further in our app, let’s take a look at the possible relation checks. </p>
<p class="calibre1"><a id="p205"/><img src="index-205_1.jpg" alt="Image 23" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Touches</b></p>
<p class="calibre1">This is true if the geometries have one or more points in common without their interiors intersecting. </p>
<p class="calibre1"><a id="p206"/><img src="index-206_1.jpg" alt="Image 24" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Crosses</b></p>
<p class="calibre1">This is true if there is an intersection between the two objects without one containing the other. </p>
<p class="calibre1"><a id="p207"/><img src="index-207_1.jpg" alt="Image 25" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Contains</b></p>
<p class="calibre1">This indicates if one object completely contains the other object; all the boundaries, lines, or points must be inside the first object. </p>
<p class="calibre1"><a id="p208"/><b class="calibre3">Within</b></p>
<p class="calibre1">This is true if one geometry is contained in another geometry. It’s the same as  <i class="calibre4">Contains</i>, but if you switch the two geometries. </p>
<p class="calibre1"><a id="p209"/><img src="index-209_1.jpg" alt="Image 26" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Equals or almost equals</b></p>
<p class="calibre1">This is true if the two objects have the same boundary and interior. Almost equals allows a configurable tolerance in the precision of the test. </p>
<p class="calibre1"><a id="p210"/><img src="index-210_1.jpg" alt="Image 27" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Intersects</b></p>
<p class="calibre1">This indicates that one geometry intersects the other in any way. It is true if any of these relations are true: contains, crosses, equals, touches, and within. </p>
<p class="calibre1"><a id="p211"/><img src="index-211_1.jpg" alt="Image 28" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Disjoint</b></p>
<p class="calibre1">This returns true if the two geometries have no relation between them. </p>
<p class="calibre1"><a id="p212"/>
<a id="p213"/><b class="calibre3">Filtering by attributes and relations</b></p>
<p class="calibre1">Now that we know how geometries relate to each other, we can search points using these relations. We already have the means for importing the points and the polygons that represent any kind of boundaries that may be of our interest. </p>
<p class="calibre1">The data that comes with the book files contains examples of world countries’ boundaries, but you are free to search the Internet for any data that is significant to you. Remember only that the data coordinates should be in latitudes and longitudes, and they need to have a name field. </p>
<p class="calibre1">For our tests, I prepared a special set of geocaching points that spans the whole globe, and as an exercise, we will filter these points by a country. </p>
<p class="calibre1">The proposed workflow is as follows:</p>
<p class="calibre1">Import the points and boundaries</p>
<p class="calibre1">Find the boundary that we want to use</p>
<p class="calibre1">Filter the points by that boundary</p>
<p class="calibre1">Return the points to the user</p>
<p class="calibre1">To find the points that we want, we will iterate over the data until it hits a match. Iterations can be costly in terms of processing depending on the amount of data and on the operations that are performed on each loop. Let’s keep this in mind. </p>
<p class="calibre1">The first step in the workflow is already done, so let’s write the code to find the boundary of our interest. If you are using the data provided, we can find the boundary of your country as follows:</p>
<p class="calibre1">1.  Go to the BoundaryCollection class and add a new method get_by_name: class BoundaryCollection(BaseGeoCollection):</p>
<p class="calibre1">"""This class represents a collection of</p>
<p class="calibre1">geographic boundaries. </p>
<p class="calibre1">""" </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = feature['geometry']['coordinates']</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">polygon = wkt.loads(geom)</p>
<p class="calibre1">boundary = Boundary(geometry=polygon, </p>
<p class="calibre1">attributes=attributes)</p>
<p class="calibre1">self.data.append(boundary)</p>
<p class="calibre1"/>
<p class="calibre1">def get_by_name(self, name):</p>
<p class="calibre1">"""Find an object by its name attribute and returns it.""" </p>
<p class="calibre1">for item in self.data:</p>
<p class="calibre1">if item.get_attribute('name') == name:</p>
<p class="calibre1">return item</p>
<p class="calibre1">raise LookupError(</p>
<p class="calibre1">"Object not found with the name: {}".format(name)) This very simple method iterates over the data. When it finds the first boundary</p>
<p class="calibre1"><a id="p214"/>whose name property matches the name passed as an argument, the function execution stops and the object is returned. If nothing is found, LookupError will be raised. </p>
<p class="calibre1">2.  Let’s play with it. Go to the if __name__ == '__main__': block at the end of the file and edit it:</p>
<p class="calibre1">if __name__ == '__main__':    </p>
<p class="calibre1">world = BoundaryCollection("../data/world_borders_simple.shp") print(world.get_by_name('Brazil'))</p>
<p class="calibre1">3.  Try the different countries’ names and see the results. If it’s found, you should have an output similar to this:</p>
<p class="calibre1">File imported: ../data/world_borders_simple.shp</p>
<p class="calibre1">Brazil</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">4.  If it’s not found, you should get a nice exception:</p>
<p class="calibre1">Traceback (most recent call last):</p>
<p class="calibre1">File "Chapter 4/code/models.py", line 153, in &lt;module&gt; print(world_Boundarys.get_by_name('Foo'))</p>
<p class="calibre1">File "Chapter 4/code/models.py", line 148, in get_by_name</p>
<p class="calibre1">'Object not found with the name: {}'.format(name))</p>
<p class="calibre1">LookupError: Object not found with the name: Foo</p>
<p class="calibre1">Process finished with exit code 1</p>
<p class="calibre1">Very well, our method works nice and with an additional (almost) unexpected feature: it’s not specific for the boundaries; it can be used to find any type of GeoObject. Take a look and notice how it only uses properties that are available in our base classes. </p>
<p class="calibre1">5.  Move the get_by_name method to the BaseGeoCollection class and test you code again. Remember that the order of the methods inside a class is irrelevant for the class’ behavior, but the best practices recommend you to put the magic methods first, then the private ones, and then the others. Your complete BaseGeoCollection class should be as follows:</p>
<p class="calibre1">class BaseGeoCollection(object):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def __init__(self, file_path=None):</p>
<p class="calibre1">self.data = []</p>
<p class="calibre1">self.epsg = None</p>
<p class="calibre1">if file_path:</p>
<p class="calibre1">self.import_data(file_path)</p>
<p class="calibre1">def __add__(self, other):</p>
<p class="calibre1">self.data += other.data</p>
<p class="calibre1">return self</p>
<p class="calibre1"><a id="p215"/>    def _parse_data(self, features):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">def import_data(self, file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features, metadata = open_vector_file(file_path)</p>
<p class="calibre1">self._parse_data(features)</p>
<p class="calibre1">self.epsg = metadata['epsg']</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">def describe(self):</p>
<p class="calibre1">print("SRS EPSG code: {}".format(self.epsg))</p>
<p class="calibre1">print("Number of features: {}".format(len(self.data))) def get_by_name(self, name):</p>
<p class="calibre1">"""Find an object by its name attribute and returns it.""" </p>
<p class="calibre1">for item in self.data:</p>
<p class="calibre1">if item.get_attribute('name') == name:</p>
<p class="calibre1">return item</p>
<p class="calibre1">raise LookupError(</p>
<p class="calibre1">"Object not found with the name: {}".format(name)) Now, in the next step, we will search for the points that are within the boundary that we found. This time, we will create a method directly inside the BaseGeoCollection class, so it becomes available to the PointCollection and the BoundaryCollection classes through inheritance. By doing this, we will get a bonus feature—we are able to filter the boundaries by another boundary. </p>
<p class="calibre1">6.  Go to the BaseGeoCollection class and add the method filter_by_boundary:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def filter_by_boundary(self, boundary):</p>
<p class="calibre1">"""Filters the data by a given boundary""" </p>
<p class="calibre1">result = []</p>
<p class="calibre1">for item in self.data:</p>
<p class="calibre1">if item.geom.within(boundary.geom):</p>
<p class="calibre1">result.append(item)</p>
<p class="calibre1">return result</p>
<p class="calibre1">Here, we created a variable result containing a list to store the objects that passes the test. The within predicate is used to test every item if it is inside the boundary that is passed as an argument. In this case, if nothing is found, no exception is raised and an empty list is returned. </p>
<p class="calibre1">7.  Edit the testing code in the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">world = BoundaryCollection("../data/world_borders_simple.shp") geocaching_points = PointCollection("../data/geocaching.gpx") usa_boundary = world.get_by_name('United States')</p>
<p class="calibre1"><a id="p216"/>    result = geocaching_points.filter_by_boundary(usa_boundary) for item in result:</p>
<p class="calibre1">print(item)</p>
<p class="calibre1">While testing, two instances are created, one from the BoundaryCollection class and one from the PointCollection class. The data files are passed as arguments. Then, the country of interest is found and stored in the usa_boundary variable. This variable is then passed to the filter_by_boundary method. </p>
<p class="calibre1">8.  Run the code. You should see a long list of geocaches as follows:</p>
<p class="calibre1">-78.90175 42.89648  -  LaSalle Park No 1</p>
<p class="calibre1">-78.89818 42.89293  -  LaSalle Park No 2</p>
<p class="calibre1">-78.47808 43.02617  -  A Unique Walk in Akron</p>
<p class="calibre1">-78.93865 42.95982  -  A view of Strawberry Island</p>
<p class="calibre1">-78.90007 42.7484  -  A View to a Windmill</p>
<p class="calibre1">-79.07533 43.08133  -  A Virtual Made in the Mist</p>
<p class="calibre1">-74.43207 43.86942  -  Adirondack Museum Guestbook…</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">As expected, it prints a list of Geocache objects whose representation given by the __repr__ method is their coordinates and names. </p>
<p class="calibre1"><a id="p217"/>
<a id="p218"/><b class="calibre3">Filtering by multiple attributes</b></p>
<p class="calibre1">The next step is to search the geocaching points by their attributes. For example, we may want to filter the points by the author of the geocache, by the level of difficulty to find the geocache, and so on. </p>
<p class="calibre1">We will borrow the techniques used in the methods that allowed us to get a GeoObject by its name property and the method that filtered by a polygon. The difference here is that we must allow the attribute that we want to filter by to be passed as a parameter, and we want to have the capability to combine multiple fields. </p>
<p class="calibre1">1.  Let’s start adding a simple filter method in the BaseGeoCollection class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def filter(self, attribute, value):</p>
<p class="calibre1">"""Filters the collection by an attribute. </p>
<p class="calibre1">:param attribute: The name of the attribute to filter by. </p>
<p class="calibre1">:param value: The filtering value. </p>
<p class="calibre1">""" </p>
<p class="calibre1">result = []</p>
<p class="calibre1">for item in self.data:</p>
<p class="calibre1">if item.get_attribute(attribute) == value:</p>
<p class="calibre1">result.append(item)</p>
<p class="calibre1">return result</p>
<p class="calibre1">This method takes two arguments: the attribute name that we want to filter by and the value that this attribute needs to have to pass the filter. Different from get_by_name, this filtering function accumulates every object found into a list and returns this list. </p>
<p class="calibre1">2.  To test the filtering method, edit the if __name__ == '__main__': block. We will filter the geocache points whose level of difficulty is 1:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty', '1')</p>
<p class="calibre1">points.describe()</p>
<p class="calibre1">print("Found {} points".format(len(result)))</p>
<p class="calibre1">3.  Run the code. You should have this output:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 112</p>
<p class="calibre1">Found 38 points</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">From a total of 112 points, 38 match our criteria. </p>
<p class="calibre1"><a id="p219"/><b class="calibre3">Chaining filters</b></p>
<p class="calibre1">This part deserves a topic because we are going to use a very handy Python technique that you will most certainly need more than once to solve your geoprocessing challenges. </p>
<p class="calibre1">So far, we can apply a single filter that will return a list of objects. If we want to apply more than one filter, we can simply make the filter function return another collection object with the results, instead of returning a list. This way, we can make it possible to take the results from one filtering and filter them again, thus narrowing the results. </p>
<p class="calibre1">Besides being surprisingly simple, this solution is also very efficient in terms of processing, because at each filtering pass, the results are smaller and the number of iterations reduces. </p>
<p class="calibre1">Python allows function calls to be chained. This means that we don’t need to store each step into a variable. We can simply put each call one after another in a very elegant and intuitive pattern as exemplified here:</p>
<p class="calibre1">my_points = points.filter('difficulty', '1').filter('status', 'Available') Note that this is an and condition. It will return the points that satisfy both the filters. But since we implemented the __add__ method to the BaseGeoCollection class, we can easily achieve an or type of filtering:</p>
<p class="calibre1">my_points = points.filter('difficulty', '1') + points.filter('difficulty', </p>
<p class="calibre1">'2')</p>
<p class="calibre1">1.  Let’s make our method return a new instance to make this work. Edit the filter method in the BaseGeoCollection class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def filter(self, attribute, value):</p>
<p class="calibre1">"""Filters the collection by an attribute. </p>
<p class="calibre1">:param attribute: The name of the attribute to filter by. </p>
<p class="calibre1">:param value: The filtering value. </p>
<p class="calibre1">""" </p>
<p class="calibre1">result = self.__class__()</p>
<p class="calibre1">for item in self.data:</p>
<p class="calibre1">if getattr(item, attribute) == value:</p>
<p class="calibre1">result.data.append(item)</p>
<p class="calibre1">return result</p>
<p class="calibre1">Now, the result is an instance of the same class that originated the instance where the method was called, because __class__ is a property that contains the class that originated the instance. Since we are using inheritance, this ensures that we have the result in the same type and the data. Although this is a very simple solution, it works very well. Let’s try it:</p>
<p class="calibre1">2.  Edit the if __name__ == '__main__': block, so we can filter the points that match the two conditions (the and condition):</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1"><a id="p220"/>    gdal.PushErrorHandler('CPLQuietErrorHandler') points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty', '1').filter('container', </p>
<p class="calibre1">'Virtual')</p>
<p class="calibre1">points.describe()</p>
<p class="calibre1">result.describe()</p>
<p class="calibre1">3.  Run the following code:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 112</p>
<p class="calibre1">SRS EPSG code: None</p>
<p class="calibre1">Number of features: 34</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">From the previous test, we know that 38 points are of difficulty 1, now we got 34</p>
<p class="calibre1">points because of those 38 points, four does not have a container = Virtual. </p>
<p class="calibre1">4.  Try another test this time using an or condition:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">points = PointCollection("../data/geocaching.gpx") result = points.filter('difficulty', '1') + points.filter(</p>
<p class="calibre1">'difficulty', '2')</p>
<p class="calibre1">points.describe()</p>
<p class="calibre1">result.describe()</p>
<p class="calibre1">5.  Run the code:</p>
<p class="calibre1">File imported: ../data/geocaching.gpx</p>
<p class="calibre1">SRS EPSG code: 4326</p>
<p class="calibre1">Number of features: 112</p>
<p class="calibre1">SRS EPSG code: None</p>
<p class="calibre1">Number of features: 50</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">This time, these 38 points of difficulty 1 were combined with another 12 points of difficulty 2. </p>
<p class="calibre1"><a id="p221"/>
<a id="p222"/><b class="calibre3">Integrating with the app</b></p>
<p class="calibre1">As we continue to work with increasing levels of abstraction, think of our app’s organization. We have two types of data and we have the GeocachingApp class with high level functionality. At this point, what we want is to enable the app to filter like we did in the tests, but in a simple and straightforward way. </p>
<p class="calibre1">Take a look at the app as it is at this point:</p>
<p class="calibre1">class GeocachingApp(PointCollection):</p>
<p class="calibre1">def __init__(self, data_file=None, my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param data_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">:param my_location: Coordinates of your location. </p>
<p class="calibre1">""" </p>
<p class="calibre1">super(GeocachingApp, self).__init__(file_path=data_file)</p>
<p class="calibre1">self._datasource = None</p>
<p class="calibre1">self._transformed_geoms = None</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">self.distances = None</p>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">@property</p>
<p class="calibre1">def my_location(self):</p>
<p class="calibre1">return self._my_location</p>
<p class="calibre1">@my_location.setter</p>
<p class="calibre1">def my_location(self, coordinates):</p>
<p class="calibre1">self._my_location = transform_points([coordinates])[0]</p>
<p class="calibre1">def calculate_distances(self):</p>
<p class="calibre1">"""Calculates the distance between a</p>
<p class="calibre1">set of points and a given location. </p>
<p class="calibre1">:return: A list of distances in the same order as</p>
<p class="calibre1">the points. </p>
<p class="calibre1">""" </p>
<p class="calibre1">xa = self.my_location[0]</p>
<p class="calibre1">ya = self.my_location[1]</p>
<p class="calibre1">points = self._transformed_geoms</p>
<p class="calibre1">distances = []</p>
<p class="calibre1">for geom in points:</p>
<p class="calibre1">point_distance = math.sqrt(</p>
<p class="calibre1">(geom.GetX() - xa)**2 + (geom.GetY() - ya))</p>
<p class="calibre1">distances.append(point_distance)</p>
<p class="calibre1">return distances</p>
<p class="calibre1">def find_closest_point(self):</p>
<p class="calibre1">"""Find the closest point to a given location and</p>
<p class="calibre1"><a id="p223"/>        return the cache that's on that point. </p>
<p class="calibre1">:return: OGR feature containing the point. </p>
<p class="calibre1">""" </p>
<p class="calibre1"># Part 1. </p>
<p class="calibre1">distances = self.calculate_distances()</p>
<p class="calibre1">index = np.argmin(distances)</p>
<p class="calibre1"># Part 2. </p>
<p class="calibre1">layer = self._datasource.GetLayerByIndex(0)</p>
<p class="calibre1">feature = layer.GetFeature(index)</p>
<p class="calibre1">print "Closest point at: {}m".format(distances[index]) return feature</p>
<p class="calibre1">Inheritance was used to give the app the functionality contained in the PointCollection class. But this schema won’t work anymore because we now have two types of data. We have to remove the inheritance and make a different approach. </p>
<p class="calibre1">What we will do is store instances of the collection classes (PointCollection and BoundaryCollection), and implement the methods that will relate them in the same way it was done in the tests of the chaining filters topic. </p>
<p class="calibre1">Let’s start with the imports and the class’ definition:</p>
<p class="calibre1">1.  Open your geocaching_app.py file and edit the imports section at the beginning of the file to include new classes:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">import math</p>
<p class="calibre1">from utils.geo_functions import transform_points</p>
<p class="calibre1">from models import PointCollection, BoundaryCollection</p>
<p class="calibre1">2.  Now, edit the GeocachingApp class definition and the __init__ method to be as follows:</p>
<p class="calibre1">class GeocachingApp(object):</p>
<p class="calibre1">def __init__(self, </p>
<p class="calibre1">geocaching_file=None, </p>
<p class="calibre1">boundary_file=None, </p>
<p class="calibre1">my_location=None):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param geocaching_file: An OGR compatible file</p>
<p class="calibre1">with geocaching points. </p>
<p class="calibre1">:param boundary_file: A file with boundaries. </p>
<p class="calibre1">:param my_location: Coordinates of your location. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.geocaching_data = PointCollection(geocaching_file)</p>
<p class="calibre1">self.boundaries = BoundaryCollection(boundary_file)</p>
<p class="calibre1">self._my_location = None</p>
<p class="calibre1">if my_location:</p>
<p class="calibre1">self.my_location = my_location</p>
<p class="calibre1">The inheritance was removed and now the data is stored in the geocaching_data and</p>
<p class="calibre1"><a id="p224"/>boundaries properties. Optionally, if the user passes a file with geocaching data or with boundary data to the GeocachingApp class, these same files are passed as an argument to the PointCollection and BoundaryCollection creations. </p>
<p class="calibre1">With what you have now, you can already do any type of filtering. You just need to access geocaching_data and boundaries and do exactly what we did before. Let’s try it. </p>
<p class="calibre1">3.  Go to the end of the file where there is a line with if __name__ == "__main__": and edit the code:</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">my_app = GeocachingApp("../data/geocaching.gpx", </p>
<p class="calibre1">"../data/world_borders_simple.shp")</p>
<p class="calibre1">usa_boundary = my_app.boundaries.get_by_name('United States') result = my_app.geocaching_data.filter_by_boundary(</p>
<p class="calibre1">usa_boundary)</p>
<p class="calibre1">print(result)</p>
<p class="calibre1">4.  Now run it. Remember that whenever you want to run a different file, you need to press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and choose the file in the popup. You should see the output with the list of geocaching points again. </p>
<p class="calibre1">But let’s suppose that there is a kind of filtering that is expected to be needed multiple times or, maybe, there is a filtering that you want to make explicit. </p>
<p class="calibre1">Following the same example, suppose that we are filtering by a country name in this case. </p>
<p class="calibre1">We can use the GeocachingApp class, which stands in the highest level of abstraction in our code to implement this or any other high level filtering method. </p>
<p class="calibre1">5.  Add this method to the GeocachingApp class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def filter_by_country(self, name):        </p>
<p class="calibre1">"""Filter by a country with a given name. </p>
<p class="calibre1">:param name: The name of the boundary (ex. county name)</p>
<p class="calibre1">:return: PointCollection</p>
<p class="calibre1">""" </p>
<p class="calibre1">boundary = self.boundaries.get_by_name(name)        </p>
<p class="calibre1">return self.geocaching_data.filter_by_boundary(boundary)</p>
<p class="calibre1">In computer programming, this is also called <b class="calibre3">convenience method</b>. It’s a method created for convenience in order to solve a more complex task or to avoid boilerplate code (that is, to avoid code repetition). </p>
<p class="calibre1"><a id="p225"/>
<a id="p226"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we saw that the different types of relationships between geometries can be tested, and that these tests can be used in the program to solve problems. </p>
<p class="calibre1">In order to filter by polygons, first we used the same code to import these polygons into the system like we did with the points, but this time we used Shapely to abstract the geometries of the polygons and points. Finally, we used geometry relationships to search for points inside the polygons. </p>
<p class="calibre1">Then, we implemented a way to filter the data by the name property and we made it filter the data by any property of the object or any combination of properties. </p>
<p class="calibre1">Finally, we adapted the app class to work with the new changes and saw that it’s possible to add convenience methods to it in order to simplify some tasks. </p>
<p class="calibre1">In the next chapter, we will start working on the Map Maker App and create means to visualize our data. </p>
<p class="calibre1"><a id="p227"/>
<a id="p228"/><b class="calibre3">Chapter 5. Making Maps</b></p>
<p class="calibre1">In this chapter, we will start a new application and use it to produce nice maps from vector data. </p>
<p class="calibre1">In order to produce these maps, we will use Mapnik, one of the world’s most used mapping packages. The objective is to understand how it works and adapt it to make an easy-to-use mapping application. </p>
<p class="calibre1">In the previous chapters, we produced some very functional classes that abstract geographic data; we will make this app capable of consuming this type of data. </p>
<p class="calibre1">We will cover the following topics:</p>
<p class="calibre1">Getting to know Mapnik and see how it works</p>
<p class="calibre1">Seeing the differences between pure Python and XML when defining a map Experimenting with different styles</p>
<p class="calibre1">Using Python objects as a source of data for Mapnik</p>
<p class="calibre1">Abstracting Mapnik into a high-level application</p>
<p class="calibre1"><a id="p229"/><b class="calibre3">Knowing Mapnik</b></p>
<p class="calibre1">Mapnik is the tool that we will use to produce our maps. It’s a very powerful mapping library used by many websites. </p>
<p class="calibre1">In this first topic, we will go through some experiments to get to know Mapnik’s features. </p>
<p class="calibre1">Now we will perform a few experiments with Mapnik in order to know how it works. </p>
<p class="calibre1">First, let’s organize the code for this chapter:</p>
<p class="calibre1">1.  Inside your geopy project, copy the Chapter4 folder and rename it to Chapter5. </p>
<p class="calibre1">2.  Inside the Chapter5 folder, create a new folder named mapnik_experiments. To do that, right-click in your Chapter5 folder and choose <b class="calibre3">New</b> | <b class="calibre3">Directory</b>. </p>
<p class="calibre1">3.  Still in Chapter5, create another folder named output; we will place the maps and images we create into that folder. </p>
<p class="calibre1"><a id="p230"/><b class="calibre3">Making a map with pure Python</b></p>
<p class="calibre1">Mapnik has two ways to define a map; one uses pure Python code, the other an XML file. </p>
<p class="calibre1">Mapnik’s Python API is very extensive and wraps almost all of the package’s functionalities. In the next steps we will experiment with making a map with Python code only. </p>
<p class="calibre1">1.  Inside mapnik_experiments, create a Python file named mapnik_python.py. </p>
<p class="calibre1">2.  Type the following code into mapnik_python.py:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1"># Create a Map</p>
<p class="calibre1">map = mapnik.Map(800, 600)</p>
<p class="calibre1"># Set the background color of the map. </p>
<p class="calibre1">map.background = mapnik.Color('white')</p>
<p class="calibre1"># Create a Style and a Rule. </p>
<p class="calibre1">style = mapnik.Style()</p>
<p class="calibre1">rule = mapnik.Rule()</p>
<p class="calibre1"># Create a PolygonSymbolizer to fill the polygons and</p>
<p class="calibre1"># add it to the rule. </p>
<p class="calibre1">polygon_symbolizer = mapnik.PolygonSymbolizer(</p>
<p class="calibre1">mapnik.Color('#f2eff9'))</p>
<p class="calibre1">rule.symbols.append(polygon_symbolizer)</p>
<p class="calibre1"># Create a LineSymbolizer to style the polygons borders and</p>
<p class="calibre1"># add it to the rule. </p>
<p class="calibre1">line_symbolizer = mapnik.LineSymbolizer(</p>
<p class="calibre1">mapnik.Color('rgb(50%,50%,50%)'), 0.1)</p>
<p class="calibre1">rule.symbols.append(line_symbolizer)</p>
<p class="calibre1"># Add the rule to the style. </p>
<p class="calibre1">style.rules.append(rule)</p>
<p class="calibre1"># Add the Style to the Map. </p>
<p class="calibre1">map.append_style('My Style', style)</p>
<p class="calibre1"># Create a data source from a shapefile. </p>
<p class="calibre1">data = mapnik.Shapefile(file='../../data/world_borders_simple.shp')</p>
<p class="calibre1"># Create a layer giving it the name 'world'. </p>
<p class="calibre1">layer = mapnik.Layer('world')</p>
<p class="calibre1"># Set the layer data source and add the style to the layer. </p>
<p class="calibre1">layer.datasource = data</p>
<p class="calibre1">layer.styles.append('My Style')</p>
<p class="calibre1"># Add the layer to the map. </p>
<p class="calibre1">map.layers.append(layer)</p>
<p class="calibre1"># Zoom the map to the extent of all layers. </p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1"><a id="p231"/><img src="index-231_1.jpg" alt="Image 29" class="calibre2"/></p>
<p class="calibre1"># Write the map to a image. </p>
<p class="calibre1">mapnik.render_to_file(map,'../output/world.png', 'png')</p>
<p class="calibre1">3.  Now run the code; press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and select mapnik_python. </p>
<p class="calibre1">4.  There should be a new file named world.png inside your output folder. You can view this image in PyCharm; just double-click it. You should see this: Congratulations on creating this first beautiful map; note the superior quality of this rendering and how quickly Mapnik does its job. </p>
<p class="calibre1"><a id="p232"/><b class="calibre3">Making a map with a style sheet</b></p>
<p class="calibre1">Instead of using only Python code, the map styles, layers, and other definitions can be put inside an XML file. Let’s try this:</p>
<p class="calibre1">1.  Inside the mapnik_experiments folder, create a new file named map_style.xml. </p>
<p class="calibre1">2.  Type the following code:</p>
<p class="calibre1">&lt;Map background-color="white"&gt; </p>
<p class="calibre1">&lt;Style name="My Style"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" /&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Layer name="world"&gt; </p>
<p class="calibre1">&lt;StyleName&gt;My Style&lt;/StyleName&gt; </p>
<p class="calibre1">&lt;Datasource&gt; </p>
<p class="calibre1">&lt;Parameter name="file"&gt; </p>
<p class="calibre1">../../data/world_borders_simple.shp</p>
<p class="calibre1">&lt;/Parameter&gt; </p>
<p class="calibre1">&lt;Parameter name="type"&gt;shape&lt;/Parameter&gt; </p>
<p class="calibre1">&lt;/Datasource&gt; </p>
<p class="calibre1">&lt;/Layer&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">This is the style definition of your map. Although PyCharm is a Python IDE, it’s also capable of recognizing a lot of file types including XML; it should help you with the tags and should apply a nice coloring to the code. </p>
<p class="calibre1">Now you need the Python code to generate this map:</p>
<p class="calibre1">3.  Create a Python file named mapnik_xml.py inside the mapnik_experiments folder and type this code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">map = mapnik.Map(800, 600)</p>
<p class="calibre1">mapnik.load_map(map, 'map_style.xml')</p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, '../output/world2.png')</p>
<p class="calibre1">4.  Run this file. Remember that, to run a different file from the previous one, you need to press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and select it. </p>
<p class="calibre1">5.  Open the generated image (world2.png) that is inside the output folder; you should see exactly the same result as before. </p>
<p class="calibre1">Styling maps in Python and XML has almost the same features. Except for a few very specific situations, you can obtain exactly the same results using either of them. </p>
<p class="calibre1"><a id="p233"/>In those simple examples, there are two things to be noticed while using Python or XML: code readability and organization. Looking at the XML code, you should see that the map, styles, and rules have a tree-like organization; this is very clear here but in the pure Python definition this get confusing and can lead to mistakes. </p>
<p class="calibre1">This is a very simple map but, as you add more rules and symbolizers, things starts to get very confusing and hard to understand using pure Python. </p>
<p class="calibre1">Another important point is that it’s a good idea to separate the map creation logic from the style. We will see how that helps to keep your code very clean and reusable in the next topic. </p>
<p class="calibre1"><a id="p234"/>
<a id="p235"/><b class="calibre3">Creating utility functions to generate</b></p>
<p class="calibre1"><b class="calibre3">maps</b></p>
<p class="calibre1">Now we will create the first function that will compose our application. </p>
<p class="calibre1">1.  Still in the mapnik_experiments folder, create a new file: map_functions.py. </p>
<p class="calibre1">2.  Insert the code as follows into that file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">def create_map(style_file, output_image, size=(800, 600)):</p>
<p class="calibre1">"""Creates a map from a XML file and writes it to an image. </p>
<p class="calibre1">:param style_file: Mapnik XML file. </p>
<p class="calibre1">:param output_image: Name of the output image file. </p>
<p class="calibre1">:param size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">map = mapnik.Map(*size)</p>
<p class="calibre1">mapnik.load_map(map, style_file)</p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, output_image)</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">create_map('map_style.xml', '../output/world3.png', </p>
<p class="calibre1">size=(400, 400))</p>
<p class="calibre1">What we did here is pack the map generation code into a function that we can reuse in the future. It takes two required arguments: the XML style file and the name of the image file that Mapnik will write the results to. </p>
<p class="calibre1">The third optional parameter is the size of the map that will be created; you can pass a list or a tuple with the width and height of the map in pixels. This tuple or list is then unpacked with the * symbol into mapnik.Map arguments. </p>
<p class="calibre1">Finally, again we used the if __name__ == '__main__': technique to test the code. </p>
<p class="calibre1">Remember that everything that is inside this if block is run only if the file is called directly. On the other hand, if this file is imported as a module, this code will be ignored. </p>
<p class="calibre1">Look at the  <i class="calibre4">Creating the application entry point</i> section in <a href="index_split_000.html#p103">Chapter 2</a>,  <i class="calibre4">The Geocaching</i> <i class="calibre4">App</i>, if you need more information on that technique. </p>
<p class="calibre1"><a id="p236"/><b class="calibre3">Changing the data source at runtime</b></p>
<p class="calibre1">This is a useful function; now we can create maps from XML files with a single line of code. But there is a flaw: the data source (the shapefile that will be used) is hardcoded inside the XML. Suppose that we want to generate maps for a bunch of shapefiles; for every file we would need to change the XML, impeding the execution of batch operations. </p>
<p class="calibre1">Fortunately, there are two ways that we can change the data source file that Mapnik will use without manually changing the XML. We can make code to edit the XML for us, or we can mix XML and Python in the map definition. </p>
<p class="calibre1">Mapnik’s Map object has a couple of properties that can be accessed. At the moment, we are interested in accessing the layer, because the layer contains the data source that we want to define or change. </p>
<p class="calibre1">Every Map instance contains a layers property that returns a Layers object containing all the layers defined in the map. This object behaves like a list of Layer objects in which its items could be iterated or retrieved by an index. In turn, the Layer object contains the name and the data source properties. Let’s take a look how this works: <b class="calibre3">Note</b></p>
<p class="calibre1">Check the Mapnik API documentation at: <a href="http://mapnik.org/docs/v2.2.0/api/python/">http://mapnik.org/docs/v2.2.0/api/python/. </a></p>
<p class="calibre1">There you can find all the classes, methods, and properties that are available. </p>
<p class="calibre1">1.  Change your function so we can inspect the properties of the map object: def create_map(style_file, output_image, size=(800, 600)):</p>
<p class="calibre1">"""Creates a map from a XML file and writes it to an image. </p>
<p class="calibre1">:param style_file: Mapnik XML file. </p>
<p class="calibre1">:param output_image: Name of the output image file. </p>
<p class="calibre1">:param size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">map = mapnik.Map(*size)</p>
<p class="calibre1">mapnik.load_map(map, style_file)</p>
<p class="calibre1"><b class="calibre3">    layers = map.layers</b></p>
<p class="calibre1"><b class="calibre3">    layer = layers[0]</b></p>
<p class="calibre1"><b class="calibre3">    print(layer)</b></p>
<p class="calibre1"><b class="calibre3">    print(layer.name)</b></p>
<p class="calibre1"><b class="calibre3">    print(layer.datasource)</b></p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, output_image)</p>
<p class="calibre1">The highlighted code gets the layers object and the first layer in it (at index 0), then prints it, its name, and the data source properties. </p>
<p class="calibre1">2.  Just rerun the code and you should get this output:</p>
<p class="calibre1">&lt;mapnik._mapnik.Layer object at 0x01E579F0&gt; </p>
<p class="calibre1">world</p>
<p class="calibre1">&lt;mapnik.Datasource object at 0x01F3E9F0&gt; </p>
<p class="calibre1"><a id="p237"/>Process finished with exit code 0</p>
<p class="calibre1">As you see in the output, the first layer is the world layer defined in the XML and it has a data source. This data source is what we want to set or modify during code execution. </p>
<p class="calibre1">3.  Make another test. Open the map_style.xml file and remove the data source from the definition, like this:</p>
<p class="calibre1">&lt;Map background-color="white"&gt; </p>
<p class="calibre1">&lt;Style name="My Style"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" /&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Layer name="world"&gt; </p>
<p class="calibre1">&lt;StyleName&gt;My Style&lt;/StyleName&gt; </p>
<p class="calibre1">&lt;/Layer&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">4.  Run the code again and see the output:</p>
<p class="calibre1">&lt;mapnik._mapnik.Layer object at 0x01DD79F0&gt; </p>
<p class="calibre1">world</p>
<p class="calibre1">None</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Now, when we print the data source property, it shows None because we removed it from the definition; also the image (world3.png) is empty because there is no data to display. Now we are going to define it in the Python code. </p>
<p class="calibre1">5.  Edit the map_functions.py file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">def create_map(shapefile, style_file, output_image, size=(800, 600)):</p>
<p class="calibre1">"""Creates a map from a XML file and writes it to an image. </p>
<p class="calibre1">:param shapefile: Shapefile containing the data for the map. </p>
<p class="calibre1">:param style_file: Mapnik XML file. </p>
<p class="calibre1">:param output_image: Name of the output image file. </p>
<p class="calibre1">:param size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">map = mapnik.Map(*size)</p>
<p class="calibre1">mapnik.load_map(map, style_file)</p>
<p class="calibre1">data source = mapnik.Shapefile(file=shapefile)</p>
<p class="calibre1">layers = map.layers</p>
<p class="calibre1">layer = layers[0]</p>
<p class="calibre1"><a id="p238"/>    layer.datasource = data source</p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, output_image)</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">create_map('../../data/world_borders_simple.shp', </p>
<p class="calibre1">'map_style.xml', '../output/world3.png', </p>
<p class="calibre1">size=(400, 400))</p>
<p class="calibre1">The new required argument in the function is the name of the shapefile containing the data. In the code we create a Mapnik data source from this file, get the first layer, and set its data source to the one that was created. Run the code and look at the output, you should see the rendered world map. Besides setting the data source, it is possible to combine XML and Python to change the map definition any way you want. </p>
<p class="calibre1"><a id="p239"/><b class="calibre3">Automatically previewing the map</b></p>
<p class="calibre1">As we start to play with the map style, it could get a little boring to manually open the image every time we want to see the results. So we will write a function that will automatically open and display the image for us when we run the code. To do that we will use the <b class="calibre3">Open Computer Vision</b> (<b class="calibre3">OpenCV</b>) package. </p>
<p class="calibre1">1.  Import the package at the beginning of the map_functions.py file: import mapnik</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">2.  Create this new function before the create_map function: def display_map(image_file):</p>
<p class="calibre1">"""Opens and displays a map image file. </p>
<p class="calibre1">:param image_file: Path to the image. </p>
<p class="calibre1">""" </p>
<p class="calibre1">image = cv2.imread(image_file)</p>
<p class="calibre1">cv2.imshow('image', image)</p>
<p class="calibre1">cv2.waitKey(0)</p>
<p class="calibre1">cv2.destroyAllWindows()</p>
<p class="calibre1">3.  Now change our tests to call the function; to do that, edit the if __name__ ==</p>
<p class="calibre1">'__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">map_image = '../output/world3.png' </p>
<p class="calibre1">create_map('../../data/world_borders_simple.shp', </p>
<p class="calibre1">'map_style.xml',map_image, size=(400, 400))</p>
<p class="calibre1">display_map(map_image)</p>
<p class="calibre1">4.  Run the code. Now you should see a window pop up with the map image:</p>
<p class="calibre1"><a id="p240"/><img src="index-240_1.jpg" alt="Image 30" class="calibre2"/></p>
<p class="calibre1">We won’t explore OpenCV functionality in depth now; just note that cv2.waitKey(0) halts code execution until any key is pressed or the window is closed. </p>
<p class="calibre1"><a id="p241"/>
<a id="p242"/><b class="calibre3">Styling maps</b></p>
<p class="calibre1">Now that we have a function to generate the map and an easy way to preview them, we will experiment with the style options:</p>
<p class="calibre1">1.  First, lets produce a bigger map so we can better see the changes. Edit the if __name__ == '__main__': block at the end of the map_functions.py file, changing the size argument of the create_map function call:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">map_image = '../output/world3.png' </p>
<p class="calibre1">create_map('../../data/world_borders_simple.shp', </p>
<p class="calibre1">'map_style.xml',map_image, size=(1024, 500))</p>
<p class="calibre1">display_map(map_image)</p>
<p class="calibre1"><a id="p243"/><img src="index-243_1.jpg" alt="Image 31" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Map style</b></p>
<p class="calibre1">The map is the canvas for the drawing; it is possible to change the background color or the background image, the coordinate reference system, and a few other options. </p>
<p class="calibre1">Let’s try changing the background:</p>
<p class="calibre1">1.  In the file map_style.xml edit the map tag to change the background color. You can use a hexadecimal value, a color name, or an RGB combination. Try this as an example:</p>
<p class="calibre1">&lt;Map background-color="#f8be78"&gt; </p>
<p class="calibre1">2.  Run the code and see the changes. </p>
<p class="calibre1">3.  Now try using an image as the background for the map. I provided one as an example that will resemble old paper; change the map tag again:</p>
<p class="calibre1">&lt;Map background-color="#f8be78" </p>
<p class="calibre1">background-image="../../data/images/old-paper.png"&gt; 4.  Run the code, you should see this output:</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Note that background-image supersedes background-color in order of importance when the map is generated. </p>
<p class="calibre1"><a id="p244"/><img src="index-244_1.jpg" alt="Image 32" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Polygon style</b></p>
<p class="calibre1">In the XML tree that you have in your map_style.xml file, you should notice that, after the &lt;Map&gt; tag, you have the &lt;Style&gt; tag and then the &lt;Rule&gt; tag. We will explore them later; for now we will go directly to the symbolizers. </p>
<p class="calibre1">Each symbolizer is used to style a different type of geometry or part of the map. The first one that we used is the PolygonSymbolizer tag, which is used to style the internal area of the polygon with a solid color. </p>
<p class="calibre1">The polygon has also another possible symbolizer: the PolygonPatternSymbolizer tag, which fills the polygon with an image pattern. Let’s see how it works: 1.  Change the style again; let’s include a pattern symbolizer after the PolygonSymbolizer tag:</p>
<p class="calibre1">&lt;Map background-color="#f8be78" </p>
<p class="calibre1">background-image="../../data/images/old-paper.png"&gt; </p>
<p class="calibre1">&lt;Style name="My Style"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;PolygonPatternSymbolizer</p>
<p class="calibre1">file="../../data/images/tree_pattern.png"/&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" /&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Layer name="world"&gt; </p>
<p class="calibre1">&lt;StyleName&gt;My Style&lt;/StyleName&gt; </p>
<p class="calibre1">&lt;/Layer&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">2.  Run the code and see the results. </p>
<p class="calibre1"><a id="p245"/>The style follows the <b class="calibre3">painter model</b>. This means that things are  <i class="calibre4">painted</i> in the order that they are in the file, so the pattern was painted over the polygon fill. </p>
<p class="calibre1"><a id="p246"/><img src="index-246_1.jpg" alt="Image 33" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Line styles</b></p>
<p class="calibre1">The lines (including polygon boundaries) are styled by the LineSymbolizer tag and the LinePatternSymbolizer tag. For the next examples, we will return the map to its initial style and zoom it so we can see better how the options influence the generated map, as follows:</p>
<p class="calibre1">1.  Edit the style by removing the background image and the polygon pattern. Also, zoom in by changing maximum-extent:</p>
<p class="calibre1">&lt;Map background-color="white" maximum-extent="-21,68,66,28"&gt; </p>
<p class="calibre1">&lt;Style name="My Style"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="rgb(50%,50%,50%)" stroke-width="0.1" /&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Layer name="world"&gt; </p>
<p class="calibre1">&lt;StyleName&gt;My Style&lt;/StyleName&gt; </p>
<p class="calibre1">&lt;/Layer&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">2.  Now change the LineSymbolizer tag:</p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="3.0" /&gt; 3.  Run the code and see how the lines got thicker and red. </p>
<p class="calibre1">You may notice some strange edges and points because it’s a low-resolution map of the world and the lines are too thick. We can improve this map by reducing the thickness and by using the smooth parameter. </p>
<p class="calibre1">4.  Edit the LineSymbolizer tag again and run the code. Now you should have a much clearer map:</p>
<p class="calibre1"><a id="p247"/><img src="index-247_1.jpg" alt="Image 34" class="calibre2"/></p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" /&gt; </p>
<p class="calibre1"><a id="p248"/><img src="index-248_1.jpg" alt="Image 35" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Text styles</b></p>
<p class="calibre1">Now, let’s add the country names to our map. To do that, we will use the TextSymbolizer tag:</p>
<p class="calibre1">1.  Change the map_style.xml file with the following code:</p>
<p class="calibre1">&lt;Map background-color="white" maximum-extent="-21,68,66,28"&gt; </p>
<p class="calibre1">&lt;Style name="My Style"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" /&gt; </p>
<p class="calibre1">&lt;TextSymbolizer face-name="DejaVu Sans Book" size="10" </p>
<p class="calibre1">fill="black" halo-fill= "white" </p>
<p class="calibre1">halo-radius="1" placement="interior" </p>
<p class="calibre1">allow-overlap="false"&gt;[NAME]</p>
<p class="calibre1">&lt;/TextSymbolizer&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Layer name="world"&gt; </p>
<p class="calibre1">&lt;StyleName&gt;My Style&lt;/StyleName&gt; </p>
<p class="calibre1">&lt;/Layer&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">2.  Run the code and see the results:</p>
<p class="calibre1"><a id="p249"/><b class="calibre3">Adding layers to the map</b></p>
<p class="calibre1">We saw that it’s possible to change the data source of the map with Python. In a Mapnik map, the data source resides inside a layer or inside the map; to keep it simple we will use only layers to hold the data sources. </p>
<p class="calibre1">If we want to add more than one data source (for example, points, lines, polygons, or images) we need to add more layers. As an example, we will add the geocaching points, which we saw in the previous chapters, to the map. </p>
<p class="calibre1">The first step is to completely remove the layer definition from the XML file. This will complete the separation of the code into two categories: the XML contains only the styling and the Python code handles the data and map creation. </p>
<p class="calibre1">Secondly, we will change the create_map function so it adds layers to the map. This change will only be an experiment before we fully implement this functionality on the app:</p>
<p class="calibre1">1.  In the mapnik_xml.xml file, remove the layer from the definition, change the style name to style1, and add a new style for the points. Also change the extent of the map to focus on the points. It should be like this:</p>
<p class="calibre1">&lt;Map background-color="white" maximum-extent="-81,45,-69,40"&gt; </p>
<p class="calibre1">&lt;Style name="style1"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" /&gt; </p>
<p class="calibre1">&lt;TextSymbolizer face-name="DejaVu Sans Book" size="10" </p>
<p class="calibre1">fill="black" halo-fill= "white" </p>
<p class="calibre1">halo-radius="1" placement="interior" </p>
<p class="calibre1">allow-overlap="false"&gt;[NAME]</p>
<p class="calibre1">&lt;/TextSymbolizer&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Style name="style2"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PointSymbolizer/&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">2.  In the map_functions.py file, change your create_map function and the if __name__ == '__main__': block. The complete code should look like this:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">def display_map(image_file):</p>
<p class="calibre1">"""Opens and displays a map image file. </p>
<p class="calibre1">:param image_file: Path to the image. </p>
<p class="calibre1"><a id="p250"/>    """ </p>
<p class="calibre1">image = cv2.imread(image_file)</p>
<p class="calibre1">cv2.imshow('image', image)</p>
<p class="calibre1">cv2.waitKey(0)</p>
<p class="calibre1">cv2.destroyAllWindows()</p>
<p class="calibre1">def create_map(shapefile, gpx_file, style_file, output_image, size=(800, 600)):</p>
<p class="calibre1">"""Creates a map from a XML file and writes it to an image. </p>
<p class="calibre1">:param shapefile: Shapefile containing the data for the map. </p>
<p class="calibre1">:param style_file: Mapnik XML file. </p>
<p class="calibre1">:param output_image: Name of the output image file. </p>
<p class="calibre1">:param size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">map = mapnik.Map(*size)</p>
<p class="calibre1">mapnik.load_map(map, style_file)</p>
<p class="calibre1">layers = map.layers</p>
<p class="calibre1"># Add the shapefile. </p>
<p class="calibre1">world_datasource = mapnik.Shapefile(file=shapefile)</p>
<p class="calibre1">world_layer = mapnik.Layer('world')</p>
<p class="calibre1">world_layer.datasource = world_datasource</p>
<p class="calibre1">world_layer.styles.append('style1')</p>
<p class="calibre1">layers.append(world_layer)</p>
<p class="calibre1"># Add the shapefile. </p>
<p class="calibre1">points_datasource = mapnik.Ogr(file=gpx_file, layer='waypoints') points_layer = mapnik.Layer('geocaching_points')</p>
<p class="calibre1">points_layer.datasource = points_datasource</p>
<p class="calibre1">points_layer.styles.append('style2')</p>
<p class="calibre1">layers.append(points_layer)</p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, output_image)</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">map_image = '../output/world3.png' </p>
<p class="calibre1">create_map('../../data/world_borders_simple.shp', </p>
<p class="calibre1">'../../data/geocaching.gpx', </p>
<p class="calibre1">'map_style.xml',map_image, size=(1024, 500))</p>
<p class="calibre1">display_map(map_image)</p>
<p class="calibre1">Now the function accepts two files: one shapefile with the world borders and one GPX file containing waypoints. For each file, a data source and a layer containing it are created and added to the map list of layers. We also define the styles for the layer using the style names defined in the XML. </p>
<p class="calibre1">3.  Run the code; you should see the points rendered over the world borders with the default PointSymbolizer style:</p>
<p class="calibre1"><a id="p251"/><img src="index-251_1.jpg" alt="Image 36" class="calibre2"/></p>
<p class="calibre1"><a id="p252"/><b class="calibre3">Point styles</b></p>
<p class="calibre1">Now we are going to improve the visual representation of the points: 1.  Edit the map_style.xml file and change the point style:</p>
<p class="calibre1">&lt;Map background-color="white" maximum-extent="-81,45,-69,40"&gt; </p>
<p class="calibre1">&lt;Style name="style1"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" /&gt; </p>
<p class="calibre1">&lt;TextSymbolizer face-name="DejaVu Sans Book" size="10" </p>
<p class="calibre1">fill="black" halo-fill= "white" </p>
<p class="calibre1">halo-radius="1" placement="interior" </p>
<p class="calibre1">allow-overlap="false"&gt;[NAME]</p>
<p class="calibre1">&lt;/TextSymbolizer&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Style name="style2"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PointSymbolizer file="../../data/images/marker.svg" </p>
<p class="calibre1">transform="scale(0.3)"/&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">We introduce the use of a <b class="calibre3">Scalable Vector Graphics</b> (<b class="calibre3">SVG</b>) file to represent the point; the advantage of this kind of file is that it can be scaled or zoomed without distortions because it is composed of vectors and not pixels. </p>
<p class="calibre1">Since the SVG that we used is too big for our map, it was used with the transform parameter to scale the image. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">You can find more about SVG transformations at</p>
<p class="calibre1"><a href="http://www.w3.org/TR/SVG/coords.html">http://www.w3.org/TR/SVG/coords.html. </a></p>
<p class="calibre1">2.  Run your code and take a look at the results:</p>
<p class="calibre1"><a id="p253"/><img src="index-253_1.jpg" alt="Image 37" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">If you need symbols for your projects, you can find a good collection in the <b class="calibre3">Noun</b> <b class="calibre3">Project</b>, which aggregates creations from the community around the world at</p>
<p class="calibre1"><a href="https://thenounproject.com/">https://thenounproject.com/. </a></p>
<p class="calibre1">We have a beautiful representation of the points, and now we are going to add more information on them. </p>
<p class="calibre1"><a id="p254"/>
<a id="p255"/><b class="calibre3">Using Python objects as a source of data</b></p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">Mapnik for Windows does not come with the Python Datasource plugin and a workaround will be provided for Windows users; just follow the steps. </p>
<p class="calibre1">Data is represented internally on Mapnik by a Datasource object. This object is responsible for accessing the source of the data (for example, a file containing the data, a database, and so on) and transforming the features provided by this source of data into Feature objects. In turn, the Feature object contains a geometry and a number of properties (attributes). This organization is very similar to what we have seen in <a href="#p174">Chapter 4</a>, <i class="calibre4">Improving the App Search Capabilities</i>, in the topic  <i class="calibre4">How geographic data is represented</i>. </p>
<p class="calibre1">If we could hack into a Datasource and provide the features the way we want, we would be able to make Mapnik use Python objects that we provide as a source of data. </p>
<p class="calibre1">The advantage of using a Python object as a Datasource, instead of a file for example, is that we can perform any kind of transformation and analysis on the data and then feed it to Mapnik without needing to save it to disk. By doing that, we keep the data in memory, increase the performance of the application, and make it more versatile and easy-to-use. </p>
<p class="calibre1">Fortunately, Mapnik comes with a class already prepared for this kind of operation; as you may have guessed, it’s called PythonDatasource. </p>
<p class="calibre1">As we prepare to build our application, in this step we will produce a class that inherits from mapnik.PythonDatasource and implements the required methods for it to work. </p>
<p class="calibre1">First, we are going to take a look at Mapnik’s source code in order to understand the logic behind the PythonDatasource class. </p>
<p class="calibre1">1.  Go to your Chapter5 folder and create a file named my_datasource.py. </p>
<p class="calibre1">2.  Insert this code in that file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">test_datasource = mapnik.PythonDatasource()</p>
<p class="calibre1">3.  Now click anywhere on PythonDatasource to place your cursor on it and press  <i class="calibre4">Ctrl</i></p>
<p class="calibre1">+  <i class="calibre4">B</i>. Or, right-click anywhere on PythonDatasource then select <b class="calibre3">Go To</b> | <b class="calibre3">Declaration</b>. </p>
<p class="calibre1">This will open and show the class declaration for you. </p>
<p class="calibre1">4.  I will go through each part of the class, commenting the code. Don’t worry if you are not near a computer. I’ll place excerpts of the class before each explanation: class PythonDatasource(object):</p>
<p class="calibre1">"""A base class for a Python data source. </p>
<p class="calibre1">Optional arguments:</p>
<p class="calibre1">envelope—a mapnik.Box2d (minx, miny, maxx, maxy) envelope</p>
<p class="calibre1">of the data source, default (-180,-90,180,90)</p>
<p class="calibre1"><a id="p256"/>      geometry_type—one of the DataGeometryType enumeration values, default Point</p>
<p class="calibre1">data_type—one of the DataType enumerations, default Vector</p>
<p class="calibre1">""" </p>
<p class="calibre1">def __init__(self, envelope=None, geometry_type=None, </p>
<p class="calibre1">data_type=None):</p>
<p class="calibre1">self.envelope = envelope or Box2d(-180, -90, 180, 90)</p>
<p class="calibre1">self.geometry_type = geometry_type or DataGeometryType.Point self.data_type = data_type or DataType.Vector</p>
<p class="calibre1">This is the class declaration and the __init__ method; the arguments to create the class are all optional but if we need to we can define the envelope (that is, the bounding box) and two important parameters:</p>
<p class="calibre1">geometry_type: Can be Collection, LineString, Point, or Polygon data_type: Can be Vector or Raster</p>
<p class="calibre1">def features(self, query):</p>
<p class="calibre1">"""Return an iterable which yields instances of Feature for features within the passed query. </p>
<p class="calibre1">Required arguments:</p>
<p class="calibre1">query—a Query instance specifying the region for which</p>
<p class="calibre1">features should be returned</p>
<p class="calibre1">""" </p>
<p class="calibre1">return None</p>
<p class="calibre1">This is the key method for PythonDatasource to work. This method should return an <i class="calibre4">iterable</i> containing the features. </p>
<p class="calibre1">An iterable is any Python object that can be used in a for loop or, as described in the Python glossary, any object capable of returning its members one at a time. It can be a list, a tuple, a dictionary, and so on. </p>
<p class="calibre1">Despite the description in the docstring, this method is empty and returns None. It’s an indication that it should be implemented on the child classes and that how this iterable is created is entirely up to the programmer:</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Take a look at the Python glossary for information on new terms or terms that are still confusing for you: <a href="https://docs.python.org/2/glossary.html">https://docs.python.org/2/glossary.html. </a></p>
<p class="calibre1">def features_at_point(self, point):</p>
<p class="calibre1">"""Rarely uses. Return an iterable which yields instances of Feature for the specified point.""" </p>
<p class="calibre1">return None</p>
<p class="calibre1">This is more of a convenience method, so we won’t use it. </p>
<p class="calibre1">@classmethod</p>
<p class="calibre1">def wkb_features(cls, keys, features):</p>
<p class="calibre1">"""A convenience function to wrap an iterator yielding pairs</p>
<p class="calibre1"><a id="p257"/>        of WKB format geometry and dictionaries of key-value pairs into mapnik features. Return this from</p>
<p class="calibre1">PythonDatasource.features() passing it a sequence of keys</p>
<p class="calibre1">to appear in the output and an iterator yielding features. </p>
<p class="calibre1">For example. One might have a features() method in a derived class like the following:</p>
<p class="calibre1">def features(self, query):</p>
<p class="calibre1"># ... create WKB features feat1 and feat2</p>
<p class="calibre1">return mapnik.PythonDatasource.wkb_features(</p>
<p class="calibre1">keys = ( 'name', 'author' ), </p>
<p class="calibre1">features = [</p>
<p class="calibre1">(feat1, { 'name': 'feat1', 'author': 'alice' }), </p>
<p class="calibre1">(feat2, { 'name': 'feat2', 'author': 'bob' }), </p>
<p class="calibre1">]</p>
<p class="calibre1">)</p>
<p class="calibre1">""" </p>
<p class="calibre1">ctx = Context()</p>
<p class="calibre1">[ctx.push(x) for x in keys]</p>
<p class="calibre1">def make_it(feat, idx):</p>
<p class="calibre1">f = Feature(ctx, idx)</p>
<p class="calibre1">geom, attrs = feat</p>
<p class="calibre1">f.add_geometries_from_wkb(geom)</p>
<p class="calibre1">for k, v in attrs.iteritems():</p>
<p class="calibre1">f[k] = v</p>
<p class="calibre1">return f</p>
<p class="calibre1">return itertools.imap(make_it, features, itertools.count(1))</p>
<p class="calibre1">@classmethod</p>
<p class="calibre1">def wkt_features(cls, keys, features):</p>
<p class="calibre1">"""A convenience function to wrap an iterator yielding pairs of WKT format geometry and dictionaries of key-value pairs</p>
<p class="calibre1">into mapnik features. Return this from</p>
<p class="calibre1">PythonDatasource.features() passing it a sequence of keys</p>
<p class="calibre1">to appear in the output and an iterator yielding features. </p>
<p class="calibre1">For example. One might have a features() method in a</p>
<p class="calibre1">derived class like the following:</p>
<p class="calibre1">def features(self, query):</p>
<p class="calibre1"># ... create WKT features feat1 and feat2</p>
<p class="calibre1">return mapnik.PythonDatasource.wkt_features(</p>
<p class="calibre1">keys = ( 'name', 'author' ), </p>
<p class="calibre1">features = [</p>
<p class="calibre1">(feat1, { 'name': 'feat1', 'author': 'alice' }), </p>
<p class="calibre1">(feat2, { 'name': 'feat2', 'author': 'bob' }), </p>
<p class="calibre1">]</p>
<p class="calibre1">)</p>
<p class="calibre1">""" </p>
<p class="calibre1"><a id="p258"/>        ctx = Context()</p>
<p class="calibre1">[ctx.push(x) for x in keys]</p>
<p class="calibre1">def make_it(feat, idx):</p>
<p class="calibre1">f = Feature(ctx, idx)</p>
<p class="calibre1">geom, attrs = feat</p>
<p class="calibre1">f.add_geometries_from_wkt(geom)</p>
<p class="calibre1">for k, v in attrs.iteritems():</p>
<p class="calibre1">f[k] = v</p>
<p class="calibre1">return f</p>
<p class="calibre1">return itertools.imap(make_it, features, itertools.count(1)) These are two convenience functions (or methods). Take a look at the section  <i class="calibre4">Integrating</i> <i class="calibre4">with the app</i> in<a href="#p174"> Chapter 4, </a>  <i class="calibre4">Improving the App Search Capabilities</i>, if you don’t remember what a convenience method is. We created one there. </p>
<p class="calibre1">Those methods are an easy shortcut to creating an iterable of Mapnik features from a list of lists (or tuples) containing the geometries and the attributes in a dictionary, one from WKT geometries and one from WKB geometries (again, if you need, take a look at the section  <i class="calibre4">Knowing well-known text</i> in <a href="#p174">Chapter 4</a>,  <i class="calibre4">Improving the App Search Capabilities</i>). </p>
<p class="calibre1">One caveat is that these are not instance methods; they are class methods. Note the</p>
<p class="calibre1">@classmethod before the method name; this is a decorator that changes the method’s behavior. </p>
<p class="calibre1">I won’t go into details about class methods and decorators (it would require an entire chapter). All we need to know is that we call this method from the class and not from the instance, using PythonDatasource.wkt_features() or</p>
<p class="calibre1">PythonDatasource.wkb_features(). </p>
<p class="calibre1">Putting this into practice, what we need to do is create a class that inherits from PythonDatasource and reimplements its feature method. Let’s start from the class skeleton and then later we will go back to the classes that we built in <a href="index_split_000.html#p103">Chapter 2</a>,  <i class="calibre4">The</i> <i class="calibre4">Geocaching App</i>, <a href="index_split_000.html#p142"> Chapter 3, </a>  <i class="calibre4">Combining Multiple Data Sources</i>, and <a href="#p174">Chapter 4</a>,  <i class="calibre4">Improving</i> <i class="calibre4">the App Search Capabilities</i>, and use them as a source for the features: 1.  Edit my_datasource.py; remove the previous code and add the new class:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">class MapDatasource(mapnik.PythonDatasource):</p>
<p class="calibre1">"""Implementation of Mapinik's PythonDatasource.""" </p>
<p class="calibre1"/>
<p class="calibre1">def features(self, query=None):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">The first thing we did was to make the query an optional argument; we won’t remove it because there is a risk of breaking compatibility. Then the function only raises an exception to the effect that it’s not implemented yet. </p>
<p class="calibre1"><a id="p259"/>
<a id="p260"/><b class="calibre3">Exporting geo objects</b></p>
<p class="calibre1">Before we continue, as part of the workaround for windows users we will need to export our geo objects as files. </p>
<p class="calibre1">We will use the GeoJSON file format. It’s a good choice of format for exporting geographic data because:</p>
<p class="calibre1">It’s human-readable</p>
<p class="calibre1">It’s an open standard</p>
<p class="calibre1">It’s easy to make code that exports GeoJSON</p>
<p class="calibre1">Mapnik can import it</p>
<p class="calibre1">The properties/attributes can have multiple levels</p>
<p class="calibre1">Here you can see the same example of a GeoJSON file that we saw in<a href="index_split_000.html#p142"> Chapter 3, </a></p>
<p class="calibre1"> <i class="calibre4">Combining Multiple Data Sources – How Geographic Data is Represented</i>. You don’t need to type it, we are just going to use it as a reference to write our export code:</p>
<p class="calibre1">{"type": "FeatureCollection", </p>
<p class="calibre1">"features": [</p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Point", </p>
<p class="calibre1">"coordinates": [102.0, 0.5]}, </p>
<p class="calibre1">"properties": {"prop0": "value0"}</p>
<p class="calibre1">}, </p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "LineString", </p>
<p class="calibre1">"coordinates": [[102.0, 0.0], [103.0, 1.0], [104.0, 0.0]]</p>
<p class="calibre1">}, </p>
<p class="calibre1">"properties": {</p>
<p class="calibre1">"prop0": "value0", "prop1": 0.0</p>
<p class="calibre1">}</p>
<p class="calibre1">}, </p>
<p class="calibre1">{"type": "Feature", </p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Polygon", </p>
<p class="calibre1">"coordinates": [</p>
<p class="calibre1">[ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], </p>
<p class="calibre1">[100.0, 1.0], [100.0, 0.0] ]</p>
<p class="calibre1">]</p>
<p class="calibre1">}, </p>
<p class="calibre1">"properties": {"prop0": "value0", </p>
<p class="calibre1">"prop1": {"this": "that"}</p>
<p class="calibre1">}</p>
<p class="calibre1">}</p>
<p class="calibre1">]</p>
<p class="calibre1">}</p>
<p class="calibre1">Looking at the file, we can see that the geo objects that we created have characteristics that conveniently make it very easy to export them to this file format. If we think of a BaseGeoObject being a GeoJSON "Feature" and a BaseGeoCollection being a</p>
<p class="calibre1"><a id="p261"/>"FeatureCollection", it’s easy to get started: 1.  Open your models.py file and go to the BaseGeoObject class. Add the export_geojson_feature method:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def export_geojson_feature(self):</p>
<p class="calibre1">"""Exports this object as dictionary formatted as a GeoJSON feature. </p>
<p class="calibre1">""" </p>
<p class="calibre1">feature = {</p>
<p class="calibre1">"type": "Feature", </p>
<p class="calibre1">"geometry": mapping(self.geom), </p>
<p class="calibre1">"properties": self.attributes}</p>
<p class="calibre1">return feature</p>
<p class="calibre1">The mapping function calls a  <i class="calibre4">magic method</i> that every shapely geometry has; it returns the geometry as a GeoJSON representation. </p>
<p class="calibre1">2.  Now, edit the BaseGeoCollection class. Add the export_geojson method:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def export_geojson(self, file):</p>
<p class="calibre1">"""Exports the collection to a GeoJSON file.""" </p>
<p class="calibre1">features = [i.export_geojson_feature() for i in self.data]</p>
<p class="calibre1">geojson = {"type": "FeatureCollection", </p>
<p class="calibre1">"features": features}</p>
<p class="calibre1">with open(file, 'w') as out_file:</p>
<p class="calibre1">json.dump(geojson, out_file, indent=2)</p>
<p class="calibre1">print("File exported: {}".format(file))</p>
<p class="calibre1">Here we used a  <i class="calibre4">list comprehension</i> ([i.export_geojson_feature() for i in self.data]) to generate a list of features, then used the json module to serialize the dictionary into a JSON. </p>
<p class="calibre1">3.  Import the mapping function from shapely and add the json module to your imports at the beginning of the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from __future__ import print_function</p>
<p class="calibre1">import json</p>
<p class="calibre1">from shapely.geometry import Point, mapping</p>
<p class="calibre1">from shapely import wkb, wkt</p>
<p class="calibre1">import gdal</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">from utils.geo_functions import transform_geometry</p>
<p class="calibre1">from utils.geo_functions import convert_length_unit</p>
<p class="calibre1">4.  Finally, let’s test it. Edit your if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">gdal.PushErrorHandler('CPLQuietErrorHandler')</p>
<p class="calibre1">points = PointCollection("../data/geocaching.gpx") points.export_geojson("output/data.json")</p>
<p class="calibre1"><a id="p262"/>5.  Run the code and open the output/data.json file to check the results:</p>
<p class="calibre1">{</p>
<p class="calibre1">"type": "FeatureCollection", </p>
<p class="calibre1">"features": [</p>
<p class="calibre1">{</p>
<p class="calibre1">"geometry": {</p>
<p class="calibre1">"type": "Point", </p>
<p class="calibre1">"coordinates": [</p>
<p class="calibre1">-78.90175, </p>
<p class="calibre1">42.89648</p>
<p class="calibre1">]</p>
<p class="calibre1">}, </p>
<p class="calibre1">"type": "Feature", </p>
<p class="calibre1">"properties": {</p>
<p class="calibre1">"status": "Available", </p>
<p class="calibre1">"logs": {</p>
<p class="calibre1">"log": [</p>
<p class="calibre1">{</p>
<p class="calibre1">"@id": "1", </p>
<p class="calibre1">"time": "05/09/2015T11:04:05", </p>
<p class="calibre1">"geocacher": "SYSTEM", </p>
<p class="calibre1">"text": "Attributes: Quick Cache | Kid Friendly |\n                        </p>
<p class="calibre1">}, </p>
<p class="calibre1">... </p>
<p class="calibre1">Everything was neatly exported, including all the properties and logs. PyCharm can also inspect JSON files, so you can use the Structure panel ( <i class="calibre4">Alt</i> +  <i class="calibre4">7</i>) to explore the file structure as you did with the GPX file. </p>
<p class="calibre1"><a id="p263"/>
<a id="p264"/><b class="calibre3">Creating the Map Maker app</b></p>
<p class="calibre1">Now we will prepare an environment that is capable of using this data source. We are going to adapt the previous experiments into building blocks for the application and put them inside an application class, just as we did with the Geocaching app. </p>
<p class="calibre1">First let’s organize the folder and files. </p>
<p class="calibre1">1.  Create a new package called map_maker inside your Chapter5 folder. To do this, right-click on the folder and chose <b class="calibre3">New</b> | <b class="calibre3">Python Package</b>. </p>
<p class="calibre1">2.  Move the my_datasource.py file to the map_make folder (drag and drop it). </p>
<p class="calibre1">3.  Copy the map_style.xml and map_functions.py files that are inside the mapnik_experiments folder to the map_maker folder. </p>
<p class="calibre1">4.  Rename map_style.xml to styles.xml. </p>
<p class="calibre1">5.  In the Chapter5 root, create a file named map_maker_app.py. The complete tree structure should look like this:</p>
<p class="calibre1">Chapter5</p>
<p class="calibre1">│   geocaching_app.py</p>
<p class="calibre1">|   map_maker_app.py</p>
<p class="calibre1">│   models.py</p>
<p class="calibre1">│</p>
<p class="calibre1">├───mapnik_experiments</p>
<p class="calibre1">│</p>
<p class="calibre1">├───map_maker</p>
<p class="calibre1">│       __init__.py</p>
<p class="calibre1">│      my_datasource.py</p>
<p class="calibre1">|       styles.xml</p>
<p class="calibre1">|       map_functions.py</p>
<p class="calibre1">│</p>
<p class="calibre1">├───utils</p>
<p class="calibre1">Now we create the class that represents the application. </p>
<p class="calibre1">6.  In the map_maker_app.py file, create this new class and its __init__ method:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">class MapMakerApp(object):</p>
<p class="calibre1">def __init__(self, output_image=None):</p>
<p class="calibre1">"""Application class.""" </p>
<p class="calibre1">self.output_image = output_image</p>
<p class="calibre1">output_image will be the image that the app will write to the maps. It’s not private because we may want to change it during the application execution. </p>
<p class="calibre1">7.  Copy the display_map function from the map_functions.py file, and adapt it to work as a method of our new class:</p>
<p class="calibre1">class MapMakerApp(object):</p>
<p class="calibre1"><a id="p265"/>    def __init__(self, output_image=None):</p>
<p class="calibre1">"""Application class.""" </p>
<p class="calibre1">self.output_image = output_image</p>
</body></html>