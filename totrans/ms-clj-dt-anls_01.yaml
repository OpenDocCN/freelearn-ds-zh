- en: Chapter 1. Network Analysis – The Six Degrees of Kevin Bacon
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 网络分析 – 凯文·贝肯的六度分隔
- en: With the popularity of **Facebook**, **Twitter**, **LinkedIn**, and other social
    networks, we're increasingly defined by who we know and who's in our **network**.
    These websites help us manage who we know—whether personally, professionally,
    or in some other way—and our interactions with those groups and individuals. In
    exchange, we tell these sites who we are in the network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着**Facebook**、**Twitter**、**LinkedIn**和其他社交网络的普及，我们越来越多地被我们所认识的人和我们的**网络**中的成员所定义。这些网站帮助我们管理我们所认识的人——无论是个人、职业还是其他方式——以及我们与这些群体和个人的互动。作为交换，我们告诉这些网站我们在网络中的身份。
- en: These companies, and many others, spend a lot of time on and pay attention to
    our social networks. What do they say about us, and how can we sell things to
    these groups?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公司，以及许多其他公司，都在花大量时间和精力关注我们的社交网络。它们对我们说了些什么，我们如何向这些群体销售产品？
- en: 'In this chapter, we''ll walk through learning about and analyzing social networks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何了解和分析社交网络：
- en: Analyzing social networks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析社交网络
- en: Getting the data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据
- en: Understanding graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图
- en: Implementing the graphs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现图
- en: Measuring social network graphs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量社交网络图
- en: Visualizing social network graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化社交网络图
- en: Analyzing social networks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析社交网络
- en: Although the Internet and popular games such as *Six Degrees of Kevin Bacon*
    have popularized the concept, social network analysis has been around for a long
    time. It has deep roots in sociology. Although the sociologist John A. Barnes
    may have been the first person to use the term in 1954 in the article *Class and
    communities in a Norwegian island parish* ([http://garfield.library.upenn.edu/classics1987/A1987H444300001.pdf](http://garfield.library.upenn.edu/classics1987/A1987H444300001.pdf)),
    he was building on a tradition from the 1930s, and before that, he was looking
    at social groups and interactions relationally. Researchers contended that the
    phenomenon arose from social interactions and not individuals.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然互联网和像《凯文·贝肯的六度分隔》这样的流行游戏普及了这个概念，但社交网络分析已经存在很长时间了。它在社会学中有着深厚的根源。尽管社会学家约翰·A·巴恩斯可能在1954年的文章《挪威岛屿教区的阶级和社区》中首次使用这个术语（[http://garfield.library.upenn.edu/classics1987/A1987H444300001.pdf](http://garfield.library.upenn.edu/classics1987/A1987H444300001.pdf)），但他是在建立在20世纪30年代的传统之上，在此之前，他正在研究社会群体和相互关系。研究人员认为，这种现象源于社会互动，而不是个人。
- en: Slightly more recently, starting in the 1960s, Stanley Milgram has been working
    on a small world experiment. He would mail a letter to a volunteer somewhere in
    the mid-western United States and ask him or her to get it to a target individual
    in Boston. If the volunteer knew the target on a first-name basis, he or she could
    mail it to him. Otherwise, they would need to pass it to someone they knew who
    might know the target. At each step, the participants were to mail a postcard
    to Milgram so that he could track the progress of the letter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 稍早一些，从20世纪60年代开始，斯坦利·米尔格拉姆一直在进行一个小世界实验。他会给美国中西部的某个志愿者寄一封信，并要求他或她将信送到波士顿的目标个人手中。如果志愿者认识目标人物，可以直接寄给他。否则，他们需要将它转交给可能认识目标的人。在每一步，参与者都要给米尔格拉姆寄一张明信片，以便他追踪信件的进展。
- en: This experiment (and other experiments based on it) has been criticized. For
    one thing, the participants may decide to just throw the letter away and miss
    huge swathes of the network. However, the results are evocative. Milgram found
    that the few letters that made it to the target, did so with an average of six
    steps. Similar results have been born out by later, similar experiments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验（以及基于它的其他实验）受到了批评。一方面，参与者可能会决定直接扔掉信件，从而错过网络的大部分。然而，结果引人深思。米尔格拉姆发现，少数到达目标信件的平均步骤数为六步。后来的类似实验也产生了类似的结果。
- en: Milgram himself did not use the popular phrase *six degrees of separation*.
    This was probably taken from John Guare's play and film *Six Degrees of Separation*
    (1990 and 1993). He said he got the concept from Guglielmo Marconi, who discussed
    it in his 1909 Nobel Prize address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 米尔格拉姆本人并没有使用流行的短语“六度分隔”。这可能是从约翰·瓜雷的戏剧和电影《六度分隔》（1990年和1993年）中借用的。他说他从古列尔莫·马可尼那里得到了这个概念，马可尼在1909年的诺贝尔奖演讲中讨论了它。
- en: The phrase "six degrees" is synonymous with social networks in the popular imagination,
    and a large part of this is due to the pop culture game *Six Degrees of Kevin
    Bacon*. In this game, people would try to find a link between Kevin Bacon and
    some other actor by tracing the films in which they've worked together.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在流行想象中，“六度”这个短语与社会网络同义，这很大程度上归因于流行文化游戏《六度分隔凯文·贝肯》。在这个游戏中，人们会通过追踪他们共同出演的电影来尝试找到凯文·贝肯与其他演员之间的联系。
- en: In this chapter, we'll take a look at this game more critically. We'll use it
    to explore a network of Facebook ([https://www.facebook.com/](https://www.facebook.com/))
    users. We'll visualize this network and look at some of its characteristics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更批判性地审视这个游戏。我们将用它来探索Facebook（[https://www.facebook.com/](https://www.facebook.com/)）用户网络。我们将可视化这个网络并查看其一些特征。
- en: Specifically, we're going to look at a network that has been gathered from Facebook.
    We'll find data for Facebook users and their friends, and we'll use that data
    to construct a social network graph. We'll analyze that information to see whether
    the observation about the six degrees of separation applies to this network. More
    broadly, we'll see what we can learn about the relationships represented in the
    network and consider some possible directions for future research.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究一个从Facebook收集的网络。我们将找到Facebook用户及其朋友的数据，并使用这些数据构建一个社交网络图。我们将分析这些信息，以查看关于六度分隔的观察是否适用于这个网络。更广泛地说，我们将了解我们可以从网络中表示的关系中学到什么，并考虑一些未来研究的可能方向。
- en: Getting the data
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: A couple of small datasets of the Facebook network data are available on the
    Internet. None of them are particularly large or complete, but they do give us
    a reasonable snapshot of part of Facebook's network. As the Facebook graph is
    a private data source, this partial view is probably the best that we can hope
    for.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上可以找到一些Facebook网络数据的小型数据集。它们都不特别大或完整，但它们确实为我们提供了一个合理的Facebook网络部分的快照。由于Facebook图是一个私有数据源，这个部分视图可能就是我们所能期望的最好的了。
- en: We'll get the data from the **Stanford Large Network Dataset Collection** ([http://snap.stanford.edu/data/](http://snap.stanford.edu/data/)).
    This contains a number of network datasets, from Facebook and Twitter, to road
    networks and citation networks. To do this, we'll download the `facebook.tar.gz`
    file from [http://snap.stanford.edu/data/egonets-Facebook.html](http://snap.stanford.edu/data/egonets-Facebook.html).
    Once it's on your computer, you can extract it. When I put it into the folder
    with my source code, it created a directory named `facebook`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**斯坦福大型网络数据集收集**（[http://snap.stanford.edu/data/](http://snap.stanford.edu/data/））获取数据。这包含了许多网络数据集，从Facebook和Twitter到道路网络和引用网络。为此，我们将从[http://snap.stanford.edu/data/egonets-Facebook.html](http://snap.stanford.edu/data/egonets-Facebook.html)下载`facebook.tar.gz`文件。一旦它在您的计算机上，您就可以提取它。当我将它放入包含我的源代码的文件夹中时，它创建了一个名为`facebook`的目录。
- en: 'The directory contains 10 sets of files. Each group is based on one primary
    vertex (user), and each contains five files. For vertex `0`, these files would
    be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目录包含10组文件。每组基于一个主要顶点（用户），每组包含5个文件。对于顶点`0`，这些文件如下：
- en: '`0.edges`: This contains the vertices that the primary one links to.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.edges`：这包含主要顶点链接到的顶点。'
- en: '`0.circles`: This contains the groupings that the user has created for his
    or her friends.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.circles`：这包含用户为其朋友创建的分组。'
- en: '`0.feat`: This contains the features of the vertices that the user is adjacent
    to and ones that are listed in `0.edges`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.feat`：这包含用户相邻的顶点的特征以及列在`0.edges`中的顶点。'
- en: '`0.egofeat`: This contains the primary user''s features.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.egofeat`：这包含主要用户的特征。'
- en: '`0.featnames`: This contains the names of the features described in `0.feat`
    and `0.egofeat`. For Facebook, these values have been anonymized.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.featnames`：这包含在`0.feat`和`0.egofeat`中描述的特征的名称。对于Facebook，这些值已经被匿名化。'
- en: For these purposes, we'll just use the `*.edges` files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这些目的，我们只需使用`*.edges`文件。
- en: Now let's turn our attention to the data in the files and what they represent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向文件中的数据以及它们所代表的内容。
- en: Understanding graphs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图
- en: Graphs are the Swiss army knife of computer science data structures. Theoretically,
    any other data structure can be represented as a graph, although usually, it won't
    perform as well.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图是计算机科学数据结构中的瑞士军刀。从理论上讲，任何其他数据结构都可以表示为图，尽管通常它的性能不会很好。
- en: For example, binary trees can be seen as a graph in which each node has two
    outgoing edges at most. These edges link it to the node's children. Or, an array
    can be seen as a graph in which each item in the array has edges that link it
    to the items adjacent to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，二叉树可以看作是一个图，其中每个节点最多有两个出边。这些边将其与其子节点连接起来。或者，数组可以看作是一个图，其中数组中的每个项目都有边将其与其相邻的项目连接起来。
- en: However, in this case, the data that we're working with is naturally represented
    by a graph. The people in the network are the nodes, and their relationships are
    the edges.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，我们正在处理的数据自然地可以用图来表示。网络中的人是节点，它们之间的关系是边。
- en: Graphs come in several flavors, but they all have some things in common. First,
    they are a series of nodes that are connected by edges. Edges can be unidirectional,
    in which case, the relationship they represent goes only one way (for example,
    followers on Twitter), or it goes bidirectional, in which the relationship is
    two-way (for example, friends on Facebook).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图有多种类型，但它们都有一些共同点。首先，它们是一系列通过边连接的节点。边可以是单向的，在这种情况下，它们所代表的关系只有一个方向（例如，Twitter上的关注者），或者它是双向的，在这种情况下，关系是双向的（例如，Facebook上的朋友）。
- en: Graphs generally don't have any hierarchy or structure like trees or lists do.
    However, the data they represent may have a structure. For example, Twitter has
    a number of users (vertices) who have a lot of followers (inbound edges). However,
    most users only have a few followers. This dichotomy creates a structure to the
    graph, where a lot of data flows through a few vertices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图通常没有像树或列表那样的层次结构或结构。然而，它们所表示的数据可能具有结构。例如，Twitter有许多用户（顶点）拥有大量的关注者（入边）。然而，大多数用户只有少数关注者。这种二分法为图创建了一种结构，其中大量数据通过少数顶点流动。
- en: Graphs' data structures typically support a number of operations, including
    adding edges, removing edges, and traversing the graph. We'll implement a graph
    data structure later. At that point, we'll also look at these operations. This
    may not be the best performing graph, especially for very large datasets, but
    it should help make clear what graphs are all about.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图的数据结构通常支持许多操作，包括添加边、删除边和遍历图。我们将在稍后实现图数据结构。到那时，我们也将查看这些操作。这可能不是性能最好的图，特别是对于非常大的数据集，但它应该有助于清楚地了解图是什么。
- en: Implementing the graphs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现图
- en: As the graph data structure is so central to this chapter, we'll take a look
    at it in more detail before we move on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图数据结构在本章中非常重要，我们在继续之前将更详细地研究它。
- en: There are a number of ways to implement graphs. In this case, we'll use a variation
    of an **adjacency list**, which maps each node to a list of its neighbors. We'll
    store the nodes in a hash map and keep separate hash maps for each node's data.
    This representation is especially good for sparse graphs, because we only need
    to store existing links. If the graph is very dense, then representing the set
    of neighboring nodes as a matrix instead of a hash table will take less memory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现图有多种方法。在这种情况下，我们将使用**邻接表**的一种变体，它将每个节点映射到其邻居的列表。我们将节点存储在哈希表中，并为每个节点的数据保留单独的哈希表。这种表示对于稀疏图特别有效，因为我们只需要存储现有的链接。如果图非常密集，那么将相邻节点的集合表示为矩阵而不是哈希表将占用更少的内存。
- en: 'However, before we start looking at the code, let''s check out the **Leiningen
    2** `project.clj` file. Apart from the **Clojure** library, this makes use of
    the Clojure JSON library, the `me.raynes` file utility library ([https://github.com/Raynes/fs](https://github.com/Raynes/fs)),
    and the **Simple Logging Facade for Java** library ([http://www.slf4j.org/](http://www.slf4j.org/)):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始查看代码之前，让我们先看看**Leiningen 2**的`project.clj`文件。除了**Clojure**库之外，它还使用了Clojure
    JSON库、`me.raynes`文件实用库（[https://github.com/Raynes/fs](https://github.com/Raynes/fs)）和**Java简单日志门面**库（[http://www.slf4j.org/](http://www.slf4j.org/)）：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you're keeping track, there are several sections related to **ClojureScript**
    ([https://github.com/clojure/clojurescript](https://github.com/clojure/clojurescript))
    as well. We'll talk about them later in the chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟踪，还有一些与**ClojureScript**（[https://github.com/clojure/clojurescript](https://github.com/clojure/clojurescript)）相关的部分。我们将在本章后面讨论它们。
- en: 'For the first file that we''ll work in, open up `src/network_six/graph.clj`.
    Use this for the namespace declaration:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们将要工作的第一个文件，打开`src/network_six/graph.clj`。使用以下内容作为命名空间声明：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this namespace, we''ll create a `Graph` record that contains two slots.
    One is for the map between vertex numbers and sets of neighbors. The second is
    for the data maps. We''ll define an empty graph that we can use anywhere, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命名空间中，我们将创建一个包含两个槽位的`Graph`记录。一个是顶点编号与邻居集合之间的映射。第二个是数据映射。我们将定义一个空图，我们可以在任何地方使用它，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The primary operations that we''ll use for this chapter are functions that
    modify the graph by adding or removing edges or by merging two graphs. The `add`
    and `delete` operations both take an optional flag to treat the edge as bidirectional.
    In that case, both functions just call themselves with the ends of the edges swapped
    so that they operate on the edge that goes in the other direction:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用的主要操作是修改图的函数，通过添加或删除边或合并两个图。`add`和`delete`操作都接受一个可选标志来将边视为双向的。在这种情况下，这两个函数只是交换边的端点并调用自己，以便在另一方向的边上进行操作：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The final low-level functions to work with graphs are two functions that are
    used to set or retrieve data associated with the vertices. Sometimes, it's also
    useful to be able to store data of the edges, but we won't use that for this implementation.
    However, we will associate some information with the vertices themselves later
    on, and when we do that, we'll use these functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与图相关的最终低级函数有两个，用于设置或检索与顶点关联的数据。有时，存储与边关联的数据也是有用的，但在这个实现中我们不会使用它。然而，稍后我们将与顶点本身关联一些信息，并在那时使用这些函数。
- en: 'All of these functions are overloaded. Passed in a graph, a vertex number,
    and a key, they set or retrieve a value on a hash map that is that vertex''s value.
    Passed in just a graph and a vertex number, they set or retrieve the vertex''s
    value—either the hash map or another value that is there in its place:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是重载的。传入一个图、一个顶点编号和一个键，它们在哈希映射中设置或检索该顶点的值。传入仅图和顶点编号，它们设置或检索顶点的值——要么是哈希映射，要么是那里存在的另一个值：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also want to get the vertices and the edges for the graph. The vertices
    are the union of the set of all the nodes with outbound edges and the set of nodes
    with inbound edges. There should be some, or even a lot, of overlap between these
    two groups. If the graph is bidirectional, then `get-edges` will return each edge
    twice—one going from a to b and the other going from b to a:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望获取图中的顶点和边。顶点是所有具有出边节点的集合与具有入边节点的集合的并集。这两个组之间应该有一些，甚至很多重叠。如果图是双向的，那么`get-edges`将返回每条边两次——一条从a到b，另一条从b到a：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll write some more basic utilities later, but right now, let''s take a
    look at a function that is a slightly higher-level function, but still a fundamental
    operation on graphs: a **breadth-first walk** over the graph and a search based
    on that.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会编写一些更基本的实用工具，但现在，让我们看看一个稍微高级一点但仍然是图的基本操作的函数：对图进行**广度优先遍历**和基于此的搜索。
- en: A breadth-first walk traverses the graph by first looking at all the neighbors
    of the current node. It then looks at the neighbors of those nodes. It continues
    broadening the search one layer at a time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历首先查看当前节点的所有邻居。然后，它查看这些节点的邻居。它继续逐层扩展搜索。
- en: This is in opposition to a **depth-first walk**, which goes deep down one path
    until there are no outgoing edges to be tried. Then, it backs out to look down
    other paths.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这与**深度优先遍历**相反，后者沿着一条路径深入到底，直到没有可尝试的出边。然后，它退回到其他路径。
- en: Which walk is more efficient really depends on the nature of the individual
    graph and what is being searched for. However, in our case, we're using a breadth-first
    walk because it ensures that the shortest path between the two nodes will be found
    first. A depth-first search can't guarantee that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种遍历方式更有效实际上取决于单个图的本质以及搜索的内容。然而，在我们的情况下，我们使用广度优先遍历，因为它确保首先找到两个节点之间的最短路径。深度优先搜索不能保证这一点。
- en: The backbone of the `breadth-first` function is a **First In, First Out** (**FIFO**)
    queue. To keep track of the vertices in the paths that we're trying, we use a
    vector with the index of those vertices. The queue holds all of the active paths.
    We also keep a set of vertices that we've reached before. This prevents us from
    getting caught in loops.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`breadth-first`函数的核心是一个**先进先出**（**FIFO**）队列。为了跟踪我们正在尝试的路径中的顶点，我们使用一个包含这些顶点索引的向量。队列持有所有活动路径。我们还保持一个集合，其中包含我们之前到达的顶点。这防止我们陷入循环。'
- en: We wrap everything in a lazy sequence so that the caller can control how much
    work is done and what happens to it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有内容包装在一个懒序列中，以便调用者可以控制要完成的工作以及它会发生什么。
- en: 'At each step in the loop, the algorithm is pretty standard:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每一步中，算法相当标准：
- en: If the queue is empty, then we've exhausted the part of the graph that's accessible
    from the start node. We're done, and we return null to indicate that we didn't
    find the node.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果队列为空，那么我们已经耗尽了从起始节点可访问的图的部分。我们完成了，我们返回null来表示我们没有找到节点。
- en: Otherwise, we pop a path vector off the queue. The current vertex is the last
    one.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们从队列中弹出一个路径向量。当前顶点是最后一个。
- en: We get the current vertex's neighbors.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取当前顶点的邻居。
- en: We remove any vertices that we've already considered.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们移除任何已经考虑过的顶点。
- en: 'For each neighbor, we append it to the current path vector, creating that many
    new path vectors. For example, if the current path vector is `[0, 171, 4]` and
    the new neighbors are `7`, `42` and `532`, then we''ll create three new vectors:
    `[0, 171, 4, 7]`, `[0, 171, 4, 42]`, and `[0, 171, 4, 532]`.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个邻居，我们将它追加到当前路径向量中，创建那么多新的路径向量。例如，如果当前路径向量是`[0, 171, 4]`，而新的邻居是`7`、`42`和`532`，那么我们将创建三个新的向量：`[0,
    171, 4, 7]`、`[0, 171, 4, 42]`和`[0, 171, 4, 532]`。
- en: We push each of the new path vectors onto the queue.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个新的路径向量推入队列。
- en: We add each of the neighbors onto the list of vertices that we've seen.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个邻居添加到我们已看到的顶点列表中。
- en: We output the current path to the lazy sequence.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将当前路径输出到懒序列中。
- en: Finally, we loop back to step one for the rest of the output sequence.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们回到第一步，继续输出序列的其余部分。
- en: 'The following code is the implementation of this. Most of it takes place in
    `bf-seq`, which sets up the processing in the first clause (two parameters) and
    constructs the sequence in the second clause (three parameters). The other function,
    `breadth-first`, is the public interface to the function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是这个实现的实现。大部分都在`bf-seq`中完成，它设置了第一个子句中的处理（两个参数）并在第二个子句中构建序列（三个参数）。另一个函数`breadth-first`是该函数的公共接口：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that what makes this a breadth-first search is that we use a FIFO queue.
    If we used a **LIFO** (**Last In, First Out**) queue (a Clojure list works well
    for this), then this would be a depth-first search. Instead of going broadly and
    simultaneously trying a number of paths, it would dive deep into the graph along
    one path and not backtrack to try a new one until it had exhausted the first path.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使这成为一个广度优先搜索的是我们使用了一个先进先出队列。如果我们使用一个后进先出队列（Clojure列表对此很适用），那么这将是一个深度优先搜索。它不会广泛地同时尝试多条路径，而是沿着一条路径深入图，直到耗尽第一条路径，然后才回溯尝试新的路径。
- en: 'This is a flexible base on which one can build a number of functionalities.
    For example, a breadth-first search is now a two-line function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个灵活的基础，可以在此基础上构建许多功能。例如，广度优先搜索现在是一个两行函数：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are just filters that find all paths that start from a and end at b and
    then return the first of those.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是过滤器，它们找到所有从a开始到b结束的路径，然后返回这些路径中的第一个。
- en: Loading the data
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载数据
- en: Now that we have the fundamental data structure that we're going to use, we
    can read the data files that we downloaded into a graph.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将要使用的基本数据结构，我们可以将下载的数据文件读入一个图中。
- en: 'For the purposes of analyzing the network itself, we''re only interested in
    the `*.edges` files. This lists the edges in the graph, one edge per line. Each
    edge is defined by the node numbers that it connects. As Facebook relationships
    are two-way, the edges represented here are bidirectional. For example, the first
    few lines of `0.edges` are shown as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析网络本身的目的，我们只对`*.edges`文件感兴趣。它列出了图中的边，每行一个边。每条边由它连接的节点编号定义。由于Facebook关系是双向的，这里表示的边是双向的。例如，`0.edges`的前几行如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll first define a function that reads one edge file into a `Graph`, and
    then we''ll define another function that walks a directory, reads each edge file,
    and merges the graphs into one. I''m keeping these in a new namespace, `network-six.ego`.
    This is defined in the `src/network_six/ego.clj` file. It uses the following namespace
    declaration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，该函数将一个边文件读入一个`Graph`，然后我们定义另一个函数，该函数遍历目录，读取每个边文件，并将图合并为一个。我将这些放在一个新的命名空间`network-six.ego`中。这定义在`src/network_six/ego.clj`文件中。它使用以下命名空间声明：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we''ll define the function that reads the `*.edges` files from a data directory:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义一个函数，该函数从数据目录中读取`*.edges`文件：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use these from **read-eval-print loop** (**REPL**) to load the data
    into a graph that we can work with. We can get some basic information about the
    data at this point, and the following how we''ll go about doing that:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些从**read-eval-print loop**（REPL）中加载数据到我们可以工作的图中。此时我们可以获取一些关于数据的基本信息，以下是如何进行这一操作的步骤：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now let's dive deeper into the graph and get some other metrics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地研究图，并获取一些其他指标。
- en: Measuring social network graphs
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量社交网络图
- en: There are a variety of metrics that we can use to describe graph data structures
    in particular and social network graphs in general. We'll look at a few of them
    and think about both, what they can teach us, and how we can implement them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用各种指标来描述特定的图数据结构以及一般的社交网络图。我们将查看其中的一些，并思考它们能教给我们什么，以及我们如何实现它们。
- en: Density
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密度
- en: Recall that a network's density is the number of actual edges versus the number
    of possible edges. A completely dense network is one that has an edge between
    each vertex and every other vertex. For example, in the following figure, the
    graph on the upper-right section is completely dense. The graph in the lower-left
    section has a density factor of 0.5333.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，网络的密度是实际边数与可能边数之比。一个完全密集的网络是每个顶点之间都存在边的网络。例如，在以下图中，右上角的图是完全密集的。左下角的图的密度因子为0.5333。
- en: '![Density](img/4139OS_01_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![密度](img/4139OS_01_01.jpg)'
- en: 'The number of possible edges is given as `N(N-1)`. We''ll define the density
    formula as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的边数给出为`N(N-1)`。我们将密度公式定义为以下：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use this to get some information about the number of edges in the graph:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来获取关于图中边数的一些信息：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at this, it appears that this graph is not very dense. Maybe some other
    metrics will help explain why.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个图，它看起来并不是很密集。也许其他一些指标能帮助我们解释原因。
- en: Degrees
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 度
- en: 'A vertex''s degree is the number of other vertexes connected to it, and another
    summary statistic for social networks is the average degree. This is computed
    by the formula *2E/N*. The Clojure to implement this is straightforward:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点的度是连接到它的其他顶点的数量，而对于社交网络来说，平均度也是一个总结统计量。这是通过公式*2E/N*计算的。Clojure实现这一点的代码非常直接：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, it is easy to use it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用它也很容易：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, the typical number of edges is around 85\. Given that there are almost 4,000
    vertices, it is understandable why the density is so low (0.022).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，典型的边数大约是85。考虑到有近4,000个顶点，密度如此低（0.022）是可以理解的。
- en: Paths
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径
- en: We can get a number of interesting metrics based on all of the paths between
    two elements. For example, we'll need those paths to get the centrality of nodes
    later in this chapter. The average path length is also an important metric. To
    calculate any of these, we'll need to compute all of the paths between any two
    vertices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据两个元素之间的所有路径得到一些有趣的指标。例如，我们需要这些路径来获取本章后面节点的重要性。平均路径长度也是一个重要的指标。为了计算这些指标中的任何一个，我们需要计算任何两个顶点之间的所有路径。
- en: For weighted graphs that have a weight or cost assigned to each edge, there
    are a number of algorithms to find the shortest path. **Dijkstra's algorithm**
    and **Johnson's algorithm** are two common ones that perform well in a range of
    circumstances.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个边都分配了权重或成本的加权图，有许多算法可以找到最短路径。**Dijkstra算法**和**Johnson算法**是两种在多种情况下表现良好的常见算法。
- en: However, for non-weighted graphs, any of these search algorithms evolve into
    a breadth-first search. We just implemented this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于无权图，这些搜索算法中的任何一个都会演变成广度优先搜索。我们刚刚实现了这一点。
- en: 'We can find the paths that use the `breadth-first` function that we walked
    through earlier. We simply take each vertex as a starting point and get all the
    paths from there. To make access easier later, we convert each path returned into
    a hash map as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到使用之前提到的`breadth-first`函数走过的路径。我们只需将每个顶点作为起点，并从那里获取所有路径。为了便于后续访问，我们将返回的每个路径转换为以下哈希表：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unfortunately, there's an added complication; the output will probably take
    more memory than available. Because of this, we'll also define a couple of functions
    to write the paths out to a file and iterate over them again. We'll name them
    `network-six.graph/write-paths` and `network-six.graph/iter-paths`, and you can
    find them in the code download provided for this chapter on the Packt Publishing
    website. I saved it to the file `path.json`, as each line of the file is a separate
    JSON document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，还有一个额外的复杂性；输出可能需要的内存比可用的还要多。因此，我们还将定义几个函数来将路径写入文件并再次遍历它们。我们将它们命名为`network-six.graph/write-paths`和`network-six.graph/iter-paths`，你可以在Packt
    Publishing网站上提供的该章节代码下载中找到它们。我将其保存到了名为`path.json`的文件中，因为文件中的每一行都是一个单独的JSON文档。
- en: Average path length
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均路径长度
- en: 'The first metric that we can get from the paths is the average path length.
    We can find this easily by walking over the paths. We''ll use a slightly different
    definition of mean that doesn''t require all the data to be kept in the memory.
    You can find this in the `network-six.util` namespace:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从路径中获取的第一个度量是平均路径长度。我们可以通过遍历路径来轻松找到这个度量。我们将使用一个略微不同的平均定义，它不需要将所有数据都保存在内存中。你可以在`network-six.util`命名空间中找到它：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is interesting! Strictly speaking, the concept of six degrees of separation
    says that all paths in the network should be six or smaller However, experiments
    often look at the paths in terms of the average path length. In this case, the
    average distance between any two connected nodes in this graph is just over six.
    So, the six degrees of separation do appear to hold in this graph.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣！严格来说，六度分隔的概念表明网络中的所有路径应该是六度或更小。然而，实验通常从平均路径长度的角度来观察路径。在这种情况下，图中任意两个连接节点之间的平均距离略大于六。因此，六度分隔似乎在这个图中是成立的。
- en: 'We can see the distribution of path lengths more clearly by looking at a histogram
    of them:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看它们的直方图，我们可以更清楚地看到路径长度的分布：
- en: '![Average path length](img/4139OS_01_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![平均路径长度](img/4139OS_01_02.jpg)'
- en: So, the distribution of path lengths appears to be more or less normal, centered
    on 6.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，路径长度的分布似乎大致呈正态分布，中心在6。
- en: Network diameter
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络直径
- en: 'The network diameter is the longest of the shortest paths between any two nodes
    in the graph. This is simple to get:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 网络直径是图中任意两个节点之间最短路径中最长的路径。这很简单就可以得到：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So the network diameter is approximately three times larger than the average.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，网络直径大约是平均路径长度的三倍。
- en: Clustering coefficient
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚类系数
- en: Clustering coefficient is a measure of how many densely linked clusters there
    are in the graph. This is one measure of the small world effect, and it's sometimes
    referred to as the "all my friends know each other" property. To find the clustering
    coefficient for one vertex, this basically cuts all of its neighbors out of the
    network and tries to find the density of the subgraph. In looking at the whole
    graph, a high clustering coefficient indicates a small world effect in the graph.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 聚类系数是衡量图中密集连接的集群数量的度量。这是小世界效应的一个度量，有时也被称为“我的所有朋友都互相认识”的性质。为了找到一个顶点的聚类系数，这基本上是将所有邻居从网络中移除并尝试找到子图的密度。在观察整个图时，高聚类系数表明图中存在小世界效应。
- en: 'The following is how to find the clustering coefficient for a single vertex:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何找到一个单顶点的聚类系数：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function to find the average clustering coefficient for the graph is straightforward,
    and you can find it in the code download. The following is how it looks when applied
    to this graph:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 找到图中平均聚类系数的函数很简单，你可以在代码下载中找到它。以下是将其应用于此图时的样子：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So it's not overly large. Chances are, there are a few nodes that are highly
    connected throughout the graph and most others are less connected.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它并不算特别大。可能性很大，有一些节点在整个图中高度连接，而大多数其他节点则连接较少。
- en: Centrality
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中心性
- en: There are several ways to measure how central a vertex is to the graph. One
    is **closeness centrality**. This is the distance of any particular vertex from
    all other vertices. We can easily get this information with the `breadth-first`
    function that we created earlier. Unfortunately, this only applies to complete
    networks, that is, to networks in which every vertex is reachable from every other
    vertex. This is not the case in the graph we're working with right now. There
    are some small pockets that are completely isolated from the rest of the network.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以衡量一个顶点在图中的中心程度。一种是**接近中心性**。这是任何特定顶点与其他所有顶点的距离。我们可以通过之前创建的`breadth-first`函数轻松地获取这些信息。不幸的是，这仅适用于完整网络，即每个顶点都可以从其他每个顶点到达的网络。我们目前正在处理的是这种情况。有一些小区域完全与网络的其他部分隔离。
- en: However, there are other measures of centrality that we can use instead. **Betweenness
    centrality** counts the number of shortest paths that a vertex is found in. Betweenness
    finds the vertices that act as a bridge. The original intent of this metric was
    to identify people who control the communication in the network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用其他中心性度量来代替。**中介中心性**计算一个顶点出现在最短路径中的数量。中介性找到充当桥梁的顶点。这个度量原始的目的是为了识别控制网络通信的人。
- en: 'To get this done efficiently, we can rely on the paths returned by the `breadth-first`
    function again. We''ll get the paths from each vertex and call `reduce` over each.
    At every step, we''ll calculate the total number of paths plus the number of times
    each vertex appears in a path:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地完成这项工作，我们可以再次依赖`breadth-first`函数返回的路径。我们将从每个顶点获取路径并调用`reduce`。在每一步中，我们将计算路径总数以及每个顶点出现在路径中的次数：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, once we reach the end, we''ll take the total number of paths and convert
    the betweenness and reachable totals for each vertex to a ratio, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一旦我们到达终点，我们将取路径总数并将每个顶点的中介性和可达性总数转换为比率，如下所示：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While these two functions do all the work, they aren''t the public interface.
    The function metrics tie these two together in something we''d want to actually
    call:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个函数做了所有的工作，但它们并不是公共接口。函数指标将这些两个函数结合在一起，形成一个我们实际上想要调用的东西：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now use this to find the betweenness centrality of any vertex as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个方法来找到任何顶点的中介中心性，如下所示：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or, we can sort the vertices on the centrality measure to get those vertices
    that have the highest values. The first number in each pair of values that are
    returned is the node, and the second number is the betweenness centrality of that
    node. So, the first result says that the betweenness centrality for node `1085`
    is `0.254`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以根据中心性度量对顶点进行排序，以获取具有最高值的顶点。返回的每一对值中的第一个数字是节点，第二个数字是该节点的中介中心性。因此，第一个结果是说节点`1085`的中介中心性为`0.254`：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This has all been interesting, but what about Kevin Bacon?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很有趣，但凯文·贝肯呢？
- en: Degrees of separation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分隔度
- en: We started this chapter talking about the *Six Degrees* *of Kevin Bacon*, a
    pop culture phenomenon and how this captures a fundamental nature of many social
    networks. Let's analyze our Facebook network for this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一章中讨论了*六度分隔*的凯文·贝肯，这是一个流行文化现象，以及它如何捕捉许多社交网络的基本性质。让我们分析我们的Facebook网络来了解这一点。
- en: 'First, we''ll create a function called `degrees-between`. This will take an
    origin vertex and a degree of separation to go out, and it will return a list
    of each level of separation and the vertices at that distance from the origin
    vertex. The `degrees-between` function will do this by accumulating a list of
    vertices at each level and a set of vertices that we''ve seen. At each step, it
    will take the last level and find all of those vertices'' neighbors, without the
    ones we''ve already visited. The following is what this will look like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`degrees-between`的函数。这个函数将接受一个起始顶点和要向外延伸的度数，然后返回每个级别的分离以及从起始顶点这个距离的顶点列表。`degrees-between`函数将通过累积每个级别的顶点列表和我们已经看到的顶点集合来实现这一点。在每一步中，它将取最后一级别并找到所有这些顶点的邻居，但不包括我们已访问过的那些。以下是这样做的样子：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Earlier, we included a way to associate data with a vertex, but we haven''t
    used this yet. Let''s exercise that feature to store the degrees of separation
    from the origin vertex in the graph. We can either call this function with the
    output of `degrees-between` or with the parameters to `degrees-between`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们包括了一种将数据与顶点关联起来的方法，但我们还没有使用它。让我们练习这个功能，将图中从原顶点分离的度数存储起来。我们可以用`degrees-between`函数的输出调用这个函数，或者用`degrees-between`的参数调用：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, the full graph is a little large, especially for many visualizations.
    So, let''s include a function that will let us zoom in on the graph identified
    by the `degrees-between` function. It will return both the original graph, with
    the vertex data fields populated and the subgraph of vertices within the `n` levels
    of separation from the origin vertex:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，完整的图形有点大，特别是对于许多可视化来说。所以，让我们包括一个函数，它将允许我们放大由`degrees-between`函数标识的图形。它将返回原始图形，其中顶点数据字段已填充，以及从原顶点分离的`n`级内的顶点子图：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With these defined, we can learn some more interesting things about the network
    that we''re studying. Let''s see how much of the network with different vertices
    can reach within six hops. Let''s look at how we''d do this with vertex `0`, and
    then we can see a table that presents these values for several vertices:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些之后，我们可以了解一些关于我们正在研究的网络更有趣的事情。让我们看看有多少不同顶点的网络可以在六跳内到达。让我们看看如何使用顶点`0`来做这件事，然后我们可以看到一张表格，展示了几个顶点的这些值：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, it''s interesting to see how the betweenness values for these track the
    amount of the graph that they can access quickly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看到这些顶点的介数值如何跟踪它们可以快速访问的图形量是很有趣的：
- en: '| Vertex | Betweenness | Percent accessible |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 顶点 | 介数 | 可访问百分比 |'
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0.0005093 | 89.5000 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.0005093 | 89.5000 |'
- en: '| 256 | 0.0000001 | 0.0005 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 256 | 0.0000001 | 0.0005 |'
- en: '| 1354 | 0.0005182 | 75.9500 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 1354 | 0.0005182 | 75.9500 |'
- en: '| 1085 | 0.2541568 | 96.1859 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 1085 | 0.2541568 | 96.1859 |'
- en: These are some interesting data points. What does this look like for the network
    as a whole?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些有趣的数据点。对于整个网络来说，这看起来是怎样的？
- en: '![Degrees of separation](img/4139OS_01_03.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![分离度](img/4139OS_01_03.jpg)'
- en: This makes it clear that there's probably little correlation between these two
    variables. Most vertices have a very low betweenness, although they range between
    0 and 100 in the percent of the network that they can access.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，这两个变量之间可能几乎没有相关性。大多数顶点的介数非常低，尽管它们在它们可以访问的网络百分比为0到100之间变化。
- en: At this point, we have some interesting facts about the network, but it would
    be helpful to get a more intuitive overview of it, like we just did for the betweenness
    centrality. Visualizations can help here.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一些关于网络的有趣事实，但得到一个更直观的概述将非常有帮助，就像我们刚才对介数中心性所做的那样。可视化可以帮助我们做到这一点。
- en: Visualizing the graph
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化图形
- en: At this point, it would be really useful to visualize this graph. There are
    a number of different ways to visualize graphs. We'll use the JavaScript library
    `D3` (data-driven documents, [http://d3js.org/](http://d3js.org/)) to generate
    several graph visualizations on subgraphs of the Facebook network data, and we'll
    look at the pros and cons of each. Finally, we'll use a simple pie chart to visualize
    how much of the graph is affected as we move outward from a node through its degrees
    of separation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可视化这个图将非常有用。有许多不同的方法可以可视化图形。我们将使用JavaScript库`D3`（数据驱动文档，[http://d3js.org/](http://d3js.org/))在Facebook网络数据的子图上生成几个图形可视化，并探讨每种方法的优缺点。最后，我们将使用简单的饼图来可视化当我们从一个节点通过其分离度向外移动时，图形受影响的程度。
- en: Setting up ClojureScript
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 ClojureScript
- en: As I just mentioned, `D3` is a JavaScript library. JavaScripts are not bad,
    but this is a book about Clojure. There's an implementation of the Clojure compiler
    that takes Clojure and generates JavaScript. So, we'll use that to keep our focus
    on Clojure while we call JavaScript libraries and deploy them on a browser.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚才提到的，`D3`是一个JavaScript库。JavaScript并不差，但这是一本关于Clojure的书。有一个Clojure编译器的实现，它可以将Clojure转换为JavaScript。所以，我们将使用它来保持我们的Clojure焦点，同时调用JavaScript库并将它们部署在浏览器上。
- en: 'Before we can do that, however, we need to set up our system to use ClojureScript.
    The first thing we''ll need to do is to add the configuration to our `project.clj`
    file for this project. This is fairly simple. We just need to declare `lein-cljsbuild`
    as a plugin for this project and then configure the ClojureScript compiler. Our
    `project.clj` file from earlier is shown as follows, with the relevant lines highlighted
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够做到这一点之前，我们需要设置我们的系统以使用 ClojureScript。我们首先需要做的是将配置添加到我们项目的 `project.clj`
    文件中。这相当简单。我们只需要声明 `lein-cljsbuild` 作为此项目的插件，然后配置 ClojureScript 编译器。我们之前的 `project.clj`
    文件如下所示，相关行已突出显示：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first line adds the `lein-cljsbuild` plugin to the project. The second block
    of lines tell Leiningen to watch the `src-cljs` directory for ClojureScript files.
    All of these files are then compiled into the `www/js/main.js` file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将 `lein-cljsbuild` 插件添加到项目中。第二段代码告诉 Leiningen 监视 `src-cljs` 目录中的 ClojureScript
    文件。所有这些文件随后都被编译成 `www/js/main.js` 文件。
- en: We'll need an HTML file to frame the compiled JavaScript. In the code download,
    I've included a basic page that's modified from an HTML5 Boilerplate template
    ([http://html5boilerplate.com/](http://html5boilerplate.com/)). The biggest change
    is that I've taken out everything that's in the `div` content.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 HTML 文件来包围编译后的 JavaScript。在代码下载中，我已经包含了一个从 HTML5 Boilerplate 模板（[http://html5boilerplate.com/](http://html5boilerplate.com/)）修改的基本页面。最大的变化是我已经移除了
    `div` 内容中的所有内容。
- en: 'Also, I added some `script` tags to load `D3` and a `D3` plugin for one of
    the types of graphs that we''ll use later. After the tag that loads `bootstrap.min.js`,
    I added these:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还添加了一些 `script` 标签来加载 `D3` 和我们将要使用的某些类型图表的 `D3` 插件。在加载 `bootstrap.min.js`
    的标签之后，我添加了以下内容：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, to load the data files asynchronously with AJAX, the `www` directory
    will need to be accessible from a web server. There are a number of different
    options, but if you have Python installed, the easiest option is to probably navigate
    to the `www` directory and execute the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了异步使用 AJAX 加载数据文件，`www` 目录需要可以从网络服务器访问。有几种不同的选项，但如果您已安装 Python，最简单的选项可能是导航到
    `www` 目录并执行以下命令：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we're ready to proceed. Let's make some charts!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备继续前进。让我们制作一些图表！
- en: A force-directed layout
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 力导向布局
- en: One of the standard chart types to visualize graphs is a **force-directed layout**.
    These charts use a dynamic-layout algorithm to generate charts that are more clear
    and look nice. They're modeled on springs. Each vertex repels all the other vertices,
    but the edges draw the vertices closer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用于可视化图形的标准图表类型之一是**力导向布局**。这些图表使用动态布局算法生成更清晰且看起来更漂亮的图表。它们基于弹簧模型。每个顶点都排斥其他所有顶点，但边将顶点拉近。
- en: 'To have this graph compiled to JavaScript, we start by creating a file named
    `src-cljs/network-six/force.cljs`. We''ll have a standard namespace declaration
    at the top of the file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此图形编译成 JavaScript，我们首先创建一个名为 `src-cljs/network-six/force.cljs` 的文件。我们将在文件的顶部有一个标准的命名空间声明：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Generally, when we use `D3`, we first set up part of the graph. Then, we get
    the data. When the data is returned, we continue setting up the graph. In `D3`,
    this generally means selecting one or more elements currently in the tree and
    then selecting some of their children using `selectAll`. The elements in this
    new selection may or may not exist at this point. We join the `selectAll` elements
    with the data. From this point, we use the `enter` method most of the time to
    enter the data items and the nonexistent elements that we selected earlier. If
    we're updating the data, assuming that the elements already exist, then the process
    is slightly different. However, the process that uses the `enter` method, which
    I described, is the normal workflow that uses `D3`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们使用 `D3` 时，我们首先设置图形的一部分。然后，我们获取数据。当数据返回时，我们继续设置图形。在 `D3` 中，这通常意味着选择树中当前的一个或多个元素，然后使用
    `selectAll` 选择它们的一些子元素。在这个新选择中的元素可能在这个时候存在，也可能不存在。我们将 `selectAll` 元素与数据连接起来。从这一点开始，我们大多数时候使用
    `enter` 方法来输入数据项和我们之前选择的非存在元素。如果我们正在更新数据，假设元素已经存在，那么过程略有不同。然而，我描述的使用 `enter` 方法的流程是
    `D3` 的正常工作流程。
- en: 'So, we''ll start with a little setup for the graph by creating the color palette.
    In the graph that we''re creating, colors will represent the node''s distance
    from a central node. We''ll take some time to understand this, because it illustrates
    some of the differences between Clojure and ClojureScript, and it shows us how
    to call JavaScript:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从设置图形的简单设置开始，创建颜色调色板。在我们创建的图形中，颜色将代表节点与中心节点的距离。我们将花一些时间来理解这一点，因为它说明了 Clojure
    和 ClojureScript 之间的一些差异，并展示了如何调用 JavaScript：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s take this bit by bit so that we can understand it all. I''ll list a
    line and then point out what''s interesting about it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一点一点地分析，以便我们能够理解所有内容。我会列出一条线，然后指出它的有趣之处：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are a couple of things that we need to notice about this line. First,`..`
    is the standard member access macro that we use for Java's interoperability with
    the main Clojure implementation. In this case, we're using it to construct a series
    of access calls against a JavaScript object. In this case, the ClojureScript that
    the macro expands to would be `(.domain (.category10 (.-scale js/d3)) (array 0
    1 2 3 4 5 6))`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意关于这一行的一些事情。首先，`..` 是我们用于 Java 与主要 Clojure 实现互操作性的标准成员访问宏。在这种情况下，我们使用它来对
    JavaScript 对象进行一系列访问调用。在这种情况下，宏展开后的 ClojureScript 将会是 `(.domain (.category10 (.-scale
    js/d3)) (array 0 1 2 3 4 5 6))`。
- en: 'In this case, that object is the main `D3` object. The `js/` namespace is available
    by default. It''s just an escape hatch to the main JavaScript scope. In this case,
    it would be the same as accessing a property on the JavaScript `window` object.
    You can use this to access anything from JavaScript without having to declare
    it. I regularly use it with `js/console` for debugging, for example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个对象是主要的 `D3` 对象。`js/` 命名空间默认可用。它只是一个通向主要 JavaScript 作用域的出口。在这种情况下，它将等同于访问
    JavaScript `window` 对象上的属性。你可以用它来访问 JavaScript 中的任何内容，而无需声明它。例如，我经常用 `js/console`
    进行调试：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This resolves into the JavaScript `d3.scale` call. The minus sign before `scale`
    just means that the call is a property and not a function that takes no arguments.
    As Clojure doesn''t have properties and everything here would look like a function
    call, ClojureScript needs some way to know that this should not generate a function
    call. The dash does that as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这解析为 JavaScript 的 `d3.scale` 调用。`scale` 前的减号仅仅意味着这是一个属性调用，而不是一个不接受任何参数的函数。由于
    Clojure 没有属性，这里所有东西看起来都像函数调用，ClojureScript 需要某种方式知道这不应该生成函数调用。破折号就是这样做的：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This line, combined with the preceding lines, generates JavaScript that looks
    like `d3.scale.category10()`. In this case, the call doesn''t have a minus sign
    before it, so the ClojureScript compiler knows that it should generate a function
    call in this case:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行，结合前面的行，生成类似于 `d3.scale.category10()` 的 JavaScript 代码。在这种情况下，调用前没有减号，所以 ClojureScript
    编译器知道在这种情况下应该生成一个函数调用：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, this makes a call to the scale's `domain` method with an array that
    sets the domain to the integers between 0 and 6, inclusive of both. These are
    the values for the distances that we'll look at. The JavaScript for this would
    be `d3.scale.category10().domain([0, 1, 2, 3, 4, 5, 6])`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个调用使用一个设置域为 0 到 6（包括两者）的数组调用缩放的 `domain` 方法。这些是我们将要查看的距离值。这个 JavaScript
    将会是 `d3.scale.category10().domain([0, 1, 2, 3, 4, 5, 6])`。
- en: This function creates and returns a color object. This object is callable, and
    when it acts as a function that takes a value and returns a color, this will consistently
    return the same color whenever it's called with a given value from the domain.
    For example, this way, the distance `1` will also be associated with the same
    color in the visualization.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建并返回一个颜色对象。这个对象是可调用的，当它作为一个接受值并返回颜色的函数时，每次调用给定域中的值时，都会一致地返回相同的颜色。例如，这样，距离
    `1` 也会与可视化中的相同颜色相关联。
- en: This gives us an introduction to the rules for interoperability in ClojureScript.
    Before we make the call to get the data file, we'll also create the object that
    takes care of managing the force-directed layout and the `D3` object for the `svg`
    element. However, you can check the code download provided on the Packt Publishing
    website for the functions that create these objects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们介绍了 ClojureScript 中互操作性的规则。在我们调用获取数据文件之前，我们还将创建一个负责管理力导向布局和 `svg` 元素的 `D3`
    对象。然而，你可以检查 Packt 出版网站提供的代码下载，以获取创建这些对象的函数。
- en: Next, we need to access the data. We'll see that in a minute, though. First,
    we need to define some more functions to work with the data once we have it.For
    the first function, we need to take the force-layout object and associate the
    data with it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要访问数据。我们稍后会看到。首先，我们需要定义一些函数来处理我们得到的数据。对于第一个函数，我们需要将力导向布局对象与数据关联起来。
- en: The data for all of the visualizations has the same format. Each visualization
    is a JSON object with three keys. The first one, `nodes`, is an array of JSON
    objects, each representing one vertex in the graph. The main property of these
    objects that we're interested in is the `data` property. This contains the distance
    of the current vertex from the origin vertex. Next, the `links` property is a
    list of JSON objects that represent the edges of the graph. Each link contains
    the index of a source vertex and a target vertex. Third, the `graph` property
    contains the entire graph using the same data structures as we did in Clojure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可视化的数据都有相同的格式。每个可视化都是一个包含三个键的JSON对象。第一个键，`nodes`，是一个表示图中每个顶点的JSON对象的数组。我们感兴趣的主要属性是`data`属性。它包含当前顶点与原点顶点的距离。接下来，`links`属性是一个表示图中边的JSON对象的列表。每个链接包含一个源顶点和目标顶点的索引。第三个键`graph`包含整个图，使用与我们之前在Clojure中使用的相同的数据结构。
- en: 'The force-directed layout object expects to work with the data from the `nodes`
    and the `links` properties. We set this up and start the animation with the `setup-force-layout`
    function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 力导向布局对象期望与`nodes`和`links`属性的数据一起工作。我们使用`setup-force-layout`函数设置并开始动画：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As the animation continues, the force-layout object will assign each node and
    link the object with one or more coordinates. We'll need to update the circles
    and paths with those values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 随着动画的进行，力导向布局对象将为每个节点和边分配一个或多个坐标。我们需要用这些值更新圆圈和路径。
- en: 'We''ll do this with a handler for a `tick` event that the layout object will
    emit:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过布局对象将发出`tick`事件的处理器来完成这项工作：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Also, at this stage, we create the `circle` and `path` elements that represent
    the vertices and edges. We won't list these functions here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个阶段，我们创建了代表顶点和边的`circle`和`path`元素。我们不会在这里列出这些函数。
- en: 'Finally, we tie everything together. First, we set up the initial objects,
    then we ask the server for the data, and finally, we create the HTML/SVG elements
    that represent the data. This is all tied together with the `main` function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些整合在一起。首先，我们设置初始对象，然后我们向服务器请求数据，最后，我们创建代表数据的HTML/SVG元素。所有这些都与`main`函数紧密相连：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are a couple of things that we need to notice about this function, and
    they're both highlighted in the preceding snippet. The first is that the function
    name has an `:export` metadata flag attached to it. This just signals that the
    ClojureScript compiler should make this function accessible from JavaScript outside
    this namespace. The second is the call to `d3.json`. This function takes a URL
    for a JSON data file and a function to handle the results. We'll see more of this
    function later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个函数，我们需要注意几点，它们都在前面的代码片段中被突出显示。首先，函数名附有一个`:export`元数据标志。这仅仅表示ClojureScript编译器应该使这个函数在这个命名空间外部的JavaScript中可访问。其次，是调用`d3.json`。这个函数接受一个JSON数据文件的URL和一个处理结果的函数。我们稍后会看到这个函数的更多用法。
- en: 'Before we can use this, we need to call it from the HTML page. After the `script`
    tag that loads `js/main.js`, I added this `script` tag:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用它之前，我们需要从HTML页面中调用它。在加载`js/main.js`的`script`标签之后，我添加了这个`script`标签：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This loads the data file for vertex number `49`. This vertex had a betweenness
    factor of 0.0015, and it could reach four percent of the larger network within
    six hops. This is small enough to create a meaningful, comprehensible graphic,
    as seen in the following figure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这加载了顶点编号为`49`的数据文件。这个顶点的介数因子为0.0015，它可以在六步之内到达更大网络的四分之一。这足够小，可以创建一个有意义的、可理解的图形，如下面的图所示：
- en: '![A force-directed layout](img/4139OS_01_04.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![力导向布局](img/4139OS_01_04.jpg)'
- en: The origin vertex (`49`) is the blue vertex on the lower-right section, almost
    the farthest-right node of the graph. All the nodes at each hop away from that
    node will be of a different color. The origin vertex branches to three orange
    vertices, which link to some green ones. One of the green vertices is in the middle
    of the larger cluster on the right.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 原点顶点（`49`）是位于右下角部分的蓝色顶点，几乎是图中最右边的节点。从这个节点跳出的每个节点都将有不同的颜色。原点顶点分支到三个橙色顶点，这些顶点连接到一些绿色顶点。其中一个绿色顶点位于右侧较大集群的中间。
- en: Some aspects of this graph are very helpful. It makes it relatively easy to
    trace the nodes as they get farther from the origin. This is even easier when
    interacting with the node in the browser, because it's easy to grab a node and
    pull it away from its neighbors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图的某些方面非常有帮助。它使得追踪节点随着它们远离原点变得相对容易。当在浏览器中与节点交互时，这甚至更容易，因为很容易抓住一个节点并将其从其邻居中拉出来。
- en: However, it distorts some other information. The graph that we're working with
    today is not weighted. Theoretically, the links in the graph should be the same
    length because all the edges have the same weight. In practice, however, it's
    impossible to display a graph in two dimensions. Force-directed layouts help you
    display the graph, but the cost is that it's hard to tell exactly what the line
    lengths and the several clear clusters of various sizes mean on this graph.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它扭曲了一些其他信息。我们今天正在处理的图是没有权重的。从理论上讲，图中的链接应该有相同的长度，因为所有边都有相同的权重。然而，在实践中，在二维中显示一个图是不可能的。力导向布局可以帮助你显示图，但代价是它很难准确地知道线长度和几个不同大小的清晰集群在这个图上的意义。
- en: Also, the graphs themselves cannot be compared. If we then pulled out a subgraph
    around a different vertex and charted it, we wouldn't be able to tell much by
    comparing the two.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，图本身是无法比较的。如果我们围绕不同的顶点提取一个子图并绘制它，通过比较这两个图我们也不会得到太多信息。
- en: So what other options do we have?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还有哪些其他选择？
- en: A hive plot
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个蜂巢图
- en: The first option is a **hive plot**. This is a chart type developed by Martin
    Krzywinski ([http://egweb.bcgsc.ca/](http://egweb.bcgsc.ca/)). These charts are
    a little different, and reading them can take some time to get used to, but they
    pack in more meaningful information than force-directed layout or other similar
    chart types do.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是一个**蜂巢图**。这是由Martin Krzywinski开发的一种图表类型（[http://egweb.bcgsc.ca/](http://egweb.bcgsc.ca/)）。这些图表略有不同，阅读它们可能需要一些时间来习惯，但它们包含的信息比力导向布局或其他类似图表类型更多。
- en: In hive plots, the nodes are positioned along a number of radial axes, often
    three. Their positions on the axis and which axis they fall on are often meaningful,
    although the meanings may change between different charts in different domains.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在蜂巢图中，节点沿着多个径向轴定位，通常是三个。它们在轴上的位置以及它们所在的轴通常是有意义的，尽管在不同的领域和不同的图表中，这些意义可能会发生变化。
- en: For this, we'll have vertices with a higher degree (with more edges attached
    to them) be positioned farther out from the center. Vertices closer in will have
    fewer edges and fewer neighbors. Again, the color of the lines represent the distance
    of that node from the central node. In this case, we won't make the selection
    of the axis meaningful.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们将具有更高度（与更多边相连）的顶点定位在中心更远的位置。靠近中心的顶点将有更少的边和更少的邻居。再次强调，线的颜色代表该节点与中心节点的距离。在这种情况下，我们不会使轴的选择有意义。
- en: 'To create this plot, we''ll open a new file, `src-cljs/network-six/hive.cljs`.
    At the top, we''ll use this namespace declaration:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个图，我们将打开一个新的文件，`src-cljs/network-six/hive.cljs`。在顶部，我们将使用这个命名空间声明：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The axis on which a node falls on is an example of a `D3` *scale*; its color
    from the force layout plot is another scale. Scales are functions that also have
    properties attached and are accessible via getter or setter functions. However,
    primarily, when they are passed a data object and a key function, they know how
    to assign that data object a position on the scale.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点所在的轴是一个`D3` *scale*的例子；其从力导向布局图中的颜色是另一个scale。Scales是具有附加属性并可通过getter或setter函数访问的函数。然而，主要的是，当它们传递一个数据对象和一个键函数时，它们知道如何将数据对象分配到scale上的一个位置。
- en: 'In this case, the `make-angle` function will be used to assign nodes to an
    axis:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`make-angle`函数将被用来将节点分配到一个轴上：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We''ll position the nodes along each axis with the `get-radius` function. This
    is another scale that takes a vertex and positions it in a range between `40`
    and `400` according to the number of edges that are connected to it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`get-radius`函数将节点定位在每个轴上。这是另一个刻度，它根据连接到节点的边的数量，将顶点定位在`40`到`400`的范围之间：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We use these scales, along with a scale for color, to position and style the
    nodes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些刻度尺，以及一个颜色刻度尺，来定位和样式化节点：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I've highlighted the scales that we use in the preceding code snippet. The circle's
    `stroke` property comes from the color, which represents the distance of the vertex
    from the origin for this graph.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了前面代码片段中使用的刻度尺。圆的`stroke`属性来自颜色，它代表顶点在这个图中的距离。
- en: The `angle` is used to assign the circle to an axis using the circle's `transform`
    attribute. This is done more or less at random, based on the vertex's index in
    the data collection.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`angle`用于通过圆的`transform`属性将圆分配给一个轴。这是基于顶点在数据集中的索引，或多或少是随机进行的。'
- en: Finally, the `radius` scale positions the circle along the axis. This sets the
    circle's position on the *x* axis, which is then rotated using the `transform`
    attribute and the `angle` scale.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`radius`刻度将圆定位在轴上。这设置了圆在*x*轴上的位置，然后使用`transform`属性和`angle`刻度进行旋转。
- en: 'Again, everything is brought together in the `main` function. This sets up
    the scales, requests the data, and then creates and positions the nodes and edges:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有内容都在`main`函数中整合。这个函数设置了刻度尺，请求数据，然后创建和定位节点和边：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s see what this graph looks like:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个图是什么样子：
- en: '![A hive plot](img/4139OS_01_05.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![蜂巢图](img/4139OS_01_05.jpg)'
- en: Again, the color represents the distance of the node from the central node.
    The distance from the center on each axis is the degree of the node.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，颜色代表节点与中心节点的距离。每个轴上的中心距离是节点的度数。
- en: It's clear from the predominance of the purple-pink color and the bands that
    the majority of the vertices are six hops from the origin vertex. From the vertices'
    position on the axes, we can also see that most nodes have a moderate number of
    edges attached to them. One has quite a few, but most are much closer to the center.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从紫色-粉红色的颜色和条纹的普遍存在来看，大多数顶点距离起点有六跳。从顶点在轴上的位置，我们还可以看到大多数节点连接的边数适中。有一个节点连接的边相当多，但大多数节点都更靠近中心。
- en: This graph is denser. Although the force-layout graph may have been problematic,
    it seemed more intuitive and easier to understand, whether it was meaningful or
    not. Hive plots are more meaningful, but they also take a bit more work to learn
    to read and to decipher.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图更密集。虽然力导向图可能有问题，但它似乎更直观，更容易理解，无论它是否有意义。蜂巢图更有意义，但它们也稍微复杂一些，需要更多的工作来学习和解读。
- en: A pie chart
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 饼图
- en: Our needs today are simpler than the complex graph we just created; however,
    we're primarily interested in how much of the network is covered within six hops
    from a vertex. Neither of the two graphs that we've looked at so far conveyed
    that well, although they have presented other information and they're commonly
    used with graphs. We want to know proportions, and the go-to chart for proportions
    is the pie chart. Maybe it's a little boring, and it's does not strictly speak
    of a graph visualization per se, but it's clear, and we know what we're dealing
    with in it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的需求比我们刚才创建的复杂图要简单；然而，我们主要感兴趣的是从顶点出发，网络中有多少部分在六跳之内。到目前为止，我们查看的两个图都没有很好地传达这一点，尽管它们提供了其他信息，并且通常与图一起使用。我们想知道比例，而用于比例的图表通常是饼图。也许它有点无聊，而且它并不严格地描述图形可视化本身，但它很清晰，我们知道我们在处理什么。
- en: Generating a pie chart will look very similar to creating a force-directed layout
    graph or a hive plot. We'll go through the same steps, overall, even though some
    of the details will be different.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 生成饼图的过程将非常类似于创建力导向布局图或蜂巢图。我们将采取相同的步骤，尽管一些细节会有所不同。
- en: 'One of the first differences is the function to create an arc. This is similar
    to a scale, but its output is used to create the `d` (path description) attribute
    of the pie chart''s wedges:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于创建弧线的函数。这类似于一个刻度尺，但其输出用于创建饼图扇形的`d`（路径描述）属性：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `pie` layout controls the overall process and design of the chart. In this
    case, we say that we want no sorting, and we need to use the `amount` property
    of the data objects:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`pie`布局控制图表的整体过程和设计。在这种情况下，我们说我们不需要排序，我们需要使用数据对象的`amount`属性：'
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The other difference in this chart is that we''ll need to preprocess the data
    before it''s ready to be fed to the pie layout. Instead of a list of nodes and
    links, we''ll need to give it categories and counts. To make this easier, we''ll
    create a record type for these frequencies:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中的另一个不同之处在于，在数据准备好被输入到饼图布局之前，我们需要先对数据进行预处理。而不是一个节点和链接的列表，我们需要提供类别和计数。为了使这个过程更简单，我们将为这些频率创建一个记录类型：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Also, we''ll need a function that takes the same data as the other charts,
    counts it by distance from the origin vertex, and creates `Freq` instances to
    contain that data:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要一个函数，它接受与其他图表相同的数据，按距离原点顶点的距离进行计数，并创建`Freq`实例来包含这些数据：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, we pull all these together in the `main` function, and we do things in
    the usual way. First, we set up the graph, then we retrieve the data, and finally,
    we put the two together to create the graph.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在`main`函数中把这些放在一起，我们按照通常的方式行事。首先，我们设置图，然后我们检索数据，最后，我们将两者结合起来创建图。
- en: In this case, this should give us an idea of how much of the graph this vertex
    can easily touch. The graph for vertex `49` is shown as follows. We can see that
    it really doesn't touch much of the network at all. 3799 vertices, more than 95
    percent of the network, aren't within six hops of vertex `49`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这应该能给我们一个概念，即这个顶点可以轻松接触图中的多少部分。顶点`49`的图如下所示。我们可以看到，它实际上几乎根本不接触网络中的任何部分。3799个顶点，超过网络95%的部分，都不在顶点`49`的六跳范围内。
- en: '![A pie chart](img/4139OS_01_06.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![一个饼图](img/4139OS_01_06.jpg)'
- en: However, if we compare this with the pie chart for vertex `1085`, which was
    the vertex with the highest betweenness factor, we see a very different picture.
    For that vertex, more than 95 percent of the network is reachable within 6 hops.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将其与顶点`1085`的饼图进行比较，这是具有最高中介中心性的顶点，我们会看到一个完全不同的画面。对于那个顶点，超过95%的网络在六跳内是可到达的。
- en: '![A pie chart](img/4139OS_01_07.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![一个饼图](img/4139OS_01_07.jpg)'
- en: It's also interesting that most of the vertices are four edges away from the
    origin. For smaller networks, most vertices are further away. However, in this
    case, it's almost as if it had started running out of vertices in the network.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 同样有趣的是，大多数顶点距离原点有四个边。对于较小的网络，大多数顶点距离更远。然而，在这种情况下，它几乎就像它开始耗尽网络中的顶点一样。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, we discovered that this dataset does conform to a loose definition of the
    small world or a six-degree hypothesis. The average distance between any two nodes
    is about six. Also, as we're working with a sample, it's possible that working
    with a complete graph may fill in some links and bring the nodes closer together.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们发现这个数据集符合对“小世界”或六度假设的宽松定义。任何两个节点之间的平均距离大约是六。另外，由于我们正在处理一个样本，使用完整的图可能填补一些链接并将节点更紧密地聚集在一起。
- en: We also had an interesting time looking at some visualizations. One of the important
    lessons that we learned was that more complicated isn't always better. Simple,
    perhaps even a little boring, graphs can sometimes answer the questions we have
    in a better manner.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了一些时间查看一些可视化。我们学到的一个重要教训是，更复杂的不一定是更好的。简单，甚至可能有点无聊的图，有时可以更好地回答我们的问题。
- en: However, we've barely scratched the surface of what we can do with social graphs.
    We've primarily been looking at the network as a very basic, featureless graph,
    looking at the existence of people and their relationships without digging into
    the details. However, there are several directions we could go in to make our
    analysis more social. For one, we could look at the different types of relationships.
    Facebook and other social platforms allow you to specify spouses, for example,
    it might be interesting to look at an overlap between spouses' networks. Facebook
    also tracks interests and affiliations using their well-known **Like** feature.
    We could also look at how well people with similar interests find each other and
    form cliques.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只是触及了使用社交图可以做的事情的表面。我们主要将网络视为一个非常基本的、无特征的图，查看人们及其关系的存在，而不深入细节。然而，有几个方向我们可以走，使我们的分析更具社交性。一方面，我们可以查看不同类型的关系。例如，Facebook和其他社交平台允许你指定配偶，可能有趣的是查看配偶网络的交集。Facebook还使用他们著名的**喜欢**功能跟踪兴趣和归属。我们还可以查看具有相似兴趣的人如何找到彼此并形成小团体。
- en: In the end, we've managed to learn a lot about networks and how they work. Many
    real-world social networks share very similar characteristics, and there's a lot
    to be learned from sociology as well. These structures have always defined us
    but never more so than now. Being able to effectively analyze social networks,
    and the insights we can get from them, can be a useful and effective part of our
    toolkit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们成功地学到了很多关于网络及其工作原理的知识。许多现实世界的社交网络具有非常相似的特征，同时社会学也有很多值得学习的地方。这些结构始终在定义着我们，但从未像现在这样重要。能够有效地分析社交网络，并从中获得洞见，可以成为我们工具箱中一个有用且有效的部分。
- en: In the next chapter, we'll look at using geographical analysis and applying
    that to weather data.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用地理分析并将其应用于气象数据。
