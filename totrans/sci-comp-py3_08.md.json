["```py\nclass RationalNumber: \n      pass\n```", "```py\nr = RationalNumber()\n```", "```py\nif isinstance(a, RationalNumber):\n    print('Indeed it belongs to the class RationalNumber')  \n```", "```py\nclass RationalNumber:\n    def __init__(self, numerator, denominator):\n        self.numerator = numerator\n        self.denominator = denominator\n```", "```py\nq = RationalNumber(10, 20)    # Defines a new object\nq.numerator    # returns 10\nq.denominator    # returns 20\n```", "```py\n<object>.attribute\n```", "```py\nq = RationalNumber(3, 5) # instantiation\nq.numerator     # attribute access\nq.denominator\n\na = array([1, 2])    # instantiation\na.shape\n\nz = 5 + 4j    # instantiation\nz.imag\n```", "```py\nq = RationalNumber(3, 5) \nr = RationalNumber(7, 3)\nq.numerator = 17\ndel r.denominator\n```", "```py\n<object>.method(<arguments...>)\n```", "```py\nclass RationalNumber:\n...\n    def convert2float(self):\n        return float(self.numerator) / float(self.denominator)\n```", "```py\nq = RationalNumber(10, 20)    # Defines a new object\nq.convert2float() # returns 0.5   \n```", "```py\nRationalNumber.convert2float(q)\n```", "```py\nTypeError: convert2float() takes exactly 1 argument (2 given)\n```", "```py\nclass RationalNumber:\n ...\n    def __repr__(self):\n        return '{} / {}'.format(self.numerator,self.denominator)\n```", "```py\nclass RationalNumber:\n...\n    def add(self, other):\n        p1, q1 = self.numerator, self.denominator\n        if isinstance(other, int):\n            p2, q2 = other, 1\n        else:\n            p2, q2 = other.numerator, other.denominator\n        return RationalNumber(p1 * q2 + p2 * q1, q1 * q2)\n```", "```py\nq = RationalNumber(1, 2)\np = RationalNumber(1, 3)\nq.add(p)   # returns the RationalNumber for 5/6\n```", "```py\nq = RationalNumber(1, 2)\np = RationalNumber(1, 3)\nq + p # RationalNumber(5, 6)\n```", "```py\nclass RationalNumber:\n...\n    def __eq__(self, other):\n        return self.denominator * other.numerator == \n            self.numerator * other.denominator\n```", "```py\np = RationalNumber(1, 2) # instantiation\nq = RationalNumber(2, 4) # instantiation\np == q # True\n```", "```py\np = RationalNumber(1, 2) # instantiation\np + 5  # corresponds to p.__add__(5)  \n5 + p  # returns an error\n```", "```py\nclass RationalNumber:\n   ....\n    def __radd__(self, other):\n        return self + other\n```", "```py\nclass Polynomial:\n...\n    def __call__(self, x):\n        return self.eval(x)\n```", "```py\np = Polynomial(...)\np(3.) # value of p at 3.\n```", "```py\nimport itertools\n\nclass  Recursion3Term:\n    def __init__(self, a0, a1, u0, u1):\n        self.coeff = [a1, a0]\n        self.initial = [u1, u0]\n    def __iter__(self):\n        u1, u0 = self.initial\n        yield u0  # (see also Iterators section in Chapter 9) \n        yield u1\n        a1, a0 = self.coeff\n        while True :\n            u1, u0 = a1 * u1 + a0 * u0, u1\n            yield u1\n    def __getitem__(self, k):\n        return list(itertools.islice(self, k, k + 1))[0]\n```", "```py\nr3 = Recursion3Term(-0.35, 1.2, 1, 1)\nfor i, r in enumerate(r3):\n    if i == 7:\n        print(r)  # returns 0.194167\n        break\n```", "```py\nr3[7] # returns 0.194167\n```", "```py\nclass Triangle:\n    def __init__(self,  A, B, C):\n        self.A = array(A)\n        self.B = array(B)\n        self.C = array(C)\n        self.a = self.C - self.B\n        self.b = self.C - self.A\n        self.c = self.B - self.A\n    def area(self):\n        return abs(cross(self.b, self.c)) / 2\n```", "```py\ntr = Triangle([0., 0.], [1., 0.], [0., 1.])\n```", "```py\ntr.area() # returns 0.5\n```", "```py\ntr.B = [12., 0.]\ntr.area() # still returns 0.5, should be 6 instead.\n```", "```py\nattribute = property(fget = get_attr, fset = set_attr, \n                     fdel = del_attr, doc = string)\n```", "```py\nB = property(fget = get_B, fset = set_B, fdel = del_B, doc = ’The point B of a triangle’)\n```", "```py\ntr.B = <something>\n```", "```py\nclass Triangle:\n    def __init__(self, A, B, C):\n        self._A = array(A)\n        self._B = array(B)\n        self._C = array(C)\n        self._a = self._C - self._B\n        self._b = self._C - self._A\n        self._c = self._B - self._A\n    def area(self):\n        return abs(cross(self._c, self._b)) / 2.\n    def set_B(self, B):\n        self._B = B\n        self._a = self._C - self._B\n        self._c = self._B - self._A\n    def get_B(self):\n        return self._B\n    def del_Pt(self):\n        raise Exception('A triangle point cannot be deleted')\n    B = property(fget = get_B, fset = set_B, fdel = del_Pt)\n```", "```py\ntr.B = [12., 0.]\ntr.area() # returns 6.0\n```", "```py\ndel tr.B # raises an exception\n```", "```py\nclass A:\n    def func(self,arg):\n        pass\n```", "```py\nA.func  # <unbound method A.func>\ninstA = A()  # we create an instance\ninstA.func  #  <bound method A.func of ... >\n```", "```py\nTypeError: func() missing 1 required positional argument: 'arg'\n```", "```py\nclass Newton:\n    tol = 1e-8 # this is a class attribute\n    def __init__(self,f):\n        self.f = f # this is not a class attribute\n    ....\n```", "```py\nN1 = Newton(f)\nN2 = Newton(g)\n```", "```py\nN1.tol # 1e-8\nN2.tol # 1e-8\n```", "```py\nNewton.tol = 1e-10\nN1.tol # 1e-10\nN2.tol # 1e-10\n```", "```py\nN2.tol = 1.e-4\nN1.tol  # still 1.e-10\n```", "```py\nNewton.tol = 1e-5 # now all instances of the Newton classes have 1e-5\nN1.tol # 1.e-5\nN2.tol # 1e-4 but not N2.\n```", "```py\n@classmethod\n```", "```py\n      class A:\n          def func(self,*args):\n               <...>\n```", "```py\n      class B:\n          @classmethod\n          def func(cls,*args):\n               <...>\n```", "```py\nclass Polynomial:\n    def __init__(self, coeff):\n        self.coeff = array(coeff)\n    @classmethod\n    def by_points(cls, x, y):\n        degree = x.shape[0] - 1\n        coeff = polyfit(x, y, degree)\n        return cls(coeff) \n    def __eq__(self, other):\n        return allclose(self.coeff, other.coeff)\n```", "```py\np1 = Polynomial.by_points(array([0., 1.]), array([0., 1.]))\np2 = Polynomial([1., 0.])\n\nprint(p1 == p2)  # prints True\n```", "```py\nclass OneStepMethod:\n    def __init__(self, f, x0, interval, N):\n        self.f = f\n        self.x0 = x0\n        self.interval = [t0, te] = interval\n        self.grid = linspace(t0, te, N)\n        self.h = (te - t0) / N\n\n    def generate(self):\n        ti, ui = self.grid[0], self.x0\n        yield ti, ui\n        for t in self.grid[1:]:\n            ui = ui + self.h * self.step(self.f, ui, ti)\n            ti = t\n            yield ti, ui\n\n    def solve(self):\n        self.solution = array(list(self.generate()))\n\n    def plot(self):\n        plot(self.solution[:, 0], self.solution[:, 1])\n\n    def step(self, f, u, t):\n        raise NotImplementedError()\n```", "```py\nclass ExplicitEuler(OneStepMethod):\n    def step(self, f, u, t):\n        return f(u, t)\n\nclass MidPointRule(OneStepMethod):\n    def step(self, f, u, t):\n        return f(u + self.h / 2 * f(u, t), t + self.h / 2)\n```", "```py\nclass ExplicitEuler(OneStepMethod)\n```", "```py\ndef f(x, t):\n    return -0.5 * x\n\neuler = ExplicitEuler(f, 15., [0., 10.], 20)\neuler.solve()\neuler.plot()\nhold(True)\nmidpoint = MidPointRule(f, 15., [0., 10.], 20)\n\nmidpoint.solve()\nmidpoint.plot()\n```", "```py\n...\nargument_list = [f, 15., [0., 10.], 20]\neuler = ExplicitEuler(*argument_list)\n...\nmidpoint = MidPointRule(*argument_list)\n...\n```", "```py\nclass ExplicitEuler(OneStepMethod):\n    def __init__(self,*args, **kwargs):\n        self.name='Explicit Euler Method'\n        super(ExplicitEuler, self).__init__(*args,**kwargs)\n    def step(self, f, u, t):\n        return f(u, t)\n```", "```py\nclass Function:\n    def __init__(self, f):\n        self.f = f\n    def __call__(self, x):\n        return self.f(x)\n    def __add__(self, g):\n        def sum(x):\n            return self(x) + g(x)\n        return type(self)(sum) \n    def __mul__(self, g): \n        def prod(x):\n            return self.f(x) * g(x)\n        return type(self)(prod)\n    def __radd__(self, g):\n        return self + g\n    def __rmul__(self, g):\n        return self * g\n```", "```py\nT5 = Function(lambda x: cos(5 * arccos(x)))\nT6 = Function(lambda x: cos(6 * arccos(x)))\n```", "```py\nimport scipy.integrate as sci\n\nweight = Function(lambda x: 1 / sqrt((1 - x ** 2)))\n[integral, errorestimate] = \n        sci.quad(weight * T5 * T6, -1, 1) # (6.510878470473995e-17, 1.3237018925525037e-14)\n```", "```py\nclass echo:\n    text = 'Input parameters of {name}n'+\n        'Positional parameters {args}n'+\n        'Keyword parameters {kwargs}n'\n    def __init__(self, f):\n        self.f = f\n    def __call__(self, *args, **kwargs):\n        print(self.text.format(name = self.f.__name__,\n              args = args, kwargs = kwargs))\n        return self.f(*args, **kwargs)\n```", "```py\n@echo\ndef line(m, b, x):\n    return m * x + b\n```", "```py\nline(2., 5., 3.)\nline(2., 5., x=3.)\n```", "```py\nInput parameters of line\nPositional parameters (2.0, 5.0)\nKeyword parameters {'x': 3.0}\n\n11.0\n```", "```py\nclass CountCalls:\n    \"\"\"\n    Decorator that keeps track of the number of times \n    a function is called.\n    \"\"\"\n    instances = {} \n    def __init__(self, f):\n        self.f = f\n        self.numcalls = 0\n        self.instances[f] = self\n    def __call__(self, *args, **kwargs):\n        self.numcalls += 1\n        return self.f(*args, **kwargs)\n    @classmethod\n    def counts(cls):\n        \"\"\"\n        Return a dict of {function: # of calls} for all \n        registered functions.\n        \"\"\"\n        return dict([(f.__name__, cls.instances[f].numcalls) \n                                    for f in cls.instances])\n```", "```py\n@CountCalls\ndef line(m, b, x):\n    return m * x + b\n@CountCalls \ndef parabola(a, b, c, x):\n    return a * x ** 2 + b * x + c\nline(3., -1., 1.)\nparabola(4., 5., -1., 2.)\n\nCountCalls.counts() # returns {'line': 1, 'parabola': 1}\nparabola.numcalls # returns 1\n```", "```py\nclass RationalNumber:\n    ....\n    def __radd__(self, other):\n        return other + self\n```", "```py\nq = RationalNumber(10, 15)\n5 + q\n```"]