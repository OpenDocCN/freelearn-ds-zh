- en: Chapter 5. Vector Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Clipping LineStrings to an area of interest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting polygons with lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the location of a point on a line using linear referencing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snapping a point to the nearest line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating 3D ground distance and total elevation gain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vector data analysis is used in many, many application areas, starting from
    measuring the distance from point A to point B all the way through to complex
    routing algorithms. The first GIS systems were built on vector data and vector
    analysis, and then later expanded into the raster domain. In this chapter, we
    will start with simple vector operations, then work our way into a more complex
    model, chaining the various vector methods together to deliver new data that answers
    our spatial questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of data analysis is broken down into a couple of steps starting
    with an *input* dataset, performing a *spatial operation* on the data such as
    a buffer analysis, and, finally, we''ll have some *output* in the form of a new
    dataset. The following diagram shows the flow of analysis in the simplest model
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B03543_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Converting simple questions into spatial operation methods and models takes
    experience and is not a simple task. For example, you may come across a simple
    task such as, "Identify and locate how many residential land parcels were affected
    by the flood." This would translate into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, an input dataset in the form of a flood polygon that defines the affected
    floods areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, the input dataset represents cadaster polygons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our spatial operation is an intersection function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this results in a new polygon dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This would result in a spatial model that could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B03543_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To tackle more complex questions, spatial modeling simply starts chaining more
    inputs along with more operations that output new data feeding into other new
    operations. This then leads us to a final set or sets of data.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping LineStrings to an area of interest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A project involving spatial data is typically geographically limited to within
    a specified boundary area, the so-called *project area*. The input data can come
    from multiple sources and usually extends outside the project area. Removing this
    excess data is sometimes critical to speed up spatial processes, and at the same
    time, it reduces data volume. Reductions in data volumes can also result in secondary
    speed-ups, for example, less time to transfer or copy the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a boundary polygon represented by a circle Shapefile,
    and then remove all excess LineStrings that are outside this circle.
  prefs: []
  type: TYPE_NORMAL
- en: This process of clipping will remove all lines outside the clip area—that is,
    our project area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A standard function called `clip` performs an intersection spatial operation.
    This is slightly different from a normal intersection function. The clip will
    NOT or should not retain the attributes attached to the clip area. Clipping involves
    two input datasets; the first defines the boundary that we want to clip our data
    to, and the second defines the data that will be clipped. Both sets contain attributes
    and these attributes of the clipping boundary are usually not included in a clip
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The new clipped data will only have the attributes from the original input dataset,
    excluding all the attributes from the clip polygon.
  prefs: []
  type: TYPE_NORMAL
- en: An `intersection` function will find geometries that overlap and output only
    lines within a circle. To demonstrate this concept better, the following graphical
    representation shows what we are going to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate a simple clip operation, we will take a single LineString and
    polygon defining a clip boundary and perform a quick intersect. The result will
    look like what's represented in the following screenshot and can be viewed as
    a live web map in your browser. Refer to the HTML file located at `/code/html/ch05-01-clipping.html`
    to check out the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Clipping LineStrings to an area of interest](img/B03543_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When running the simple `intersection` function, the line is cut into two new
    LineStrings as in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Our second result will use two Shapefiles that represent our inputs. Our real
    data from `OpenStreetMapconverted` is converted to a Shapefile format for our
    input and output. The circle defines our polygon area of interest, while the road
    LineStrings are what we want to clip. Our result will be in the form of a new
    Shapefile that only shows the roads that are inside the circle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is in two parts. The first part is a simple clip demonstration using
    two GeoJSON files consisting of a single LineString and polygon. The second part
    uses data from OSM and can be found in your `/ch05/geodata` folder containing
    the circle polygon that represents our area of interest named `clip_area_3857.shp`.
    The `roads_london_3857.shp` file represents our input Shapefile of lines that
    we will clip to the circle polygon.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the first part, we use the leaflet JavaScript library in a very
    basic HTML page. Our second resulting Shapefile can then be opened with QGIS to
    see the resulting clipped set of roads.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two sets of code examples ahead of us. The first is a simple self-made
    set of GeoJSON inputs that are clipped and outputted as a GeoJSON representation.
    This is then visualized using a web page with the help of Leaflet JS.
  prefs: []
  type: TYPE_NORMAL
- en: The second code example takes in two Shapefiles and returns a clipped Shapefile
    that you can view using QGIS. Both examples use the same method and demonstrate
    how a clipping function works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the first code example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This ends our first code demonstration using a simple self-made GeoJSON LineString
    that's clipped to a simple polygon. This quick recipe is found in the `/code/ch05-01-1_clipping_simple.py`
    file. After you run this file, you can go ahead and open the `/code/html/ch05-01-clipping.html`
    file in your local web browser to see the results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It works by defining an output JavaScript file that is used to visualize our
    clipped results. This is followed by our input clipping areas and the LineString
    to be clipped as GeoJSON. We'll convert our GeoJSON to shapely geometry objects
    with the `ashape()` function so that we can run the intersection. The resulting
    intersection geometry is then converted from a shapely geometry into a GeoJSON
    file that is written to our output JavaScript file, which is used inside the `.html`
    file for visualization with Leaflet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To begin our second code example located in the `/code/ch05-01-2_clipping.py`
    file, we will input two Shapefiles, create a new set of roads that are clipped
    to our circle polygon, and export them as Shapefiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll use Shapely for our spatial operation and pyshp to read
    in and out of our Shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin with the import of the road LineStrings and our circle polygon for
    the demo project area. We'll use the `pyshp` module to handle the Shapefile input/output.
    `Pyshp` allows us to access the Shapefile bounds, feature geometry, feature attributes,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to convert the `pyshp` geometry object into something that
    `Shapely` can understand. We'll use the `shape()` function to get the `pyshp`
    geometry followed by the Shapely `asShape()` function. Next, we'll want all the
    records of roads so that we can use `shapeRecords()` to return these records for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll get ourselves ready to perform the actual clipping by setting up
    two list variables to store our new data. The *for* loop runs over each record,
    that is, each line in the road dataset, converts it to a shapely geometry object
    using `geo_interface,` and is built in the pyshp function. This is then followed
    by the actual `intersection` shapely function that only returns geometry that
    *intersects* our circle. Finally, we'll check to see if the intersection geometry
    is a LineString. If it is, we'll append it to our output list.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During an intersection operation, Shapely will return points and LineStrings
    in a geometry collection. The reason for this is that, if two LineStrings touch
    at the ends, for example, or overlap each other, it will generate a point intersection
    location plus any overlapping segments.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we can write out our new dataset to a new Shapefile. Using the pyshp
    `writer()` function, we create a new object and give it one single field called
    `name`. Looping through each feature, we can create a GeoJSON object using the
    shapely mapping function and an empty pyhsp record that we will add to it in a
    moment. We want to add the point coordinates from our GeoJSON and append them
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting the loop, we'll save our new Shapefile `roads_clipped.shp` to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting polygons with lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, in GIS, we work with data that influences other data in some form
    due to their inherit spatial relationship. This means that we need to work with
    one dataset to edit, update, and even delete another dataset. A typical example
    of this is an administrative boundary, which is a polygon that you cannot see
    on a physical surface but that influences feature information it crosses such
    as a lake. If we have a lake polygon and an administrative boundary, we might
    want to know how many square meters of lake belongs to each administrative boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Another example could be a forest polygon that contains one species of trees
    that crosses a river. We might want to know the area on either side of the river.
    In the first scenario, we need to transform our administrative boundaries into
    LineStrings and then perform the cut.
  prefs: []
  type: TYPE_NORMAL
- en: To see what this looks like, take a look at this spoiler on how the results
    will look up front since we all like a good visual.
  prefs: []
  type: TYPE_NORMAL
- en: '![Splitting polygons with lines](img/B03543_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will once again use our GeoJSON LineString and polygon from
    the previous recipe. These homemade geometries will cut up our polygon into three
    new polygons. Be sure to fire up your virtual environment with the `workon pygeoan_cb`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code example is located at `/code/ch05-02_split_poly_with_line.py` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now the actual splitting of the polygons takes place in our `/ch05/code/ch05-02_split_poly_with_line.py`
    script.
  prefs: []
  type: TYPE_NORMAL
- en: The basic methodology to split a polygon based on a LineString follows this
    simple algorithm. First, we'll take our input polygon and convert the boundaries
    of this polygon into a new LineString dataset. Next up, we'll combine the LineString
    we want to use to cut the newly generated polygon LineStrings of boundaries. Finally,
    we use the `polygonize` method to rebuild polygons based on the new union set
    of LineStrings.
  prefs: []
  type: TYPE_NORMAL
- en: This rebuilding of polygons results in extra polygons that are created outside
    the original polygon. To identify these polygons, we'll use a simple trick. We
    can simply generate a `centroid` point inside each newly created polygon and then
    check to see if this point is inside the original polygon using the `within` predicate.
    If the point is not inside the original polygon, the predicate returns `False`
    and we do not need to include this polygon in our output.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the location of a point on a line using linear referencing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of linear referencing is widespread, ranging from storing bus routes
    to oil and gas pipelines. Our ability to locate any position along a line based
    on a distance value from the start of the line is done using the interpolation
    methodology. We want to interpolate a point location at any position along a line.
    To determine the position, we'll use simple mathematics to calculate the position
    along a line based on the distance from the starting coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: For our calculation, we'll measure the length of the line and find a coordinate
    located at a specified length from the start of the line. However, the question
    of where the start of the line is will soon arise. The starting point of the line
    is the first coordinate in the LineString's array of vertexes that make up the
    LineString because a LineString is nothing more than a collection of points chained
    together.
  prefs: []
  type: TYPE_NORMAL
- en: This will lead nicely to our next recipe, which is a little more complex.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is our shortest code snippet; check it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the `/code/ch05-03_point_on_line.py` file, you should see the
    following screenshot when you open the `/code/html/ch05-03.html` file in your
    web browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/B03543_05_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If you would like to reverse the LineString starting and ending points, you
    can use the `list(shply_line.coords)[::-1]` code to reverse the coordinate order
    as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It all boils down to executing one single line of code to locate a point on
    a line specified at a certain distance. The shapely interpolate function does
    this for us. All you need is the shapely LineString geometry and a distance value.
    The distance value is the distance from the 0,0 start coordinate of the LineString.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful in case the LineString direction is not the correct form in which
    you want to measure it. This would mean that you need to switch the LineString
    direction. Take a look at the `line_reversed` variable that holds the original
    LineString with a reversed order. To do the `reverse`, we'll use a simple python
    string operation, `[::-1]`, to reverse our LineString list.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action with our print statement reversing the LineString
    order on screen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are interested in more information regarding linear referencing, ESRI
    has a great reference of use cases and examples at [http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm](http://resources.arcgis.com/en/help/main/10.1/0039/003900000001000000.htm)
    and [http://en.wikipedia.org/wiki/Linear_referencin](http://en.wikipedia.org/wiki/Linear_referencin).
  prefs: []
  type: TYPE_NORMAL
- en: Snapping a point to the nearest line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on our newly gained wisdom from the last recipe, we will now attack
    another common spatial problem. This super common spatial task is for all the
    GPS junkies who want their GPS coordinates to snap to an existing road. Imagine
    that you have some GPS tracks and you want to have these coordinates snap to your
    base road dataset. To accomplish such a task, we need to snap a point (GPS coordinates)
    to a line (roads).
  prefs: []
  type: TYPE_NORMAL
- en: The `geos` library is what `Shapely` is built on and can handle this problem
    with ease. We will combine the use of the `shapely.interpolate` and `shapely.project`
    functions to snap our point to the true nearest point on the line using linear
    referencing.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following diagram, our input point is located on the sun
    icon. The green line is what we want to snap our point to at the nearest location.
    The gray icon with a point on it is our result that represents the nearest point
    on the line from our original x position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Snapping a point to the nearest line](img/B03543_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shapely is well suited for snapping a point to the nearest line, so let''s
    get started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use a tried and tested methodology called **linear referencing** to
    do the work. Let''s kick it off with the imports needed to do this, including
    `shapely.geometry asShape`, `json`, and `pyproj`'' Pyproj is used to quickly transform
    our coordinates to and from EPSG: 4326 and EPSG 3857\. Shapely works on planar
    coordinates and cannot work directly with `lat`/`lon` values.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending our functions from the last recipe, we have the `transform_point()`
    function alongside the `transform_geom()` function. The `transform_point()` function
    converts a Shapely geometry to GeoJSON and transforms the point coordinate, while
    the `transform_geom()` function takes GeoJSON in and transforms it to the new
    coordinate system. Both functions use pyproj to execute the transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll define our output GeoJSON file and the input line and point features.
    Then, we'll execute our two new transform functions followed closely with the
    conversion into a Shapely geometry object. This new Shapely geometry is then run
    through the interpolate function.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolate alone does not answer our question. We need to combine its usage
    with the Shapely `project` function that takes in the original point and projects
    it onto the line.
  prefs: []
  type: TYPE_NORMAL
- en: We then print out our results to screen and create a new JavaScript file called
    `/geodata/ch05-04-geojson.js,` used in our `/code/html/ch05-04.html` for viewing.
    Go ahead and open the HTML file in your browser to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at your console to see the print to console statements that show
    us the point coordinates and distances from the original as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Calculating 3D ground distance and total elevation gain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finished finding points on lines and returning points on a line, so now,
    it is time to calculate the true ground 3D distance that we actually ran or biked
    along a real 3D road. It is also possible to calculate the elevation profile and
    we will see this in the [Chapter 7](ch07.html "Chapter 7. Raster Analysis"), *Raster
    Analysis*.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the ground distance sounds easy, but 3D calculations are more complicated
    to calculate than 2D. Our 3D LineString has a z-coordinate for each vertex that
    makes up our LineString. Therefore, we need to calculate the 3D distance between
    each set of coordinates, —that is, from vertex to vertex in our input LineString.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mathematics to calculate the distance between two 3D Cartesian coordinates
    is relatively simple and uses the 3D form of the Pythagoras formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3d_distance = square root √ ( (x2 – x1) ² + (y2 – y1) ² + (z2 -z1)²)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First up, we will get our hands on some 3D data to play with and what better
    to analyze than the Stage 16 Carcassonne/Bagnères-de-Luchon of the Tour de France
    2014 mountain stage, a real killer. Here are some stats from [www.letour.com](http://www.letour.com),
    including the 237.5 km length, Michael Rogers' winning time of 6:07:10, the average
    speed of 38.811 km/h, and the highest point of 1753 m. You will find the data
    in your folder at `/ch05/geodata/velowire_stage_16_27563_utf8.geojson`.
  prefs: []
  type: TYPE_NORMAL
- en: The original KML was generously provided by Thomas Vergouwen ([www.velowire.com](http://www.velowire.com))
    and it is free for us to use with his permission; thanks, Thomas. The original
    data is located at `/ch05/geodata/velowire_stage_16-Carcassonne-Bagneres-de-Luchon.kml`.
    The conversion to *GeoJSON* and the transformation to EPSG:27563 was done using
    the QGIS `save as` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, according to the LA Times web page ([http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html](http://www.latimes.com/la-sp-g-tour-de-france-stage-elevation-profile-20140722-htmlstory.html)),
    they've quoted a 3895 m elevation gain. As compared to team Strava ([http://blog.strava.com/tour-de-france-2014/](http://blog.strava.com/tour-de-france-2014/))
    where they've stated a 4715 m elevation gain. Now, who is correct and is this
    237.5 km ground distance in 3D? Let's find out!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the official profile of Stage 16 for your visual pleasure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B03543_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To give you an idea of what accurate and simplified data looks like, take a
    look at this comparison of the velowire''s site''s ([www.velowire.com](http://www.velowire.com))
    KML marked in purple (accurate) and the bikemap site''s progression highlighted
    by yellow line (simplified). If you sum up the differences, the length and elevation
    are both significantly different for both. For a race that''s 237.5 km long, every
    meter counts when you''re planning and attacking on the course. In the following
    screenshot, you can see the comparison of the velowire site''s KML marked in purple
    and the bikemap site''s progression highlighted by the yellow line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/B03543_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Data source: [http://www.mapcycle.com.au/LeTour2014/#](http://www.mapcycle.com.au/LeTour2014/#)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with looping through each vertex and calculating the 3D distance
    from one vertex to another in our LineString. Each vertex is nothing more than
    a point with *x*, *y*, and *z* (3D Cartesian) values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to calculate each vertex:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to transform our original KML file stored in EPSG: 4326 to a planar
    coordinate system to facilitate our calculations (refer to the upcoming table).
    So, we''ll begin by transforming the KML into EPSG: 27563 NTF Paris / Lambert
    Sud France. For further information on this, refer to [http://epsg.io/27563](http://epsg.io/27563).'
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we'll define three functions for our calculations starting with
    the `pairs()` function that takes a list and then uses the Python yield generator
    function to yield two sets of values. The first set of values is the starting
    x, y, and z coordinates, and the second set includes the ending x, y, and z coordinates
    of the coordinate pairs that we want to measure.
  prefs: []
  type: TYPE_NORMAL
- en: The `calc_3d_distancte_2pts()` function takes the two coordinate pairs, including
    the important z value, and calculates the distance between two points in 3D space
    using the Pythagorean theorem.
  prefs: []
  type: TYPE_NORMAL
- en: Our `readin_json()` function inputs a path to a file, and in this case, we can
    point it to our GeoJSON file stored in the `/ch05/geodata` folder. This will return
    a Python dictionary object for us to work with within the next few steps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's define the variables to hold our GeoJSON file, load this file, and
    set the starting 3D/2D lengths to zero for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let's iterate through the GeoJSON LineString features and convert them
    into a Shapely object so that we can use Shapely to tell us the inherent 2D length
    as used by our `length_2d` variable and read the coordinates. This is followed
    by our `for` loop where all the action occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over our new list created by our `pairs()` function, we can loop over
    each vertex of a LineString. We define the `line_start` and `line_end` variables
    to identify the start of each new line segment that we need to access with a single
    LineString feature. We'll follow up by then defining our input parameters to do
    the 3D distance calculations by parsing our list object with standard Python positional
    slicing. At last, we'll call the `calc_3d_distance_2pts()` function to give us
    our distance in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: We need to iteratively sum the distances together from one segment to the next.
    We can do this by adding the distance to our `length_3d` with `+=` operator. Now,
    our `length_3d` variable is updated for each segment in the loop, giving us our
    desired 3D length.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of the loop calculates our elevation gain. Our `z1` and `z2`
    elevation values need to be constantly compared to additively add the total elevation
    gain only if the next value is greater than the last. If not, set them to equal
    each other and continue to the next *z* value. The `elevation_gain` variable is
    then constantly updated to itself if there's no change; otherwise not, the difference
    between the two elevations is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we''ll print out our results to the screen; they should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With our data transformed and converted to GeoJSON, the 2D length according
    to our script is 243.558 km from the velowire KML as compared to 237.5 km from
    the official race page, which is a difference of 6.058 km. The original KML in
    EPSG:4326 was 302.805 km long, a difference of over 65 km, hence the necessary
    transformation. For a better comparison, take a look at this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Source + EPSG | 2D length | 3D length | Difference |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Velowire EPSG:4326 | 302.805 km | This is not calculated |   |'
  prefs: []
  type: TYPE_TB
- en: '| **Velowire EPSG:27563** | **243.558 km** | **244.12** | **561.14 m** |'
  prefs: []
  type: TYPE_TB
- en: '| Mapcycle EPSG:4326 | 293.473 km | This data is not available |   |'
  prefs: []
  type: TYPE_TB
- en: '| Mapcylce EPSG:27563 | 236.216 km | This data is not available |   |'
  prefs: []
  type: TYPE_TB
- en: '| Letour official | 237.500 km (approximate) | 237.500 km (approximate) |  
    |'
  prefs: []
  type: TYPE_TB
- en: The elevation gain is also very different between different sources.
  prefs: []
  type: TYPE_NORMAL
- en: '| Source | Elevation gain |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Strava ([http://blog.strava.com/](http://blog.strava.com/)) | 4715 m |'
  prefs: []
  type: TYPE_TB
- en: '| Los Angeles Times | 3895 m |'
  prefs: []
  type: TYPE_TB
- en: '| TrainingPeaks ([www.trainingpeaks.com](http://www.trainingpeaks.com)) | 3243
    m |'
  prefs: []
  type: TYPE_TB
- en: '| The Velowire KML data analysis | 4322 m |'
  prefs: []
  type: TYPE_TB
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The accuracy of all these calculations is based on the original KML data source.
    Each data source is/was derived by different people and, possibly, different methods.
    The more you know about your data source, the more you know about its accuracy.
    In this case, I assume that the Velowire data source was digitized by hand using
    Google Earth. Thus, the accuracy is only as accurate as that of the underlying
    Google Earth imagery and coordinate system, which is EPSG:3857.
  prefs: []
  type: TYPE_NORMAL
