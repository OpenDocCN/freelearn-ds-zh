- en: Vector Data Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量数据分析
- en: This chapter will cover geospatial analysis and processing of vector data. The
    following three Python libraries will be covered—Shapely, OGR, and GeoPandas.
    The reader will learn how to use these Python libraries to perform geospatial
    analysis, including the writing of basic and advanced analysis scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖地理空间分析和处理向量数据。以下三个 Python 库将被介绍——Shapely、OGR 和 GeoPandas。读者将学习如何使用这些 Python
    库进行地理空间分析，包括编写基本和高级分析脚本。
- en: Each library is covered separately, with an overview of its data structures,
    methods, and classes where appropriate. We'll discuss the best use cases for each
    library and how to use them together for geospatial workflows. Short example scripts
    illustrate how to perform the basic geographical analysis. The GeoPandas library
    enables more complex functionality for doing data science tasks and incorporating
    geospatial analysis.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都将单独介绍，其中适当的地方将概述其数据结构、方法和类。我们将讨论每个库的最佳用例以及如何将它们结合起来用于地理空间工作流程。简短的示例脚本将说明如何执行基本的地理分析。GeoPandas
    库为执行数据科学任务和结合地理空间分析提供了更复杂的功能。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reading and writing vector data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入向量数据
- en: Creating and manipulating vector data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作向量数据
- en: Visualizing (plotting) vector data on a map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上可视化（绘图）向量数据
- en: Working with map projections and reproject data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理地图投影和重新投影数据
- en: Performing spatial operations such as spatial joins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行空间操作，如空间连接
- en: Working with vector geometries and attribute data in tabular form
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表格形式中处理向量几何和属性数据
- en: Analyzing the results to answer questions, such as how many wildfires are there
    in area x?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析结果以回答问题，例如在区域 x 中有多少次野火？
- en: After this chapter, you'll have a solid foundation to start working with geospatial
    vector data. You'll know the characteristics and use cases of all three geospatial
    libraries, and know how to do basic vector data processing and analysis.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你将拥有一个坚实的基础，开始处理地理空间向量数据。你将了解所有三个地理空间库的特点和应用场景，并知道如何进行基本的向量数据处理和分析。
- en: OGR Simple Features Library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OGR 简单特征库
- en: '**OGR Simple Features Library** (part of the **Geospatial Data Abstraction
    Library** (**GDAL**)) offers a set of tools for dealing with vector data. Although
    both GDAL and OGR are now more integrated than they used to be, we can still divide
    GDAL between a vector part (OGR) and a raster part (GDAL). While OGR was written
    in C++ and the documentation is also in C++, with Python bindings we can access
    all of GDAL''s functionality using Python.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**OGR 简单特征库**（属于**地理空间数据抽象库**（**GDAL**）的一部分）提供了一套处理向量数据的工具。尽管 GDAL 和 OGR 现在比以前更加集成，但我们仍然可以将
    GDAL 区分为向量部分（OGR）和栅格部分（GDAL）。虽然 OGR 是用 C++ 编写的，文档也是用 C++ 编写的，但通过 Python 绑定，我们可以使用
    Python 访问 GDAL 的所有功能。'
- en: 'We can distinguish the following components of OGR:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分以下 OGR 的组成部分：
- en: OGR batch commands for describing and processing vector data
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于描述和处理向量数据的 OGR 批处理命令
- en: '`ogrmerge`, an instant Python script for merging multiple vector data files'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ogrmerge`，一个用于合并多个向量数据文件的即时 Python 脚本'
- en: The OGR library itself
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OGR 库本身
- en: We'll briefly cover these components first, before moving on to some examples
    of how to use all three.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍一些如何使用这三个库的示例之前，我们将简要介绍这些组件。
- en: OGR batch commands
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OGR 批处理命令
- en: 'OGR offers a series of batch commands that can be used to describe and convert
    existing geospatial vector data. We''ve already mentioned two of them, `ogrinfo`
    and `ogr2ogr`, in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OGR 提供了一系列批处理命令，可用于描述和转换现有的地理空间向量数据。我们已经在[第 4 章](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml)，*数据类型、存储和转换*中提到了其中两个，`ogrinfo`和`ogr2ogr`：
- en: '`ogrinfo` can be used for doing all sorts of reporting on vector data, such
    as listing supported vector formats, available layers, and summary details, and
    can be combined with SQL-query syntax to select features from a dataset.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ogrinfo`可用于对向量数据进行各种报告，例如列出支持的向量格式、可用图层和摘要细节，并且可以与SQL查询语法结合，从数据集中选择特征。'
- en: '`ogr2ogr` is for doing vector data translations, such as converting vector
    files between different formats, converting multiple layers into a new data source,
    and reproject vector data and filter features based on location. It can also be
    used with SQL-query syntax just like `ogrinfo`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ogr2ogr`用于执行矢量数据转换，例如在不同格式之间转换矢量文件，将多个图层转换为新的数据源，以及根据位置重新投影矢量数据和过滤特征。它也可以像`ogrinfo`一样使用SQL查询语法。'
- en: These are very powerful commands that let you do a lot of work. It is recommended
    you familiarize yourself with these commands when working with vector data. We'll
    get to some examples shortly.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常强大的命令，可以让您完成大量工作。建议您在工作处理矢量数据时熟悉这些命令。我们很快会提供一些示例。
- en: Additionally, two other batch commands exist for creating vector tiles, `ogrtindex`
    and `ogr2vrt`. The difference between the two is that the second one is more broadly
    usable than the first. The second command needs to be imported from an online
    script as it is not distributed with recent GDAL versions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个用于创建矢量瓦片的批处理命令，`ogrtindex`和`ogr2vrt`。这两个命令之间的区别在于，第二个命令比第一个命令更通用。第二个命令需要从在线脚本中导入，因为它不包括在最近的GDAL版本中。
- en: ogrmerge
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ogrmerge
- en: 'Along with the installation of GDAL comes a set of Python scripts that can
    be used for specialized geospatial tasks. These scripts can be run directly from
    a Jupyter Notebook or terminal, along with a specified dataset. You can find all
    of the scripts inside of the `scripts` directory of your local `gdal` file folder,
    which on a Windows machine might be similar to the following path:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着GDAL的安装，还附带了一套Python脚本，可用于专门的地理空间任务。这些脚本可以直接从Jupyter Notebook或终端运行，并指定数据集。您可以在本地`gdal`文件文件夹的`scripts`目录中找到所有这些脚本，在Windows机器上可能类似于以下路径：
- en: '`C:\Users\Username\Anaconda3\pkgs\gdal-2.2.2-py36_1\scripts`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\Users\Username\Anaconda3\pkgs\gdal-2.2.2-py36_1\scripts`'
- en: As you can see from the list of Python scripts in this folder, almost all of
    them are for GDAL rather than OGR. All of these Python scripts can be run from
    a Jupyter Notebook or a terminal. Using a Jupyter Notebook, you can use the magic
    command `%run` to execute your Python script, whereas using a terminal you'd use
    `python` followed by the name of the script and the input/output data files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从该文件夹中的Python脚本列表中看到的，几乎所有的脚本都是针对GDAL而不是OGR的。所有这些Python脚本都可以从Jupyter Notebook或终端运行。使用Jupyter
    Notebook，您可以使用魔法命令`%run`来执行Python脚本，而使用终端，您将使用`python`后跟脚本名称和输入/输出数据文件。
- en: Magic commands are commands that extend the core Python language and can only
    be used in the Jupyter Notebook application. They offer useful shortcuts, for
    example, inserting code from an external script, and executing Python code from
    `.py` files on disc or `shell` commands. A full list of magic commands can be
    printed with the following command in an empty cell, `%lsmagic`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法命令是扩展核心Python语言的命令，并且只能在Jupyter Notebook应用程序中使用。它们提供了有用的快捷方式，例如，从外部脚本插入代码，以及从磁盘上的`.py`文件或`shell`命令中执行Python代码。可以使用以下命令在空单元格中打印出所有魔法命令的完整列表：%lsmagic。
- en: 'The following example uses `ogrmerge.py`, a Python script available with GDAL
    version 2.2.2 and higher. Running this script from a Jupyter Notebook, it takes
    all shapefiles in a single folder from the Earth dataset and merges them into
    a single GeoPackage file called `merged.gpkg`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`ogrmerge.py`，这是GDAL 2.2.2及更高版本中可用的一个Python脚本。从Jupyter Notebook中运行此脚本，它将地球数据集中单个文件夹中的所有shapefile合并成一个名为`merged.gpkg`的单个GeoPackage文件：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that in order to run one of the Python scripts in the GDAL directory
    correctly, you need to reference their file location if it's located in a different
    folder than the one where you're running the script, which is likely to be the
    case if you're working with the Jupyter Notebook application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了正确运行GDAL目录中的一个Python脚本，如果您在运行脚本的不同文件夹中，需要参考它们的文件位置，如果您在使用Jupyter Notebook应用程序工作，这种情况很可能是这样。
- en: The OGR library and Python bindings
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OGR库和Python绑定
- en: The `OGR` library, combined with its Python bindings, forms the most important
    part for working with vector data in Python. With it, you can create points, lines,
    and polygons, and perform spatial operations on these elements. For example, you
    can calculate the area of a geometry, overlay different data on top of each other,
    and use proximity tools such as buffers. Additionally, just as with `ogrinfo`
    and `ogr2ogr`, the OGR library offers tools to read vector data files, iterate
    over individual elements, and select and reproject data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`OGR` 库及其 Python 绑定结合在一起，是使用 Python 处理矢量数据最重要的部分。有了它，你可以创建点、线和多边形，并对这些元素执行空间操作。例如，你可以计算几何形状的面积，将不同的数据叠加在一起，并使用如缓冲区之类的邻近工具。此外，就像
    `ogrinfo` 和 `ogr2ogr` 一样，OGR 库提供了读取矢量数据文件、遍历单个元素以及选择和重新投影数据的工具。'
- en: OGR's main modules and classes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OGR 的主要模块和类
- en: The OGR library consists of two main modules—`ogr` and `osr`. Both are sub-modules
    inside of the `osgeo` module. The `ogr` sub-module deals with vector geometry,
    while `osr` is all about projections. In the *Reading and writing vector data
    with OGR* section in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*, we already saw some examples of how to make use
    of both.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OGR 库由两个主要模块组成——`ogr` 和 `osr`。这两个都是 `osgeo` 模块内的子模块。`ogr` 子模块处理矢量几何，而 `osr`
    则全部关于投影。在 [第 4 章](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml) 的 *使用 OGR 读取和写入矢量数据*
    部分，*数据类型、存储和转换*，我们已经看到了一些如何利用这两个模块的例子。
- en: 'OGR offers the following seven classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OGR 提供以下七个类：
- en: '`Geometry`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`几何形状`'
- en: '`Spatial Reference`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`空间参考`'
- en: '`Feature`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`要素`'
- en: '`Feature Class Definition`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`要素类定义`'
- en: '`Layer`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图层`'
- en: '`Dataset`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据集`'
- en: '`Drivers`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`驱动程序`'
- en: The class names are mostly self-explanatory, but it's good to have an overview
    of how OGR is structured. In the following examples, we'll see how to access and
    make use of these classes. OGR's modules, classes, and functions are documented
    on the GDAL website ([www.gdal.org/python](http://www.gdal.org/python)) but offer
    no code examples, which makes it hard to get started. What's good to know at this
    point is that other Python libraries fill in the gap and offer a more user-friendly
    way to deal with GDAL's capabilities (such as Fiona and GeoPandas). Also, both
    `ogrinfo` and `ogr2ogr` might be preferable over using Python in some use cases,
    for example, when reprojecting vector data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类名大多一目了然，但了解 OGR 的结构概述是很好的。在以下示例中，我们将看到如何访问和使用这些类。OGR 的模块、类和函数在 GDAL 网站上有所记录（[www.gdal.org/python](http://www.gdal.org/python)），但未提供代码示例，这使得入门变得困难。现在值得知道的是，其他
    Python 库填补了这一空白，并提供了更用户友好的方式来处理 GDAL 的功能（如 Fiona 和 GeoPandas）。此外，在某些用例中，`ogrinfo`
    和 `ogr2ogr` 可能比使用 Python 更可取，例如，在重新投影矢量数据时。
- en: Let's look at a few OGR examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个 OGR 的例子。
- en: Creating polygon geometry with OGR
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OGR 创建多边形几何形状
- en: 'OGR lets you write vector geometries such as points, lines, mulitipoints, multilinestrings,
    multipolygons and geometry collections. You can give these geometry values in
    coordinates or meters if you plan to project them later. All geometries you create
    follow the same procedure, separate points are defined and then strung together
    as lines or polygons. You define separate entities in numbers, encode them in
    **well-known binary** (**WKB**), and the final polygon is translated to **well-known
    text** (**WKT**). A Jupyter Notebook will return the coordinates of the polygon
    but won''t plot it automatically, for this, we''ll use Shapely later in this chapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OGR 允许你写入矢量几何，如点、线、多点、多线字符串、多边形和几何集合。如果你计划稍后进行投影，你可以用坐标或米来给出这些几何值。你创建的所有几何形状都遵循相同的程序，单独的点被定义并连接成线或多边形。你用数字定义单独的实体，用**已知二进制**（**WKB**）进行编码，最终的多边形被转换为**已知文本**（**WKT**）。Jupyter
    Notebook 会返回多边形的坐标，但不会自动绘制它，为此，我们将在本章后面使用 Shapely：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating polygon geometry from GeoJSON
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 GeoJSON 创建多边形几何形状
- en: 'You can also create a geometry by passing in GeoJSON to OGR, which saves space
    compared to the first example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将 GeoJSON 传递给 OGR 来创建几何形状，与第一个例子相比，这样可以节省空间：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Basic geometric operations
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本几何操作
- en: 'Here are some basic geometric operations we can perform on our polygon. We
    create the area, centroid, boundary, convex hull, buffer, and check if a polygon
    contains a certain point:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基本几何操作，我们可以对我们的多边形执行。我们创建面积、质心、边界、凸包、缓冲区，并检查多边形是否包含某个点：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing polygon data to a newly created shapefile
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多边形数据写入新创建的 shapefile
- en: 'Our current polygon only exists in memory. We can create a new shapefile and
    write the polygon geometry we created earlier to this shapefile. The script consists
    of the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的多边形仅存在于内存中。我们可以创建一个新的shapefile，并将我们之前创建的多边形几何形状写入此shapefile。脚本包括以下步骤：
- en: Import the modules and set the spatial reference (in this case, **World Geodetic
    System 1984** (**WGS1984**)).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块并设置空间参考（在这种情况下，**世界大地测量系统1984**（**WGS1984**））。
- en: Create the shapefile, then the layer using polygon geometry. Next, the geometry
    is put inside a feature and the feature in a layer. Notice that the script directly
    references the polygon from the earlier example.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建shapefile，然后使用多边形几何创建图层。接下来，将几何形状放入特征中，并将特征放入图层中。注意，脚本直接引用了早期示例中的多边形。
- en: The catch is to use the right geometry type in the first line of code, which
    in this case should be `wkbPolygon`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键是要在代码的第一行使用正确的几何类型，在这种情况下应该是`wkbPolygon`。
- en: The polygon geometry from our earlier example is referenced in this step and
    put into the shapefile.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在早期示例中使用的多边形几何形状在本步骤中被引用并放入了shapefile中。
- en: The shapefile is added as a layer in this step.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中将shapefile添加为图层。
- en: 'Take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use `ogrInfo` to see if the file has been created correctly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ogrInfo`来查看文件是否已正确创建：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using a spatial filter to select features
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空间过滤器选择要素
- en: This example uses the Natural Earth Dataset introduced in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage*, *and Conversion*, under the *Reading and writing vector data
    with GeoPandas* section. We'll use latitude-longitude coordinates to create a
    spatial filter in the form of a bounding box. This box selects only the data inside
    of this box. This is a way to work with a subset of our data. We'll use OGR's
    `SpatialFilterRec` method, which takes four values—`minx`, `miny`, `maxx` and
    `maxy`, to create a bounding box. Our (random) example is to select the cities
    in our bounding box (which shows the state of Texas, as well as parts of Oklahoma
    and Mexico). To filter our results even further, we only want the cities in the
    US. This means we have to filter our search results with an extra `if`/`else`
    statement in our `for` loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用在[第4章](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml)，“数据类型、存储和转换”部分中介绍的Natural
    Earth Dataset。我们将在“使用GeoPandas读取和写入矢量数据”小节中使用经纬度坐标来创建一个边界框形式的空问过滤器。这个框只选择框内的数据。这是一种处理数据子集的方法。我们将使用OGR的`SpatialFilterRec`方法，该方法接受四个值——`minx`、`miny`、`maxx`和`maxy`，来创建一个边界框。我们的（随机）示例是选择边界框内的城市（显示德克萨斯州以及俄克拉荷马州和墨西哥的部分）。为了进一步过滤我们的结果，我们只想选择美国内的城市。这意味着我们必须在`for`循环中添加额外的`if`/`else`语句来过滤我们的搜索结果。
- en: 'The website [www.mapsofworld.com](http://www.mapsofworld.com) gives the following
    four values for our example code: `-102` (`minx`), `26` (`miny`), `-94` (`maxx`),
    and `36` (`maxy`) for the state of Texas. Here is the script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 网站www.mapsofworld.com为我们提供的示例代码如下四个值：`-102` (`minx`)，`26` (`miny`)，`-94` (`maxx`)，和`36`
    (`maxy`)，用于德克萨斯州。以下是脚本：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Shapely and Fiona
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shapely和Fiona
- en: The Shapely and Fiona libraries have been introduced in [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml), *Introduction
    to Geospatial Code Libraries*, in the sections *Shapely* and *Fiona*. It makes
    sense to cover both of them together, as Shapely depends on other libraries for
    reading and writing files and Fiona fits the bill. As we'll see in the examples,
    we can use Fiona to open and read files and then pass geometry data to Shapely
    objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely和Fiona库在[第2章](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml)，“地理空间代码库简介”部分中介绍，包括*Shapely*和*Fiona*小节。将它们一起介绍是有意义的，因为Shapely依赖于其他库来读取和写入文件，而Fiona则符合这一要求。正如我们将在示例中看到的那样，我们可以使用Fiona打开和读取文件，然后将几何数据传递给Shapely对象。
- en: Shapely objects and classes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shapely对象和类
- en: The Shapely library is used for creating and manipulating 2D vector data without
    the need for a spatial database. Not only does it do away with a database, it
    also does away with projections and data formats, focusing on geometry only. The
    strength of Shapely is that it uses easily-readable syntax to create a variety
    of geometries that can be used for geometric operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely库用于创建和操作2D矢量数据，无需空间数据库。它不仅摒弃了数据库，还摒弃了投影和数据格式，只关注几何形状。Shapely的强大之处在于它使用易于阅读的语法创建各种几何形状，这些形状可用于几何运算。
- en: With the aid of other Python packages, these geometries and the results of geometric
    operations can be written to a vector file format and projected if necessary—we'll
    cover examples combing `pyproj` and Fiona with Shapely's capabilities. An example
    of a workflow incorporating Shapely might be where you'd read vector geometries
    out of a shapefile using Fiona, and then use Shapely to simplify or clean up existing
    geometries, in case things might line up correctly internally or in combination
    with other geometries. The cleaned-up geometries can be used as input for other
    workflows, for example, for creating a thematic map or performing data science.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 Python 包的帮助下，这些几何形状和几何运算的结果可以被写入矢量文件格式，并在必要时进行投影——我们将结合 `pyproj` 和 Fiona
    的功能来介绍示例。一个可能的工作流程示例是使用 Fiona 从 shapefile 中读取矢量几何形状，然后使用 Shapely 简化或清理现有的几何形状，以防内部或与其他几何形状的组合可能正确对齐。清理后的几何形状可以用作其他工作流程的输入，例如创建专题地图或执行数据科学。
- en: 'The Shapely library uses a set of classes that are implementations of three
    fundamental types of geometric objects—points, curves, and surfaces. If you are
    familiar with geospatial data and their geometries, they will sound familiar.
    If you''re not, use the examples to get familiar with them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Shapely 库使用一组类，这些类是三种基本几何对象类型（点、曲线和表面）的实现。如果你熟悉地理空间数据和它们的几何形状，它们会听起来很熟悉。如果你不熟悉，请使用示例来熟悉它们：
- en: '| **Geometric object name** | **Class name** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **几何对象名称** | **类名** |'
- en: '| Point | Point |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 点集合 | Point |'
- en: '| Curve | LineString, LinearRing |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 曲线集合 | LineString, LinearRing |'
- en: '| Surface | Polygon |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 表面 | Polygon |'
- en: '| Collection of points | MultiPoint |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 点集合 | MultiPoint |'
- en: '| Collection of curves | MultiLineString |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 曲线集合 | MultiLineString |'
- en: '| Collection of surfaces | MultiPolygon |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 表面集合 | MultiPolygon |'
- en: Shapely methods for geospatial analysis
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shapely 的地理空间分析方法
- en: Topological relationships are implemented as methods on geometric objects (for
    example, contains, touches, and more). Shapely also provides analysis methods
    that return new geometric objects (intersections, unions, and more). Creative
    use of the buffering method provides ways to clean shapes. Interoperation with
    other software is provided through well-known formats (WKT and WKB), NumPy + Python
    arrays, and the Python Geo Interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑关系作为几何对象上的方法实现（例如，包含、接触等）。Shapely 还提供了返回新几何对象的分析方法（交集、并集等）。通过知名格式（WKT 和 WKB）、NumPy
    + Python 数组和 Python 地理接口提供与其他软件的互操作性。
- en: Fiona's data model
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fiona 的数据模型
- en: Although Fiona is OGR's Python wrapper, Fiona uses a data model that differs
    from OGR. While OGR uses data sources, layers and features, Fiona uses the term
    records for accessing geographic features stored in vector data. These are based
    on GeoJSON features—reading a shapefile with Fiona, you reference a record through
    one of its keys, using a Python dictionary object. A record has an ID, geometry,
    and property key.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Fiona 是 OGR 的 Python 封装器，但 Fiona 使用的数据模型与 OGR 不同。OGR 使用数据源、层和要素，而 Fiona 使用术语记录来访问存储在矢量数据中的地理要素。这些基于
    GeoJSON 特性——使用 Fiona 读取 shapefile 时，你通过其中一个键引用记录，使用 Python 字典对象。记录有一个 ID、几何形状和属性键。
- en: Let's look at a few Shapely and Fiona code examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些 Shapely 和 Fiona 的代码示例。
- en: Creating geometries with Shapely
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shapely 创建几何形状
- en: 'Just like OGR, you can use Shapely to create geometries. Jupyter Notebook will
    plot the geometries after you''ve created them, as opposed to OGR. You don''t
    have to use extra plot statements to do this, just repeat the variable name used
    to store the geometries:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 OGR 一样，你可以使用 Shapely 来创建几何形状。在创建几何形状后，Jupyter Notebook 会像 OGR 一样绘制这些几何形状，而不需要使用额外的绘图语句，只需重复用于存储几何形状的变量名即可：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Applying geometrical methods with Shapely
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shapely 应用几何方法
- en: 'In a similar way to OGR, you can apply geometrical methods, using the polygon
    from the earlier example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OGR 类似，你可以应用几何方法，使用前面示例中的多边形：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Reading JSON geometries with Shapely
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shapely 读取 JSON 几何形状
- en: 'Although Shapely does not read or write data files, you can access geometries
    from outside of the library, for instance, by feeding it vector data written in
    `json`. The following script creates a polygon in `json` that is read into Shapely
    in line. Next, the mapping command returns a new, independent geometry with coordinates
    copied from the context:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Shapely 不读取或写入数据文件，但你可以通过从库外部访问几何形状，例如，通过提供以 `json` 编写的矢量数据来访问它。以下脚本创建了一个在行中读取到
    Shapely 的 `json` 多边形。接下来，映射命令返回一个新的、独立的几何对象，其坐标来自上下文：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Reading data with Fiona
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fiona读取数据
- en: 'The following code reads a file from our Natural Earth dataset and prints its
    dictionary keys:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从我们的Natural Earth数据集中读取一个文件并打印其字典键：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using the data pretty-print (`pprint`) library that is part of Python''s standard
    library, we can print the corresponding values to the keys of the first feature
    from our dataset:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python标准库中的数据格式化打印库 (`pprint`)，我们可以将数据集中第一个特征对应的值打印到键上：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the following methods on the data file object for printing the following
    information:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据文件对象上使用以下方法来打印以下信息：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Accessing vector geometry in shapefiles using Shapely and Fiona
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shapely和Fiona在shapefile中访问矢量几何
- en: 'Using Fiona, you can open a shapefile and access attribute data, such as geometries.
    For example, our Natural Earth dataset contains a shapefile with all of the states
    in the US with their vector geometries. Use the following code to open the shapefile
    and get all of the vector geometry of the first feature (starting from index number
    `0`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fiona，你可以打开一个shapefile并访问属性数据，例如几何形状。例如，我们的Natural Earth数据集包含一个包含美国所有州及其矢量几何的shapefile。使用以下代码打开shapefile并获取第一个特征的所有矢量几何（从索引号`0`开始）：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can use the `shape` method and pass in all of the coordinates from Minnesota:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `shape` 方法并传入明尼苏达州的所有坐标：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we plot the geometry with Shapely:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Shapely绘制几何形状：
- en: '![](img/39032e40-fc47-412b-8d32-15240025c709.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39032e40-fc47-412b-8d32-15240025c709.png)'
- en: 'A note on plotting separate shapefile geometries in Python:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在Python中绘制单独的shapefile几何形状的注意事项：
- en: 'As you may have noticed from the prefacing text, referencing separate geometry
    elements such as a state from shapefiles and plotting them with Python isn''t
    that straightforward. Luckily, there are many code examples available for professionals
    to solve this problem. Have a look at the following options that are freely available
    for Python users, to see how you could approach plotting shapefile vector geometries
    in Python, if you decide to work directly with shapefiles instead of converting
    to the GeoJSON format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，从shapefile中引用单独的几何元素，如一个州，并用Python绘制它们并不直接。幸运的是，有许多代码示例可供专业人士解决此问题。查看以下免费提供的Python用户选项，了解如果你决定直接使用shapefile而不是转换为GeoJSON格式，如何处理Python中的shapefile矢量几何绘图：
- en: Use NumPy arrays and `matplotlib`**: **You can use NumPy arrays to squeeze all
    of the coordinates in a one-dimensional array and plot these next.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy数组并`matplotlib`：**你可以使用NumPy数组将所有坐标挤压到一个一维数组中，然后绘制这些坐标。
- en: Use Shapely and create a new dictionary from an existing shapefile**: **If you
    know how to reorganize an existing collection of dictionaries, it is possible
    to create a new dictionary out of an existing shapefile that uses the name of
    a geographical area as a key, with the geometry data of that area as values. Next,
    you can use Shapely to pass in elements of these dictionaries and plot them in
    Python.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shapely并从现有shapefile创建一个新的字典：**如果你知道如何重新组织现有的字典集合，则可以从现有的shapefile中创建一个新的字典，该字典使用地理区域的名称作为键，该区域的几何数据作为值。接下来，你可以使用Shapely将这些字典的元素传递进去，并在Python中绘制它们。
- en: Use `pyshp` and `matplotlib`**: **The `pyshp` library can be used to read in
    geometry information that can then be plotted with `matplotlib`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pyshp`和`matplotlib`：**`pyshp`库可以用来读取几何信息，然后可以使用`matplotlib`进行绘图。
- en: Use GeoPandas and `matplotlib`**: **The GeoPandas library can be used together
    to read in shapefiles. Not only can you plot vector data using matplotlib's capabilities,
    but you can also read in attribute tables as `pandas` dataframes.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GeoPandas和`matplotlib`：**GeoPandas库可以与matplotlib一起使用来读取shapefile。不仅可以使用matplotlib的功能绘制矢量数据，还可以将属性表作为`pandas`数据框读取。
- en: GeoPandas
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GeoPandas
- en: GeoPandas has been introduced in the *GeoPandas* section of  [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml), *Introduction
    to Geospatial Code Libraries*, where its data structures and methods have also
    been covered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: GeoPandas已在[第2章](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml)的“地理空间代码库简介”部分的*GeoPandas*小节中介绍，其中也涵盖了其数据结构和方法。
- en: Geospatial analysis with GeoPandas
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GeoPandas进行地理空间分析
- en: GeoPandas was created to offer data to scientists who want to work with spatial
    data similar to `pandas`, and this means giving access to geospatial attribute
    data through data structures not available through `pandas`. Combine this with
    a set of geometric operations, data overlay capabilities, geocoding and plotting
    capabilities and you have an idea of this library's capabilities. In the examples
    mentioned as we proceed, we'll cover GeoPandas' plotting methods, explain how
    to access and subset spatial data, and provide a typical workflow for doing geospatial
    analysis with GeoPandas, where data processing is an important condition for being
    able to analyze and interpret the data correctly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: GeoPandas 是为了向希望使用类似于 `pandas` 的空间数据的科学家提供数据而创建的，这意味着通过数据结构提供对地理空间属性数据的访问，这些数据结构在
    `pandas` 中不可用。结合一组几何运算、数据叠加功能、地理编码和绘图功能，您就可以了解这个库的功能。在我们继续提到的示例中，我们将涵盖 GeoPandas
    的绘图方法，解释如何访问和子集空间数据，并提供使用 GeoPandas 进行地理空间分析的典型工作流程，其中数据处理是正确分析和解释数据的重要条件。
- en: Let's have a look at a few code examples of GeoPandas.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些 GeoPandas 的代码示例。
- en: Selecting and plotting geometry data with GeoPandas and Matplotlib
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GeoPandas 和 Matplotlib 选择和绘制几何数据
- en: 'The following script combines `pandas` dataframe methods on GeoPandas GeoDataFrame
    objects. Together, you can easily subset data and plot separate feature geometries.
    We start with importing the module, the magic command for plotting data inside
    a Juypter Notebook and input data, which is a shapefile with all US state boundaries:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本结合了 GeoPandas GeoDataFrame 对象上的 `pandas` 数据框方法。一起使用，您可以轻松地子集数据并绘制单独的特征几何图形。我们从导入模块开始，这是在
    Jupyter Notebook 内部绘制数据的神奇命令，以及输入数据，这是一个包含所有美国州边界的 shapefile：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some simple data inspection methods—`type(df)` returns the object type, which
    is a GeoPandas `GeoDataFrame`, which takes in the same methods as `pandas` dataframes.
    The `shape` method returns a tuple with rows and column amounts, while `df.columns`
    returns the column names as a list item:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的数据检查方法——`type(df)` 返回对象类型，它是一个 GeoPandas `GeoDataFrame`，它接受与 `pandas` 数据框相同的方法。`shape`
    方法返回一个包含行数和列数的元组，而 `df.columns` 返回列名列表：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can subset separate rows of our `GeoDataFrame` using `pandas`, `.loc` and
    `.iloc` methods. We access the first feature''s attributes, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `pandas`、`.loc` 和 `.iloc` 方法来子集我们的 `GeoDataFrame` 的单独行。我们访问第一个特征的属性，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we''ll plot some state data. First, we''ll get a list of all of the state
    names as we need the state names and their row numbers next:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将绘制一些州的数据。首先，我们将获取所有州名的列表，因为我们需要州名及其行号：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Separate rows can be referenced by `name` instead of row number using `.loc`
    and a value. Repeating the `name` value returns all columns and attribute data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `.loc` 和一个值来通过 `name` 而不是行号引用单独的行。重复 `name` 值将返回所有列和属性数据：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can plot the geometry of this variable as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式绘制这个变量的几何图形：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is what the graph looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个图表的样子：
- en: '![](img/35aa3f80-07fc-48e7-ad32-6bc065dc5b38.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35aa3f80-07fc-48e7-ad32-6bc065dc5b38.png)'
- en: 'You can plot multiple items by using the `.iloc` function and pass it a list
    of row numbers; in this case, the row numbers correspond to Washington, California,
    Nevada, and Oregon, respectively:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `.iloc` 函数并传递一个行号列表来绘制多个项目；在这种情况下，行号分别对应华盛顿、加利福尼亚、内华达和俄勒冈：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output graph will look like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的图表将看起来像这样：
- en: '![](img/53ca246a-1f7e-4212-9d3f-63c0d05bad08.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53ca246a-1f7e-4212-9d3f-63c0d05bad08.png)'
- en: 'The same results can be obtained using the `.cx` method on the `GeoDataFrame`,
    passing in values for a bounding box. This method uses the following syntax: `df.cx[xmin:xmax,
    ymin:ymax]`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.cx` 方法在 `GeoDataFrame` 上也可以获得相同的结果，传入边界框的值。此方法使用以下语法：`df.cx[xmin:xmax,
    ymin:ymax]`：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Mapping wildfire data with GeoPandas
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GeoPandas 绘制野火数据
- en: The following script can be used to create a choropleth map that shows the total
    wildfires in the US from 1984-2015, based on total count per state. We can use
    the MTBS with fire data that was introduced in [Chapter 4](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml), *Data
    Types, Storage, and Conversion*, which gives us point data of all of the wildfire
    occurrences from 1984-2015\. We can use the state field of the wildfire data to
    map the wildfire occurrences by state. But, we choose here to overlay the data
    on a separate shapefile with state geometries, to illustrate the use of a spatial
    join. Next, we'll count the total wildfires per state and map the results. GeoPandas
    can be used to accomplish all of these tasks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本可以用来创建一个表示1984-2015年美国总野火数量的等值线图，基于每个州的计数。我们可以使用在[第4章](16f36845-4cea-4aa2-8eb4-8b2916c23398.xhtml)中引入的MTBS火数据，*数据类型、存储和转换*，它给我们1984-2015年所有野火发生点的数据。我们可以使用野火数据的州字段来按州映射野火发生。但，我们选择在这里将数据叠加到一个包含州几何形状的单独形状文件上，以说明空间连接的使用。接下来，我们将按州统计总野火数量并绘制结果。GeoPandas可以用来完成所有这些任务。
- en: 'We start with importing the module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入模块：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we import the shapefile with all of the state boundaries:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入包含所有州边界的形状文件：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The attribute table of the file can be displayed as a `pandas` dataframe by
    repeating the variable name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重复变量名，可以显示文件的属性表作为一个`pandas`数据框：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can see all of the state names listed in the name column. We will need this
    column later. The vector data can be plotted inside our Jupyter Notebook, using
    the magic command and the `plot` method from `matplotlib`. As the default maps
    look quite small, we''ll pass in some values using the `figsize` option to make
    it look bigger:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有州名都列在name列中。我们稍后会需要这个列。矢量数据可以使用Jupyter Notebook中的魔法命令和`matplotlib`的`plot`方法进行绘制。由于默认地图看起来相当小，我们将通过`figsize`选项传递一些值来使其看起来更大：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You''ll see the following map:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下地图：
- en: '![](img/0f4166b8-d750-402b-a4c0-84b903e89bed.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f4166b8-d750-402b-a4c0-84b903e89bed.png)'
- en: 'The same procedure is repeated for our wildfire data. Using large values for
    the `figsize` option gives a large map showing the location of the wildfires:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的野火数据，重复相同的步骤。使用大的`figsize`选项值可以得到一个显示野火位置的较大地图：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The map looks something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 地图看起来像这样：
- en: '![](img/0ef12ff6-c9ae-46ad-adb1-ffba9bff5878.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ef12ff6-c9ae-46ad-adb1-ffba9bff5878.png)'
- en: 'Have a look at the column called MTBS Zone in the `fires` `GeoDataFrame`, and
    verify that this dataset does not include all of the state names to reference
    the data. However, we have a geometry column that we can use to join both of the
    datasets. Before we can do this, we have to make sure that the data uses the same
    map projection. We can verify this as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看名为MTBS Zone的`fires` `GeoDataFrame`列，并验证这个数据集并不包含所有州名以引用数据。然而，我们有一个几何列，我们可以用它来连接这两个数据集。在我们能这样做之前，我们必须确保数据使用相同的地图投影。我们可以如下验证：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are two map projections, but both need to have the same CRS in order
    to line up correctly. We can reproject the `fires` shapefile to WGS84 as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种地图投影，但两者都需要有相同的CRS才能正确对齐。我们可以如下将`fires`形状文件重新投影到WGS84：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''re ready to perform a spatial join, using the `sjoin` method, indicating
    we want to know if the `fires` geometries are within the state geometries:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备执行空间连接，使用`sjoin`方法，表示我们想知道`fires`几何形状是否在州几何形状内：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The new `state_fires` `GeoDataFrame` has a column added to the outer right
    called name, showing the state where each fire is located:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`state_fires` `GeoDataFrame`在右侧外边增加了一个名为name的列，显示每个火灾所在的州：
- en: '![](img/44eddb95-7f43-4511-bb9a-4060333fe9e3.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44eddb95-7f43-4511-bb9a-4060333fe9e3.png)'
- en: 'We can now count the total amount of wildfires per state. The result is a `pandas`
    series object showing the state name and total count. To start with the highest
    counts, we''ll use the `sort_values` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按州统计每州的野火总数。结果是显示州名和总数的一个`pandas`系列对象。为了从最高计数开始，我们将使用`sort_values`方法：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`Florida`, `California`, and `Idaho` are the three states with the most wildfires
    during 1984-2015, according to our data:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的数据，`佛罗里达州`、`加利福尼亚州`和`爱达荷州`是1984-2015年期间野火最多的三个州：
- en: '![](img/85151228-aa11-41f2-b580-a5acf8b4f2b0.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85151228-aa11-41f2-b580-a5acf8b4f2b0.png)'
- en: 'These values can be fed into the original shapefile as a new field, showing
    total wildfire count per state:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以作为新字段输入到原始形状文件中，显示每个州的野火总数：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `head` method prints the first five entries in the `states` shapefile,
    with a new field added to the right end of the table. Finally, a choropleth map
    for wildfire count per state can be created and plotted as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`方法打印了`states` shapefile中的前五个条目，并在表格的右端添加了一个新字段。最后，可以创建并绘制每个州的野火计数热力图如下：'
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will look something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '![](img/89b121e1-d8ce-40b8-a6f6-d099b4af28b3.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89b121e1-d8ce-40b8-a6f6-d099b4af28b3.png)'
- en: 'Compare this to another color scheme applied to the same results, doing away
    with the light colors for the lower values:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与应用于相同结果的另一种颜色方案进行比较，去除低值处的浅色：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is what the map looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是地图的样貌：
- en: '![](img/cfe4449d-6928-4c49-b997-a88001460399.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfe4449d-6928-4c49-b997-a88001460399.png)'
- en: 'Use the following code to fine-tune the map a little further, by adding a title
    and dropping the *x*-axis and *y*-axis:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码进一步微调地图，通过添加标题并删除*x*轴和*y*轴：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/aaff1d5b-9846-4f61-b356-e29fbbf393bd.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaff1d5b-9846-4f61-b356-e29fbbf393bd.png)'
- en: Why data inspection matters
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么数据检查很重要
- en: 'When you''re preparing your data, it''s good to know the data you''re dealing
    with. For example, listing statistics about your dataset that show you how many
    elements there are, and if there are any missing values. It''s common that data
    has to be cleaned up before doing the analysis. Because the GeoPandas data objects
    are subclasses of `pandas` data objects, you can use their methods to do data
    inspection and cleaning. Take, for instance, the wildfire data shapefile we used
    earlier. By listing our dataframe object, it not only prints all of the attribute
    data, but also lists the total rows and columns, which is 20340 rows and 30 columns.
    The total amount of rows can also be printed this way:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备数据时，了解你处理的数据是很重要的。例如，列出关于你的数据集的统计数据，显示有多少元素，以及是否有任何缺失值。在进行分析之前，通常需要对数据进行清理。由于GeoPandas数据对象是`pandas`数据对象的子类，你可以使用它们的方法进行数据检查和清理。以我们之前使用的野火数据shapefile为例。通过列出我们的dataframe对象，它不仅打印了所有属性数据，还列出了总行数和列数，共有20340行和30列。总行数也可以这样打印出来：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This means there are `20340` individual wildfire cases in our input dataset.
    Now, compare this row value to the sum of the counts per state, after we''ve performed
    the spatial join:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们的输入数据集中有`20340`个单独的野火案例。现在，将这个行值与我们执行空间连接后每个州计数之和进行比较：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We notice that there are 74 less wildfires in our dataset after our spatial
    join. While at this point it''s not clear what went wrong with our spatial join
    and why there are missing values, it''s possible and recommended to check datasets
    before and after performing geometric operations, for example, checking for empty
    fields, non-values, or simply null-values:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，在空间连接之后，我们的数据集中野火减少了74个。虽然目前还不清楚我们的空间连接出了什么问题，为什么会有缺失值，但在执行几何操作之前和之后检查数据集是可能的，也是推荐的，例如检查空字段、非值或简单的空值：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The same operation can also be done by specifying a column name:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的操作也可以通过指定列名来完成：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Be aware of the fact that GeoPandas geometry columns use a combination of text
    and values, so checking for NaN or zero values doesn't make any sense.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到GeoPandas几何列使用文本和值的组合，因此检查NaN或零值没有意义。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered three Python libraries for working with vector data—OGR,
    Shapely, and GeoPandas. In particular, we showed how to use all three for doing
    geospatial analysis and processing. Each library was covered separately, with
    their classes, methods, data structures and popular use cases. Short example scripts
    showed how to get started doing data processing and analysis. Taken as a whole,
    the reader now knows how to use each library separately, as well as how to combine
    all three for doing the following tasks:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了三个用于处理矢量数据的Python库——OGR、Shapely和GeoPandas。特别是，我们展示了如何使用这三个库进行地理空间分析和处理。每个库都单独介绍，包括它们的类、方法、数据结构和常用用例。简短的示例脚本展示了如何开始进行数据处理和分析。整体来看，读者现在知道了如何单独使用每个库，以及如何将这三个库结合起来完成以下任务：
- en: Reading and writing vector data
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入矢量数据
- en: Creating and manipulating vector data
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和操作矢量数据
- en: Plotting vector data
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制矢量数据
- en: Working with map projections
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理地图投影
- en: Performing spatial operations
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行空间操作
- en: Working with vector geometries and attribute data in tabular form
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以表格形式处理矢量几何和属性数据
- en: Presenting and analyzing the data to answer questions with a spatial component
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示和分析数据以回答具有空间成分的问题
- en: The next chapter discusses raster data processing and how to use the GDAL and
    Rasterio libraries. Using these libraries, the reader will learn how to perform
    raster-based geospatial search and analysis, and how to use geolocated text and
    images.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章讨论了光栅数据处理以及如何使用GDAL和Rasterio库。使用这些库，读者将学习如何执行基于光栅的地理空间搜索和分析，以及如何使用地理定位的文本和图像。
