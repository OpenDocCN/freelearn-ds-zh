- en: Data Types, Storage, and Conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on the many different data types that exist within GIS
    and will provide an overview of the major data types in GIS and how to use the
    previously covered Python code libraries to read and write geospatial data. Apart
    from reading and writing different geospatial data types, you'll learn how to
    use these libraries to perform file conversion between different data types and
    how to download data from geospatial databases and remote sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following vector and raster data types will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Shapefiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoJSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoPackages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoTIFF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following file actions will also be covered, using Python geospatial data
    libraries covered in [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml),
    *Introduction to Geospatial Code Libraries*:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening existing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and displaying different attributes (spatial and non-spatial)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and writing new geospatial data in different formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting one file format to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading geospatial data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll provide an overview of the most used GIS data types before we head over
    to write some code for reading and writing them. Next, we will use some examples
    to explain how to use various Python libraries for reading, writing, downloading,
    and converting geospatial data. We'll start with an explanation of what geospatial
    data represents and the difference between vector and raster data.
  prefs: []
  type: TYPE_NORMAL
- en: Raster and vector data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into some of the most used GIS data types, a little background
    is required about what type of information geographical data represents. Earlier
    in this book, the distinction between raster and vector data was mentioned. All
    GIS data is comprised of one or the other, but a combination of both vectors and
    rasters is also possible. When deciding on which data type to use, consider the
    scale and type of geographical information represented by the data, which in turn
    determines what Python data libraries to use. As is illustrated in the following
    examples, the choice for a certain Python library can also depend on personal
    preference, and there may be various ways to do the same task.
  prefs: []
  type: TYPE_NORMAL
- en: In the geospatial world, raster data comes in the form of aerial imagery or
    satellite data, where each pixel has an associated value that corresponds to a
    different color or shade. Raster data is used for large continuous areas, such
    as differentiating between different temperature zones across various parts of
    the world. Other popular applications are elevation, vegetation, and precipitation
    mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Rasters can also be used as input for creating vector maps, where, for example,
    objects such as roads and buildings can be distinguished (an example being the
    standard map view when navigating to Google Maps). Vector data itself consists
    of points, lines, and polygons to distinguish features in a geographical space,
    such as administrative boundaries. These are built up from individual points that
    have spatial relationships with each other that are described in an associated
    data model. Vectors maintain the same sharpness the more you zoom-in, while raster
    data will look more coarse-grained.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what geographical data represents, let's discuss the most
    used geospatial data formats for vector and raster data.
  prefs: []
  type: TYPE_NORMAL
- en: Shapefiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shapefile is probably the most often-used data format for geographical vector
    data today. This file format was developed by Esri, based on a mostly open specification
    for data interoperability among Esri and other GIS software products. Although
    many other file formats have been introduced in an attempt to replace the shapefile,
    it remains a widely-used file format. These days, many third-party programming
    modules in Python exist for reading and writing shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the name *shapefile* might suggest that there''s only one file associated
    with it, a single shapefile requires in fact at least three files that need to
    be stored in the same directory in order to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: A `.shp` file with the feature geometry itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `.shx` file featuring a positional index of the feature geometry to allow
    seeking forwards and backwards quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `.dbf` file with columnar attributes for each shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shapefiles have their own structure. The main file (`.shp`) contains the geometry
    data, consisting of a single fixed-length header, followed by one or more variable-length
    records.
  prefs: []
  type: TYPE_NORMAL
- en: GeoJSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GeoJSON is a JSON-based file format that has become popular in a short time.
    GeoJSON uses the **JavaScript Object Notation** (**JSON**) open data standard
    for storing geographical features as key-value pairs. The files are easily readable,
    can be created using a simple text editor, and are now common in spatial databases,
    open data platforms, as well as commercial GIS software. You would use GeoJSON
    for various types of geospatial vector data, such as points, lines, and polygons. GeoJSON
    uses either `.json` or `.geojson` as the filename extension. This means that a
    filename doesn't have to be `.geojson` in order to be a GeoJSON file.
  prefs: []
  type: TYPE_NORMAL
- en: KML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Keyhole Markup Language** (**KML**), referring to the company that developed
    the format. It can be used to store geographic data which can be visualized using
    a host of applications such as Google Earth, Esri ArcGIS Explorer, Adobe Photoshop,
    and AutoCAD. KML is based on XML, using a tag-based structure with nested elements
    and attributes. KML files are often distributed in KMZ files, which are zipped
    KML files with a `.kmz` extension. For its reference system, KML uses longitude,
    latitude, and altitude coordinates, defined by the **World Geodetic System of
    1984** (**WGS84**).'
  prefs: []
  type: TYPE_NORMAL
- en: GeoPackage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **Open Geospatial Consortium** (**OGC**) **GeoPackage** (**GPKG**) is an
    open data format for geographic information systems that support both vector and
    raster data. The format was defined by OGC and published in 2014, after which
    it has seen wide support from various government, commercial, and open source
    organizations. The GeoPackage data format was developed with the mobile user in
    mind—it was designed to be as efficient as possible, with all information contained
    in a single file. This makes it easy to rapidly share them on cloud storage and
    USB drives, and it is used in mobile applications that are disconnected. A GeoPackage
    file is built up as an extended SQLite 3 database file (`*.gpkg`) that combines
    data and metadata tables.
  prefs: []
  type: TYPE_NORMAL
- en: Raster data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some of the most popular raster data formats used for geographical
    information today:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ECW** (**Enhanced Compressed Wavelet**): ECW is a compressed image format
    typically for aerial and satellite imagery. This GIS file type is known for its
    high compression ratios while still maintaining quality contrast in images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Esri grid**: A file format for adding attribute data to a raster file. Esri
    grid files are available as integer and floating point grids.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GeoTIFF** (**Geographic Tagged Image File Format**): An industry image standard
    file for GIS and satellite remote sensing applications. Almost all GIS and image
    processing software packages have GeoTIFF compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JPEG 2000**: An open source compressed raster format that allows both lossy
    and lossless compression. JPEG 2000 typically have a JP2 file extension. JPEG
    2000 can achieve a compression ratio of 20:1, which is similar to the MrSID format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MrSID** (**Multi-Resolution Seamless Image Database**): A compressed wavelet
    format that allows for both lossy and lossless compression. LizardTech''s proprietary
    MrSID format is commonly used for orthoimages in need of compression. MrSID images
    have an extension of SID and are accompanied with a world file with the file extension
    SDW.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing vector data with GeoPandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time for some hands-on exercises. We'll start with reading and writing
    some vector data in the form of GeoJSON using the GeoPandas library, which is
    the application used to demonstrate all examples is Jupyter Notebook, which comes
    preinstalled with Anaconda3\. If you've installed all geospatial Python libraries
    from [Chapter 2](757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml), *Introduction to
    Geospatial Code Libraries,* you're good to go. If not, do this first. You might
    decide to create virtual environments for different combinations of Python libraries
    because of different dependencies and versioning. Open up a new Jupyter Notebook
    and a browser window and head over to [http://www.naturalearthdata.com/downloads/](http://www.naturalearthdata.com/downloads/)
    and download the Natural Earth quick start kit at a convenient location. We'll
    examine some of that data for the rest of this chapter, along with some other
    geographical data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, type the following code in a Jupyter Notebook with access to the GeoPandas
    library and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3c8a0ac-845c-4349-a7af-7395f808a1aa.png)'
  prefs: []
  type: TYPE_IMG
- en: The code does the following—the first line imports the GeoPandas library and
    shortens its name, saving space whenever we reference it later. The second line
    reads the data on disk, in this case, a shapefile with land boundary lines. It
    is assigned to a dataframe variable, which refers to a `pandas` dataframe, namely
    a 2D object comparable to an Excel table with rows and columns. The data structures
    of GeoPandas mimic are subclasses from those of `pandas` and are named differently—the
    `pandas` dataframe in GeoPandas is called a **GeoDataFrame**. The third line prints
    the attribute table, which is limited to the first five rows. After running the
    code, a separate cell's output will list the attribute data from the referenced
    shapefile. You'll notice that the FID column has no name and that a `geometry`
    column has been added as the last column.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only command to read data, as you can also read data from a
    PostGIS database, by using the `read_postgis()` command. Next, we''ll plot the
    data inside our Jupyter Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b2011c9-8607-462d-8870-bce357d8173a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first line is a so-called magic command, only to be used inside a Jupyter
    Notebook, and tells it to use the plotting capabilities of the `matplotlib` library
    inside a cell of the Jupyter Notebook app. This way, you can plot map data directly
    as opposed to working with an IDE. The second line states that we want the dataframe
    plotted, in `black` (the default color is blue). The output resembles a world
    map with only land borders, which are visible as black lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll investigate some of the attributes of GeoPandas data objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that the first five entries in our attribute table are made of
    line strings and multiline strings. For printing all entries, use the same line
    of code, without `.head()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `crs` attribute refers to the **coordinate reference system** (**CRS**)
    of the dataframe, in this case, `epsg:4326`, a code defined by the **International
    Association of Oil and Gas Producers** (**IOGP**). Go to [www.spatialreference.org](http://www.spatialreference.org) for
    more information on EPSG. The CRS offers essential information about your spatial
    dataset. EPSG 4326 is also known as WGS 1984, a standard coordinate system for
    the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can change the CRS as follows to a Mercator projection, showing a more
    vertically stretched image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1773eda6-d8f6-4636-9e34-fd21623b077d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose we want to convert the shapefile data of our dataframe into `json`.
    GeoPandas does this in one line of code, and the output is listed in a new cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This previous command converted the data to a new format but did not write
    it to a new file. Writing your dataframe to a new `geojson` file can be done like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Don't be confused by JSON file extensions—a JSON file with spatial data is a
    GeoJSON file, even though there's also a separate `.geojson` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'For file conversion, GeoPandas relies on the Fiona library. To list all available
    `drivers` (a software component that lets the operating system and a device communicate
    with each other), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing vector data with OGR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's turn to OGR for reading and writing a vector so that you can compare
    both OGR and GeoPandas functionality for performing the same kind of tasks. To
    follow the instructions that are mentioned as we proceed, you can download the
    MTBS wildfire data from: [https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/fod_pt_shapefile/mtbs_fod_pts_data.zip](https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/fod_pt_shapefile/mtbs_fod_pts_data.zip) and
    store them on your PC. The file that will be analyzed here is the `mtbs_fod_pts_20170501`
    shapefile's attribute table, which has 20,340 rows and 30 columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the `ogrinfo` command which works in a terminal window and
    can be used for describing vector data. These are not Python commands, but we''ll
    include them here as you can easily run them in a Jupyter Notebook with a simple
    prefix (adding an exclamation mark before the used command). Take, for instance,
    the following command, which is similar to the Fiona driver command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the available formats that `ogrinfo` can access, by using
    the general option `--formats`. The results also tells us whether GDAL/OGR can
    only read/open the format, or whether it can also write new layers in that format.
    As you can see from the output, there are many supported file formats with OGR.
    Looking at Esri shapefiles in the list, the addition of (rw+v) means OGR supports
    read, write, update (meaning create), and virtual formats for Esri shapefiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command lists the summary information about all the layers in
    a data source, which in this case is all the shapefiles in the folder called `"pts"`.
    The addition of `-so` stands for summary option. You can see that this command
    lists similar information as we saw with GeoPandas, such as the CRS. The same
    line of code, but without the `-so` addition will print all features and attributes,
    and takes some time to process. This is comparable to creating a GeoDataFrame
    in GeoPandas, but all attribute info is printed per feature on a new line instead
    of preserving the tabular form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to convert this shapefile into a GeoJSON file, we will use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `-f` prefix stands for the format, followed by the output driver name, the
    output file name, and the location and the input file. You might receive error
    warnings doing file conversions, for example when a bad feature is encountered,
    but an output file will be written anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'OGR has also read and write capabilities for KML files. Download this KML sample
    file ([https://developers.google.com/kml/documentation/KML_Samples.kml](https://developers.google.com/kml/documentation/KML_Samples.kml))
    with the following code and run the following code to read its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For a more Pythonic approach for OGR, let's see some examples of how you can
    read and write data with OGR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code lists all 30 field names of our wildfire shapefile using
    OGR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, this is a little more involved than
    using GeoPandas, where you can directly load all attribute data into one GeoDataFrame
    using little code. With OGR, you need to iterate over the individual features
    which need to be referenced from a layer definition and appended to an empty list.
    But first, you need to use the `GetLayer` function— this is because OGR has its
    own data model that does not adapt itself automatically to the file format it
    reads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the field names, we can iterate over the individual features,
    for instance, for the state field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Judging from the output of the last cell, there are apparently many features,
    but exactly how many? The total feature count can be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve seen previously, the CRS is essential information about your spatial
    data. You can print this information in two ways—from the layer and the geometry
    of the layer. In the following code, two spatial reference variables will print
    the same output, as it should be (only the output of the first option is listed
    here to save space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check if we''re dealing with points and print the *x* and *y* values
    of all individual features as well as their centroids as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing raster data with Rasterio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After covering how to read and write various vector data formats in Python,
    we''ll now do the same for raster data. We''ll start with the Rasterio library
    and have a look at how we can read and write raster data. Open up a new Jupyter
    Notebook where you have access to the Rasterio library and type the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This imports the `rasterio` library and opens a GeoTIFF file. We can now perform
    some simple data description commands, such as printing the number of image bands.
  prefs: []
  type: TYPE_NORMAL
- en: Raster images contain either a single or multiple bands. All bands are contained
    in a single file, with each band covering the same area. When the image is read
    by your computer, these bands are overlayed on top of each other so that you'll
    see one single image. Each band contains a 2D array with rows and columns of data.
    Each data cell of each array contains a numeric value that corresponds to a color
    value (or elevation value, which is also possible). If a raster image has multiple
    bands, each band corresponds to a segment of the electromagnetic spectrum that
    was collected by a sensor. Users can display one or multiple bands, combining
    different bands together to make their own color composites. [Chapter 9](399c3041-569f-400a-83f0-e13020a177cf.xhtml), *ArcGIS
    API for Python and ArcGIS Online* features some examples of these color composites
    when discussing displaying raster data using the ArcGIS API for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, there are three different bands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'A `dataset` band is an array of values representing the partial distribution
    of a single variable in a 2D space. The number of columns is returned by the `width`
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of rows is returned by the `height` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code returns the spatial bounding box in meters, so you can calculate
    the area it covers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The CRS of the dataset can be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access and return a NumPy ndarray with the raster array for a raster
    band as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to visualize the image, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output map will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a5807c2-e0b5-4e62-9d69-be725f7b2100.png)'
  prefs: []
  type: TYPE_IMG
- en: Reading and writing raster data using GDAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some commands for reading and writing raster data with GDAL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists all supported file formats in GDAL. For a summary including
    the CRS, use `!gdalinfo` without any prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert a GeoTIFF to a JPEG file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, `NE1_50M_SR_W.jpg`, will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f0da7fa-655a-491f-a105-2227c3c45978.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s open a GeoPackage using GDAL. GeoPackages can be either vector
    or raster-based, but in this case, we''ll open a raster-based one, which becomes
    clear from the following output. For reading and writing GeoPackages, we need
    GDAL version 2.2.2, so the following example won''t work for lower version numbers.
    Download the following GeoPackage file ([http://www.geopackage.org/data/gdal_sample_v1.2_no_extensions.gpkg](http://www.geopackage.org/data/gdal_sample_v1.2_no_extensions.gpkg))
    and reference it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The GDAL **Web Map Service** (**WMS**) driver allows for interacting with online
    web mapping services. You can use it to download various geospatial datasets,
    subsets, or information about available datasets directly from a command prompt
    (or in this case, a Jupyter Notebook) without using a browser to navigate to a
    website and download data manually. There are many different options, so refer
    to the online documentation for more information. The following example requires
    GDAL version 2.0 or higher. The following command uses the URL of a **REpresentational
    State Transfer** (**REST**) definition for an ArcGIS MapServer and returns the
    information about the requested image service, such as the amount of bands, band
    names, CRS, corner coordinates, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that you added some information to the URL of the image service, in this
    case, `f=json&pretty=true`. This means the requested file format by the user is
    `pretty json`, which is a nicely formatted `json` that is easier to read for humans.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an overview of major data types in GIS. After explaining
    the difference between vector and raster data, the following vector and raster
    data types were covered—Esri shapefiles, GeoJSON, KML, GeoPackages, and GeoTIFF
    files. Next, we explained how to use some of the earlier described Python code
    libraries to read and write geospatial data. The following geospatial Python libraries
    for reading and writing raster and vector data were covered in particular—GeoPandas,
    OGR, GDAL, and Rasterio. Apart from reading and writing different geospatial data
    types, you learned how to use these libraries to perform file conversion between
    different data types and how to upload and download data from geospatial databases
    and remote sources.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover geospatial analysis and processing. Python libraries
    covered are OGR, Shapely and GeoPandas. The reader will learn how to use these
    libraries and write scripts for geospatial analysis, using real-world examples.
  prefs: []
  type: TYPE_NORMAL
