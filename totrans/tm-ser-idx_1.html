<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>An Introduction to Time Series and the Required Python Knowledge</h1>
<p>This is the first chapter of the book that you are reading. Although first chapters usually contain basic information that you might want to skip, this is not such a chapter. It teaches you the basics of time series and indexing, as well as how to set up a proper Python environment, which is going to be used during the development of the code of this book. You might need to refer to it while you are reading other chapters, which is a good thing! So, let us <span class="No-Break">get started!</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Understanding <span class="No-Break">time series</span></li>
<li>What is an index and why do we <span class="No-Break">need indexing?</span></li>
<li>The Python knowledge that we are going <span class="No-Break">to need</span></li>
<li>Reading time series <span class="No-Break">from disk</span></li>
<li>Visualizing <span class="No-Break">time series</span></li>
<li>Working with the <span class="No-Break">Matrix Profile</span></li>
<li>Exploring the <span class="No-Break">MPdist distance</span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>In order to follow this chapter, which is the foundation of the entire book, you need to have a recent Python 3 version installed on your computer and be able to install any other required software on your own. We are not going to teach you how to install a Python 3 package, but we are going to tell you which packages you should install and the commands that we have used to do so. Similarly, we are not going to explain the process of installing new software on your machines, but we are going to tell you the command or commands we have used to install a given software on <span class="No-Break">our machines.</span></p>
<p>The GitHub repository of the book can be found at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for <a href="B14769_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a> can be found inside the <strong class="source-inline">ch01</strong> folder. You can download the entire repository on your computer using <strong class="source-inline">git(1)</strong>, or you can access the files via the GitHub <span class="No-Break">user interface.</span></p>
<p>You can download the entire code of this book, including the code in the <strong class="source-inline">ch01</strong> folder, using <strong class="source-inline">git(1)</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
git clone git@github.com:PacktPublishing/Time-Series-Indexing.git</pre>
<p>As the repository name is long and the local directory is named after the repository name, you can execute the previous command as follows to shorten the <span class="No-Break">folder name:</span></p>
<pre class="source-code">
git clone git@github.com:PacktPublishing/Time-Series-Indexing.git tsi</pre>
<p>This is going to put the contents of the repository in a directory named <strong class="source-inline">tsi</strong>. Both ways are valid – do what is best <span class="No-Break">for you.</span></p>
<p>The code of the book is now on your local machine. However, you are going to need to have some Python packages installed for most of the code to run – we are going to discuss the required Python packages later on in <span class="No-Break">this chapter.</span></p>
<p class="callout-heading">Disclaimer</p>
<p class="callout">This code of the book was written and tested on Arch Linux and macOS Ventura machines. Even though the book is Unix-oriented, there exist similar commands that can be executed on a Microsoft Windows machine that should not be so difficult to find and execute. What is important is the presented code, understanding the code and the logic behind it, and being able to execute and make changes to it on your own. If this information helps you, I am mainly using Microsoft Visual Studio Code to write code on both macOS <span class="No-Break">and Linux.</span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Understanding time series</h1>
<p>A time series is a set of data. Keep in mind that a time series does not have to contain time or date data in it – time and date data usually come in the form of <em class="italic">timestamps</em>. So, a time series might contain timestamps, but usually, it does not. In fact, most of the time series in this book do not contain timestamps. In practice, what we really need is ordered data – this is what makes a bunch of values a <span class="No-Break">time series.</span></p>
<p>Strictly speaking, a time series (<em class="italic">T</em>) of size <em class="italic">n</em> is an ordered list of data points: <span class="_-----MathTools-_Math_Variable_v-normal">T</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">{</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">0</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">1</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">2</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">…</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">n</span><span class="subscript">−</span><span class="subscript">1</span><span class="_-----MathTools-_Math_Base">}</span>. Data points can be timestamped and store a single value, a set of values, or a list of values. The index of a time series might begin with 1 instead of 0 – in this case, <span class="_-----MathTools-_Math_Variable_v-normal">T</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">{</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">1</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">2</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">3</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">…</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">t</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">n</span><span class="_-----MathTools-_Math_Base">}</span>. What is truly important here is that the length of the time series is <em class="italic">n</em> in both cases. So, each element has an index value associated with it, which replaces the need for a timestamp. Time series in this book are going to use index values to distinguish their elements. The following ordered list can be considered a time series – <strong class="source-inline">{1, -2, -3, 4, 5, 1, 2, 0.23, 4.3}</strong>. It contains nine elements. The first element is <strong class="source-inline">1</strong> and the last element is <strong class="source-inline">4.3</strong>. If the index of the first element is <strong class="source-inline">0</strong>, then the index of the last element would be <strong class="source-inline">8</strong>, whereas if the index of the first element is <strong class="source-inline">1</strong>, then the index of the last element is going to be <strong class="source-inline">9</strong>. Time series can contain the same value <span class="No-Break">multiple times.</span></p>
<p class="callout-heading">An alternative definition of time series</p>
<p class="callout">A time series is a collection of observations made sequentially in time. Many types of observations are not true time series but can be transformed into <span class="No-Break">time series.</span></p>
<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em> shows a graphical representation of a time series with 1,000 elements – even with a small time series such as the one presented here, it is difficult to search for a specific subsequence or value. As we will discuss later on, this is why indexing <span class="No-Break">is important.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer005">
<img alt="Figure 1.1 – Visualizing a time series" height="730" src="image/Figure_1.1_B14769.jpg" width="968"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Visualizing a time series</p>
<p>In the <em class="italic">Visualizing time series</em> section, we will learn how to visualize a time series <span class="No-Break">in Python.</span></p>
<p>The next subsection tells us where we can find time <span class="No-Break">series data.</span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Time series are everywhere</h2>
<p>You might now ask where we can find time series. The answer is simple: time series are everywhere! From medical data to positional data and from software and hardware metrics to financial information and stock prices! Successfully using them allows us to find answers to questions we might have, such as which stock to sell or which hard disk is going <span class="No-Break">to fail.</span></p>
<p>Let us look at some definitions that we need to know to understand the <span class="No-Break">concepts better.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Essential definitions</h2>
<p>In this subsection, we are going to learn some core definitions related to <span class="No-Break">time series:</span></p>
<ul>
<li>The <em class="italic">length</em> of a time series or a subsequence is the number of elements found in the time series or <span class="No-Break">the subsequence.</span></li>
<li>A <em class="italic">subsequence</em> <em class="italic">s</em> of size <em class="italic">w</em> of a time series  <em class="italic">T</em>  is a sublist of <em class="italic">T</em>, with consecutive elements of <span class="No-Break">length </span><span class="No-Break"><em class="italic">w</em></span><span class="No-Break">.</span></li>
<li>A <em class="italic">sliding window</em> of size <em class="italic">w</em> decomposes a time series into subsequences of size <em class="italic">w</em>. The sliding window separates a time series into multiple subsequences, with a length equal to the sliding window value. Given a time series with length <em class="italic">n</em> and a sliding window of size <em class="italic">w</em>, the total number of subsequences of size <em class="italic">w</em> is equal <span class="No-Break">to </span><span class="No-Break"><em class="italic">n</em></span><span class="No-Break">-</span><span class="No-Break"><em class="italic">w</em></span><span class="No-Break">+</span><span class="No-Break"><em class="italic">1</em></span><span class="No-Break">.</span></li>
</ul>
<p>Let us now give you an example. Imagine having the following time series, T: {0, 1, 2, 3, 4, 5, 6}. Given a sliding window of size <em class="italic">5</em>, <em class="italic">T</em> can be separated into the <span class="No-Break">following subsequences:</span></p>
<ul>
<li><strong class="source-inline">{0, 1, 2, </strong><span class="No-Break"><strong class="source-inline">3, 4}</strong></span></li>
<li><strong class="source-inline">{1, 2, 3, </strong><span class="No-Break"><strong class="source-inline">4, 5}</strong></span></li>
<li><strong class="source-inline">{2, 3, 4, </strong><span class="No-Break"><strong class="source-inline">5, 6}</strong></span></li>
</ul>
<p>So, we have three subsequences in total, each having a length of <em class="italic">5</em>. As this is a tedious process, we are going to learn how to tell a computer to do that for us in <span class="No-Break">this chapter.</span></p>
<p>The next subsection briefly discusses the subject of time series <span class="No-Break">data mining.</span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Time series data mining</h2>
<p><strong class="bold">Data mining</strong> is the study of collecting, cleaning up, processing, analyzing, and understanding data. Data mining is a large subject. In fact, data mining is an area of computer science with its own subtopics and areas. The most important areas of data mining are <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Classification</strong>: This is the process of determining the class label of an element given a set of predefined <span class="No-Break">class labels</span></li>
<li><strong class="bold">Clustering</strong>: This is the process of grouping data into sets so that group members are similar to each other, based on a given criterion, which is usually a <span class="No-Break">distance function</span></li>
<li><strong class="bold">Outlier detection</strong>: This is the process of finding an observation that differs from other ones enough to raise suspicions that it was created by a <span class="No-Break">different process</span></li>
</ul>
<p><em class="italic">Time series data mining</em>, as the term suggests<em class="italic">,</em> is the data mining of time series. The main difference between regular data mining and time series data mining is that in time series, data comes sorted by time. Therefore, you cannot arrange time series data on your own. Although time gives context, what is important is the <span class="No-Break">actual value.</span></p>
<p>Apart from time, time series data can also be characterized by longitude and latitude values (<em class="italic">spatial data</em>). We are not going to deal with spatial data in <span class="No-Break">this book.</span></p>
<p>Having time series data is good, but it might be useless if we cannot compare this data. The next subsection shows some popular techniques and algorithms for comparing <span class="No-Break">time series.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Comparing time series</h2>
<p>To compare anything, we need a metric. We can compare numerical values because the values are the metrics. But how do we compare time series? This is an active research subject that does not have a <span class="No-Break">definitive answer.</span></p>
<p>Before you continue reading the remaining chapter, take some time and try to think whether you can compare time series with a different number of elements. Is that even possible? <em class="italic">Write down your thoughts</em> before you continue reading and find out <span class="No-Break">the answer.</span></p>
<p>Well, it turns out that you can compare time series with a different number of elements. However, not all metric functions support <span class="No-Break">that functionality.</span></p>
<p class="callout-heading">Writing and reading</p>
<p class="callout">Reading any worthwhile book or research paper is good and allows you to learn new things and keep your mind active. However, to test your knowledge and organize your thoughts, you need to write them down! I do that all the time. After all, this is how this book <span class="No-Break">was created!</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>The Euclidean distance</h2>
<p>The Euclidean distance is a way of finding out how close or how far apart a couple of time series are. Put simply, the Euclidean distance measures the shortest path between two multidimensional points. A time series or a subsequence with more than one element is a <span class="No-Break">multidimensional point.</span></p>
<p>The Euclidean distance <strong class="bold">prioritizes time</strong> – it compares data points that appear at the same time and ignores anything else. Therefore, if two time series only match at different times, they are considered dissimilar. Finally, the Euclidean distance works with data of many dimensions – in this book, we use data of one dimension only. Do not confuse <strong class="bold">multidimensional points</strong> with <strong class="bold">multidimensional data</strong>. Multidimensional data contains multidimensional points. The time series of this book contains data with one dimension only (single values). However, we can consider a time series or subsequence as a <span class="No-Break"><em class="italic">multi-dimensional point</em></span><span class="No-Break">.</span></p>
<p>The formula to calculate the Euclidean distance of two multidimensional points can be described as follows. Given a point <span class="_-----MathTools-_Math_Variable_v-normal">p</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">1</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">2</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">…</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">n</span><span class="_-----MathTools-_Math_Base">)</span> and a point <span class="_-----MathTools-_Math_Variable_v-normal">q</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">1</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">2</span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Operator">…</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">,</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">n</span><span class="_-----MathTools-_Math_Base">)</span>, the Euclidean distance is the square root of the sum of all <span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="No-Break"><span class="superscript">2</span></span><span class="No-Break"> values:</span></p>
<p>Let us now present some examples by calculating the Euclidean distance of two subsequence pairs. The first pair is <strong class="source-inline">p =</strong> <strong class="source-inline">{1, 2, 3}</strong> and <strong class="source-inline">q =</strong> <strong class="source-inline">{0, 2, 2}</strong>. So, first, we find all <span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="No-Break"><span class="superscript">2</span></span><span class="No-Break"> values:</span></p>
<ul>
<li><em class="italic"><a id="_idTextAnchor024"/></em><em class="italic">(</em><em class="italic">1</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">0</em><em class="italic">)</em><em class="italic"> </em><span class="superscript">2</span><em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">1</em></li>
<li><em class="italic"><a id="_idTextAnchor025"/></em><em class="italic">(</em><em class="italic">2</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">2</em><em class="italic">)</em><em class="italic"> </em><span class="superscript">2</span><em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">0</em></li>
<li><em class="italic"><a id="_idTextAnchor026"/></em><em class="italic">(</em><em class="italic">3</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">2</em><em class="italic">)</em><em class="italic"> </em><span class="superscript">2</span><em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">1</em></li>
</ul>
<p>Then, we add the results: 1 + 0 + 1 = <span class="No-Break">2.</span></p>
<p>Last, we find the square root of the result, which is approximately equal <span class="No-Break">to 1.414213.</span></p>
<p>Now, imagine having the following two time series or subsequences – <strong class="source-inline">p =</strong> <strong class="source-inline">{1, 2, -1, -3}</strong> and <strong class="source-inline">q =</strong> <strong class="source-inline">{-3, 1, 2, -1}</strong>. Although the time series have the same elements, these elements are in a different order. Their Euclidean distance can be calculated as before. First, we find all <span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="No-Break"><span class="superscript">2</span></span><span class="No-Break"> values:</span></p>
<ul>
<li><a id="_idTextAnchor027"/><span class="_-----MathTools-_Math_Base">[</span><span class="_-----MathTools-_Math_Number">1</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">3</span><span class="_-----MathTools-_Math_Number">)</span><span class="_-----MathTools-_Math_Base">]</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Number">4</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Base"> </span><span class="No-Break"><span class="_-----MathTools-_Math_Number">16</span></span></li>
<li><a id="_idTextAnchor028"/><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Number">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">1</span><span class="_-----MathTools-_Math_Number">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Number">1</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">1</span></li>
<li><a id="_idTextAnchor029"/><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">1</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">2</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">3</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">9</span></li>
<li><a id="_idTextAnchor030"/><span class="_-----MathTools-_Math_Base">[</span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">3</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">1</span><span class="_-----MathTools-_Math_Number">)</span><span class="_-----MathTools-_Math_Base">]</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base">(</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">2</span><span class="_-----MathTools-_Math_Base">)</span><span class="_-----MathTools-_Math_Base"> </span><span class="superscript">2</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">=</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Number">4</span></li>
</ul>
<p>Therefore, the Euclidean distance is equal to the square root of (16+1+9+4) = 30, which approximately is equal <span class="No-Break">to 5.4472.</span></p>
<p>A major drawback of the Euclidean distance is that it requires the two time series to be of the same length. Although there exist techniques to overcome that limitation, this is still an issue. One of the techniques involves using extrapolation to make the length of the smaller time series equal to the length of the <span class="No-Break">bigger one.</span></p>
<p>Going forward, we are not going to calculate Euclidean distances manually, as <em class="italic">NumPy</em> offers a better way of doing so – this is illustrated <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ed.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
#!/usr/bin/env python3 
import numpy as np
import sys
def euclidean(a, b):
    return np.linalg.norm(a-b)
def main():
    ta = np.array([1, 2, 3])
    tb = np.array([0, 2, 2])
    if len(ta) != len(tb):
        print("Time series should have the same length!")
        print(len(ta), len(tb))
        sys.exit()
    ed = euclidean(ta, tb)
    print("Euclidean distance:", ed)
if __name__ == '__main__':
    main()</pre>
<p>The <strong class="source-inline">euclidean()</strong> function takes two NumPy arrays as input and returns their Euclidean distance as output, using <strong class="source-inline">np.linalg.norm()</strong>. This works because the Euclidean distance is the <strong class="source-inline">l2</strong> norm and the default value of the <strong class="source-inline">ord</strong> parameter in <strong class="source-inline">numpy.linalg.norm()</strong> is <strong class="source-inline">2</strong>, which is the reason for not specifically defining it. You do not need to remember that; just use the <strong class="source-inline">euclidean()</strong> function <span class="No-Break">when needed.</span></p>
<p>The two<a id="_idIndexMarker000"/> time series are hardcoded in the script. Running <strong class="source-inline">ed.py</strong> generates<a id="_idIndexMarker001"/> the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ ./ed.py
Euclidean distance: 1.4142135623730951</pre>
<h2 id="_idParaDest-24">The Chebyshe<a id="_idTextAnchor031"/>v distance</h2>
<p>The Chebyshev <a id="_idIndexMarker002"/>distance<a id="_idIndexMarker003"/> has a totally different logic than the Euclidean distance. This does not make it superior or inferior to the Euclidean distance, just different. If you do not know what to use, go with the <span class="No-Break">Euclidean distance.</span></p>
<p>So, the Chebyshev distance between two multidimensional points is equal to the greatest distance of<a id="_idTextAnchor032"/> all <span class="_-----MathTools-_Math_Base">|</span><span class="_-----MathTools-_Math_Variable">p</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Operator">−</span><span class="_-----MathTools-_Math_Base"> </span><span class="_-----MathTools-_Math_Variable">q</span><span class="_-----MathTools-_Math_Base"> </span><span class="subscript">i</span><span class="_-----MathTools-_Math_Base">|</span> values. The || symbol is the <em class="italic">absolute value</em> of a quantity. Put simply, the <em class="italic">absolute value</em> of a quantity is equal to the value without the plus or <span class="No-Break">minus sign.</span></p>
<p>Let us now present some examples by calculating the Chebyshev distance of two subsequence pairs. The first pair is <strong class="source-inline">{1, 2, 3}</strong> and <strong class="source-inline">{0, 2, 2}</strong>. Now, let us find the distances between <span class="No-Break">the pairs:</span></p>
<ul>
<li><em class="italic">|1 – 0| = 1</em></li>
<li><em class="italic">|2 – 2| = 0</em></li>
<li><em class="italic">|3 – 2| = 1</em></li>
</ul>
<p>So, the maximum of 1, 0, and 1 is equal to 1, which is the <span class="No-Break">Chebyshev distance.</span></p>
<p>The second pair is <strong class="source-inline">{1, 2, -1, -3}</strong> and <strong class="source-inline">{-3, 1, 2, -1}</strong>. As before, we find the distances between the pairs of the points at the same position (<span class="No-Break">same index):</span></p>
<ul>
<li><em class="italic">|1 – (–3)| = 4</em></li>
<li><em class="italic">|2 – 1| = 1</em></li>
<li><em class="italic">|(–1) – 2| = 3</em></li>
<li><em class="italic">|(–3) – (–1)| = 2</em></li>
</ul>
<p>So, the maximum of 4, 1, 3, and 2 is equal to 4, which is the Chebyshev distance of the <span class="No-Break">aforementioned pair.</span></p>
<p>Later in this chapter, we are going to learn about a more sophisticated distance function, which is <span class="No-Break">called </span><span class="No-Break"><em class="italic">MPdist</em></span><span class="No-Break">.</span></p>
<p>Now that we know how to compare time series and subsequences, it is time to discuss indexes <a id="_idIndexMarker004"/>and<a id="_idIndexMarker005"/> indexing. Keep in mind that we cannot create an index without being able to compare its data, which includes time <span class="No-Break">series data.</span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor033"/>What is an index and why do we need indexing?</h1>
<p>Can you imagine <a id="_idIndexMarker006"/>searching for a<a id="_idIndexMarker007"/> surname in an unsorted list of names? Can you imagine looking for a book in a library that does not sort its books based on book subject (the Dewey system) and then book title and author surname? I cannot! Both examples showcase a naïve but efficient indexing scheme. The more complex the data, the more sophisticated the index should be in order to perform quick searches and maybe updates on <span class="No-Break">the data.</span></p>
<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> shows the visualization of a <a id="_idIndexMarker008"/>really small <strong class="bold">iSAX</strong> index – in reality, as a time series can be really huge, iSAX indexes tend to be much bigger and <span class="No-Break">more complex.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<img alt="Figure 1.2 – A small iSAX index" height="612" src="image/Figure_1.2_B14769.jpg" width="1171"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A small iSAX index</p>
<p>Do not try to understand the iSAX index or the titles of the nodes at this point. Everything is going to become clearer in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> and <a href="B14769_03.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. For now, keep in mind that the titles of the nodes are <em class="italic">SAX words</em> and that there exist two kinds of nodes on an iSAX index – <em class="italic">internal nodes</em> and <em class="italic">terminal nodes</em> (leaf nodes). Everything about the iSAX index <a id="_idIndexMarker009"/>and its<a id="_idIndexMarker010"/> connection with SAX words will become clear in <a href="B14769_03.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></p>
<p>In the next section, we will begin working with Python and set up <span class="No-Break">our environment.</span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor034"/>The Python knowledge that we are going to need</h1>
<p>All the <a id="_idIndexMarker011"/>presented<a id="_idIndexMarker012"/> code in this book is written in Python. Therefore, in this section, we are going to present the required Python knowledge for you to follow this book better. However, do not expect to learn the basics of Python here – more appropriate books exist for <span class="No-Break">that purpose.</span></p>
<p class="callout-heading">What about other programming languages?</p>
<p class="callout">Once you learn and understand the presented theory, the Python code of this book can be easily translated into any other modern programming language, such as Swift, Java, C, C++, Ruby, Kotlin, Go, Rust, <span class="No-Break">or JavaScript.</span></p>
<p>You might have compatibility issues with the used Python packages if you keep updating them for no particular reason. As a rule of thumb, I would suggest that throughout this book, you should use the same package versions, provided that they work well with each other. There exist two main ways to achieve that. You can stop upgrading your Python installation once you find the versions that work, or you can use a Python package manager such as Anaconda or <strong class="source-inline">pyenv</strong>. In this book, we are going to <span class="No-Break">use Anaconda.</span></p>
<p>It does not matter what you use, as long as you know how to operate your tools and have a stable and reliable Python environment to <span class="No-Break">work with.</span></p>
<p>I hope we all agree that the most important property of any code is correctness. However, after <a id="_idIndexMarker013"/>we have working code, we might need to optimize it, but we <a id="_idIndexMarker014"/>cannot optimize code if we do not know whether it runs slowly or not. So, the next section shows you how to calculate the time it takes Python code <span class="No-Break">to execute.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor035"/>Timing Python code</h2>
<p>There are times when <a id="_idIndexMarker015"/>we need to know how slow or how fast our code is being executed because some operations might take hours or even days. This section presents a simple technique to calculate the time it takes a block of code <span class="No-Break">to run.</span></p>
<p>The <strong class="source-inline">timing.py</strong> script shows a technique to time Python code – this might come in really handy when you want to learn how much time it takes for a process to finish. The source code of <strong class="source-inline">timing.py</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import time
start_time = time.time()
for i in range(5):
    time.sleep(1)
print("--- %.5f seconds ---" % (time.time() - start_time))</pre>
<p>We use <strong class="source-inline">time.time()</strong> to initiate the beginning of the timing and the same statement to declare the end of the timing. The difference between these two statements is the desired result. You can also keep that difference in a <span class="No-Break">separate variable.</span></p>
<p>The program executes <strong class="source-inline">time.sleep(1)</strong> five times, which means the total time should be pretty close<a id="_idIndexMarker016"/> to 5 seconds. Running <strong class="source-inline">timing.py</strong> generates the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ ./timing.py
--- 5.01916 seconds ---</pre>
<p class="callout-heading">About the Python scripts</p>
<p class="callout">In this book, we<a id="_idIndexMarker017"/> are mostly going to show you the Python scripts in full without omitting any statements. Although this adds some extra lines, it helps you understand the functionality of the Python scripts by looking at their <strong class="source-inline">import</strong> statements before reading the actual <span class="No-Break">Python code.</span></p>
<p>The next subsection is about the Anaconda software, which is used to create <span class="No-Break">Python environments.</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/>An introduction to Anaconda</h2>
<p>Anaconda<a id="_idIndexMarker018"/> is a product <a id="_idIndexMarker019"/>for package, dependency, and environment management. Although Anaconda is a commercial product, there exists an Individual Edition for solo practitioners, students, and researchers. What Anaconda does is create a controlled environment where you can define the version of Python as well as the versions of the packages you want to use. Additionally, you can create multiple environments and switch <span class="No-Break">between them.</span></p>
<p>You do not have to use Anaconda if you do not want to – however, if you are using Python 3 and you do not want to become overwhelmed by the details of Python 3 package versions, incompatibilities, and dependencies, then you should give Anaconda a try. The reason for needing package and environment management software is because some Python packages are very picky about the Python version used. Put simply, Anaconda makes sure that your Python 3 environment is not going to change and gives you the <a id="_idIndexMarker020"/>capability<a id="_idIndexMarker021"/> to transfer your Python 3 environments to multiple machines. The Anaconda command line tool is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">conda</strong></span><span class="No-Break">.</span></p>
<h3>Installing Anaconda</h3>
<p>Anaconda is<a id="_idIndexMarker022"/> a huge piece of software, as it contains lots of packages and utilities. There exist multiple ways to install Anaconda, which mainly depend on your <span class="No-Break">development environment.</span></p>
<p>On a macOS Ventura machine, we can install Anaconda using Homebrew <span class="No-Break">as follows:</span></p>
<pre class="source-code">
$ brew install anaconda</pre>
<p>On an Arch Linux machine, Anaconda can be installed <span class="No-Break">as follows:</span></p>
<pre class="source-code">
$ pacman -S anaconda</pre>
<p>We will not discuss the Anaconda installation in any more detail. The installation process is straightforward and contains lots of information. The single most important task to do is to include the Anaconda utilities on your <strong class="source-inline">PATH</strong> environment variable, in order for them to be accessible from everywhere on your UNIX shell. This also depends on the UNIX shell you are using – I use <strong class="source-inline">zsh</strong> with the Oh My Zsh extensions on both my Linux and macOS machines, but your environment might most <span class="No-Break">likely vary.</span></p>
<p>If you choose to use Anaconda to work with this book, please make sure that you can access the <strong class="source-inline">conda</strong> binary and that you can enable and disable Anaconda on your machine at will – you might not need to use Anaconda all <span class="No-Break">the time.</span></p>
<p>On my macOS Ventura machine, I can disable Anaconda <span class="No-Break">as follows:</span></p>
<pre class="source-code">
$ conda deactivate</pre>
<p>I can also enable Anaconda <span class="No-Break">as follows:</span></p>
<pre class="source-code">
$ source /opt/homebrew/anaconda3/bin/activate base</pre>
<p>You should replace <strong class="source-inline">base</strong> with the desired <span class="No-Break">Anaconda environment.</span></p>
<p>The previous command depends on the path where Anaconda was installed. Therefore, on my Arch Linux machine, I should execute the following <span class="No-Break">command instead:</span></p>
<pre class="source-code">
$ source /opt/anaconda/bin/activate base</pre>
<p>You should modify the previous command to fit your <span class="No-Break">Anaconda installation.</span></p>
<p>When a new<a id="_idIndexMarker023"/> Anaconda version is available, you can update to the latest version by executing the <span class="No-Break">next command:</span></p>
<pre class="source-code">
$ conda update -n base -c defaults conda</pre>
<h3>Creating a new Anaconda environment</h3>
<p>The single most important <a id="_idIndexMarker024"/>thing to decide when creating a new Anaconda environment is the selection of the Python 3 version. In order to create a new Anaconda environment named <strong class="source-inline">TSI</strong> that uses Python 3.8.5, you should run the <span class="No-Break">following command:</span></p>
<pre class="source-code">
$ conda create  ––name TSI python=3.8.5</pre>
<p>In order to activate this environment, run <strong class="source-inline">conda activate TSI</strong>. The <strong class="source-inline">python3 --version</strong> command shows the Python version included in a given <span class="No-Break">Anaconda environment.</span></p>
<p>You can list all existing Anaconda environments using the <strong class="source-inline">conda info --envs</strong> command (the <strong class="source-inline">*</strong> character shows the <span class="No-Break">active one):</span></p>
<pre class="source-code">
$ conda info --envs
# conda environments:
#
TSI                      /home/mtsouk/.conda/envs/TSI
base                    /opt/anaconda</pre>
<h3>Changing to a different environment</h3>
<p>This subsection<a id="_idIndexMarker025"/> presents the <strong class="source-inline">conda</strong> command used to change from one environment to another. Changing to a different environment is as simple as activating a different environment using <strong class="source-inline">conda </strong><span class="No-Break"><strong class="source-inline">activate environment_name</strong></span><span class="No-Break">.</span></p>
<h3>Installing a Python package</h3>
<p>Although<a id="_idIndexMarker026"/> you can still use <strong class="source-inline">pip3</strong> to install Python <a id="_idIndexMarker027"/>packages, the best way to install a Python package in an Anaconda environment is with the <strong class="source-inline">conda install</strong> command. Keep in mind that the <strong class="source-inline">conda install</strong> command cannot install all packages – in this case, use <span class="No-Break"><strong class="source-inline">pip3</strong></span><span class="No-Break"> instead.</span></p>
<h3>Listing all installed packages</h3>
<p>The <strong class="source-inline">conda list</strong> command <a id="_idIndexMarker028"/>gives you a full list of installed Python packages under a given Anaconda environment. As the list is pretty long, we will show you just a part <span class="No-Break">of it:</span></p>
<pre class="source-code">
$ conda list
# packages in environment at /home/mtsouk/.conda/envs/TSI:
#
# Name                    Version                   Build
python                    3.8.5                h7579374_1
readline                  8.2                  h5eee18b_0
numpy                     1.23.5                   pypi_0
pandas                    1.5.2                    pypi_0</pre>
<h3>Deleting an existing environment</h3>
<p>You can delete<a id="_idIndexMarker029"/> an existing Anaconda environment <em class="italic">that is not active</em> using the <strong class="source-inline">conda env remove --name ENVIRONMENT</strong> command. Its execution is illustrated in the following output when deleting an environment <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">mtsouk</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$ conda env remove --name mtsouk
Remove all packages in environment /home/mtsouk/.conda/envs/mtsouk:</pre>
<p>This discussion of Python environments, package versions, and package incompatibilities culminates here. From now on, let us assume that we have a stable Python environment where we can use existing Python packages, develop new Python packages, and run Python scripts without any issues. The next subsection lists the Python packages that we need <span class="No-Break">to</span><span class="No-Break"><a id="_idIndexMarker030"/></span><span class="No-Break"> install.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor037"/>The required Python packages</h2>
<p>Here is a list of the<a id="_idIndexMarker031"/> required Python packages along with an explanation of the use of each one <span class="No-Break">of them:</span></p>
<ul>
<li><strong class="source-inline">NumPy</strong>: This is the standard Python package for <span class="No-Break">array computing.</span></li>
<li><strong class="source-inline">Pandas</strong>: This package offers data structures for data analysis, time series, and statistics, including functions to read data files <span class="No-Break">from disk.</span></li>
<li><strong class="source-inline">SciPy</strong>: This package offers fundamental functions for scientific computing <span class="No-Break">in Python.</span></li>
<li><strong class="source-inline">Matplotlib</strong>: This is the most popular Python package for <span class="No-Break">scientific plotting.</span></li>
<li><strong class="source-inline">Stumpy</strong>: This is a powerful package for time series analysis and time series data mining. You do not have to install it right away, as it is not needed for the development of the <span class="No-Break">iSAX index.</span></li>
</ul>
<p>These are the basic packages that you need to install in a fresh Python environment. Python will automatically install any <span class="No-Break">package dependencies.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor038"/>Setting up our environment</h2>
<p>In this subsection, we <a id="_idIndexMarker032"/>are going to set up our Anaconda environment. As explained earlier, this is not required to follow this book, but it will save you from Python package incompatibilities that might come up when upgrading Python and Python packages. We will execute the following commands in the <strong class="source-inline">TSI</strong> Anaconda environment, and then we <span class="No-Break">are done:</span></p>
<pre class="source-code">
(TSI) $ conda install numpy
(TSI) $ conda install pandas
(TSI) $ conda install scipy
(TSI) $ conda install matplotlib
(TSI) $ conda install stumpy</pre>
<h2 id="_idParaDest-31"><a id="_idTextAnchor039"/>Printing package versions</h2>
<p>In this subsection, we <a id="_idIndexMarker033"/>present a Python script that just loads the desired packages and prints their versions <span class="No-Break">on screen.</span></p>
<p>The code of <strong class="source-inline">load_packages.py</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import argparse
import stumpy
import numpy as np
import scipy
import matplotlib
def main():
     print("scipy version:", scipy.__version__)
     print("numpy version:", np.__version__) 
print("stumpy version:", stumpy.__version__) 
print("matplotlib version:", matplotlib.__version__) 
print("argparse version:", argparse.__version__) 
print("pandas version:", pd.__version__)
if __name__ == '__main__':
     main()</pre>
<p>Running <strong class="source-inline">load_packages.py</strong> on one of my UNIX machines prints the <span class="No-Break">following information:</span></p>
<pre class="source-code">
$ chmod 755 ./load_packages.py
$ ./load_packages.py
scipy version: 1.9.2
numpy version: 1.23.4
stumpy version: 1.11.1
matplotlib version: 3.6.2
argparse version: 1.1
pandas version: 1.5.0</pre>
<p>The first command is needed to make the Python script executable and is required for all Python scripts presented in this book, provided that they begin with the <strong class="source-inline">#!/usr/bin/env python3</strong> statement. If they do not begin with that statement, you can execute them using <strong class="source-inline">python3 &lt;script_name&gt;</strong> without the need to change their permissions. You can learn more about the <strong class="source-inline">chmod(1)</strong> command by running <strong class="source-inline">man chmod</strong>. From now on, we will assume that you know this information and will not present any <a id="_idIndexMarker034"/>more <strong class="source-inline">chmod</strong> commands and instructions. Your output might be a little different, but that is OK, as packages <span class="No-Break">get updated.</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor040"/>Creating sample data</h2>
<p>The official name <a id="_idIndexMarker035"/>of sample data created by a program is <strong class="bold">synthetic data</strong>. This subsection<a id="_idIndexMarker036"/> is going to present a Python script that creates synthetic data based on given parameters. The logic of the program is based on randomly generated numbers – as most of you might know, randomly generated numbers are not that random. This makes them good for testing the performance of a program but not the actual use of it. However, for the purposes of this book, synthetic data generated with the help of random numbers <span class="No-Break">is fine!</span></p>
<p>The code of the <strong class="source-inline">synthetic_data.py</strong> Python script is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import random
import sys
precision = 5
if len(sys.argv) != 4:
    print("N MIN MAX")
    sys.exit()
# Number of values
N = int(sys.argv[1])
# Minimum value
MIN = int(sys.argv[2])
# Maximum value
MAX = int(sys.argv[3])
x = random.uniform(MIN, MAX)
# Random float number
for i in range(N):
    print(round(random.uniform(MIN, MAX), precision))</pre>
<p>The script<a id="_idIndexMarker037"/> accepts three parameters, which are the <em class="italic">number of floating-point values</em> to create the minimum value and the maximum value. Running the script generates the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ ./synthetic_data.py 5 1 3
1.18243
2.81486
1.74816
1.42797
2.21639</pre>
<p>As floating-point values can have any precision you want, the <strong class="source-inline">precision</strong> variable holds the number of digits after the decimal point that will <span class="No-Break">be printed.</span></p>
<p>Creating your own time series is not the only way to get data. Publicly available time series data also exists. Let us check this <span class="No-Break">out next.</span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor041"/>Publicly available time series data</h2>
<p>Websites exist that offer <a id="_idIndexMarker038"/>samples of time series data, allowing everyone to process real-world time series data. Another important aspect of publicly available time series data is that people can compare the performance of their techniques, using the same datasets, with others. This is a huge issue in academia, where people have to prove that their techniques and algorithms are faster or more efficient in a variety of aspects compared <span class="No-Break">to others.</span></p>
<p>A very popular set of publicly available time series data files can be found at <a href="https://www.cs.ucr.edu/~eamonn/time_series_data_2018/">https://www.cs.ucr.edu/~eamonn/time_series_data_2018/</a> (the UCR Time Series <span class="No-Break">Classification Archive).</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor042"/>How time series are processed</h2>
<p>Time series <a id="_idIndexMarker039"/>processing in Python usually follows <span class="No-Break">these steps:</span></p>
<ol>
<li><strong class="bold">Importing to Python</strong>: In this step, we import the time series into Python. There exist multiple ways to do that, including reading from a local file, a database server, or an Internet location. In this book, we include all used time series in the GitHub repository as plain text files, which are compressed to save <span class="No-Break">disk space.</span></li>
<li><strong class="bold">Converting it into a time series</strong>: In this step, we convert the data we read in the previous step into a valid time series format. This mainly depends on the Python package used to store the time <span class="No-Break">series data.</span></li>
<li><strong class="bold">Dealing with missing values</strong>: In this step, we look for missing values and ways to deal with them. We are not going to deal with missing values in this book. All presented time series <span class="No-Break">are complete.</span></li>
<li><strong class="bold">Processing time series</strong>: This last step involves processing a time series in order to perform the desired task <span class="No-Break">or tasks.</span></li>
</ol>
<h1 id="_idParaDest-35"><a id="_idTextAnchor043"/>Reading time series from disk</h1>
<p>After storing<a id="_idIndexMarker040"/> a time series in a file, we need to write the necessary Python code to read it and put it in a Python variable of some type. This section will teach you exactly that. The <strong class="source-inline">read_ts.py</strong> script contains the <span class="No-Break">following code:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import numpy as np
import sys
def main():
        filename = sys.argv[1]
        ts1Temp = pd.read_csv(filename, header = None)
        # Convert to NParray
        ta = ts1Temp.to_numpy()
        ta = ta.reshape(len(ta))
        print("Length:", len(ta))
if __name__ == '__main__':
        main()</pre>
<p>After reading the time series, <strong class="source-inline">read_ts.py</strong> prints the number of elements in the <span class="No-Break">time series:</span></p>
<pre class="source-code">
$ ./read_ts.py ts2
Length: 50</pre>
<p>The <strong class="source-inline">pd.read_csv()</strong> function reads a plain text file that uses the CSV format – in our case, each value is on its own line, so there should be no issues with separating values that reside on the same line. The <strong class="source-inline">pd.read_csv()</strong> function is able to detect issues in the input file. The return value of <strong class="source-inline">pd.read_csv()</strong> is a <em class="italic">DataFrame</em> or <em class="italic">TextParser</em>. In our case, it is <span class="No-Break">a </span><span class="No-Break"><em class="italic">DataFrame</em></span><span class="No-Break">.</span></p>
<p>Putting <strong class="source-inline">.astype(np.float64)</strong> at the end of the <strong class="source-inline">pd.read_csv()</strong> statement is going to ensure that all values are read as floating-point values, even when the entire time series contains integer values only. Additionally, <strong class="source-inline">header = None</strong> ensures that the input does not contain a header line with text or data different from the <span class="No-Break">actual data.</span></p>
<p>The <strong class="source-inline">ts1Temp.to_numpy()</strong> call converts a <em class="italic">DataFrame</em> into a NumPy array. So, the return value of <strong class="source-inline">ts1Temp.to_numpy()</strong> is a NumPy array. This is needed because we will work with <span class="No-Break">NumPy arrays.</span></p>
<p>The <strong class="source-inline">ta.reshape(len(ta))</strong> call gives a new shape to an existing NumPy array without changing the data. This is needed for processing the time series data using the <span class="No-Break">correct shape.</span></p>
<p>As files with time series can be pretty big, it is a good idea to compress them and use them in compressed format. Fortunately, Pandas can read compressed files with the help of a parameter. This is illustrated in the <strong class="source-inline">read_ts_gz.py</strong> script. The statement that does the <a id="_idIndexMarker041"/>job is <strong class="source-inline">pd.read_csv(filename, compression='gzip', header = None).astype(np.float64)</strong>. Here, you also see <strong class="source-inline">.astype(np.float64)</strong> <span class="No-Break">in action.</span></p>
<p class="callout-heading">How to store time series</p>
<p class="callout">This book uses plain text files to store time series. In these files, each value is in a separate line. More ways exist to store a time series, including the CSV format and the <span class="No-Break">JSON format.</span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor044"/>Is all data numeric?</h2>
<p>Not all data is<a id="_idIndexMarker042"/> numeric, but in time series, almost all data is numeric. The presented script reads a plain text file and makes sure that all data is numeric – note that the <strong class="source-inline">isNumeric.py</strong> script does not currently support compressed files, as it uses the <strong class="source-inline">open()</strong> call to read the input file and it expects a single value <span class="No-Break">per line.</span></p>
<p>The code <a id="_idIndexMarker043"/>of <strong class="source-inline">isNumeric.py</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    TS = sys.argv[1]
    file = <strong class="bold">open</strong>(TS, 'r')
    Lines = file.readlines()
    count = 0
    for line in Lines:
        # Strips the newline character
        t = line.strip()
        try:
            _ = <strong class="bold">float(t)</strong>
        except:
            count = count + 1
    print("Number of errors:", count)
if __name__ == '__main__':
    main()</pre>
<p>The <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> block is where we try to convert the current string value into a floating-point value using <strong class="source-inline">float()</strong>. If this fails, we know that we are not dealing with a valid <span class="No-Break">numerical value.</span></p>
<p>Running <strong class="source-inline">isNumeric.py</strong> produces the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ cat ts.txt
5.2
-12.4
-    # Error
17.9
a a     # Error
2 3 4    # Error
4.2
$ ./isNumeric.py ts.txt
Number of errors: 3</pre>
<p>As we<a id="_idIndexMarker044"/> have three erroneous lines, the result <span class="No-Break">is correct.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor045"/>Do all lines have the same amount of data?</h2>
<p>In this subsection, we <a id="_idIndexMarker045"/>present a script that counts the number of words in each line, checks that each word is a valid float value, and checks that each line has the same number of values. If not, it states the expected and found number of fields. Additionally, it considers the first line read as the correct one, so all the following lines should have the same amount of data fields. Values are separated by <span class="No-Break">whitespace characters.</span></p>
<p>The code of <strong class="source-inline">floats_per_line.py</strong> is <span class="No-Break">the following:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    TS = sys.argv[1]
    file = open(TS, 'r')
    Lines = file.readlines()
    first = True
    wordsPerLine = 0
    for line in Lines:
        t = line.strip()
        words = t.split()
        for word in words:
            try:
                _ = float(word)
            except:
                print("Error:", word)
        if first:
            wordsPerLine = len(words)
            first = False
        elif wordsPerLine != len(words):
            print("Expected", wordsPerLine, "found", len(words))
            continue
if __name__ == '__main__':
    main()</pre>
<p>If <strong class="source-inline">String.split()</strong> is executed without any arguments, it splits the string using all the whitespace characters as delimiters, which is what we do here to separate the fields of each input line. If your data is in a different format, you might need to modify the <strong class="source-inline">String.split()</strong> statement to match <span class="No-Break">your needs.</span></p>
<p>Running <strong class="source-inline">floats_per_line.py</strong> produces<a id="_idIndexMarker046"/> the following kind <span class="No-Break">of output:</span></p>
<pre class="source-code">
$ ./floats_per_line.py ts.txt
Error: -
Error: a
Error: b
Expected 1 found 2
Expected 1 found 3</pre>
<p>The next subsection shows how to process time series based on the sliding <span class="No-Break">window size.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor046"/>Creating subsequences</h2>
<p>Although we <a id="_idIndexMarker047"/>read a time series as an entity from a plain text file, we process it as a large list of subsequences. In this subsection, you are going to learn how to process a time series as a list of subsequences, based on a given sliding <span class="No-Break">window size.</span></p>
<p>The name of the Python script is <strong class="source-inline">subsequences.py</strong>. We are going to present it in two parts. Among other things, the first part contains the Python structure used to keep <span class="No-Break">the subsequences:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
import stumpy
import numpy as np
import pandas as pd
import sys
class TS:
    def __init__(self, ts, index):
        self.ts = ts
        self.index = index</pre>
<p>The <strong class="source-inline">TS</strong> class has two members, one to hold the actual data (the <strong class="source-inline">ts</strong> variable) and the other to keep the index (index variable) number of the subsequence. The chapters that follow are going to enrich the <strong class="source-inline">TS</strong> class to fit our <span class="No-Break">growing needs.</span></p>
<p>The rest of the <a id="_idIndexMarker048"/>script is <span class="No-Break">the following:</span></p>
<pre class="source-code">
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", dest = "window", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    file = args.TS
    ts = pd.read_csv(file, names=['values'], compression='gzip', header = None)
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    # Split time series into subsequences
    for i in range(length - windowSize + 1):
        # Get the subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = TS(ts, i)
if __name__ == '__main__':
    main()</pre>
<p>The <strong class="source-inline">argparse</strong> package helps us put the command-line arguments in order. In this case, we expect two parameters: first, the sliding window size (<strong class="source-inline">-w</strong>), and second, the filename that holds the time series. The <strong class="source-inline">for</strong> loop is used to split the time series into subsequences and generate multiple <strong class="source-inline">TS</strong> <span class="No-Break">class members.</span></p>
<p>The previous code is not something difficult to read or understand or make changes to. Expect to see <a id="_idIndexMarker049"/>this sort of code in most of the Python scripts in <span class="No-Break">this book!</span></p>
<p>In its current form, <strong class="source-inline">subsequences.py</strong> generates no output. You will only get error messages if something is wrong with the provided filename or <span class="No-Break">its data.</span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor047"/>Visualizing time series</h1>
<p>Most of the time, having <a id="_idIndexMarker050"/>a high-level overview of your data is an excellent way to get to know your data. The best way to get an overview of a time series is by <span class="No-Break">visualizing it.</span></p>
<p>There are multiple ways to visualize a time series, including tools such as R or Matlab, or using a large amount of existing JavaScript packages. In this section, we are going to use a Python package called Matplotlib for visualizing the data. Additionally, we will save the output to a PNG file. A viable alternative to this is to use a Jupyter notebook – Jupyter comes with Anaconda – and display the graphical output on your favorite <span class="No-Break">web browser.</span></p>
<p>The <strong class="source-inline">visualize.py</strong> script reads a plain text file with values – a time series – and creates a plot. The <a id="_idIndexMarker051"/>Python code of <strong class="source-inline">visualize.py</strong> is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import math
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    F = sys.argv[1]
    # Read Sequence as Pandas
    ts = pd.read_csv(F, compression='gzip', header = None)
    # Convert to NParray
    ta = ts.to_numpy()
    ta = ta.reshape(len(ta))
    <strong class="bold">plt.plot</strong>(ta, label=F, linestyle='-', markevery=100, marker='o')
    plt.xlabel('Time Series', fontsize=14)
    plt.ylabel('Values', fontsize=14)
    plt.grid()
    <strong class="bold">plt.savefig</strong>("CH01_03.png", dpi=300, format='png', bbox_inches='tight')
if __name__ == '__main__':
    main()</pre>
<p>You must be familiar with most of the presented code, as you already saw some of it earlier in this chapter. The <strong class="source-inline">plt.plot()</strong> statement plots the data, whereas the <strong class="source-inline">plt.savefig()</strong> function saves the output in the file instead of displaying it <span class="No-Break">on screen.</span></p>
<p>The output from <a id="_idIndexMarker052"/>the <strong class="source-inline">./visualize.py ts1.gz</strong> command can be seen in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<img alt="Figure 1.3 – Visualizing a time series" height="807" src="image/Figure_1.3_B14769.jpg" width="1047"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Visualizing a time series</p>
<p>Now that we understand how to work with time series and subsequences, it is time to present an advanced technique called the <strong class="bold">Matrix Profile</strong>, which shows the tasks that we might need to<a id="_idIndexMarker053"/> compute when working with time series and how time-consuming these tasks <span class="No-Break">might be.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor048"/>Working with the Matrix Profile</h1>
<p>In this section, as <a id="_idIndexMarker054"/>well as the next one, we will work with the <strong class="source-inline">stumpy</strong> Python package. This package is not related to iSAX but offers lots of advanced functionality related to time series. With the help of <strong class="source-inline">stumpy</strong>, we can calculate the <span class="No-Break"><em class="italic">Matrix Profile</em></span><span class="No-Break">.</span></p>
<p>The Matrix Profile is <span class="No-Break">two things:</span></p>
<ul>
<li>A vector of distances that shows the distance of each subsequence in a time series to its <span class="No-Break">nearest neighbor</span></li>
<li>A vector of indexes that shows the index of the nearest neighbor of each subsequence in a <span class="No-Break">time series</span></li>
</ul>
<p>The Matrix Profile can be used in many time series mining tasks. The main reason for presenting it is to understand that working with time series can be slow, so we need structures and techniques to improve the performance of time <span class="No-Break">series-related tasks.</span></p>
<p>To get a better idea of the use of the Matrix Profile and the time it takes <strong class="source-inline">stumpy</strong> to calculate the Matrix Profile, here is the Python code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">matrix_profile.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import argparse
import time
import stumpy
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", "--window", dest = "window", default = "16", help="Sliding Window", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    inputTS = args.TS
    print("TS:", inputTS, "Sliding Window size:", windowSize)
    start_time = time.time()
    ts = pd.read_csv(inputTS, names=['values'], compression='gzip')
    # Convert to NParray
    ts_numpy = ts.to_numpy()
    ta = ts_numpy.reshape(len(ts_numpy))
    realMP = stumpy.stump(ta, windowSize)
    print("--- %.5f seconds ---" % (time.time() - start_time))
if __name__ == '__main__':
    main()</pre>
<p>The <strong class="source-inline">stumpy.stump()</strong> function <a id="_idIndexMarker055"/>calculates the Matrix Profile of a given <span class="No-Break">time series.</span></p>
<p>We are going to execute <strong class="source-inline">matrix_profile.py</strong> two times. The first time using a time series with 100,000 elements and the second time using a time series with 300,000 elements. As with almost all the Python scripts in this book that read a time series, <strong class="source-inline">matrix_profile.py</strong> expects to read compressed plain <span class="No-Break">text files.</span></p>
<p class="callout-heading">The taskset(1) command</p>
<p class="callout">The <strong class="source-inline">taskset(1)</strong> command is used to assign the desired number of cores to a given process and is currently available on Linux machines. The reason for using it is to limit the number of available cores when executing <strong class="source-inline">matrix_profile.py</strong> and <strong class="source-inline">mpdistance.py</strong>, which, by default, use all available cores due to the use of the Numba Python package. As a rule of thumb, when testing the performance of an algorithm or comparing one to another, it is better to use a single core. There is no similar utility <span class="No-Break">on macOS.</span></p>
<p>Running <strong class="source-inline">matrix_profile.py</strong> with <a id="_idIndexMarker056"/>the smaller time series produces the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ taskset --cpu-list 3 ./matrix_profile.py 100k.txt.gz
TS: 100k.txt.gz Sliding Window size: 16
--- 120.44 seconds ---</pre>
<p>So, it took <strong class="source-inline">stumpy.stump()</strong> around <strong class="source-inline">120.44 seconds</strong> to process a time series with <span class="No-Break">100,000 elements.</span></p>
<p>Running <strong class="source-inline">matrix_profile.py</strong> with the bigger time series produces the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ taskset --cpu-list 0 ./matrix_profile.py 300k.gz -w 1024
TS: 300k.gz Sliding Window size: 1024
--- 922.30060 seconds ---</pre>
<p>Here, it took <strong class="source-inline">stumpy.stump()</strong> around <strong class="source-inline">922 seconds</strong> to process a time series with 300,000 elements on a single CPU core. Now, imagine doing the same with a time series that has more than <span class="No-Break">1,000,000 elements!</span></p>
<p>You are going to learn all about the Matrix Profile and understand why it is so slow in <a href="B14769_07.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
<p>The next section <a id="_idIndexMarker057"/>discusses a distance function named <strong class="bold">MPdist</strong> that internally uses the Matrix Profile for <span class="No-Break">its computation.</span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor049"/>Exploring the MPdist distance</h1>
<p>MPdist offers a way <a id="_idIndexMarker058"/>to calculate the distance between two time series. Strictly speaking, the <em class="italic">MPdist</em> distance is a distance measure that is based on the Matrix Profile. It is much slower to compute than the Euclidean distance, but it does not require the time series to have the <span class="No-Break">same size.</span></p>
<p>As you might expect, it must offer many advantages when compared to the Euclidean distance, as well as other existing distance metrics. The main advantages of MPdist, according to the people that created it, are <span class="No-Break">the following:</span></p>
<ul>
<li>It is more flexible regarding the way it compares data than most existing <span class="No-Break">distance functions.</span></li>
<li>It considers similarities of data that may not take place at the same time, where time means at the <span class="No-Break">same index.</span></li>
<li>MPdist is considered more robust in specific analytics scenarios due to the way it is computed. More specifically, MPdist is more robust to spikes and <span class="No-Break">missing values.</span></li>
</ul>
<p>As MPdist is based on the Matrix Profile, calculating the MPdist distance can be extremely slow, especially when working with large <span class="No-Break">time series.</span></p>
<p>First, let us have a look at the Python code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">mpdistance.py</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
#!/usr/bin/env python3
import stumpy
import stumpy.mpdist
import numpy as np
import time
import sys
import pandas as pd
if len(sys.argv) != 4:
    print("TS1 + TS2 + Window size")
    sys.exit()
# Time series files
TS1 = sys.argv[1]
TS2 = sys.argv[2]
windowSize = int(sys.argv[3])
print("TS1:", TS1, "TS2:", TS2, "Window Size:", windowSize)
# Read Sequence as Pandas
ts1Temp = pd.read_csv(TS1, compression='gzip', header = None).astype(np.float64)
# Convert to NParray
ta = ts1Temp.to_numpy()
ta = ta.reshape(len(ta))
# Read Sequence as Pandas
ts2Temp = pd.read_csv(TS2, compression='gzip', header = None).astype(np.float64)
# Convert to NParray
tb = ts2Temp.to_numpy()
tb = tb.reshape(len(tb))
print(len(ta), len(tb))
start_time = time.time()
mpdist = stumpy.mpdist(ta, tb, m=windowSize)
print("--- %.5f seconds ---" % (time.time() - start_time))
print("MPdist: %.4f " % mpdist)</pre>
<p>This program uses command-line arguments with the help of <strong class="source-inline">sys</strong> to read the required data, instead of the <span class="No-Break"><strong class="source-inline">argparse</strong></span><span class="No-Break"> package.</span></p>
<p>All of this is done by the call to <strong class="source-inline">stumpy.mpdist()</strong>, which requires three parameters – the two time series and the sliding <span class="No-Break">window size.</span></p>
<p>As <strong class="source-inline">mpdistance.py</strong> calculates the distance between two time series, it expects to read two files. Running <strong class="source-inline">mpdistance.py</strong> with two synthetic data sets with 100,000 elements each <a id="_idIndexMarker059"/>generates the <span class="No-Break">following output:</span></p>
<pre class="source-code">
$ taskset --cpu-list 0 ./mpdistance.py 100k_1.txt.gz 100k_2.txt.gz 512
TS1: 100k_1.txt.gz TS2: 100k_2.txt.gz Window Size: 512
100000 100000
--- 349.81955 seconds ---
MPdist: 28.3882</pre>
<p>So, on a Linux machine with an Intel i7 CPU, it took <strong class="source-inline">mpdistance.py</strong> <strong class="source-inline">349.81955</strong> <strong class="source-inline">seconds</strong> to execute when <em class="italic">using a single CPU core</em>. The value of the MPdist distance <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">28.3882</strong></span><span class="No-Break">.</span></p>
<p>If we use two datasets with half a million elements each (500,000 elements), the output and the time it takes to execute <strong class="source-inline">mpdistance.py</strong> should be similar to <span class="No-Break">the following:</span></p>
<pre class="source-code">
$ taskset --cpu-list 3 ./mpdistance.py h_500k_f.gz t_500k_f.gz 2048
TS1: h_500k_f.gz TS2: t_500k_f.gz Window Size: 2048
506218 506218
--- 4102.92 seconds ---
MPdist: 38.2851</pre>
<p>So, on a Linux machine with an Intel i7 CPU, it took <strong class="source-inline">mpdistance.py</strong> <strong class="source-inline">4102.92</strong> seconds to execute when <em class="italic">using a single CPU core</em>. The value of the MPdist distance <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">38.2851</strong></span><span class="No-Break">.</span></p>
<p>You will learn all the details about MPdist in <a href="B14769_07.xhtml#_idTextAnchor160"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. For now, what you should keep in mind is that <a id="_idIndexMarker060"/>MPdist is a distance function that has some <span class="No-Break">performance issues.</span></p>
<p class="callout-heading">Experiment and stay humble</p>
<p class="callout">If I can give you just one piece of advice to remember from this book, it would be to experiment and try things. Experiment as much as possible with what you read, question it, think in new ways, try new things, and keep learning. At the same time, stay humble, and do not forget that lots of people have worked to lay the foundation for us to be here today talking about time series <span class="No-Break">and indexing.</span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Summary</h1>
<p>In this chapter, we learned the basics of time series, indexing, and distance functions. Although the theoretical knowledge included in this chapter remains valid and relevant no matter what programming language is used, alternative ways and packages to achieve the presented tasks in Python exist, as well as other programming languages. What remains unchanged is the validity of the approach – you must read a text file from disk in order to use its data, no matter the programming language – and the logical steps needed to perform a task, such as the visualization of a time series. This means that if you know an alternative way to load a text file from disk in Python, feel free to use it if it allows you to perform the next task at hand. If you are an amateur Python developer, I would suggest that you follow the book’s suggestions until you become more competent with Python. After all, the used Python packages are the most popular ones in the <span class="No-Break">Python community.</span></p>
<p>Before you continue reading this book, please make sure that you understand the knowledge presented in this chapter, as it is the foundation for the rest of the book, especially if you are new to time series <span class="No-Break">and indexing.</span></p>
<p>The next chapter is about the SAX representation, which is an integral part of the <span class="No-Break">iSAX index.</span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor051"/>Resources and useful links</h1>
<ul>
<li>The Stumpy Python <span class="No-Break">package: </span><a href="https://pypi.org/project/stumpy/"><span class="No-Break">https://pypi.org/project/stumpy/</span></a><span class="No-Break">.</span></li>
<li>The NumPy Python <span class="No-Break">package: </span><a href="https://numpy.org/"><span class="No-Break">https://numpy.org/</span></a><span class="No-Break">.</span></li>
<li>The SciPy Python package: <a href="https://pypi.org/project/scipy/">https://pypi.org/project/scipy/</a> <span class="No-Break">and </span><a href="https://scipy.org/"><span class="No-Break">https://scipy.org/</span></a><span class="No-Break">.</span></li>
<li>Anaconda <span class="No-Break">documentation: </span><a href="https://docs.anaconda.com/"><span class="No-Break">https://docs.anaconda.com/</span></a><span class="No-Break">.</span></li>
<li>Anaconda <span class="No-Break">distribution: </span><a href="https://www.anaconda.com/products/distribution"><span class="No-Break">https://www.anaconda.com/products/distribution</span></a><span class="No-Break">.</span></li>
<li>Jupyter <span class="No-Break">Notebooks: </span><a href="https://jupyter.org/"><span class="No-Break">https://jupyter.org/</span></a><span class="No-Break">.</span></li>
<li>Matplotlib: <a href="https://pypi.org/project/matplotlib/">https://pypi.org/project/matplotlib/</a> <span class="No-Break">and </span><a href="https://matplotlib.org/"><span class="No-Break">https://matplotlib.org/</span></a><span class="No-Break">.</span></li>
<li>The Z <span class="No-Break">Shell: </span><a href="https://www.zsh.org/"><span class="No-Break">https://www.zsh.org/</span></a><span class="No-Break">.</span></li>
<li>Oh My <span class="No-Break">Zsh: </span><a href="https://github.com/ohmyzsh/ohmyzsh"><span class="No-Break">https://github.com/ohmyzsh/ohmyzsh</span></a><span class="No-Break">.</span></li>
<li>The Pandas Python <span class="No-Break">package: </span><a href="https://pypi.org/project/pandas/"><span class="No-Break">https://pypi.org/project/pandas/</span></a><span class="No-Break">.</span></li>
<li>The Dewey Decimal Classification <span class="No-Break">system: </span><a href="https://en.wikipedia.org/wiki/Dewey_Decimal_Classification"><span class="No-Break">https://en.wikipedia.org/wiki/Dewey_Decimal_Classification</span></a><span class="No-Break">.</span></li>
<li>The Numba Python <span class="No-Break">package: </span><a href="https://pypi.org/project/numba/"><span class="No-Break">https://pypi.org/project/numba/</span></a><span class="No-Break">.</span></li>
<li>The Matrix Profile is defined in a research paper called <em class="italic">Matrix Profile I: All Pairs Similarity Joins for Time Series: A Unifying View That Includes Motifs, Discords and Shapelets</em>. The authors of the paper are Chin-Chia Michael Yeh, Yan Zhu, Liudmila Ulanova, Nurjahan Begum, Yifei Ding, Hoang Anh Dau, Diego Furtado Silva, Abdullah Mueen, and Eamonn <span class="No-Break">J. Keogh.</span></li>
<li>The MPdist distance is defined in a research paper called <em class="italic">Matrix Profile XII: MPdist: A novel time series distance measure to allow data mining in more challenging scenarios</em>. The authors of the paper are S. Gharghabi, S. Imani, A. Bagnall, A. Darvishzadeh, and <span class="No-Break">E. Keogh.</span></li>
<li>You can find more information about <strong class="source-inline">numpy.linalg.norm()</strong> <span class="No-Break">at </span><a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml"><span class="No-Break">https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml</span></a><span class="No-Break">.</span></li>
<li>The Homebrew macOS package <span class="No-Break">manager: </span><a href="https://brew.sh/"><span class="No-Break">https://brew.sh/</span></a><span class="No-Break">.</span></li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor052"/>Exercises</h1>
<p>Try to do the <span class="No-Break">following exercises:</span></p>
<ul>
<li>Create a new <span class="No-Break">Anaconda environment.</span></li>
<li>List the installed packages of an <span class="No-Break">Anaconda environment.</span></li>
<li>Delete an existing <span class="No-Break">Anaconda environment.</span></li>
<li>Create a new synthetic dataset with 1,000 values from -10 <span class="No-Break">to +10.</span></li>
<li>Create a new synthetic dataset with 100,000 values from 0 <span class="No-Break">to +10.</span></li>
<li>Write a Python script that reads a plain text file line <span class="No-Break">by line.</span></li>
<li>Write a Python script that reads a plain text file and prints it word by word. Why is this more difficult than printing a file line <span class="No-Break">by line?</span></li>
<li>Write a Python script that reads the same plain text file multiple times, and time that operation. The number of times the file is read as well as the file path should be given as <span class="No-Break">command-line arguments.</span></li>
<li>Modify <strong class="source-inline">synthetic_data.py</strong> to generate integer values instead of <span class="No-Break">floating-point values.</span></li>
<li>Create a time series with 500,000 elements with <strong class="source-inline">synthetic_data.py</strong>, and execute <strong class="source-inline">matrix_profile.py</strong> on the generated time series. Do not forget to compress the plain <span class="No-Break">text file.</span></li>
<li>Modify <strong class="source-inline">mpdistance.py</strong> to use <strong class="source-inline">argparse</strong> to read <span class="No-Break">its parameters.</span></li>
<li>Experiment with <strong class="source-inline">visualize.py</strong> to plot your own time series. What happens when you plot big time series? How easy it is to find what you are <span class="No-Break">looking for?</span></li>
<li>In the iSAX index in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> a binary tree? Is it a balanced <span class="No-Break">tree? Why?</span></li>
<li>Modify <strong class="source-inline">ed.py</strong> to read the time series from compressed plain <span class="No-Break">text files.</span></li>
</ul>
</div>
</div></body></html>