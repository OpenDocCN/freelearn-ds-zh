<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>An Introduction to Time Series and the Required Python Knowledge</h1>
<p>This is the first chapter of the book that you are reading. Although first chapters usually contain basic information that you might want to skip, this is not such a chapter. It teaches you the basics of time series and indexing, as well as how to set up a proper Python environment, which is going to be used during the development of the code of this book. You might need to refer to it while you are reading other chapters, which is a good thing! So, let us get started!</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>Understanding time series</li>
<li>What is an index and why do we need indexing?</li>
<li>The Python knowledge that we are going to need</li>
<li>Reading time series from disk</li>
<li>Visualizing time series</li>
<li>Working with the Matrix Profile</li>
<li>Exploring the MPdist distance</li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>In order to follow this chapter, which is the foundation of the entire book, you need to have a recent Python 3 version installed on your computer and be able to install any other required software on your own. We are not going to teach you how to install a Python 3 package, but we are going to tell you which packages you should install and the commands that we have used to do so. Similarly, we are not going to explain the process of installing new software on your machines, but we are going to tell you the command or commands we have used to install a given software on our machines.</p>
<p>The GitHub repository of the book can be found at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for <a href="B14769_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> can be found inside the <code>ch01</code> folder. You can download the entire repository on your computer using <code>git(1)</code>, or you can access the files via the GitHub user interface.</p>
<p>You can download the entire code of this book, including the code in the <code>ch01</code> folder, using <code>git(1)</code> as follows:</p>
<pre class="source-code">
git clone git@github.com:PacktPublishing/Time-Series-Indexing.git</pre>
<p>As the repository name is long and the local directory is named after the repository name, you can execute the previous command as follows to shorten the folder name:</p>
<pre class="source-code">
git clone git@github.com:PacktPublishing/Time-Series-Indexing.git tsi</pre>
<p>This is going to put the contents of the repository in a directory named <code>tsi</code>. Both ways are valid – do what is best for you.</p>
<p>The code of the book is now on your local machine. However, you are going to need to have some Python packages installed for most of the code to run – we are going to discuss the required Python packages later on in this chapter.</p>
<p class="callout-heading">Disclaimer</p>
<p class="callout">This code of the book was written and tested on Arch Linux and macOS Ventura machines. Even though the book is Unix-oriented, there exist similar commands that can be executed on a Microsoft Windows machine that should not be so difficult to find and execute. What is important is the presented code, understanding the code and the logic behind it, and being able to execute and make changes to it on your own. If this information helps you, I am mainly using Microsoft Visual Studio Code to write code on both macOS and Linux.</p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Understanding time series</h1>
<p>A time series is a set of data. Keep in mind that a time series does not have to contain time or date data in it – time and date data usually come in the form of <em class="italic">timestamps</em>. So, a time series might contain timestamps, but usually, it does not. In fact, most of the time series in this book do not contain timestamps. In practice, what we really need is ordered data – this is what makes a bunch of values a time series.</p>
<p>Strictly speaking, a time series (<em class="italic">T</em>) of size <em class="italic">n</em> is an ordered list of data points: T = { t 0, t 1, t 2, … t n−1}. Data points can be timestamped and store a single value, a set of values, or a list of values. The index of a time series might begin with 1 instead of 0 – in this case, T = { t 1, t 2, t 3, … t n}. What is truly important here is that the length of the time series is <em class="italic">n</em> in both cases. So, each element has an index value associated with it, which replaces the need for a timestamp. Time series in this book are going to use index values to distinguish their elements. The following ordered list can be considered a time series – <code>{1, -2, -3, 4, 5, 1, 2, 0.23, 4.3}</code>. It contains nine elements. The first element is <code>1</code> and the last element is <code>4.3</code>. If the index of the first element is <code>0</code>, then the index of the last element would be <code>8</code>, whereas if the index of the first element is <code>1</code>, then the index of the last element is going to be <code>9</code>. Time series can contain the same value multiple times.</p>
<p class="callout-heading">An alternative definition of time series</p>
<p class="callout">A time series is a collection of observations made sequentially in time. Many types of observations are not true time series but can be transformed into time series.</p>
<p><em class="italic">Figure 1</em><em class="italic">.1</em> shows a graphical representation of a time series with 1,000 elements – even with a small time series such as the one presented here, it is difficult to search for a specific subsequence or value. As we will discuss later on, this is why indexing is important.</p>
<div><div><img alt="Figure 1.1 – Visualizing a time series" height="730" src="img/Figure_1.1_B14769.jpg" width="968"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Visualizing a time series</p>
<p>In the <em class="italic">Visualizing time series</em> section, we will learn how to visualize a time series in Python.</p>
<p>The next subsection tells us where we can find time series data.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Time series are everywhere</h2>
<p>You might now ask where we can find time series. The answer is simple: time series are everywhere! From medical data to positional data and from software and hardware metrics to financial information and stock prices! Successfully using them allows us to find answers to questions we might have, such as which stock to sell or which hard disk is going to fail.</p>
<p>Let us look at some definitions that we need to know to understand the concepts better.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Essential definitions</h2>
<p>In this subsection, we are going to learn some core definitions related to time series:</p>
<ul>
<li>The <em class="italic">length</em> of a time series or a subsequence is the number of elements found in the time series or the subsequence.</li>
<li>A <em class="italic">subsequence</em> <em class="italic">s</em> of size <em class="italic">w</em> of a time series  <em class="italic">T</em>  is a sublist of <em class="italic">T</em>, with consecutive elements of length <em class="italic">w</em>.</li>
<li>A <em class="italic">sliding window</em> of size <em class="italic">w</em> decomposes a time series into subsequences of size <em class="italic">w</em>. The sliding window separates a time series into multiple subsequences, with a length equal to the sliding window value. Given a time series with length <em class="italic">n</em> and a sliding window of size <em class="italic">w</em>, the total number of subsequences of size <em class="italic">w</em> is equal to <em class="italic">n</em>-<em class="italic">w</em>+<em class="italic">1</em>.</li>
</ul>
<p>Let us now give you an example. Imagine having the following time series, T: {0, 1, 2, 3, 4, 5, 6}. Given a sliding window of size <em class="italic">5</em>, <em class="italic">T</em> can be separated into the following subsequences:</p>
<ul>
<li><code>{0, 1, 2, </code><code>3, 4}</code></li>
<li><code>{1, 2, 3, </code><code>4, 5}</code></li>
<li><code>{2, 3, 4, </code><code>5, 6}</code></li>
</ul>
<p>So, we have three subsequences in total, each having a length of <em class="italic">5</em>. As this is a tedious process, we are going to learn how to tell a computer to do that for us in this chapter.</p>
<p>The next subsection briefly discusses the subject of time series data mining.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Time series data mining</h2>
<p><strong class="bold">Data mining</strong> is the study of collecting, cleaning up, processing, analyzing, and understanding data. Data mining is a large subject. In fact, data mining is an area of computer science with its own subtopics and areas. The most important areas of data mining are the following:</p>
<ul>
<li><strong class="bold">Classification</strong>: This is the process of determining the class label of an element given a set of predefined class labels</li>
<li><strong class="bold">Clustering</strong>: This is the process of grouping data into sets so that group members are similar to each other, based on a given criterion, which is usually a distance function</li>
<li><strong class="bold">Outlier detection</strong>: This is the process of finding an observation that differs from other ones enough to raise suspicions that it was created by a different process</li>
</ul>
<p><em class="italic">Time series data mining</em>, as the term suggests<em class="italic">,</em> is the data mining of time series. The main difference between regular data mining and time series data mining is that in time series, data comes sorted by time. Therefore, you cannot arrange time series data on your own. Although time gives context, what is important is the actual value.</p>
<p>Apart from time, time series data can also be characterized by longitude and latitude values (<em class="italic">spatial data</em>). We are not going to deal with spatial data in this book.</p>
<p>Having time series data is good, but it might be useless if we cannot compare this data. The next subsection shows some popular techniques and algorithms for comparing time series.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Comparing time series</h2>
<p>To compare anything, we need a metric. We can compare numerical values because the values are the metrics. But how do we compare time series? This is an active research subject that does not have a definitive answer.</p>
<p>Before you continue reading the remaining chapter, take some time and try to think whether you can compare time series with a different number of elements. Is that even possible? <em class="italic">Write down your thoughts</em> before you continue reading and find out the answer.</p>
<p>Well, it turns out that you can compare time series with a different number of elements. However, not all metric functions support that functionality.</p>
<p class="callout-heading">Writing and reading</p>
<p class="callout">Reading any worthwhile book or research paper is good and allows you to learn new things and keep your mind active. However, to test your knowledge and organize your thoughts, you need to write them down! I do that all the time. After all, this is how this book was created!</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>The Euclidean distance</h2>
<p>The Euclidean distance is a way of finding out how close or how far apart a couple of time series are. Put simply, the Euclidean distance measures the shortest path between two multidimensional points. A time series or a subsequence with more than one element is a multidimensional point.</p>
<p>The Euclidean distance <strong class="bold">prioritizes time</strong> – it compares data points that appear at the same time and ignores anything else. Therefore, if two time series only match at different times, they are considered dissimilar. Finally, the Euclidean distance works with data of many dimensions – in this book, we use data of one dimension only. Do not confuse <strong class="bold">multidimensional points</strong> with <strong class="bold">multidimensional data</strong>. Multidimensional data contains multidimensional points. The time series of this book contains data with one dimension only (single values). However, we can consider a time series or subsequence as a <em class="italic">multi-dimensional point</em>.</p>
<p>The formula to calculate the Euclidean distance of two multidimensional points can be described as follows. Given a point p = ( p 1, p 2, … , p n) and a point q = ( q 1, q 2, … , q n), the Euclidean distance is the square root of the sum of all (p i − q i) 2 values:</p>
<p>Let us now present some examples by calculating the Euclidean distance of two subsequence pairs. The first pair is <code>p =</code> <code>{1, 2, 3}</code> and <code>q =</code> <code>{0, 2, 2}</code>. So, first, we find all (p i − q i) 2 values:</p>
<ul>
<li><em class="italic"><a id="_idTextAnchor024"/></em><em class="italic">(</em><em class="italic">1</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">0</em><em class="italic">)</em><em class="italic"> </em>2<em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">1</em></li>
<li><em class="italic"><a id="_idTextAnchor025"/></em><em class="italic">(</em><em class="italic">2</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">2</em><em class="italic">)</em><em class="italic"> </em>2<em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">0</em></li>
<li><em class="italic"><a id="_idTextAnchor026"/></em><em class="italic">(</em><em class="italic">3</em><em class="italic"> </em><em class="italic">−</em><em class="italic"> </em><em class="italic">2</em><em class="italic">)</em><em class="italic"> </em>2<em class="italic"> </em><em class="italic">=</em><em class="italic"> </em><em class="italic">1</em></li>
</ul>
<p>Then, we add the results: 1 + 0 + 1 = 2.</p>
<p>Last, we find the square root of the result, which is approximately equal to 1.414213.</p>
<p>Now, imagine having the following two time series or subsequences – <code>p =</code> <code>{1, 2, -1, -3}</code> and <code>q =</code> <code>{-3, 1, 2, -1}</code>. Although the time series have the same elements, these elements are in a different order. Their Euclidean distance can be calculated as before. First, we find all (p i − q i) 2 values:</p>
<ul>
<li><a id="_idTextAnchor027"/>[1 − (− 3)] 2 = 4 2 = 16</li>
<li><a id="_idTextAnchor028"/>(2 − 1) 2 = 1 2 = 1</li>
<li><a id="_idTextAnchor029"/>( − 1 − 2) 2 = ( − 3) 2 = 9</li>
<li><a id="_idTextAnchor030"/>[( − 3) − (− 1)] 2 = ( − 2) 2 = 4</li>
</ul>
<p>Therefore, the Euclidean distance is equal to the square root of (16+1+9+4) = 30, which approximately is equal to 5.4472.</p>
<p>A major drawback of the Euclidean distance is that it requires the two time series to be of the same length. Although there exist techniques to overcome that limitation, this is still an issue. One of the techniques involves using extrapolation to make the length of the smaller time series equal to the length of the bigger one.</p>
<p>Going forward, we are not going to calculate Euclidean distances manually, as <em class="italic">NumPy</em> offers a better way of doing so – this is illustrated in <code>ed.py</code>:</p>
<pre class="source-code">
#!/usr/bin/env python3 
import numpy as np
import sys
def euclidean(a, b):
    return np.linalg.norm(a-b)
def main():
    ta = np.array([1, 2, 3])
    tb = np.array([0, 2, 2])
    if len(ta) != len(tb):
        print("Time series should have the same length!")
        print(len(ta), len(tb))
        sys.exit()
    ed = euclidean(ta, tb)
    print("Euclidean distance:", ed)
if __name__ == '__main__':
    main()</pre>
<p>The <code>euclidean()</code> function takes two NumPy arrays as input and returns their Euclidean distance as output, using <code>np.linalg.norm()</code>. This works because the Euclidean distance is the <code>l2</code> norm and the default value of the <code>ord</code> parameter in <code>numpy.linalg.norm()</code> is <code>2</code>, which is the reason for not specifically defining it. You do not need to remember that; just use the <code>euclidean()</code> function when needed.</p>
<p>The two<a id="_idIndexMarker000"/> time series are hardcoded in the script. Running <code>ed.py</code> generates<a id="_idIndexMarker001"/> the following output:</p>
<pre class="source-code">
$ ./ed.py
Euclidean distance: 1.4142135623730951</pre>
<h2 id="_idParaDest-24">The Chebyshe<a id="_idTextAnchor031"/>v distance</h2>
<p>The Chebyshev <a id="_idIndexMarker002"/>distance<a id="_idIndexMarker003"/> has a totally different logic than the Euclidean distance. This does not make it superior or inferior to the Euclidean distance, just different. If you do not know what to use, go with the Euclidean distance.</p>
<p>So, the Chebyshev distance between two multidimensional points is equal to the greatest distance of<a id="_idTextAnchor032"/> all |p i  − q i| values. The || symbol is the <em class="italic">absolute value</em> of a quantity. Put simply, the <em class="italic">absolute value</em> of a quantity is equal to the value without the plus or minus sign.</p>
<p>Let us now present some examples by calculating the Chebyshev distance of two subsequence pairs. The first pair is <code>{1, 2, 3}</code> and <code>{0, 2, 2}</code>. Now, let us find the distances between the pairs:</p>
<ul>
<li><em class="italic">|1 – 0| = 1</em></li>
<li><em class="italic">|2 – 2| = 0</em></li>
<li><em class="italic">|3 – 2| = 1</em></li>
</ul>
<p>So, the maximum of 1, 0, and 1 is equal to 1, which is the Chebyshev distance.</p>
<p>The second pair is <code>{1, 2, -1, -3}</code> and <code>{-3, 1, 2, -1}</code>. As before, we find the distances between the pairs of the points at the same position (same index):</p>
<ul>
<li><em class="italic">|1 – (–3)| = 4</em></li>
<li><em class="italic">|2 – 1| = 1</em></li>
<li><em class="italic">|(–1) – 2| = 3</em></li>
<li><em class="italic">|(–3) – (–1)| = 2</em></li>
</ul>
<p>So, the maximum of 4, 1, 3, and 2 is equal to 4, which is the Chebyshev distance of the aforementioned pair.</p>
<p>Later in this chapter, we are going to learn about a more sophisticated distance function, which is called <em class="italic">MPdist</em>.</p>
<p>Now that we know how to compare time series and subsequences, it is time to discuss indexes <a id="_idIndexMarker004"/>and<a id="_idIndexMarker005"/> indexing. Keep in mind that we cannot create an index without being able to compare its data, which includes time series data.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor033"/>What is an index and why do we need indexing?</h1>
<p>Can you imagine <a id="_idIndexMarker006"/>searching for a<a id="_idIndexMarker007"/> surname in an unsorted list of names? Can you imagine looking for a book in a library that does not sort its books based on book subject (the Dewey system) and then book title and author surname? I cannot! Both examples showcase a naïve but efficient indexing scheme. The more complex the data, the more sophisticated the index should be in order to perform quick searches and maybe updates on the data.</p>
<p><em class="italic">Figure 1</em><em class="italic">.2</em> shows the visualization of a <a id="_idIndexMarker008"/>really small <strong class="bold">iSAX</strong> index – in reality, as a time series can be really huge, iSAX indexes tend to be much bigger and more complex.</p>
<div><div><img alt="Figure 1.2 – A small iSAX index" height="612" src="img/Figure_1.2_B14769.jpg" width="1171"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – A small iSAX index</p>
<p>Do not try to understand the iSAX index or the titles of the nodes at this point. Everything is going to become clearer in <a href="B14769_02_MA.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a> and <a href="B14769_03.xhtml#_idTextAnchor081"><em class="italic">Chapter 3</em></a>. For now, keep in mind that the titles of the nodes are <em class="italic">SAX words</em> and that there exist two kinds of nodes on an iSAX index – <em class="italic">internal nodes</em> and <em class="italic">terminal nodes</em> (leaf nodes). Everything about the iSAX index <a id="_idIndexMarker009"/>and its<a id="_idIndexMarker010"/> connection with SAX words will become clear in <a href="B14769_03.xhtml#_idTextAnchor081"><em class="italic">Chapter 3</em></a>.</p>
<p>In the next section, we will begin working with Python and set up our environment.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor034"/>The Python knowledge that we are going to need</h1>
<p>All the <a id="_idIndexMarker011"/>presented<a id="_idIndexMarker012"/> code in this book is written in Python. Therefore, in this section, we are going to present the required Python knowledge for you to follow this book better. However, do not expect to learn the basics of Python here – more appropriate books exist for that purpose.</p>
<p class="callout-heading">What about other programming languages?</p>
<p class="callout">Once you learn and understand the presented theory, the Python code of this book can be easily translated into any other modern programming language, such as Swift, Java, C, C++, Ruby, Kotlin, Go, Rust, or JavaScript.</p>
<p>You might have compatibility issues with the used Python packages if you keep updating them for no particular reason. As a rule of thumb, I would suggest that throughout this book, you should use the same package versions, provided that they work well with each other. There exist two main ways to achieve that. You can stop upgrading your Python installation once you find the versions that work, or you can use a Python package manager such as Anaconda or <code>pyenv</code>. In this book, we are going to use Anaconda.</p>
<p>It does not matter what you use, as long as you know how to operate your tools and have a stable and reliable Python environment to work with.</p>
<p>I hope we all agree that the most important property of any code is correctness. However, after <a id="_idIndexMarker013"/>we have working code, we might need to optimize it, but we <a id="_idIndexMarker014"/>cannot optimize code if we do not know whether it runs slowly or not. So, the next section shows you how to calculate the time it takes Python code to execute.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor035"/>Timing Python code</h2>
<p>There are times when <a id="_idIndexMarker015"/>we need to know how slow or how fast our code is being executed because some operations might take hours or even days. This section presents a simple technique to calculate the time it takes a block of code to run.</p>
<p>The <code>timing.py</code> script shows a technique to time Python code – this might come in really handy when you want to learn how much time it takes for a process to finish. The source code of <code>timing.py</code> is the following:</p>
<pre class="source-code">
#!/usr/bin/env python3
import time
start_time = time.time()
for i in range(5):
    time.sleep(1)
print("--- %.5f seconds ---" % (time.time() - start_time))</pre>
<p>We use <code>time.time()</code> to initiate the beginning of the timing and the same statement to declare the end of the timing. The difference between these two statements is the desired result. You can also keep that difference in a separate variable.</p>
<p>The program executes <code>time.sleep(1)</code> five times, which means the total time should be pretty close<a id="_idIndexMarker016"/> to 5 seconds. Running <code>timing.py</code> generates the following kind of output:</p>
<pre class="source-code">
$ ./timing.py
--- 5.01916 seconds ---</pre>
<p class="callout-heading">About the Python scripts</p>
<p class="callout">In this book, we<a id="_idIndexMarker017"/> are mostly going to show you the Python scripts in full without omitting any statements. Although this adds some extra lines, it helps you understand the functionality of the Python scripts by looking at their <code>import</code> statements before reading the actual Python code.</p>
<p>The next subsection is about the Anaconda software, which is used to create Python environments.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor036"/>An introduction to Anaconda</h2>
<p>Anaconda<a id="_idIndexMarker018"/> is a product <a id="_idIndexMarker019"/>for package, dependency, and environment management. Although Anaconda is a commercial product, there exists an Individual Edition for solo practitioners, students, and researchers. What Anaconda does is create a controlled environment where you can define the version of Python as well as the versions of the packages you want to use. Additionally, you can create multiple environments and switch between them.</p>
<p>You do not have to use Anaconda if you do not want to – however, if you are using Python 3 and you do not want to become overwhelmed by the details of Python 3 package versions, incompatibilities, and dependencies, then you should give Anaconda a try. The reason for needing package and environment management software is because some Python packages are very picky about the Python version used. Put simply, Anaconda makes sure that your Python 3 environment is not going to change and gives you the <a id="_idIndexMarker020"/>capability<a id="_idIndexMarker021"/> to transfer your Python 3 environments to multiple machines. The Anaconda command line tool is called <code>conda</code>.</p>
<h3>Installing Anaconda</h3>
<p>Anaconda is<a id="_idIndexMarker022"/> a huge piece of software, as it contains lots of packages and utilities. There exist multiple ways to install Anaconda, which mainly depend on your development environment.</p>
<p>On a macOS Ventura machine, we can install Anaconda using Homebrew as follows:</p>
<pre class="source-code">
$ brew install anaconda</pre>
<p>On an Arch Linux machine, Anaconda can be installed as follows:</p>
<pre class="source-code">
$ pacman -S anaconda</pre>
<p>We will not discuss the Anaconda installation in any more detail. The installation process is straightforward and contains lots of information. The single most important task to do is to include the Anaconda utilities on your <code>PATH</code> environment variable, in order for them to be accessible from everywhere on your UNIX shell. This also depends on the UNIX shell you are using – I use <code>zsh</code> with the Oh My Zsh extensions on both my Linux and macOS machines, but your environment might most likely vary.</p>
<p>If you choose to use Anaconda to work with this book, please make sure that you can access the <code>conda</code> binary and that you can enable and disable Anaconda on your machine at will – you might not need to use Anaconda all the time.</p>
<p>On my macOS Ventura machine, I can disable Anaconda as follows:</p>
<pre class="source-code">
$ conda deactivate</pre>
<p>I can also enable Anaconda as follows:</p>
<pre class="source-code">
$ source /opt/homebrew/anaconda3/bin/activate base</pre>
<p>You should replace <code>base</code> with the desired Anaconda environment.</p>
<p>The previous command depends on the path where Anaconda was installed. Therefore, on my Arch Linux machine, I should execute the following command instead:</p>
<pre class="source-code">
$ source /opt/anaconda/bin/activate base</pre>
<p>You should modify the previous command to fit your Anaconda installation.</p>
<p>When a new<a id="_idIndexMarker023"/> Anaconda version is available, you can update to the latest version by executing the next command:</p>
<pre class="source-code">
$ conda update -n base -c defaults conda</pre>
<h3>Creating a new Anaconda environment</h3>
<p>The single most important <a id="_idIndexMarker024"/>thing to decide when creating a new Anaconda environment is the selection of the Python 3 version. In order to create a new Anaconda environment named <code>TSI</code> that uses Python 3.8.5, you should run the following command:</p>
<pre class="source-code">
$ conda create  ––name TSI python=3.8.5</pre>
<p>In order to activate this environment, run <code>conda activate TSI</code>. The <code>python3 --version</code> command shows the Python version included in a given Anaconda environment.</p>
<p>You can list all existing Anaconda environments using the <code>conda info --envs</code> command (the <code>*</code> character shows the active one):</p>
<pre class="source-code">
$ conda info --envs
# conda environments:
#
TSI                      /home/mtsouk/.conda/envs/TSI
base                    /opt/anaconda</pre>
<h3>Changing to a different environment</h3>
<p>This subsection<a id="_idIndexMarker025"/> presents the <code>conda</code> command used to change from one environment to another. Changing to a different environment is as simple as activating a different environment using <code>conda </code><code>activate environment_name</code>.</p>
<h3>Installing a Python package</h3>
<p>Although<a id="_idIndexMarker026"/> you can still use <code>pip3</code> to install Python <a id="_idIndexMarker027"/>packages, the best way to install a Python package in an Anaconda environment is with the <code>conda install</code> command. Keep in mind that the <code>conda install</code> command cannot install all packages – in this case, use <code>pip3</code> instead.</p>
<h3>Listing all installed packages</h3>
<p>The <code>conda list</code> command <a id="_idIndexMarker028"/>gives you a full list of installed Python packages under a given Anaconda environment. As the list is pretty long, we will show you just a part of it:</p>
<pre class="source-code">
$ conda list
# packages in environment at /home/mtsouk/.conda/envs/TSI:
#
# Name                    Version                   Build
python                    3.8.5                h7579374_1
readline                  8.2                  h5eee18b_0
numpy                     1.23.5                   pypi_0
pandas                    1.5.2                    pypi_0</pre>
<h3>Deleting an existing environment</h3>
<p>You can delete<a id="_idIndexMarker029"/> an existing Anaconda environment <em class="italic">that is not active</em> using the <code>conda env remove --name ENVIRONMENT</code> command. Its execution is illustrated in the following output when deleting an environment named <code>mtsouk</code>:</p>
<pre class="source-code">
$ conda env remove --name mtsouk
Remove all packages in environment /home/mtsouk/.conda/envs/mtsouk:</pre>
<p>This discussion of Python environments, package versions, and package incompatibilities culminates here. From now on, let us assume that we have a stable Python environment where we can use existing Python packages, develop new Python packages, and run Python scripts without any issues. The next subsection lists the Python packages that we need to<a id="_idIndexMarker030"/> install.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor037"/>The required Python packages</h2>
<p>Here is a list of the<a id="_idIndexMarker031"/> required Python packages along with an explanation of the use of each one of them:</p>
<ul>
<li><code>NumPy</code>: This is the standard Python package for array computing.</li>
<li><code>Pandas</code>: This package offers data structures for data analysis, time series, and statistics, including functions to read data files from disk.</li>
<li><code>SciPy</code>: This package offers fundamental functions for scientific computing in Python.</li>
<li><code>Matplotlib</code>: This is the most popular Python package for scientific plotting.</li>
<li><code>Stumpy</code>: This is a powerful package for time series analysis and time series data mining. You do not have to install it right away, as it is not needed for the development of the iSAX index.</li>
</ul>
<p>These are the basic packages that you need to install in a fresh Python environment. Python will automatically install any package dependencies.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor038"/>Setting up our environment</h2>
<p>In this subsection, we <a id="_idIndexMarker032"/>are going to set up our Anaconda environment. As explained earlier, this is not required to follow this book, but it will save you from Python package incompatibilities that might come up when upgrading Python and Python packages. We will execute the following commands in the <code>TSI</code> Anaconda environment, and then we are done:</p>
<pre class="source-code">
(TSI) $ conda install numpy
(TSI) $ conda install pandas
(TSI) $ conda install scipy
(TSI) $ conda install matplotlib
(TSI) $ conda install stumpy</pre>
<h2 id="_idParaDest-31"><a id="_idTextAnchor039"/>Printing package versions</h2>
<p>In this subsection, we <a id="_idIndexMarker033"/>present a Python script that just loads the desired packages and prints their versions on screen.</p>
<p>The code of <code>load_packages.py</code> is the following:</p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import argparse
import stumpy
import numpy as np
import scipy
import matplotlib
def main():
     print("scipy version:", scipy.__version__)
     print("numpy version:", np.__version__) 
print("stumpy version:", stumpy.__version__) 
print("matplotlib version:", matplotlib.__version__) 
print("argparse version:", argparse.__version__) 
print("pandas version:", pd.__version__)
if __name__ == '__main__':
     main()</pre>
<p>Running <code>load_packages.py</code> on one of my UNIX machines prints the following information:</p>
<pre class="source-code">
$ chmod 755 ./load_packages.py
$ ./load_packages.py
scipy version: 1.9.2
numpy version: 1.23.4
stumpy version: 1.11.1
matplotlib version: 3.6.2
argparse version: 1.1
pandas version: 1.5.0</pre>
<p>The first command is needed to make the Python script executable and is required for all Python scripts presented in this book, provided that they begin with the <code>#!/usr/bin/env python3</code> statement. If they do not begin with that statement, you can execute them using <code>python3 &lt;script_name&gt;</code> without the need to change their permissions. You can learn more about the <code>chmod(1)</code> command by running <code>man chmod</code>. From now on, we will assume that you know this information and will not present any <a id="_idIndexMarker034"/>more <code>chmod</code> commands and instructions. Your output might be a little different, but that is OK, as packages get updated.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor040"/>Creating sample data</h2>
<p>The official name <a id="_idIndexMarker035"/>of sample data created by a program is <strong class="bold">synthetic data</strong>. This subsection<a id="_idIndexMarker036"/> is going to present a Python script that creates synthetic data based on given parameters. The logic of the program is based on randomly generated numbers – as most of you might know, randomly generated numbers are not that random. This makes them good for testing the performance of a program but not the actual use of it. However, for the purposes of this book, synthetic data generated with the help of random numbers is fine!</p>
<p>The code of the <code>synthetic_data.py</code> Python script is as follows:</p>
<pre class="source-code">
#!/usr/bin/env python3
import random
import sys
precision = 5
if len(sys.argv) != 4:
    print("N MIN MAX")
    sys.exit()
# Number of values
N = int(sys.argv[1])
# Minimum value
MIN = int(sys.argv[2])
# Maximum value
MAX = int(sys.argv[3])
x = random.uniform(MIN, MAX)
# Random float number
for i in range(N):
    print(round(random.uniform(MIN, MAX), precision))</pre>
<p>The script<a id="_idIndexMarker037"/> accepts three parameters, which are the <em class="italic">number of floating-point values</em> to create the minimum value and the maximum value. Running the script generates the following kind of output:</p>
<pre class="source-code">
$ ./synthetic_data.py 5 1 3
1.18243
2.81486
1.74816
1.42797
2.21639</pre>
<p>As floating-point values can have any precision you want, the <code>precision</code> variable holds the number of digits after the decimal point that will be printed.</p>
<p>Creating your own time series is not the only way to get data. Publicly available time series data also exists. Let us check this out next.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor041"/>Publicly available time series data</h2>
<p>Websites exist that offer <a id="_idIndexMarker038"/>samples of time series data, allowing everyone to process real-world time series data. Another important aspect of publicly available time series data is that people can compare the performance of their techniques, using the same datasets, with others. This is a huge issue in academia, where people have to prove that their techniques and algorithms are faster or more efficient in a variety of aspects compared to others.</p>
<p>A very popular set of publicly available time series data files can be found at <a href="https://www.cs.ucr.edu/~eamonn/time_series_data_2018/">https://www.cs.ucr.edu/~eamonn/time_series_data_2018/</a> (the UCR Time Series Classification Archive).</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor042"/>How time series are processed</h2>
<p>Time series <a id="_idIndexMarker039"/>processing in Python usually follows these steps:</p>
<ol>
<li><strong class="bold">Importing to Python</strong>: In this step, we import the time series into Python. There exist multiple ways to do that, including reading from a local file, a database server, or an Internet location. In this book, we include all used time series in the GitHub repository as plain text files, which are compressed to save disk space.</li>
<li><strong class="bold">Converting it into a time series</strong>: In this step, we convert the data we read in the previous step into a valid time series format. This mainly depends on the Python package used to store the time series data.</li>
<li><strong class="bold">Dealing with missing values</strong>: In this step, we look for missing values and ways to deal with them. We are not going to deal with missing values in this book. All presented time series are complete.</li>
<li><strong class="bold">Processing time series</strong>: This last step involves processing a time series in order to perform the desired task or tasks.</li>
</ol>
<h1 id="_idParaDest-35"><a id="_idTextAnchor043"/>Reading time series from disk</h1>
<p>After storing<a id="_idIndexMarker040"/> a time series in a file, we need to write the necessary Python code to read it and put it in a Python variable of some type. This section will teach you exactly that. The <code>read_ts.py</code> script contains the following code:</p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import numpy as np
import sys
def main():
        filename = sys.argv[1]
        ts1Temp = pd.read_csv(filename, header = None)
        # Convert to NParray
        ta = ts1Temp.to_numpy()
        ta = ta.reshape(len(ta))
        print("Length:", len(ta))
if __name__ == '__main__':
        main()</pre>
<p>After reading the time series, <code>read_ts.py</code> prints the number of elements in the time series:</p>
<pre class="source-code">
$ ./read_ts.py ts2
Length: 50</pre>
<p>The <code>pd.read_csv()</code> function reads a plain text file that uses the CSV format – in our case, each value is on its own line, so there should be no issues with separating values that reside on the same line. The <code>pd.read_csv()</code> function is able to detect issues in the input file. The return value of <code>pd.read_csv()</code> is a <em class="italic">DataFrame</em> or <em class="italic">TextParser</em>. In our case, it is a <em class="italic">DataFrame</em>.</p>
<p>Putting <code>.astype(np.float64)</code> at the end of the <code>pd.read_csv()</code> statement is going to ensure that all values are read as floating-point values, even when the entire time series contains integer values only. Additionally, <code>header = None</code> ensures that the input does not contain a header line with text or data different from the actual data.</p>
<p>The <code>ts1Temp.to_numpy()</code> call converts a <em class="italic">DataFrame</em> into a NumPy array. So, the return value of <code>ts1Temp.to_numpy()</code> is a NumPy array. This is needed because we will work with NumPy arrays.</p>
<p>The <code>ta.reshape(len(ta))</code> call gives a new shape to an existing NumPy array without changing the data. This is needed for processing the time series data using the correct shape.</p>
<p>As files with time series can be pretty big, it is a good idea to compress them and use them in compressed format. Fortunately, Pandas can read compressed files with the help of a parameter. This is illustrated in the <code>read_ts_gz.py</code> script. The statement that does the <a id="_idIndexMarker041"/>job is <code>pd.read_csv(filename, compression='gzip', header = None).astype(np.float64)</code>. Here, you also see <code>.astype(np.float64)</code> in action.</p>
<p class="callout-heading">How to store time series</p>
<p class="callout">This book uses plain text files to store time series. In these files, each value is in a separate line. More ways exist to store a time series, including the CSV format and the JSON format.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor044"/>Is all data numeric?</h2>
<p>Not all data is<a id="_idIndexMarker042"/> numeric, but in time series, almost all data is numeric. The presented script reads a plain text file and makes sure that all data is numeric – note that the <code>isNumeric.py</code> script does not currently support compressed files, as it uses the <code>open()</code> call to read the input file and it expects a single value per line.</p>
<p>The code <a id="_idIndexMarker043"/>of <code>isNumeric.py</code> is as follows:</p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    TS = sys.argv[1]
    file = <strong class="bold">open</strong>(TS, 'r')
    Lines = file.readlines()
    count = 0
    for line in Lines:
        # Strips the newline character
        t = line.strip()
        try:
            _ = <strong class="bold">float(t)</strong>
        except:
            count = count + 1
    print("Number of errors:", count)
if __name__ == '__main__':
    main()</pre>
<p>The <code>try</code> and <code>except</code> block is where we try to convert the current string value into a floating-point value using <code>float()</code>. If this fails, we know that we are not dealing with a valid numerical value.</p>
<p>Running <code>isNumeric.py</code> produces the following kind of output:</p>
<pre class="source-code">
$ cat ts.txt
5.2
-12.4
-    # Error
17.9
a a     # Error
2 3 4    # Error
4.2
$ ./isNumeric.py ts.txt
Number of errors: 3</pre>
<p>As we<a id="_idIndexMarker044"/> have three erroneous lines, the result is correct.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor045"/>Do all lines have the same amount of data?</h2>
<p>In this subsection, we <a id="_idIndexMarker045"/>present a script that counts the number of words in each line, checks that each word is a valid float value, and checks that each line has the same number of values. If not, it states the expected and found number of fields. Additionally, it considers the first line read as the correct one, so all the following lines should have the same amount of data fields. Values are separated by whitespace characters.</p>
<p>The code of <code>floats_per_line.py</code> is the following:</p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    TS = sys.argv[1]
    file = open(TS, 'r')
    Lines = file.readlines()
    first = True
    wordsPerLine = 0
    for line in Lines:
        t = line.strip()
        words = t.split()
        for word in words:
            try:
                _ = float(word)
            except:
                print("Error:", word)
        if first:
            wordsPerLine = len(words)
            first = False
        elif wordsPerLine != len(words):
            print("Expected", wordsPerLine, "found", len(words))
            continue
if __name__ == '__main__':
    main()</pre>
<p>If <code>String.split()</code> is executed without any arguments, it splits the string using all the whitespace characters as delimiters, which is what we do here to separate the fields of each input line. If your data is in a different format, you might need to modify the <code>String.split()</code> statement to match your needs.</p>
<p>Running <code>floats_per_line.py</code> produces<a id="_idIndexMarker046"/> the following kind of output:</p>
<pre class="source-code">
$ ./floats_per_line.py ts.txt
Error: -
Error: a
Error: b
Expected 1 found 2
Expected 1 found 3</pre>
<p>The next subsection shows how to process time series based on the sliding window size.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor046"/>Creating subsequences</h2>
<p>Although we <a id="_idIndexMarker047"/>read a time series as an entity from a plain text file, we process it as a large list of subsequences. In this subsection, you are going to learn how to process a time series as a list of subsequences, based on a given sliding window size.</p>
<p>The name of the Python script is <code>subsequences.py</code>. We are going to present it in two parts. Among other things, the first part contains the Python structure used to keep the subsequences:</p>
<pre class="source-code">
#!/usr/bin/env python3
import argparse
import stumpy
import numpy as np
import pandas as pd
import sys
class TS:
    def __init__(self, ts, index):
        self.ts = ts
        self.index = index</pre>
<p>The <code>TS</code> class has two members, one to hold the actual data (the <code>ts</code> variable) and the other to keep the index (index variable) number of the subsequence. The chapters that follow are going to enrich the <code>TS</code> class to fit our growing needs.</p>
<p>The rest of the <a id="_idIndexMarker048"/>script is the following:</p>
<pre class="source-code">
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", dest = "window", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    file = args.TS
    ts = pd.read_csv(file, names=['values'], compression='gzip', header = None)
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    # Split time series into subsequences
    for i in range(length - windowSize + 1):
        # Get the subsequence
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        ts_node = TS(ts, i)
if __name__ == '__main__':
    main()</pre>
<p>The <code>argparse</code> package helps us put the command-line arguments in order. In this case, we expect two parameters: first, the sliding window size (<code>-w</code>), and second, the filename that holds the time series. The <code>for</code> loop is used to split the time series into subsequences and generate multiple <code>TS</code> class members.</p>
<p>The previous code is not something difficult to read or understand or make changes to. Expect to see <a id="_idIndexMarker049"/>this sort of code in most of the Python scripts in this book!</p>
<p>In its current form, <code>subsequences.py</code> generates no output. You will only get error messages if something is wrong with the provided filename or its data.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor047"/>Visualizing time series</h1>
<p>Most of the time, having <a id="_idIndexMarker050"/>a high-level overview of your data is an excellent way to get to know your data. The best way to get an overview of a time series is by visualizing it.</p>
<p>There are multiple ways to visualize a time series, including tools such as R or Matlab, or using a large amount of existing JavaScript packages. In this section, we are going to use a Python package called Matplotlib for visualizing the data. Additionally, we will save the output to a PNG file. A viable alternative to this is to use a Jupyter notebook – Jupyter comes with Anaconda – and display the graphical output on your favorite web browser.</p>
<p>The <code>visualize.py</code> script reads a plain text file with values – a time series – and creates a plot. The <a id="_idIndexMarker051"/>Python code of <code>visualize.py</code> is as follows:</p>
<pre class="source-code">
#!/usr/bin/env python3
import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import math
def main():
    if len(sys.argv) != 2:
        print("TS")
        sys.exit()
    F = sys.argv[1]
    # Read Sequence as Pandas
    ts = pd.read_csv(F, compression='gzip', header = None)
    # Convert to NParray
    ta = ts.to_numpy()
    ta = ta.reshape(len(ta))
    <strong class="bold">plt.plot</strong>(ta, label=F, linestyle='-', markevery=100, marker='o')
    plt.xlabel('Time Series', fontsize=14)
    plt.ylabel('Values', fontsize=14)
    plt.grid()
    <strong class="bold">plt.savefig</strong>("CH01_03.png", dpi=300, format='png', bbox_inches='tight')
if __name__ == '__main__':
    main()</pre>
<p>You must be familiar with most of the presented code, as you already saw some of it earlier in this chapter. The <code>plt.plot()</code> statement plots the data, whereas the <code>plt.savefig()</code> function saves the output in the file instead of displaying it on screen.</p>
<p>The output from <a id="_idIndexMarker052"/>the <code>./visualize.py ts1.gz</code> command can be seen in <em class="italic">Figure 1</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 1.3 – Visualizing a time series" height="807" src="img/Figure_1.3_B14769.jpg" width="1047"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Visualizing a time series</p>
<p>Now that we understand how to work with time series and subsequences, it is time to present an advanced technique called the <strong class="bold">Matrix Profile</strong>, which shows the tasks that we might need to<a id="_idIndexMarker053"/> compute when working with time series and how time-consuming these tasks might be.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor048"/>Working with the Matrix Profile</h1>
<p>In this section, as <a id="_idIndexMarker054"/>well as the next one, we will work with the <code>stumpy</code> Python package. This package is not related to iSAX but offers lots of advanced functionality related to time series. With the help of <code>stumpy</code>, we can calculate the <em class="italic">Matrix Profile</em>.</p>
<p>The Matrix Profile is two things:</p>
<ul>
<li>A vector of distances that shows the distance of each subsequence in a time series to its nearest neighbor</li>
<li>A vector of indexes that shows the index of the nearest neighbor of each subsequence in a time series</li>
</ul>
<p>The Matrix Profile can be used in many time series mining tasks. The main reason for presenting it is to understand that working with time series can be slow, so we need structures and techniques to improve the performance of time series-related tasks.</p>
<p>To get a better idea of the use of the Matrix Profile and the time it takes <code>stumpy</code> to calculate the Matrix Profile, here is the Python code of <code>matrix_profile.py</code>:</p>
<pre class="source-code">
#!/usr/bin/env python3
import pandas as pd
import argparse
import time
import stumpy
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-w", "--window", dest = "window", default = "16", help="Sliding Window", type=int)
    parser.add_argument("TS")
    args = parser.parse_args()
    windowSize = args.window
    inputTS = args.TS
    print("TS:", inputTS, "Sliding Window size:", windowSize)
    start_time = time.time()
    ts = pd.read_csv(inputTS, names=['values'], compression='gzip')
    # Convert to NParray
    ts_numpy = ts.to_numpy()
    ta = ts_numpy.reshape(len(ts_numpy))
    realMP = stumpy.stump(ta, windowSize)
    print("--- %.5f seconds ---" % (time.time() - start_time))
if __name__ == '__main__':
    main()</pre>
<p>The <code>stumpy.stump()</code> function <a id="_idIndexMarker055"/>calculates the Matrix Profile of a given time series.</p>
<p>We are going to execute <code>matrix_profile.py</code> two times. The first time using a time series with 100,000 elements and the second time using a time series with 300,000 elements. As with almost all the Python scripts in this book that read a time series, <code>matrix_profile.py</code> expects to read compressed plain text files.</p>
<p class="callout-heading">The taskset(1) command</p>
<p class="callout">The <code>taskset(1)</code> command is used to assign the desired number of cores to a given process and is currently available on Linux machines. The reason for using it is to limit the number of available cores when executing <code>matrix_profile.py</code> and <code>mpdistance.py</code>, which, by default, use all available cores due to the use of the Numba Python package. As a rule of thumb, when testing the performance of an algorithm or comparing one to another, it is better to use a single core. There is no similar utility on macOS.</p>
<p>Running <code>matrix_profile.py</code> with <a id="_idIndexMarker056"/>the smaller time series produces the following output:</p>
<pre class="source-code">
$ taskset --cpu-list 3 ./matrix_profile.py 100k.txt.gz
TS: 100k.txt.gz Sliding Window size: 16
--- 120.44 seconds ---</pre>
<p>So, it took <code>stumpy.stump()</code> around <code>120.44 seconds</code> to process a time series with 100,000 elements.</p>
<p>Running <code>matrix_profile.py</code> with the bigger time series produces the following output:</p>
<pre class="source-code">
$ taskset --cpu-list 0 ./matrix_profile.py 300k.gz -w 1024
TS: 300k.gz Sliding Window size: 1024
--- 922.30060 seconds ---</pre>
<p>Here, it took <code>stumpy.stump()</code> around <code>922 seconds</code> to process a time series with 300,000 elements on a single CPU core. Now, imagine doing the same with a time series that has more than 1,000,000 elements!</p>
<p>You are going to learn all about the Matrix Profile and understand why it is so slow in <a href="B14769_07.xhtml#_idTextAnchor160"><em class="italic">Chapter 7</em></a>.</p>
<p>The next section <a id="_idIndexMarker057"/>discusses a distance function named <strong class="bold">MPdist</strong> that internally uses the Matrix Profile for its computation.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor049"/>Exploring the MPdist distance</h1>
<p>MPdist offers a way <a id="_idIndexMarker058"/>to calculate the distance between two time series. Strictly speaking, the <em class="italic">MPdist</em> distance is a distance measure that is based on the Matrix Profile. It is much slower to compute than the Euclidean distance, but it does not require the time series to have the same size.</p>
<p>As you might expect, it must offer many advantages when compared to the Euclidean distance, as well as other existing distance metrics. The main advantages of MPdist, according to the people that created it, are the following:</p>
<ul>
<li>It is more flexible regarding the way it compares data than most existing distance functions.</li>
<li>It considers similarities of data that may not take place at the same time, where time means at the same index.</li>
<li>MPdist is considered more robust in specific analytics scenarios due to the way it is computed. More specifically, MPdist is more robust to spikes and missing values.</li>
</ul>
<p>As MPdist is based on the Matrix Profile, calculating the MPdist distance can be extremely slow, especially when working with large time series.</p>
<p>First, let us have a look at the Python code of <code>mpdistance.py</code>:</p>
<pre class="source-code">
#!/usr/bin/env python3
import stumpy
import stumpy.mpdist
import numpy as np
import time
import sys
import pandas as pd
if len(sys.argv) != 4:
    print("TS1 + TS2 + Window size")
    sys.exit()
# Time series files
TS1 = sys.argv[1]
TS2 = sys.argv[2]
windowSize = int(sys.argv[3])
print("TS1:", TS1, "TS2:", TS2, "Window Size:", windowSize)
# Read Sequence as Pandas
ts1Temp = pd.read_csv(TS1, compression='gzip', header = None).astype(np.float64)
# Convert to NParray
ta = ts1Temp.to_numpy()
ta = ta.reshape(len(ta))
# Read Sequence as Pandas
ts2Temp = pd.read_csv(TS2, compression='gzip', header = None).astype(np.float64)
# Convert to NParray
tb = ts2Temp.to_numpy()
tb = tb.reshape(len(tb))
print(len(ta), len(tb))
start_time = time.time()
mpdist = stumpy.mpdist(ta, tb, m=windowSize)
print("--- %.5f seconds ---" % (time.time() - start_time))
print("MPdist: %.4f " % mpdist)</pre>
<p>This program uses command-line arguments with the help of <code>sys</code> to read the required data, instead of the <code>argparse</code> package.</p>
<p>All of this is done by the call to <code>stumpy.mpdist()</code>, which requires three parameters – the two time series and the sliding window size.</p>
<p>As <code>mpdistance.py</code> calculates the distance between two time series, it expects to read two files. Running <code>mpdistance.py</code> with two synthetic data sets with 100,000 elements each <a id="_idIndexMarker059"/>generates the following output:</p>
<pre class="source-code">
$ taskset --cpu-list 0 ./mpdistance.py 100k_1.txt.gz 100k_2.txt.gz 512
TS1: 100k_1.txt.gz TS2: 100k_2.txt.gz Window Size: 512
100000 100000
--- 349.81955 seconds ---
MPdist: 28.3882</pre>
<p>So, on a Linux machine with an Intel i7 CPU, it took <code>mpdistance.py</code> <code>349.81955</code> <code>seconds</code> to execute when <em class="italic">using a single CPU core</em>. The value of the MPdist distance is <code>28.3882</code>.</p>
<p>If we use two datasets with half a million elements each (500,000 elements), the output and the time it takes to execute <code>mpdistance.py</code> should be similar to the following:</p>
<pre class="source-code">
$ taskset --cpu-list 3 ./mpdistance.py h_500k_f.gz t_500k_f.gz 2048
TS1: h_500k_f.gz TS2: t_500k_f.gz Window Size: 2048
506218 506218
--- 4102.92 seconds ---
MPdist: 38.2851</pre>
<p>So, on a Linux machine with an Intel i7 CPU, it took <code>mpdistance.py</code> <code>4102.92</code> seconds to execute when <em class="italic">using a single CPU core</em>. The value of the MPdist distance is <code>38.2851</code>.</p>
<p>You will learn all the details about MPdist in <a href="B14769_07.xhtml#_idTextAnchor160"><em class="italic">Chapter 7</em></a>. For now, what you should keep in mind is that <a id="_idIndexMarker060"/>MPdist is a distance function that has some performance issues.</p>
<p class="callout-heading">Experiment and stay humble</p>
<p class="callout">If I can give you just one piece of advice to remember from this book, it would be to experiment and try things. Experiment as much as possible with what you read, question it, think in new ways, try new things, and keep learning. At the same time, stay humble, and do not forget that lots of people have worked to lay the foundation for us to be here today talking about time series and indexing.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Summary</h1>
<p>In this chapter, we learned the basics of time series, indexing, and distance functions. Although the theoretical knowledge included in this chapter remains valid and relevant no matter what programming language is used, alternative ways and packages to achieve the presented tasks in Python exist, as well as other programming languages. What remains unchanged is the validity of the approach – you must read a text file from disk in order to use its data, no matter the programming language – and the logical steps needed to perform a task, such as the visualization of a time series. This means that if you know an alternative way to load a text file from disk in Python, feel free to use it if it allows you to perform the next task at hand. If you are an amateur Python developer, I would suggest that you follow the book’s suggestions until you become more competent with Python. After all, the used Python packages are the most popular ones in the Python community.</p>
<p>Before you continue reading this book, please make sure that you understand the knowledge presented in this chapter, as it is the foundation for the rest of the book, especially if you are new to time series and indexing.</p>
<p>The next chapter is about the SAX representation, which is an integral part of the iSAX index.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor051"/>Resources and useful links</h1>
<ul>
<li>The Stumpy Python package: <a href="https://pypi.org/project/stumpy/">https://pypi.org/project/stumpy/</a>.</li>
<li>The NumPy Python package: <a href="https://numpy.org/">https://numpy.org/</a>.</li>
<li>The SciPy Python package: <a href="https://pypi.org/project/scipy/">https://pypi.org/project/scipy/</a> and <a href="https://scipy.org/">https://scipy.org/</a>.</li>
<li>Anaconda documentation: <a href="https://docs.anaconda.com/">https://docs.anaconda.com/</a>.</li>
<li>Anaconda distribution: <a href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a>.</li>
<li>Jupyter Notebooks: <a href="https://jupyter.org/">https://jupyter.org/</a>.</li>
<li>Matplotlib: <a href="https://pypi.org/project/matplotlib/">https://pypi.org/project/matplotlib/</a> and <a href="https://matplotlib.org/">https://matplotlib.org/</a>.</li>
<li>The Z Shell: <a href="https://www.zsh.org/">https://www.zsh.org/</a>.</li>
<li>Oh My Zsh: <a href="https://github.com/ohmyzsh/ohmyzsh">https://github.com/ohmyzsh/ohmyzsh</a>.</li>
<li>The Pandas Python package: <a href="https://pypi.org/project/pandas/">https://pypi.org/project/pandas/</a>.</li>
<li>The Dewey Decimal Classification system: <a href="https://en.wikipedia.org/wiki/Dewey_Decimal_Classification">https://en.wikipedia.org/wiki/Dewey_Decimal_Classification</a>.</li>
<li>The Numba Python package: <a href="https://pypi.org/project/numba/">https://pypi.org/project/numba/</a>.</li>
<li>The Matrix Profile is defined in a research paper called <em class="italic">Matrix Profile I: All Pairs Similarity Joins for Time Series: A Unifying View That Includes Motifs, Discords and Shapelets</em>. The authors of the paper are Chin-Chia Michael Yeh, Yan Zhu, Liudmila Ulanova, Nurjahan Begum, Yifei Ding, Hoang Anh Dau, Diego Furtado Silva, Abdullah Mueen, and Eamonn J. Keogh.</li>
<li>The MPdist distance is defined in a research paper called <em class="italic">Matrix Profile XII: MPdist: A novel time series distance measure to allow data mining in more challenging scenarios</em>. The authors of the paper are S. Gharghabi, S. Imani, A. Bagnall, A. Darvishzadeh, and E. Keogh.</li>
<li>You can find more information about <code>numpy.linalg.norm()</code> at <a href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml">https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.xhtml</a>.</li>
<li>The Homebrew macOS package manager: <a href="https://brew.sh/">https://brew.sh/</a>.</li>
</ul>
<h1 id="_idParaDest-44"><a id="_idTextAnchor052"/>Exercises</h1>
<p>Try to do the following exercises:</p>
<ul>
<li>Create a new Anaconda environment.</li>
<li>List the installed packages of an Anaconda environment.</li>
<li>Delete an existing Anaconda environment.</li>
<li>Create a new synthetic dataset with 1,000 values from -10 to +10.</li>
<li>Create a new synthetic dataset with 100,000 values from 0 to +10.</li>
<li>Write a Python script that reads a plain text file line by line.</li>
<li>Write a Python script that reads a plain text file and prints it word by word. Why is this more difficult than printing a file line by line?</li>
<li>Write a Python script that reads the same plain text file multiple times, and time that operation. The number of times the file is read as well as the file path should be given as command-line arguments.</li>
<li>Modify <code>synthetic_data.py</code> to generate integer values instead of floating-point values.</li>
<li>Create a time series with 500,000 elements with <code>synthetic_data.py</code>, and execute <code>matrix_profile.py</code> on the generated time series. Do not forget to compress the plain text file.</li>
<li>Modify <code>mpdistance.py</code> to use <code>argparse</code> to read its parameters.</li>
<li>Experiment with <code>visualize.py</code> to plot your own time series. What happens when you plot big time series? How easy it is to find what you are looking for?</li>
<li>In the iSAX index in <em class="italic">Figure 1</em><em class="italic">.2</em> a binary tree? Is it a balanced tree? Why?</li>
<li>Modify <code>ed.py</code> to read the time series from compressed plain text files.</li>
</ul>
</div>
</div></body></html>