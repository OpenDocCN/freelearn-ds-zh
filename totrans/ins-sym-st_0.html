<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Instant SymPy Starter</h1></div></div></div><p>Welcome to <em>Instant SymPy Starter</em>. This book has been especially created to provide you with all the information that you need to get up to speed with SymPy. You will learn the basics of SymPy, build your first SymPy code, and discover functions and tricks of the trade when it comes to using SymPy.</p><p>This document contains the following sections:</p><p><em>So, what is SymPy?</em> helps you find out what SymPy actually is, what you can do with it, and why it’s so great.</p><p><em>Installation</em> teaches you how to try out SymPy in your browser, download and install it with minimum fuss, and then set up its optional dependencies so that you can use all its functionalities.</p><p><em>Quick start – Automated curve sketching</em> will show you how to perform one of the core tasks of SymPy, automating mathematical tasks, by guiding you through the creation of a commonplace curve sketching application.</p><p><em>Top 5 features you need to know about</em> will teach you how to perform five tasks with the most important features of SymPy. By the end of this section you will be able to create symbolic expressions, manipulate them, convert them to efficient numerical functions, compute limits, integrals and derivatives, and solve equations.</p><p><em>People and places you should get to know</em> provides you with many useful links to the open source project as it is centered around a community. You will find the project page and forums, as well as a number of helpful articles, tutorials, blogs, and the Twitter feeds of SymPy contributors.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec03"/>So, what is SymPy?</h1></div></div></div><p>SymPy is a library for symbolic computation written entirely in Python and distributed under a BSD-type permissive free software license. Its core symbolic capabilities include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elementary algebra</li><li class="listitem" style="list-style-type: disc">Pattern matching and substitution</li><li class="listitem" style="list-style-type: disc">Symbolic transformations and simplifications</li><li class="listitem" style="list-style-type: disc">All the common mathematical functions and many special ones</li><li class="listitem" style="list-style-type: disc">Calculus: limits, derivatives, integrals, Taylor series, and so on</li><li class="listitem" style="list-style-type: disc">Solving many kinds of equations, including differential equations</li><li class="listitem" style="list-style-type: disc">Linear algebra</li><li class="listitem" style="list-style-type: disc">Polynomials</li><li class="listitem" style="list-style-type: disc">Infinite sums and products</li><li class="listitem" style="list-style-type: disc">Planar geometry</li><li class="listitem" style="list-style-type: disc">Physical constants and units</li><li class="listitem" style="list-style-type: disc">Numeric computation in arbitrary precision</li></ul></div><p>SymPy also includes subpackages dealing with advanced, specialized topics such as category theory, quantum logic, mechanical dynamics, or statistics. Even if you have no use for their functionalities, they can serve as useful examples of how to encode complex domain knowledge.</p><p>SymPy is well integrated with the rest of the scientific Python ecosystem. Using it inside the IPython notebook provides a productive environment for prototyping and exploration of symbolic models and calculations. Powerful numerical libraries—such as NumPy, SciPy, pandas, and sklearn—are also just a few import statements away, and SymPy has features to help smooth the transition between the symbolic and numeric worlds.</p><p>What sets SymPy apart from conventional computer algebra systems is that it is easy to integrate it into any processing pipeline. Drawing from the qualities of Python, it is easy to interface it with any other Python library or even with other languages. It can, for instance, serve as a bridge between two otherwise incompatible systems, such as a proprietary dynamical modeling application or a C library for coupled differential equations, transform user input to feed it to a renderer, or serve as an easier and less error-prone way of turning equations into efficient code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec04"/>Installation</h1></div></div></div><p>In four easy steps, you can install SymPy and prepare it to be used on your system.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec03"/>Step 1 – Trying it out online</h2></div></div></div><p>The easiest way to use SymPy is to try it out in your browser. SymPy is available from <a class="ulink" href="http://live.sympy.org">http://live.sympy.org</a>, an online Python shell, with SymPy already imported, which allows you to perform simple calculations. Take a moment to become familiar with it. Every code snippet in the online documentation can be turned into a SymPy Live shell, so you will be using it quite often. It looks as follows:</p><div><img src="img/3626OS_01_01.jpg" alt="Step 1 – Trying it out online"/></div><p>The Live shell is similar to the default Python shell, with tab completion enabled and LaTeX-based pretty printing. The obvious limitations of an online app apply: the local filesystem is unavailable and computations are throttled.</p><p>When it comes to deployment and distribution of the final product, SymPy's liberal license places no legal restriction on re-use, and being a pure-Python library, it can easily be installed into most environments, so it can easily be used to enable mathematically-aware scripting by end users.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec04"/>Step 2 – Installing the environment</h2></div></div></div><p>SymPy is entirely written in Python and has no mandatory dependencies. So the only thing you need to run it is an appropriate version of the Python interpreter.</p><p>However, for developing with SymPy or using it interactively, it is highly recommended to install NumPy, matplotlib, and, most importantly, IPython. The IPython notebook provides a productive environment for interactive exploration, combined with the ability to display mathematical notation.</p><p>On Mac and Windows devices, the easiest way is to install one of the scientific Python distributions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Python(x,y)</strong> – <a class="ulink" href="http://code.google.com/p/pythonxy/">http://code.google.com/p/pythonxy/</a></li><li class="listitem" style="list-style-type: disc"><strong>Enthought Python Disrtibution</strong> (<strong>EPD</strong>) – <a class="ulink" href="http://www.enthought.com/products/epd.php">http://www.enthought.com/products/epd.php</a></li><li class="listitem" style="list-style-type: disc"><strong>Anaconda CE</strong> – <a class="ulink" href="http://www.continuum.io/downloads.html">http://www.continuum.io/downloads.html</a></li></ul></div><p>Python(x, y) targets Windows and is the best choice on that platform. EPD is free to use only for academics and students. Anaconda CE has fewer features, but is free for everyone. All three provide SymPy as well as the core components of the Python scientific stack; if you install one of them, you can skip ahead to step 4.</p><p>On Linux, the package manager simplifies the installation of packages with dependencies. The same applies to Mac users of Homebrew or Macports who want more control over their system than what the distribution route affords. Windows users with the same requirements will have to rely on the binary installers provided by the different projects or master the art of compiling Python extensions.</p><p>The best supported version of Python is 2.7, but 2.6, 3.2, 3.3, and PyPy are also supported. Additionally, SymPy supports Python 2.5 but the IPython notebook does not. You probably already have a Python interpreter, but if it is not Version 2.7, we recommend that you install it with your package manager or go to <a class="ulink" href="http://www.python.org/download/">http://www.python.org/download/</a> and choose the appropriate installer.</p><p>For IPython, we need Version 0.13 or newer. Install it from your package manager if you can, noting that some distributions split its components into several packages. So, on Debian and Ubuntu, for instance, you should use the following command:</p><div><pre class="programlisting">$ sudo apt-get install ipython-notebook</pre></div><p>If your OS does not provide a sufficiently recent version, go to <a class="ulink" href="http://ipython.org">http://ipython.org</a> and follow the installation instructions. On Ubuntu, you can also use a <strong>Personal Package Archive</strong> (<strong>PPA</strong>) at <a class="ulink" href="https://launchpad.net/~jtaylor/+archive/ipython">https://launchpad.net/~jtaylor/+archive/ipython</a>.</p><p>For NumPy and matplotlib, there are no stringent version requirements so you can probably use whatever version your package manager provides. On Debian and Ubuntu, you only need to use the following command:</p><div><pre class="programlisting">$ sudo apt-get install python-numpy python-matplotlib</pre></div><p>Installing the libraries from the source presents no particular difficulty if you are used to compiling C and C++ extensions. Just locate and, if needed, compile their respective dependencies, then use pip to compile and install the libraries themselves. If you do not already have pip, go to <a class="ulink" href="http://www.pip-installer.org/en/latest/installing.html">http://www.pip-installer.org/en/latest/installing.html</a> and follow the instructions. Then, type the following command:</p><div><pre class="programlisting">$ [sudo] pip install numpy matplotlib ipython[zmq,notebook]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec05"/>Step 3 – Installing SymPy</h2></div></div></div><p>The easiest option is to use pip. At the command line, simply type the following command and that's it:</p><div><pre class="programlisting">$ [sudo] pip install sympy</pre></div><p>Another possibility is to download a source archive. Go to <a class="ulink" href="http://code.google.com/p/sympy/downloads/list">http://code.google.com/p/sympy/downloads/list</a> and pick the most recent source release for your Python version (its name should look something like <code class="literal">sympy-0.7.2.tar.gz</code>, or <code class="literal">sympy-0.7.2-py3.2.tar.gz</code> if you use Python 3.*). Unpack the archive, open a console in the newly created folder, and type the following command (replace <code class="literal">python</code> with <code class="literal">python3</code> if needed):</p><div><pre class="programlisting">$ python setup.py install</pre></div><p>SymPy should now be installed and you can discard the archive and the folder.</p><div><img src="img/3626OS_01_02.jpg" alt="Step 3 – Installing SymPy"/><div><p>Choosing the right archive to download</p></div></div><p>Finally, on Linux, another simple alternative is to use your distribution's package manager. For example, for Debian and Ubuntu, use the following command:</p><div><pre class="programlisting">$ sudo apt-get install python-sympy</pre></div><p>However, you may not get the latest version of SymPy.</p><p>In any case, to check that SymPy has been correctly installed, enter a Python shell and type <code class="literal">import sympy</code>. It should succeed without producing any output (ignore any warnings related to matplotlib). To make sure that all of SymPy works as intended on your system, you can additionally run the full test suite with <code class="literal">sympy.test()</code> (beware, it takes quite a long time).</p><div><img src="img/3626OS_01_03.jpg" alt="Step 3 – Installing SymPy"/><div><p>Testing a fresh installation of SymPy</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Step 4 – Configuring the notebook</h2></div></div></div><p>The IPython notebook is a two-process application split between a frontend and a kernel executing Python code. The frontend is a JavaScript application that runs in a web browser (all recent versions of major browsers are supported, except Internet Explorer).</p><p>The notebook is a perfect environment for exploratory analysis. It has an intuitive and minimalist interface based on the concept of cells, that is, multiline text input boxes. They can hold text—to structure the notebook and add explanations—or Python code. Code cells are executed as a unit and the result of the last line is displayed as in a shell. There is also a rich and extensible system of magic commands that start with <code class="literal">%</code> and allow nearly any conceivable action inside the notebook, from configuring IPython to executing shell commands to embedding other languages. Look inside the <strong>Help</strong> menu for more information.</p><p>The notebook has built-in support for displaying matplotlib figures in-line, and we recommend that you always use it when working with SymPy (one reason is that a quirk of the three-way interaction between sympy-0.7.2, IPython, and matplotlib prevents the latter from being properly configured once SymPy has been imported). Therefore, to start the notebook, use the following command:</p><div><pre class="programlisting">$ ipython notebook –-pylab inline</pre></div><p>This should open your web browser on the IPython Dashboard page. Create a new notebook. To configure it for a SymPy session, type the following into the first cell and execute it by pressing <em>Shift</em> + <em>Enter</em>:</p><div><pre class="programlisting">%load_ext sympy.interactive.ipythonprinting
from sympy import *
x, y, z = symbols('x y z')</pre></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line sets up LaTeX-based rendering of results using MathJax.</li><li class="listitem" style="list-style-type: disc">The second one imports a large number of names from the <code class="literal">sympy</code> namespace. This makes it possible to type formulas in a natural way, but you should be aware that there are many name conflicts with <code class="literal">numpy</code>. Consequently, whenever you plan to use both libraries heavily in the same notebook, you should rather use an import shortcut trick à la <code class="literal">import sympy as sy</code>.</li><li class="listitem" style="list-style-type: disc">The third line is optional and merely creates a few mathematical variables to play with.</li></ul></div><p>Now, try to enter a formula, for instance, <code class="literal">(exp(x)/factorial(y))**z</code>, and admire the result. You should see something like the following :</p><div><img src="img/3626OS_01_04.jpg" alt="Step 4 – Configuring the notebook"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>And that's it</h2></div></div></div><p>By this point, you should have a working environment ready to make full use of SymPy. You are encouraged to play around in the notebook and discover more.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Quick start – Automated curve sketching</h1></div></div></div><p>The main use of SymPy is to automate tedious mathematical procedures, so let us look at an example of this. Curve sketching, that staple of introductory calculus classes where the student has to find out the salient features of the curve of a function through algebraic manipulations, limits, and derivatives. In this section, you will learn how to perform it automatically using SymPy.</p><p>There are many variants of the task. For simplicity, we will reduce it to its bare essentials: identifying the local extrema and asymptotes of the curve, and highlight them on a plot of the function. We will also limit ourselves to rational fractions, which are functions equal to a ratio of polynomials.</p><p>We shall work exclusively in the IPython notebook, taking advantage of its advanced mathematical rendering and of in-line plotting. Our goal will be to write a function that takes a string (representing a mathematical function using the Python syntax) and creates a figure similar to the following:</p><div><img src="img/3626OS_01_05.jpg" alt="Quick start – Automated curve sketching"/></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Step 1 – Handling the input</h2></div></div></div><p>Let us choose <code class="literal">string = '1/(x-1) + 1/(x+1) + x + 1'</code> as the example that will guide us along the way. The <code class="literal">sympify()</code>function can convert a string into an expression. However, this expression needs further transformation. One issue is that SymPy defaults to computing in the complex field, but here we are only interested in real values. We also need to ensure that the expression is explicitly in the form of a rational fraction.</p><p>Our first task is therefore to create a function that handles all these operations. Thanks to the notebook interface, you can build it step by step, first by creating a series of statements operating on the example string and then converting this series of operation into a <code class="literal">convert_input(string)</code> function that works on all valid input strings. These steps are illustrated as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new notebook.</li><li class="listitem">In the first cell, add <code class="literal">%load_ext sympy.interactive.ipythonprinting</code> and <code class="literal">from sympy import *</code> (refer to <em>Step 4 – Configuring the notebook</em> of the <em>Quick start</em> section), and execute by pressing <em>Shift</em> + <em>Enter</em>.</li><li class="listitem">In the next cell, type <code class="literal">string = '1/(x-1) + 1/(x+1) + x + 1'</code>.</li><li class="listitem">Still in the second cell, add the line: <code class="literal">expr = sympify(string)</code> and execute it. This converts <code class="literal">string</code> into a SymPy expression.</li><li class="listitem">Check your result by executing <code class="literal">expr</code> in the third cell.</li><li class="listitem">Back in the second cell, find the symbol that <code class="literal">expr</code> uses with <code class="literal">sym, = expr.free_symbols</code> (this will fail if there are no symbols or if there are more than one). Again execute the cell and check your result.</li><li class="listitem">Create a real symbol with the same name using <code class="literal">x = Symbol(sym.name, real=True)</code>.</li><li class="listitem">Replace <code class="literal">sym</code> with <code class="literal">x</code> in the expression using <code class="literal">expr = expr.subs(sym, x)</code> and check your result.</li><li class="listitem">Turn the expression into a rational fraction. For this, you need the <code class="literal">together()</code>function, which combines the expression into a single fraction, and the <code class="literal">cancel()</code> function, which simplifies the fraction.</li><li class="listitem">Finally, create the <code class="literal">convert_input(string)</code> function: insert the line <code class="literal">def convert_input(string):</code> before the second line of the cell, add <code class="literal">return frac, x</code> at the end, and, just for clarity, move the first line (the definition of <code class="literal">string</code>) elsewhere.</li></ol></div><p>You can now test your function on <code class="literal">string</code> and on other inputs. In the following sections, we will assume that <code class="literal">frac, x = convert_input('1/(x-1) + 1/(x+1) + x + 1')</code> has been run. At this point, your notebook should contain something like the following:</p><div><img src="img/3626OS_01_06.jpg" alt="Step 1 – Handling the input"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Step 2 – Finding the domain of definition</h2></div></div></div><p>The domain of definition of the function is the set of values of <em>x</em> for which the expression is well-defined. In the case of a rational fraction, these are the values where the denominator is not zero. Computing the domain is hence just a matter of finding the (real) roots of the denominator and computing the complement of the set of roots. You can do this as follows (continue to check the results after every instruction):</p><div><ol class="orderedlist arabic"><li class="listitem">Extract the denominator of the fraction, using <code class="literal">den = denom(x)</code>.</li><li class="listitem">Find the zeros of the denominator with <code class="literal">poles = solve(den, x)</code>. Since <code class="literal">x</code> was declared as real, this call to <code class="literal">solve()</code> finds the real values of <code class="literal">x</code> for which <code class="literal">den</code> is zero.</li><li class="listitem">Get the domain. The full real line is <code class="literal">Interval(-oo, oo)</code> and the list of zeros can be converted to a symbolic set by calling <code class="literal">FiniteSet.fromiter(poles)</code>.</li></ol></div><p>Here are the notebook cells corresponding to this step:</p><div><img src="img/3626OS_01_07.jpg" alt="Step 2 – Finding the domain of definition"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Step 3 – Finding the local extrema</h2></div></div></div><p>To find the local extrema, we need to compute the derivative of the function. The zeros of the derivative give the critical points, in other words, the points where the curve has a horizontal tangent. The local extrema of the function are actually the zeros where the derivative changes sign, but for simplicity, we will ignore this detail and assume, as is usually the case, that every zero is an extremum.</p><p>You should therefore use the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Compute the derivative by calling <code class="literal">diff(frac, x)</code>.</li><li class="listitem">Apply the <code class="literal">cancel()</code> function to the previous result to simplify the derivative. These two steps can be combined using the code: <code class="literal">deriv = cancel(diff(frac, x))</code>.</li><li class="listitem">Find the zeros using the following code: <code class="literal">extrema = solve(deriv, x)</code>.</li><li class="listitem">Get the value of the function at each extremum. To do this, replace <code class="literal">x</code> with the location <code class="literal">x0</code> of each extremum, using <code class="literal">frac.subs(x, x0)</code>.</li></ol></div><p>Applying these instructions should give you the following:</p><div><img src="img/3626OS_01_08.jpg" alt="Step 3 – Finding the local extrema"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Step 4 – Computing the asymptotes</h2></div></div></div><p>We shall now find the asymptotes of the curve. In fact, we already know the vertical asymptotes; they are simply the lines <em>x = x0</em> for each pole <em>x0</em>. For a rational function, the only other possible asymptote can be found by studying the function's behavior when <em>x</em> goes to infinity. If we have <em>f(x) ≈ m x + p</em> in that case, <em>y = m x + p</em> is the equation of the asymptote. To find <em>m</em> and <em>p</em>, we take <em>m</em> as the limit of <em>f(x)/x</em>, if it is not infinite, and then take <em>p</em> as the limit of <em>f(x) – m x</em>.</p><p>It is actually easier to do it than to explain it – simply follow these instructions:</p><div><ol class="orderedlist arabic"><li class="listitem">Compute the limit of <em>f(x)/x</em> using <code class="literal">m = limit(y/x, x, oo)</code>.</li><li class="listitem">To check that m is not infinite, use <code class="literal">m.is_bounded</code></li><li class="listitem">Compute the limit of f(x) – m x, using <code class="literal">p = limit(y – m*x, x, oo)</code></li><li class="listitem">Wrap this into a function <code class="literal">find_asymptote(expr, x)</code> that returns <code class="literal">(m, p)</code> if the asymptote exists and <code class="literal">None</code> otherwise.</li></ol></div><p>The result of this step should look as follows:</p><div><img src="img/3626OS_01_09.jpg" alt="Step 4 – Computing the asymptotes"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Step 5 – Plotting the curve</h2></div></div></div><p>To create the summary plot, we will use matplotlib directly. So, let us first see how to plot just the curve. Since direct numerical evaluation inside SymPy, while precise, is rather slow, it would be inefficient to generate the curve using it. Fortunately, it is easy to "compile" a symbolic expression into a Python function that takes advantage of NumPy's fast vectorized operations. Everything else is just standard matplotlib. Follow these instructions:</p><div><ol class="orderedlist arabic"><li class="listitem">Import matplotlib and NumPy, using <code class="literal">import matplotlib.pyplot as plt</code> and <code class="literal">import numpy as np</code>.</li><li class="listitem">Compile the function using <code class="literal">func = lambdify([x], frac)</code>.</li><li class="listitem">Create a NumPy array sampling the <em>x</em>-interval, with the <code class="literal">np.linspace()</code>function.</li><li class="listitem">Evaluate the compiled function over the array.</li><li class="listitem">Draw the plot, using <code class="literal">plt.plot()</code>.</li><li class="listitem">Set the bounding box in the <em>x</em> and <em>y</em> directions, using the <code class="literal">plt.xlim()</code> and <code class="literal">plt.ylim()</code>functions.</li><li class="listitem">Bundle this procedure into a helper function, <code class="literal">plot_curve(expr, x, (x_min, x_max), (y_min, y_max))</code>.</li></ol></div><p>For this step, you should end up with the following:</p><div><img src="img/3626OS_01_10.jpg" alt="Step 5 – Plotting the curve"/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Step 6 – Building the figure</h2></div></div></div><p>To make the final figure, we need to choose a plotting domain, overlay the asymptotes and the critical points over the graph of the function, and add a descriptive title.</p><p>Choosing a domain that gives an informative and aesthetically pleasing figure is actually an art. Doing it automatically is hence challenging. We will dodge this difficulty by simply making sure that the domain contains all the interesting values of <code class="literal">x</code> and <code class="literal">y</code>, and add a buffer of <code class="literal">2</code> on all sides. In code, this means <code class="literal">x_min = min(xs) - 2</code> and <code class="literal">x_max = max(xs) + 2</code>.</p><p>Here are the steps you should use:</p><div><ol class="orderedlist arabic"><li class="listitem">Write a helper function <code class="literal">choose_domain()</code>: it needs to take a list, convert its elements to float, and return <code class="literal">x_min</code> and <code class="literal">x_max</code> as aforementioned. Note that calling <code class="literal">float()</code> on symbolic SymPy objects automatically converts them into ordinary Python floats using numerical algorithms.</li><li class="listitem">Find the bounds for <code class="literal">x</code>, the interesting values being the origin, the poles, and the extrema. For this, you can use the following code:<div><pre class="programlisting">x_min, x_max = choose_domain([0] + poles + extrema)</pre></div></li><li class="listitem">Find the bounds for <code class="literal">y</code>, using the origin, the extrema, and the end points of the oblique asymptote, with the following:<div><pre class="programlisting">y_min, y_max = choose_domain([0] + extrema_values + [m*x_min + p, m*x_max + p])</pre></div></li><li class="listitem">Plot the curve, using <code class="literal">plot_curve(frac, x, (x_min, x_max), (y_min, y_max))</code>.</li><li class="listitem">Add the vertical asymptotes, using the following code:<div><pre class="programlisting">plt.vlines(poles, y_min, y_max, 'r', linewidth=2)</pre></div></li><li class="listitem">Add the oblique asymptote, using the following code:<div><pre class="programlisting">plt.plot([x_min, x_max], [m*x_min + p, m*x_max + p], 'r', linewidth=2)</pre></div></li><li class="listitem">Add the extrema, using the following code:<div><pre class="programlisting">plt.plot(extrema, extrema_values, 'ro')</pre></div></li><li class="listitem">Finally, add the title. SymPy's <code class="literal">latex()</code> function returns the LaTex representation of its argument, which matplotlib can render. This allows you to use mathematical notation in the title, using the following code:<div><pre class="programlisting">plt.title("Sketch of $%s \mapsto %s$" % (latex(x), latex(frac)))</pre></div></li></ol></div><p>The final result of these steps looks as follows:</p><div><img src="img/3626OS_01_11.jpg" alt="Step 6 – Building the figure"/></div><div><div><h3 class="title"><a id="tip01"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Top 5 features you'll want to know about</h1></div></div></div><p>As you start to use SymPy, you will realize that there are a wide variety of things that you can do with it and many concepts you need to understand. This section will teach you all about the most fundamental features and the most commonly performed tasks in SymPy.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Creating expressions</h2></div></div></div><p>Mathematical expressions are the most important objects in SymPy. Nearly everything you can do involves expressions at some point. In this section, you will learn how best to create mathematical expressions that SymPy can manipulate.</p><p>The first building blocks for expressions are numbers. SymPy uses its own classes to represent them because the behavior of Python's built-in types is geared toward numerical evaluation, not symbolic computation. There are two major kinds of numbers: exact expressions and floating point numbers. The latter are represented by the class <code class="literal">Float</code>.</p><p>Exact expressions can involve many different classes as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Integer</code> represents signed integer numbers of arbitrary magnitude.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Rational</code> represents rational numbers, or ordinary fractions. Internally, it is implemented as a pair of integers.</li><li class="listitem" style="list-style-type: disc">Common mathematical constants are represented by singleton classes and are directly available in the <code class="literal">sympy</code> namespace. Thus, <code class="literal">pi</code> is the diameter of a unit circle, <code class="literal">E</code> is the base of the natural logarithm, and <code class="literal">I</code> is the imaginary unit. Note that there is no separate type corresponding to complex numbers. Rather, they are represented in the same way as they are usually written with pen and paper, for example, <code class="literal">2 + 3*I</code> is 2 + 3i.</li></ul></div><p><code class="literal">Integer</code> objects behave mostly like Python's built-in <code class="literal">int</code>. The most important exception is that the division between integers is exact and returns either an <code class="literal">Integer</code> or <code class="literal">Rational</code> object. Here are a few examples of arithmetic operations:</p><div><pre class="programlisting">&gt;&gt;&gt; Integer(3) + Integer(4)
7
&gt;&gt;&gt; Integer(3) - Integer(4)
-1
&gt;&gt;&gt; Integer(3) * Integer(4)
12
&gt;&gt;&gt; Integer(4) / Integer(3)  # returns a Rational
4/3
&gt;&gt;&gt; Integer(6) / Integer(3)  # returns an Integer
2
&gt;&gt;&gt; Integer(3) ** Integer(4)
81
&gt;&gt;&gt; Integer(4) // Integer(3)
1
&gt;&gt;&gt; Integer(12) % Integer(5)
2</pre></div><div><div><h3 class="title"><a id="note01"/>Note</h3><p>When you enter a number into the interpreter, such as "3", it creates a Python built-in object, of class <code class="literal">int</code>. To convert it to a SymPy object, you need to use the <code class="literal">sympify()</code> function, or the more convenient shortcut <code class="literal">S()</code>. Thus, you can use <code class="literal">S(23)</code> to create an integer. However, all operations between a SymPy object and a Python number convert the number into a SymPy object, and all the common functions do the same to their arguments. This limits the need for <code class="literal">S()</code>drastically. In practice, the rule to remember is that you must use <code class="literal">S()</code> only when dividing two integers, as in <code class="literal">S(1)/2</code>.</p></div></div><p>A few additional operations are available, such as prime factor decomposition with <code class="literal">factorint()</code>, finding the least common multiple with <code class="literal">lcm()</code>, or the greatest common divisor with <code class="literal">gcd()</code>.</p><div><pre class="programlisting">&gt;&gt;&gt; factorint(42)
{2: 1, 3: 1, 7: 1}
&gt;&gt;&gt; lcm(15, 20)
60
&gt;&gt;&gt; gcd(15, 20)
5</pre></div><p>Rationals also support all arithmetic operations. The resulting fractions are always reduced to their lowest terms. Also, raising a number to a fractional power produces algebraic <em>n</em>th roots. There are a few conveniences to make such calculations easier: <code class="literal">sqrt(n)</code> is a shortcut for <code class="literal">n**(S(1)/2)</code> and <code class="literal">root(n, a)</code> is a shortcut for <code class="literal">n**(1/a)</code>.</p><p>Doing calculations involving fractions and square roots with SymPy is therefore as easy as elementary arithmetic using only integers. Here are the steps to follow:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the relevant numbers, using <code class="literal">S()</code> as necessary.</li><li class="listitem">Write the calculation in the obvious manner.</li></ol></div><p>For example, the following commands find the hypotenuse of a right triangle with sides one-half and two-thirds:</p><div><pre class="programlisting">&gt;&gt;&gt; # Decomposing for clarity
&gt;&gt;&gt; a = S(1)/2
&gt;&gt;&gt; b = S(2)/3
&gt;&gt;&gt; sqrt(a**2 + b**2)
5/6
&gt;&gt;&gt; # In a real setting, you would probably rather use a one-liner
&gt;&gt;&gt; # But mind the parentheses!
&gt;&gt;&gt; sqrt((S(1)/2)**2 + (S(2)/3)**2)
5/6</pre></div><p>Roots of negative and complex numbers are supported, but note that <em>n</em>th roots are always defined as the principal <em>n</em>th root of the number. This means in particular that the third root of a negative number is a complex number with positive real and imaginary parts. Also, these roots are often expressed using fractional powers of -1, as shown in the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; root(-25, 4)
(-1)**(1/4)*sqrt(5)
&gt;&gt;&gt; root(-1, 3) != -1
True</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Symbols</h3></div></div></div><p>We have just seen how to calculate with numbers, but the real power of mathematics comes from using algebraic variables. For this, you need to use the <code class="literal">Symbol</code> objects. To create them, you must specify their name and you can optionally specify various "assumptions" about the variable. The available assumptions include "integer", "real", "positive", and so on. If none is specified, the <code class="literal">Symbol</code> object is treated as a complex variable. Implications between properties are automatically taken into account, and impossible combinations cause an error. The following are a few examples of <code class="literal">Symbol</code> declarations:</p><div><pre class="programlisting">&gt;&gt;&gt; z = Symbol('z') # complex variable
&gt;&gt;&gt; x = Symbol('x', real=True) # real variable
&gt;&gt;&gt; a = Symbol('a', positive=True) # positive and therefore real</pre></div><p>The <code class="literal">symbols()</code>function makes it easier to create many symbols at once. The keyword arguments you give it are passed on to the <code class="literal">Symbol()</code> constructor. For the first argument, it accepts a mini-language inspired by the Python <code class="literal">slice</code> notation, which is best described by the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; symbols('x, y, z')
(x, y, z)
&gt;&gt;&gt; symbols('a:c, i:k')
(a, b, c, i, j, k)
&gt;&gt;&gt; symbols('x:5')
(x0, x1, x2, x3, x4)
&gt;&gt;&gt; symbols('x3:12')
(x3, x4, x5, x6, x7, x8, x9, x10, x11)</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>You may find on the Internet (including SymPy's own documentation) some references to the <code class="literal">sympy.abc</code> module or the <code class="literal">var</code> function. Their sole purpose is to save a little bit of typing, while using implicit magic to do so. We recommend that you only use <code class="literal">Symbol()</code> or <code class="literal">symbols()</code> and explicit assignments to create <code class="literal">Symbol</code> objects.</p></div></div><p>In the IPython notebook, symbol names containing Greek letters, underscores, and/or numbers get special rendering as shown in the following screenshot:</p><div><img src="img/3626OS_02_01.jpg" alt="Symbols"/></div><p>For the remainder of the text, we will assume that the following definitions are in effect:</p><div><pre class="programlisting">&gt;&gt;&gt; x, y = symbols('x, y', real=True)
&gt;&gt;&gt; a, b = symbols('a, b', positive=True)
&gt;&gt;&gt; z = symbols('z')</pre></div><p>All the arithmetic operators and mathematical functions operating on numbers work on symbols as well. The result is a new symbolic expression. Very simple calculations such as <code class="literal">x + x</code> are automatically carried out, but more complex expressions such as <code class="literal">(x + 1) * (x - 1)</code> are not simplified, as you can see:</p><div><pre class="programlisting">&gt;&gt;&gt; x + 2*y + x - 3*y
2*x - y
&gt;&gt;&gt; (x + 1)*(x - 1)
(x - 1)*(x + 1)</pre></div><p>It is worth emphasizing that SymPy symbols are just ordinary objects, as far as the Python interpreter is concerned. Even experienced SymPy users sometimes get bitten by the semantic proximity between Python variables and mathematical variables. To prevent confusion on this subject, let us analyze the following sequence of statements:</p><div><pre class="programlisting">&gt;&gt;&gt; t = Symbol('t')
&gt;&gt;&gt; expr = t + 1
&gt;&gt;&gt; t = 1
&gt;&gt;&gt; expr
t + 1</pre></div><p>In the first line, a <code class="literal">Symbol</code> object is created with <code class="literal">t</code> as the value of its name attribute. This object is immediately bound to a Python variable named <code class="literal">t</code>. In the second line, the object <code class="literal">(1 + Symbol('t'))</code> is bound to the variable <code class="literal">expr</code>. In the third line, the <code class="literal">t</code> variable is re-bound to the object <code class="literal">1</code>. This new binding does not affect the objects created in the first-two lines in any way, as the fourth line demonstrates.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Confusion arises when a <code class="literal">Symbol</code> object is bound to a variable with the same name (for example, with the statement <code class="literal">x = Symbol('x')</code>). To prevent it entirely, consider using different names for the variable and the <code class="literal">Symbol</code> object, that is, <code class="literal">symb = Symbol('x')</code>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Functions</h3></div></div></div><p>SymPy implements a large number of mathematical functions. Their names tend to follow programmers' naming conventions, with for example, "atanh" for the inverse hyperbolic tangent, "log" for the natural logarithm, or "sqrt" for the square root.</p><p>Applying a function to an exact number expression always results in another exact expression. This result is usually an unevaluated expression, such as sin(1), unless a simple result exists, such as sin(0) = 0, in which case it is returned. Evaluating the result can sometimes involve floating-point computations, which are automatically performed with enough precision.</p><p>Here is an elementary example of the use of mathematical functions:</p><div><pre class="programlisting">&gt;&gt;&gt; cos(log(2))
cos(log(2))</pre></div><p>It is also possible to create abstract symbolic functions; the syntax for this is <code class="literal">Function('f')</code>. Such functions behave like the built-in ones, except that their values always remain unevaluated, as shown in this example:</p><div><pre class="programlisting">&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; f(0)
f(0)</pre></div><p>Mathematical functions defined by an expression such as g(x) = 1 – x² are represented by Lambda objects. The name of this class and the syntax it uses echo Python's <code class="literal">Lambda</code> keyword. Calling these objects evaluates the function according to the given expression. Here is an example demonstrating the creation and use of a <code class="literal">Lambda</code> object:</p><div><pre class="programlisting">&gt;&gt;&gt; g = Lambda([x], 1 - x**2)
&gt;&gt;&gt; g
Lambda(_x, -_x**2 + 1)
&gt;&gt;&gt; g(2)
-3</pre></div><p>Note that the <code class="literal">Lambda</code> objects are rarely actually useful. The idiomatic way of studying the function <code class="literal">g</code>, which is previously defined, is to define <code class="literal">expr = 1 - x**2</code> and to manipulate that expression.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Manipulating expressions</h2></div></div></div><p>Once you have created expressions, you often need to transform them in some way. This section will teach you how to inspect them and to transform them in many ways.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>The structure of expressions</h3></div></div></div><p>In terms of structure, SymPy objects such as integers, rationals, constants, and symbols are called <strong>atoms</strong>. All expressions are built on top of these simpler objects. They obey the following invariant: <code class="literal">expr == expr.__class__(*expr.args)</code>, which means that all their properties derive solely from their type and the contents of their <code class="literal">.args</code> attribute. Also, since the elements of <code class="literal">expr.args</code> are SymPy objects themselves, the whole expression actually has a tree structure with SymPy classes as nodes and atoms as leaves.</p><p>It is easy, and often illuminating, to explore this expression tree. Here are some of the options at your disposal to do it:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">srepr()</code>function prints a low-level representation of the expression.</li><li class="listitem" style="list-style-type: disc">To walk the whole expression tree, use <code class="literal">preorder_traversal()</code>; it returns an iterator that yields nodes in a preorder fashion. That is, it yields the root (the full expression), then its first child, then the first child's first child, and so on</li><li class="listitem" style="list-style-type: disc">Drill down directly through the chain of <code class="literal">args</code>.</li></ul></div><p>The following commands show all these ways of exploring the expression <code class="literal">exp(-x)*log(1-x)*2</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; expr = exp(-x)*log(1-x)*2
&gt;&gt;&gt; srepr(expr)
"Mul(Integer(2), Function('exp')(Mul(Integer(-1), Symbol('x'))), Function('log')(Add(Mul(Integer(-1), Symbol('x')), Integer(1))))"
&gt;&gt;&gt; list(preorder_traversal(expr))
[2*exp(-x)*log(-x + 1), 2, exp(-x), -x, -1, x, log(-x + 1), -x + 1, 1, -x, -1, x]
&gt;&gt;&gt; expr.__class__, expr.args
(, (2, exp(-x), log(-x + 1)))
&gt;&gt;&gt; expr.args[1].__class__, expr.args[1].args
(exp, (-x,))</pre></div><p>In this example, you can see two important classes, <code class="literal">Add</code> and <code class="literal">Mul</code>, which are used internally to represent addition and multiplication, respectively. Note in particular that <code class="literal">1 - x</code> is actually represented as <code class="literal">Add(Mul(-1, x), 1)</code>, and that the actual order in which the arguments are stored internally has no relation to the order in which they were input.</p><p>You can also obtain an aggregate view of the contents of the expression with the <code class="literal">.atoms()</code>method. By default, it returns the set of the atomic objects contained in the expressions. A type can also be passed to it, to return all the objects of that type appearing in the expression tree. Here are a few ways of applying it to the expression from the previous example:</p><div><pre class="programlisting">&gt;&gt;&gt; expr.atoms()
set([1, 2, -1, x])
&gt;&gt;&gt; expr.atoms(Integer)
set([1, 2, -1])</pre></div><p>If you want to check which variables an expression depends on, this purely structural query does not give enough information, because some objects, such as <code class="literal">Lambda</code>, use <code class="literal">Symbol</code> internally as bound variables: in <code class="literal">Lambda([x], x*2)</code>, the identity of the symbol does not matter and, for any practical purpose, this object is the same as <code class="literal">Lambda([y], y**2)</code>. What you need in this case is the <code class="literal">free_symbols</code> property, which returns only the symbols acting as free variables. The right way of checking if some expr depends explicitly on <code class="literal">x</code> is therefore <code class="literal">x in expr.free_symbols</code>, as shown in the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; Lambda([x, y], x + y).free_symbols
set([])
&gt;&gt;&gt; Lambda([x, y], a*x + b*y).free_symbols
set([b, a])</pre></div><p>Conceivably, every operation on expressions could be done by walking through the expression tree and inspecting its elements as we have just seen and then constructing the result directly. And, indeed, a sizable portion of SymPy's source code does precisely that. It is, however, too cumbersome for ordinary uses and there are much more convenient ways of manipulating expressions, but exploring the expression tree should be your first reflex when debugging any problem.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Querying properties</h3></div></div></div><p>Every expression has properties, which include <code class="literal">is_integer</code>, <code class="literal">is_real</code>, and so on. These allow querying the mathematical properties of the object and correspond to the similarly named assumptions on symbols. They return <code class="literal">True</code>, <code class="literal">False</code>, or <code class="literal">None</code>, depending on whether the mathematical property is proven to be true, proven to be false, or of uncertain truth value.</p><p>For number expressions, they will usually return a definite answer, either <code class="literal">True</code> or <code class="literal">False</code>. For symbolic expressions, on the other hand, <code class="literal">None</code> is a common and meaningful result. For example, if <code class="literal">x = Symbol('x', real=True)</code>, then <code class="literal">x.is_positive</code> must return <code class="literal">None</code> because both positive and negative values are compatible with the assumption that <code class="literal">x</code> is real.</p><p>The following commands demonstrate the computation of these properties for numbers and symbolic expressions:</p><div><pre class="programlisting">&gt;&gt;&gt; (pi**2 - 9).is_positive
True
&gt;&gt;&gt; (x**2 + 1).is_positive
True
&gt;&gt;&gt; (x**2 - 1).is_positive is None
True</pre></div><p>SymPy checks the properties when performing many operations and can return different results depending on them. For instance, compare the following:</p><div><pre class="programlisting">&gt;&gt;&gt; sqrt(z**2)  # recall that z is complex
sqrt(z**2)
&gt;&gt;&gt; sqrt(x**2)  # x is real
Abs(x)
&gt;&gt;&gt; sqrt(a**2)  # a is positive
a</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Substitution</h3></div></div></div><p>SymPy objects and expressions are immutable. Transforming them actually means creating a new object differing from the initial one in some way. The most direct way of doing this is to use the <code class="literal">.subs()</code> method. <code class="literal">expr.subs(old, new)</code> returns a new expression where all the occurrences of <code class="literal">old</code> in <code class="literal">expr</code> have been replaced by <code class="literal">new</code>. To replace several different expressions at once, you can also pass it as a single argument a dictionary of the <code class="literal">{old: new}</code> pairs, as shown in the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; x, y = symbols('x, y', real=True)
&gt;&gt;&gt; (cos(x) * exp(y)).subs({x: pi, y: 2})
-exp(2)</pre></div><p>Substitution is also the most idiomatic way of evaluating a function at a specific value. To take an example, here is what you should do if you want to compute <code class="literal">f(2)</code>, where the function <code class="literal">f</code> is given by <code class="literal">f(x) = exp(x+1)/(x^2-2)</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the expression corresponding to the <code class="literal">exp(x+1)/(x**2 - 2)</code> function.</li><li class="listitem">Substitute <code class="literal">x</code> by <code class="literal">2</code> in the expression.</li></ol></div><p>The corresponding commands are as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; expr = exp(x+1)/(x**2-2)
&gt;&gt;&gt; expr.subs(x, 2)
exp(3)/2</pre></div><p>A useful trick involving substitution is to force some transformation that SymPy would not normally do. For instance, supposing you want to simplify <code class="literal">sqrt((z-1)**2)</code> to <code class="literal">z-1</code> inside a larger expression, even though <code class="literal">z</code> is complex, here is what you should do:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify what assumption would allow the transformation. Here you need to make the value of <code class="literal">(z - 1).is_positive</code> to be true.</li><li class="listitem">Find a substitution that makes the assumption true. Here, replacing <code class="literal">z</code> with <code class="literal">1 + a</code>, <code class="literal">a</code> positive, would do it.</li><li class="listitem">Do the substitution:<div><pre class="programlisting">expr.subs(z, 1 + a).</pre></div></li><li class="listitem">Optionally, do more manipulations on the substituted expression (not needed in this example).</li><li class="listitem">Substitute back the initial symbol.</li></ol></div><p>The corresponding commands are as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; expr = sqrt((z-1)**2)/z
&gt;&gt;&gt; tmp_expr = expr.subs(z, 1 + a)
&gt;&gt;&gt; tmp_expr
a/(a + 1)
&gt;&gt;&gt; expr = tmp_expr.subs(a, z-1)
&gt;&gt;&gt; expr
(z - 1)/z</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Simplification</h3></div></div></div><p>When you have a symbolic expression, a common need is to put it into a shorter form or one that is easier to understand. It is nearly always more convenient to deal with 1 than with <code class="literal">cos(x)**2 + sin(x)**2</code>. This is where the <code class="literal">simplify()</code> function comes in use.</p><p><code class="literal">simplify()</code> applies a heuristic combination of simplification algorithms. It can use trigonometric relations, apply properties of logarithms and exponentials, simplify fractions and square roots, and so on. In all these operations, it takes into account the properties of the objects, particularly <code class="literal">is_positive</code> and <code class="literal">is_real</code>, as shown in the following example:</p><div><pre class="programlisting">&gt;&gt;&gt; simplify(cos(x)**2 + sin(x)**2
1
&gt;&gt;&gt; simplify(cos(log(a**2))*tan(log(a**2)))
sin(2*log(a))</pre></div><p>Note that, in general, simplification is not a well-defined concept and what is considered the simplest expression depends on how it will be used subsequently. <code class="literal">simplify()</code> is a good choice for interactive exploration or when you do not know much about the expression. However, SymPy has a large array of specialized simplification functions, so when you know the structure of the expression and what kind of transformation you need, it is better to use these.</p><p>Here is a list of the most useful ones (there are more in the <code class="literal">sympy.simplify</code> module):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">radsimp()</code>: This simplifies expressions with square roots</li><li class="listitem" style="list-style-type: disc"><code class="literal">trigsimp()</code>: This simplifies combinations of trigonometric functions</li><li class="listitem" style="list-style-type: disc"><code class="literal">cancel()</code>: This clears out common factors between the numerator and the denominator of a fraction</li><li class="listitem" style="list-style-type: disc"><code class="literal">together()</code>: This puts sums of a fraction over the same denominator</li><li class="listitem" style="list-style-type: disc"><code class="literal">apart()</code>: This applies partial fraction decomposition</li></ul></div><p>The following commands show how they can be used:</p><div><pre class="programlisting">&gt;&gt;&gt; radsimp(1/(sqrt(5) – 2))
2 + sqrt(5)
&gt;&gt;&gt; trigsimp(sin(x)**2 + cos(x)**2)
1
&gt;&gt;&gt; cancel((x**2 - 1)/(x - 1))
x + 1
&gt;&gt;&gt; together(1/(x-1) - 1/(x+1))
2/((x - 1)*(x + 1))
&gt;&gt;&gt; apart(2/(x**2 - 1))
-1/(x + 1) + 1/(x - 1)</pre></div><p>Another class of transformations is provided by the <code class="literal">expand</code> family of functions. They modify expressions by making their structure simpler or by replacing "advanced" objects with more elementary ones. Their result is typically longer than their input (and sometimes very much longer). <code class="literal">expand()</code> itself subsumes all the <code class="literal">expand_*()</code> functions via a complex set of keyword flags (see its docstring for details).</p><p>Like <code class="literal">simplify()</code>, <code class="literal">expand()</code> is a good one-stop shop, but you should rather use the specialized variants when you can. Here is a selection of them, demonstrated by example:</p><div><pre class="programlisting">&gt;&gt;&gt; expand_power_base((a*b)**3)
a**3*b**3
&gt;&gt;&gt; expand_power_exp(2**(a+b))
2**a*2**b
&gt;&gt;&gt; expand_log(log(a*b**2))
log(a) + 2*log(b)
&gt;&gt;&gt; expand_complex((-1)**(S(1)/3))
1/2 + sqrt(3)*I/2
&gt;&gt;&gt; expand_trig(cos(a+b))
-sin(a)*sin(b) + cos(a)*cos(b)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Checking for mathematical equality</h3></div></div></div><p>Comparing two expressions with <code class="literal">==</code> checks whether they are structurally identical, which is a sufficient but by no means a necessary condition for mathematical equality. Note that only expressions that are printed identically may be considered equal:</p><div><pre class="programlisting">&gt;&gt;&gt; x + x == 2*x
True
&gt;&gt;&gt; x*(x+1) == x**2 + x
False</pre></div><p>To check whether two expressions are mathematically equal, you need to check whether their difference reduces to zero. To do this, apply a canonicalization function to the difference, and test whether it's equal to zero. <code class="literal">simplify()</code> is a generally useful choice for this, but <code class="literal">expand()</code> can also be used:</p><div><pre class="programlisting">&gt;&gt;&gt; simplify(x*(x+1) - (x**2 + x)) == 0
True
&gt;&gt;&gt; simplify(1/cos(x)**2 - (1 + tan(x)**2)) == 0
True</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Numerical evaluation</h2></div></div></div><p>In this section you will learn all the best ways of obtaining numerical results from your symbolic computations.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Floating-point numbers</h3></div></div></div><p>To represent floating point numbers, SymPy uses the class <code class="literal">Float</code>. The major difference between the built-in <code class="literal">float</code> and <code class="literal">sympy.Float</code> is that the latter uses arbitrary precision. This means that you can use it to obtain as many digits of precision as you want.</p><p>Floating point numbers are approximations. Symbolic calculations work best when all objects involved are known exactly. For this reason, you should avoid letting <code class="literal">Float</code> objects appear in your expressions. Instead, perform your calculations with <code class="literal">Rational</code> and other symbolic objects and convert only the final result to a numeric value. This is done with the <code class="literal">N()</code> function. It takes an optional second argument, <code class="literal">'n'</code>, specifying the number of digits of precision of the result. By default, the result has 15 digits of precision, which is roughly as much as can be encoded in a Python <code class="literal">float</code>. However, a major difference between using <code class="literal">N()</code> and floating point arithmetic is that <code class="literal">N()</code> can perform intermediate computation at a much higher precision if needed. The following example illustrates this:</p><div><pre class="programlisting">&gt;&gt;&gt; N(exp(pi*sqrt(163)))
2.62537412640769e+17
&gt;&gt;&gt; N(exp(pi*sqrt(163)), 50)
262537412640768743.99999999999925007259719818568888
&gt;&gt;&gt; q = exp(pi*sqrt(163))
&gt;&gt;&gt; N(ceiling(q) - q)
7.49927402801814e-13</pre></div><p>In the last line, note the precision of the result. It can only have been obtained by using a much higher precision internally. This shows why it's important to carry out exact computations as far as possible. Indeed, if <code class="literal">q</code> had been converted to a double-precision float (with ~15 digits of precision), it would have been impossible to extend the precision to recover a meaningful result.</p><p>You can see in the following code that converting to <code class="literal">Float</code> too early gives a wrong and even absurd result:</p><div><pre class="programlisting">&gt;&gt;&gt; r = N(exp(pi*sqrt(163)))
&gt;&gt;&gt; ceiling(r) - r
-6.00000000000000</pre></div><p>To get a numerical result out of a symbolic computation, it is best to use the <code class="literal">subs</code> option of <code class="literal">N()</code>, which accepts a substitution dictionary. Step by step, here is the process to follow:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a symbolic expression.</li><li class="listitem">Do the computation symbolically.</li><li class="listitem">Evaluate the result using <code class="literal">N()</code> with the <code class="literal">subs</code> option.</li></ol></div><p>For instance, the following commands compute the derivative of <code class="literal">f</code> at x=1.2345, where <code class="literal">f(x) = exp(x)/(x+1)</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; expr = exp(x)/(x+1)
&gt;&gt;&gt; deriv = diff(expr, x)
&gt;&gt;&gt; N(deriv, subs={x: 1.2345})
0.849702535502635</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>Compiling expressions</h3></div></div></div><p>SymPy's facilities for floating point computations are implemented in pure Python and their primary objective is precision, not speed. As a result, they are too slow for the many applications where double-precision is sufficient but many computations are required, such as plotting or numerical integration.</p><p>The solution to this problem is to convert symbolic expressions obtained with SymPy into a more efficient form for numerical evaluation. More specifically, this form will often be a function using <code class="literal">numpy</code>. To obtain it, you can use <code class="literal">lambdify()</code>. Its interface is <code class="literal">lambdify(args, expr)</code>, where <code class="literal">expr</code> is the expression you wish to convert, and <code class="literal">args</code> is a list of symbols that correspond to the arguments of the resulting Python callable, so that, for example, <code class="literal">lambdify([x, y, z], x+y)</code> is effectively equivalent to <code class="literal">lambda x, y, z: x+y</code>.</p><p>Here are the steps you should follow to evaluate an expression efficiently for a large number of parameter values:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the symbolic expression. It would usually be the result of some symbolic calculation, but in this example, we will use <code class="literal">a + x**2</code>.</li><li class="listitem">Identify all the symbols appearing in the expression. This step is often trivial (here, the symbols are obviously <code class="literal">x</code> and <code class="literal">a</code>), but nevertheless critical: if you happened to leave one symbol out, the "compiled" function would actually return a symbolic expression and be slow.</li><li class="listitem">Compile the expression using <code class="literal">lambdify()</code>. In this example, you should use <code class="literal">lambdify([x, a], a + x**2, "numpy")</code> (we will explain the meaning of the third argument in the following explanation).</li><li class="listitem">Create NumPy arrays holding the parameter values.</li><li class="listitem">Evaluate the compiled function.</li></ol></div><p>The corresponding commands are as follows:</p><div><pre class="programlisting">&gt;&gt;&gt; f = lambdify([x, a], a + x**2, "numpy")
&gt;&gt;&gt; arr = np.random.randn(1000)
&gt;&gt;&gt; result = f(arr, 0.4)
&gt;&gt;&gt; result[:3]
array([ 0.75059394,  4.68686571,  1.70330863])</pre></div><p>By default, <code class="literal">lambdify()</code> converts SymPy functions into their equivalents in either the <code class="literal">math</code> module in the standard library, <code class="literal">numpy</code>, or <code class="literal">mpmath</code>, by decreasing the order of preference. To get fast numerical evaluation, the best choice is to use only NumPy functions. For this, pass the string <code class="literal">"numpy"</code> as the third argument of <code class="literal">lambdify</code>.</p><p>You can also make <code class="literal">lambdify()</code> use any function you wish, by passing the appropriate objects as the third argument. Passing any module will fetch the functions from it, but note that functions are matched by name, so that naming differences (for example, <code class="literal">sympy.atan</code> versus <code class="literal">numpy.arctan</code>) may prevent some functions from being translated. You can also pass a dictionary directly mapping names to functions.</p><p>Preset dictionaries establishing the correct equivalences are also available for the modules <code class="literal">math</code>, <code class="literal">numpy</code>, <code class="literal">mpmath</code>, and <code class="literal">sympy</code>. To use them, pass the name of the module as a string.</p><p>Finally, it is also possible to combine these mapping specifications by putting several of them in a list. For instance, assuming you have created your own approximation for sin, and wish to fallback to NumPy for any other function, you would use the following:</p><div><pre class="programlisting">[{'sin': mysin}, "numpy"]</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Calculus</h2></div></div></div><p>Calculus is probably the most important application of SymPy. In this section, you will learn how to compute derivatives, integrals, limits, and series.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Derivatives</h3></div></div></div><p>To compute the derivative of a function, create the corresponding expression and use <code class="literal">diff()</code>. Its first argument is the expression and the second is the variable with regard to which you want to differentiate. The result is the expression for the derivative:</p><div><pre class="programlisting">&gt;&gt;&gt; diff(exp(x**2), x)
2*x*exp(x**2)
&gt;&gt;&gt; diff(x**2 * y**2, y)
2*x**2*y</pre></div><p>Higher-order derivatives can also be computed with a single call to <code class="literal">diff()</code>:</p><div><pre class="programlisting">&gt;&gt;&gt; diff(x**3, x, x)
6*x
&gt;&gt;&gt; diff(x**3, x, 2)
6*x
&gt;&gt;&gt; diff(x**2 * y**2, x, 2, y, 2)
4</pre></div><p>Due to SymPy's focus on expressions rather than functions, the derivatives for symbolic functions can seem a little surprising, but LaTeX rendering in the notebook should make their meaning clear.</p><div><pre class="programlisting">&gt;&gt;&gt; f = Function('f')
&gt;&gt;&gt; diff(f(x**2), x)
2*x*Subs(Derivative(f(_xi_1), _xi_1), (_xi_1,), (x**2,))</pre></div><p>Let's take a look at the following screenshot:</p><div><img src="img/3626OS_02_02.jpg" alt="Derivatives"/></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Limits</h3></div></div></div><p>Limits are obtained through <code class="literal">limit()</code>. The syntax for the limit of <code class="literal">expr</code> when <code class="literal">x</code> goes to some value <code class="literal">x0</code> is <code class="literal">limit(expr, x, x0)</code>. To specify a limit towards infinity, you need to use SymPy's infinity object, named <code class="literal">oo</code>. This object will also be returned for infinite limits:</p><div><pre class="programlisting">&gt;&gt;&gt; limit(exp(-x), x, oo)
0
&gt;&gt;&gt; limit(1/x**2, x, 0)
oo</pre></div><p>There is also a fourth optional parameter, to specify the direction of approach of the limit target. <code class="literal">"+"</code> (the default) gives the limit from above, and <code class="literal">"-"</code> is from below. Obviously, this parameter is ignored when the limit target is infinite:</p><div><pre class="programlisting">&gt;&gt;&gt; limit(1/x, x, 0, "-")
-oo
&gt;&gt;&gt; limit(1/x, x, 0, "+")
oo</pre></div><p>Let's take a look at the following screenshot:</p><div><img src="img/3626OS_02_03.jpg" alt="Limits"/></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Integrals</h3></div></div></div><p>SymPy has powerful algorithms for integration, and, in particular, can find most integrals of logarithmic and exponential functions expressible with special functions, and many more besides, thanks to Meijer G-functions.</p><p>The main function for integration is <code class="literal">integrate()</code>. It can compute both antiderivatives (indefinite integrals) and definite integrals. Note that the value of an antiderivative is only defined up to an arbitrary constant but the result does not include it.</p><div><pre class="programlisting">&gt;&gt;&gt; integrate(sin(x), x)
-cos(x)
&gt;&gt;&gt; integrate(sin(x), (x, 0, pi))
2</pre></div><p>Unevaluated symbolic integrals and antiderivatives are represented by the <code class="literal">Integral</code> class. <code class="literal">integrate()</code> may return these objects if it cannot compute the integral.</p><p>It is also possible to create <code class="literal">Integral</code> objects directly, using the same syntax as <code class="literal">integrate()</code>. To evaluate them, call their <code class="literal">.doit()</code> method:</p><div><pre class="programlisting">&gt;&gt;&gt; integral = Integral(sin(x), (x, 0, pi))
&gt;&gt;&gt; integral
Integral(sin(x), (x, 0, pi))
&gt;&gt;&gt; integral.doit()
2</pre></div><p>Let's take a look at the following screenshot:</p><div><img src="img/3626OS_02_04.jpg" alt="Integrals"/></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Taylor series</h3></div></div></div><p>A Taylor series approximation is an approximation of a function obtained by truncating its Taylor series. To compute it, use <code class="literal">series(expr, x, x0, n)</code>, where <code class="literal">x</code> is the relevant variable, <code class="literal">x0</code> is the point where the expansion is done (defaults to 0), and <code class="literal">n</code> is the order of expansion (defaults to 6):</p><div><pre class="programlisting">&gt;&gt;&gt; series(cos(x), x)
1 - x**2/2 + x**4/24 + O(x**6)
&gt;&gt;&gt; series(cos(x), x, n=10)
1 - x**2/2 + x**4/24 - x**6/720 + x**8/40320 + O(x**10)</pre></div><p>The <code class="literal">O(x**6)</code> part in the result is a "big-O" object. Intuitively, it represents all the terms of order equal to or higher than 6. This object automatically absorbs or combines with powers of the variable, which makes simple arithmetic operations on expansions convenient:</p><div><pre class="programlisting">&gt;&gt;&gt; O(x**2) + 2*x**3
O(x**2)
&gt;&gt;&gt; O(x**2) * 2*x**3
O(x**5)
&gt;&gt;&gt; expand(series(sin(x), x, n=6) * series(cos(x), x, n=4))
x - 2*x**3/3 + O(x**5)
&gt;&gt;&gt; series(sin(x)*cos(x), x, n=5)
x - 2*x**3/3 + O(x**5)</pre></div><p>If you want to use the expansion as an approximation of the function, the <code class="literal">O()</code> term prevents it from behaving like an ordinary expression, so you need to remove it. You can do so by using the aptly named <code class="literal">.removeO()</code> method:</p><div><pre class="programlisting">&gt;&gt;&gt; series(cos(x), x).removeO()
x**4/24 - x**2/2 + 1</pre></div><p>Taylor series look better in the notebook, as shown in the following screenshot:</p><div><img src="img/3626OS_02_05.jpg" alt="Taylor series"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Solving equations</h2></div></div></div><p>This section will teach you how to solve the different types of equations that SymPy handles.</p><p>The main function to use for solving equations is <code class="literal">solve()</code>. Its interface is somewhat complicated as it accepts many different kinds of inputs and can output results in various forms depending on the input.</p><p>In the simplest case, univariate equations, use the syntax <code class="literal">solve(expr, x)</code> to solve the equation expr = 0 for the variable <code class="literal">x</code>. If you want to solve an equation of the form A = B, simply put it under the preceding form, using <code class="literal">solve(A - B, x)</code>. This can solve algebraic and transcendental equations involving rational fractions, square roots, absolute values, exponentials, logarithms, trigonometric functions, and so on. The result is then a list of the values of the variables satisfying the equation.</p><p>The following commands show a few examples of equations that can be solved:</p><div><pre class="programlisting">&gt;&gt;&gt; solve(x**2 - 1, x)
[-1, 1]
&gt;&gt;&gt; solve(x*exp(x) - 1, x)
[LambertW(1)]
&gt;&gt;&gt; solve(abs(x**2-4) - 3, x)
[-1, 1, -sqrt(7), sqrt(7)]</pre></div><p>Note that the form of the result means that it can only return a finite set of solutions. In cases where the true solution is infinite, it can therefore be misleading. When the solution is an interval, <code class="literal">solve()</code> typically returns an empty list. For periodic functions, usually only one solution is returned:</p><div><pre class="programlisting">&gt;&gt;&gt; solve(0, x) # all x are solutions
[]
&gt;&gt;&gt; solve(x - abs(x), x) # all positive x are solutions
[]
&gt;&gt;&gt; solve(sin(x), x) # all k*pi with k integer are solutions
[0]</pre></div><p>The domain over which the equation is solved depends on the assumptions on the variable. Hence, if the variable is a real <code class="literal">Symbol</code> object, only real solutions are returned, but if it is complex, then all solutions in the complex plane are returned (subject to the aforementioned restriction on returning infinite solution sets). This difference is readily apparent when solving polynomials, as the following example demonstrates:</p><div><pre class="programlisting">&gt;&gt;&gt; solve(x**2 + 1, x)
[]
&gt;&gt;&gt; solve(z**2 + 1, z)
[-I, I]</pre></div><p>There is no restriction on the number of variables appearing in the expression. Solving a multivariate expression for any of its variables allows it to be expressed as a function of the other variables, and to eliminate it from other expressions. The following example shows different ways of solving the same multivariate expression:</p><div><pre class="programlisting">&gt;&gt;&gt; solve(x**2 - exp(a), x)
[-exp(a/2), exp(a/2)]
&gt;&gt;&gt; solve(x**2 - exp(a), a)
[log(x**2)]
&gt;&gt;&gt; solve(x**2 - exp(a), x, a)
[{x: -exp(a/2)}, {x: exp(a/2)}]
&gt;&gt;&gt; solve(x**2 - exp(a), x, b)
[{x: -exp(a/2)}, {x: exp(a/2)}]</pre></div><p>To solve a system of equations, pass a list of expressions to <code class="literal">solve()</code>: each one will be interpreted, as in the univariate case, as an equation of the form expr = 0. The result can be returned in one of two forms, depending on the mathematical structure of the input: either as a list of tuples, where each tuple contains the values for the variables in the order given to solve, or a single dictionary, suitable for use in <code class="literal">subs()</code>, mapping variables to their values.</p><p>As you can see in the following example, it can be hard to predict what form the result will take:</p><div><pre class="programlisting">&gt;&gt;&gt; solve([exp(x**2) - y, y - 3], x, y)
[(-sqrt(log(3)), 3), (sqrt(log(3)), 3)]
&gt;&gt;&gt; solve([x**2 - y, y - 3], x, y)
[(-sqrt(3), 3), (sqrt(3), 3)]
&gt;&gt;&gt; solve([x - y, y - 3], x, y)
{y: 3, x: 3}</pre></div><p>This variability in return types is fine for interactive use, but for library code, more predictability is required. In this case, you should use the <code class="literal">dict=True</code> option. The output will then always be a list of mappings of variables to value. Compare the following example to the previous one:</p><div><pre class="programlisting">&gt;&gt;&gt; solve([x**2 - y, y - 3], x, y, dict=True)
[{y: 3, x: -sqrt(3)}, {y: 3, x: sqrt(3)}]
&gt;&gt;&gt; solve([x - y, y - 3], x, y, dict=True)
[{y: 3, x: 3}]</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>People and places you should get to know</h1></div></div></div><p>If you need help with SymPy, here are some people and places which will prove invaluable.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Official sites</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Homepage: <a class="ulink" href="http://sympy.org/">http://sympy.org/</a></li><li class="listitem" style="list-style-type: disc">Manual and documentation: <a class="ulink" href="http://docs.sympy.org/">http://docs.sympy.org/</a></li><li class="listitem" style="list-style-type: disc">Wiki: <a class="ulink" href="http://wiki.sympy.org/">http://wiki.sympy.org/</a></li><li class="listitem" style="list-style-type: disc">Blog: <a class="ulink" href="http://sympy.blogspot.com/">http://sympy.blogspot.com/</a></li><li class="listitem" style="list-style-type: disc">Source code: <a class="ulink" href="https://github.com/sympy/sympy">https://github.com/sympy/sympy</a></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Articles and tutorials</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An impressive demonstration of SymPy-powered multibody dynamics by Jason Moore at <a class="ulink" href="http://www.moorepants.info/blog/npendulum.html">http://www.moorepants.info/blog/npendulum.html</a></li><li class="listitem" style="list-style-type: disc">A SymPy tutorial given at SciPy 2011 at <a class="ulink" href="http://mattpap.github.com/scipy-2011-tutorial/html/index.html">http://mattpap.github.com/scipy-2011-tutorial/html/index.html</a></li><li class="listitem" style="list-style-type: disc">SymPy's tutorial, straight from the official documentation at <a class="ulink" href="http://docs.sympy.org/0.7.2/tutorial.html">http://docs.sympy.org/0.7.2/tutorial.html</a></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Community</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Official mailing list at <code class="email">&lt;<a class="email" href="mailto:sympy@googlegroups.com">sympy@googlegroups.com</a>&gt;</code></li><li class="listitem" style="list-style-type: disc">Web interface to the mailing list at <a class="ulink" href="https://groups.google.com/forum/?fromgroups#!forum/sympy">https://groups.google.com/forum/?fromgroups#!forum/sympy</a></li><li class="listitem" style="list-style-type: disc">Official IRC channel: <code class="literal">#sympy on freenode</code></li><li class="listitem" style="list-style-type: disc">User FAQ at <a class="ulink" href="https://github.com/sympy/sympy/wiki/Faq">https://github.com/sympy/sympy/wiki/Faq</a></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Blogs</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Official blog aggregator for the whole community: <a class="ulink" href="http://planet.sympy.org/">http://planet.sympy.org/</a></li><li class="listitem" style="list-style-type: disc">The blog of Aaron Meurer, SymPy's project leader: <a class="ulink" href="http://asmeurersympy.wordpress.com/">http://asmeurersympy.wordpress.com/</a></li><li class="listitem" style="list-style-type: disc">Matthew Rocklin blogs on statistics and linear algebra in SymPy at <a class="ulink" href="http://matthewrocklin.com/blog/">http://matthewrocklin.com/blog/</a></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Twitter</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more open source information, follow Packt at <a class="ulink" href="http://twitter.com/#!/packtopensource">http://twitter.com/#!/packtopensource</a></li></ul></div></div></div></body></html>