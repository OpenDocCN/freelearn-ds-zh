<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Classes</h1></div></div></div><p>In mathematics, when we write sin, we refer to a mathematical object for which we know many methods from elementary calculus. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We might want to evaluate sin<span class="emphasis"><em> x</em></span> at <span class="emphasis"><em>x=</em></span>0.5, that is, compute sin(0.5), which returns a real number</li><li class="listitem" style="list-style-type: disc">We might want to compute its derivative, which gives us another mathematical object, cos</li><li class="listitem" style="list-style-type: disc">We might want to compute the first three coefficients of its Taylor polynomial</li></ul></div><p>These methods may be applied not only to sin but also to other sufficiently smooth functions. There are, however, other mathematical objects (for example, the number <span class="emphasis"><em>5</em></span>) for which these methods make no sense. Objects that have the same methods are grouped together in abstract classes, for example, functions. Every statement and every method that can be applied to functions applies in particular to sin or cos. Other examples for such classes might be a rational number, for which a denominator and numerator method exist; an interval, which has a left and right boundary method; an infinite sequence, for which we can ask whether it has a limit, and so on.</p><p>In this case, sin is called an instance of the class. The mathematical phrase <span class="emphasis"><em>Let g be a function...</em></span> is, in this context, called instantiation. Here, <span class="emphasis"><em>g</em></span> is the name of the function; one of many attributes that can be assigned to it. Another attribute might be its domain.</p><p>The mathematical object <span class="emphasis"><em>p(x) = 2x<sup>2</sup>- 5</em></span> is just like the sine function. Every function method applies to <span class="emphasis"><em>p</em></span>, but we can also define special methods for <span class="emphasis"><em>p</em></span>. We might, for instance, ask for <span class="emphasis"><em>p</em></span>’s coefficients. These methods can be used to define the class of polynomials. As polynomials are functions, they additionally inherit all methods of the function class.</p><p>In mathematics, we often use the same operator symbol for completely different operations. For instance, in  5+4 and sin<span class="emphasis"><em> + </em></span>cos, the operator symbol + has different meanings. By using the same symbol, one tries to express the similarities of mathematical operations. We have introduced these terms from object-oriented programming by applying them to mathematical examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Classes</li><li class="listitem" style="list-style-type: disc">Instance and instantiation</li><li class="listitem" style="list-style-type: disc">Inheritance</li><li class="listitem" style="list-style-type: disc">Methods</li><li class="listitem" style="list-style-type: disc">Attributes</li><li class="listitem" style="list-style-type: disc">Operator overloading</li></ul></div><p>In this chapter, we will show how these concepts are used in Python.</p><div class="section" title="Introduction to classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Introduction to classes</h1></div></div></div><p>We will illustrate the concept of classes with an example of rational numbers, that is, numbers of the form <span class="emphasis"><em>q= q</em></span><sub>N </sub><span class="emphasis"><em>⁄ q</em></span><sub>D</sub>, where <span class="emphasis"><em>q</em></span><sub>N</sub> and <span class="emphasis"><em>q</em></span><sub>D</sub> are integers.</p><p>
</p><div class="mediaobject"><img src="graphics/class_anatomy-2.jpg" alt="Introduction to classes"/></div><p>
</p><p>Figure 8.1: An example of a class declaration</p><p>We use rational numbers here only as an example for the class concept. For future work in Python with rational numbers use the <span class="emphasis"><em>fractions</em></span> module (refer to <a class="link" href="apa.html" title="Appendix . References">[6]</a>).</p><div class="section" title="Class syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Class syntax</h2></div></div></div><p>The definition of a class is made by a block command with the <code class="literal">class</code> keyword, the name of the class, and some statements in the block (refer to <span class="emphasis"><em>Figure 8.1</em></span>):</p><pre class="programlisting">class RationalNumber: &#13;
      pass</pre><p>An instance of this class (or in other words, an object of the type <code class="literal">RationalNumber</code>) is created by</p><pre class="programlisting">r = RationalNumber()</pre><p>and a query <code class="literal">type(a)</code> returns the answer,  <code class="literal">&lt;class'__main__.RationalNumber'&gt;</code>. If we want to investigate whether an object is an instance of this class, we can use this:</p><pre class="programlisting">if isinstance(a, RationalNumber):&#13;
    print('Indeed it belongs to the class RationalNumber')  </pre><p>So far we've generated an object of the <code class="literal">RationalNumber</code> type, which has no data yet. Furthermore, there are no methods defined to perform operations with these objects. This will be the subject of the next sections.</p></div><div class="section" title="The __init__ method"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec89"/>The __init__ method</h2></div></div></div><p>Now we provide our example class with some attributes; that is, we give it defining data. In our case, this data will be the values of the denominator and the numerator. To this end, we have to define a method, <code class="literal">__init__</code>, used to initialize the class with these values:</p><pre class="programlisting">class RationalNumber:&#13;
    def __init__(self, numerator, denominator):&#13;
        self.numerator = numerator&#13;
        self.denominator = denominator</pre><p>Before we explain the special <code class="literal">__init__</code> function, which we added to the class, we demonstrate the instantiation of a <code class="literal">RationalNumber</code> object:</p><pre class="programlisting">q = RationalNumber(10, 20)    # Defines a new object&#13;
q.numerator    # returns 10&#13;
q.denominator    # returns 20</pre><p>A new object of type <code class="literal">RationalNumber</code> is created by using the class name as if it was a function. This statement does two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It first creates an empty object, <code class="literal">q</code>.</li><li class="listitem" style="list-style-type: disc">Then it applies the <code class="literal">__init__</code> function to it; that is, <code class="literal">q.__init__(10, 20)</code> is executed.</li></ul></div><p>The first parameter of <code class="literal">__init__</code> refers to the new object itself. On function call, this first parameter is replaced by the object’s instance. This applies to all methods of the class and not only to the special method <code class="literal">__init__</code>. The special role of this first parameter is reflected by the convention to name it <code class="literal">self</code>. In the  previous example, the <code class="literal">__init__</code> function defines two attributes of the new object, <code class="literal">numerator</code> and <code class="literal">denominator</code>.</p></div></div></div>
<div class="section" title="Attributes and methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Attributes and methods</h1></div></div></div><p>One of the main reasons for working with classes is that objects can be grouped together and bound to a common object. We saw this already when looking at rational numbers; denominator and numerator are two objects which we bound to an instance of the <code class="literal">RationalNumber</code> class. They are called attributes of the instance. The fact that an object is an attribute of a class instance becomes apparent from the way they are referenced, which we have used tacitly before:</p><pre class="programlisting">&lt;object&gt;.attribute</pre><p>Here are some examples of instantiation and attribute reference:</p><pre class="programlisting">q = RationalNumber(3, 5) # instantiation&#13;
q.numerator     # attribute access&#13;
q.denominator&#13;
&#13;
a = array([1, 2])    # instantiation&#13;
a.shape&#13;
&#13;
z = 5 + 4j    # instantiation&#13;
z.imag</pre><p>Once an instance is defined we can set, change or delete attributes of that particular instance. The syntax is the same as for regular variables:</p><pre class="programlisting">q = RationalNumber(3, 5) &#13;
r = RationalNumber(7, 3)&#13;
q.numerator = 17&#13;
del r.denominator</pre><p>Changing or deleting an attribute may have undesired side effects, which might even render the object useless. We will be learning more on this in the section <span class="emphasis"><em>Attributes that depend on each other</em></span>. As functions are objects too, we can also use functions as attributes; they are called methods of the instance:</p><pre class="programlisting">&lt;object&gt;.method(&lt;arguments...&gt;)</pre><p>For example, let us add a method to the class <code class="literal">RationalNumber</code> that converts the number to a float:</p><pre class="programlisting">class RationalNumber:&#13;
...&#13;
    def convert2float(self):&#13;
        return float(self.numerator) / float(self.denominator)</pre><p>Again, this method takes as its first (and only) argument, <code class="literal">self</code>, the reference to the object itself. We use this method with a regular function call:</p><pre class="programlisting">q = RationalNumber(10, 20)    # Defines a new object&#13;
q.convert2float() # returns 0.5   </pre><p>This is equivalent to the following call:</p><pre class="programlisting">RationalNumber.convert2float(q)</pre><p>Note again that the object instance is inserted as the first argument of the function. This use of the first argument explains the error message that would occur if this particular method were used with additional arguments:</p><p>The <code class="literal">q.convert2float(15)</code> call provokes this error message:</p><pre class="programlisting">TypeError: convert2float() takes exactly 1 argument (2 given)</pre><p>The reason this does not work is that <code class="literal">q.convert2float(15)</code> is precisely equivalent to <code class="literal">RationalNumber.convert2float(q,15)</code>, which fails because <code class="literal">RationalNumber.convert2float</code> takes only one argument.</p><div class="section" title="Special methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec90"/>Special methods</h2></div></div></div><p>The special method <code class="literal">__repr__</code>  gives us the ability to define the way the object is represented in a Python interpreter. For rational numbers, a possible definition of this method could be as follows:</p><pre class="programlisting">class RationalNumber:&#13;
 ...&#13;
    def __repr__(self):&#13;
        return '{} / {}'.format(self.numerator,self.denominator)</pre><p>With this method defined, just typing <code class="literal">q</code> returns 10 / 20.</p><p>We would like to have a method that performs addition of two rational numbers. A first attempt could result in a method like this:</p><pre class="programlisting">class RationalNumber:&#13;
...&#13;
    def add(self, other):&#13;
        p1, q1 = self.numerator, self.denominator&#13;
        if isinstance(other, int):&#13;
            p2, q2 = other, 1&#13;
        else:&#13;
            p2, q2 = other.numerator, other.denominator&#13;
        return RationalNumber(p1 * q2 + p2 * q1, q1 * q2)</pre><p>A call to this method takes the following form:</p><pre class="programlisting">q = RationalNumber(1, 2)&#13;
p = RationalNumber(1, 3)&#13;
q.add(p)   # returns the RationalNumber for 5/6</pre><p>It would be much nicer if we could write <code class="literal">q + p</code> instead. But so far, the plus sign is not defined for the <code class="literal">RationalNumber</code> type. This is done by using the <code class="literal">__add__</code> special method. So, just renaming <code class="literal">add</code> to <code class="literal">__add__</code> allows for using the plus sign for rational numbers:</p><pre class="programlisting">q = RationalNumber(1, 2)&#13;
p = RationalNumber(1, 3)&#13;
q + p # RationalNumber(5, 6)</pre><p>The expression <code class="literal">q + p</code> is in fact an alias for the expression <code class="literal">q.__add__(p)</code>. In the table (<span class="emphasis"><em>Table 8.1)</em></span>, you will find the special methods for binary operators, such as <code class="literal">+</code>, <code class="literal">-</code>, or <code class="literal">*</code>.</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p>
</p><p>
<span class="strong"><strong>Operator</strong></span>
</p><p>
</p>
</td><td>
<p>
<span class="strong"><strong>Method</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Operator</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Method</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">+</code>
</p>
</td><td>
<p>
<code class="literal">__add__</code>
</p>
</td><td>
<p>
<code class="literal">+=</code>
</p>
</td><td>
<p>
<code class="literal">__iadd__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">*</code>
</p>
</td><td>
<p>
<code class="literal">__mul__</code>
</p>
</td><td>
<p>
<code class="literal">*=</code>
</p>
</td><td>
<p>
<code class="literal">__imul__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">-</code>
</p>
</td><td>
<p>
<code class="literal">__sub__</code>
</p>
</td><td>
<p>
<code class="literal">-=</code>
</p>
</td><td>
<p>
<code class="literal">__isub__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">/</code>
</p>
</td><td>
<p>
<code class="literal">__truediv__</code>
</p>
</td><td>
<p>
<code class="literal">/=</code>
</p>
</td><td>
<p>
<code class="literal">__itruediv__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">//</code>
</p>
</td><td>
<p>
<code class="literal">__floordiv__</code>
</p>
</td><td>
<p>
<code class="literal">//=</code>
</p>
</td><td>
<p>
<code class="literal">__ifloordiv__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">**</code>
</p>
</td><td>
<p>
<code class="literal">__pow__</code>
</p>
</td><td>
</td><td>
</td></tr><tr><td>
<p>
<code class="literal">==</code>
</p>
</td><td>
<p>
</p><p>
<code class="literal">__eq__</code>
</p><p>
</p>
</td><td>
<p>
<code class="literal">!=</code>
</p>
</td><td>
<p>
<code class="literal">__ne__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">&lt;=</code>
</p>
</td><td>
<p>
<code class="literal">__le__</code>
</p>
</td><td>
<p>
<code class="literal">&lt;</code>
</p>
</td><td>
<p>
<code class="literal">__lt__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">&gt;=</code>
</p>
</td><td>
<p>
<code class="literal">__ge__</code>
</p>
</td><td>
<p>
<code class="literal">&gt;</code>
</p>
</td><td>
<p>
<code class="literal">__gt__</code>
</p>
</td></tr><tr><td>
<p>
<code class="literal">()</code>
</p>
</td><td>
<p>
<code class="literal">__call__</code>
</p>
</td><td>
<p>
<code class="literal">[]</code>
</p>
</td><td>
<p>
<code class="literal">__getitem__</code>
</p>
</td></tr></tbody></table></div><p>Table 8.1: Some Python operators &amp; corresponding class methods, you can find the complete list <a class="link" href="apa.html" title="Appendix . References">[31]</a></p><p>The implementation of those operators for a new class is called operator overloading. Another example of operator overloading is a method for examining whether two rational numbers are the same:</p><pre class="programlisting">class RationalNumber:&#13;
...&#13;
    def __eq__(self, other):&#13;
        return self.denominator * other.numerator == &#13;
            self.numerator * other.denominator</pre><p>It is used like this:</p><pre class="programlisting">p = RationalNumber(1, 2) # instantiation&#13;
q = RationalNumber(2, 4) # instantiation&#13;
p == q # True</pre><p>Operations between objects belonging to different classes need special care:</p><pre class="programlisting">p = RationalNumber(1, 2) # instantiation&#13;
p + 5  # corresponds to p.__add__(5)  &#13;
5 + p  # returns an error</pre><p>By default, the <code class="literal">+</code> operator invokes the left operand’s method, <code class="literal">__add__</code>. We programmed it so that it allows both, objects of type <code class="literal">int</code> and objects of type <code class="literal">RationalNumber</code>. In the statement <code class="literal">5 + p</code>, the operands are commuted and the <code class="literal">__add__</code> method of the build-in <code class="literal">int</code> type is invoked. This method returns an error as it does not know how to handle rational numbers. This case can be handled by the method <code class="literal">__radd__</code>, with which we will equip the <code class="literal">RationalNumber</code> class now. The method <code class="literal">__radd__</code> is called reverse addition.</p><div class="section" title="Reverse operations"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl4sec8"/>Reverse operations</h3></div></div></div><p>If operations like <code class="literal">+</code> are applied to two operands of different types, the corresponding method (in this case, <code class="literal">__add__</code>) of the left operand is invoked first. If this raises an exception, the reverse method (here, <code class="literal">__radd__</code>) of the right operand is called. If this method does not exist, a <code class="literal">TypeError</code> exception is raised.</p><p>Consider an example of reverse operation. In order to enable the operation 5+<span class="emphasis"><em>p</em></span> where <span class="emphasis"><em>p</em></span> is an instance of <code class="literal">RationalNumber</code>, we define this:</p><pre class="programlisting">class RationalNumber:&#13;
   ....&#13;
    def __radd__(self, other):&#13;
        return self + other</pre><p>Note that <code class="literal">__radd__</code> interchanges the order of the arguments; <code class="literal">self</code> is the object of type <code class="literal">RationalNumber</code> while other is the object that has to be converted.</p><p>Using a class instance together with brackets<span class="emphasis"><em>,</em></span> ( <span class="emphasis"><em>, </em></span>) or [ , ] invokes a call to one of the special methods <code class="literal">__call__</code> or <code class="literal">__getitem__</code>, giving the instance the behavior of a function or of an iterable (refer to the T<span class="emphasis"><em>able 8.1</em></span> for these and other special methods):</p><pre class="programlisting">class Polynomial:&#13;
...&#13;
    def __call__(self, x):&#13;
        return self.eval(x)</pre><p>Which now may be used as follows:</p><pre class="programlisting">p = Polynomial(...)&#13;
p(3.) # value of p at 3.</pre><p>The <code class="literal">__getitem__</code> special method makes sense if the class provides an iterator (It is recommended to refer section <span class="emphasis"><em>Iterators</em></span> in <a class="link" href="ch09.html" title="Chapter 9. Iterating">Chapter 9</a>, <span class="emphasis"><em>Iterating</em></span> before you consider the following example).</p><p>The recursion <span class="emphasis"><em>u<sub>i+1</sub> = a</em></span><sub>1</sub><span class="emphasis"><em>u<sub>i</sub></em></span>+<span class="emphasis"><em> a</em></span><sub>0</sub><span class="emphasis"><em>u<sub>i</sub></em></span><sub>-1</sub>is called a three<span class="emphasis"><em>-</em></span>term recursion. It plays an important role in applied mathematics, in particular in the construction of orthogonal polynomials. We can set up a three-term recursion as a class in the following way:</p><pre class="programlisting">import itertools&#13;
&#13;
class  Recursion3Term:&#13;
    def __init__(self, a0, a1, u0, u1):&#13;
        self.coeff = [a1, a0]&#13;
        self.initial = [u1, u0]&#13;
    def __iter__(self):&#13;
        u1, u0 = self.initial&#13;
        yield u0  # (see also Iterators section in Chapter 9) &#13;
        yield u1&#13;
        a1, a0 = self.coeff&#13;
        while True :&#13;
            u1, u0 = a1 * u1 + a0 * u0, u1&#13;
            yield u1&#13;
    def __getitem__(self, k):&#13;
        return list(itertools.islice(self, k, k + 1))[0]</pre><p>Here, the <code class="literal">__iter__</code> method defines a generator object, which allows us to use an instance of the class as an iterator:</p><pre class="programlisting">r3 = Recursion3Term(-0.35, 1.2, 1, 1)&#13;
for i, r in enumerate(r3):&#13;
    if i == 7:&#13;
        print(r)  # returns 0.194167&#13;
        break</pre><p>The <code class="literal">__getitem__</code> method enables us to directly access the iterates as if <code class="literal">r3</code> were a list:</p><pre class="programlisting">r3[7] # returns 0.194167</pre><p>Note that we used <code class="literal">itertools.islice</code> when coding the <code class="literal">__getitem__</code> method (refer to section <span class="emphasis"><em>Iterators </em></span>of <a class="link" href="ch09.html" title="Chapter 9. Iterating">Chapter 9</a>, <span class="emphasis"><em>Iterating</em></span>, for more information). An example of the use of <code class="literal">__getitem__</code> together with slices and the function <code class="literal">ogrid</code> is given in the section <span class="emphasis"><em>Function with two variables</em></span> in <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <span class="emphasis"><em>Advance Array Concepts</em></span>.</p></div></div></div>
<div class="section" title="Attributes that depend on each other"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl2sec91"/>Attributes that depend on each other</h1></div></div></div><p>Attributes of an instance can be changed (or created) by simply assigning them a value. However, if other attributes depend on the one just changed, it is desirable to change these simultaneously:</p><p>Let us consider a class that defines an object for planar triangles from three given points. A first attempt to set up such a class could be as follows:</p><pre class="programlisting">class Triangle:&#13;
    def __init__(self,  A, B, C):&#13;
        self.A = array(A)&#13;
        self.B = array(B)&#13;
        self.C = array(C)&#13;
        self.a = self.C - self.B&#13;
        self.b = self.C - self.A&#13;
        self.c = self.B - self.A&#13;
    def area(self):&#13;
        return abs(cross(self.b, self.c)) / 2</pre><p>An instance of this triangle is created by this:</p><pre class="programlisting">tr = Triangle([0., 0.], [1., 0.], [0., 1.])</pre><p>And its area is computed by this:</p><pre class="programlisting">tr.area() # returns 0.5</pre><p>If we change an attribute, say point <span class="emphasis"><em>B</em></span>, the corresponding edges <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>c</em></span> are not automatically updated and the computed area is wrong:</p><pre class="programlisting">tr.B = [12., 0.]&#13;
tr.area() # still returns 0.5, should be 6 instead.</pre><p>A remedy is to define a method that is executed when an attribute is changed; such a method is called a setter method. Correspondingly, one might ask for a method that is executed when a value of an attribute is requested; such a method is called a getter method.</p><div class="section" title="The property function"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl3sec26"/>The property function</h2></div></div></div><p>The function <code class="literal">property</code>  links an attribute to such a getter, setter, and deleter method. It might also be used to assign a documentation string to an attribute:</p><pre class="programlisting">attribute = property(fget = get_attr, fset = set_attr, &#13;
                     fdel = del_attr, doc = string)</pre><p>We continue with the previous example with a setter method and consider the <code class="literal">Trinagle</code> class again. If the following statement is included in <code class="literal">Triangle</code>
</p><pre class="programlisting">B = property(fget = get_B, fset = set_B, fdel = del_B, doc = ’The point B of a triangle’)</pre><p>a command</p><pre class="programlisting">tr.B = &lt;something&gt;</pre><p>invokes the setter method, <code class="literal">set_B</code>.</p><p>Let us modify the Triangle class:</p><pre class="programlisting">class Triangle:&#13;
    def __init__(self, A, B, C):&#13;
        self._A = array(A)&#13;
        self._B = array(B)&#13;
        self._C = array(C)&#13;
        self._a = self._C - self._B&#13;
        self._b = self._C - self._A&#13;
        self._c = self._B - self._A&#13;
    def area(self):&#13;
        return abs(cross(self._c, self._b)) / 2.&#13;
    def set_B(self, B):&#13;
        self._B = B&#13;
        self._a = self._C - self._B&#13;
        self._c = self._B - self._A&#13;
    def get_B(self):&#13;
        return self._B&#13;
    def del_Pt(self):&#13;
        raise Exception('A triangle point cannot be deleted')&#13;
    B = property(fget = get_B, fset = set_B, fdel = del_Pt)</pre><p>If the attribute <code class="literal">B</code> is changed, then the method <code class="literal">set_B</code> stores the new value in the internal attribute <code class="literal">_B</code> and changes all depending attributes:</p><pre class="programlisting">tr.B = [12., 0.]&#13;
tr.area() # returns 6.0</pre><p>The way the <code class="literal">deleter</code> method is used here is to prevent deletion of attributes:</p><pre class="programlisting">del tr.B # raises an exception</pre><p>The use of an underscore as a prefix of attribute names is a convention used to indicate attributes that are not designed to be accessed directly. They are intended to hold data for attributes handled by setters and getters. These attributes are not private in the sense of other programming languages; they are just not intended to be accessed directly.</p></div></div>
<div class="section" title="Bound and unbound methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl2sec92"/>Bound and unbound methods</h1></div></div></div><p>We will now take a closer look at attributes that are methods. Let us consider an example:</p><pre class="programlisting">class A:&#13;
    def func(self,arg):&#13;
        pass</pre><p>A little inspection shows us how the nature of <code class="literal">func</code> changes after creating an instance:</p><pre class="programlisting">A.func  # &lt;unbound method A.func&gt;&#13;
instA = A()  # we create an instance&#13;
instA.func  #  &lt;bound method A.func of ... &gt;</pre><p>Calling, for example,  <code class="literal">A.func(3)</code> would result in an error message such as this:</p><pre class="programlisting">TypeError: func() missing 1 required positional argument: 'arg'</pre><p>
<code class="literal">instA.func(3)</code> is executed as expected. Upon creation of an instance, the <code class="literal">func</code> method is bound to the instance. The <code class="literal">self</code> argument gets the instance assigned as its value. Binding a method to an instance makes the method usable as a function. Before that, it is of no use. Class methods, which we will consider later, are different in this aspect.</p></div>
<div class="section" title="Class attributes"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl2sec93"/>Class attributes</h1></div></div></div><p>Attributes specified in the class declaration are called class attributes. Consider the following example:</p><pre class="programlisting">class Newton:&#13;
    tol = 1e-8 # this is a class attribute&#13;
    def __init__(self,f):&#13;
        self.f = f # this is not a class attribute&#13;
    ....</pre><p>Class attributes are useful for simulating default values and can be used if values have to be reset:</p><pre class="programlisting">N1 = Newton(f)&#13;
N2 = Newton(g)</pre><p>Both instances have an attribute, <code class="literal">tol</code>, with the value initialized in the class definition:</p><pre class="programlisting">N1.tol # 1e-8&#13;
N2.tol # 1e-8</pre><p>Altering the class attribute automatically affects all the corresponding attributes of all instances:</p><pre class="programlisting">Newton.tol = 1e-10&#13;
N1.tol # 1e-10&#13;
N2.tol # 1e-10</pre><p>Altering <code class="literal">tol</code> for one instance does not affect the other instance:</p><pre class="programlisting">N2.tol = 1.e-4&#13;
N1.tol  # still 1.e-10</pre><p>But now <code class="literal">N2.tol</code> is detached from the class attribute. Changing <code class="literal">Newton.tol</code> no longer has any effect on <code class="literal">N2.tol</code>:</p><pre class="programlisting">Newton.tol = 1e-5 # now all instances of the Newton classes have 1e-5&#13;
N1.tol # 1.e-5&#13;
N2.tol # 1e-4 but not N2.</pre></div>
<div class="section" title="Class methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl2sec94"/>Class methods</h1></div></div></div><p>We saw in the previous section on <span class="emphasis"><em>Bound and unbound methods</em></span> how methods are either bound to an instance of a class or remain in a state as unbound methods. Class methods are different. They are always bound methods. They are bound to the class itself.</p><p>We will first describe the syntactic details and then give some examples to show what these methods can be used for. To indicate that a method is a class method the decorator line precedes the method definition:</p><pre class="programlisting">@classmethod</pre><p>While standard methods make a reference to an instance by the use of their first argument, the first argument of a class method refers to the class itself. By convention the first argument is called <code class="literal">self</code> for standard methods and <code class="literal">cls</code> for class methods.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Standard case:</li></ul></div><pre class="programlisting">      class A:&#13;
          def func(self,*args):&#13;
               &lt;...&gt;</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Class method case:</li></ul></div><pre class="programlisting">      class B:&#13;
          @classmethod&#13;
          def func(cls,*args):&#13;
               &lt;...&gt;</pre><p>In practice, class methods may be useful for executing commands before an instance is created, for instance, in a preprocessing step. See the following example:</p><p>In this example we show how class methods can be used to prepare data before creating an instance:</p><pre class="programlisting">class Polynomial:&#13;
    def __init__(self, coeff):&#13;
        self.coeff = array(coeff)&#13;
    @classmethod&#13;
    def by_points(cls, x, y):&#13;
        degree = x.shape[0] - 1&#13;
        coeff = polyfit(x, y, degree)&#13;
        return cls(coeff) &#13;
    def __eq__(self, other):&#13;
        return allclose(self.coeff, other.coeff)</pre><p>The class is designed so, that a polynomial object is created by specifying its coefficients. Alternatively, the <code class="literal">by_points</code> class method allows us to define a polynomial by interpolation points. We can transform the interpolation data to the polynomial coefficients even when no instance of Polynomial is available:</p><pre class="programlisting">p1 = Polynomial.by_points(array([0., 1.]), array([0., 1.]))&#13;
p2 = Polynomial([1., 0.])&#13;
&#13;
print(p1 == p2)  # prints True</pre><p>Another example of a class method is presented in an example later in this chapter. In that example, a class method is used to access information related to several (or all) instances from this class.</p></div>
<div class="section" title="Subclassing and inheritance"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Subclassing and inheritance</h1></div></div></div><p>In this section, we will introduce some central concepts from object-oriented programming: abstract classes, subclasses, and inheritance. To guide you through these concepts, we consider another mathematical example: one-step methods for solving a differential equation. The generic form of an ordinary initial value problem is</p><p>
</p><div class="mediaobject"><img src="graphics/ode.jpg" alt="Subclassing and inheritance"/></div><p>
</p><p>The data is the right-hand side function <span class="emphasis"><em>f</em></span>, the initial value <span class="emphasis"><em>x<sub>0</sub></em></span>, and the interval of interest [<span class="emphasis"><em>t</em></span><sub>0</sub><span class="emphasis"><em>, t</em></span><sub>e</sub>]. The solution of this problem is a function <span class="inlinemediaobject"><img src="graphics/realvaluedfunction.jpg" alt="Subclassing and inheritance"/></span>. A numerical algorithm gives this solution as a vector <span class="emphasis"><em>u</em></span> of discrete values <span class="emphasis"><em>u<sub>i</sub></em></span> being approximations to <span class="emphasis"><em>x</em></span>(<span class="emphasis"><em>t<sub>i</sub></em></span>). Here, <span class="inlinemediaobject"><img src="graphics/B05511_08_02.jpg" alt="Subclassing and inheritance"/></span>are discretized values of the independent variable<span class="emphasis"><em> t</em></span>, which in physical models often represents time.</p><p>A one-step method constructs the solution values <span class="emphasis"><em>u<sub>i</sub></em></span> by the recursion steps:</p><p>
</p><div class="mediaobject"><img src="graphics/onestep.jpg" alt="Subclassing and inheritance"/></div><p>
</p><p>Here, Φ is a step function that characterizes the individual methods (refer to <a class="link" href="apa.html" title="Appendix . References">[28]</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Explicit Euler</strong></span>:   <span class="inlinemediaobject"><img src="graphics/B05511_08_03.jpg" alt="Subclassing and inheritance"/></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Midpoint Rule</strong></span>:   <span class="inlinemediaobject"><img src="graphics/B05511_08_04.jpg" alt="Subclassing and inheritance"/></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Runge–Kutta 4</strong></span>:  <span class="inlinemediaobject"><img src="graphics/B05511_08_05.jpg" alt="Subclassing and inheritance"/></span> with  <span class="inlinemediaobject"><img src="graphics/B05511_08_06.jpg" alt="Subclassing and inheritance"/></span></li></ul></div><p>What we did here is the typical way of describing a mathematical algorithm. We first described a method by its idea, giving its steps in an abstract way. To actually use it, we have to fill in the parameters of a concrete method, in this example, the function Φ. This is also the way things are explained in object-oriented programming. First, we set up a class with the abstract description of the method:</p><pre class="programlisting">class OneStepMethod:&#13;
    def __init__(self, f, x0, interval, N):&#13;
        self.f = f&#13;
        self.x0 = x0&#13;
        self.interval = [t0, te] = interval&#13;
        self.grid = linspace(t0, te, N)&#13;
        self.h = (te - t0) / N&#13;
&#13;
    def generate(self):&#13;
        ti, ui = self.grid[0], self.x0&#13;
        yield ti, ui&#13;
        for t in self.grid[1:]:&#13;
            ui = ui + self.h * self.step(self.f, ui, ti)&#13;
            ti = t&#13;
            yield ti, ui&#13;
&#13;
    def solve(self):&#13;
        self.solution = array(list(self.generate()))&#13;
&#13;
    def plot(self):&#13;
        plot(self.solution[:, 0], self.solution[:, 1])&#13;
&#13;
    def step(self, f, u, t):&#13;
        raise NotImplementedError()</pre><p>This abstract class, with its methods, is used as a template for the individual methods:</p><pre class="programlisting">class ExplicitEuler(OneStepMethod):&#13;
    def step(self, f, u, t):&#13;
        return f(u, t)&#13;
&#13;
class MidPointRule(OneStepMethod):&#13;
    def step(self, f, u, t):&#13;
        return f(u + self.h / 2 * f(u, t), t + self.h / 2)</pre><p>Note that in the class definitions, the name of the abstract class that we used as a template,  <code class="literal">OneStepMethod</code>, is given as an extra argument:</p><pre class="programlisting">class ExplicitEuler(OneStepMethod)</pre><p>That class is called the parent class. All methods and attributes of the parent class are inherited by the subclasses as long as they are not overridden. They are overridden if they are redefined in the subclass. The <code class="literal">step</code> method is redefined in the subclasses, while the method <code class="literal">generate</code> is generic for the entire family and therefore inherited from the parent. Before considering further details, we will demonstrate how these three classes can be used:</p><pre class="programlisting">def f(x, t):&#13;
    return -0.5 * x&#13;
&#13;
euler = ExplicitEuler(f, 15., [0., 10.], 20)&#13;
euler.solve()&#13;
euler.plot()&#13;
hold(True)&#13;
midpoint = MidPointRule(f, 15., [0., 10.], 20)&#13;
&#13;
midpoint.solve()&#13;
midpoint.plot()</pre><p>You can avoid the repetition of common parameter lists by using the star operator (refer to section <span class="emphasis"><em>Variable Number of Argument</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions </em></span>for more details):</p><pre class="programlisting">...&#13;
argument_list = [f, 15., [0., 10.], 20]&#13;
euler = ExplicitEuler(*argument_list)&#13;
...&#13;
midpoint = MidPointRule(*argument_list)&#13;
...</pre><p>Note that the abstract class has never been used to create an instance. As the <code class="literal">step</code> method was not completely defined, calling it raises an exception of type <code class="literal">NotImplementedError</code>.</p><p>Sometimes one has to access the methods or attributes of a parent class. This is done using the command <code class="literal">super</code>. This is useful when the child class uses its own <code class="literal">__init__</code> method in order to extend the parent’s <code class="literal">__init__</code>:</p><p>For example let us assume that we want to give every solver class a string variable with the solver’s name. To this end, we provide the solver with an <code class="literal">__init__</code> method as it overrides the parent’s <code class="literal">__init__</code> method. In the case that both methods should be used, we have to refer to the parent’s method by the command <code class="literal">super</code>:</p><pre class="programlisting">class ExplicitEuler(OneStepMethod):&#13;
    def __init__(self,*args, **kwargs):&#13;
        self.name='Explicit Euler Method'&#13;
        super(ExplicitEuler, self).__init__(*args,**kwargs)&#13;
    def step(self, f, u, t):&#13;
        return f(u, t)</pre><p>Note that one could use the name of the parent class explicitly. The use of <code class="literal">super</code> instead allows us to change the name of the parent class without having to change all the references to the parent class.</p></div>
<div class="section" title="Encapsulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Encapsulation</h1></div></div></div><p>Sometimes the use of inheritance is impractical or even impossible. This motivates the use of encapsulation. We will explain the concept of encapsulation by considering Python functions, that is, objects of the Python type <code class="literal">function</code>, which we encapsulate in a new class, <code class="literal">Function</code>, and provide with some relevant methods:</p><pre class="programlisting">class Function:&#13;
    def __init__(self, f):&#13;
        self.f = f&#13;
    def __call__(self, x):&#13;
        return self.f(x)&#13;
    def __add__(self, g):&#13;
        def sum(x):&#13;
            return self(x) + g(x)&#13;
        return type(self)(sum) &#13;
    def __mul__(self, g): &#13;
        def prod(x):&#13;
            return self.f(x) * g(x)&#13;
        return type(self)(prod)&#13;
    def __radd__(self, g):&#13;
        return self + g&#13;
    def __rmul__(self, g):&#13;
        return self * g</pre><p>Note that the <code class="literal">__add__</code> and <code class="literal">__mul__</code> operations should return an instance of the same class. This is achieved by the <code class="literal">return type(self)(sum)</code> statement, which in this case is a more general form of writing <code class="literal">return Function(sum)</code>. We can now derive subclasses by inheritance:</p><p>Consider as an example  Chebyshev polynomials which can be computed in the interval [1,-1] by:</p><p>
<span class="inlinemediaobject"><img src="graphics/cheby2.jpg" alt="Encapsulation"/></span>.</p><p>We construct a Chebyshev polynomial as an instance of the <code class="literal">Function</code> class:</p><pre class="programlisting">T5 = Function(lambda x: cos(5 * arccos(x)))&#13;
T6 = Function(lambda x: cos(6 * arccos(x)))</pre><p>Chebyshev polynomials are orthogonal in the sense:</p><p>
</p><div class="mediaobject"><img src="graphics/cheby1-1.jpg" alt="Encapsulation"/></div><p>
</p><p>This can easily be checked using this construction:</p><pre class="programlisting">import scipy.integrate as sci&#13;
&#13;
weight = Function(lambda x: 1 / sqrt((1 - x ** 2)))&#13;
[integral, errorestimate] = &#13;
        sci.quad(weight * T5 * T6, -1, 1) # (6.510878470473995e-17, 1.3237018925525037e-14)</pre><p>Without encapsulation multiplying functions as simply as writing  <code class="literal">weight * T5 * T6</code> would not have been possible.</p></div>
<div class="section" title="Classes as decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Classes as decorators</h1></div></div></div><p>In section <span class="emphasis"><em>Function as decorators</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span> , we saw how functions can be modified by applying another function as a decorator. In previous examples, we saw how classes can be made to behave as functions as long as they are provided with the <code class="literal">__call__</code> method. We will use this here to show how classes can be used as decorators.</p><p>Let us assume that we want to change the behavior of some functions in such a way that before the function is invoked, all input parameters are printed. This could be useful for debugging purposes. We take this situation as an example to explain the use of a decorator class:</p><pre class="programlisting">class echo:&#13;
    text = 'Input parameters of {name}n'+&#13;
        'Positional parameters {args}n'+&#13;
        'Keyword parameters {kwargs}n'&#13;
    def __init__(self, f):&#13;
        self.f = f&#13;
    def __call__(self, *args, **kwargs):&#13;
        print(self.text.format(name = self.f.__name__,&#13;
              args = args, kwargs = kwargs))&#13;
        return self.f(*args, **kwargs)</pre><p>We use this class to decorate function definitions,</p><pre class="programlisting">@echo&#13;
def line(m, b, x):&#13;
    return m * x + b</pre><p>and call the function as usual,</p><pre class="programlisting">line(2., 5., 3.)&#13;
line(2., 5., x=3.)</pre><p>On the second call, we obtain the following output:</p><pre class="programlisting">Input parameters of line&#13;
Positional parameters (2.0, 5.0)&#13;
Keyword parameters {'x': 3.0}&#13;
&#13;
11.0</pre><p>This example shows that both classes and functions can be used as decorators. Classes allow for more possibilities, as they can be used to collect data as well.</p><p>Indeed, we observe that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every decorated function creates a new instance of the decorator class.</li><li class="listitem" style="list-style-type: disc">Data collected by one instance can be saved and made accessible to another instance by class attributes (refer section <span class="emphasis"><em>Attributes</em></span> in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes)</em></span>.</li></ul></div><p>The last point emphasizes the difference with function decorators. We show this now by a decorator that counts function calls and stores the result in a dictionary with the function as key.</p><p>In order to analyze the performance of algorithms, it might be useful to count the calls of particular functions. We can get counter information without changing the function definition. The code is a slight modification of an example given in <a class="link" href="apa.html" title="Appendix . References">[4]</a> .</p><pre class="programlisting">class CountCalls:&#13;
    """&#13;
    Decorator that keeps track of the number of times &#13;
    a function is called.&#13;
    """&#13;
    instances = {} &#13;
    def __init__(self, f):&#13;
        self.f = f&#13;
        self.numcalls = 0&#13;
        self.instances[f] = self&#13;
    def __call__(self, *args, **kwargs):&#13;
        self.numcalls += 1&#13;
        return self.f(*args, **kwargs)&#13;
    @classmethod&#13;
    def counts(cls):&#13;
        """&#13;
        Return a dict of {function: # of calls} for all &#13;
        registered functions.&#13;
        """&#13;
        return dict([(f.__name__, cls.instances[f].numcalls) &#13;
                                    for f in cls.instances])</pre><p>Here, we use the class attribute <code class="literal">CountCalls.instances</code>  to store the counters for each individual instance. Let us see how this decorator works:</p><pre class="programlisting">@CountCalls&#13;
def line(m, b, x):&#13;
    return m * x + b&#13;
@CountCalls &#13;
def parabola(a, b, c, x):&#13;
    return a * x ** 2 + b * x + c&#13;
line(3., -1., 1.)&#13;
parabola(4., 5., -1., 2.)&#13;
 &#13;
CountCalls.counts() # returns {'line': 1, 'parabola': 1}&#13;
parabola.numcalls # returns 1</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Summary</h1></div></div></div><p>One of the most important programming concepts in modern computer science is object-oriented programming. We learned in this chapter how to define objects as instances of classes, which we provide with methods and attributes. The first parameter of methods, usually denoted by <code class="literal">self</code>, plays an important and special role. You saw methods that can be used to define basic operations such as <code class="literal">+</code> and <code class="literal">*</code> for your own classes.</p><p>While in other programming languages attributes and methods can be protected against unintended use, Python allows a technique to hide attributes and access these hidden attributes through special getter and setter methods. To this end, you met an important function, <code class="literal">property</code>.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Exercises</h1></div></div></div><p>
<span class="strong"><strong>Ex. 1</strong></span> → Write a method <code class="literal">simplify</code> to the class <code class="literal">RationalNumber</code>. This method should return the simplified version of the fraction as a tuple.</p><p>
<span class="strong"><strong>Ex. 2</strong></span> → To provide results with confidence intervals a special calculus, so-called interval arithmetic is introduced in numerical mathematics; (refer to<a class="link" href="apa.html" title="Appendix . References"> [3, 14]</a><span class="emphasis"><em>)</em></span>. Define a class called <code class="literal">Interval</code> and provide it with methods for addition, subtraction, division, multiplication, and power (with positive integers only). These operations obey the following rules:</p><p><span class="inlinemediaobject"><img src="graphics/B05511_08_01.jpg" alt="Exercises"/></span>.</p><p>Provide this class with methods that allow operations of the type <span class="emphasis"><em>a </em></span>+<span class="emphasis"><em> I, a I, I </em></span>+<span class="emphasis"><em> a, I a</em></span>, where <span class="emphasis"><em>I</em></span> is an interval and <span class="emphasis"><em>a</em></span> an integer or float. Convert an integer or float to an interval <code class="literal">[a,a]</code> first. (Hint: you may want to use function decorators for this; (refer to section<span class="emphasis"><em> Function as decorators</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>). Furthermore, implement the <code class="literal">__contains__</code> method, which enables you to check if a given number belongs to the interval using the syntax <code class="literal">x in I</code> for an object <code class="literal">I</code> of type Interval. Test your class by applying a polynomial <code class="literal">f=lambda x: 25*x**2-4*x+1</code> to an interval.</p><p>
<span class="strong"><strong>Ex. 3</strong></span> → Consider the example under section <span class="emphasis"><em>Classes as decorators</em></span>. Extend this example to obtain a <span class="emphasis"><em>function decorator</em></span> that counts how often a certain function is called.</p><p>
<span class="strong"><strong>Ex. 4</strong></span> → Compare the two ways to implement a method for reverse addition <code class="literal">__radd__</code> in the class<code class="literal"> RationalNumber</code>: the one given in the example in section <span class="emphasis"><em>Special methods</em></span> and the one given here:</p><pre class="programlisting">class RationalNumber:&#13;
    ....&#13;
    def __radd__(self, other):&#13;
        return other + self</pre><p>Do you expect an error in this version? What is the error and how do you explain it? Test your answer by executing:</p><pre class="programlisting">q = RationalNumber(10, 15)&#13;
5 + q</pre><p>
<span class="strong"><strong>Ex. 4</strong></span> → Consider the decorator class <code class="literal">CountCalls</code> as in example in section <span class="emphasis"><em>Classes as decorators</em></span>. Provide this class with a method, <code class="literal">reset</code>, which sets the counters of all functions in the dictionary, <code class="literal">CountCalls.instances</code>, to zero. What would happen if the dictionary were replaced by an empty dictionary instead?</p></div></body></html>