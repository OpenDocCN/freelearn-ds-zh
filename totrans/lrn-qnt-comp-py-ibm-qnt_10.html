<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer725" class="Basic-Text-Frame">
    <h1 class="chapterNumber">10</h1>
    <h1 id="_idParaDest-166" class="chapterTitle">Suppressing and Mitigating Quantum Noise</h1>
    <p class="normal">In the previous edition of this book, you may recall a chapter which discussed, in a reasonable amount of detail, the different types of noise that affect various quantum systems. Since then, there has been an incredible amount of research that has evolved not only the hardware but the software as well. Due to the changes since then, which includes a few major refactorization iterations of Qiskit, for example, the deprecation of Ignis and its many test circuit libraries, I thought it might be a good time to shift into the latest and not spend too much time on how to test a system, but rather understand how to leverage the latest error suppression and mitigation techniques. Of course, I don’t want to leave you too far in the dark, so I will cover some of the fundamentals of what these noises are and how they affect your experiments. However, I do want to ensure we cover the current era of quantum utility (<a href="https://www.nature.com/articles/s41586-023-06096-3"><span class="url">https://www.nature.com/articles/s41586-023-06096-3</span></a>), which entails using error suppression and mitigation techniques to help you find some useful quantum applications. We should expect to see some advancements as the systems evolve and get wider (more qubits) and deeper (complex quantum circuits with thousands of 2-qubit gates), which can be seen as a great step towards useful quantum applications without needing to wait for fault-tolerant quantum computers.</p>
    <p class="normal">Early quantum systems were commonly referred to as near-term devices, which generally means they are close to becoming fully fault-tolerant quantum systems. One of the reasons for this is that all current quantum systems, no matter what technology they use to create qubits, are affected by <strong class="keyWord">noise</strong> in some shape or form, which increases the error rates of these systems. To address, and in turn minimize the error rates, it helps to understand what causes these errors and how can we suppress or mitigate them. Keep in mind that the study of errors in any one of the following examples could easily qualify as a research topic, which is why we will simply touch on some examples but if you are interested in more details, I will provide some reference materials at the end of the chapter. For now, this chapter is merely an overview with some examples to help you get an idea on how to create some of these noise models using the functionalities provided to you in Qiskit and how to suppress and mitigate against them using features included in the Qiskit Runtime. The goal here is to help you optimize the effectiveness of your quantum circuits, which in turn helps you design your applications to be as resistant as possible to the various forms of errors.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding the Qiskit Runtime Service</li>
      <li class="bulletList">Understanding Sessions</li>
      <li class="bulletList">Understanding the Qiskit Runtime Options</li>
      <li class="bulletList">Understanding Primitives</li>
      <li class="bulletList">Understanding the Sampler primitive</li>
      <li class="bulletList">Understand the noise effects of decoherence</li>
      <li class="bulletList">Differences between error suppression, mitigation, and correction</li>
    </ul>
    <p class="normal">In this chapter, we will cover one of the challenges faced by most quantum systems: noise. By the end of the chapter, you will understand some of the varying noise effects, such as relaxation and dephasing. Then, you’ll get an overview of the latest advancements in the Qiskit Runtime Service and learn about the building blocks to run your circuits efficiently on any backend system. Finally, you will learn about the error suppression and error mitigation techniques and how to apply them to your complex quantum circuits.</p>
    <p class="normal">In previous versions of Qiskit, there was a module titled, Ignis, which was the module that contained libraries to characterize and mitigate against noise. Since then, the Ignis library has been deprecated, so it is recommended that you read the Qiskit Migration Guide on the Qiskit GitHub page (<a href="https://github.com/Qiskit/qiskit-ignis#migration-guide"><span class="url">https://github.com/Qiskit/qiskit-ignis#migration-guide</span></a>), particularly if you want to use many of the recent advancements.</p>
    <p class="normal">In quantum systems, noise originates from various sources: thermal heat from electronics, decoherence, dephasing, crosstalk, or signal loss. Here, we will see how to measure the effects of noise on a <strong class="keyWord">qubit</strong>, and how to mitigate readout error noise to optimize our results. In the end, we will compare the differences to better understand the effects and <a id="_idIndexMarker1075"/>ways to mitigate them using other techniques such as <strong class="keyWord">dynamical decoupling</strong>, which is used to help reduce noise caused by decoherence of a qubit when its state is left idle for too long.</p>
    <p class="normal">Before we get started with all of that, we need to first get familiar with one of the newest features that will help bring all these techniques to our fingertips and allow us to adjust them all as needed: the Qiskit Runtime service.</p>
    <h1 id="_idParaDest-167" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, we will cover some refreshers on simulating noise, so if you have some knowledge of signal to noise theory, this will help. If not, review <em class="chapterRef">Chapter 9</em>, <em class="italic">Simulating Quantum Systems and Noise Models</em>, to get an understanding of the various forms of noise that affect quantum systems. This will help you understand how to suppress and mitigate errors on a quantum computer using the Qiskit Runtime.</p>
    <p class="normal">Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-168" class="heading-1">Understanding the Qiskit Runtime service</h1>
    <p class="normal">For those of you who have used earlier versions of Qiskit, you may have been using the <code class="inlineCode">execute()</code> or <code class="inlineCode">backend.run()</code> functions to run quantum circuits on a quantum system. This was <a id="_idIndexMarker1076"/>good to run some basic quantum circuits for learning purposes on small quantum systems with less than 100 qubits. However, if we want to start to think about the future and how we can create circuits for hundreds, thousands, and even millions of qubits, then we will need to think about how to optimally do so without just throwing a large circuit onto a single machine. This is where the <strong class="keyWord">Qiskit Runtime Service</strong> comes in very handy. Not only does it include many new options, such as selecting the optimization and resilience levels, which we will learn about later in this chapter, but it also includes all the transpilation features we covered earlier, so we won’t necessarily lose what we have learned so far. In this section, we will cover what the Qiskit Runtime is and how you can execute your circuits using it. Knowing how to use the Qiskit Runtime will also help you later in this chapter, when we learn about the various error suppression and mitigation techniques and how they are applied to your quantum circuit.</p>
    <p class="normal">Let’s begin by learning more about the Qiskit Runtime Service, how is it different from the execute function, and what new features we can use to optimize executing our quantum circuits on a quantum system.</p>
    <p class="normal">First, let’s create <a id="_idIndexMarker1077"/>a new notebook and import a few Qiskit Runtime objects, functions, and instantiate the <code class="inlineCode">QiskitRuntimeService</code> class, using our helper file.</p>
    <div class="note">
      <p class="normal">Note, at the time of writing, there has been a switch from the current Sampler version to SamplerV2. In the following code, it is assumed that the “V2” will be removed. If for some reason it is not, then please update <code class="inlineCode">Sampler</code> to <code class="inlineCode">SamplerV2</code> to ensure you are using the latest version of the Sampler.</p>
    </div>
    <p class="normal">Another important step is that you must use the <code class="inlineCode">token</code> parameter to set either your IBM Quantum or IBM Cloud API token, as illustrated in the following code snippet. If you do not set this, you will likely get an error, and when trying to access the Qiskit Runtime service, it will not work.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Loading your IBM Quantum account(s)</span>
service = QiskitRuntimeService(channel=<span class="hljs-string">"ibm_quantum"</span>, token=<span class="hljs-string">"API_TOKEN"</span>)
</code></pre>
    <p class="normal">Now that you have your notebook setup, let’s dig into some of the execution mode descriptions..</p>
    <h2 id="_idParaDest-169" class="heading-2">Understanding Sessions</h2>
    <p class="normal">A <strong class="keyWord">Session</strong> is in <a id="_idIndexMarker1078"/>essence a collection of Jobs that is guaranteed to run on the backend without any interruptions from other user Jobs, particularly those that require <a id="_idIndexMarker1079"/>multiple iterations, such as those that <a id="_idIndexMarker1080"/>are based on variational algorithms: <strong class="keyWord">Variational Quantum Eigensolver</strong> (<strong class="keyWord">VQE</strong>), and <strong class="keyWord">Quantum Approximate Optimization Algorithm</strong> (<strong class="keyWord">QAOA</strong>). In other words, “without interruptions” means that the Qiskit Runtime will ensure that each Job will complete, including the period where the variables are being adjusted between classical and quantum resources, where in the past this time was used to interleave Jobs from another user in the queue.</p>
    <p class="normal">To understand the practicality of this format, imagine standing in a long queue waiting your turn to submit a form, like renewing your driver’s license. After waiting a few hours, you’re finally at the window and handing over your form, only to be told that you need to adjust some values in the form. This is where the difference comes in. In the previous version, you would have to stand off to the side and update the form fields; meanwhile, someone else will move up to the window. Now, if you happen to be ready, you now must wait for that other person to finish before you can continue. This, of course, might take a long time, causing you to wait longer. What Sessions allows you to do is keep that window free and available for you until you finish updating the form and then turn it in.</p>
    <p class="normal">Regarding what the default and max times are for both the interactive and maximum <a id="_idIndexMarker1081"/>time values, I would refer you to the Qiskit Runtime documentation <a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service"><span class="url">https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime_service</span></a> ) as these values might change over time. However, time in the queue does count towards the maximum time of the Session. The idle time could be used to perform any classical operations based on the results of the Job and/or prepare for the subsequent Job in the Session.</p>
    <p class="normal">Each Job can <a id="_idIndexMarker1082"/>be set as part of a batch of Jobs to ensure that they run on the same device or closely together to avoid the issues that can occur if they are run on separate systems or far apart, which would introduce strangeness to our results due to device characteristics or device drift. To learn more about device drift, see the <em class="italic">Further reading</em> section at the end of this chapter. At the time of writing, there are upcoming features that will further optimize execution of circuits, so do keep an eye on the documentation and information feeds for details and examples.</p>
    <p class="normal">Before we start coding, let’s get familiar with the other classes first as this will simplify our coding experience moving forward. In the next section, we will look at the options that we can set to our <code class="inlineCode">Session</code> class. The <code class="inlineCode">Options</code> class will also be very important later when suppressing and mitigating errors.</p>
    <h2 id="_idParaDest-170" class="heading-2">Understanding the Qiskit Runtime Options</h2>
    <p class="normal"><code class="inlineCode">RuntimeOptions</code> is a class used to set the various parameters for the Qiskit Runtime execution <a id="_idIndexMarker1083"/>options. Parameters are used to select which quantum system to use and which optimization or resilience levels to use that enable various error suppression or error mitigation features. Below is a list of <code class="inlineCode">Options</code> parameters that are used for the various Qiskit Runtime primitives. Keep in mind that, as always, you should check the latest version of Qiskit API documentation to ensure your code is always current:</p>
    <ul>
      <li class="bulletList">Environment parameters such as <code class="inlineCode">log_level</code> (<code class="inlineCode">DEBUG</code>, <code class="inlineCode">INFO</code>, etc.), and <code class="inlineCode">callback</code> for any interim or final results, which will receive two positional parameters: Job ID and Job result</li>
      <li class="bulletList">Execution parameters for execution time options, such as number of <code class="inlineCode">shots(int)</code>, and <code class="inlineCode">init_qubits(bool)</code>, which will reset the qubits to the ground state for each shot the (default is <code class="inlineCode">true</code>)</li>
      <li class="bulletList"><code class="inlineCode">max_execution_time</code> is the maximum time, in seconds, after which a job is canceled. If this is not set, the default will be the time limit of the Primitive. If it is set, then the time must be set between 300 seconds and the maximum execution time set for the simulator or device, which can be found in the Qiskit API documentation: <a href="https://docs.quantum.ibm.com/guides/max-execution-time"><span class="url">https://docs.quantum.ibm.com/guides/max-execution-time</span></a>.</li>
      <li class="bulletList"><code class="inlineCode">optimization_level</code> sets the level of optimization to the circuit. The higher the level, the more optimal and therefore longer the transpilation time. These <a id="_idIndexMarker1084"/>optimization levels also include error suppression such as dynamical decoupling, which we will cover later in this chapter. There are four <code class="inlineCode">optimization_level</code> settings. The default value is set to the highest, <code class="inlineCode">3</code>:<ul>
          <li class="bulletList level-2">0 – no optimization, uses basic translation, whichever layout is specified, and routing (uses stochastic swaps by default)</li>
          <li class="bulletList level-2">1 – light optimization, routing (uses SabreSWAP, 1Q gate optimization, and dynamical decoupling for error suppression)</li>
          <li class="bulletList level-2">2 – medium optimization, layout and routing are the same as level 1, but includes heuristic optimization with a greater search depth and trials of optimization and dynamical decoupling for error suppression</li>
          <li class="bulletList level-2">3 – high optimization, layout and routing are the same as level 2 and include further optimization with greater efforts/trials, 2-qubit KAK optimization, and dynamical decoupling for error suppression</li>
        </ul>
      </li>
      <li class="bulletList"><code class="inlineCode">resilience_level</code> sets the level of resilience to mitigate errors. The higher the resilience level, the higher the accuracy of your results. Higher results are like that of the optimization level where it will cause longer transpilation time. These resilience levels range from 0 to 2, where level 1 is the default value and is only available for the Estimator primitive. It is important to note that as the technology evolves, so does the implementation and mitigation of these techniques. Please refer to the latest documentation to ensure your code is running the latest version (<a href="https://docs.quantum.ibm.com/guides/configure-error-mitigation"><span class="url">https://docs.quantum.ibm.com/guides/configure-error-mitigation</span></a> ).<ul>
          <li class="bulletList level-2">0 – no mitigation.</li>
          <li class="bulletList level-2">1 – (default) minimal mitigation, which minimizes readout errors. The Estimator primitive uses the Twirled Readout Error Extinction.</li>
          <li class="bulletList level-2">2 – medium mitigation, used to minimize bias in a circuit but indicates that it is not guaranteed to be zero, using the same as level 1 and includes Zero Noise Extrapolation. </li>
        </ul>
      </li>
    </ul>
    <p class="normal">Now that <a id="_idIndexMarker1085"/>we’re familiar with all the options we can set to optimize and run circuits on our backend systems, let’s continue to move forward and learn what the Primitive classes are all about.</p>
    <h2 id="_idParaDest-171" class="heading-2">Understanding Primitives</h2>
    <p class="normal"><strong class="keyWord">Primitives</strong>, as defined on the Qiskit documentation, are generally the “<em class="italic">foundational building blocks for designing and optimizing quantum workloads</em>.” At the time of writing, there <a id="_idIndexMarker1086"/>are two primitives within the Qiskit Runtime: <strong class="keyWord">Sampler</strong> and <strong class="keyWord">Estimator</strong>. Each of these provides a simple way to encapsulate your circuit and leverage each of its features to optimize workloads during execution to optimize running them on multiple quantum systems at scale. If you recall in the previous chapters, when we built and applied optimization levels to our circuit, it involved quite a bit of work, and the optimization was based on a single quantum system that we selected to run on. You can imagine the number of steps and overhead that would require if we needed to do that for each different system that executes our circuit. With the interface provided by the primitives, a lot of that is taken care of for us by applying a handful of option settings and selections. The runtime will then apply these accordingly as it selects multiple systems to execute the circuits. The primitives each perform a specific task and serve as the entry point to the Qiskit Runtime service. Let’s look at each primitive to get a little understanding of their functionality and the differences between them. In this chapter, we will focus on the Sampler primitive. The IBM Quantum Learning platform has some very good examples, courses, and tutorials that you can learn from in much greater detail than I can provide in this one chapter. </p>
    <h3 id="_idParaDest-172" class="heading-3">Understanding the Sampler primitive</h3>
    <p class="normal">The <strong class="keyWord">Sampler</strong> primitive is <a id="_idIndexMarker1087"/>similar to what we have used <a id="_idIndexMarker1088"/>throughout this book in that it takes a quantum circuit as its input and generates a quasi-probability result. The result of this is also error-mitigated to ensure that the results are as precise as possible. Example of Sampler primitive circuits are Grover’s search and Deutsch-Jozsa. The Sampler can be modified to allow changes such as backends (local simulator or quantum system), which simplifies the management of your circuits and how they are run on the backend in accordance with the needs of your experiments. This is very helpful as each primitive has its own form of operating on the quantum circuit when executed on a quantum system, therefore certain properties or mitigating techniques will not work on some primitives based on the way they perform their tasks.</p>
    <p class="normal">Well, so far, we’ve done quite a bit of reading, why don’t we get back to some coding. Let’s create <a id="_idIndexMarker1089"/>a new Qiskit notebook and run a simple circuit using <a id="_idIndexMarker1090"/>the Sampler to try it out. We’ll also include the classes mentioned earlier so we can wrap everything together in a simple construct of a circuit.</p>
    <p class="normal">First, we’ll create a simple circuit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Create a simple circuit:</span>
<span class="hljs-keyword">from</span> qiskit <span class="hljs-keyword">import</span> QuantumCircuit, QuantumRegister, ClassicalRegister,   
                   transpile
<span class="hljs-keyword">from</span> qiskit.visualization <span class="hljs-keyword">import</span> plot_distribution
q_reg = QuantumRegister(<span class="hljs-number">4</span>, name=<span class="hljs-string">'qr'</span>)
c_reg = ClassicalRegister(<span class="hljs-number">4</span>, name=<span class="hljs-string">'cr'</span>)
qc = QuantumCircuit(q_reg, c_reg)
qc.h(0)
qc.cx(0, 1)
qc.cx(1, 2)
qc.cx(2, 3)
qc.draw(output=<span class="hljs-string">"mpl"</span>)
</code></pre>
    <p class="normal">This will display the following circuit that we wish to run:</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_01.png" alt="A diagram of a circuit  Description automatically generated" width="282" height="210"/></figure>
    <p class="packt_figref">Figure 10.1: Simple circuit to run on the system</p>
    <p class="normal">Now, here’s where <a id="_idIndexMarker1091"/>the fun starts! Let’s begin by following the Qiskit Patterns so we are not only ensuring that our circuits are efficient but also our development patterns.</p>
    <p class="normal">Qiskit Patterns <a id="_idIndexMarker1092"/>are a 4-step process that we can use to help integrate our quantum computation circuits into a larger application layer. The 4 steps are Map, Optimize, Execute, and Post-process. We’ll go through each of these steps so that you can get familiar with running circuits optimally on a quantum system. We’ll start with what we just did: map our problem into a quantum circuit.</p>
    <h4 class="heading-4">Step 1: Map</h4>
    <p class="normal">Mapping a problem to a quantum circuit can be done in many ways. We can probably write volumes of books that could be dedicated to this. This is because it not only depends on the problem we’re trying to solve, but also how we can best map our input data and problem solution into a quantum state or initial state. This is similar to planning a trip. If I were to ask you to plan a group trip to New York, there could be many options and even more questions regarding how to get there? Where will everyone be? Are they all in the same location at the beginning of the trip. How long will they be available? These are similar questions we need to consider. How do we get the data to the quantum systems? Where is all the data, at that moment, and how long will the data be there? Once we have obtained the input data the next step is to translate <a id="_idIndexMarker1093"/>it from classical information into a quantum <a id="_idIndexMarker1094"/>state or input for our circuit. Let’s do this now with a simple example, the circuit we built earlier in this chapter. In <em class="chapterRef">Chapter 13</em>, we will cover a more sophisticated problem, Grover’s search. For now, to allow us to focus on the overall process, we’ll stick with the simple circuit, and some random circuits.</p>
    <p class="normal">So far, we have mapped a problem into a quantum state, in this case the circuit we constructed above. That’s step one, Map, done.</p>
    <p class="normal">Let’s now run this circuit using a <code class="inlineCode">Statevector</code> class to get the expected results before running on a quantum system. Since this is a small and simple quantum circuit, we can simulate this easily on a classical system such as the one you have at home or in your office. If the circuit or problem involved a large number of qubits that you would be unable to run on a classical system, then the preferred way to do this would be to reduce the problem size to something you can run on a classical system so that you can confirm the expected result at a smaller scale and then run on a quantum system to get the full-scale results.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> qiskit.quantum_info <span class="hljs-keyword">import</span> Statevector
<span class="hljs-comment"># Pass the circuit instructions into the Statevector</span>
results = Statevector.from_instruction(qc).probabilities_dict()
plot_distribution(results)
</code></pre>
    <p class="normal">This will display the expected results in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_02.png" alt="A graph with blue bars  Description automatically generated" width="732" height="534"/></figure>
    <p class="packt_figref">Figure 10.2: Expected probability results from the circuit using Statevector</p>
    <p class="normal">Next, we can <a id="_idIndexMarker1095"/>prepare this to run on an actual backend. To do <a id="_idIndexMarker1096"/>this, we need to include measurement operators in our circuit, which we will do, and then obtain the least busy backend system to run this circuit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Add measurements to our circuit</span>
qc.measure_all(add_bits=<span class="hljs-literal">False</span>)
<span class="hljs-comment"># Select the least busy backend system to run circuit</span>
backend = service.least_busy(simulator=<span class="hljs-literal">False</span>, operational=<span class="hljs-literal">True</span>)
<span class="hljs-built_in">print</span>("Least busy backend: ", backend)
</code></pre>
    <p class="normal">This will print out the selected backend, which is the least busy at the time it is called.</p>
    <h4 class="heading-4">Step 2: Optimize</h4>
    <p class="normal">Now we can prepare our circuit to run on the backend by transpiling it accordingly. To do this, we will use the new <code class="inlineCode">preset_passmanager</code> function, which is a new addition to the Qiskit <code class="inlineCode">transpiler</code> library that allows you to set, run, and draw the result of the circuit after transpilation. Aligning a circuit to a target backend is ideal in that it will optimize <a id="_idIndexMarker1097"/>the circuit to that selected backend by applying not <a id="_idIndexMarker1098"/>only the general passes available but also AI generated optimizers that introduce further improvements. </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> qiskit.transpiler.preset_passmanagers <span class="hljs-keyword">import</span> generate_preset_pass_manager
target = backend.target
pm = generate_preset_pass_manager(target=target, optimization_level=<span class="hljs-number">3</span>)
transpiled_qc = pm.run(qc)
transpiled_qc.draw(output="mpl", idle_wires=<span class="hljs-literal">False</span>, style="iqp")
</code></pre>
    <p class="normal">This displays the transpiled circuit specific to the selected backend target. Here, you will note two differences from the original circuit. First, note the qubit mapping has changed; qubit 0 is now assigned to qubit 73. In your case, depending on which system was selected, it might point to other qubits. Next, you’ll also note that there are more gates added. This is due to having to use basis gates and connectivity between qubits (using ECR gates: <a href="https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate"><span class="url">https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.ECRGate</span></a> ) to connect between qubits that might not be adjacent to each other. Results might differ here as your selected backend might have different results.</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_03.png" alt="A diagram of a graph  Description automatically generated with medium confidence" width="826" height="236"/></figure>
    <p class="packt_figref">Figure 10.3: Transpiled circuit</p>
    <p class="normal">Now that we know how to transpile a circuit and set the optimization level values, let’s now switch to a bit more complex circuit so we can push the optimizer further and see the differences between the resulting circuits. We’ll use a simple Grover operator to generate a circuit. Since we have not yet covered Grover’s algorithm in much detail, let’s ease into it and just <a id="_idIndexMarker1099"/>say that we will use it to mark a state we wish the <a id="_idIndexMarker1100"/>circuit to find. In this case, we will use the binary representation <code class="inlineCode">110</code>. Grover’s algorithm will be discussed in <em class="chapterRef">Chapter 13</em>.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> qiskit.circuit.library <span class="hljs-keyword">import</span> GroverOperator
oracle = Statevector.from_label("<span class="hljs-number">110</span>")
grover_qc = QuantumCircuit(<span class="hljs-number">3</span>)
grover_qc.h(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))
grover_qc = grover_qc.compose(GroverOperator(oracle))
grover_qc.draw(output="mpl")
</code></pre>
    <p class="normal">This will result in the following circuit, where we have a set of Hadamard gates followed by the Grover operator composite. Note that this is a composite that represents a series of gates into a single block titled Q to simplify the visualization of the circuit. You can run the <code class="inlineCode">decompose</code> method a few times to break it down to the basis gates.</p>
    <p class="normal">In the next steps, we will transpile it with varying optimization level values and compare the two so you can see the power that the <code class="inlineCode">transpiler</code> optimizers have on the circuit.</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_04.png" alt="A diagram of a number of squares  Description automatically generated with medium confidence" width="203" height="197"/></figure>
    <p class="packt_figref">Figure 10.4: Grover operator circuit</p>
    <p class="normal">The following will highlight the difference between optimization levels with the complexities that accompany many circuits. To be more specific regarding the comparisons, we will be observing <a id="_idIndexMarker1101"/>the number of <strong class="keyWord">ECR</strong> gates, which is an acronym <a id="_idIndexMarker1102"/>for <strong class="keyWord">Echoed Cross-Resonance</strong> gate. They’re similar to CX gates but with an echoing <a id="_idIndexMarker1103"/>procedure, which mitigates a few unwanted terms. Details on this gate can be found in the Qiskit Circuit Library. ECR gates, or any multi-source/multi-target gates, are quite complex as they require additional gates to generate connectivity. In this example, we will use the number of ECR gates to compare the circuits.</p>
    <p class="normal">Let’s first capture the <code class="inlineCode">Statevector</code> results from the current circuit so we can compare them to the results after transpiling and running on the quantum systems:</p>
    <pre class="programlisting code"><code class="hljs-code">results = Statevector.from_instruction(grover_qc).probabilities_dict()
</code></pre>
    <p class="normal">Next, we’ll add measurement gates to this circuit and create multiple copies, each with varying <code class="inlineCode">optimization_level</code> values to compare:</p>
    <pre class="programlisting code"><code class="hljs-code">grover_qc.measure_all()
transpiled_grover_qc = pm.run(grover_qc)
transpiled_grover_qc.draw(output="mpl", idle_wires=<span class="hljs-literal">False</span>, style="iqp")
</code></pre>
    <p class="normal">The result <a id="_idIndexMarker1104"/>here is a transpiled version of the original Grover <a id="_idIndexMarker1105"/>circuit we created. I have included a truncated portion of it in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_05.png" alt="A diagram of a circuit  Description automatically generated with medium confidence" width="825" height="194"/></figure>
    <p class="packt_figref">Figure 10.5: Transpiled Grover operator circuit (truncated)</p>
    <p class="normal">As you can see, it is much more complex and with quite a few extra gates, including ECR gates.</p>
    <p class="normal">Now, let’s go through the circuit and assign a different <code class="inlineCode">optimization_level</code> value for each. In this case, we’ll compare the extreme levels, one at 0, which is to say no optimization at all, and another at 3, which is fully optimized. We’ll then add it to a <code class="inlineCode">circuits</code> array to run on a quantum system later.</p>
    <pre class="programlisting code"><code class="hljs-code">circuits=[]
<span class="hljs-keyword">for</span> optimization_level <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]:
    transpiled_grover_qc = transpile(grover_qc, backend, optimization_level=optimization_level, seed_transpiler=<span class="hljs-number">1000</span>)
    <span class="hljs-built_in">print</span>(f"ECR (Optimization level={optimization_level}): ", transpiled_grover_qc.count_ops()["ecr"])
    circuits.append(transpiled_grover_qc)
</code></pre>
    <p class="normal">This will display the number of ECR gates for each circuit. Note the difference between the two circuits (they will vary based on system) is quite large when compared with no optimization (level 0) and fully optimized (level 3).</p>
    <pre class="programlisting code"><code class="hljs-code">ECRs (optimization_level=<span class="hljs-number">0</span>):  <span class="hljs-number">24</span>
ECRs (optimization_level=<span class="hljs-number">3</span>):  <span class="hljs-number">14</span>
</code></pre>
    <p class="normal">Now that we have optimized our circuit by transpiling to the device with specific optimization levels, let’s now run both circuits and compare the results, along with the simulated results, on an actual quantum system.</p>
    <p class="normal">This completes the optimize step and we move onto the next Qiskit Pattern, executing the optimized circuit.</p>
    <h4 class="heading-4">Step 3: Execute</h4>
    <p class="normal">Here, we will now run our circuit on the targeted backend, but this time with a twist. We will use a new feature of the Qiskit Runtime called Batch. This will allow us to <a id="_idIndexMarker1106"/>provide a batch of operations to run on a quantum system. </p>
    <p class="normal">To execute <a id="_idIndexMarker1107"/>the circuits we created, we will first need to create a batch, which is one of the execution modes of the Qiskit Runtime (<a href="https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch"><span class="url">https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit_ibm_runtime.Batch</span></a> ), and load it up with our circuit and backend information first, then within the batch, we’ll run the Sampler primitive on the backend and print the results.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">with</span> Batch(service=service, backend=backend):
    sampler = Sampler()
    job = sampler.run(
        circuits=circuits,
        skip_transpilation=<span class="hljs-literal">True</span>,
        shots=<span class="hljs-number">8000</span>
    )
    result = job.result()
</code></pre>
    <p class="normal">This might take a while depending on where you are in the queue. But once it’s complete, you should see the following results from your experiment, which includes the quasi-probability results and the metadata from the experiment, in this case the number of shots used to obtain the results.</p>
    <pre class="programlisting code"><code class="hljs-code">SamplerResult(quasi_dists=[{<span class="hljs-number">0</span>: <span class="hljs-number">0.136596417234717</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0.057482039100449</span>, <span class="hljs-number">2</span>: <span class="hljs-number">0.03807773583055</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0.051080549862785</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0.028575374054239</span>, <span class="hljs-number">5</span>: <span class="hljs-number">0.068434342226471</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0.540689745421478</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0.079063796269311</span>}, {<span class="hljs-number">0</span>: 
<span class="hljs-number">0.013241830253957</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0.044991185036454</span>, <span class="hljs-number">2</span>: <span class="hljs-number">0.066493715476242</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0.033981414166734</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0.077452855226391</span>, <span class="hljs-number">5</span>: <span class="hljs-number">0.045273457404358</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0.654480551636603</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0.064084990799261</span>}], metadata=[{<span class="hljs-string">'shots'</span>: <span class="hljs-number">8000</span>, <span class="hljs-string">'circuit_metadata'</span>: {}, <span class="hljs-string">'readout_mitigation_overhead'</span>: <span class="hljs-number">1.2784314899265776</span>, <span class="hljs-string">'readout_mitigation_time'</span>: <span class="hljs-number">0.03348202304914594</span>}, {<span class="hljs-string">'shots'</span>: <span class="hljs-number">8000</span>, <span class="hljs-string">'circuit_metadata'</span>: {}, <span class="hljs-string">'readout_mitigation_overhead'</span>: <span class="hljs-number">1.0800027370262115</span>, <span class="hljs-string">'readout_mitigation_time'</span>: <span class="hljs-number">0.0965154911391437</span>}])
</code></pre>
    <p class="normal">Let’s look at the results a little deeper. First, you will see a set of <code class="inlineCode">quasi_dists</code>. These are the results of the quasi-distribution from our experiments. Since we ran a 3-qubit circuit, we should <a id="_idIndexMarker1108"/>see 8 possible results, 0-7, and the quasi-probabilities for each. This is then followed by some nice information on the readout overhead <a id="_idIndexMarker1109"/>for each circuit, which is simply the time it took to read out the results for each circuit. </p>
    <p class="normal">This now helps us move into the final step in the Qiskit Patterns, post-process.</p>
    <h4 class="heading-4">Step 4: Post-process</h4>
    <p class="normal">In this final step of the Qiskit patterns, we will extract the results from the quantum systems and do some post-processing. What exactly is post-processing? Well, simply put, it’s whatever you wish it to be. You could extrapolate the results and return them to the next task in your classical application to continue a particular hybrid classical-quantum workflow, or you can simply provide the results as an input to another classical or quantum computational task and continue. In this case, we’ll keep it simple and just display the results visually to compare them. We’ll compare the state vector results we computed earlier and visualize them in comparison to the results from the two circuits we ran on a quantum system. The following will display the results onto a histogram:</p>
    <pre class="programlisting code"><code class="hljs-code">qc_results = [quasi_dist.binary_probabilities() <span class="hljs-keyword">for</span> quasi_dist <span class="hljs-keyword">in</span> result.quasi_dists]
plot_histogram(
    qc_results + [results],
    legend=[
        "optimization_level=<span class="hljs-number">0</span>",
        "optimization_level=<span class="hljs-number">3</span>",
        "Simulated results"
    ],
    bar_labels=<span class="hljs-literal">False</span>
)
</code></pre>
    <p class="normal">The resulting plot will be as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_06.png" alt="A graph with different colored bars  Description automatically generated" width="820" height="427"/></figure>
    <p class="packt_figref">Figure 10.6: Post-processed results, visualization comparison</p>
    <p class="normal">Here, you can see that our result is as expected, where the results from the optimization at the higher level, 3, are closer to our simulated results, whereas the results from the circuit without any optimization are less accurate. </p>
    <p class="normal">This brings us to the next topic we need to discuss: noise. All quantum systems, no matter the <a id="_idIndexMarker1110"/>technology, have some form of noise or effect that the system has that is related to noise. There are some technologies that isolate qubits from any environmental noise; however, this also presents a disadvantage in that when we <a id="_idIndexMarker1111"/>want to alter the state of the qubit, the speed and fidelity might take longer than other technologies. In this book, since we are using IBM Quantum systems, we will focus on superconducting qubits and the effects that noise has on them. We will, of course, also cover the latest advancements in both error suppression and error mitigation, which over time will potentially provide us with useful quantum applications. In the next section, we’ll begin by understanding the differences between the types of noise and how they affect quantum systems.</p>
    <h1 id="_idParaDest-173" class="heading-1">Understanding the noise effects of decoherence</h1>
    <p class="normal">We learned in <em class="chapterRef">Chapter 9</em>, <em class="italic">Simulating Quantum Systems and Noise Models</em>, that we can generate <a id="_idIndexMarker1112"/>various noise models that are based on the configuration of a specified quantum computer. After the configuration information is extracted, we can then apply any one of an array of error functions to a local simulator, which will reproduce similar error effects to what we would get from a quantum computer.</p>
    <p class="normal">In this section, we will expand on that to learn how these errors affect our circuits over time. The two effects <a id="_idIndexMarker1113"/>we will review here are the two most common issues found in <a id="_idIndexMarker1114"/>near-term quantum systems: <strong class="keyWord">relaxation</strong> and <strong class="keyWord">dephasing</strong>. These are critical errors as they can affect the quantum state information, which would result in erroneous responses.</p>
    <p class="normal">Later in this chapter, we will <a id="_idIndexMarker1115"/>also look at <strong class="keyWord">readout errors</strong>, another common source of noise that originates when the system is applying a measurement pulse, while in parallel, listening in on the acquisition channel. The results and conversion from an analog pulse to a digital value (either 0 or 1) can introduce many errors as well, which we will then try and mitigate.</p>
    <p class="normal">We will start by learning about one of the most common and important effects of noise in quantum systems: <strong class="keyWord">decoherence</strong>. The three main types of decoherence are <strong class="keyWord">T1</strong>, <strong class="keyWord">T2</strong>, and <strong class="keyWord">T2*</strong>. Each of these represents a type of decoherence effect on the qubit. We will begin by looking at each of them individually to understand the differences between them and how to suppress and mitigate against them when they are run on a real quantum device.</p>
    <p class="normal">If you are deeply interested to learn how to analyze the effects of <strong class="keyWord">relaxation</strong> (<strong class="keyWord">T1</strong>) and <strong class="keyWord">dephasing</strong> (<strong class="keyWord">T2/T2*</strong>), <em class="chapterRef">Chapter 9</em>, <em class="italic">Simulating Quantum Systems and Noise Models</em>, illustrates ways to create circuits that include noise models that replicate each of the three. This will help you run experiments to analyze the characterization of the device.</p>
    <p class="normal">The next section provides a quick overview of both, just to get you to understand which of them is affected when discussing the mitigation features.</p>
    <h2 id="_idParaDest-174" class="heading-2">Understanding decoherence errors</h2>
    <p class="normal">T<sub class="subscript">1</sub>, as we <a id="_idIndexMarker1116"/>covered in <em class="chapterRef">Chapter 9</em>, <em class="italic">Simulating Quantum Systems and Noise Models</em>, is often referred to as the <strong class="keyWord">relaxation time</strong>. Relaxation time refers to the time it takes the energy of a qubit to decay from the <strong class="keyWord">excited state</strong> (<img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1117"/>) back down to its <strong class="keyWord">ground state</strong> (<img src="../Images/B18420_10_002.png" alt="" width="23" height="25"/><a id="_idIndexMarker1118"/>), as illustrated in the following graph, where <img src="../Images/B18420_10_003.png" alt="" width="52" height="25"/><a id="_idIndexMarker1119"/> indicates the probability of <code class="inlineCode">1</code>, and <img src="../Images/B18420_10_004.png" alt="" width="52" height="25"/><a id="_idIndexMarker1120"/> is the probability of <code class="inlineCode">0</code>. The T<sub class="subscript">1</sub> time is defined as the value when <em class="italic">P(t) = 1/e</em> (refer to the following diagram):</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_07.png" alt="Figure 11.1 – T1 defined as the decay time where the probability of the energy state reaches 1/e " width="588" height="211"/></figure>
    <p class="packt_figref">Figure 10.7: T1 defined as the decay time where the probability of the energy state reaches 1/e</p>
    <p class="normal">When applying this to a quantum system, if you want to determine the amount of time to reach T<sub class="subscript">1</sub> for any qubit, you would need to create a test circuit that places the qubit in an excited state, <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1121"/>. We know how to do this by simply <a id="_idIndexMarker1122"/>applying an X gate to the qubit and then waiting a given amount of time before measuring that qubit. If you were to do this over a set number of time intervals, you will likely start to see the results switch from the excited state transition to the ground state.</p>
    <p class="normal">So, what does all that mean? Let’s dig in a little bit and see how this applies to quantum systems over time and on complex circuits.</p>
    <p class="normal">We’ll start with a simple analogy to provide you with some intuitive understanding of the concepts here. For those of you who already have knowledge of these concepts, feel free to jump to the next section.</p>
    <p class="normal">Imagine yourself just before or soon after New Year’s Eve making that same resolution most of us make, me included, year after year of hitting the gym and getting back in shape, particularly after the feasts we’ve enjoyed over the holidays. Then, usually on the first or second week of January, we go to the gym and our personal trainer takes us straight to the weights and asks us to pick a weight. Now, one of the things we naturally do is try to pick up where we were the last time we were at the gym and grab a heavy weight. Of course, at first it seems a little heavy, but we power on. Our trainer then wants to test our strength and asks us to hold the weight high over our heads with our arms extended. We then raise the weight confidently over our heads and we’re <em class="italic">excited</em> that this wasn’t too bad. Let’s call our ability to hold the weight over our heads the excited state. OK, so let’s now say our trainer asks us to hold it there as long as we can. What we will notice is that our strength can only sustain this position for some time. We <a id="_idIndexMarker1123"/>will then begin to feel the fatigue in our muscles, which will then slowly, or in my case rather rapidly, start to lower down towards the original position, which is with the weight down close to the <em class="italic">ground</em>, where I am no longer feeling the strain of my muscles. Let’s call this the <em class="italic">relaxed</em> position, the ground state.</p>
    <p class="normal">A qubit pretty much follows this concept in that it will start at a ground state, then sometime later we will amplify the qubit from the ground state to some excited state. Now, just like us, over time we will return to that ground state to relax. This relaxation from excited to ground state is, logically enough, called amplitude relaxation, which may sound familiar because we learned about this in the previous chapter when creating an amplitude dampening noise model to represent decoherence.</p>
    <p class="normal">Looking back at <em class="italic">Figure 10.8</em>, you can imagine this is what the effect decoherence (T<sub class="subscript">1</sub>) has on a qubit caused by its environment. What do we mean by environment? I’m glad you asked! A qubit isn’t just a single aluminum-niobium component with a Josephson Junction. </p>
    <p class="normal">Oh no, no, no, it has so much more going on! Of course, depending on the technology that the qubit relies on, superconducting, ion traps, photonics, etc. the qubit is not sitting all alone. It is usually surrounded by various environment variables that can interfere with and even at times speed up the decoherence of the qubit. Superconducting qubits, for example, must sit at a certain temperature, approximately 15 millikelvin, to work properly and make sure that the energy levels between the ground and first excited state are precise to determine the state of the qubit. Then, the pulse sent to the qubit has to have the right amplitude, duration, frequency, etc. in order to place the qubit in the correct state. Keep in mind that this could be difficult as the quantum system might be very complex. For example, we defined one amplitude value as the excited state as just one position earlier in our example: lifting the weight over our heads. But what if we needed multiple amplitudes to encode our data? Then the precision of our gates will need to be very exact, which means that the fidelity of the gates also might influence our system. This is how decoherence, also referred to as the relaxation rate or T<sub class="subscript">1</sub>, if not suppressed, causes us to lose the quantum state information of our circuit, which leads to errors when we read the results of our circuits.</p>
    <h2 id="_idParaDest-175" class="heading-2">Understanding dephasing errors</h2>
    <p class="normal">T<sub class="subscript">1</sub>, we learned in the previous section, refers to the decoherence or relaxation rate caused when the amplitude of the qubit decays over time. Dephasing errors, on the other hand, <a id="_idIndexMarker1124"/>occur when the phase of the qubit is blurred, often referred to either T<sub class="subscript">2</sub> or T<sub class="subscript">2</sub>*. Dephasing is quite like decoherence in that we will also lose state information over time, only in a slightly different manner.</p>
    <p class="normal">To define dephasing simply means to lose phase information, of a qubit in this case.</p>
    <p class="normal">There are many different sources for dephasing noise, each of which has varying properties. A few examples are:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">White noise</strong>, when there <a id="_idIndexMarker1125"/>is an equal amount of a signal that is of equal intensity at varying frequencies.</li>
      <li class="bulletList"><strong class="keyWord">Pink noise</strong>, often referred <a id="_idIndexMarker1126"/>to as flicker noise, occurs usually in electronic devices where the power density decreases with increasing frequency, i.e., 1/f, where f is the frequency.</li>
      <li class="bulletList"><strong class="keyWord">Flux noise</strong>, is <a id="_idIndexMarker1127"/>found on the surface of <strong class="keyWord">superconducting quantum interference devices</strong>, commonly referred to as <strong class="keyWord">SQUIDS</strong>, the source of which are the magnetic spins on the surface of the SQUID.</li>
    </ul>
    <p class="normal">Short of converting this from a developer to an engineering book, I will include some references to these as well, should you want to learn more about them, at the end of this chapter.</p>
    <p class="normal">Now that we have a basic understanding of noise, let’s learn what the differences are between error suppression, error mitigation, and error correction and how we can use them to create useful quantum applications.</p>
    <h2 id="_idParaDest-176" class="heading-2">Differences between error suppression, mitigation, and correction</h2>
    <p class="normal">In <a id="_idIndexMarker1128"/>the <a id="_idIndexMarker1129"/>previous <a id="_idIndexMarker1130"/>section, <a id="_idIndexMarker1131"/>we <a id="_idIndexMarker1132"/>discussed <a id="_idIndexMarker1133"/>some sources of errors that can be introduced to your quantum circuit when running them on a quantum system. Here, we will define the various ways to eliminate these errors from your quantum circuit to obtain optimal results. We’ll begin by first defining what the differences between suppressing, mitigating, and correcting errors.</p>
    <p class="normal"><strong class="keyWord">Error suppression</strong> is just as the <a id="_idIndexMarker1134"/>name states, suppressing the noise of a given circuit so that the quantum state remains intact. The specific noise here could be either the decoherence time of a qubit (amplitude dampening) or dephasing. As we learned earlier, if a qubit is placed in a specific state and left there over some long period of time, that qubit will eventually return to the ground state, or some state that is different from the set state. What we would like to do here is suppress this by keeping the circuit in the current state. Of course, this is easier said than done. Let’s first think about this intuitively, and then get into the details.</p>
    <p class="normal">Returning to our gym scenario from earlier, let’s now assume you are lifting a very heavy set of weights over your chest from a laying position on the workout bench, bench-pressing. There is a risk here that the weight, over time, starts to feel heavier due to the strain your muscles are feeling. This is why you see most people that do this have, standing very close to the weights, a spotter. This is someone who helps you either when you are fatigued and need a little help, or helps lift the weight off your chest when your muscles just suddenly give up. There are many videos I’m sure you can find online where you can see the terrible results when there’s no spotter around, but for now, let’s elaborate on what this has to do with error suppression.</p>
    <p class="normal">If you imagine that you need to sustain the weight over your head for a long period of time, you’ll realize that over time your muscles will strain; we aligned this to decoherence earlier. To help with this, your spotter can assist by gently helping you raise the bar back up so you can maintain your initial position, or state in this case. That assistance from your spotter can be seen as error suppression in that it helped maintain your state while not changing the state itself, meaning you’re not holding it any higher or lower than expected to count as a lift. Now, let’s get out of the gym and switch our context back to quantum and see how this helps us understand error suppression with respect to a quantum circuit.</p>
    <p class="normal">When a gate or set of gates is applied to a qubit within a circuit, that circuit may, over some period of time, lose its state in many ways, some of which we mentioned earlier. What we need to do is apply a technique in which we can help the circuit maintain its state. Yes, this sounds like the definition of error correction, but let me take a moment to elaborate on that to identify the difference. To do that I’ll explain a new Pass (recall that a Pass is an object used to optimize a circuit, such as finding an optimal layout mapping, or optimal qubits) that <a id="_idIndexMarker1135"/>was added to Qiskit called <strong class="keyWord">Dynamical Decoupling</strong> (<strong class="keyWord">DD</strong>). Dynamical decoupling is a well-known technique that was described back in 1998 by Dr. Seth Lloyd and Dr. Lorenza Viola from MIT (<a href="https://arxiv.org/abs/quant-ph/9803057"><span class="url">https://arxiv.org/abs/quant-ph/9803057</span></a> ). They describe it as a form of using control pulses to minimize the diffusion of the state of the qubit. This is generally done by applying the same gate operation twice, which mimics an identity gate. We learned about this earlier when we explained that most universal quantum gates are reversible, hence by applying two reversible gates back-to-back, you end up with the identity gate. So, how does this work, you ask? I’m glad you did, here we go! </p>
    <p class="normal">If you recall from <em class="italic">Chapter 7</em>,<em class="italic"> Programming with Qiskit</em>; <em class="italic">Understanding pulses, and Pulse Library</em> section when we described that when running your circuit on a quantum computer, you <a id="_idIndexMarker1136"/>must first create a pulse schedule, which is <a id="_idIndexMarker1137"/>what dictates to the control systems the pulses to the qubits by following the pulse schedule in order. You may also <a id="_idIndexMarker1138"/>recall that the pulse schedule includes <a id="_idIndexMarker1139"/>information regarding the pulse, but also the duration of the pulse and the time gaps in between pulses. Luckily for us, we learned that <a id="_idIndexMarker1140"/>all of this is done for us with the Transpiler and <a id="_idIndexMarker1141"/>the <code class="inlineCode">PassManager</code>. Once the pulse schedule is created to run on the specific quantum system, the Dynamical Decoupling Pass takes a run through it before running on the system. What the DD Pass looks for is idle time gaps between pulse signals, and it inserts a sequence of gates into those gaps. Remember that since the gates are reversible and we do not want to alter the state or phase of the circuit, it will apply a pair of gates to ensure that it sustains the action of a unitary gate. Let’s go to the code and see this in action to get a better idea.</p>
    <p class="normal">First, we’ll import some of the objects and functions we need to get started.</p>
    <pre class="programlisting code"><code class="hljs-code">%run helper_file_1<span class="hljs-number">.0</span>.ipynb
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> qiskit.circuit.library <span class="hljs-keyword">import</span> XGate
<span class="hljs-keyword">from</span> qiskit.transpiler <span class="hljs-keyword">import</span> PassManager, InstructionDurations
<span class="hljs-keyword">from</span> qiskit.transpiler.passes <span class="hljs-keyword">import</span> ALAPScheduleAnalysis, PadDynamicalDecoupling
<span class="hljs-keyword">from</span> qiskit.visualization <span class="hljs-keyword">import</span> timeline_drawer
</code></pre>
    <p class="normal">Let’s go over what we are importing here. First, from the Transpiler, we’re pulling in <code class="inlineCode">PassManager</code> and <code class="inlineCode">InstructionDurations</code>. <code class="inlineCode">PassManager</code> is what manages the Passes used to optimize our quantum circuits during transpilation. <code class="inlineCode">InstructionDurations</code> is basically just that; it stores the durations of all the gates, timescales (dt), to the selected backend system. Let’s pull the durations for a random backend system to try this out. Check which backends are availale as the systems may change over time.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Select a random backend you have access to, or pick the least busy:</span>
backend = service.get_backend(<span class="hljs-string">'ibm_kyoto'</span>)
<span class="hljs-comment"># Pull and print the duration times of the backend system for each get per qubit:</span>
dur = InstructionDurations.from_backend(backend)
<span class="hljs-built_in">print</span>(dur)
</code></pre>
    <p class="normal">The following <a id="_idIndexMarker1142"/>is a truncated example of the outputs, in this <a id="_idIndexMarker1143"/>case the X gates. Since <code class="inlineCode">ibm_kyoto</code> is a 127-qubit device, we see that the durations shown are indexed to identify the duration <a id="_idIndexMarker1144"/>time for the x-gate and its corresponding <a id="_idIndexMarker1145"/>qubit. Note that the actual results will be <a id="_idIndexMarker1146"/>a list of all gate durations between all qubits; the <a id="_idIndexMarker1147"/>following is just a subset of the results:</p>
    <pre class="programlisting code"><code class="hljs-code">x(<span class="hljs-number">0</span>,): <span class="hljs-number">3.5555555555555554e-08</span> s
x(<span class="hljs-number">1</span>,): <span class="hljs-number">3.5555555555555554e-08</span> s
x(<span class="hljs-number">2</span>,): <span class="hljs-number">3.5555555555555554e-08</span> s
x(<span class="hljs-number">3</span>,): <span class="hljs-number">3.5555555555555554e-08</span> s
x(<span class="hljs-number">4</span>,): <span class="hljs-number">3.5555555555555554e-08</span> s
</code></pre>
    <p class="normal">Qiskit also provides you with the ability to set the durations yourself for each gate. This allows you to have a bit more control should you want to modify them for specific devices. The following illustrates how to do this for all gates:</p>
    <pre class="programlisting code"><code class="hljs-code"> <span class="hljs-comment"># Set the duration times for each gate.</span>
custom_duration_times = InstructionDurations([(<span class="hljs-string">'x'</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">100</span>),
                                              (<span class="hljs-string">'h'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>),
                                              (<span class="hljs-string">"cx"</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-number">200</span>),
                                              (<span class="hljs-string">"cx"</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">200</span>), 
                                              (<span class="hljs-string">"cx"</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">200</span>),
                                              (<span class="hljs-string">"</span><span class="hljs-string">measure"</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">500</span>
                                                  )])
<span class="hljs-comment"># Print the timescales for each gate we set:</span>
<span class="hljs-built_in">print</span>(custom_duration_times)
</code></pre>
    <p class="normal">Here, we have set the following custom duration times for each gate: </p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Gate</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Duration</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">x</p>
          </td>
          <td class="table-cell">
            <p class="normal">100</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">h</p>
          </td>
          <td class="table-cell">
            <p class="normal">100</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">cx[0,1]</p>
          </td>
          <td class="table-cell">
            <p class="normal">200</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">cx[1,2]</p>
          </td>
          <td class="table-cell">
            <p class="normal">200</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">cx[2,3]</p>
          </td>
          <td class="table-cell">
            <p class="normal">200</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">measure</p>
          </td>
          <td class="table-cell">
            <p class="normal">500</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 10.1: Custom gate duration times</p>
    <p class="normal">Next, we will visualize the circuit duration in a nice timeline. To visualize the circuit and its timeline, we will need to transpile the circuit using a <em class="italic">scheduling method</em> to a backend. A scheduling <a id="_idIndexMarker1148"/>method is how the <code class="inlineCode">transpiler</code> will schedule <a id="_idIndexMarker1149"/>the operations to the qubits, for example, as soon as possible when the qubit is ready for the next instruction, or you can have it <a id="_idIndexMarker1150"/>scheduled for later, which basically keeps the qubit <a id="_idIndexMarker1151"/>in the ground state when possible. For these examples, we will use the <strong class="keyWord">alap</strong> scheduling method, which is an acronym for <em class="italic">as late as possible</em>. You <a id="_idIndexMarker1152"/>can find details about the various <a id="_idIndexMarker1153"/>scheduling methods in the Qiskit API documentation.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">#Let's transpile the circuit and view the default timeline</span>
transpiled_qc = transpile(qc, backend, scheduling_method=<span class="hljs-string">'alap'</span>,
layout_method=<span class="hljs-string">'trivial'</span>)
timeline_drawer(transpiled_qc, time_range=[<span class="hljs-number">0</span>,<span class="hljs-number">5500</span>], show_idle=<span class="hljs-literal">False</span>)
</code></pre>
    <p class="normal">This will print out a visual representation of the gate duration. It will look very much like the pulse schedule we learned about earlier; however, this is the circuit and not the pulse schedule. You can tell because we see the qubit labels on the left and not the drive </p>
    <p class="normal">channels. Also note that CX gates have taken on the label of <strong class="screenText">ecr</strong> in this case.</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_08.png" alt="A screenshot of a computer  Description automatically generated" width="825" height="252"/></figure>
    <p class="packt_figref">Figure 10.8: Circuit timeline visualization</p>
    <p class="normal">As shown in <em class="italic">Figure 10.8</em>, this is the specified duration for each gate that is based on the selected backend. We will use this duration to visualize some of the error suppression features included in Qiskit, particularly Dynamical Decoupling.</p>
    <p class="normal">The way <a id="_idIndexMarker1154"/>Dynamical Decoupling works is that it will search for <a id="_idIndexMarker1155"/>idle time in your circuit and insert a sequence of Dynamical Decoupling gates to those idle time slots to ensure that the qubit’s <a id="_idIndexMarker1156"/>state is not altered. The pair of reversible <a id="_idIndexMarker1157"/>gates used will operate equally to that of an Identity gate so that it does not alter the state of the circuit. Let’s use our custom <a id="_idIndexMarker1158"/>duration times and a pair of X gates to create the <a id="_idIndexMarker1159"/>Dynamical Decoupling sequence of reversible gates.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Create the Dynamical Decoupling sequence of reversible gates, let's use XGates:</span>
rev_gates = [XGate(), XGate()]
<span class="hljs-comment"># Set the PassManager with the Dynamical Decoupling sequence and custom duration times</span>
pm = PassManager([ALAPScheduleAnalysis(custom_duration_times),
                  PadDynamicalDecoupling(custom_duration_times, rev_gates)])
</code></pre>
    <p class="normal">What we have defined is the pair of reversible gates that mimic an Identity gate. In this case, we are using a pair of X gates. Then, we instantiated our <code class="inlineCode">PassManager</code>, which is what manages which Passes to use to optimize our circuit during the transpilation phase. In this case, we are setting the <code class="inlineCode">alap</code> scheduling method and Dynamical Decoupling times to the custom duration times we created earlier. Also included are the reversible gates as an argument to the constructor.</p>
    <p class="normal">Next, we want to run our transpiled circuit through the <code class="inlineCode">PassManager</code> we just created to produce the altered circuit with the Dynamical Decoupling included:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Run the circuit through the PassManager to add the DD to the circuit</span>
qc_dynamical_decoupling = pm.run(transpiled_qc)
</code></pre>
    <p class="normal">Now, let’s <a id="_idIndexMarker1160"/>visualize this circuit and compare it to the previous <a id="_idIndexMarker1161"/>circuit in <em class="italic">Figure 10.9</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">timeline_drawer(qc_dynamical_decoupling, show_idle=<span class="hljs-literal">False</span>)
</code></pre>
    <p class="normal">This will <a id="_idIndexMarker1162"/>draw the circuit with the error suppression <a id="_idIndexMarker1163"/>of the Dynamical Decoupling added. You can see <a id="_idIndexMarker1164"/>the X gates that have been added to the first qubit, q<sub class="subscript">0</sub>.</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_09.png" alt="A screenshot of a computer  Description automatically generated" width="825" height="257"/></figure>
    <p class="packt_figref">Figure 10.9: Visualization of the Dynamical Decoupling circuit</p>
    <p class="normal">Here, we <a id="_idIndexMarker1165"/>can observe a couple of things. First, that the gate durations are smaller due to the custom duration we set when compared to the previous circuit. Next, you will also note that the inserted X gates were added to the first qubit only, and not to the space after the second qubit, q<sub class="subscript">1</sub>. This is because the idle time gap is shorter than that of the two X gates, therefore the gate pairs were not added. Let’s make a quick yet significant adjustment to the custom duration time to include a pair of X gates after the second qubit by increasing the duration from 50 to 1500. Since we are only updating the value of one gate, we can just update the value of the gate without restating the other gates by using the <code class="inlineCode">update()</code> function, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Update durations</span>
updated_values = [(<span class="hljs-string">'x'</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">1500</span>)]
updated_durations = custom_duration_times.update(updated_values)
<span class="hljs-built_in">print</span>(updated_durations)
</code></pre>
    <p class="normal">Now, let’s <a id="_idIndexMarker1166"/>retry and see what we get back this time. Here, <a id="_idIndexMarker1167"/>we will set the parameters with the <a id="_idIndexMarker1168"/>updated values and rerun the <code class="inlineCode">PassManager</code> and <a id="_idIndexMarker1169"/>visualize the results:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Set the PassManager with the Dynamical Decoupling sequence and custom duration times</span>
pm = PassManager([ALAPScheduleAnalysis(updated_durations),
                  PadDynamicalDecoupling(updated_durations, rev_gates)])
qc_dynamical_decoupling = pm.run(transpiled_qc)
timeline_drawer(qc_dynamical_decoupling, show_idle=<span class="hljs-literal">False</span>)
</code></pre>
    <p class="normal">This will <a id="_idIndexMarker1170"/>now produce two sets of reversible gates, one as <a id="_idIndexMarker1171"/>before, and now a second set, which we can see after the second qubit. Since we have reduced the duration time, it can now fit in the idle time gap at the end of the second qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_10_10.png" alt="A screenshot of a computer  Description automatically generated" width="825" height="254"/></figure>
    <p class="packt_figref">Figure 10.10: Visualization of circuit with updated duration times</p>
    <p class="normal">As <em class="italic">Figure 10.10</em> illustrates, we can set the duration time of each gate. In this case, we increased the duration so we can see the changes. However, in many cases you need to reduce it to try to squeeze in our reversible gates to fill in the idle time gaps as needed. But, of course, like anything else, we do not necessarily need to do all this fine tuning ourselves. Thankfully for us, the Qiskit Runtime includes optimization and <strong class="keyWord">resilience levels</strong> that we can set to enable these features for us, as described earlier in this chapter when we discussed the various optimization levels we can set in the Options, which include enabling Dynamical Decoupling.</p>
    <p class="normal">Now that we have covered an example of error suppression, let’s continue and look at error mitigation.</p>
    <p class="normal">First, before we begin defining what <strong class="keyWord">error mitigation </strong>is, let me cover what <strong class="keyWord">error correction</strong> is and how it is different. Error correction in general is composed of two steps: first identifying that an error has occurred and second, correcting that error using various <a id="_idIndexMarker1172"/>error correcting techniques. Error mitigation <a id="_idIndexMarker1173"/>on the other hand uses the errors to calculate <a id="_idIndexMarker1174"/>and determine an outcome that reduces <a id="_idIndexMarker1175"/>yet does not necessarily eliminate the error itself.</p>
    <p class="normal">There are <a id="_idIndexMarker1176"/>various error mitigating techniques, and <a id="_idIndexMarker1177"/>much research is still ongoing to find more optimal ways to reduce errors. At the time of writing, three techniques are used to mitigate errors that are included into the Qiskit Runtime resilience level options: <strong class="keyWord">TREX</strong>, <strong class="keyWord">ZNE</strong>, and <strong class="keyWord">PEC</strong>. Details regarding each are linked earlier in this chapter, where we defined the resilience levels. Each of these techniques uses classical resources to perform their tasks. This of course introduces overhead into our application. However, there are advances released regularly that reduce a lot of the overhead to optimize speed, quality, and scalability. By continuing to do this we can surely over time reach a level of quantum utility that will mean the cost to implement a complex quantum circuit may be substantially lower than that of classical simulations.</p>
    <p class="normal">Thankfully, again, Qiskit makes it easy for us to set the levels of error mitigation using the resilience levels to activate specific error mitigation techniques. In the following code snippet, we will run a circuit first without any error suppression or mitigation techniques, and then we will create one that will use Dynamical Decoupling for error suppression and TREX for error mitigation.</p>
    <p class="normal">We’ll start with no error suppression or mitigation:</p>
    <pre class="programlisting code"><code class="hljs-code">least_busy_backend = service.least_busy(simulator=<span class="hljs-literal">False</span>, operational=<span class="hljs-literal">True</span>,    
                         min_num_qubits=transpiled_qc.num_qubits)
<span class="hljs-comment"># Let's transpile the circuit to this new backend:</span>
transpiled_qc=transpile(qc, backend=least_busy_backend)
options = Options()
options.execution.shots = <span class="hljs-number">1000</span>
options.optimization_level = <span class="hljs-number">0</span>  <span class="hljs-comment"># No error suppression</span>
options.resilience_level = <span class="hljs-number">0</span>  <span class="hljs-comment"># No error mitigation</span>
<span class="hljs-keyword">with</span> Session(service=service, backend=least_busy_backend) <span class="hljs-keyword">as</span> session:
    sampler = Sampler(session=session, options=options)
    job_sim_0 = sampler.run(transpiled_qc)
    <span class="hljs-built_in">print</span>(job_sim_0.result())
    session.close()
plot_distribution(job_sim_0.result().quasi_dists)
</code></pre>
    <p class="normal">The results <a id="_idIndexMarker1178"/>are <a id="_idIndexMarker1179"/>as follows <a id="_idIndexMarker1180"/>when running the Sampler, and <a id="_idIndexMarker1181"/>you should see a visual representation <a id="_idIndexMarker1182"/>of the results as well:</p>
    <pre class="programlisting code"><code class="hljs-code">SamplerResult(quasi_dists=[{<span class="hljs-number">0</span>: <span class="hljs-number">0.463</span>, <span class="hljs-number">1</span>: <span class="hljs-number">0.011</span>, <span class="hljs-number">2</span>: <span class="hljs-number">0.006</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0.008</span>, <span class="hljs-number">4</span>: <span class="hljs-number">0.008</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0.001</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0.009</span>, <span class="hljs-number">8</span>: <span class="hljs-number">0.01</span>, <span class="hljs-number">9</span>: <span class="hljs-number">0.001</span>, <span class="hljs-number">10</span>: <span class="hljs-number">0.008</span>, <span class="hljs-number">11</span>: <span class="hljs-number">0.01</span>, <span class="hljs-number">12</span>: <span class="hljs-number">0.006</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0.014</span>, <span class="hljs-number">14</span>: <span class="hljs-number">0.099</span>, <span class="hljs-number">15</span>: <span class="hljs-number">0.346</span>}], metadata=[{<span class="hljs-string">'shots'</span>: <span class="hljs-number">1000</span>}])
</code></pre>
    <p class="normal">Next, we will <a id="_idIndexMarker1183"/>enable both Dynamical Decoupling and TREX:</p>
    <pre class="programlisting code"><code class="hljs-code">options.execution.shots = <span class="hljs-number">1000</span>
options.optimization_level = <span class="hljs-number">3</span>  <span class="hljs-comment"># Levels 1-3 use Dynamical Decoupling</span>
options.resilience_level = <span class="hljs-number">1</span>  <span class="hljs-comment"># Level 1 uses TREX for error mitigation</span>
<span class="hljs-keyword">with</span> Session(service=service, backend=least_busy_backend) <span class="hljs-keyword">as</span> session:
    sampler = Sampler(session=session, options=options)
    job_sim_1 = sampler.run(transpiled_qc)
    <span class="hljs-built_in">print</span>(job_sim_1.result())
    session.close()
plot_distribution(job_sim_1.result().quasi_dists)
</code></pre>
    <p class="normal">Here, we set the <code class="inlineCode">optimization_level</code> to <code class="inlineCode">3</code>, which will enable Dynamical Decoupling, and the <code class="inlineCode">resilience_level</code> to <code class="inlineCode">1</code>, which uses TREX for error mitigation. Note the difference in the <a id="_idIndexMarker1184"/>results are much more refined and the metadata <a id="_idIndexMarker1185"/>includes the added overhead and mitigation time:</p>
    <pre class="programlisting code"><code class="hljs-code">SamplerResult(quasi_dists=[{<span class="hljs-number">0</span>: <span class="hljs-number">0.4741007821539706</span>, <span class="hljs-number">1</span>: -<span class="hljs-number">0.00328801216329741</span>, <span class="hljs-number">2</span>: -<span class="hljs-number">0.006989853410409116</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0.0018169643386157586</span>, <span class="hljs-number">4</span>: -<span class="hljs-number">0.005096477885881826</span>, <span class="hljs-number">5</span>: <span class="hljs-number">0.00010104383589854057</span>, <span class="hljs-number">6</span>: <span class="hljs-number">0.0016676295409465852</span>, <span class="hljs-number">7</span>: <span class="hljs-number">0.0017229622606998135</span>, <span class="hljs-number">8</span>: <span class="hljs-number">0.0038884349758400295</span>, <span class="hljs-number">11</span>: -<span class="hljs-number">0.0025386992448873155</span>, <span class="hljs-number">12</span>: <span class="hljs-number">0.0014124334608473367</span>, <span class="hljs-number">13</span>: <span class="hljs-number">0.0009761688074426505</span>, <span class="hljs-number">14</span>: <span class="hljs-number">3.0231076968467426e-05</span>, <span class="hljs-number">15</span>: <span class="hljs-number">0.5321963922532457</span>}], metadata=[{<span class="hljs-string">'shots'</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">'</span><span class="hljs-string">readout_mitigation_overhead'</span>: <span class="hljs-number">1.6922534955446735</span>, <span class="hljs-string">'readout_mitigation_time'</span>: <span class="hljs-number">0.059042368084192276</span>}])
</code></pre>
    <p class="normal">This and <a id="_idIndexMarker1186"/>many other error suppression and mitigation <a id="_idIndexMarker1187"/>methods are increasing in popularity among <a id="_idIndexMarker1188"/>researchers as they try to understand the effects <a id="_idIndexMarker1189"/>of noise and determine optimal ways to mitigate against them in the hopes of accelerating our path from quantum utility towards quantum advantage.</p>
    <h1 id="_idParaDest-177" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered some of the many effects that noise has on a quantum computing system, both specific to the qubit and externally with respect to the quantum system itself via readout errors. We discovered how we can use the Qiskit Runtime service to run our circuits using the fundamental building blocks known as Primitives. Finally, we learned how to apply error suppression and mitigation techniques to our quantum circuits so to filter the noisy results from a quantum device, which significantly reduces errors and provides more accurate results to complex quantum circuits.</p>
    <p class="normal">In the next chapter, we will learn how to create quantum applications using the many features available in Qiskit. We will look at creating quantum algorithms, and ultimately provide you with all the tools you need to create your own quantum algorithms and quantum applications.</p>
    <h1 id="_idParaDest-178" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">List the three main error mitigation techniques used by the Qiskit Runtime service.</li>
      <li class="numberedList">Which resilience levels are used for error mitigation?</li>
      <li class="numberedList">What other reversible gates could you use to fill in the idle time of a qubit using Dynamical Decoupling?</li>
      <li class="numberedList">Which type of noise contributes to amplitude dampening of a qubit?</li>
      <li class="numberedList">Which type of noises contribute to dephasing of a qubit?</li>
    </ol>
    <h1 id="_idParaDest-179" class="heading-1">Further reading</h1>
    <ul>
      <li class="bulletList">IBM Quantum Learning platform: <a href="https://learning.quantum.ibm.com"><span class="url">https://learning.quantum.ibm.com</span></a></li>
      <li class="bulletList">Evidence for the utility of quantum computing before fault tolerance: <a href="https://www.nature.com/articles/s41586-023-06096-3"><span class="url">https://www.nature.com/articles/s41586-023-06096-3</span></a></li>
      <li class="bulletList">Quasi-probability decompositions with reduced sampling overhead: <a href="https://www.nature.com/articles/s41534-022-00517-3"><span class="url">https://www.nature.com/articles/s41534-022-00517-3</span></a></li>
      <li class="bulletList">Dynamical suppression of decoherence in two-state quantum systems: <a href="https://arxiv.org/pdf/quant-ph/9803057.pdf"><span class="url">https://arxiv.org/pdf/quant-ph/9803057.pdf</span></a></li>
      <li class="bulletList">Error mitigation in short depth circuits: <a href="https://arxiv.org/pdf/1612.02058.pdf"><span class="url">https://arxiv.org/pdf/1612.02058.pdf</span></a></li>
      <li class="bulletList">Sutor, B., <em class="italic">Dancing with Qubits</em>, Packt Publishing: <a href="https://www.packtpub.com/data/dancing-with-qubits%0D%0A"><span class="url">https://www.packtpub.com/data/dancing-with-qubits</span></a></li>
      <li class="bulletList">Nielsen, M. &amp; Chuang, I., <em class="italic">Quantum Computation and Quantum Information</em>, Cambridge University Press: <a href="https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition"><span class="url">https://www.cambridge.org/us/academic/subjects/physics/quantum-physics-quantum-information-and-quantum-computation/quantum-computation-and-quantum-information-10th-anniversary-edition</span></a></li>
      <li class="bulletList">Wootton, J., <em class="italic">What is Quantum Error Correction?</em>, Medium Series: <a href="https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398%0D%0A%0D%0A"><span class="url">https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398</span></a></li>
    </ul>
    <p class="normal"><a href="https://decodoku.medium.com/1-what-is-quantum-error-correction-4ab6d97cb398%0D%0A%0D%0A"/></p>
    <h1 id="_idParaDest-180" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_10.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code261762599683826593.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>