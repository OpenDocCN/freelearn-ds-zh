<html><head></head><body>
<p class="calibre1">def display_map(self):</p>
<p class="calibre1">"""Opens and displays a map image file. </p>
<p class="calibre1">:param image_file: Path to the image. </p>
<p class="calibre1">""" </p>
<p class="calibre1">image = cv2.imread(self.output_image)</p>
<p class="calibre1">cv2.imshow('image', image)</p>
<p class="calibre1">cv2.waitKey(0)</p>
<p class="calibre1">cv2.destroyAllWindows()</p>
<p class="calibre1">This function now uses the output_image property to display the map and takes no arguments apart from the class instance (self) when called. </p>
<p class="calibre1">Next, let’s work on the create_map function. </p>
<p class="calibre1">8.  Copy the create_map function from the map_functions.py file and make the following changes to the class:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">class MapMakerApp(object):</p>
<p class="calibre1">def __init__(self, output_image="map.png", </p>
<p class="calibre1">style_file="map_maker/styles.xml", </p>
<p class="calibre1">map_size=(800, 600)):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param output_image: Path to the image output of the map. </p>
<p class="calibre1">:param style_file: Mapnik XML file containing only the style for the map. </p>
<p class="calibre1">:param map_size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.output_image = output_image</p>
<p class="calibre1">self.style_file = style_file</p>
<p class="calibre1">self.map_size = map_size</p>
<p class="calibre1">def display_map(self):</p>
<p class="calibre1">"""Opens and displays a map image file.""" </p>
<p class="calibre1">image = cv2.imread(self.output_image)</p>
<p class="calibre1">cv2.imshow('image', image)</p>
<p class="calibre1">cv2.waitKey(0)</p>
<p class="calibre1">cv2.destroyAllWindows()</p>
<p class="calibre1">def create_map(self):</p>
<p class="calibre1">"""Creates a map and writes it to a file.""" </p>
<p class="calibre1">map = mapnik.Map(*self.map_size)</p>
<p class="calibre1">mapnik.load_map(map, self.style_file)</p>
<p class="calibre1">layers = map.layers</p>
<p class="calibre1"><a id="p266"/>        map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, self.output_image)</p>
<p class="calibre1">As we did with display_map, now the create_map function takes no arguments (except for self) and all parameters come from the instance attributes, the ones that were added to the __init__ method. We also improved the default values for those arguments. </p>
<p class="calibre1">All the layer and data source definitions were removed from create_map because in the next steps we will plug in the PythonDatasource that we created earlier. </p>
<p class="calibre1"><a id="p267"/><b class="calibre3">Using PythonDatasource</b></p>
<p class="calibre1">To use this type of data source and implement the ability to display any number of data sources on the map, we will make our app class take control of the organization of the layers and the data that they use, always following the premise that the application should have a high level of abstraction:</p>
<p class="calibre1">1.  Include this import at the beginning of the file:</p>
<p class="calibre1">from map_maker.my_datasource import MapDatasource</p>
<p class="calibre1">2.  Modify the class __init__ method and create an add_layer method, as follows: class MapMakerApp(object):</p>
<p class="calibre1">def __init__(self, output_image="map.png", </p>
<p class="calibre1">style_file="map_maker/styles.xml", </p>
<p class="calibre1">map_size=(800, 600)):</p>
<p class="calibre1">"""Application class. </p>
<p class="calibre1">:param output_image: Path to the image output of the map. </p>
<p class="calibre1">:param style_file: Mapnik XML file containing only the style for the map. </p>
<p class="calibre1">:param map_size: Size of the map in pixels. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.output_image = output_image</p>
<p class="calibre1">self.style_file = style_file</p>
<p class="calibre1">self.map_size = map_size</p>
<p class="calibre1">self._layers = {}</p>
<p class="calibre1">def display_map(self):... </p>
<p class="calibre1">def create_map(self):... </p>
<p class="calibre1">def add_layer(self, geo_data, name, style='style1'):</p>
<p class="calibre1">"""Add data to the map to be displayed in a layer with a given style. </p>
<p class="calibre1">:param geo_data: a BaseGeoCollection subclass instance. </p>
<p class="calibre1">""" </p>
<p class="calibre1">data source = mapnik.Python(factory='MapDatasource', </p>
<p class="calibre1">data=geo_data)</p>
<p class="calibre1">layer = {"data source": data source, </p>
<p class="calibre1">"data": geo_data, </p>
<p class="calibre1">"style": style}</p>
<p class="calibre1">self._layers[name] = layer</p>
<p class="calibre1">What we did here is use a private attribute (_layers) to keep track of the layers that we will use by their names. The add_layer method is responsible for instantiating the MapDatasource class and passing to it the data. </p>
<p class="calibre1">The data that we will use here is a subclass of BaseGeoCollection that we used in the previous chapters. With this, we will manipulate the map using only high-level objects, and also get all their functionality for free. </p>
<p class="calibre1">As we said before,  <i class="calibre4">Python Datasource does not work on Windows</i>, so we need to</p>
<p class="calibre1"><a id="p268"/>create a workaround to make things work despite the operating system. What we are going to do is save the data to a temporary file and then use Mapnik’s GeoJSON</p>
<p class="calibre1">plugin to create a data source. </p>
<p class="calibre1">3.  Add these imports to the beginning of the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1"><b class="calibre3">import platform</b></p>
<p class="calibre1"><b class="calibre3">import tempfile</b></p>
<p class="calibre1"><b class="calibre3">from models import BoundaryCollection, PointCollection</b></p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import mapnik</p>
<p class="calibre1">4.  Now let’s create a folder to hold our temporary files. Create a new folder named temp inside your Chapter5 folder. </p>
<p class="calibre1">5.  Modify the add_layer method to include the workaround:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def add_layer(self, geo_data, name, style='style1'):</p>
<p class="calibre1">"""Add data to the map to be displayed in a layer with a given style. </p>
<p class="calibre1">:param geo_data: a BaseGeoCollection subclass instance. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if platform.system() == "Windows":</p>
<p class="calibre1">print("Windows system")</p>
<p class="calibre1">temp_file, filename = tempfile.mkstemp(dir="temp") print temp_file, filename</p>
<p class="calibre1">geo_data.export_geojson(filename)</p>
<p class="calibre1">data source = mapnik.GeoJSON(file=filename)</p>
<p class="calibre1">else:</p>
<p class="calibre1">data source = mapnik.Python(factory='MapDatasource', </p>
<p class="calibre1">data=geo_data)</p>
<p class="calibre1">layer = {"data source": data source, </p>
<p class="calibre1">"data": geo_data, </p>
<p class="calibre1">"style": style}</p>
<p class="calibre1">self._layers[name] = layer</p>
<p class="calibre1">Here, we used platform.system() to detect whether the operating system is Windows. If so, instead of creating a Python DataSource, it creates a temporary file and exports geo_data to it. Then we use the GeoJSON plugin to open that file, creating a DataSource. </p>
<p class="calibre1">Now that the workaround is complete, we need to go back to the MapDatasource definition and make it accept the data that we are passing to it. </p>
<p class="calibre1">6.  In the my_datasource.py file, include the following __init__ method in the MapDatasource class:</p>
<p class="calibre1">class MapDatasource(mapnik.PythonDatasource):</p>
<p class="calibre1">"""Implementation of Mapinik's PythonDatasource.""" </p>
<p class="calibre1">def __init__(self, data):</p>
<p class="calibre1">super(MapDatasource, self).__init__(envelope, geometry_type, data_type)</p>
<p class="calibre1"><a id="p269"/>       </p>
<p class="calibre1">self.data = data</p>
<p class="calibre1">def features(self, query=None):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">Our subclass of PythonDatasource now takes one obligatory data argument. Since we are increasing the level of abstraction, we will make the MapDatasource class define all the other arguments automatically by inspecting the data it receives; with this change, we won’t need to worry about the geometry type or data type. </p>
<p class="calibre1">7.  Make another change to the __init__ method:</p>
<p class="calibre1">class MapDatasource(mapnik.PythonDatasource):</p>
<p class="calibre1">"""Implementation of Mapinik's PythonDatasource.""" </p>
<p class="calibre1">def __init__(self, data):</p>
<p class="calibre1">data_type = mapnik.DataType.vector</p>
<p class="calibre1">if isinstance(data, PointCollection):</p>
<p class="calibre1">geometry_type = mapnik.GeometryType.Point</p>
<p class="calibre1">elif isinstance(data, BoundaryCollection):</p>
<p class="calibre1">geometry_type = mapnik.GeometryType.Polygon</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise TypeError</p>
<p class="calibre1"/>
<p class="calibre1">super(MapDatasource, self).__init__(</p>
<p class="calibre1">envelope=None, geometry_type=geometry_type, </p>
<p class="calibre1">data_type=data_type)</p>
<p class="calibre1">self.data = data</p>
<p class="calibre1">def features(self, query=None):</p>
<p class="calibre1">raise NotImplementedError</p>
<p class="calibre1">Here, isinstance() checks which type is data, and for each of the possible types it defines the corresponding geometry_type to be passed to the parent __init__</p>
<p class="calibre1">method. </p>
<p class="calibre1">For now, we only have one data type: the vector. Anyway, we will make this definition explicit (data_type = mapnik.DataType.vector) because in the next chapter, the raster type will be introduced. </p>
<p class="calibre1">Before we go any further, let’s test the app as it is. </p>
<p class="calibre1">8.  Now edit the if __name__ == '__main__': block at the end of the file: if __name__ == '__main__':</p>
<p class="calibre1">world_borders = BoundaryCollection(</p>
<p class="calibre1">"../data/world_borders_simple.shp")</p>
<p class="calibre1">map_app = MapMakerApp()</p>
<p class="calibre1">map_app.add_layer(world_borders, 'world')</p>
<p class="calibre1">map_app.create_map()</p>
<p class="calibre1">map_app.display_map()</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Note how Mapnik is completely abstracted; we now only deal with the high-level</p>
<p class="calibre1"><a id="p270"/>functionality provided by our models and the app. </p>
<p class="calibre1">9.  Run the code; you should see an empty map and an output like this in the console: File imported: ../data/world_borders_simple.shp</p>
<p class="calibre1">Windows system</p>
<p class="calibre1">File exported: \geopy\Chapter5\temp\tmpfqv9ch</p>
<p class="calibre1">The map is empty because two points are still missing: the features method, which is the glue between our geo data and the Mapnik data source, and making the create_map function use the layers that we have defined. </p>
<p class="calibre1">10.  Let’s start with the create_map method. Change its code so it can iterate over our layers and add them to the map:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def create_map(self):</p>
<p class="calibre1">"""Creates a map and writes it to a file.""" </p>
<p class="calibre1">map = mapnik.Map(*self.map_size)</p>
<p class="calibre1">mapnik.load_map(map, self.style_file)</p>
<p class="calibre1">layers = map.layers</p>
<p class="calibre1">for name, layer in self._layers.iteritems():</p>
<p class="calibre1">new_layer = mapnik.Layer(name)</p>
<p class="calibre1">new_layer.datasource = layer["data source"]</p>
<p class="calibre1">new_layer.stylers.append(layer['style'])</p>
<p class="calibre1">layers.append(new_layer)</p>
<p class="calibre1">map.zoom_all()</p>
<p class="calibre1">mapnik.render_to_file(map, self.output_image)</p>
<p class="calibre1">11.  Now edit styles.xml in order to remove the extent restriction from it:</p>
<p class="calibre1">&lt;Map background-color="white"&gt; </p>
<p class="calibre1">&lt;Style name="style1"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PolygonSymbolizer fill="#f2eff9" /&gt; </p>
<p class="calibre1">&lt;LineSymbolizer stroke="red" stroke-width="1.0" smooth="0.5" /&gt; </p>
<p class="calibre1">&lt;TextSymbolizer face-name="DejaVu Sans Book" size="10" </p>
<p class="calibre1">fill="black" halo-fill= "white" </p>
<p class="calibre1">halo-radius="1" placement="interior" </p>
<p class="calibre1">allow-overlap="false"&gt;[NAME]</p>
<p class="calibre1">&lt;/TextSymbolizer&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;Style name="style2"&gt; </p>
<p class="calibre1">&lt;Rule&gt; </p>
<p class="calibre1">&lt;PointSymbolizer file="marker.svg" transform="scale(0.3)"/&gt; </p>
<p class="calibre1">&lt;/Rule&gt; </p>
<p class="calibre1">&lt;/Style&gt; </p>
<p class="calibre1">&lt;/Map&gt; </p>
<p class="calibre1">12.  Now run the code again and look at the output. If you are using Windows, you should see a rendered map. If you are using Linux you should get an exception: Traceback (most recent call last):</p>
<p class="calibre1">File … in &lt;module&gt; </p>
<p class="calibre1"><a id="p271"/>    raise NotImplementedError</p>
<p class="calibre1">NotImplementedError</p>
<p class="calibre1">Process finished with exit code 1</p>
<p class="calibre1">If you got this exception (in Linux), it is because everything went fine and Mapnik called our unimplemented features method. </p>
<p class="calibre1">So now let’s implement this method. </p>
<p class="calibre1">13.  Go to the my_datasource.py file and edit our class:</p>
<p class="calibre1">class MapDatasource(mapnik.PythonDatasource):</p>
<p class="calibre1">"""Implementation of Mapinik's PythonDatasource.""" </p>
<p class="calibre1">def __init__(self, data):</p>
<p class="calibre1">data_type = mapnik.DataType.Vector</p>
<p class="calibre1">if isinstance(data, PointCollection):</p>
<p class="calibre1">geometry_type = mapnik.GeometryType.Point</p>
<p class="calibre1">elif isinstance(data, BoundaryCollection):</p>
<p class="calibre1">geometry_type = mapnik.GeometryType.Polygon</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise TypeError</p>
<p class="calibre1">super(MapDatasource, self).__init__(</p>
<p class="calibre1">envelope=None, geometry_type=geometry_type, </p>
<p class="calibre1">data_type=data_type)</p>
<p class="calibre1">self.data = data</p>
<p class="calibre1">def features(self, query=None):</p>
<p class="calibre1">keys = ['name',]</p>
<p class="calibre1">features = []</p>
<p class="calibre1">for item in self.data.data:</p>
<p class="calibre1">features.append([item.geom.wkb, {'name': item.name}])</p>
<p class="calibre1">return mapnik.PythonDatasource.wkb_features(keys, features) 14.  Run the code again; now you should see the rendered map in the output:</p>
<p class="calibre1"><a id="p272"/><img src="img/index-272_1.jpg" alt="Image 38" class="calibre2"/></p>
<p class="calibre1"><a id="p273"/><img src="img/index-273_1.jpg" alt="Image 39" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Using the app with filtering</b></p>
<p class="calibre1">Since the BaseGeoCollection class has filtering capabilities that were implemented before, it’s possible to filter the data before passing it to the map. </p>
<p class="calibre1">Let’s try some examples:</p>
<p class="calibre1">1.  In the map_maker_app.py file, edit the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">world_borders = BoundaryCollection(</p>
<p class="calibre1">"../data/world_borders_simple.shp")</p>
<p class="calibre1">my_country = world_borders.filter('name', 'Brazil')</p>
<p class="calibre1">map_app = MapMakerApp()</p>
<p class="calibre1">map_app.add_layer(my_country, 'countries')</p>
<p class="calibre1">map_app.create_map()</p>
<p class="calibre1">map_app.display_map()</p>
<p class="calibre1">Here, we are using the filter function of the BaseGeoCollection class to filter the countries by name; feel free to try to filter by your country. </p>
<p class="calibre1">2.  Run the code and you should see a map containing only one country (zoom should be active), as in the following screenshot:</p>
<p class="calibre1">3.  Now try combining filters to show more than one country:</p>
<p class="calibre1"><a id="p274"/><img src="img/index-274_1.jpg" alt="Image 40" class="calibre2"/></p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">world_borders = BoundaryCollection(</p>
<p class="calibre1">"../data/world_borders_simple.shp")</p>
<p class="calibre1">countries = world_borders.filter('name', 'China') +\</p>
<p class="calibre1">world_borders.filter('name', 'India') +\</p>
<p class="calibre1">world_borders.filter('name', 'Japan')</p>
<p class="calibre1">map_app = MapMakerApp()</p>
<p class="calibre1">map_app.add_layer(countries, 'countries')</p>
<p class="calibre1">map_app.create_map()</p>
<p class="calibre1">map_app.display_map()</p>
<p class="calibre1">4.  Run the code again and see the results. </p>
<p class="calibre1"><a id="p275"/>
<a id="p276"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter we saw how Mapnik works and how maps are defined and styled using both Python and XML. Using Mapnik’s Python API, it was possible to define the map in XML and then alter it in Python, showing great flexibility for all kinds of needs. </p>
<p class="calibre1">As the app was structured, Mapnik was hidden behind high-level functionalities that enabled us to use the geographic data objects that we created before, allowing the application to filter the data to be displayed in the map. </p>
<p class="calibre1">In the next chapter, we will meet raster data for the first time; we will see how it works and display it in our maps. </p>
<p class="calibre1"><a id="p277"/>
<a id="p278"/><b class="calibre3">Chapter 6. Working with Remote Sensing</b></p>
<p class="calibre1"><b class="calibre3">Images</b></p>
<p class="calibre1">In this chapter, we will start working with images—images that may come from a variety of sensors carried by satellites, drones, airplanes, and so on. These types of images, the ones collected from remote sensing devices, are images that contain pixels representing a spectral response from a given geographic region. </p>
<p class="calibre1">Besides just adding images to a map, it is important to prepare the images to be presented on the map. You may need to combine, cut, change the resolution, change values, and perform many other transformations in order to produce a visually appealing map or valuable information. </p>
<p class="calibre1">To perform these transformations on the images, we will go through a process of deduction that will result in a versatile and powerful software structure. </p>
<p class="calibre1">The topics covered here are:</p>
<p class="calibre1">Understanding how the images are represented</p>
<p class="calibre1">The relation of the images with the real world</p>
<p class="calibre1">Combining, cropping, and adjusting the values of the images Creating shaded relief maps from the elevation data</p>
<p class="calibre1">How to execute a sequence of processing steps</p>
<p class="calibre1"><a id="p279"/><img src="img/index-279_1.jpg" alt="Image 41" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Understanding how images are</b></p>
<p class="calibre1"><b class="calibre3">represented</b></p>
<p class="calibre1">In order to understand what images are in terms of computer representation and the data they contain, we are going to start with some examples. The first thing to do is to organize your project to follow this chapter’s code as follows:</p>
<p class="calibre1">1.  As before, inside your geopy project, make a copy of your Chapter5 folder and rename it to Chapter6. </p>
<p class="calibre1">2.  Inside Chapter6, navigate to the experiments folder and create a new file inside it named image_experiments.py. Open it for editing. </p>
<p class="calibre1">We will start by inspecting a small sample image that has a structure similar to a large satellite image. </p>
<p class="calibre1">Nothing fancy, you will see four squares of different colors. But if we take a step further and add a grid to it, we can see a little bit more information. </p>
<p class="calibre1"><a id="p280"/><img src="img/index-280_1.jpg" alt="Image 42" class="calibre2"/></p>
<p class="calibre1">The image was divided into 16 squares of equal size. Each one of these squares is a so-called <b class="calibre3">pixel</b>. A pixel is the smallest portion of information that an image (that is, raster data) contains. While talking about geoprocessing, the image as a whole comprehends a space in the real world and each pixel is a fraction of that space. </p>
<p class="calibre1">When we added the sample image to the map in the beginning of the chapter, we manually defined the extent of this image (that is, its bounding box). This information told Mapnik how the coordinates in the image relates to the real world coordinates. </p>
<p class="calibre1">So far, we have seen that our sample image has 16 pixels with a shape of 4 x 4. But how this image or any other raster data relates to a real world space depends on the information that may or may not be stored in the data itself. </p>
<p class="calibre1">The first information that states the relation is where the image is in the world. Images and raster data normally have their point of origin in the top left corner. If we assign a coordinate to the point of origin, we will be able to place the image on the world. </p>
<p class="calibre1">Secondly, we need information on the area that this image covers. And there are three ways this information can appear:</p>
<p class="calibre1">The size of the pixels of the image</p>
<p class="calibre1">The size of the image</p>
<p class="calibre1">The coordinates of the bounding box of the image</p>
<p class="calibre1"><a id="p281"/><img src="img/index-281_1.jpg" alt="Image 43" class="calibre2"/></p>
<p class="calibre1">This information is related by the following equations:</p>
<p class="calibre1">x_pixel_size = width / columns</p>
<p class="calibre1">y_pixel_size = height / lines</p>
<p class="calibre1">width = xmax – xmin</p>
<p class="calibre1">height = ymax – ymin</p>
<p class="calibre1"><a id="p282"/><b class="calibre3">Opening images with OpenCV</b></p>
<p class="calibre1">For a better understanding, we will open the sample image with OpenCV and inspect its contents as follows:</p>
<p class="calibre1">1.  In your image_expriments.py file, type the following code: def open_raster_file(image):</p>
<p class="calibre1">"""Opens a raster file. </p>
<p class="calibre1">:param image: Path of the raster file or np array. </p>
<p class="calibre1">""" </p>
<p class="calibre1">image = cv2.imread(image)</p>
<p class="calibre1">return image</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">image = open_raster_file('../../data/sample_image.tiff')</p>
<p class="calibre1">print(image)</p>
<p class="calibre1">print(type(image))</p>
<p class="calibre1">print(image.shape)</p>
<p class="calibre1">2.  Run the code. Since it’s the first time you have run this file, press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i></p>
<p class="calibre1">and choose image_experiments from the list. You should see the following output:</p>
<p class="calibre1">[[[  0   0 255]</p>
<p class="calibre1">[  0   0 255]</p>
<p class="calibre1">[  0 255   0]</p>
<p class="calibre1">[  0 255   0]]</p>
<p class="calibre1">[[  0   0 255]</p>
<p class="calibre1">[  0   0 255]</p>
<p class="calibre1">[  0 255   0]</p>
<p class="calibre1">[  0 255   0]]</p>
<p class="calibre1">[[255   0   0]</p>
<p class="calibre1">[255   0   0]</p>
<p class="calibre1">[100 100 100]</p>
<p class="calibre1">[100 100 100]]</p>
<p class="calibre1">[[255   0   0]</p>
<p class="calibre1">[255   0   0]</p>
<p class="calibre1">[100 100 100]</p>
<p class="calibre1">[100 100 100]]]</p>
<p class="calibre1">&lt;type 'numpy.ndarray'&gt; </p>
<p class="calibre1">(4, 4, 3)</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The expression print(type(image)) prints the type of the object that is stored in the image variable. As you can see, it’s a NumPy array with a shape of 4 x 4 x 3. OpenCV</p>
<p class="calibre1">opens the image and put its data inside an array, although for now, it is a little bit hard to visualize how the data is organized. The array contains the color information for each</p>
<p class="calibre1"><a id="p283"/>pixel on the image. </p>
<p class="calibre1">For better visualization, I’m going to reorganize the print output for you:</p>
<p class="calibre1">[[[  0   0 255] [  0   0 255] [  0 255   0] [  0 255   0]]</p>
<p class="calibre1">[[  0   0 255] [  0   0 255] [  0 255   0] [  0 255   0]]</p>
<p class="calibre1">[[255   0   0] [255   0   0] [100 100 100] [100 100 100]]</p>
<p class="calibre1">[[255   0   0] [255   0   0] [100 100 100] [100 100 100]]]</p>
<p class="calibre1">Now the shape of the array makes more sense. Notice that we have four  <i class="calibre4">lines</i> and each line has four  <i class="calibre4">columns</i> exactly as it is seen in the image. By its turn, each item has a set of three numbers that represents the values for the blue, green, and red channels. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">Remember that when you import a colored image with OpenCV, the order of the channels will be BGR (blue, green, and red). </p>
<p class="calibre1">For example, take the first pixel in the top left corner. It’s all red as we see in the image: Blue Green Red</p>
<p class="calibre1">[  0    0   255]</p>
<p class="calibre1">So, the first and the most important implication of the images being imported as NumPy arrays is that they behave like arrays and have all the functions and methods that any NumPy array has, opening the possibility of using the full power of NumPy while working with raster data. </p>
<p class="calibre1"><a id="p284"/><img src="img/index-284_1.jpg" alt="Image 44" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Knowing numerical types</b></p>
<p class="calibre1">Each pixel in the previous topic has three channels: blue, green, and red. Each one has a value ranging from 0 to 255 (256 possible values). The combination of these channels result in a visible color. This range of values is not random; 256 is the number of combinations that is possible to achieve with a single <b class="calibre3">byte</b>. </p>
<p class="calibre1">A byte is the smallest portion of data that a computer can store and retrieve from the memory. It’s composed of 8 bits of zeros or ones. </p>
<p class="calibre1">This is important to us because the computer uses its memory to store the image and it will reserve a given space to store the value for each channel for each pixel. We must be sure that the space reserved is adequate for the data we want to store. </p>
<p class="calibre1">Let’s make an abstraction. Think that you have 1 liter (1,000 ml) of water and you want to store it. If you choose a 250 ml cup to store this water, the excess will spill out. If you choose a water truck with 10,000 liter capacity, you can store the water, but it will be a huge waste of space. So, you may choose a 3 liter bucket that would be sufficient to store the water. It’s not big as a truck and you will have some extra space if you want to store a little bit more water. </p>
<p class="calibre1">In computing, things work similarly. You need to choose the size of the container before you put things in it. In the previous example, OpenCV made this choice for us. You will see a number of instances in the future where the programs we use will help us in these choices. But a clear understanding on how this works is very important because if the water spills out (that is, overflows), you will end up with unexpected behavior in your program. Or, if you choose a too large recipient, you may run out of computer memory. </p>
<p class="calibre1">The needs for value storage may vary in the aspects of:</p>
<p class="calibre1">Only positive or positive and negative numbers</p>
<p class="calibre1">Integers or fractions</p>
<p class="calibre1">Small or large numbers</p>
<p class="calibre1">Complex numbers</p>
<p class="calibre1">The available options and their sizes may vary with the computer architecture and software. For a common 64-bit desktop, NumPy will give you these possible numerical types:</p>
<p class="calibre1">bool: Boolean (True or False) stored as a byte</p>
<p class="calibre1">int8: Byte (-128 to 127)</p>
<p class="calibre1">int16: Integer (-32768 to 32767)</p>
<p class="calibre1"><a id="p285"/>int32: Integer (-2147483648 to 2147483647) int64: Integer (-9223372036854775808 to 9223372036854775807) uint8: Unsigned integer (0 to 255)</p>
<p class="calibre1">uint16: Unsigned integer (0 to 65535)</p>
<p class="calibre1">uint32: Unsigned integer (0 to 4294967295)</p>
<p class="calibre1">uint64: Unsigned integer (0 to 18446744073709551615)</p>
<p class="calibre1">float16: Half precision float: sign bit, 5 bits exponent, 10 bits mantissa float32: Single precision float: sign bit, 8 bits exponent, 23 bits mantissa float64: Double precision float: sign bit, 11 bits exponent, 52 bits mantissa complex64: Complex number represented by two 32-bit floats (real and imaginary components)</p>
<p class="calibre1">complex128: Complex number represented by two 64-bit floats (real and imaginary components)</p>
<p class="calibre1">So, we may expect that our sample image has the type uint8. Let’s check whether it’s true:</p>
<p class="calibre1">1.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">image = open_raster_file('../../data/sample_image.tiff')</p>
<p class="calibre1">print(type(image))</p>
<p class="calibre1">print(image.dtype)</p>
<p class="calibre1">2.  Run the code again. You should see an output matching our expectations:</p>
<p class="calibre1">&lt;type 'numpy.ndarray'&gt; </p>
<p class="calibre1">uint8</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p286"/>
<a id="p287"/><b class="calibre3">Processing remote sensing images and</b></p>
<p class="calibre1"><b class="calibre3">data</b></p>
<p class="calibre1">Satellite images come in a different format and serve different purposes. These images can be used to visualize features on Earth using real colors or they may be used to identify a variety of characteristics using parts of the spectrum invisible to the human eye. </p>
<p class="calibre1">As we saw, our sample image had three channels (blue, green, and red) that were combined in a single file to compose a real color image. Different from the sample image, most satellite data comes with each channel separated into a file for each one of them. </p>
<p class="calibre1">These channels are called <b class="calibre3">bands</b> and comprise of a range of the electromagnetic spectrum visible or not to the human eye. </p>
<p class="calibre1">In the following examples, we are going to use the <b class="calibre3">digital elevation models</b> (<b class="calibre3">DEM</b>) generated with the data obtained by the <b class="calibre3">Advanced Spaceborne Thermal Emission and</b> <b class="calibre3">Reflection Radiometer</b> (<b class="calibre3">ASTER</b>). </p>
<p class="calibre1">These DEM have a resolution of approximately 90 m and the values are stored in the 16</p>
<p class="calibre1">bits signed integers representing the elevation in meters. </p>
<p class="calibre1">The dataset we are going to use is included in the data folder and is from a Brazilian city called  <i class="calibre4">Poços de Caldas</i>. This city is inside a giant extinct volcano crater, a feature we hope to see during data processing. For didactic reasons and in order to cover a big region, four images will be used:</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">You can obtain more digital elevation models at <a href="http://earthexplorer.usgs.gov/">http://earthexplorer.usgs.gov/. </a></p>
<p class="calibre1">1.  If want to download and use your own DEM, you need to extract the downloaded ZIP</p>
<p class="calibre1">file. Notice that each ZIP archive has two images. The one ending with _dem is the actual elevation data. The one ending with _num contains the quality assessment information. Take a look at the included README.pdf file for more information. </p>
<p class="calibre1">2.  Move or copy all the images to the data folder of your Chapter 6 code. </p>
<p class="calibre1">Each image represents a tile of 1 degree. The information on which tile the image covers is encoded in the name of the file, as seen in the following image:</p>
<p class="calibre1"><a id="p288"/><img src="img/index-288_1.jpg" alt="Image 45" class="calibre2"/></p>
<p class="calibre1"><a id="p289"/><b class="calibre3">Mosaicking images</b></p>
<p class="calibre1">Mapnik has the ability to read tiled data from the disk using the raster data source. But we are not going to use it, because the process of patching images together is very important and is worth learning. </p>
<p class="calibre1">The next code will open the images, combine them, and save a single combined image in the disk. This process (with varying levels of complexity) is called <b class="calibre3">mosaicking</b>: 1.  Still in the image_experiments.py file, add a new function after the open_raster_file function:</p>
<p class="calibre1">def combine_images(input_images):</p>
<p class="calibre1">"""Combine images in a mosaic. </p>
<p class="calibre1">:param input_images: Path to the input images. </p>
<p class="calibre1">""" </p>
<p class="calibre1">images = []</p>
<p class="calibre1">for item in input_images:</p>
<p class="calibre1">images.append(open_raster_file(item))</p>
<p class="calibre1">print images</p>
<p class="calibre1">2.  Now, edit the if __name__ == '__main__': block so we can test the code: if __name__ == '__main__':</p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">combine_images(elevation_data)</p>
<p class="calibre1">3.  Run the code and look at the output:</p>
<p class="calibre1">[array([[[1, 1, 1], </p>
<p class="calibre1">[1, 1, 1], </p>
<p class="calibre1">[2, 2, 2], </p>
<p class="calibre1">..., </p>
<p class="calibre1">[4, 4, 4], </p>
<p class="calibre1">[4, 4, 4], </p>
<p class="calibre1">[4, 4, 4]], </p>
<p class="calibre1">. . . </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">You should see a list of four arrays. PyCharm will hide some values so it can fit in the console. </p>
<p class="calibre1">The first thing we should notice is that the order of the images in the input images argument is the same as the order of the arrays in the output list. This will be very important later. </p>
<p class="calibre1">Secondly, although the elevation data is a 16-bit signed integer (int16), the arrays representing the images still have three bands of an 8-bit unsigned integer. This is an error. </p>
<p class="calibre1"><a id="p290"/><img src="img/index-290_1.jpg" alt="Image 46" class="calibre2"/></p>
<p class="calibre1">OpenCV is converting the grayscale image to a color image. We are going to fix it as follows:</p>
<p class="calibre1">1.  Change the open_raster_file function to accept a new argument. It will allow us to open the images without changing them:</p>
<p class="calibre1">def open_raster_file(image, unchanged=True):</p>
<p class="calibre1">"""Opens a raster file. </p>
<p class="calibre1">:param image: Path of the raster file or np array. </p>
<p class="calibre1">:param unchanged: Set to true to keep the original format. </p>
<p class="calibre1">""" </p>
<p class="calibre1">flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1</p>
<p class="calibre1">image = cv2.imread(image, flags=flags)</p>
<p class="calibre1">return image</p>
<p class="calibre1">The flags argument in cv2.imread allows us to tune how the images are opened and converted into arrays. If the flags are set to cv2.CV_LOAD_IMAGE_UNCHANGED, the image will open as it is without any conversion. </p>
<p class="calibre1">2.  Since we set the default of unchanged to true, we will just run the code again and see the results:</p>
<p class="calibre1">[array([[ 508,  511,  514, ..., 1144, 1148, 1152], </p>
<p class="calibre1">[ 507,  510,  510, ..., 1141, 1144, 1150], </p>
<p class="calibre1">[ 510,  508,  506, ..., 1141, 1145, 1154], </p>
<p class="calibre1">..., </p>
<p class="calibre1">[ 805,  805,  803, ...,  599,  596,  593], </p>
<p class="calibre1">[ 802,  797,  803, ...,  598,  594,  590], </p>
<p class="calibre1">[ 797,  797,  800, ...,  603,  596,  593]], dtype=uint16)</p>
<p class="calibre1">. . . </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The values now are correct and they are the measured elevation in meters for each pixel. </p>
<p class="calibre1">So far, we have a list of arrays in the order that the input files are listed. To figure out the next step, we can imagine this list as if the images were mosaicked as a strip: Now, we must reorganize this, so the images are placed in their correct position. </p>
<p class="calibre1">Remember that NumPy arrays have a shape property. In a 2D array, it’s a tuple containing</p>
<p class="calibre1"><a id="p291"/>the shape in columns and rows. NumPy arrays also have the reshape() method that performs a shape transformation. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Take a look at the NumPy documentation on the reshape method and function. Changing the shape of an array is a very powerful tool at</p>
<p class="calibre1"><a href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html">http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html. </a></p>
<p class="calibre1">The reshape works by filling a row with the input values in order. When the row is full, the method jumps to the next row and continues until the end. So, if we pass the expected shape of the mosaic to the combine_images function, we can use this information to combine the images with respect to the proper positions. </p>
<p class="calibre1">But we need something else. We need to know the shape of the output image through the number of pixels, and this will be the product of the shape of each image by the shape of the mosaic. Let’s try a few changes in the code as follows: 1.  Edit the combine images function:</p>
<p class="calibre1">def combine_images(input_images, shape, output_image):</p>
<p class="calibre1">"""Combine images in a mosaic. </p>
<p class="calibre1">:param input_images: Path to the input images. </p>
<p class="calibre1">:param shape: Shape of the mosaic in columns and rows. </p>
<p class="calibre1">:param output_image: Path to the output image mosaic. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if len(input_images) != shape[0] * shape[1]:</p>
<p class="calibre1">raise ValueError(</p>
<p class="calibre1">"Number of images doesn't match the mosaic shape.") images = []</p>
<p class="calibre1">for item in input_images:</p>
<p class="calibre1">images.append(open_raster_file(item))</p>
<p class="calibre1">rows = []</p>
<p class="calibre1">for row in range(shape[0]):</p>
<p class="calibre1">start = (row * shape[1])</p>
<p class="calibre1">end = start + shape[1]</p>
<p class="calibre1">rows.append(np.concatenate(images[start:end], axis=1))</p>
<p class="calibre1">mosaic = np.concatenate(rows, axis=0)</p>
<p class="calibre1">print(mosaic)</p>
<p class="calibre1">print(mosaic.shape)</p>
<p class="calibre1">Now the function accepts two more arguments, the shape of the mosaic (the number of images in the row and columns and not the number of pixels) and the path of the output image for later use. </p>
<p class="calibre1">With this code, the list of images is separated into rows. Then, the rows are combined to form the complete mosaic. </p>
<p class="calibre1">2.  Before you run the code, don’t forget to import NumPy at the beginning of the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1"><a id="p292"/>And edit the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">combine_images(elevation_data, shape=(2, 2))</p>
<p class="calibre1">3.  Now run the code and see the results:</p>
<p class="calibre1">[[508 511 514…, 761 761 761]</p>
<p class="calibre1">[507 510 510…, 761 761 761]</p>
<p class="calibre1">[510 508 506…, 761 761 761]</p>
<p class="calibre1">..., </p>
<p class="calibre1">[514 520 517…, 751 745 739]</p>
<p class="calibre1">[517 524 517…, 758 756 753]</p>
<p class="calibre1">[509 509 510…, 757 759 760]]</p>
<p class="calibre1">(7202, 7202)</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">It’s now a single array with 7202 x 7202 pixels. The remaining task is to save this array to the disk as an image. </p>
<p class="calibre1">4.  Just add two lines to the function and edit the if __name__ == '__main__': block: def combine_images(input_images, shape, output_image):</p>
<p class="calibre1">"""Combine images in a mosaic. </p>
<p class="calibre1">:param input_images: Path to the input images. </p>
<p class="calibre1">:param shape: Shape of the mosaic in columns and rows. </p>
<p class="calibre1">:param output_image: Path to the output image mosaic. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if len(input_images) != shape[0] * shape[1]:</p>
<p class="calibre1">raise ValueError(</p>
<p class="calibre1">"Number of images doesn't match the mosaic shape.") images = []</p>
<p class="calibre1">for item in input_images:</p>
<p class="calibre1">images.append(open_raster_file(item))</p>
<p class="calibre1">rows = []</p>
<p class="calibre1">for row in range(shape[0]):</p>
<p class="calibre1">start = (row * shape[1])</p>
<p class="calibre1">end = start + shape[1]</p>
<p class="calibre1">rows.append(np.concatenate(images[start:end], axis=1))</p>
<p class="calibre1">mosaic = np.concatenate(rows, axis=0)</p>
<p class="calibre1">print(mosaic)</p>
<p class="calibre1">print(mosaic.shape)</p>
<p class="calibre1">cv2.imwrite(output_image, mosaic)</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1"><a id="p293"/>        '../../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">combine_images(elevation_data, shape=(2, 2), </p>
<p class="calibre1">output_image="../output/mosaic.png")</p>
<p class="calibre1"><a id="p294"/><b class="calibre3">Adjusting the values of the images</b></p>
<p class="calibre1">If you run the previous code, you will see a black image as an output. This happens because the value range that represents the actual data of this region is so narrow in comparison to the possible range of the 16-bit integer image that we can’t distinguish the shades of gray. For better understanding, let’s make a simple test as follows: 1.  Still in the image_experiments.py file, comment the if __name__ == '__main__': block and add this new one:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">image = open_raster_file("../output/mosaic.png")</p>
<p class="calibre1">print(image.min(), image.max())</p>
<p class="calibre1">2.  Run the code and look at the console output. </p>
<p class="calibre1">(423, 2026)</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Precisely, the image ranges from -32768 to 32767 and the elevation of the region in it ranges from 423 to 2026. So what we need to do to make the image visible is to scale the altitude range to the range of the data type. </p>
<p class="calibre1">Since we are making a data representation intended for human visualization, we don’t need to use a big range of gray values. The researches vary, but some say that we can detect only 30 shades, so an 8-bit unsigned integer with 256 possible values should be more than enough for data visualization. </p>
<p class="calibre1">3.  Add this new function:</p>
<p class="calibre1">def adjust_values(input_image, output_image, img_range=None):</p>
<p class="calibre1">"""Create a visualization of the data in the input_image by projecting a range of values into a grayscale image. </p>
<p class="calibre1">:param input_image: Array containing the data</p>
<p class="calibre1">or path to an image. </p>
<p class="calibre1">:param output_image: The image path to write the output. </p>
<p class="calibre1">:param img_range: specified range of values or None to use the range of the image (minimum and maximum). </p>
<p class="calibre1">""" </p>
<p class="calibre1">image = open_raster_file(input_image)</p>
<p class="calibre1">if img_range:</p>
<p class="calibre1">min = img_range[0]</p>
<p class="calibre1">max = img_range[1]</p>
<p class="calibre1">else:</p>
<p class="calibre1">min = image.min()</p>
<p class="calibre1">max = image.max()</p>
<p class="calibre1">interval = max - min</p>
<p class="calibre1">factor = 256.0 / interval</p>
<p class="calibre1">output = image * factor</p>
<p class="calibre1">cv2.imwrite(output_image, output)</p>
<p class="calibre1">This function accepts either an array or the path to an image file. With this feature, </p>
<p class="calibre1"><a id="p295"/><img src="img/index-295_1.jpg" alt="Image 47" class="calibre2"/></p>
<p class="calibre1">we can later use this function as a sub-step in other processing procedures. The range of values that you want to use is also optional. It can be set manually or can be extracted from the images minimum and maximum value. </p>
<p class="calibre1">4.  To test the code, edit the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1"># Adjust. </p>
<p class="calibre1">adjust_values('../output/mosaic.png', </p>
<p class="calibre1">'../output/mosaic_grey.png')</p>
<p class="calibre1">Note that the output image is now a png file. Since we are preparing the image for visualization, we can afford to lose information in data compression in exchange for a smaller file. </p>
<p class="calibre1">5.  Run the code and open the mosaic_grey.png file to see the results. You should see the following beautiful grayscale image now:</p>
<p class="calibre1"><a id="p296"/><b class="calibre3">Cropping an image</b></p>
<p class="calibre1">We made a big mosaic of images in order to cover the region of interest, and in the process, we ended up with an image much bigger than the one we needed. Now, it’s time to crop the image, so we end up with a smaller one comprising only of what we want to see, thus saving disk space and processing time. </p>
<p class="calibre1">In our example, we are interested in the volcano crater. It’s the round object located on the right-hand side of the image. In order to obtain only that region of interest, we will write a function that can crop the image using a bounding box set of coordinates, as follows: 1.  Add the new function to the image_experiments.py file:</p>
<p class="calibre1">def crop_image(input_image, image_extent, bbox, output_image):</p>
<p class="calibre1">"""Crops an image by a bounding box. </p>
<p class="calibre1">bbox and image_extent format: (xmin, ymin, xmax, ymax). </p>
<p class="calibre1">:param input_image: Array containing the data</p>
<p class="calibre1">or path to an image. </p>
<p class="calibre1">:param image_extent: The geographic extent of the image. </p>
<p class="calibre1">:param output_image: The image path to write the output. </p>
<p class="calibre1">:param bbox: The bounding box of the region of interest. </p>
<p class="calibre1">""" </p>
<p class="calibre1">input_image = open_raster_file(input_image)</p>
<p class="calibre1">img_shape = input_image.shape</p>
<p class="calibre1">img_geo_width = abs(image_extent[2] - image_extent[0])</p>
<p class="calibre1">img_geo_height = abs(image_extent[3] - image_extent[1])</p>
<p class="calibre1"># How much pixels are contained in one geographic unit. </p>
<p class="calibre1">pixel_width = img_shape[1] / img_geo_width</p>
<p class="calibre1">pixel_height = img_shape[0] / img_geo_height</p>
<p class="calibre1"># Index of the pixel to cut. </p>
<p class="calibre1">x_min = abs(bbox[0] - image_extent[0]) * pixel_width</p>
<p class="calibre1">x_max = abs(bbox[2] - image_extent[0]) * pixel_width</p>
<p class="calibre1">y_min = abs(bbox[1] - image_extent[1]) * pixel_height</p>
<p class="calibre1">y_max = abs(bbox[3] - image_extent[1]) * pixel_height</p>
<p class="calibre1">output = input_image[y_min:y_max, x_min:x_max]</p>
<p class="calibre1">cv2.imwrite(output_image, output)</p>
<p class="calibre1">Since we are dealing with NumPy arrays, the cropping itself is a simple array slicing. </p>
<p class="calibre1">The slicing of arrays is very similar to the Python lists’ slicing, but with additional dimensions. The statement input_image[y_min:y_max, x_min:x_max] tells that we want only the portion of the array contained within the specified cells (that is, pixels). </p>
<p class="calibre1">So, all the math involved is to convert geographic units into array indices. </p>
<p class="calibre1">2.  Edit the if __name__ == '__main__': block to test the code: if __name__ == '__main__':</p>
<p class="calibre1"># Crop. </p>
<p class="calibre1">roi = (-46.8, -21.7, -46.3, -22.1)  # Region of interest. </p>
<p class="calibre1">crop_image('../output/mosaic_grey.png', </p>
<p class="calibre1">(-48, -21, -46, -23), roi, "../output/cropped.png")</p>
<p class="calibre1"><a id="p297"/><img src="img/index-297_1.jpg" alt="Image 48" class="calibre2"/></p>
<p class="calibre1">3.  Run the code and open the output image to see the results. </p>
<p class="calibre1">4.  If you have missed any of the steps, you can run the whole process all at once. Just edit the if __name__ == '__main__' block:</p>
<p class="calibre1">if __name__ == '__main__':    </p>
<p class="calibre1"># Combine. </p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">combine_images(elevation_data, shape=(2, 2), </p>
<p class="calibre1">output_image="../output/mosaic.png")</p>
<p class="calibre1"># Adjust. </p>
<p class="calibre1">adjust_values('../output/mosaic.png', </p>
<p class="calibre1">'../output/mosaic_grey.png')</p>
<p class="calibre1"># Crop. </p>
<p class="calibre1">roi = (-46.8, -21.7, -46.3, -22.1)  # Region of interest. </p>
<p class="calibre1">crop_image('../output/mosaic_grey.png', </p>
<p class="calibre1">(-48, -21, -46, -23), roi, "../output/cropped.png")</p>
<p class="calibre1"><a id="p298"/><img src="img/index-298_1.jpg" alt="Image 49" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Creating a shaded relief image</b></p>
<p class="calibre1">Our digital elevation model image has improved a lot after we processed it, but it is still not suitable for a map. Untrained eyes may find it difficult to understand the relief only by looking at the different shades of gray. </p>
<p class="calibre1">Fortunately, there is a technique, called <b class="calibre3">hill shading</b> or <b class="calibre3">relief shading</b>, that transforms the elevation data into a simulated sun shading over the terrain. Look at the beautiful map in the following picture and note how much easier it is to understand the relief when it is presented as a shaded relief:</p>
<p class="calibre1">The process is simple and involves passing our image through a well-known algorithm as follows:</p>
<p class="calibre1">1.  Add the create_hillshade function to your image_experiments.py file: def create_hillshade(input_image, output_image, </p>
<p class="calibre1">azimuth=90, angle_altitude=60):</p>
<p class="calibre1">"""Creates a shaded relief image from a digital elevation model. </p>
<p class="calibre1">:param input_image: Array containing the data</p>
<p class="calibre1">or path to an image. </p>
<p class="calibre1">:param azimuth: Simulated sun azimuth. </p>
<p class="calibre1">:param angle_altitude: Sun altitude angle. </p>
<p class="calibre1">""" </p>
<p class="calibre1">input_image = open_raster_file(input_image)</p>
<p class="calibre1">x, y = np.gradient(input_image)</p>
<p class="calibre1">slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))</p>
<p class="calibre1">aspect = np.arctan2(-x, y)</p>
<p class="calibre1">az_rad = azimuth * np.pi / 180</p>
<p class="calibre1">alt_rad = angle_altitude * np.pi / 180</p>
<p class="calibre1"><a id="p299"/><img src="img/index-299_1.jpg" alt="Image 50" class="calibre2"/></p>
<p class="calibre1">a = np.sin(alt_rad) * np.sin(slope)</p>
<p class="calibre1">b = np.cos(alt_rad) * np.cos(slope) * np.cos(az_rad - aspect) output = 255 * (a + b + 1) / 2</p>
<p class="calibre1">cv2.imwrite(output_image, output)</p>
<p class="calibre1">2.  Now, alter the if __name__ == '__main__': block to test the code: if __name__ == '__main__':</p>
<p class="calibre1">create_hillshade("../output/cropped.png", </p>
<p class="calibre1">"../output/hillshade.png")</p>
<p class="calibre1">3.  Run the code and open the output image to see the results. If everything goes fine, you should see a shaded relief representation of your data. </p>
<p class="calibre1"><a id="p300"/>
<a id="p301"/><img src="img/index-301_1.jpg" alt="Image 51" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Building an image processing pipeline</b></p>
<p class="calibre1">Image processing, be it for geographic applications or not, generally requires the execution of a sequence of transformations (that is, steps) in order to obtain the desired final result. In these sequences, the output of one step is the input of the next one. In computing, this is called <b class="calibre3">processing pipeline</b>. </p>
<p class="calibre1">This type of data manipulation is very versatile, because you have a range of functions or steps than can be arranged into numerous combinations to produce a wide range of results. </p>
<p class="calibre1">What we did so far, in this chapter’s examples, was we opened an image from the disk, performed a given operation, and saved the results to another image on the disk. Then, in the next step, we opened the result from the previous one and so on. </p>
<p class="calibre1">Despite the steps are not yet connected, we can imagine the following image processing pipeline:</p>
<p class="calibre1">Saving intermediary steps to the disk is useful when we want to use the images from them, or in other situations, when the pipeline uses parallel processing or other more complex methods. </p>
<p class="calibre1">For some cases, it would be more interesting just to pass data along the pipeline without touching the hard drive, only using the computer memory. With this, one should expect a noticeable gain in speed and a lesser production of residual files. </p>
<p class="calibre1">In order to conciliate these two situations, we can use type checks for our functions’</p>
<p class="calibre1">arguments, making them accept either arrays or file paths. Navigate to your open_raster_file function and alter its code:</p>
<p class="calibre1">def open_raster_file(file_path, unchanged=True):</p>
<p class="calibre1">"""Opens a raster file. </p>
<p class="calibre1"><b class="calibre3">    :param file_path: Path of the raster file or np array. </b></p>
<p class="calibre1">:param unchanged: Set to true to keep the original format. </p>
<p class="calibre1">""" </p>
<p class="calibre1"><b class="calibre3">    if isinstance(file_path, np.ndarray):</b></p>
<p class="calibre1"><b class="calibre3">        return file_path</b></p>
<p class="calibre1">flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1</p>
<p class="calibre1">image = cv2.imread(file_path, flags=flags)</p>
<p class="calibre1">return image</p>
<p class="calibre1">This function will now check the type of file_path. If it is already a NumPy array, it will be returned. This changes the behavior of all of our functions because they can now receive arrays as input. </p>
<p class="calibre1">If we add a return statement to all the functions and make them return the output arrays, </p>
<p class="calibre1"><a id="p302"/>we would be able to combine the function as follows: create_hillshade(</p>
<p class="calibre1">crop_image(</p>
<p class="calibre1">adjust_values('mosaic.png'), </p>
<p class="calibre1">(-48, -21, -46, -23), roi), 'shaded.png')</p>
<p class="calibre1">You don’t need to type this code. This notation is hard to understand. The order in which the functions are called is unintuitive and it’s difficult to figure out of which function is each argument. </p>
<p class="calibre1">It would be much nicer if we could execute the pipeline by chaining the functions, like we did in the  <i class="calibre4">Chaining filters</i> section in<a href="index_split_001.html#p174"> Chapter 4, </a>  <i class="calibre4">Improving the App Search Capabilities</i>. </p>
<p class="calibre1">Actually, it would be great to use something with a notation as follows: adjust_values().crop_image().create_hillshade()</p>
<p class="calibre1">As in <a href="index_split_001.html#p174">Chapter 4</a>,  <i class="calibre4">Improving the App Search Capabilities</i>, the only thing we need is to have a class and the methods that return the same type of class. With these two things, there are no limits on how the steps can be combined. So, let’s do it. </p>
<p class="calibre1"><a id="p303"/><b class="calibre3">Creating a RasterData class</b></p>
<p class="calibre1">Our RasterData class will follow the pattern used before with our vectors. When instantiated, the class will receive a file path or an array. As said before, in order to use method chaining to perform a processing pipeline, each processing method must return another instance of the RasterData class. </p>
<p class="calibre1">We will start with class declaration and then fill it with the methods. To make it easier to cut and paste the work we have already done, we will do the following steps inside the image_experiments.py file:</p>
<p class="calibre1">1.  At the top of the image_experiments.py file, after the imports, create the class:</p>
<p class="calibre1"/>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">"""Represents a raster data in the form of an array. </p>
<p class="calibre1">:param input_data: Raster files or Numpy array. </p>
<p class="calibre1">:param unchanged: True to keep the original format. </p>
<p class="calibre1">:param shape: When using multiple input data, this param</p>
<p class="calibre1">determines the shape of the composition. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.data = None</p>
<p class="calibre1">if isinstance(input_data, list) \</p>
<p class="calibre1">or isinstance(input_data, tuple):</p>
<p class="calibre1">self.combine_images(input_data, shape)</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.import_data(input_data, unchanged)</p>
<p class="calibre1">The array will be stored in the data property, so we will initially set it to None. </p>
<p class="calibre1">There are a few other changes to make this class consistent with the others and avoid redundancy in the names. The first one is to use an import_data method like before. </p>
<p class="calibre1">2.  Cut and paste the open_raster_file function into the class, rename it to import_data, and change it to behave like a method:</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):             </p>
<p class="calibre1">... </p>
<p class="calibre1"/>
<p class="calibre1">def import_data(self, image, unchanged=True):</p>
<p class="calibre1">"""Opens a raster file. </p>
<p class="calibre1">:param image: Path of the raster file or np array. </p>
<p class="calibre1">:param unchanged: True to keep the original format. </p>
<p class="calibre1">""" </p>
<p class="calibre1"><a id="p304"/>        if isinstance(image, np.ndarray):</p>
<p class="calibre1">self.data = image</p>
<p class="calibre1">return image</p>
<p class="calibre1">flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1</p>
<p class="calibre1">self.data = cv2.imread(image, flags=flags)</p>
<p class="calibre1">Instead of returning an array, it will now put the array in the data property. </p>
<p class="calibre1">Next, since we will be removing the obligation of writing the image to the disk from the steps, we will need a method to perform this action. </p>
<p class="calibre1">3.  Add the write_image method:</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">... </p>
<p class="calibre1">def import_data(self, input_image, unchanged=True):</p>
<p class="calibre1">... </p>
<p class="calibre1">def write_image(self, output_image):</p>
<p class="calibre1">"""Write the data to the disk as an image. </p>
<p class="calibre1">:param output_image: Path and name of the output image. </p>
<p class="calibre1">""" </p>
<p class="calibre1">cv2.imwrite(output_image, self.data)</p>
<p class="calibre1">return self</p>
<p class="calibre1">4.  Following the examples’ order, cut and paste the combine_images function as a method to the class:</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">... </p>
<p class="calibre1">def import_data(self, input_image, unchanged=True):</p>
<p class="calibre1">... </p>
<p class="calibre1">def write_image(self, output_image):</p>
<p class="calibre1">... </p>
<p class="calibre1">def combine_images(self, input_images, shape):</p>
<p class="calibre1">"""Combine images in a mosaic. </p>
<p class="calibre1">:param input_images: Path to the input images. </p>
<p class="calibre1">:param shape: Shape of the mosaic in columns and rows. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if len(input_images) != shape[0] * shape[1]:</p>
<p class="calibre1">raise ValueError("Number of images doesn't match the" </p>
<p class="calibre1">" mosaic shape.")</p>
<p class="calibre1">images = []</p>
<p class="calibre1">for item in input_images:</p>
<p class="calibre1">if isinstance(item, RasterData):</p>
<p class="calibre1">images.append(item.data)</p>
<p class="calibre1">else:</p>
<p class="calibre1">images.append(RasterData(item).data)</p>
<p class="calibre1">rows = []</p>
<p class="calibre1"><a id="p305"/>        for row in range(shape[0]):</p>
<p class="calibre1">start = (row * shape[1])</p>
<p class="calibre1">end = start + shape[1]</p>
<p class="calibre1">rows.append(np.concatenate(images[start:end], axis=1))</p>
<p class="calibre1">mosaic = np.concatenate(rows, axis=0)</p>
<p class="calibre1">self.data = mosaic</p>
<p class="calibre1">return self</p>
<p class="calibre1">Now, it’s possible to create an empty RasterData instance and then populate it with a mosaic using this method. Or, you can create the instance with a list containing any combination of image paths, arrays, or even other RasterData instances as an argument. It will automatically combine them, put the result in the data property, and return itself. </p>
<p class="calibre1">Now that you got the hang of it, let’s do the same transformation with the last three functions. </p>
<p class="calibre1">5.  Cut and paste the adjust_values, crop_image and create_hillshade functions as methods into the class. Your complete class should be as follows: class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">"""Represents a raster data in the form of an array. </p>
<p class="calibre1">:param input_data: Raster files or Numpy array. </p>
<p class="calibre1">:param unchanged: True to keep the original format. </p>
<p class="calibre1">:param shape: When using multiple input data, this param</p>
<p class="calibre1">determines the shape of the composition. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.data = None</p>
<p class="calibre1">if isinstance(input_data, list) \</p>
<p class="calibre1">or isinstance(input_data, tuple):</p>
<p class="calibre1">self.combine_images(input_data, shape)</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.import_data(input_data, unchanged)</p>
<p class="calibre1">def import_data(self, image, unchanged=True):</p>
<p class="calibre1">"""Opens a raster file. </p>
<p class="calibre1">:param image: Path of the raster file or np array. </p>
<p class="calibre1">:param unchanged: True to keep the original format. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if isinstance(image, np.ndarray):</p>
<p class="calibre1">self.data = image</p>
<p class="calibre1">return image</p>
<p class="calibre1">flags = cv2.CV_LOAD_IMAGE_UNCHANGED if unchanged else -1</p>
<p class="calibre1">self.data = cv2.imread(image, flags=flags)</p>
<p class="calibre1">def write_image(self, output_image):</p>
<p class="calibre1">"""Write the data to the disk as an image. </p>
<p class="calibre1">:param output_image: Path and name of the output image. </p>
<p class="calibre1">""" </p>
<p class="calibre1">cv2.imwrite(output_image, self.data)</p>
<p class="calibre1">return self</p>
<p class="calibre1"><a id="p306"/>    def combine_images(self, input_images, shape):</p>
<p class="calibre1">"""Combine images in a mosaic. </p>
<p class="calibre1">:param input_images: Path to the input images. </p>
<p class="calibre1">:param shape: Shape of the mosaic in columns and rows. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if len(input_images) != shape[0] * shape[1]:</p>
<p class="calibre1">raise ValueError("Number of images doesn't match the" </p>
<p class="calibre1">" mosaic shape.")</p>
<p class="calibre1">images = []</p>
<p class="calibre1">for item in input_images:</p>
<p class="calibre1">if isinstance(item, RasterData):</p>
<p class="calibre1">images.append(item.data)</p>
<p class="calibre1">else:</p>
<p class="calibre1">images.append(RasterData(item).data)</p>
<p class="calibre1">rows = []</p>
<p class="calibre1">for row in range(shape[0]):</p>
<p class="calibre1">start = (row * shape[1])</p>
<p class="calibre1">end = start + shape[1]</p>
<p class="calibre1">rows.append(np.concatenate(images[start:end], axis=1))</p>
<p class="calibre1">mosaic = np.concatenate(rows, axis=0)</p>
<p class="calibre1">self.data = mosaic</p>
<p class="calibre1">return self</p>
<p class="calibre1">def adjust_values(self, img_range=None):</p>
<p class="calibre1">"""Create a visualization of the data in the input_image by projecting a range of values into a grayscale image. </p>
<p class="calibre1">:param img_range: specified range of values</p>
<p class="calibre1">or None to use the range of the image</p>
<p class="calibre1">(minimum and maximum). </p>
<p class="calibre1">""" </p>
<p class="calibre1">image = self.data</p>
<p class="calibre1">if img_range:</p>
<p class="calibre1">min = img_range[0]</p>
<p class="calibre1">max = img_range[1]</p>
<p class="calibre1">else:</p>
<p class="calibre1">min = image.min()</p>
<p class="calibre1">max = image.max()</p>
<p class="calibre1">interval = max - min</p>
<p class="calibre1">factor = 256.0 / interval</p>
<p class="calibre1">output = image * factor</p>
<p class="calibre1">self.data = output</p>
<p class="calibre1">return self</p>
<p class="calibre1">def crop_image(self, image_extent, bbox):</p>
<p class="calibre1">"""Crops an image by a bounding box. </p>
<p class="calibre1">bbox and image_extent format: (xmin, ymin, xmax, ymax). </p>
<p class="calibre1">:param input_image: Array containing the data</p>
<p class="calibre1">or path to an image. </p>
<p class="calibre1">:param image_extent: The geographic extent of the image. </p>
<p class="calibre1">:param output_image: The image path to write the output. </p>
<p class="calibre1">:param bbox: The bounding box of the region of interest. </p>
<p class="calibre1">""" </p>
<p class="calibre1"><a id="p307"/>        input_image = self.data</p>
<p class="calibre1">img_shape = input_image.shape</p>
<p class="calibre1">img_geo_width = abs(image_extent[2] - image_extent[0])</p>
<p class="calibre1">img_geo_height = abs(image_extent[3] - image_extent[1])</p>
<p class="calibre1"># How much pixels are contained in one geographic unit. </p>
<p class="calibre1">pixel_width = img_shape[1] / img_geo_width</p>
<p class="calibre1">pixel_height = img_shape[0] / img_geo_height</p>
<p class="calibre1"># Index of the pixel to cut. </p>
<p class="calibre1">x_min = abs(bbox[0] - image_extent[0]) * pixel_width</p>
<p class="calibre1">x_max = abs(bbox[2] - image_extent[0]) * pixel_width</p>
<p class="calibre1">y_min = abs(bbox[1] - image_extent[1]) * pixel_height</p>
<p class="calibre1">y_max = abs(bbox[3] - image_extent[1]) * pixel_height</p>
<p class="calibre1">output = input_image[y_min:y_max, x_min:x_max]</p>
<p class="calibre1">self.data = output</p>
<p class="calibre1">return self</p>
<p class="calibre1">def create_hillshade(self, azimuth=90, angle_altitude=60):</p>
<p class="calibre1">"""Creates a shaded relief image from a digital elevation model. </p>
<p class="calibre1">:param input_image: Array containing the data</p>
<p class="calibre1">or path to an image. </p>
<p class="calibre1">:param azimuth: Simulated sun azimuth. </p>
<p class="calibre1">:param angle_altitude: Sun altitude angle. </p>
<p class="calibre1">""" </p>
<p class="calibre1">input_image = self.data</p>
<p class="calibre1">x, y = np.gradient(input_image)</p>
<p class="calibre1">slope = np.pi / 2 - np.arctan(np.sqrt(x * x + y * y))</p>
<p class="calibre1">aspect = np.arctan2(-x, y)</p>
<p class="calibre1">az_rad = azimuth * np.pi / 180</p>
<p class="calibre1">alt_rad = angle_altitude * np.pi / 180</p>
<p class="calibre1">a = np.sin(alt_rad) * np.sin(slope)</p>
<p class="calibre1">b = np.cos(alt_rad) * np.cos(slope)\</p>
<p class="calibre1">* np.cos(az_rad - aspect) </p>
<p class="calibre1">output = 255 * (a + b + 1) / 2</p>
<p class="calibre1">self.data = output</p>
<p class="calibre1">return self</p>
<p class="calibre1">The class is complete and we can make a pipeline to test it. </p>
<p class="calibre1">6.  Edit and organize the if __name__ == '__main__': block to test the image processing pipeline:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1">'../../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">roi = (-46.8, -21.7, -46.3, -22.1)  # Region of interest. </p>
<p class="calibre1">iex = (-48, -21, -46, -23)  # Image extent. </p>
<p class="calibre1">RasterData(elevation_data, shape=(2, 2)).adjust_values().\</p>
<p class="calibre1">crop_image(iex, roi).create_hillshade().\</p>
<p class="calibre1">write_image('../output/pipeline_output.png')</p>
<p class="calibre1"><a id="p308"/><img src="img/index-308_1.jpg" alt="Image 52" class="calibre2"/></p>
<p class="calibre1">Due to the width limitation of the book, the pipeline is broken into three lines, but you can type it in a single line in PyCharm if you wish. </p>
<p class="calibre1">7.  Run the code and admire the result. </p>
<p class="calibre1">At this point, you have a fantastic accomplishment. I’m not talking about the shaded relief image, I’m talking about the ability to consistently develop processing steps and combine them into a processing pipeline in order to achieve the final result. The structure that we developed here can be used to do almost anything in terms of geoprocessing. </p>
<p class="calibre1">Also, note that the image generated by the pipeline is of a much superior quality than the one created before. This happened because the data was in the memory the whole time. </p>
<p class="calibre1">This avoided data loss due to compression when the data was saved to a file multiple times. </p>
<p class="calibre1">A few remarks about the functionality of the structure as we implemented it are as follows: All the processing methods do two things in the end: they change the instance data and return the instance itself. The implication of this is that the class instance will mutate along the pipeline and the old data will be replaced by new ones as the process goes on. With this, Python’s garbage collector will eliminate old results from the memory and save space. </p>
<p class="calibre1">If, at any step, you want to save the current state of processing, just insert a call to the write_image method (it will also return self and it can be piped). This is a powerful</p>
<p class="calibre1"><a id="p309"/>tool for debugging and also can save time when you only want to repeat the steps later in a long pipeline. </p>
<p class="calibre1">You can fork the pipeline. You can create a bifurcation where more than one result can be produced by following different paths. To do this, you can use the copy() function or you can write the result to the disk before the bifurcation. Later in the book we will see that, sometimes, while performing parallel processing, we will need these techniques too. </p>
<p class="calibre1"><a id="p310"/>
<a id="p311"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we understood how remote sensing images are represented inside the computer as arrays and how we can use this characteristic to process them. We saw that, in order to use images on a map, it is common that we need to transform them to achieve better results. Then, we wrote processing functions to process the digital elevation model images, ending with a beautiful shaded relief map. Finally, we created a RasterData class and transformed our functions into the methods of this class. With a few additional changes, we made it possible to chain these methods into a processing pipeline. </p>
<p class="calibre1">In the next chapter, we will explore the data in the images and obtain valuable information. </p>
<p class="calibre1"><a id="p312"/>
<a id="p313"/><b class="calibre3">Chapter 7. Extract Information from</b></p>
<p class="calibre1"><b class="calibre3">Raster Data</b></p>
<p class="calibre1">More than just a resource for visual information, raster data are samples of a given spatial attribute, whose values can be analyzed in order to produce valuable information. </p>
<p class="calibre1">Is this chapter, we will extract information from raster data with special emphasis on statistical information. Following the previous examples, we will use the digital elevation model to obtain values such as the maximum and minimum altitude of a given region, separate altitude ranges into classes, and produce histograms and other statistical information. Going beyond simple numerical values, we will display all the information on beautifully colored maps. </p>
<p class="calibre1">The topics covered by this chapter are:</p>
<p class="calibre1">How to obtain statistics from raster data</p>
<p class="calibre1">The use of programming techniques, such as lazy evaluation and memorization, to avoid unnecessary calculation</p>
<p class="calibre1">How to format tabular data output</p>
<p class="calibre1">How to colorize maps and choose suitable colors for them</p>
<p class="calibre1">How to blend color maps in order to produce colorized and shaded maps</p>
<p class="calibre1"><a id="p314"/><b class="calibre3">Getting the basic statistics</b></p>
<p class="calibre1">As we have previously seen, images or raster data are arrays containing numerical values representing a given real world space. So, they are by consequence statistical samples and they can be used in statistical analysis. </p>
<p class="calibre1">When we import the data, it is converted into NumPy arrays. These arrays are packed with methods for basic statistical calculations. In this topic, we are going to obtain the results from these calculations and save them in a file. </p>
<p class="calibre1">At the end of the previous chapter, we made an image processing pipeline by combining steps that can be saved on the disk. Here, we will follow the same pattern. The statistical computation will be added as another step. Maintaining the same kind of organization allows the user to generate statistics at any point on the processing pipeline. It will be possible to save statistics from all the substeps if needed. </p>
<p class="calibre1">Let’s start by organizing our code:</p>
<p class="calibre1">1.  As we do at the beginning of every chapter, we will copy the code from the previous chapter. In your geopy project folder, copy the Chapter 6 folder ( <i class="calibre4">Ctrl</i> +  <i class="calibre4">C</i>) and paste it ( <i class="calibre4">Ctrl</i> +  <i class="calibre4">V</i>). Name the copied folder as Chapter7. </p>
<p class="calibre1">In the last chapter, we finished the RasterData class inside the image_experiments.py file. Since our experiments are over, let’s move this class to a permanent and meaningful location. </p>
<p class="calibre1">2.  Copy the file Chapter7/experiments/image_experiments.py ( <i class="calibre4">Ctrl</i> +  <i class="calibre4">C</i>). </p>
<p class="calibre1">3.  Select the Chapter7 folder and paste the file there ( <i class="calibre4">Ctrl</i> +  <i class="calibre4">V</i>). </p>
<p class="calibre1">4.  Rename the file to raster_data.py. To do this, right-click on the file and select <b class="calibre3">Refactor</b> | <b class="calibre3">Rename…</b> or select the file and press  <i class="calibre4">Ctrl</i> +  <i class="calibre4">F6</i>. The refactor dialog will appear. Change the name in the dialog and click on the <b class="calibre3">Refactor</b> button. There are two checkboxes in the dialog asking whether you want to search for this file’s references. If they are checked (on), PyCharm will search and automatically change these references, so the code will continue to work. </p>
<p class="calibre1">5.  Remove the image_experiments.py file, as it won’t be of use anymore. </p>
<p class="calibre1">Now that our code is organized, we are going to analyze a few aspects and review some points in order to plan our next step. </p>
<p class="calibre1">Let’s take an instance of your RasterData class that has a base working pattern, as it is now:</p>
<p class="calibre1">At the instancing moment, you can pass the data or you can import the data later. </p>
<p class="calibre1">After this, the data will be stored as a NumPy array in the data property. </p>
<p class="calibre1">When you run any method in the class, the operation is performed and the data is transformed if it’s the case and the instance itself is returned along with the new data. </p>
<p class="calibre1">No information is stored in the class, other than the data. And by consequence, some methods need to take manually defined parameters. </p>
<p class="calibre1"><a id="p315"/>The data property is a NumPy array, so it has all the NumPy array methods. </p>
<p class="calibre1"><a id="p316"/><b class="calibre3">Preparing the data</b></p>
<p class="calibre1">The sample data that we will be using is composed of four images containing elevation data. The processing pipeline combines these images, adjusts the values to display on a map, cuts the image, and then generates the shaded relief image. </p>
<p class="calibre1">This pipeline is good for visualization, but data is lost in the moment we adjust the values. </p>
<p class="calibre1">For this work, we don’t want that to happen. We want the original values in meters. So, the first thing we need to do is build a pipeline adequate for our needs, and in the end, save the results, so we don’t need to repeat all the steps in the following tests: 1.  Open the raster_data.py file for editing, and at the end of it, add the if __name__</p>
<p class="calibre1">== '__main__': block with the following code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">elevation_data = [</p>
<p class="calibre1">'../data/ASTGTM2_S22W048_dem.tif', </p>
<p class="calibre1">'../data/ASTGTM2_S22W047_dem.tif', </p>
<p class="calibre1">'../data/ASTGTM2_S23W048_dem.tif', </p>
<p class="calibre1">'../data/ASTGTM2_S23W047_dem.tif']</p>
<p class="calibre1">roi = (-46.8, -21.7, -46.3, -22.1)  # Region of interest. </p>
<p class="calibre1">iex = (-48, -21, -46, -23)  # Image extent. </p>
<p class="calibre1"/>
<p class="calibre1">data = RasterData(elevation_data, shape=(2, 2))</p>
<p class="calibre1">data.crop_image(iex, roi).write_image(</p>
<p class="calibre1">'output/dem.tif')</p>
<p class="calibre1">This is very similar to what we did before, but the pipeline was simplified to combining the images and cropping and writing the results in the dem.tif file. It was chosen as a TIFF file, so the information isn’t lost due to data compression. </p>
<p class="calibre1">2.  Run the code. Remember that because it’s a new file, you need to click on <b class="calibre3">Run</b> or press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and choose raster_data. You should see an output telling you that everything went fine:</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">From now on, we can use the prepared image in output/dem.tif for our tests. This is simply a matter of speeding up the process. What we are going to do could be done in any RasterData instance. </p>
<p class="calibre1">If, by any reason, you couldn’t generate dem.tif, copy the one provided with the sample data to your output folder. </p>
<p class="calibre1"><a id="p317"/><b class="calibre3">Printing simple information</b></p>
<p class="calibre1">The first step for us to get some statistical output is to explore what NumPy has to offer. </p>
<p class="calibre1">As we know, the data property of a RasterData instance is a NumPy array, so let’s see what we can get from it:</p>
<p class="calibre1">1.  First, check whether everything is working so far. Clean the if __name__ ==</p>
<p class="calibre1">'__main__': block and add this new code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">print raster_data.data</p>
<p class="calibre1">2.  Run the code with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>. You should see this output:</p>
<p class="calibre1">[[ 933  935  942…, 1077 1076 1078]</p>
<p class="calibre1">[ 936  939  945…, 1075 1079 1076]</p>
<p class="calibre1">[ 935  939  946…, 1064 1072 1075]</p>
<p class="calibre1">..., </p>
<p class="calibre1">[ 780  781  781…, 1195 1193 1193]</p>
<p class="calibre1">[ 781  784  782…, 1191 1189 1188]</p>
<p class="calibre1">[ 781  784  785…, 1187 1185 1184]]</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">This is the array containing the data in meters. NumPy automatically suppressed some rows and columns to make the output smaller. You see this output because a NumPy array has a __repr__ method that tells what is to be shown when the print function is called. </p>
<p class="calibre1">As we did before with the vector data, we will customize the __repr__ method of our class, so it outputs some information from the data in it. </p>
<p class="calibre1">3.  Edit the RasterData class and insert the __repr__ method right after the __init__</p>
<p class="calibre1">method:</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">... </p>
<p class="calibre1"/>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">return "Hi, I'm a raster data!" </p>
<p class="calibre1">4.  Now, edit the if __name__ == '__main__': block and make it print the RasterData instance directly:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">print raster_data</p>
<p class="calibre1">5.  Run the code and see whether you get this output:</p>
<p class="calibre1">Hi, I'm a raster data! </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p318"/>OK, nothing fancy here. It’s just to remember that __repr__ takes no arguments except the instance (self) and should return only a string. Also, the method’s position in the class makes no difference. We are placing it after the __init__ method for organization. </p>
<p class="calibre1">All the  <i class="calibre4">magic</i> methods go together at the beginning of the class. </p>
<p class="calibre1">Now that we have everything set, let’s explore the NumPy array in the data property. </p>
<p class="calibre1">In order to avoid repetition, I’ll suppress the class’ declaration and the __init__ method in the code and replace it by #.... </p>
<p class="calibre1">1.  Edit the __repr__ method to look as follows:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">if self.data is None:</p>
<p class="calibre1">return "No data to display!" </p>
<p class="calibre1">data = self.data</p>
<p class="calibre1">min = "Min: {}".format(data.min())</p>
<p class="calibre1">mean = "Mean: {}".format(data.mean())</p>
<p class="calibre1">max = "Max: {}".format(data.max())</p>
<p class="calibre1">return "Hi, I'm a raster data!\n {} {} {}".format(</p>
<p class="calibre1">min, mean, max)</p>
<p class="calibre1">The first thing is to avoid an exception if the data is empty (None). In this case, the method prints a nice message telling that the instance has no data. If the instance has data, then it prepares three strings with the minimum, mean, and maximum values by calling the respective methods. In the end, a string is formatted to contain all the information. </p>
<p class="calibre1">2.  Run the code with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>. You should see this output: Hi, I'm a raster data! </p>
<p class="calibre1">Min: 671 Mean: 1139.06559874 Max: 1798</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">That’s great! Now, we have some statistical information on our data. </p>
<p class="calibre1">But this code is clumsy and if we want to add or remove information returned from __repr__, we need to do a lot of editing. So, before we proceed on to obtaining more statistics, we will make a few changes and automate the process of formatting the information that we want to display. </p>
<p class="calibre1"><a id="p319"/><b class="calibre3">Formatting the output information</b></p>
<p class="calibre1">At this point, we are displaying three parameters in a simple string output. We want to improve this code, so we can easily add or remove parameters from the output. </p>
<p class="calibre1">Before we modify the code, let’s think ahead and foresee that we may also need to output these statistics in other formats, for example:</p>
<p class="calibre1">To a file on the disk in a human-friendly format</p>
<p class="calibre1">To a file on the disk in a computer-friendly format, such as CSV or JSON</p>
<p class="calibre1">As parameters to be passed to the other function or method</p>
<p class="calibre1">So, a good way we can prepare the code to fulfill these requirements is to separate the statistic generation from the output as follows:</p>
<p class="calibre1">1.  First, separate the data verification from the __repr__ method. Create a new method to handle this task:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def _check_data(self):</p>
<p class="calibre1">"""Check if has data and if it's a Numpy array.""" </p>
<p class="calibre1">if self.data is None:</p>
<p class="calibre1">raise ValueError("No data defined.")</p>
<p class="calibre1">elif not isinstance(self.data, np.ndarray):</p>
<p class="calibre1">raise TypeError("Wrong type of data.")</p>
<p class="calibre1">The verification is more rigorous and it raises different types of exceptions for each possible failure. This makes the code mode useful and safe, because it allows error-handling to be done in the other functions and because it stops the program’s execution if the exception is not properly caught. </p>
<p class="calibre1">2.  Now, create a new method to calculate and collect the statistics that we have so far:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def _calculate_stats(self):</p>
<p class="calibre1">"""Calculate and return basic statistical information from the data. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._check_data()</p>
<p class="calibre1">data = self.data</p>
<p class="calibre1">stats = {</p>
<p class="calibre1">"Minimum": data.min(), </p>
<p class="calibre1">"Mean": data.mean(), </p>
<p class="calibre1">"Maximum": data.max()}</p>
<p class="calibre1">return stats</p>
<p class="calibre1">Here, the statistics are stored in a dictionary for two reasons: it allows the items to have readable names (including accents and spaces if you wish) and it avoids name collisions. </p>
<p class="calibre1">Finally, it lets us prepare a human-readable output with the statistics calculated. For this, we will use the tabulate module. </p>
<p class="calibre1">3.  Insert this import at the beginning of the file:</p>
<p class="calibre1"><a id="p320"/># coding=utf-8</p>
<p class="calibre1">import cv2</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">from tabulate import tabulate</p>
<p class="calibre1">4.  Add this new method:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def _format_stats(self, stats, out_format='human'):</p>
<p class="calibre1">"""Format the statistical data in a given output format. </p>
<p class="calibre1">:param out_format: 'human' or 'csv' </p>
<p class="calibre1">""" </p>
<p class="calibre1">table = []</p>
<p class="calibre1">for key, value in stats.iteritems():</p>
<p class="calibre1">table.append([key, value])</p>
<p class="calibre1">return tabulate(table)</p>
<p class="calibre1">The tabulate function takes a list of lists representing a table. It then prepares a string containing a well-formatted table with this data. </p>
<p class="calibre1">5.  Finally, edit the __repr__ method:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def __repr__(self):</p>
<p class="calibre1">stats = self._calculate_stats()</p>
<p class="calibre1">stats = self._format_stats(stats)</p>
<p class="calibre1">return "Raster data - basic statistics.\n {}".format(stats) 6.  Now, run the code again with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>. You should see this output: Raster data - basic statistics. </p>
<p class="calibre1">-------  -------</p>
<p class="calibre1">Minimum   671</p>
<p class="calibre1">Maximum  1798</p>
<p class="calibre1">Mean     1139.07</p>
<p class="calibre1">-------  -------</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The presentation is much better now. If we want to add or remove elements, we just need to edit the dictionary in the _calculate_stats method. </p>
<p class="calibre1"><a id="p321"/><b class="calibre3">Calculating quartiles, histograms, and other</b> <b class="calibre3">statistics</b></p>
<p class="calibre1">We have the minimum, maximum, and mean values for our data. In our case, it is the minimum, maximum, and mean elevation of the given region. In the next few steps, we will obtain more information from our data:</p>
<p class="calibre1">1.  Edit the _calculate_stats method, adding more items to the dictionary:</p>
<p class="calibre1"># ... </p>
<p class="calibre1">def _calculate_stats(self):</p>
<p class="calibre1">"""Calculate and return basic statistical information from the data. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self._check_data()</p>
<p class="calibre1">data = self.data</p>
<p class="calibre1">stats = {</p>
<p class="calibre1">"Minimum": data.min(), </p>
<p class="calibre1">"Mean": data.mean(), </p>
<p class="calibre1">"Maximum": data.max(), </p>
<p class="calibre1">"Q1": np.percentile(data, 25), </p>
<p class="calibre1">"Median": np.median(data), </p>
<p class="calibre1">"Q3": np.percentile(data, 75), </p>
<p class="calibre1">"Variance": data.var(), </p>
<p class="calibre1">"Histogram": np.histogram(data)</p>
<p class="calibre1">}</p>
<p class="calibre1">return stats</p>
<p class="calibre1">You can add any value to the dictionary. Maybe, you can obtain it from a NumPy function or method or from a function developed by you. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">You can find more information on NumPy statistics in</p>
<p class="calibre1"><a href="http://docs.scipy.org/doc/numpy/reference/routines.statistics.html">http://docs.scipy.org/doc/numpy/reference/routines.statistics.html</a> and</p>
<p class="calibre1"><a href="http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods">http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods</a>. </p>
<p class="calibre1">2.  Run the code with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i>. You should get more values as the output: Raster data - basic statistics. </p>
<p class="calibre1">---------  </p>
<p class="calibre1">Q1         992.0</p>
<p class="calibre1">Q3         1303.0</p>
<p class="calibre1">Minimum    671</p>
<p class="calibre1">Variance   37075.0925323</p>
<p class="calibre1">Histogram  (array([ 83917, 254729,  ..., 44225, 8279, 2068]), array([  671. ,   783.7, ..., 1685.3, 1798.]))</p>
<p class="calibre1">Median     1140.0</p>
<p class="calibre1">Maximum    1798</p>
<p class="calibre1">Mean       1139.06559874</p>
<p class="calibre1">---------  ---------------</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p322"/>Note in the output that the histogram is composed of two arrays: one containing the number of occurrences and the other containing the top limit for each bin. Since we are dealing with geographic data, it would be better if this information came translated into the amount of area for each interval. </p>
<p class="calibre1">To do this, we just need to multiply the number of currencies (the number of pixels within a given range) by the area represented by each pixel. We will get to this after we prepare a few things in the next topics. </p>
<p class="calibre1"><a id="p323"/><b class="calibre3">Making statistics a lazy property</b></p>
<p class="calibre1">Our statistics is working fine and we will make an improvement now. Instead of calculating the statistics that we need all the time, we will calculate it only once and only when it’s needed for the first time. </p>
<p class="calibre1">We will use two very useful programming techniques: <b class="calibre3">lazy evaluation</b> and <b class="calibre3">memoization</b>. </p>
<p class="calibre1">Lazy evaluation is when a process or calculation is delayed and only performed when needed. Memoization is when the results of an expensive process are stored for later use to avoid them being recalculated every time we may need them. </p>
<p class="calibre1">Let’s see how it works:</p>
<p class="calibre1">1.  Add a new _stats property to the __init__ method:</p>
<p class="calibre1">class RasterData(object):</p>
<p class="calibre1">def __init__(self, input_data, unchanged=True, shape=None):</p>
<p class="calibre1">"""Represents a raster data in the form of an array. </p>
<p class="calibre1">:param input_data: Raster files or Numpy array. </p>
<p class="calibre1">:param unchanged: True to keep the original format. </p>
<p class="calibre1">:param shape: When using multiple input data, this param</p>
<p class="calibre1">determines the shape of the composition. </p>
<p class="calibre1">""" </p>
<p class="calibre1">self.data = None</p>
<p class="calibre1">self._stats = None</p>
<p class="calibre1">if isinstance(input_data, list) \</p>
<p class="calibre1">or isinstance(input_data, tuple):</p>
<p class="calibre1">self.combine_images(input_data, shape)</p>
<p class="calibre1">else:</p>
<p class="calibre1">self.import_data(input_data, unchanged)</p>
<p class="calibre1">The property name starts with an underscore. Remember that this notation shows that the property should only be accessed from the instance itself. This property will work as a cache to store the statistics. </p>
<p class="calibre1">2.  Now add a property method that will return the statistics:</p>
<p class="calibre1">#... </p>
<p class="calibre1">@property</p>
<p class="calibre1">def stats(self):</p>
<p class="calibre1">if self._stats is None:</p>
<p class="calibre1">self._stats = self._calculate_stats()</p>
<p class="calibre1">return self._stats</p>
<p class="calibre1">When this property is accessed, it verifies that if _stats is None. If so, it calculates the statistics and stores the results into _stats. The next time we need it, it only returns what’s stored. </p>
<p class="calibre1">Making a property lazy and adding memoization to it is important when the process to obtain this information is costly. The processing power and time is used only once when the given property is needed. </p>
<p class="calibre1">3.  Now, change the __repr__ method to use this new functionality:</p>
<p class="calibre1"><a id="p324"/># ... </p>
<p class="calibre1">def __repr__(self):        </p>
<p class="calibre1">stats = self._format_stats(self.stats)</p>
<p class="calibre1">return "Raster data basic statistics.\n {}".format(stats)</p>
<p class="calibre1"><a id="p325"/>
<a id="p326"/><b class="calibre3">Creating color classified images</b></p>
<p class="calibre1">If we want to display image information on a map, we must prepare a visual output of what we got. A common and efficient form of visual representation is to separate values into classes and give each class a different color. In our case, we can split the data into altitude classes. NumPy makes it easy for us. Let’s write a method that can be called in the pipeline to get started:</p>
<p class="calibre1">1.  Add a new method to the RasterData class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def colorize(self, style):</p>
<p class="calibre1">"""Produces an BGR image based on a style containing limits and colors. </p>
<p class="calibre1">:param style: A list of limits and colors. </p>
<p class="calibre1">""" </p>
<p class="calibre1">shape = self.data.shape</p>
<p class="calibre1">limits = []</p>
<p class="calibre1">colors = []</p>
<p class="calibre1"># Separate the limits and colors. </p>
<p class="calibre1">for item in style:</p>
<p class="calibre1">limits.append(item[0])</p>
<p class="calibre1">colors.append(self._convert_color(item[1]))</p>
<p class="calibre1">colors = np.array(colors)</p>
<p class="calibre1"># Put each color in its limits. </p>
<p class="calibre1">flat_array = self.data.flatten()</p>
<p class="calibre1">di_array = np.digitize(flat_array, limits)</p>
<p class="calibre1">di_array = di_array.reshape((shape[0], shape[1], 1))</p>
<p class="calibre1">results = np.choose(di_array, colors)</p>
<p class="calibre1"># Convert from  RGB to BGR. </p>
<p class="calibre1">results = np.asarray(results, dtype=np.uint8)</p>
<p class="calibre1">results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)</p>
<p class="calibre1">self.data = results</p>
<p class="calibre1">return self</p>
<p class="calibre1">In order to achieve what we want, two important things happen here. First, the data is indexed into classes by NumPy’s digitize function. Then, each class receives an RGB value with the defined color. This is done using the choose function. </p>
<p class="calibre1">This method takes a style as an argument. This style is a list of limits and colors, like a map legend. For example, the style can be defined as: style = [[700, "#f6eff7"], </p>
<p class="calibre1">[900, "#bdc9e1"], </p>
<p class="calibre1">[1100, "#67a9cf"], </p>
<p class="calibre1">[1300, "#1c9099"], </p>
<p class="calibre1">[1800, "#016c59"]]</p>
<p class="calibre1">This means that all the values below 700 will have the color "#f6eff7" and so on. The colors are expressed in hex notations. This notation is popular with web applications and is chosen here because it’s short and easy to type or copy. </p>
<p class="calibre1"><a id="p327"/>At this point, note that inside this method, we called the _convert_color method that will perform the conversion of the color notation. Let’s add this method to the class: 1.  Add the _convert_color method to the class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def _convert_color(self, color_code):</p>
<p class="calibre1">"""Converts the color notation. </p>
<p class="calibre1">:param color_code: A string containing the color in hex</p>
<p class="calibre1">or JavaScript notation. </p>
<p class="calibre1">""" </p>
<p class="calibre1">if color_code[0] == "#":</p>
<p class="calibre1">result = (int(color_code[1:3], 16), </p>
<p class="calibre1">int(color_code[3:5], 16), </p>
<p class="calibre1">int(color_code[5:7], 16))</p>
<p class="calibre1">elif color_code[:3] == "rgb":</p>
<p class="calibre1">result = map(int, color_code[4:-1].split(','))</p>
<p class="calibre1">else:</p>
<p class="calibre1">raise ValueError("Invalid color code.")</p>
<p class="calibre1">return result</p>
<p class="calibre1">2.  Finally, edit the if __name__ == '__main__': block to test our code: if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">style = [[700, "#f6eff7"], </p>
<p class="calibre1">[900, "#bdc9e1"], </p>
<p class="calibre1">[1100, "#67a9cf"], </p>
<p class="calibre1">[1300, "#1c9099"], </p>
<p class="calibre1">[1800, "#016c59"]]</p>
<p class="calibre1">raster_data.colorize(style).write_image(</p>
<p class="calibre1">'output/classified.png')</p>
<p class="calibre1">3.  Run the code and then open the output image to see the results:</p>
<p class="calibre1"><a id="p328"/><img src="img/index-328_1.jpg" alt="Image 53" class="calibre2"/></p>
<p class="calibre1"><a id="p329"/><img src="img/index-329_1.jpg" alt="Image 54" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Choosing the right colors for a map</b></p>
<p class="calibre1">The choice of what colors to use in a map is one determining factor as to whether the map would be capable of correctly passing the desired information. In order to choose a good set of colors, some factors should be considered:</p>
<p class="calibre1">The ability of the human eye to distinguish hues—the classes need to be visually distinguishable, otherwise the map may contain colors that may look the same to some people</p>
<p class="calibre1">The media that the map will be presented on (for example, paper or screen)—</p>
<p class="calibre1">depending on the media, the colors may suffer small changes that may compromise the readability of the map</p>
<p class="calibre1">Colorblind safety—this is an inclusion measure and it allows the information to be interpreted by a wider audience</p>
<p class="calibre1">The type of data (for example, sequential or qualitative)—use colors that match what you want to show</p>
<p class="calibre1">There are a number of studies on this subject and the ones made by Cynthia Brewer are very practical and popular among modern map makers. She produced an extensive set of colors to be used in maps and made this information available for use under the name of ColorBrewer. </p>
<p class="calibre1">Let’s change the colors of our map with the help of ColorBrewer: 1.  Access the<a href="http://colorbrewer2.org/"> http://colorbrewer2.org/ </a>website. You should see this interface:</p>
<p class="calibre1"><a id="p330"/><img src="img/index-330_1.jpg" alt="Image 55" class="calibre2"/></p>
<p class="calibre1">2.  The left-hand side panel allows you to set the parameters to choose the color. At the top, change <b class="calibre3">Number of data classes</b> to <b class="calibre3">5</b> as in our data. </p>
<p class="calibre1">3.  About the nature of our data, two options would go well, sequential or diverging. I will choose diverging for this example. </p>
<p class="calibre1">4.  Before choosing a color scheme, if you wish, you can filter the schemes by <b class="calibre3">colorblind safe</b>, <b class="calibre3">print friendly</b> and <b class="calibre3">photocopy safe</b>. </p>
<p class="calibre1">5.  Now, pick a color scheme that pleases you and note that the bottom right section of the panel and the map will change to show the colors of this scheme. </p>
<p class="calibre1">6.  Let’s export this scheme in a practical way to it use in our code. Click on the <b class="calibre3">EXPORT</b> tab just to the right of the colors. A new panel will open as follows: 7.  Note that the <b class="calibre3">JavaScript</b> box contains a list of RGB values. We can easily parse this information in our code. So, we will select its contents and copy it. </p>
<p class="calibre1">8.  Go back to our code and paste the colors to a variable named colorbrewer in the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)', </p>
<p class="calibre1">'rgb(247,247,247)','rgb(146,197,222)', </p>
<p class="calibre1">'rgb(5,113,176)']</p>
<p class="calibre1">raster_data = RasterData('data/dem.tif')</p>
<p class="calibre1">style = [[700, "#f6eff7"], </p>
<p class="calibre1">[900, "#bdc9e1"], </p>
<p class="calibre1">[1100, "#67a9cf"], </p>
<p class="calibre1">[1300, "#1c9099"], </p>
<p class="calibre1">[1800, "#016c59"]]</p>
<p class="calibre1">raster_data.colorize(style).write_image(</p>
<p class="calibre1">'output/classified.png')</p>
<p class="calibre1"><a id="p331"/>At this point, the style is not yet complete. There are two problems: the colors are in a format different from what we need and we don’t have the limits associated with them. Since we want the process to be as practical as possible, we will write the code to solve these two issues instead of manually converting the colors and associating them with the limits. </p>
<p class="calibre1">First, let’s implement the capability of our program to accept colors and limits separately. </p>
<p class="calibre1">9.  Put the limits that were in the style definition into a different list: if __name__ == '__main__':</p>
<p class="calibre1">colorbrewer = ['rgb(202,0,32)','rgb(244,165,130)', </p>
<p class="calibre1">'rgb(247,247,247)','rgb(146,197,222)', </p>
<p class="calibre1">'rgb(5,113,176)']</p>
<p class="calibre1">limits = [700, 900, 1100, 1300, 1800]</p>
<p class="calibre1">raster_data = RasterData('data/dem.tif')</p>
<p class="calibre1">raster_data.colorize(style).write_image('output/classified.png') 10.  Now edit the colorize method:</p>
<p class="calibre1">#.. </p>
<p class="calibre1">def colorize(self, limits, raw_colors):</p>
<p class="calibre1">"""Produces an BGR image based on a style containing limits and colors. </p>
<p class="calibre1">:param limits: A list of limits. </p>
<p class="calibre1">:param raw_colors: A list of color codes.        """ </p>
<p class="calibre1">shape = self.data.shape</p>
<p class="calibre1">colors = []</p>
<p class="calibre1">for item in raw_colors:</p>
<p class="calibre1">colors.append(self._convert_color(item))</p>
<p class="calibre1">colors = np.array(colors)</p>
<p class="calibre1"># Put each color in its limits. </p>
<p class="calibre1">flat_array = self.data.flatten()</p>
<p class="calibre1">di_array = np.digitize(flat_array, limits, right=True)</p>
<p class="calibre1">di_array = di_array.reshape((shape[0], shape[1], 1))</p>
<p class="calibre1">results = np.choose(di_array, colors)</p>
<p class="calibre1"># Convert from  RGB to BGR. </p>
<p class="calibre1">results = np.asarray(results, dtype=np.uint8)</p>
<p class="calibre1">results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)</p>
<p class="calibre1">self.data = results</p>
<p class="calibre1">return self</p>
<p class="calibre1">This method now takes two arguments instead of just the style. The only task that remains is to convert this new color format. </p>
<p class="calibre1">11.  Edit the _convert_color method:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def _convert_color(self, color_code):</p>
<p class="calibre1">"""Converts the color notation. </p>
<p class="calibre1">:param color_code: A string containing the color in hex</p>
<p class="calibre1">or JavaScript notation. </p>
<p class="calibre1">""" </p>
<p class="calibre1"><a id="p332"/>        if color_code[0] == "#": result = (int(color_code[1:3], 16), </p>
<p class="calibre1">int(color_code[3:5], 16), </p>
<p class="calibre1">int(color_code[5:7], 16))</p>
<p class="calibre1">elif color_code[:3] == "rgb":</p>
<p class="calibre1">result = map(int, color_code[4:-1].split(',')) </p>
<p class="calibre1">else:          </p>
<p class="calibre1">raise ValueError("Invalid color code.")</p>
<p class="calibre1">return result</p>
<p class="calibre1">This method is now able to detect and convert the two color codes that we use. It can also raise an exception in case the color code is not recognized. </p>
<p class="calibre1">12.  To test the code, edit the if __name__ == '__main__': block to be compliant with the new format:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">colors = ['rgb(202,0,32)', 'rgb(244,165,130)', </p>
<p class="calibre1">'rgb(247,247,247)', 'rgb(146,197,222)', </p>
<p class="calibre1">'rgb(5,113,176)']</p>
<p class="calibre1">limits = [700, 900, 1100, 1300, 1800]</p>
<p class="calibre1">raster_data.colorize(limits, colors).write_image(</p>
<p class="calibre1">'output/classified.png')</p>
<p class="calibre1">13.  Finally, run the code with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and check the output. The schema I chose produced the following result:</p>
<p class="calibre1"><a id="p333"/><img src="img/index-333_1.jpg" alt="Image 56" class="calibre2"/></p>
<p class="calibre1">Despite the fact that this is a beautiful image, there is a mistake in the choice of colors. The warm colors are representing lower altitudes. This could lead to confusions, since on most maps, the rule is warmer the color, higher is the value. </p>
<p class="calibre1">It’s only a mater of inverting the colors. Let’s add an option to our colorize method to do this. </p>
<p class="calibre1">14.  Edit the colorize method:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def colorize(self, limits, raw_colors, invert_colors=False):</p>
<p class="calibre1">"""Produces an BGR image based on a style containing limits and colors. </p>
<p class="calibre1">:param limits: A list of limits. </p>
<p class="calibre1">:param raw_colors: A list of color codes. </p>
<p class="calibre1">:param invert_colors: Invert the order of the colors. </p>
<p class="calibre1">""" </p>
<p class="calibre1">shape = self.data.shape</p>
<p class="calibre1">colors = []</p>
<p class="calibre1">if invert_colors:</p>
<p class="calibre1">raw_colors = list(reversed(raw_colors))</p>
<p class="calibre1"># Convert the colors. </p>
<p class="calibre1"><a id="p334"/><img src="img/index-334_1.jpg" alt="Image 57" class="calibre2"/></p>
<p class="calibre1">for item in raw_colors:</p>
<p class="calibre1">colors.append(self._convert_color(item))</p>
<p class="calibre1">colors = np.array(colors)</p>
<p class="calibre1"># Put each color in its limits. </p>
<p class="calibre1">flat_array = self.data.flatten()</p>
<p class="calibre1">di_array = np.digitize(flat_array, limits, right=True)</p>
<p class="calibre1">di_array = di_array.reshape((shape[0], shape[1], 1))</p>
<p class="calibre1">results = np.choose(di_array, colors)</p>
<p class="calibre1"># Convert from  RGB to BGR. </p>
<p class="calibre1">results = np.asarray(results, dtype=np.uint8)</p>
<p class="calibre1">results = cv2.cvtColor(results, cv2.COLOR_RGB2BGR)</p>
<p class="calibre1">self.data = results</p>
<p class="calibre1">return self</p>
<p class="calibre1">15.  Now, edit the if __name__ == '__main__': block again:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">colors = ['rgb(202,0,32)', 'rgb(244,165,130)', </p>
<p class="calibre1">'rgb(247,247,247)', 'rgb(146,197,222)', </p>
<p class="calibre1">'rgb(5,113,176)']</p>
<p class="calibre1">limits = [700, 900, 1100, 1300, 1800]</p>
<p class="calibre1">raster_data.colorize(limits, colors, True).write_image(</p>
<p class="calibre1">'output/classified.png')</p>
<p class="calibre1">16.  Run the code and look at the new output:</p>
<p class="calibre1"><a id="p335"/>
<a id="p336"/>
<a id="p337"/><b class="calibre3">Blending images</b></p>
<p class="calibre1">We can make our results even more visually appealing and informative if we can combine the colorized image with the shaded relief image. Again, since we are dealing with arrays, we may deduce that this kind of composition can be achieved by performing an arithmetic operation between the two arrays. </p>
<p class="calibre1">In image processing, this is called <b class="calibre3">alpha blending</b>. Basically, a  <i class="calibre4">transparency</i> is applied to both of the images and then they are blended into a new one. In the next steps, we are going to create a function that performs this operation:</p>
<p class="calibre1">1.  First, to avoid generating the shaded relief multiple times, let’s save it on the disk and edit the if __name__ == '__main__': block of the raster_data.py file: if __name__ == '__main__':</p>
<p class="calibre1">raster_data = RasterData('output/dem.tif')</p>
<p class="calibre1">raster_data.adjust_values().create_hillshade(</p>
<p class="calibre1">10, 60).write_image('output/shaded.png')</p>
<p class="calibre1">2.  Run the code and check whether the image was correctly written on the disk. </p>
<p class="calibre1">3.  Now, add the alpha_blend method to the RasterData class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def alpha_blend(self, raster_data, alpha=0.5):</p>
<p class="calibre1">"""Blend this raster data with another one. </p>
<p class="calibre1">:param raster_data: RasterData instance. </p>
<p class="calibre1">:param alpha: Amount of transparency to apply. </p>
<p class="calibre1">""" </p>
<p class="calibre1">shade = cv2.cvtColor(raster_data.data, cv2.COLOR_GRAY2BGR)</p>
<p class="calibre1">result = (1-alpha) * self.data + alpha * shade</p>
<p class="calibre1">self.data = result</p>
<p class="calibre1">return self</p>
<p class="calibre1">4.  Finally, edit the if __name__ == '__main__': block again to test the code: if __name__ == '__main__':</p>
<p class="calibre1">shaded = RasterData('output/shaded.png')</p>
<p class="calibre1">classified = RasterData('output/classified.png')</p>
<p class="calibre1">classified.alpha_blend(shaded).write_image(</p>
<p class="calibre1">'output/color_shade.png')</p>
<p class="calibre1">5.  Run the code and check the image in the output folder:</p>
<p class="calibre1"><a id="p338"/><img src="img/index-338_1.jpg" alt="Image 58" class="calibre2"/></p>
<p class="calibre1">You should see this beautiful output. Note how the combination of the shaded relief with the colorized image produces a map that transmits a lot of information even for untrained eyes. </p>
<p class="calibre1"><a id="p339"/>
<a id="p340"/><img src="img/index-340_1.jpg" alt="Image 59" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Showing statistics with colors</b></p>
<p class="calibre1">How the map is colorized is only a matter of defining the limits and colors in the style. So, if we want to translate statistical information into colors, we just need to associate the values that we want with a sequence of colors. </p>
<p class="calibre1">First, let’s try it with the quartiles:</p>
<p class="calibre1">1.  Since everything is prepared in our class, we just need to change the code in the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">dem = RasterData('output/dem.tif')</p>
<p class="calibre1">shaded = RasterData('output/shaded.png')</p>
<p class="calibre1">limits = [dem.stats['Q1'], </p>
<p class="calibre1">dem.stats['Q3'], </p>
<p class="calibre1">dem.stats['Maximum']]</p>
<p class="calibre1">colors = ["#fc8d59", "#ffffbf", "#91cf60"]</p>
<p class="calibre1">dem.colorize(limits, colors).write_image('output/stats.png') dem.alpha_blend(shaded).write_image('output/shaded_stats.png') The following image illustrates the colored output for the analyzed parameters:</p>
<p class="calibre1"><a id="p341"/><img src="img/index-341_1.jpg" alt="Image 60" class="calibre2"/></p>
<p class="calibre1">For this image you can start the lead-in this way:</p>
<p class="calibre1"><a id="p342"/><b class="calibre3">Using the histogram to colorize the image</b> We can also use the histogram to colorize the maps. The histogram generated by NumPy is composed of two one-dimensional arrays. The first contains the number of occurrences in a given interval (that is, the number of pixels). The second one contains the  <i class="calibre4">bins</i> or the limits. By default, the histogram is produced with 11 bins, so we also need 11 different colors to produce a map. Let’s change our tests to see how this works: 1.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">dem = RasterData('data/dem.tif')</p>
<p class="calibre1">shaded = RasterData('output/shaded.png')</p>
<p class="calibre1">colors = ['rgb(103,0,31)','rgb(178,24,43)','rgb(214,96,77)', </p>
<p class="calibre1">'rgb(244,165,130)','rgb(253,219,199)', </p>
<p class="calibre1">'rgb(247,247,247)','rgb(209,229,240)', </p>
<p class="calibre1">'rgb(146,197,222)','rgb(67,147,195)', </p>
<p class="calibre1">'rgb(33,102,172)','rgb(5,48,97)']</p>
<p class="calibre1">limits = dem.stats['Histogram'][1]</p>
<p class="calibre1">dem.colorize(limits, colors, True).write_image('output/hist.png') dem.alpha_blend(shaded).write_image('output/shaded_hist.png') The colors here are also obtained from ColorBrewer. They are of a diverging nature from red to blue. The limits were taken from the histogram by simply using the stats property and the second array, which contains the bins. </p>
<p class="calibre1">2.  Run the code and look at the output. </p>
<p class="calibre1"><a id="p343"/><img src="img/index-343_1.jpg" alt="Image 61" class="calibre2"/></p>
<p class="calibre1">And the shaded result should look as the following image:</p>
<p class="calibre1"><a id="p344"/><img src="img/index-344_1.jpg" alt="Image 62" class="calibre2"/></p>
<p class="calibre1">Using more classes resulted in a better representation of the altitude variation and it allowed us to clearly see the peaks with high altitudes. </p>
<p class="calibre1"><a id="p345"/>
<a id="p346"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we took raw raster data, and with a series of techniques, we were able to extract statistical information from it and display it on high quality maps. These procedures took us to a high level of communication in terms of geospatial information because the material produced is easy to interpret, even for untrained eyes. </p>
<p class="calibre1">In the next chapter, we will enter a new field and start taking care of the efficiency of our code in order to process massive geospatial datasets in a timely manner. </p>
<p class="calibre1"><a id="p347"/>
<a id="p348"/><b class="calibre3">Chapter 8. Data Miner App</b></p>
<p class="calibre1">New challenges appear, to the extent that data size increases. Large sets of data bring problems related to excessive processing time and great memory consumption. These problems may turn data analysis into a painful process or may even make it completely impossible. </p>
<p class="calibre1">In this chapter, we will create an application capable of processing huge datasets in an efficient way. We will review our code, implementing new tools and techniques that will make our analysis not only run faster, but also make better use of computer hardware, allowing virtually any amount of data to be processed. </p>
<p class="calibre1">In order to achieve those goals, we will learn how to use databases and how to stream the data into them, making the use of computing power constant and stable regardless of the amount of data. </p>
<p class="calibre1">These tools will also enable us to perform more advanced searches, calculations, and cross information from different sources, allowing you to mine the data for precious information. </p>
<p class="calibre1">This chapter will cover the following topics:</p>
<p class="calibre1">What code efficiency is and how to measure it</p>
<p class="calibre1">How to import data into a spatial database</p>
<p class="calibre1">How to abstract database data into Python objects</p>
<p class="calibre1">Making queries and getting information from a spatial database Understanding code efficiency</p>
<p class="calibre1">What constitutes efficient code depends on the points that are being analyzed. When we talk about computational efficiency, there are four points that may be taken into consideration:</p>
<p class="calibre1">The time the code takes to execute</p>
<p class="calibre1">How much memory it uses to run</p>
<p class="calibre1">How much disk space it uses</p>
<p class="calibre1">Whether the code uses all the available computing power</p>
<p class="calibre1">Good and efficient code is not only about computational efficiency; it’s also about writing code that brings these favorable qualities to the development process (to cite just a few of them):</p>
<p class="calibre1">Clean and organized code</p>
<p class="calibre1">Readable code</p>
<p class="calibre1">Easy to maintain and debug</p>
<p class="calibre1">Generalized</p>
<p class="calibre1">Shielded against misuse</p>
<p class="calibre1">It’s obvious that some points are contradictory. Here are just a few examples. To speed up a process, you may need to use more memory. To use less memory, you may need more disk space. Alternatively, for faster code, you may need to give up on generalization and</p>
<p class="calibre1"><a id="p349"/>write very specific functions. </p>
<p class="calibre1">It is the developer who determines the balance between antagonistic characteristics, based on the software requirements and the gains obtained by investing in one point or another. </p>
<p class="calibre1">For example, if much cleaner code can be written with very little penalty in terms of execution time, the developer may opt for clean and maintainable code that will be easier for him and his team to understand. </p>
<p class="calibre1">The second block of good characteristics is prone to human evaluation, whereas the items in the first block can be measured and compared by the computer. </p>
<p class="calibre1"><a id="p350"/><b class="calibre3">Measuring execution time</b></p>
<p class="calibre1">In order to measure how fast a piece of code is executed, we need to measure its execution time. The time measured is relative and varies, depending on a number of factors: the operating system, whether there are other programs running, the hardware, and so on. </p>
<p class="calibre1">For our efficiency tests, we will measure the execution time, make changes in the code, and measure it again. In this way, we will see if the changes improve the code efficiency or not. </p>
<p class="calibre1">Let’s start with a simple example and measure how long it takes to run. </p>
<p class="calibre1">1.  As before, make a copy of the previous chapter folder in your geopy project and rename it as Chapter8. Your project structure should look like this:</p>
<p class="calibre1">├───Chapter1</p>
<p class="calibre1">├───Chapter2</p>
<p class="calibre1">├───Chapter3</p>
<p class="calibre1">├───Chapter4</p>
<p class="calibre1">├───Chapter5</p>
<p class="calibre1">├───Chapter6</p>
<p class="calibre1">├───Chapter7</p>
<p class="calibre1">├───Chapter8</p>
<p class="calibre1">│   ├───experiments</p>
<p class="calibre1">│   ├───map_maker</p>
<p class="calibre1">│   ├───output</p>
<p class="calibre1">│   └───utils</p>
<p class="calibre1">└───data</p>
<p class="calibre1">2.  Click on your experiments folder and create a new Python file inside it. Name that file timing.py. </p>
<p class="calibre1">3.  Now add the following code to that file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">def make_list1(items_list):</p>
<p class="calibre1">result = "" </p>
<p class="calibre1">for item in items_list:</p>
<p class="calibre1">template = "I like {}. \n" </p>
<p class="calibre1">text = template.format(item)</p>
<p class="calibre1">result = result + text</p>
<p class="calibre1">return result</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']</p>
<p class="calibre1">print(make_list1(my_list))</p>
<p class="calibre1">4.  Run the code. Press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and select a timing from the list. You should get this output:</p>
<p class="calibre1">I like bacon. </p>
<p class="calibre1">I like lasagna. </p>
<p class="calibre1"><a id="p351"/>I like salad. </p>
<p class="calibre1">I like eggs. </p>
<p class="calibre1">I like apples. </p>
<p class="calibre1">Nothing fancy, it’s a simple inefficient function to format texts and produce a printable list of things. </p>
<p class="calibre1">5.  Now we are going to measure how long it takes to execute. Modify your code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from timeit import timeit</p>
<p class="calibre1">def make_list1(items_list):</p>
<p class="calibre1">result = "" </p>
<p class="calibre1">for item in items_list:</p>
<p class="calibre1">template = "I like {}. \n" </p>
<p class="calibre1">text = template.format(item)</p>
<p class="calibre1">result = result + text</p>
<p class="calibre1">return result</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']</p>
<p class="calibre1">number = 100</p>
<p class="calibre1">execution_time = timeit('make_list1(my_list)', </p>
<p class="calibre1">setup='from __main__ import make_list1, my_list', </p>
<p class="calibre1">number=number)</p>
<p class="calibre1">print("It took {}s to execute the code {} times".format(</p>
<p class="calibre1">execution_time, number))</p>
<p class="calibre1">6.  Run your code again with  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and look at the results: It took 0.000379365835017s to execute the code 100 times</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Here we are using the timeit module to measure the execution time of our function. </p>
<p class="calibre1">Since some pieces of code run vary fast, we need to repeat the execution many times to get a more precise measurement and a more meaningful number. The number of times that the statement is repeated is given by the number parameter. </p>
<p class="calibre1">7.  Increase your number parameter to 1000000 and run the code again: It took 3.66938576408s to execute the code 1000000 times</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Now we have a more consistent number to work with. If your computer is much faster than mine you can increase the number. If it’s slower, decrease it. </p>
<p class="calibre1">Grab a piece of paper and take note of that result. We are going to change the function and see if we make the code more efficient. </p>
<p class="calibre1"><a id="p352"/>8.  Add another version of our function; name it make_list2: def make_list2(items_list):</p>
<p class="calibre1">result = "" </p>
<p class="calibre1">template = "I like {}. \n" </p>
<p class="calibre1">for item in items_list:        </p>
<p class="calibre1">text = template.format(item)</p>
<p class="calibre1">result = result + text</p>
<p class="calibre1">return result</p>
<p class="calibre1">9.  Also change your if __name__ == '__main__': block. We will make it clear which version of the function we are executing:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']</p>
<p class="calibre1">number = 1000000</p>
<p class="calibre1">function_version = 2</p>
<p class="calibre1">statement = 'make_list{}(my_list)'.format(function_version) setup = 'from __main__ import make_list{}, my_list'.format(</p>
<p class="calibre1">function_version)</p>
<p class="calibre1">execution_time = timeit(statement, setup=setup, number=number) print("Version {}.".format(function_version))</p>
<p class="calibre1">print("It took {}s to execute the code {} times".format(</p>
<p class="calibre1">execution_time, number))</p>
<p class="calibre1">10.  Run the code again and see your results. On my computer, I got this: Version 2. </p>
<p class="calibre1">It took 3.5384931206s to execute the code 1000000 times</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">That was a slight improvement in execution time. The only change that was made in version 2 was that we moved the template out of the for loop. </p>
<p class="calibre1">11.  Make a third version of the function:</p>
<p class="calibre1">def make_list3(items_list):</p>
<p class="calibre1">result = "" </p>
<p class="calibre1">template = "I like " </p>
<p class="calibre1">for item in items_list:</p>
<p class="calibre1">text = template + item + ". \n" </p>
<p class="calibre1">result = result + text</p>
<p class="calibre1">return result</p>
<p class="calibre1">12.  Change your function_version variable to 3 and run the code again: Version 3. </p>
<p class="calibre1">It took 1.88675713574s to execute the code 1000000 times</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Now we changed how the string "I like " is formed. Instead of using string formatting, we added parts of the string and got code that ran almost twice as fast as the previous version. </p>
<p class="calibre1"><a id="p353"/>You can find out which small changes will reduce the execution time by trial and error, by consulting articles on the Internet, or by experience. But there is a more assertive and powerful way to find out where your code spends more time; this is called <b class="calibre3">profiling</b>. </p>
<p class="calibre1"><a id="p354"/>
<a id="p355"/><b class="calibre3">Code profiling</b></p>
<p class="calibre1">By trial, we found that the most expensive part of our code was the string formatting. </p>
<p class="calibre1">When your code gets more complex, finding bottlenecks by this method gets harder and at some point becomes impractical. </p>
<p class="calibre1">The solution is to break and analyze small pieces of code. To see how long they take to execute, make a profile of the code. </p>
<p class="calibre1">Python comes with a good profiling tool that automates this process to a certain level. </p>
<p class="calibre1">Let’s use it on our code to see what it tells us:</p>
<p class="calibre1">1.  Add this import at the beginning of the file:</p>
<p class="calibre1">from timeit import timeit</p>
<p class="calibre1"><b class="calibre3">import cProfile</b></p>
<p class="calibre1">2.  Edit your if __name__ == '__main__': block to use the profiler: if __name__ == '__main__':</p>
<p class="calibre1">my_list = ['bacon', 'lasagna', 'salad', 'eggs', 'apples']</p>
<p class="calibre1">number = 1000000    </p>
<p class="calibre1">profile = cProfile.Profile()</p>
<p class="calibre1">profile.enable()</p>
<p class="calibre1">for i in range(number):</p>
<p class="calibre1">make_list1(my_list)</p>
<p class="calibre1">profile.disable()</p>
<p class="calibre1">profile.print_stats(sort='cumulative')</p>
<p class="calibre1">3.  Run the code. You should see the profiler statistics on the console. (I suppressed some information for reasons of space):</p>
<p class="calibre1">6000002 function calls in 4.755 seconds</p>
<p class="calibre1">Ordered by: cumulative time</p>
<p class="calibre1">ncalls  tottime  percall  cumtime  percall </p>
<p class="calibre1">1000000    2.718    0.000    4.738    0.000 timing.py</p>
<p class="calibre1">5000000    2.019    0.000    2.019    0.000 {'format' ...}</p>
<p class="calibre1">1    0.017    0.017    0.017    0.017 {range}</p>
<p class="calibre1">1    0.000    0.000    0.000    0.000 {'disable' ...}</p>
<p class="calibre1">There are many ways to execute the profiler. In our case, we instantiated the Profile class and used the enable and disable methods to tell the profiler where to start and stop collecting data. Again, the call to make_list1 was repeated 1000000 times to generate bigger numbers. </p>
<p class="calibre1">In the output, we can see that make_list1 was called 1000000 times and the format method was called five million times, taking 2.019 seconds. Note that the profiler only gave information regarding methods and functions. </p>
<p class="calibre1"><a id="p356"/>
<a id="p357"/><b class="calibre3">Storing information on a database</b></p>
<p class="calibre1">In the previous chapters, the basic workflow was to import all the data into memory as Python objects every time we ran the code. That’s perfectly fine and efficient when we work with small pieces of data. </p>
<p class="calibre1">At some point, you may have noticed that the performance of our code was debilitated, especially when we started importing country boundaries along with all the attributes. This happened because importing attributes is slow. </p>
<p class="calibre1">Secondly, although our filtering mechanisms worked pretty well, we may have problems when dealing with huge datasets. </p>
<p class="calibre1">The formula to solve these problems is very simple and consists of only two basic ingredients:</p>
<p class="calibre1">Get only what you need</p>
<p class="calibre1">Use indexed searches</p>
<p class="calibre1">The first point is about getting only the records you need, as well as getting only the attributes that are desired for a given analysis. </p>
<p class="calibre1">The second point is about how things are found. In our method, a loop tests every record for a condition until the desired one is found (that is, the test returns True). Alternatively, if the computer somehow had an idea of where the item was, the search would be much faster; this is indexing. </p>
<p class="calibre1">Instead of trying to implement these features by ourselves, we can use a database to handle these mechanisms for us; they are state-of-the-art for this kind of job. </p>
<p class="calibre1">Here we have two options:</p>
<p class="calibre1">Use a <b class="calibre3">SQLite</b> database with the <b class="calibre3">Spatialite </b>extension, which is an open source, simple, and very efficient SQL database. It doesn’t require a server or installation, and Python comes bundled with a connector to it. </p>
<p class="calibre1">Use a <b class="calibre3">PostgreSQL</b> database with the <b class="calibre3">Postgis</b> extension. Also open source and powerful, this is a full-featured database server. </p>
<p class="calibre1">The choice is up to you and will have no influence on the code except for a small change in the settings. </p>
<p class="calibre1"><b class="calibre3">Tip</b></p>
<p class="calibre1">PostgreSQL can be download from:<a href="http://www.postgresql.org/"> http://www.postgresql.org/. </a> In order to enable Postgis, you just need to select it in the stack builder during the installation. </p>
<p class="calibre1">If you are using Ubuntu, you can find more details at:</p>
<p class="calibre1"><a href="https://wiki.ubuntu.com/UbuntuGIS">https://wiki.ubuntu.com/UbuntuGIS. </a></p>
<p class="calibre1"><a id="p358"/><b class="calibre3">Creating an Object Relational Mapping</b></p>
<p class="calibre1"><b class="calibre3">Object Relational Mapping</b> (<b class="calibre3">ORM</b>) is a method that we will use to convert the data stored in a database into Python objects. This no different from what we did before in our models.py file, where we made code that transformed data stored in geographic files (for example, a GPX shapefile) into Python objects. </p>
<p class="calibre1">This time, we will close the circle by importing the data into the database, and then later retrieve data or information from it in the same elegant and intuitive manner as before. </p>
<p class="calibre1">SQL databases, such as SQLite, store the data in tables with row and columns. The following table illustrates how the geocaching data that we previously used would be represented in this format:</p>
<p class="calibre1"><b class="calibre3">ID Geom Name</b></p>
<p class="calibre1"><b class="calibre3">Status</b></p>
<p class="calibre1"><b class="calibre3">Owner Hints</b></p>
<p class="calibre1">1</p>
<p class="calibre1">(wkb) LaSalle Park Available John</p>
<p class="calibre1">Under sign</p>
<p class="calibre1">2</p>
<p class="calibre1">(wkb) Parking</p>
<p class="calibre1">Available Nina</p>
<p class="calibre1">Big tree</p>
<p class="calibre1">We can guess that this is incompatible with the premise of being able to import any type of data, because the type of column is fixed. If we have data with different attributes or more attributes, we need different tables or to add more columns to match every possibility. </p>
<p class="calibre1">To overcome the limitation of this schema, we will use the relational capabilities of SQL</p>
<p class="calibre1">databases. We will store items and attributes in different tables and relate them: <b class="calibre3">Points</b></p>
<p class="calibre1"><b class="calibre3">ID Geom</b></p>
<p class="calibre1">1</p>
<p class="calibre1">42.89 - 78.90</p>
<p class="calibre1">2</p>
<p class="calibre1">43.00 - 78.0</p>
<p class="calibre1"><b class="calibre3">Attributes</b></p>
<p class="calibre1"><b class="calibre3">ID Key</b></p>
<p class="calibre1"><b class="calibre3">Value</b></p>
<p class="calibre1"><b class="calibre3">point_id</b></p>
<p class="calibre1">1</p>
<p class="calibre1">name LaSalle Park 1</p>
<p class="calibre1">2</p>
<p class="calibre1">status Available</p>
<p class="calibre1">1</p>
<p class="calibre1">3</p>
<p class="calibre1">owner John</p>
<p class="calibre1">1</p>
<p class="calibre1">4</p>
<p class="calibre1">hints</p>
<p class="calibre1">under sign</p>
<p class="calibre1">1</p>
<p class="calibre1">5</p>
<p class="calibre1">name Parking</p>
<p class="calibre1">2</p>
<p class="calibre1">6</p>
<p class="calibre1">status Available</p>
<p class="calibre1">2</p>
<p class="calibre1"><a id="p359"/>7</p>
<p class="calibre1">owner Nina</p>
<p class="calibre1">2</p>
<p class="calibre1">8</p>
<p class="calibre1">hints</p>
<p class="calibre1">big tree</p>
<p class="calibre1">2</p>
<p class="calibre1">This key/value data model allows each point (or other objects) to have arbitrary numbers and types of attributes. Each attribute is attached to its owner by an ID. </p>
<p class="calibre1">You may have heard of Django,  <i class="calibre4">batteries-included</i> Python web framework. It happens that Django has a fantastic ORM included in it, and it has very developed support for geospatial databases and geospatial operations (this part of Django is called <b class="calibre3">GeoDjango</b> and is included by default). You will also notice that the transition from our models to Django will be smooth and they will remain easy to use, as before. </p>
<p class="calibre1"><b class="calibre3">Preparing the environment</b></p>
<p class="calibre1">In order to use Django’s ORM we need to setup a Django project. To do that we will prepare the minimum required structure, which consists of a few files and settings. </p>
<p class="calibre1">First, let’s set up our application to use Django. </p>
<p class="calibre1">1.  Inside your Chapter8 folder, create a new Python file named settings.py. If you are using PostgreSQL/Postgis, add the following code to the file: DATABASES = {</p>
<p class="calibre1">'default': {</p>
<p class="calibre1">'ENGINE': 'django.contrib.gis.db.backends.postgis', </p>
<p class="calibre1">'NAME': 'postgres', </p>
<p class="calibre1">'USER': 'postgres', </p>
<p class="calibre1">'PASSWORD': 'mypassword', </p>
<p class="calibre1">'PORT': 5432</p>
<p class="calibre1">}}</p>
<p class="calibre1">The first item (DATABASES) is the database settings. If you have a default PostgreSQL/Postgis installation, this will work. Just change your password for the one you set during the installation. </p>
<p class="calibre1">2.  If you are using SQLite/Spatialite, use this configuration: DATABASES = {</p>
<p class="calibre1">'default': {</p>
<p class="calibre1">'ENGINE': 'django.contrib.gis.db.backends.spatialite', </p>
<p class="calibre1">'NAME': 'mydatabase.db' </p>
<p class="calibre1">}}</p>
<p class="calibre1">3.  After the database configuration, add these items:</p>
<p class="calibre1">INSTALLED_APPS = ('django.contrib.gis', 'geodata')</p>
<p class="calibre1">SECRET_KEY = 'abc' </p>
<p class="calibre1">The INSTALLED_APPS item tells Django where to look for models. SECRET_KEY is used for Django’s user management. Although we won’t use it, this needs to be set (you can use any value as the secret key). </p>
<p class="calibre1">4.  Now create a Python package that will be our Django app. Right-click the Chapter8</p>
<p class="calibre1">folder and select <b class="calibre3">New</b> | <b class="calibre3">Python Package</b>. Name it geodata. </p>
<p class="calibre1"><a id="p360"/>5.  Create a new Python file inside Chapter8 and name it geodata_app.py. </p>
<p class="calibre1"><b class="calibre3">Changing our models</b></p>
<p class="calibre1">We have the basic structure ready, now we need to adapt our models so they can use the database instead of storing all the information in memory. Django’s model definition is very similar to ours. </p>
<p class="calibre1">Using the new capabilities provided by Django, we will make one change in the choice of design: instead of one class for each type of object (geocaching, roads, boundaries, and so on) we will have only one class that can store data for all of them and any others that we can think of. </p>
<p class="calibre1">1.  Create a file models.py inside the geodata folder and add this code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from django.contrib.gis.db import models</p>
<p class="calibre1">class GeoObject(models.Model):</p>
<p class="calibre1">geom = models.GeometryField()</p>
<p class="calibre1">atype = models.CharField(max_length=20)</p>
<p class="calibre1">objects = models.GeoManager()</p>
<p class="calibre1">The GeoObject class represents a single object (a single row in a table). It can accept any kind of geometry (a point, polygon, and so on) in the geom field. The atype property represents the high-level type of the object. This property will tell us if it’s a geocaching point or something else (we are using atype and not type to avoid conflicts with the internal type() function). </p>
<p class="calibre1">Finally, the objects property represents the collection of GeoObject (the table in the database). In Django this is called a <b class="calibre3">manager</b>; don’t worry, we will see more about this later. </p>
<p class="calibre1">2.  Now we need the tags for our GeoObject; the tags will contain every attribute. Add another class after the GeoObject class. </p>
<p class="calibre1">class Tag(models.Model):</p>
<p class="calibre1">key = models.CharField(max_length=250)</p>
<p class="calibre1">value = models.CharField(max_length=250)</p>
<p class="calibre1">geo_object = models.ForeignKey(GeoObject, related_name='tags') Again, this class represents a single object, a single tag with a key and a value that is connected with a GeoObject by a foreign key. The result is that a Tag class has a GeoObject and a GeoObject has many tags. </p>
<p class="calibre1"><b class="calibre3">Customizing a manager</b></p>
<p class="calibre1">As said before, a manager can be considered as something that represents a table in a database. It contains methods to retrieve records, add, delete, and many other operations. </p>
<p class="calibre1"><a id="p361"/>Django comes with the GeoManager class that is used for tables that contain spatial objects. If we want to add more functionalities to our GeoData manager, we just need to inherit from GeoManager and then add a class property with an instance of it in the GeoObject class. Actually, we will just replace the instance in the objects property. </p>
<p class="calibre1">Let’s adapt our BaseGeoCollection class to be a manager for the GeoObject class: 1.  Navigate to your Chapter8/models.py file (the one that we wrote in previous chapters) and rename it to Chapter8/old_models.py. With this, we avoid confusion about which model we are talking about. </p>
<p class="calibre1">2.  Create a file named managers.py inside the geodata folder. Add this code to the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from django.contrib.gis.db.models import GeoManager</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">class GeoCollection(GeoManager):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">Pass</p>
<p class="calibre1">This is the first step in migrating our BaseGeoCollection class. Note that we named it GeoCollection because it won’t be a base class anymore. We will simplify our code so this class will manage all types of geo objects. To do that, we will add the import_data method from the BaseGeoCollection class and combine it with the _parse_data method from the PointCollection class. Before we continue, let’s take a look at these methods as they are (you don’t need to type this code):</p>
<p class="calibre1">#... </p>
<p class="calibre1">def import_data(self, file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features, metadata = open_vector_file(file_path)</p>
<p class="calibre1">self._parse_data(features)</p>
<p class="calibre1">self.epsg = metadata['epsg']</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">#... </p>
<p class="calibre1">def _parse_data(self, features):</p>
<p class="calibre1">"""Transforms the data into Geocache objects. </p>
<p class="calibre1">:param features: A list of features. </p>
<p class="calibre1">""" </p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">coords = feature['geometry']['coordinates']</p>
<p class="calibre1">point = Point(float(coords[1]), float(coords[0]))</p>
<p class="calibre1">attributes = feature['properties']</p>
<p class="calibre1">cache_point = Geocache(point, attributes=attributes)</p>
<p class="calibre1">self.data.append(cache_point)</p>
<p class="calibre1"><a id="p362"/>Note that import_data opens the vector file and then sends the features to _parse_data, which iterates over the data, creating points and putting the feature properties into a dictionary. If we manage to import any kind of geometry and pass the feature properties to the tag model, we end with a piece of code that will serve any kind of geospatial object. </p>
<p class="calibre1">3.  Edit the code in geodata/managers.py again. Whether you want to copy and edit the mentioned methods or type the new import_data method from scratch is up to you. </p>
<p class="calibre1">The resulting code should be the following:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from django.contrib.gis.db.models import GeoManager</p>
<p class="calibre1">from django.db import IntegrityError, DataError</p>
<p class="calibre1">from utils.geo_functions import open_vector_file</p>
<p class="calibre1">from shapely.geometry import shape</p>
<p class="calibre1">class GeoCollection(GeoManager):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def import_data(self, file_path, atype):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features = open_vector_file(file_path)</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = shape(feature['geometry'])</p>
<p class="calibre1">geo_object = self.model(geom=geom.wkt, atype=atype)</p>
<p class="calibre1">geo_object.save()</p>
<p class="calibre1">for key, value in feature['properties'].iteritems():</p>
<p class="calibre1">try:</p>
<p class="calibre1">geo_object.tags.create(key=key, value=value)</p>
<p class="calibre1">except (IntegrityError, DataError):</p>
<p class="calibre1">pass</p>
<p class="calibre1">print("File imported: {}".format(file_path))</p>
<p class="calibre1">We used Shapley’s shape function to directly convert feature['geometry'], which is a GeoJSON geometry-like dictionary, into a shapely geometry of the correct type. </p>
<p class="calibre1">Then we used that geometry to get a WKT representation of it. </p>
<p class="calibre1">The atype argument was included on the method, so we can use it to define the type of the GeoObject. Remember that atype is not a type of geometry; it represents the high-level type of the object (geocaching, boundary, road, river, waypoint, and so on). </p>
<p class="calibre1">In the statement geo_object = self.model(geom=geom.wkt, atype=atype), we see a great feature of Django managers: the same manager can be used by many models, and self.model contains a reference to the class that this manager was called from. </p>
<p class="calibre1">If we had decided on another design pattern and used one class for each object type, we would still be able to use the same manager for all of them. </p>
<p class="calibre1"><a id="p363"/>In the sequence, the model is saved and then the properties dictionary is iterated and for every item a tag is created. We are catching exceptions here because we have two special conditions that may happen: if the value of a property is None it will raise an IntegrityError; if the length of the value is larger than 250, it will raise a DataError. If you are interested in long fields, such as the logs from the geocaching data, you can increase the field max_length or try a different field type. </p>
<p class="calibre1">4.  We are not using the metadata here, and reading it can cause an incompatibility error between libraries for Windows users. So we will remove it from the open_vector_file function. Edit your utils/geo_functions.py file to change this function. As a plus, let’s print the number of features read: def open_vector_file(file_path):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR or a GPX file. </p>
<p class="calibre1">Returns a list of features and informations about the file. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">datasource = ogr.Open(file_path)</p>
<p class="calibre1"># Check if the file was opened. </p>
<p class="calibre1">if not datasource:</p>
<p class="calibre1">if not os.path.isfile(file_path):</p>
<p class="calibre1">message = "Wrong path." </p>
<p class="calibre1">else:</p>
<p class="calibre1">message = "File format is invalid." </p>
<p class="calibre1">raise IOError('Error opening the file {}\n{}'.format(</p>
<p class="calibre1">file_path, message))</p>
<p class="calibre1">file_name, file_extension = os.path.splitext(file_path)</p>
<p class="calibre1"># Check if it's a GPX and read it if so. </p>
<p class="calibre1">if file_extension in ['.gpx', '.GPX']:</p>
<p class="calibre1">features = read_gpx_file(file_path)</p>
<p class="calibre1"># If not, use OGR to get the features. </p>
<p class="calibre1">else:</p>
<p class="calibre1">features = read_ogr_features(datasource.GetLayerByIndex(0)) print("{} features.".format(len(features)))</p>
<p class="calibre1">return features</p>
<p class="calibre1">5.  Finally, edit geodata/models.py to import and use the new manager:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from django.contrib.gis.db import models</p>
<p class="calibre1">from managers import GeoCollection</p>
<p class="calibre1">class GeoObject(models.Model):</p>
<p class="calibre1">geom = models.GeometryField()</p>
<p class="calibre1">atype = models.CharField(max_length=20)</p>
<p class="calibre1">objects = GeoCollection()</p>
<p class="calibre1">class Tag(models.Model):</p>
<p class="calibre1">key = models.CharField(max_length=250)</p>
<p class="calibre1">value = models.CharField(max_length=250)</p>
<p class="calibre1"><a id="p364"/>    geo_object = models.ForeignKey(GeoObject, related_name='tags') We are almost ready to begin testing. At this point, your Chapter 8 structure should be like this:</p>
<p class="calibre1">+---Chapter8</p>
<p class="calibre1">|   geocaching_app.py</p>
<p class="calibre1">|   geodata_app.py</p>
<p class="calibre1">|   map_maker_app.py</p>
<p class="calibre1">|   models_old.py</p>
<p class="calibre1">|   raster_data.py</p>
<p class="calibre1">|   settings.py</p>
<p class="calibre1">|   settings.pyc</p>
<p class="calibre1">|   __init__.py</p>
<p class="calibre1">|   </p>
<p class="calibre1">+---experiments</p>
<p class="calibre1">|       </p>
<p class="calibre1">+---geodata</p>
<p class="calibre1">|   |   managers.py</p>
<p class="calibre1">|   |   models.py</p>
<p class="calibre1">|   |   __init__.py</p>
<p class="calibre1">|           </p>
<p class="calibre1">+---map_maker</p>
<p class="calibre1">|       </p>
<p class="calibre1">+---output</p>
<p class="calibre1">|       </p>
<p class="calibre1">\---utils</p>
<p class="calibre1">check_plugins.py</p>
<p class="calibre1">data_transfer.py</p>
<p class="calibre1">geo_functions.py</p>
<p class="calibre1"><a id="p365"/><b class="calibre3">Generating the tables and importing data</b> Now it’s time to make Django generate the database tables for us. Since our models are defined, we just need to call a pair of commands and Django will perform its magic. </p>
<p class="calibre1">1.  Go back to the geodata_app.py file and add some content to it:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import os</p>
<p class="calibre1">import django</p>
<p class="calibre1">os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()</p>
<p class="calibre1">from django.core.management import call_command</p>
<p class="calibre1">from geodata.models import *</p>
<p class="calibre1">def prepare_database():</p>
<p class="calibre1">"""Call this to setup the database or any time you change your models. </p>
<p class="calibre1">""" </p>
<p class="calibre1">call_command('makemigrations', 'geodata')</p>
<p class="calibre1">call_command('migrate', 'geodata')</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">prepare_database()</p>
<p class="calibre1">After we import os and django we need to specify which settings file it should look for. After that, django.setup() initializes Django. </p>
<p class="calibre1">The prepare_database function calls two Django management commands responsible for database creation. We will need to call it every time we change our models. Internally, Django keeps a record of the changes made and automatically generates SQL queries that perform the modifications on the database. </p>
<p class="calibre1">2.  Run your code now. If everything goes fine, you should see the database migration results in the output:</p>
<p class="calibre1">Migrations for 'geodata':</p>
<p class="calibre1">0001_initial.py:</p>
<p class="calibre1">- Create model GeoObject</p>
<p class="calibre1">- Create model Tag</p>
<p class="calibre1">Operations to perform:</p>
<p class="calibre1">Apply all migrations: geodata</p>
<p class="calibre1">Running migrations:</p>
<p class="calibre1">Rendering model states… DONE</p>
<p class="calibre1">Applying geodata.0001_initial… OK</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">3.  Now, edit geodata_app.py again to add a convenience function to import some data. </p>
<p class="calibre1"><a id="p366"/>We will begin with the geocaching data as a test:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import os</p>
<p class="calibre1">import django</p>
<p class="calibre1">os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings") django.setup()</p>
<p class="calibre1">from django.core.management import call_command</p>
<p class="calibre1">from geodata.models import *</p>
<p class="calibre1">def prepare_database():</p>
<p class="calibre1">"""Call this to setup the database or any time you change your models. </p>
<p class="calibre1">""" </p>
<p class="calibre1">call_command('makemigrations', 'geodata')</p>
<p class="calibre1">call_command('migrate', 'geodata')</p>
<p class="calibre1">def import_initial_data(input_file, atype):</p>
<p class="calibre1">"""Import new data into the database.""" </p>
<p class="calibre1">print("Importing {}...".format(atype))</p>
<p class="calibre1">GeoObject.objects.import_data(input_file, atype)</p>
<p class="calibre1">print("Done!")</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1"># prepare_database()</p>
<p class="calibre1">import_initial_data("../data/geocaching.gpx", 'geocaching') This new function is only a convenience function to reduce typing since we will import a lot of data very soon. We are commenting the prepare_database() statement because we will use it later. </p>
<p class="calibre1">4.  Run your code (make sure you run it only once to avoid duplicated entries). In your output you should see this:</p>
<p class="calibre1">Importing geocaching…</p>
<p class="calibre1">112 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p367"/><b class="calibre3">Filtering the data</b></p>
<p class="calibre1">Now that we have some data in the database, it’s time to test it and see if we can filter some points as we did before. </p>
<p class="calibre1">1.  Edit your if __name__ == '__main__': block (remember to comment the previous commands):</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1"># prepare_database()</p>
<p class="calibre1"># import_initial_data("../data/geocaching.gpx", 'geocaching') points = GeoObject.objects.filter(atype='geocaching', </p>
<p class="calibre1">tags__key='status', </p>
<p class="calibre1">tags__value='Available')</p>
<p class="calibre1">print(len(points))</p>
<p class="calibre1">for tag in points[0].tags.all():</p>
<p class="calibre1">print(tag.key, tag.value)</p>
<p class="calibre1">Here we are using the filter method inherited by our manager to filter the records of geocaching type. Plus we are accessing the related tags to filter only the available geocaches. This is done by using a double underscore after the property name. In the end, we print all the tags for the first of the points returned. </p>
<p class="calibre1">2.  Run your code and you should see a list of tags like this: 224</p>
<p class="calibre1">(u'type', u'Other')</p>
<p class="calibre1">(u'hints', u'under sign')</p>
<p class="calibre1">(u'time', u'2013-09-29T00:00:00Z')</p>
<p class="calibre1">(u'state', u'New York')</p>
<p class="calibre1">(u'country', u'United States')</p>
<p class="calibre1">(u'url', u'http://www.opencaching.us/viewcache.php?cacheid=1728') (u'name', u'LaSalle Park No 1')</p>
<p class="calibre1">(u'container', u'Virtual')</p>
<p class="calibre1">(u'src', u'www.opencaching.us')</p>
</body></html>