<html><head></head><body>
<p class="calibre1">(u'@xmlns', u'http://geocaching.com.au/geocache/1')</p>
<p class="calibre1">(u'desc', u'LaSalle Park No 1 by Mr.Yuck, Unknown Cache (1/1)') (u'urlname', u'LaSalle Park No 1')</p>
<p class="calibre1">(u'owner', u'Mr.Yuck')</p>
<p class="calibre1">(u'difficulty', u'1')</p>
<p class="calibre1">(u'sym', u'Geocache')</p>
<p class="calibre1">(u'terrain', u'1')</p>
<p class="calibre1">(u'status', u'Available')</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p368"/>
<a id="p369"/><b class="calibre3">Importing massive amount of data</b></p>
<p class="calibre1">Now that our environment is ready, we can begin working with bigger datasets. Let’s start by profiling the import process and then optimize it. We will start with our small geocaching dataset and after the code is optimized we will move to bigger sets. </p>
<p class="calibre1">1.  In your geodata_app.py file, edit the if __name__ == '__main__': block to call the profiler. </p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">profile = cProfile.Profile()</p>
<p class="calibre1">profile.enable()</p>
<p class="calibre1">import_initial_data("../data/geocaching.gpx", 'geocaching') profile.disable()</p>
<p class="calibre1">profile.print_stats(sort='cumulative')</p>
<p class="calibre1">2.  Run the code and see the results. Don’t worry about duplicated entries in the database now, we will clean it later. (I removed some information from the following output for space reasons.)</p>
<p class="calibre1">Importing geocaching…</p>
<p class="calibre1">112 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">1649407 function calls (1635888 primitive calls) in 5.858 seconds cumtime  percall filename:lineno(function)</p>
<p class="calibre1">5.863    5.863 geodata_app.py:24(import_initial_data)</p>
<p class="calibre1">5.862    5.862 managers.py:11(import_data)</p>
<p class="calibre1">4.899    0.002 related.py:749(create)</p>
<p class="calibre1">4.888    0.002 manager.py:126(manager_method)</p>
<p class="calibre1">3.621    0.001 base.py:654(save)</p>
<p class="calibre1">3.582    0.001 base.py:737(save_base)</p>
<p class="calibre1">3.491    0.001 query.py:341(create)</p>
<p class="calibre1">1.924    0.001 base.py:799(_save_table)</p>
<p class="calibre1">ncalls  tottime  percall  cumtime  percall filename:lineno(function) 1    0.001    0.001    5.863    5.863 (import_initial_data) 1    0.029    0.029    5.862    5.862 (import_data)</p>
<p class="calibre1">2497    0.018    0.000    4.899    0.002 related.py:749(create) Take a look at ncalls and cumtime for each of the functions. The create function is called a lot of times and accumulates almost five seconds on my computer. This is the function (method) called when we add a tag to a GeoObject. The time spent on this function is relevant when we import geocaching data because every point has a lot of attributes. Maybe we can make this process more efficient. </p>
<p class="calibre1"><a id="p370"/><b class="calibre3">Optimizing database inserts</b></p>
<p class="calibre1">As we saw in the profiler, the method we are using to insert the tags into the database creates a bottleneck when we import geocaching data with our current code. If we can change how it’s done, we can make the code run faster. </p>
<p class="calibre1">1.  Go to your manager and edit the import_data method of the GeoCollection manager:</p>
<p class="calibre1">class GeoCollection(GeoManager):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def import_data(self, file_path, atype):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">from models import Tag</p>
<p class="calibre1">features = open_vector_file(file_path)</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = shape(feature['geometry'])</p>
<p class="calibre1">geo_object = self.model(geom=geom.wkt, atype=atype)</p>
<p class="calibre1">geo_object.save()</p>
<p class="calibre1">geoo_id = geo_object.id</p>
<p class="calibre1">for key, value in feature['properties'].iteritems():</p>
<p class="calibre1">tags.append(Tag(key=key, value=value, </p>
<p class="calibre1">geo_object_id=geoo_id))</p>
<p class="calibre1">Tag.objects.bulk_create(tags)</p>
<p class="calibre1">Instead of creating the tags one by one, now we add them to a list without hitting the database; only in the end do we call bulk_create, which inserts all entries in a single request. Note that the import statements for the Tag model are inside the function. </p>
<p class="calibre1">This will avoid an error with circular imports, because models also import the managers. </p>
<p class="calibre1">2.  Run your code and see what happens:</p>
<p class="calibre1">django.db.utils.DataError: value too long for type character varying(250)</p>
<p class="calibre1">Process finished with exit code 1</p>
<p class="calibre1">Since bulk_insert sends everything together to the database, we can’t catch exceptions for individual tags. </p>
<p class="calibre1">The solution is to validate the tag before we insert it. At this point we are making a trade-off between generalization and performance because the validation may fail depending on the type of data, whereas the error catching could be triggered by a wide range of reasons. </p>
<p class="calibre1">3.  Edit the code again:</p>
<p class="calibre1"><a id="p371"/>class GeoCollection(GeoManager):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def import_data(self, file_path, atype):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">from models import Tag</p>
<p class="calibre1">features = open_vector_file(file_path)</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geom = shape(feature['geometry'])</p>
<p class="calibre1">geo_object = self.model(geom=geom.wkt, atype=atype)</p>
<p class="calibre1">geo_object.save()</p>
<p class="calibre1">geoo_id = geo_object.id</p>
<p class="calibre1">for key, value in feature['properties'].iteritems():</p>
<p class="calibre1">if value and (isinstance(value, unicode) </p>
<p class="calibre1">or isinstance(value, str)):</p>
<p class="calibre1">if len(value) &lt;= 250:</p>
<p class="calibre1">tags.append(Tag(key=key, value=value, </p>
<p class="calibre1">geo_object_id=geoo_id))</p>
<p class="calibre1">Tag.objects.bulk_create(tags)</p>
<p class="calibre1">4.  Now run geodata_app.py again and look at the profiler results: 506679 function calls (506308 primitive calls) in 1.144 seconds Ordered by: cumulative time</p>
<p class="calibre1">ncalls  cumtime  percall filename:lineno(function)</p>
<p class="calibre1">1    1.144    1.144 geodata_app.py:24(import_initial_data)</p>
<p class="calibre1">1    1.142    1.142 managers.py:12(import_data)</p>
<p class="calibre1">1    0.556    0.556 geo_functions.py:91(open_vector_file)</p>
<p class="calibre1">1    0.549    0.549 geo_functions.py:9(read_gpx_file)</p>
<p class="calibre1"><b class="calibre3">     1    0.541    0.541 xmltodict.py:155(parse)</b></p>
<p class="calibre1">1    0.541    0.541 {built-in method Parse}</p>
<p class="calibre1">6186    0.387    0.000 pyexpat.c:566(StartElement)</p>
<p class="calibre1">6186    0.380    0.000 xmltodict.py:89(startElement)</p>
<p class="calibre1">112    0.317    0.003 base.py:654(save)</p>
<p class="calibre1">112    0.316    0.003 base.py:737(save_base)</p>
<p class="calibre1">14/113    0.290    0.003 manager.py:126(manager_method)</p>
<p class="calibre1">12487    0.278    0.000 collections.py:38(__init__)</p>
<p class="calibre1">113    0.235    0.002 query.py:910(_insert)</p>
<p class="calibre1">113    0.228    0.002 compiler.py:969(execute_sql)</p>
<p class="calibre1">6186    0.178    0.000 xmltodict.py:84(_attrs_to_dict)</p>
<p class="calibre1"><b class="calibre3">     1    0.170    0.170 query.py:356(bulk_create)</b></p>
<p class="calibre1">The import now runs five times faster. Note how the profile changed. The database part of the process felt down on the list and now the most time-consuming part is the conversion from XML (the GPX file) to a dictionary. </p>
<p class="calibre1">Looking at the output, we also see that we have another. </p>
<p class="calibre1">At this point, we have much more efficient code and we won’t change how the XML</p>
<p class="calibre1">conversion is done. Instead, we will move on to testing and optimizing the process for</p>
<p class="calibre1"><a id="p372"/>other types of data. </p>
<p class="calibre1"><a id="p373"/><b class="calibre3">Optimizing data parsing</b></p>
<p class="calibre1">Remember that we made a branch in our code to import GPX files, because OGR/GDAL</p>
<p class="calibre1">was unable to import the nested data inside those files. So we should expect that when importing shapefiles or GML files, we will have a different profile for code execution time. Let’s try it:</p>
<p class="calibre1">1.  Now we will test the code with the world borders dataset. Change the if __name__</p>
<p class="calibre1">== '__main__': block of geodata_app.py:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">profile = cProfile.Profile()</p>
<p class="calibre1">profile.enable()</p>
<p class="calibre1">import_initial_data("../data/world_borders_simple.shp", </p>
<p class="calibre1">'boundary')</p>
<p class="calibre1">profile.disable()</p>
<p class="calibre1">profile.print_stats(sort='cumulative')</p>
<p class="calibre1">2.  Run the code:</p>
<p class="calibre1">ValueError: A LinearRing must have at least 3 coordinate tuples Process finished with exit code 1</p>
<p class="calibre1">Well, it doesn’t work. What is happening here is that Shapely is complaining about the geometry that is being passed to it. This is because this branch of the code is passing a WKT geometry instead of coordinates. </p>
<p class="calibre1">Django can receive the geometry as a WKT and we are using Shapely for the conversion. </p>
<p class="calibre1">This may be a time-consuming step and we are going to eliminate it. At this point, we are just using common sense to optimize the code: the fewer the steps, the faster the code. </p>
<p class="calibre1">1.  Edit the GeoCollection manager:</p>
<p class="calibre1">class GeoCollection(GeoManager):</p>
<p class="calibre1">"""This class represents a collection of spatial data.""" </p>
<p class="calibre1">def import_data(self, file_path, atype):</p>
<p class="calibre1">"""Opens an vector file compatible with OGR and parses the data. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">from models import Tag</p>
<p class="calibre1">features = open_vector_file(file_path)</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">for feature in features:</p>
<p class="calibre1">geo_object = self.model(geom=feature['geom'], </p>
<p class="calibre1">atype=atype)</p>
<p class="calibre1">geo_object.save()</p>
<p class="calibre1">geoo_id = geo_object.id</p>
<p class="calibre1">for key, value in feature['properties'].iteritems():</p>
<p class="calibre1">if value and (isinstance(value, unicode) </p>
<p class="calibre1"><a id="p374"/>                              or isinstance(value, str)): if len(value) &lt;= 250:</p>
<p class="calibre1">tags.append(Tag(key=key, value=value, </p>
<p class="calibre1">geo_object_id=geoo_id))</p>
<p class="calibre1">Tag.objects.bulk_create(tags)</p>
<p class="calibre1">We eliminated the Shapely use (you can remove it from the imports too) and changed how the geometry is retrieved from the dictionary. </p>
<p class="calibre1">2.  Now go to geo_functions.py and edit the read_ogr_features function: def read_ogr_features(layer):</p>
<p class="calibre1">"""Convert OGR features from a layer into dictionaries. </p>
<p class="calibre1">:param layer: OGR layer. </p>
<p class="calibre1">""" </p>
<p class="calibre1">features = []</p>
<p class="calibre1">layer_defn = layer.GetLayerDefn()</p>
<p class="calibre1">layer.ResetReading()</p>
<p class="calibre1">type = ogr.GeometryTypeToName(layer.GetGeomType())</p>
<p class="calibre1">for item in layer:</p>
<p class="calibre1">attributes = {}</p>
<p class="calibre1">for index in range(layer_defn.GetFieldCount()):</p>
<p class="calibre1">field_defn = layer_defn.GetFieldDefn(index)</p>
<p class="calibre1">key = field_defn.GetName()</p>
<p class="calibre1">value = item.GetFieldAsString(index)</p>
<p class="calibre1">attributes[key] = value</p>
<p class="calibre1">feature = {</p>
<p class="calibre1">"geom": item.GetGeometryRef().ExportToWkt(), </p>
<p class="calibre1">"properties": attributes}</p>
<p class="calibre1">features.append(feature)</p>
<p class="calibre1">return features</p>
<p class="calibre1">As a trade-off between generalization and performance, we changed the feature dictionary from the universal GeoJSON format to contain only two keys: geom with a WKT geometry and properties. </p>
<p class="calibre1">3.  Now edit the read_gpx_file function so it’s compliant with the new format: def read_gpx_file(file_path):</p>
<p class="calibre1">"""Reads a GPX file containing geocaching points. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">with open(file_path) as gpx_file:</p>
<p class="calibre1">gpx_dict = xmltodict.parse(gpx_file.read())</p>
<p class="calibre1">output = []</p>
<p class="calibre1">for wpt in gpx_dict['gpx']['wpt']:</p>
<p class="calibre1">geometry = "POINT(" + wpt.pop('@lat') + " " + \ wpt.pop('@lon') + ")" </p>
<p class="calibre1"># If geocache is not on the dict, skip this wpt. </p>
<p class="calibre1">try:</p>
<p class="calibre1">geocache = wpt.pop('geocache')</p>
<p class="calibre1">except KeyError:</p>
<p class="calibre1">continue</p>
<p class="calibre1">attributes = {'status': geocache.pop('@status')}</p>
<p class="calibre1"><a id="p375"/>        # Merge the dictionaries. </p>
<p class="calibre1">attributes.update(wpt)</p>
<p class="calibre1">attributes.update(geocache)</p>
<p class="calibre1"># Construct a GeoJSON feature and append to the list. </p>
<p class="calibre1">feature = {</p>
<p class="calibre1">"geom": geometry, </p>
<p class="calibre1">"properties": attributes}</p>
<p class="calibre1">output.append(feature)</p>
<p class="calibre1">return output</p>
<p class="calibre1">4.  Run your code again (you can also test importing points again if you wish, you will get a few milliseconds of improvement). Look at the result: Importing boundary…</p>
<p class="calibre1">245 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">90746 function calls (90228 primitive calls) in 5.164 seconds</p>
<p class="calibre1"><a id="p376"/><img src="img/index-376_1.jpg" alt="Image 63" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Importing OpenStreetMap points of interest</b></p>
<p class="calibre1"><b class="calibre3">OpenStreetMap</b> (<b class="calibre3">OSM</b>) is a collaborative mapping project where everyone can make an account and collaborate in the map making. It’s something like Wikipedia, but instead of articles the community make maps. </p>
<p class="calibre1">The data is all available for download, and some regions have incredibly detailed maps. </p>
<p class="calibre1">What we want here is to get <b class="calibre3">points of interest</b> (<b class="calibre3">POI</b>). These are points that represent the location of restaurants, supermarkets, banks, and so on. </p>
<p class="calibre1">Take a look at the following screenshot of Boulevard Saint-Laurent in Montreal. Each one of those small icons is a POI:</p>
<p class="calibre1">OSM data can be easily obtained using its API, which is called <b class="calibre3">Overpass API</b>. It allows the user to make advanced queries and filter data of interest. </p>
<p class="calibre1">The obtained data is in XML format adapted for OSM needs. We are going to use overpy, a Python package that translates this data into Python objects. </p>
<p class="calibre1">At this point, I have to admit that through my career I have been deeply inspired by OSM</p>
<p class="calibre1">and its data format. It’s simple and yet flexible, to the point where everything in OSM is represented by the same schema. </p>
<p class="calibre1">OSM consists of nodes, a lot of nodes. Actually by this date it had 3,037,479,553 nodes. </p>
<p class="calibre1"><a id="p377"/><img src="img/index-377_1.jpg" alt="Image 64" class="calibre2"/></p>
<p class="calibre1">That’s right, more than three billion nodes. Nodes can be points or can be related to other nodes as part of something represented by a line or polygon. </p>
<p class="calibre1">Every node can have an arbitrary number of tags made of key/value pairs, just like our data. Take a look at the information obtained from one of the POI: So, storing OpenStreetMap POIs in our database will be pretty straightforward. First, let’s create a utility function to download points for a given region of interest. </p>
<p class="calibre1">1.  Go to the utils folder and create a new Python file named osm_data.py. </p>
<p class="calibre1">2.  Add the following code to this file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import overpy</p>
<p class="calibre1">def get_osm_poi(bbox):</p>
<p class="calibre1">"""Downloads points of interest from OpenStreetMap. </p>
<p class="calibre1">:param bbox: The bounding box of the region to get the points. </p>
<p class="calibre1">""" </p>
<p class="calibre1">api = overpy.Overpass()</p>
<p class="calibre1">result = api.query(""" </p>
<p class="calibre1">&lt;osm-script&gt; </p>
<p class="calibre1">&lt;query type="node"&gt; </p>
<p class="calibre1">&lt;bbox-query s="{ymin}" n="{ymax}" w="{xmin}" e="{xmax}"/&gt; </p>
<p class="calibre1"><a id="p378"/>            &lt;has-kv k="amenity"/&gt; </p>
<p class="calibre1">&lt;/query&gt; </p>
<p class="calibre1">&lt;print/&gt; </p>
<p class="calibre1">&lt;/osm-script&gt; </p>
<p class="calibre1">""".format(**bbox))</p>
<p class="calibre1">print("Found {} POIs".format(len(result.nodes)))</p>
<p class="calibre1">return result</p>
<p class="calibre1">if __name__ == "__main__":</p>
<p class="calibre1">bbox = {"xmin":-71.606, "ymin":46.714, </p>
<p class="calibre1">"xmax":-71.140, "ymax":48.982}</p>
<p class="calibre1">result = get_osm_poi(bbox)</p>
<p class="calibre1">print(result.nodes[0].tags)</p>
<p class="calibre1">This is a simple wrapper for overpy that queries all points in a given region and has the amenity key. In the if __name__ == '__main__': block, we make a simple test, get some points, and print the tags of one of them. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">You can get more information on the Overpass API at this site:</p>
<p class="calibre1"><a href="http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide">http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide</a>. </p>
<p class="calibre1">3.  Run the code on this file. Remember to press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> to choose a different file and select osm_data in the list. You should get an output like this: Found 3523 POIs</p>
<p class="calibre1">{'operator': 'Desjardins', 'amenity': 'bank', 'atm': 'yes', 'name': </p>
<p class="calibre1">'Caisse Populaire Desjardins'}</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">If you don't have overpy installed, just click on it in your code, press Alt + F10 and select "Install Package" </p>
<p class="calibre1">Now, let’s import this data into our database. Open your manage.py file. We will create a new method to our GeoCollection manager, very similar to import_data, but specific to OSM data. </p>
<p class="calibre1">4.  Edit your manage.py file and add this new method to the GeoCollection class:</p>
<p class="calibre1">#... </p>
<p class="calibre1">def import_osm_data(self, result):</p>
<p class="calibre1">"""Import OpenStreetMap points of interest. </p>
<p class="calibre1">:param str file_path: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">from models import Tag</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">for node in result.nodes:</p>
<p class="calibre1">geometry = "POINT(" + str(node.lat) + " " + \ str(node.lon) + ")" </p>
<p class="calibre1">geo_object = self.model(geom=geometry, atype="poi") geo_object.save()</p>
<p class="calibre1">geoo_id = geo_object.id</p>
<p class="calibre1">for key, value in node.tags.iteritems():</p>
<p class="calibre1"><a id="p379"/>                tags.append(Tag(key=key, value=value, geo_object_id=geoo_id))</p>
<p class="calibre1">Tag.objects.bulk_create(tags)</p>
<p class="calibre1">We could have reused the code that is common for both import_data and import_osm_data, but in this chapter we are emphasizing speed and, as was stated earlier, sometimes it’s easier to achieve better execution times with specific functions. </p>
<p class="calibre1">In this case, we were able to remove the verifications when creating the tags, making the loop run faster. </p>
<p class="calibre1">Now let’s test this new method:</p>
<p class="calibre1">5.  Open the geodata_app.py file and add this import at the beginning of the file: from utils.osm_data import get_osm_poi</p>
<p class="calibre1">6.  Now edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">bbox = {"xmin":-71.206, "ymin":47.714, </p>
<p class="calibre1">"xmax":-71.140, "ymax":48.982}</p>
<p class="calibre1">result = get_osm_poi(bbox)</p>
<p class="calibre1">GeoObject.objects.import_osm_data(result)</p>
<p class="calibre1">points = GeoObject.objects.filter(atype='poi')</p>
<p class="calibre1">print(len(points))</p>
<p class="calibre1">7.  Finally, run the code and see if you get an output resembling the following (the number of points may be different for you):</p>
<p class="calibre1">Found 14 POIs</p>
<p class="calibre1">14</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p380"/><b class="calibre3">Removing the test data</b></p>
<p class="calibre1">Before we continue with real imports, let’s clean the database of all the data we put into it for testing. Let’s make a simple function for this job in our app: 1.  In geodata_app.py, add this function:</p>
<p class="calibre1">def clean_database():</p>
<p class="calibre1">"""Remove all records from the database.""" </p>
<p class="calibre1">from django.db import connection</p>
<p class="calibre1">cursor = connection.cursor()</p>
<p class="calibre1">cursor.execute('DELETE FROM geodata_tag;')</p>
<p class="calibre1">cursor.execute('DELETE FROM geodata_geoobject;')</p>
<p class="calibre1">Here we are calling SQL commands directly on the database in order to avoid all Django overheads and get a better performance. </p>
<p class="calibre1">2.  Now call it from the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">clean_database()</p>
<p class="calibre1">3.  Run the code; it may take a while to finish. </p>
<p class="calibre1">4.  Keep it as a resource in case you want to make other tests or if you need to start over. </p>
<p class="calibre1"><a id="p381"/><b class="calibre3">Populating the database with real data</b></p>
<p class="calibre1">Now it’s time to put real data into our database. We will import all the data that we used so far, plus additional data:</p>
<p class="calibre1">Geocaching points (extended version)</p>
<p class="calibre1">World borders</p>
<p class="calibre1">Canadian districts borders</p>
<p class="calibre1">Points of interest in Canada</p>
<p class="calibre1">1.  Go to your geodata_app.py file and edit the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">import_initial_data("../data/canada_div.gml", 'canada') import_initial_data("../data/world_borders_simple.shp", 'world') import_initial_data("../data/geocaching_big.gpx", 'geocaching') This time we are setting more specific types for our data to make our queries easier. </p>
<p class="calibre1">1.  Now, run the code to begin importing. In the end you should have this output: Importing canada…</p>
<p class="calibre1">293 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">Importing world…</p>
<p class="calibre1">245 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">Importing geocaching…</p>
<p class="calibre1">1638 features. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Now it’s time to fetch points of interest from OpenStreetMap and add them to our database. </p>
<p class="calibre1">2.  Add this function to your geodata_app.py:</p>
<p class="calibre1">def import_from_osm(district):</p>
<p class="calibre1"># tags = Tag.objects.filter(value="Montreal")</p>
<p class="calibre1">borders = GeoObject.objects.get(atype='canada', </p>
<p class="calibre1">tags__key='CDNAME', </p>
<p class="calibre1">tags__value=district)</p>
<p class="calibre1">extent = borders.geom.extent</p>
<p class="calibre1">print("Extent: {}".format(extent))</p>
<p class="calibre1">bbox = {"xmin":extent[0], "ymin":extent[1], </p>
<p class="calibre1">"xmax":extent[2], "ymax":extent[3]}</p>
<p class="calibre1">osm_poi = get_osm_poi(bbox)</p>
<p class="calibre1">GeoObject.objects.import_osm_data(osm_poi)</p>
<p class="calibre1">print("Done!")</p>
<p class="calibre1">This function takes a district name. Get it from our database and use its extent to query the OSM API. </p>
<p class="calibre1">3.  Change the if __name__ == '__main__': block:</p>
<p class="calibre1"><a id="p382"/>if __name__ == '__main__':</p>
<p class="calibre1">import_from_osm('Montréal')</p>
<p class="calibre1">4.  Now, run the code. It may take some time to download the data from OSM. When it’s done, your output should be something like the following (the number of features may be different):</p>
<p class="calibre1">Extent: (-73.9763757739999, 45.4021292300001, -73.476065978, 45.703747476)</p>
<p class="calibre1">Found 5430 POIs</p>
<p class="calibre1">Done! </p>
<p class="calibre1">--- Memory Error ----</p>
<p class="calibre1">At this point, you will probably have your first contact with another issue in code optimization: memory consumption. Unless you have a large amount of RAM, you’ll be faced with Python’s MemoryError. This means that your computer ran out of memory while parsing the huge amount of POIs acquired from OSM. </p>
<p class="calibre1">This happened because the whole XML from OSM was parsed into Python objects and later into Django objects, and they were all stored in the memory at the same time. </p>
<p class="calibre1">The solution here is to read one XML tag at a time. If it’s a node, put it into the database, get its tags, and release the memory. To do that, we will use a XML file available on the sample data, so we don’t need to download it again. </p>
<p class="calibre1">1.  Open the managers.py file and add this import at the beginning of the file: import xml.etree.cElementTree as ET</p>
<p class="calibre1">2.  Go to your GeoCollection manager and edit the import_osm_data method:</p>
<p class="calibre1">#... </p>
<p class="calibre1">#... </p>
<p class="calibre1">def import_osm_data(self, input_file):</p>
<p class="calibre1">"""Import OpenStreetMap points of interest. </p>
<p class="calibre1">:param str input_file: The full path to the file. </p>
<p class="calibre1">""" </p>
<p class="calibre1">from models import Tag</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">tags_counter = 0</p>
<p class="calibre1">nodes_counter = 0</p>
<p class="calibre1">xml_iter = ET.iterparse(input_file)</p>
<p class="calibre1">for event, elem in xml_iter:</p>
<p class="calibre1">if elem.tag == 'node':</p>
<p class="calibre1">lat, lon = elem.get('lat'), elem.get('lon')</p>
<p class="calibre1">geometry = "POINT(" + str(lat) + " " + str(lon) + ")" </p>
<p class="calibre1">geo_object = self.model(geom=geometry, atype="poi") geo_object.save()</p>
<p class="calibre1">geoo_id = geo_object.id</p>
<p class="calibre1">nodes_counter += 1</p>
<p class="calibre1">if nodes_counter % 10000 == 0:</p>
<p class="calibre1">print("{} Nodes…".format(nodes_counter))</p>
<p class="calibre1"><a id="p383"/>                    print("Creating tags…") Tag.objects.bulk_create(tags)</p>
<p class="calibre1">tags = []</p>
<p class="calibre1">for child_tag in elem:</p>
<p class="calibre1">key = child_tag.get('k')</p>
<p class="calibre1">value = child_tag.get('v')</p>
<p class="calibre1">if len(value) &lt;= 250:</p>
<p class="calibre1">tags.append(Tag(key=key, </p>
<p class="calibre1">value=value, </p>
<p class="calibre1">geo_object_id=geoo_id))</p>
<p class="calibre1">tags_counter += 1</p>
<p class="calibre1">elem.clear()</p>
<p class="calibre1">print("Creating tags…")</p>
<p class="calibre1">Tag.objects.bulk_create(tags)</p>
<p class="calibre1">print("Imported {} nodes with {} tags.".format(</p>
<p class="calibre1">nodes_counter, tags_counter))</p>
<p class="calibre1">print("Done!")</p>
<p class="calibre1"><b class="calibre3">ElementTree</b> is a Python module designed for XML parsing; cElementTree has the same functionality but is implemented in C. The only restriction on using cElementTree is when C library loading is not available, which is not the case here. </p>
<p class="calibre1">Note that the solution to optimizing tag creation is to accumulate the tags in a list, bulk-create tags every 10,000 nodes, and then clear the list. </p>
<p class="calibre1">3.  Edit the if __name__ == '__main__': block of the geodata_app.py file to test the code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">GeoObject.objects.import_osm_data("../data/osm.xml") 4.  Now run it. While you wait, you can open the Windows Task Manager, or the system monitor on Ubuntu, and see how your computer resources are being consumed and/or watch the progress in the console output:</p>
<p class="calibre1">10000 Nodes…</p>
<p class="calibre1">Creating tags…</p>
<p class="calibre1">20000 Nodes…</p>
<p class="calibre1">Creating tags…</p>
<p class="calibre1">30000 Nodes…</p>
<p class="calibre1">Creating tags…</p>
<p class="calibre1">40000 Nodes…</p>
<p class="calibre1">Creating tags…</p>
<p class="calibre1">50000 Nodes…</p>
<p class="calibre1">... </p>
<p class="calibre1">Imported 269300 nodes with 1272599 tags. </p>
<p class="calibre1">Done! </p>
<p class="calibre1">If you were watching your computer resources, you should have seen that the memory consumption fluctuated around some value. As the memory didn’t keep increasing as more and more nodes were imported, we would be able to import virtually any given number of points on files of any size because the code is stable and has no memory leaks. </p>
<p class="calibre1"><a id="p384"/>On my computer, Python consumed something around 100 Mb of memory during the program execution. The processor cores stayed mostly at 5% of load (Python and PostgreSQL) and the hard drive was 100% occupied with database writing. </p>
<p class="calibre1">It would be possible to tweak the database for a better performance, but this is beyond the scope of this book. </p>
<p class="calibre1">Remember that, if you want to make more tests, you can always clean the database with the function that we created before. Just remember to import all the data again before we continue. </p>
<p class="calibre1"><a id="p385"/>
<a id="p386"/><b class="calibre3">Searching for data and crossing</b></p>
<p class="calibre1"><b class="calibre3">information</b></p>
<p class="calibre1">Now that we have our database populated with some data, it’s time to get some information from it; let’s explore what kind of information all those POIs hold. We know that we downloaded points that contain at least one of the amenity or store keys. </p>
<p class="calibre1">Amenities are described by OSM as any type of community facilities. As an exercise, let’s see a list of amenity types that we got from the points:</p>
<p class="calibre1">1.  Edit your geodata_app.py file’s if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">amenity_values = Tag.objects.filter(</p>
<p class="calibre1">key='amenity').distinct('value').values_list('value')</p>
<p class="calibre1">for item in amenity_values:</p>
<p class="calibre1">print(item[0])</p>
<p class="calibre1">Here we take the Tag model, access its manager (objects), then filter the tags whose key='amenity'. Then we separate only distinct values (exclude repeated values from the query). The final part—values_list('value')—tells Django that we don’t want it to create Tag models, we only want a list of values. </p>
<p class="calibre1">2.  Run the code, and take a look at the huge list of amenity types: atm, fuel</p>
<p class="calibre1">atm;telephone</p>
<p class="calibre1">audiologist</p>
<p class="calibre1">auditorium</p>
<p class="calibre1">Auto Body Repair Shop</p>
<p class="calibre1">auto_club</p>
<p class="calibre1">automobile_club</p>
<p class="calibre1">baby_hatch</p>
<p class="calibre1">bail_bonds</p>
<p class="calibre1">bakery</p>
<p class="calibre1">ball_washer</p>
<p class="calibre1">ballet</p>
<p class="calibre1">bandshell</p>
<p class="calibre1">bank</p>
<p class="calibre1">bank_construction</p>
<p class="calibre1">banquet_hall</p>
<p class="calibre1">bar</p>
<p class="calibre1">bar/food</p>
<p class="calibre1">barber</p>
<p class="calibre1">barbershop</p>
<p class="calibre1">bathroom</p>
<p class="calibre1">bbq</p>
<p class="calibre1">beauty</p>
<p class="calibre1">Beauty Services</p>
<p class="calibre1">bell_tower</p>
<p class="calibre1">bench</p>
<p class="calibre1">betting</p>
<p class="calibre1">bicycle_dirt jumping</p>
<p class="calibre1"><a id="p387"/><img src="img/index-387_1.jpg" alt="Image 65" class="calibre2"/></p>
<p class="calibre1">bicycle_parking</p>
<p class="calibre1">bicycle_parking; bicycle_rental</p>
<p class="calibre1">bicycle_parking;bank</p>
<p class="calibre1">bicycle_rental</p>
<p class="calibre1">... </p>
<p class="calibre1">You can also spot some misuse of this OSM tag as people mistakenly put street names, business names, and so on instead of the amenity type. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">For a list of common amenity types, you can check the OpenStreetMap wiki:</p>
<p class="calibre1"><a href="http://wiki.openstreetmap.org/wiki/Key:amenity">http://wiki.openstreetmap.org/wiki/Key:amenity. </a></p>
<p class="calibre1"><a id="p388"/><b class="calibre3">Filtering using boundaries</b></p>
<p class="calibre1">Now, let’s try getting only the amenities that are at Montréal. The procedure is similar to what we did before. We will use one of the known predicates to filter objects by a geometry relationship, but this time the searches are powered by the database and spatial indexes, making them incredibly fast. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Take a look at the  <i class="calibre4">Geometry relationships</i> section in<a href="index_split_001.html#p174"> Chapter 4, </a>  <i class="calibre4">Improving the App Search</i> <i class="calibre4">Capabilities</i> for a list of predicates. </p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1"># Get Montreal object. </p>
<p class="calibre1">montreal = GeoObject.objects.get(atype='canada', </p>
<p class="calibre1">tags__key='CDNAME', </p>
<p class="calibre1">tags__value='Montréal')</p>
<p class="calibre1"/>
<p class="calibre1"># Filter tags whose POI is within Montreal. </p>
<p class="calibre1">amenities = Tag.objects.filter(</p>
<p class="calibre1">key='amenity', geo_object__geom__within=montreal.geom)</p>
<p class="calibre1"/>
<p class="calibre1"># Filter only the distinct values. </p>
<p class="calibre1">amenities = amenities.distinct('value')</p>
<p class="calibre1"/>
<p class="calibre1"># Get the list of 'values' </p>
<p class="calibre1">amenity_values = amenities.values_list('value')</p>
<p class="calibre1">for item in amenity_values:</p>
<p class="calibre1">print(item[0])</p>
<p class="calibre1">Here I separated each part into a different statement to facilitate understanding. </p>
<p class="calibre1">It doesn’t make any difference if you put everything together or keep it separated, Django query sets are lazy (somewhat like what we did in<a href="index_split_002.html#p312"> Chapter 7, </a>  <i class="calibre4">Extract Information from</i> <i class="calibre4">Raster Data</i>), and they are evaluated only when a value is needed. This means that Django will only hit the database once when we start iterating through the values (for item in amenity_values). </p>
<p class="calibre1">1.  Run the code. You should get a more modest list of amenity types: arts_centre</p>
<p class="calibre1">atm</p>
<p class="calibre1">audiologist</p>
<p class="calibre1">bakery</p>
<p class="calibre1">bank</p>
<p class="calibre1">bar</p>
<p class="calibre1">bbq</p>
<p class="calibre1">bench</p>
<p class="calibre1">bicycle_parking</p>
<p class="calibre1">bicycle_rental</p>
<p class="calibre1">billboard</p>
<p class="calibre1">bureau_de_change</p>
<p class="calibre1">bus_station</p>
<p class="calibre1"><a id="p389"/>cafe</p>
<p class="calibre1">car_rental</p>
<p class="calibre1">car_repair</p>
<p class="calibre1">car_sharing</p>
<p class="calibre1">car_wash</p>
<p class="calibre1">childcare</p>
<p class="calibre1">cinema</p>
<p class="calibre1">city_hall</p>
<p class="calibre1">clinic</p>
<p class="calibre1">clock</p>
<p class="calibre1">college</p>
<p class="calibre1">... </p>
<p class="calibre1">Now, let’s find out how many cinemas (movie theatres) we can find in Montreal: 2.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':    </p>
<p class="calibre1">montreal = GeoObject.objects.get(atype='canada', </p>
<p class="calibre1">tags__key='CDNAME', </p>
<p class="calibre1">tags__value='Montréal')</p>
<p class="calibre1">cinemas = GeoObject.objects.filter(atype='poi', </p>
<p class="calibre1">geom__within=montreal.geom, </p>
<p class="calibre1">tags__key='amenity', </p>
<p class="calibre1">tags__value='cinema')</p>
<p class="calibre1">print("{} cinemas.".format(cinemas.count()))</p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">Note that we are using the count method instead of Python’s len function. This makes the counting happen on the database and only the output value is returned. </p>
<p class="calibre1">This is much faster than getting all the objects and then counting with Python. </p>
<p class="calibre1">3.  Now run it and check the output:</p>
<p class="calibre1">16 cinemas. </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1"><a id="p390"/>
<a id="p391"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we explored introductory concepts about code efficiency and how to measure it. Equipped with the right tools, we optimized our code to make it run faster. </p>
<p class="calibre1">Instead of storing data into Python objects, we turned to SQL databases. We thereby enhanced our app with state-of-the-art filtering and got information in an efficient way. </p>
<p class="calibre1">Later, we came across a large amount of data that was impossible to import with ordinary computers. We optimized our code again, making it memory-efficient and stable, allowing us to import this data. Finally, we queried the data, testing the new feature capabilities. </p>
<p class="calibre1">In the next chapter, we will face similar speed and memory problems but with images (raster) data. This will require us to develop new and creative solutions. </p>
<p class="calibre1"><a id="p392"/>
<a id="p393"/><b class="calibre3">Chapter 9. Processing Big Images</b></p>
<p class="calibre1">Processing satellite images (or other remote sensing data) is a computational challenge for two reasons: normally, the images are big (many megabytes or gigabytes) and many images are needed in combination to produce the desired information. </p>
<p class="calibre1">Opening and processing many big images can consume a lot of computer memory. This condition sets a tight limit on what the user can do before running out of memory. </p>
<p class="calibre1">In this chapter, we will focus on how to perform sustainable image processing and how to open and make calculations with many big images while keeping the memory consumption low with efficient code. </p>
<p class="calibre1">The following topics will be covered:</p>
<p class="calibre1">An introduction to satellite images and Landsat 8 data</p>
<p class="calibre1">How to select and download Landsat 8 data</p>
<p class="calibre1">What happens to the computer memory when we work with images? </p>
<p class="calibre1">How to read images in chunks</p>
<p class="calibre1">What are Python iterators and generators? </p>
<p class="calibre1">How to iterate through an image</p>
<p class="calibre1">How to create color compositions with the new techniques</p>
<p class="calibre1"><a id="p394"/><img src="img/index-394_1.jpg" alt="Image 66" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Working with satellite images</b></p>
<p class="calibre1">Satellite images are a form of remote sensing data. They are composed of the information collected by satellites and are made available to users as image files. Just like the digital elevation model that we worked on before, these images are made of pixels, each one representing the value of a given attribute for a given geographic extent. </p>
<p class="calibre1">These images can be used to visualize features on Earth using real colors or they can be used to identify a variety of characteristics using parts of the light spectrum invisible to the human eyes. </p>
<p class="calibre1">In order to follow the examples, we will use images from the Landsat 8 satellite. They are available for free on the Internet. Let’s take a look at some of the characteristics of this satellite. </p>
<p class="calibre1">Landsat 8 carries two instruments: the <b class="calibre3">Operational Land Imager</b> (<b class="calibre3">OLI</b>) and the <b class="calibre3">Thermal Infrared Sensor</b> (<b class="calibre3">TIRS</b>). </p>
<p class="calibre1">These sensors can collect data in a total of 10 different bands processed in a resolution of 4096 possible levels (12-bit). The data is encoded into 16-bit TIFF images scaled to 55000</p>
<p class="calibre1">possible values. </p>
<p class="calibre1"><b class="calibre3">Wavelength</b></p>
<p class="calibre1"><b class="calibre3">Resolution</b></p>
<p class="calibre1"><b class="calibre3">Bands</b></p>
<p class="calibre1"><b class="calibre3">Common uses</b></p>
<p class="calibre1"><b class="calibre3">(micrometers)</b></p>
<p class="calibre1"><b class="calibre3">(meters)</b></p>
<p class="calibre1">Band 1—Coastal</p>
<p class="calibre1">Shallow coastal water studies and estimation of the</p>
<p class="calibre1">0.43 - 0.45</p>
<p class="calibre1">30</p>
<p class="calibre1">aerosol</p>
<p class="calibre1">concentration of aerosols in the atmosphere</p>
<p class="calibre1">Band 2—Blue</p>
<p class="calibre1">0.45 - 0.51</p>
<p class="calibre1">30</p>
<p class="calibre1">Visible blue channel, distinguish soil from vegetation</p>
<p class="calibre1">Band 3—Green</p>
<p class="calibre1">0.53 - 0.59</p>
<p class="calibre1">30</p>
<p class="calibre1">Visible green channel</p>
<p class="calibre1">Band 4—Red</p>
<p class="calibre1">0.64 - 0.67</p>
<p class="calibre1">30</p>
<p class="calibre1">Visible red channel</p>
<p class="calibre1"><a id="p395"/>Band 5—Near Infrared 0.85 - 0.88</p>
<p class="calibre1">30</p>
<p class="calibre1">Biomass estimation</p>
<p class="calibre1">(NIR)</p>
<p class="calibre1">Band 6—SWIR 1</p>
<p class="calibre1">1.57 - 1.65</p>
<p class="calibre1">30</p>
<p class="calibre1">Soil moisture</p>
<p class="calibre1">Band 7—SWIR 2</p>
<p class="calibre1">2.11 - 2.29</p>
<p class="calibre1">30</p>
<p class="calibre1">Soil moisture</p>
<p class="calibre1">Band 8—Panchromatic 0.50 - 0.68</p>
<p class="calibre1">15</p>
<p class="calibre1">Sharper resolution</p>
<p class="calibre1">Band 9—Cirrus</p>
<p class="calibre1">1.36 - 1.38</p>
<p class="calibre1">30</p>
<p class="calibre1">Detection of cirrus cloud contamination</p>
<p class="calibre1">Band 10—Thermal</p>
<p class="calibre1">10.60 - 11.19</p>
<p class="calibre1">30</p>
<p class="calibre1">Thermal mapping and estimating soil moisture</p>
<p class="calibre1">Infrared (TIRS) 1</p>
<p class="calibre1">Band 11—Thermal</p>
<p class="calibre1">11.50 - 12.51</p>
<p class="calibre1">30</p>
<p class="calibre1">Thermal mapping and estimating soil moisture</p>
<p class="calibre1">Infrared (TIRS) 2</p>
<p class="calibre1"><a id="p396"/><img src="img/index-396_1.jpg" alt="Image 67" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Getting Landsat 8 images</b></p>
<p class="calibre1">Landsat 8 images are available freely on the Internet and there are some nice tools to find and download these images. For the book, we will use <b class="calibre3">U.S Geological Survey</b> (<b class="calibre3">USGS</b>) EarthExplorer. It’s a web app packed with resources to obtain geographic data. </p>
<p class="calibre1">In order to follow the book’s examples, we will download data for the same Montreal (Quebec, Canada) area that we obtained the points of interest of the previous chapter. This data is included in the book’s sample data and you can skip these steps if you wish. </p>
<p class="calibre1">First, we will open the website and select our region of interest as follows: 1.  Go to the <a href="http://earthexplorer.usgs.gov/">http://earthexplorer.usgs.gov/ </a>website. You will see a map, some options at the top, and a panel with search tools on the left-hand side: 2.  At the top right, you will see a <b class="calibre3">Login</b>/<b class="calibre3">Register</b> button. If you don’t have an account, click on <b class="calibre3">Register</b> and create a new one. Otherwise, log in to the system. </p>
<p class="calibre1">3.  The next step is to search for the location of interest. You can search by entering Montreal in the box and clicking on <b class="calibre3">Show</b>. A list will appear with the search results. </p>
<p class="calibre1">Click on <b class="calibre3">Montreal</b> on the list. A marker will appear and the coordinates will be set. </p>
<p class="calibre1">4.  Click on the <b class="calibre3">Data Sets</b> button to show the available data for this coordinate. </p>
<p class="calibre1">5.  On the next screen, expand the <b class="calibre3">Landsat Archive</b> item, select <b class="calibre3">L8 OLI/TIRS</b>, and click on the <b class="calibre3">Additional Criteria</b> button. </p>
<p class="calibre1"><a id="p397"/><img src="img/index-397_1.jpg" alt="Image 68" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-397_2.jpg" alt="Image 69" class="calibre2"/></p>
<p class="calibre1">6.  Now, let’s make sure that we get images with little cloud cover. Use the scroll bar to find the <b class="calibre3">Cloud Cover</b> item and select <b class="calibre3">Less than 10%</b>. Now, click on <b class="calibre3">Results</b> to see what was found. </p>
<p class="calibre1">7.  A new tab will open showing the results. Note that each item contains a small toolbar with a set of icons. Click on the feet icon of some of the images to see their extent on the map:</p>
<p class="calibre1">8.  For our examples, we need just one data set: one for path 14, row 28. Find the data</p>
<p class="calibre1"><a id="p398"/><img src="img/index-398_1.jpg" alt="Image 70" class="calibre2"/></p>
<p class="calibre1">for this set of rows and columns (you can use an image from any date; it’s up to you) and then click on the <b class="calibre3">Download Options</b> button on the mini toolbar (it’s the icon with a green arrow pointing to a hard drive). </p>
<p class="calibre1">9.  A window will pop up with the download options. Click on <b class="calibre3">Download Level 1</b></p>
<p class="calibre1"><b class="calibre3">GeoTIFF Data Product</b>. </p>
<p class="calibre1"><b class="calibre3">Note</b></p>
<p class="calibre1">USGS has an application that can manage and resume large downloads. Take a look at<a href="https://lta.cr.usgs.gov/BulkDownloadApplication"> https://lta.cr.usgs.gov/BulkDownloadApplication </a>for more information. </p>
<p class="calibre1">10.  After the download is complete, create a new folder in your data folder and name it landsat. Unpack all the images in this folder. </p>
<p class="calibre1">Each package contains 12 .tif images and a text file containing the metadata. Each image name is composed of the row, column, date, and band of the image. Note that the band 8</p>
<p class="calibre1">image (B8) is much larger than the other images. This is because it has a better resolution. </p>
<p class="calibre1">BQA is a quality assessment band. It contains information on the quality of each of the pixels in the image. We will see more about this band later. </p>
<p class="calibre1"><a id="p399"/>
<a id="p400"/><b class="calibre3">Memory and images</b></p>
<p class="calibre1">First, we will check how opening images affects random access memory (RAM) usage. In our first example, we will try to open band 8 of the Landsat data using the same technique as before:</p>
<p class="calibre1">1.  Prepare the working environment for Chapter 9 by making a copy of the Chapter8</p>
<p class="calibre1">folder in your geopy project. Name the copied folder as Chapter9. </p>
<p class="calibre1">2.  In Chapter9 folder, open the experiments folder and delete all the files inside it. </p>
<p class="calibre1">3.  In the experiments folder, create a new Python file and name it images.py. Open it for editing. </p>
<p class="calibre1">4.  Now type the following code in this file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import cv2 as cv</p>
<p class="calibre1">def open_image(img_path):</p>
<p class="calibre1">image = cv.imread(img_path)</p>
<p class="calibre1">print(type(image))</p>
<p class="calibre1">raw_input("Press any key.")</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">open_image(image_path)</p>
<p class="calibre1">5.  Run the code. Press  <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> and select the images on the list. </p>
<p class="calibre1">6.  Depending on your computer’s memory and the OpenCV version, you may succeed. </p>
<p class="calibre1">Otherwise, you will see this nice exception:</p>
<p class="calibre1">OpenCV Error: Insufficient memory (Failed to allocate 723585188 bytes) in cv::OutOfMemoryError, file ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp, line 52</p>
<p class="calibre1">Traceback (most recent call last):</p>
<p class="calibre1">File "Chapter9/experiments/images.py", line 14, in &lt;module&gt; open_image(image_path)</p>
<p class="calibre1">File " experiments/images.py", line 6, in open_image image = cv.imread(img_path)</p>
<p class="calibre1">cv2.error: ..\..\..\opencv-2.4.11\modules\core\src\alloc.cpp:52: error: (-4) Failed to allocate 723585188 bytes in function </p>
<p class="calibre1">cv::OutOfMemoryError</p>
<p class="calibre1">Process finished with exit code 1</p>
<p class="calibre1">This happens because we are using the 32-bit version of the Python interpreter (that is, x86) and the program fails to allocate enough memory to open the whole image at once. </p>
<p class="calibre1">7.  Let’s try with a band with a smaller file size. Change the filename to match band 1 of any of the images. It could be LC80140282015270LGN00_B1.TIF. </p>
<p class="calibre1"><a id="p401"/><img src="img/index-401_1.jpg" alt="Image 71" class="calibre2"/></p>
<p class="calibre1">8.  Run the code again. You should see a prompt asking you to press any key:</p>
<p class="calibre1">&lt;type 'numpy.ndarray'&gt; </p>
<p class="calibre1">Press any key. </p>
<p class="calibre1">This was done on purpose in order to halt the program execution while the image is still in the memory. </p>
<p class="calibre1">9.  Now, if you are using Windows, press  <i class="calibre4">Ctrl</i> +  <i class="calibre4">Alt</i> +  <i class="calibre4">Del</i> and open the task manager. If you are using Ubuntu Linux, open the system monitor. </p>
<p class="calibre1">10.  Look for the Python process and see how much memory it’s using. You should see something as follows:</p>
<p class="calibre1">That’s OK. The image has opened and isn’t consuming much memory. </p>
<p class="calibre1">11.  Press any key on the console to finish program execution. </p>
<p class="calibre1">12.  Now, let’s simulate opening more than one image and see what happens. Change your open_image function:</p>
<p class="calibre1">def open_image(img_path):</p>
<p class="calibre1">image = cv.imread(img_path)</p>
<p class="calibre1">image2 = cv.imread(img_path)</p>
<p class="calibre1">image3 = cv.imread(img_path)</p>
<p class="calibre1">image4 = cv.imread(img_path)</p>
<p class="calibre1">image5 = cv.imread(img_path)</p>
<p class="calibre1">raw_input("Press any key.")</p>
<p class="calibre1">13.  Run the code again and check the memory used by Python. For me, it’s 872 MB. </p>
<p class="calibre1">14.  Press any key in the console to exit the program and release the memory. </p>
<p class="calibre1">15.  For our last test, open the image one more time to see what happens: def open_image(img_path):</p>
<p class="calibre1">image = cv.imread(img_path)</p>
<p class="calibre1">image2 = cv.imread(img_path)</p>
<p class="calibre1">image3 = cv.imread(img_path)</p>
<p class="calibre1">image4 = cv.imread(img_path)</p>
<p class="calibre1">image5 = cv.imread(img_path)</p>
<p class="calibre1">image6 = cv.imread(img_path)</p>
<p class="calibre1">raw_input("Press any key.")</p>
<p class="calibre1">16.  Run the code and see the result:</p>
<p class="calibre1">cv2.error: D:\Build\OpenCV\OpenCV-</p>
<p class="calibre1">2.4.11\modules//python//src2//cv2.cpp:201: error: (-2) The numpy array of typenum=2, ndims=3 can not be created in function </p>
<p class="calibre1">NumpyAllocator::allocate</p>
<p class="calibre1"><a id="p402"/>Process finished with exit code 1</p>
<p class="calibre1">Again, the program failed to allocate enough memory to open the image. </p>
<p class="calibre1">The point of these experiments was to show that, while processing images, there is a good chance of facing memory problems. With band 8, it was even impossible to begin processing it because we couldn’t open it. </p>
<p class="calibre1">With band 1, we simulated a common situation where we wanted to perform a calculation involving many images and this calculation had sub-steps. The memory consumption would escalate until the program crashes. </p>
<p class="calibre1">The maximum amount of memory that Python is allowed to use is limited by the operation system and the Python version (64 or 32 bits). Probably, if you are running the 64 bits version of Python, or using Linux, you won’t face any error during the examples. </p>
<p class="calibre1">Independent of being able to run this program or not, these examples show a code whose success is tied to the image size. Even while running a 64-bit Python on a Linux machine with 32 GB of RAM, the program may run out of memory if the images are too big and the process is complex. Remember that some satellite images could be pretty large. </p>
<p class="calibre1"><a id="p403"/>
<a id="p404"/><b class="calibre3">Processing images in chunks</b></p>
<p class="calibre1">We will change the code, so we can open images of any size. The principle is the same as the one we applied in the previous chapter: in order to read and import an arbitrary number of points, we made the program read, import, and release the memory after each small set of points. </p>
<p class="calibre1">Instead of reading points, we will read a small piece from the image, make some calculations, write the output on the disk, and release the memory before repeating the process with the next piece. </p>
<p class="calibre1"><a id="p405"/><b class="calibre3">Using GDAL to open images</b></p>
<p class="calibre1">The process of reading selected regions of a given image is no easy task. Many factors are relevant, such as how the data is encoded in the image, the type of data, how to read the data, and so on. Fortunately, GDAL is equipped with great functions and methods that abstract most of the low-level process. Let’s experiment with it: 1.  In the images.py file, import GDAL at the beginning of the file: import gdal</p>
<p class="calibre1">2.  Now, create a new function to open the Landsat band 8 using GDAL: def open_image_gdal(img_path):</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">cols = dataset.RasterXSize</p>
<p class="calibre1">rows = dataset.RasterYSize</p>
<p class="calibre1">print "Image dimensions: {} x {}px".format(cols, rows) raw_input("Press any key.")</p>
<p class="calibre1">3.  Change the if __name__ == '__main__': block to use the new function: if __name__ == '__main__':</p>
<p class="calibre1">image_path = "../../data/landsat/LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">open_image_gdal(image_path)</p>
<p class="calibre1">4.  Run your code and check the output:</p>
<p class="calibre1">Image dimensions: 15401 x 15661px</p>
<p class="calibre1">Press any key. </p>
<p class="calibre1">We simply opened the image and printed its dimensions. You should have noticed that the code ran incredibly fast and with no errors. If you wish, you can check how much memory the Python process is using (using the Task Manager or the system monitor). </p>
<p class="calibre1">What happened this time is that the data wasn’t read when the file was opened. GDAL</p>
<p class="calibre1">only got the information about the image, but the actual data wasn’t touched. </p>
<p class="calibre1">Let’s try reading a few pixels from this image:</p>
<p class="calibre1">1.  Press any key to exit the program. </p>
<p class="calibre1">2.  Edit the function:</p>
<p class="calibre1">def open_image_gdal(img_path):</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">cols = dataset.RasterXSize</p>
<p class="calibre1">rows = dataset.RasterYSize</p>
<p class="calibre1">print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols / 2)</p>
<p class="calibre1">middle_row = int(rows / 2)</p>
<p class="calibre1">array = dataset.ReadAsArray(xoff=middle_col - 50, </p>
<p class="calibre1">yoff=middle_row - 50, </p>
<p class="calibre1">xsize=100, ysize=100)</p>
<p class="calibre1">print(array)</p>
<p class="calibre1">print(array.shape)</p>
<p class="calibre1"><a id="p406"/>3.  Run the code again and check the output: Image dimensions: 15401 x 15661px</p>
<p class="calibre1">[[8826 8821 8846…, 8001 7965 7806]</p>
<p class="calibre1">[8842 8838 8853…, 7982 7931 7676]</p>
<p class="calibre1">[8844 8860 8849…, 8050 7958 7693]</p>
<p class="calibre1">..., </p>
<p class="calibre1">[7530 7451 7531…, 7471 7457 7494]</p>
<p class="calibre1">[7605 7620 7555…, 7533 7519 7610]</p>
<p class="calibre1">[7542 7542 7499…, 7620 7947 7728]]</p>
<p class="calibre1">(100, 100)</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">We just read a chunk of 100 x 100 pixels from the centre of the image. Again, the code ran fast and little memory was consumed. </p>
<p class="calibre1">Now let’s try something fancier. Read a region from the image and save it on the disk, so we can visualize it. </p>
<p class="calibre1">4.  First, delete all the files from the Chapter9/output folder. We will save our image here. </p>
<p class="calibre1">5.  Add the adjust_values function and edit the code of the open_image_gdal function: def adjust_values(array, img_range=None):</p>
<p class="calibre1">"""Projects a range of values into a grayscale image. </p>
<p class="calibre1">:param array: A Numpy array containing the image data. </p>
<p class="calibre1">:param img_range: specified range of values or None to use</p>
<p class="calibre1">the range of the image (minimum and maximum). </p>
<p class="calibre1">""" </p>
<p class="calibre1">if img_range:</p>
<p class="calibre1">min = img_range[0]</p>
<p class="calibre1">max = img_range[1]</p>
<p class="calibre1">else:</p>
<p class="calibre1">min = array.min()</p>
<p class="calibre1">max = array.max()</p>
<p class="calibre1">interval = max - min</p>
<p class="calibre1">factor = 256.0 / interval</p>
<p class="calibre1">output = array * factor</p>
<p class="calibre1">return output</p>
<p class="calibre1">def open_image_gdal(img_path):</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">cols = dataset.RasterXSize</p>
<p class="calibre1">rows = dataset.RasterYSize</p>
<p class="calibre1">print "Image dimensions: {} x {}px".format(cols, rows) middle_col = int(cols / 2)</p>
<p class="calibre1">middle_row = int(rows / 2)</p>
<p class="calibre1">array = dataset.ReadAsArray(xoff=middle_col - 50, </p>
<p class="calibre1">yoff=middle_row - 50, </p>
<p class="calibre1">xsize=1000, ysize=1000)</p>
<p class="calibre1">print(array.shape)</p>
<p class="calibre1">greyscale_img = adjust_values(array)</p>
<p class="calibre1">cv.imwrite('../output/landsat_chunk.jpg', greyscale_img)</p>
<p class="calibre1"><a id="p407"/><img src="img/index-407_1.jpg" alt="Image 72" class="calibre2"/></p>
<p class="calibre1">The adjust_values function is the same that we used before to adjust the gray values of the elevation data in order to visualize it. </p>
<p class="calibre1">We are using OpenCV to write the JPG image for two reasons: by default, GDAL</p>
<p class="calibre1">can’t write JPG on Windows, and OpenCV is easier to use in this simple case. </p>
<p class="calibre1">6.  Run the code and open the image in the output folder. If you are using the same Landsat data as I am, you should see this beautiful image of Quebec’s rural area:</p>
<p class="calibre1"><a id="p408"/><img src="img/index-408_1.jpg" alt="Image 73" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Iterating through the whole image</b></p>
<p class="calibre1">We saw that we can read specific parts of an image. With this concept, we can process the whole image one piece at a time. By doing this, it’s possible to make calculations that involve many bands. We just need to read the same region of each band, obtain the results, write them, release the memory, and move to the next piece. </p>
<p class="calibre1">The most obvious way to iterate through something in Python is to use a for loop. We can iterate through the elements on a list, characters on a string, keys on a dictionary, features on a vector layer, and so on. </p>
<p class="calibre1"> <i class="calibre4">The preceding image is taken from http://nvie.com/posts/iterators-vs-generators/</i></p>
<p class="calibre1">You may have heard the concepts of iterables, iterators, and generators. <b class="calibre3">Iterables</b>, like a list, become iterators when they are used in a for loop. But we don’t want to create a list of image chunks, because in order to do this, we would need to read the whole image upfront to produce the list. That’s when a special feature of iterators comes into light: they are lazy. </p>
<p class="calibre1">An <b class="calibre3">iterator</b> is nothing more than a class with specific magic methods. At every loop, this class next() method is called and a new value is returned. Python has handy tools to create iterators and that’s the point when we are going to see what are generators. Let’s write some code:</p>
<p class="calibre1">1.  In your images.py file, add a new function:</p>
<p class="calibre1">def create_image_generator(dataset):</p>
<p class="calibre1">cols = dataset.RasterXSize</p>
<p class="calibre1">rows = dataset.RasterYSize</p>
<p class="calibre1">for row_index in xrange(0, rows):</p>
<p class="calibre1">yield dataset.ReadAsArray(xoff=0, yoff=row_index, </p>
<p class="calibre1">xsize=cols, ysize=1)</p>
<p class="calibre1"><a id="p409"/>2.  Now edit the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">img_generator = create_image_generator(dataset)</p>
<p class="calibre1">print(img_generator)</p>
<p class="calibre1">print(type(img_generator))</p>
<p class="calibre1">3.  Run the code and check the output:</p>
<p class="calibre1">&lt;generator object create_image_generator at 0x0791D968&gt; </p>
<p class="calibre1">&lt;type 'generator'&gt; </p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Our create_image_generator function has a special behavior because of the yield word in the for loop. When we iterate through the generator object created by this function, the yield statement halts the function execution and returns a value at each loop. In our case, the generator/iterator will return one image row at a time. </p>
<p class="calibre1">4.  Just to check whether it works, try this in the if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">img_generator = create_image_generator(dataset)</p>
<p class="calibre1">print(img_generator)</p>
<p class="calibre1">print(type(img_generator))</p>
<p class="calibre1">for row in img_generator:</p>
<p class="calibre1">print(row)</p>
<p class="calibre1">5.  Run the code and look at the output:</p>
<p class="calibre1">... </p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">[[0 0 0…, 0 0 0]]</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">What you see is Python printing a lot of arrays, each containing the data of one row. You see zeros because the borders of the image are black and all the other values are</p>
<p class="calibre1"><a id="p410"/>suppressed by NumPy to fit the console. Let’s make a few tests to explore the characteristics of iterators:</p>
<p class="calibre1">1.  Now, try this concept test just to check another characteristic of iterators: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat" </p>
<p class="calibre1">base_path = "C:/Users/Pablo/Desktop/landsat" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">dataset = gdal.Open(img_path)</p>
<p class="calibre1">img_generator = create_image_generator(dataset)</p>
<p class="calibre1">print(img_generator[4])</p>
<p class="calibre1">2.  Run the code and an error will be raised:</p>
<p class="calibre1">Traceback (most recent call last):</p>
<p class="calibre1">File "Chapter9/experiments/images.py", line 98, in &lt;module&gt; print(img_generator[4])</p>
<p class="calibre1">TypeError: 'generator' object has no attribute '__getitem__' </p>
<p class="calibre1">Remember that iterators are lazy and do not behave like sequences (for example, lists). The elements are calculated one at a time and we can’t get the 5th element directly. </p>
<p class="calibre1">3.  Now, to check whether it really works, let’s make a copy of the image one line at a time. Create this new function:</p>
<p class="calibre1">def copy_image(src_image, dst_image):</p>
<p class="calibre1">try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1">src_dataset = gdal.Open(src_image)</p>
<p class="calibre1">cols = src_dataset.RasterXSize</p>
<p class="calibre1">rows = src_dataset.RasterYSize</p>
<p class="calibre1">driver = gdal.GetDriverByName('GTiff')</p>
<p class="calibre1">new_dataset = driver.Create(dst_image, cols, rows, </p>
<p class="calibre1">eType=gdal.GDT_UInt16)</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(src_dataset, new_dataset)</p>
<p class="calibre1">band = new_dataset.GetRasterBand(1)</p>
<p class="calibre1">for index, img_row in enumerate(</p>
<p class="calibre1">create_image_generator(src_dataset)):</p>
<p class="calibre1">band.WriteArray(xoff=0, yoff=index, array=img_row)</p>
<p class="calibre1">In order to copy the image, we created a new dataset using GDAL’s GTiff driver. The new dataset has the same number of rows, columns, and data types (an unsigned 16-bit integer). </p>
<p class="calibre1">To ensure that the copy has the same projection information as the source, we used</p>
<p class="calibre1"><a id="p411"/>the function gdal_array.CopyDatasetInfo, thus saving us a lot of code. </p>
<p class="calibre1">Finally, using our generator, we read one line at a time and wrote it to the output band. </p>
<p class="calibre1">4.  Edit the if __name__ == '__main__': block and run the following code to test it: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">img_copy = "../output/B8_copy.TIF" </p>
<p class="calibre1">copy_image(img_path, img_copy)</p>
<p class="calibre1">Open both of the images (the original and the copy) just to check whether they look the same. </p>
<p class="calibre1"><a id="p412"/>
<a id="p413"/><b class="calibre3">Creating image compositions</b></p>
<p class="calibre1">Now that we know the basics of iterating through the image, which allows us to process many bands together without running out of memory, let’s produce some fancier results. </p>
<p class="calibre1"><a id="p414"/><b class="calibre3">True color compositions</b></p>
<p class="calibre1">Since we have Landsat’s red, green, and blue bands, we can create an image with  <i class="calibre4">true</i> <i class="calibre4">colors</i>. This means an image with colors similar to what they would be if we were directly observing the scene (for example, the grass is green and the soil is brown). To do this, we will explore a little bit more of Python’s iterators. </p>
<p class="calibre1">The Landsat 8 RGB bands are respectively bands 4, 3, and 2. Following the concept that we want to automate tasks and processes, we won’t repeat the commands for each one of the bands. We will program Python to do this as follows:</p>
<p class="calibre1">1.  Edit your imports at the beginning of the file to be as follows: import os</p>
<p class="calibre1">import cv2 as cv</p>
<p class="calibre1">import itertools</p>
<p class="calibre1">from osgeo import gdal, gdal_array</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">2.  Now add this new function. It will prepare the bands’ paths for us: def compose_band_path(base_path, base_name, band_number):</p>
<p class="calibre1">return os.path.join(</p>
<p class="calibre1">base_path, base_name) + str(band_number) + ".TIF" </p>
<p class="calibre1">3.  To check the purpose of this function and itertools we imported, edit the if __name__ == '__main__': block with this code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat" </p>
<p class="calibre1">base_name = 'LC80140282015270LGN00_B' </p>
<p class="calibre1">bands_numbers = [4, 3, 2]</p>
<p class="calibre1">bands = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat(base_path), </p>
<p class="calibre1">itertools.repeat(base_name), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">print(bands)</p>
<p class="calibre1">for item in bands:</p>
<p class="calibre1">print(item)</p>
<p class="calibre1">4.  Now run the code and check the results:</p>
<p class="calibre1">&lt;itertools.imap object at 0x02DE9510&gt; </p>
<p class="calibre1">../../data/landsat/LC80140282015270LGN00_B4.TIF</p>
<p class="calibre1">../../data/landsat/LC80140282015270LGN00_B3.TIF</p>
<p class="calibre1">../../data/landsat/LC80140282015270LGN00_B2.TIF</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The compose band path simply joins the base path, the name of the band, and the band number in order to output a band filename with its path. </p>
<p class="calibre1"><a id="p415"/>Instead of calling the function in a for loop and appending the results to a list, we used the itertools.imap function. This function takes another function as the first argument and any iterables as the other arguments. It creates an iterator that will call the function with the arguments at each iteration. The itertools.repeat function is responsible for repeating a given value infinite times when iterated. </p>
<p class="calibre1">5.  Now, we will write the function that will combine the bands into an RGB image. Add this function to your file:</p>
<p class="calibre1">def create_color_composition(bands, dst_image):</p>
<p class="calibre1">try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1"># Part1</p>
<p class="calibre1">datasets = map(gdal.Open, bands)</p>
<p class="calibre1">img_iterators = map(create_image_generator, datasets)</p>
<p class="calibre1">cols = datasets[0].RasterXSize</p>
<p class="calibre1">rows = datasets[0].RasterYSize</p>
<p class="calibre1"># Part2</p>
<p class="calibre1">driver = gdal.GetDriverByName('GTiff')</p>
<p class="calibre1">new_dataset = driver.Create(dst_image, cols, rows, </p>
<p class="calibre1">eType=gdal.GDT_Byte, </p>
<p class="calibre1">bands=3, </p>
<p class="calibre1">options=["PHOTOMETRIC=RGB"])</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(datasets[0], new_dataset)</p>
<p class="calibre1"># Part3</p>
<p class="calibre1">rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])</p>
<p class="calibre1">for index, bands_rows in enumerate(</p>
<p class="calibre1">itertools.izip(*img_iterators)):</p>
<p class="calibre1">for band, row in zip(rgb_bands, bands_rows):</p>
<p class="calibre1">row = adjust_values(row, [0, 30000])</p>
<p class="calibre1">band.WriteArray(xoff=0, yoff=index, array=row)</p>
<p class="calibre1">In Part 1, Python’s built-in map function works like itertools.imap, but instead of an iterator, it creates a list with the results. This means that all the items are calculated and available. First, we used it to create a list of GDAL datasets by calling gdal.Open on all the bands. Then, the map function is used to create a list of image iterators, one for each band. </p>
<p class="calibre1">In Part 2, we created the output database just like we did before. But this time, we told the driver to create a dataset with three bands, each with byte data type (256</p>
<p class="calibre1">possible values). We also tell that it’s an RGB photo in the options. </p>
<p class="calibre1">In Part 3, we used the map function again to get the reference to the bands in the dataset. In the first for loop, at each iteration, we got an index, that is, the row number, and a tuple containing a row for every band. </p>
<p class="calibre1">In the nested for loop, each iteration gets one of the output image bands and one row of the input bands. The values of the row are then converted from 16-bit to 8-bit (byte) with our adjust_values function. To adjust the values, we passed a magic</p>
<p class="calibre1"><a id="p416"/><img src="img/index-416_1.jpg" alt="Image 74" class="calibre2"/></p>
<p class="calibre1">number in order to get a brighter image. Finally, the row is written to the output band. </p>
<p class="calibre1">6.  Finally, let’s test the code. Edit your if __name__ == '__main__': block: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">base_name = 'LC80140282015270LGN00_B' </p>
<p class="calibre1">bands_numbers = [4, 3, 2]</p>
<p class="calibre1">bands = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat(base_path), </p>
<p class="calibre1">itertools.repeat(base_name), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">dst_image = "../output/color_composition.tif" </p>
<p class="calibre1">create_color_composition(bands, dst_image)</p>
<p class="calibre1">7.  Now run it. After it’s done, open the image (color_composition.tif) in the output folder. You should see this beautiful color image:</p>
<p class="calibre1">You can play with the numbers that we passed to the adjust_values function. Try changing the lower limit and the upper limit; you will get different variations of brightness. </p>
<p class="calibre1"><a id="p417"/><b class="calibre3">Processing specific regions</b></p>
<p class="calibre1">Now, let’s change our code to crop the image for us, so we can have a better view of the details of the region around Montreal. It’s something like we did before. But instead of cropping the image after processing, we will only process the region of interest, making the code much more efficient. </p>
<p class="calibre1">1.  Edit the create_image_generator function:</p>
<p class="calibre1">def create_image_generator(dataset, crop_region=None):</p>
<p class="calibre1">if not crop_region:</p>
<p class="calibre1">cols = dataset.RasterXSize</p>
<p class="calibre1">rows = dataset.RasterYSize</p>
<p class="calibre1">xoff = 0</p>
<p class="calibre1">yoff = 0</p>
<p class="calibre1">else:</p>
<p class="calibre1">xoff = crop_region[0]</p>
<p class="calibre1">yoff = crop_region[1]</p>
<p class="calibre1">cols = crop_region[2]</p>
<p class="calibre1">rows = crop_region[3]</p>
<p class="calibre1">for row_index in xrange(yoff, yoff + rows):</p>
<p class="calibre1">yield dataset.ReadAsArray(xoff=xoff, yoff=row_index, </p>
<p class="calibre1">xsize=cols, ysize=1)</p>
<p class="calibre1">Now, the function receives an optional crop_region argument and only yields rows of the region of interest if it’s passed. If not, it yields rows for the whole image. </p>
<p class="calibre1">2.  Change the create_color_composition class to work with the cropped data: def create_color_composition(bands, dst_image, crop_region=None): try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1">datasets = map(gdal.Open, bands)</p>
<p class="calibre1">img_iterators = list(itertools.imap(</p>
<p class="calibre1">create_image_generator, datasets, </p>
<p class="calibre1">itertools.repeat(crop_region)))</p>
<p class="calibre1">if not crop_region:</p>
<p class="calibre1">cols = datasets[0].RasterXSize</p>
<p class="calibre1">rows = datasets[0].RasterYSize</p>
<p class="calibre1">else:</p>
<p class="calibre1">cols = crop_region[2]</p>
<p class="calibre1">rows = crop_region[3]</p>
<p class="calibre1">driver = gdal.GetDriverByName('GTiff')</p>
<p class="calibre1">new_dataset = driver.Create(dst_image, cols, rows, </p>
<p class="calibre1">eType=gdal.GDT_Byte, </p>
<p class="calibre1">bands=3, </p>
<p class="calibre1">options=["PHOTOMETRIC=RGB"])</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(datasets[0], new_dataset)</p>
<p class="calibre1">rgb_bands = map(new_dataset.GetRasterBand, [1, 2, 3])</p>
<p class="calibre1">for index, bands_rows in enumerate(</p>
<p class="calibre1">itertools.izip(*img_iterators)):</p>
<p class="calibre1"><a id="p418"/><img src="img/index-418_1.jpg" alt="Image 75" class="calibre2"/></p>
<p class="calibre1">for band, row in zip(rgb_bands, bands_rows):</p>
<p class="calibre1">row = adjust_values(row, [1000, 30000])</p>
<p class="calibre1">band.WriteArray(xoff=0, yoff=index, array=row)</p>
<p class="calibre1">Note that when img_iterators was created, we replaced the map function by itertools.imap in order to be able to use the itertools.repeat function. Since we need img_iterators to be a list of iterators, we used the list function. </p>
<p class="calibre1">3.  Finally, edit the if __name__ == '__main__': block to pass our region of interest: if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">base_name = 'LC80140282015270LGN00_B' </p>
<p class="calibre1">bands_numbers = [4, 3, 2]</p>
<p class="calibre1">bands = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat(base_path), </p>
<p class="calibre1">itertools.repeat(base_name), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">dst_image = "../output/color_composition.tif" </p>
<p class="calibre1">create_color_composition(bands, dst_image, </p>
<p class="calibre1">(1385, 5145, 1985, 1195))</p>
<p class="calibre1">4.  Run the code. You should now have this nice image of Montreal:</p>
<p class="calibre1"><a id="p419"/><b class="calibre3">False color compositions</b></p>
<p class="calibre1">Color compositions are a great tool for information visualization, and we can use it even to see things that would be otherwise invisible to the human eye. </p>
<p class="calibre1">Landsat 8 and other satellites provide data in ranges of the spectrum that are reflected or absorbed more or less by specific objects. For example, vigorous vegetation reflects a lot of near-infrared radiation, so if we are looking for information on vegetation coverage or plant growth, we should consider this band. </p>
<p class="calibre1">Besides the computational analysis of different bands, we are able to visualize them by replacing the red, blue, and green components by other bands. Let’s try it as follows: 1.  Just edit the if __name__ == '__main__': block, so we use the near infrared (band 5) as the green component of the RGB image:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">base_name = 'LC80140282015270LGN00_B' </p>
<p class="calibre1">bands_numbers = [4, 5, 2]</p>
<p class="calibre1">bands = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat(base_path), </p>
<p class="calibre1">itertools.repeat(base_name), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">dst_image = "../output/color_composition.tif" </p>
<p class="calibre1">create_color_composition(bands, dst_image, </p>
<p class="calibre1">(1385, 5145, 1985, 1195))</p>
<p class="calibre1">2.  Run the code and look at the output image:</p>
<p class="calibre1"><a id="p420"/><img src="img/index-420_1.jpg" alt="Image 76" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-420_2.jpg" alt="Image 77" class="calibre2"/></p>
<p class="calibre1">3.  You can have many other combinations. Just change the band_numbers variables to achieve different results. Try changing it to [6, 5, 2 ]. Run the code and look at how the farm fields stand out from the other features. </p>
<p class="calibre1"><a id="p421"/><b class="calibre3">Note</b></p>
<p class="calibre1">You can check out more interesting band combinations by clicking on the following links:</p>
<p class="calibre1"><a href="http://landsat.gsfc.nasa.gov/?page_id=5377">http://landsat.gsfc.nasa.gov/?page_id=5377</a></p>
<p class="calibre1"><a href="http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/">http://blogs.esri.com/esri/arcgis/2013/07/24/band-combinations-for-landsat-8/</a></p>
<p class="calibre1"><a id="p422"/>
<a id="p423"/><b class="calibre3">Summary</b></p>
<p class="calibre1">As we did with the points of interest, we managed the problem of excessive computational resource consumption by splitting the load into pieces. Specifically, instead of reading and processing whole images, we created Python iterators that allowed us to iterate through these images one row at a time without hitting the memory limit of the computer. </p>
<p class="calibre1">With this technique, we were able to process three Landsat 8 bands at a time to produce fancy colored images valuable for data visualization. </p>
<p class="calibre1">At this point, we are able to split our processing tasks into pieces that can be processed independently. We can do this with vectors, with database access, and now, with images as well. </p>
<p class="calibre1">With this, we completely paved the road for the next chapter, where we will be sending each of these pieces to be calculated at the same time by a different processor core performing the so-called parallel processing. </p>
<p class="calibre1"><a id="p424"/>
<a id="p425"/><b class="calibre3">Chapter 10. Parallel Processing</b></p>
<p class="calibre1">In this chapter, we will take another step in code optimization; we will experiment with the possibility of using multiple processor cores to perform calculations. </p>
<p class="calibre1">Using the satellite images from the previous chapter, we will use Python’s multiprocessing library to distribute tasks and make them run in parallel. As an example, we will experiment with different techniques to produce true color compositions from Landsat 8</p>
<p class="calibre1">data, with better resolution and a greater level of detail. </p>
<p class="calibre1">To achieve our objects, we will go through these topics:</p>
<p class="calibre1">How multiprocessing works</p>
<p class="calibre1">How to iterate through two-dimensional image blocks</p>
<p class="calibre1">Image resizing and resampling</p>
<p class="calibre1">Parallel processing in image operations</p>
<p class="calibre1">Image pan sharpening</p>
<p class="calibre1"><a id="p426"/><b class="calibre3">Multiprocessing basics</b></p>
<p class="calibre1">The implementation of Python that we are using, CPython, has a mechanism called <b class="calibre3">global</b> <b class="calibre3">interpreter lock</b> (<b class="calibre3">GIL</b>). GIL’s purpose is to make CPython thread-safe; it works by preventing the code from being executed by more than one thread at once. </p>
<p class="calibre1">With that limitation, multiprocessing in Python works by forking the running program (for example, making a copy of the state of the program) and sending it to another computer core. As a consequence, the new process comes with an overhead. </p>
<p class="calibre1">Let’s try a simple code:</p>
<p class="calibre1">1.  First, make a copy of the previous chapter folder in your geopy project and rename it to Chapter10. </p>
<p class="calibre1">2.  Clean the Chapter10/output folder (delete all files in it). </p>
<p class="calibre1">3.  Expand the Chapter10/experiments folder, right-click on it, and create a new Python file. Name it parallel.py. </p>
<p class="calibre1">4.  Add this code to this new file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from datetime import datetime</p>
<p class="calibre1">import multiprocessing as mp</p>
<p class="calibre1">def an_expensive_function(text):</p>
<p class="calibre1">for i in range(500):</p>
<p class="calibre1">out = "{} {} {}" </p>
<p class="calibre1">out.format(text, text, text)</p>
<p class="calibre1">return "dummy output" </p>
<p class="calibre1">This is a simple function that receives text and performs string formatting multiple times. The only purpose of this function is to consume CPU time, so we can test whether we can speed up our code by running parallel processes. </p>
<p class="calibre1">5.  Now, create an if __name__ == '__main__': block at the end of the file so we can test the code and measure its execution time. </p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">texts = []</p>
<p class="calibre1">for t in range(100000):</p>
<p class="calibre1">texts.append('test text')</p>
<p class="calibre1">t1 = datetime.now()</p>
<p class="calibre1">result = map(an_expensive_function, texts)</p>
<p class="calibre1">print("Execution time: {}".format(datetime.now() - t1)) This code makes a list of 100000 strings, then this list is mapped to the function; this means that an_expensive_function is called 100000. Note that here we are using a simpler technique for measuring the execution time for this piece of code; t1 holds the start time and in the end it’s subtracted from the current time. This avoids the</p>
<p class="calibre1"><a id="p427"/>overhead of using a profiler and is also more suitable for what we are going to do than the timeit module. </p>
<p class="calibre1">6.  Run the code and check the result in the console:</p>
<p class="calibre1">Execution time: 0:00:35.667500</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">My computer took approximately 35 seconds to run the function 100,000 times; probably your results will be different. If your computer is much faster, change this number to get an execution time of at least 10 seconds. Take note of your result. </p>
<p class="calibre1">1.  Now edit the if __name__ == '__main__': block so we can execute this code in parallel:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">texts = []</p>
<p class="calibre1">for t in range(100000):</p>
<p class="calibre1">texts.append('test text')</p>
<p class="calibre1">multi = True</p>
<p class="calibre1">t1 = datetime.now()</p>
<p class="calibre1">if multi:</p>
<p class="calibre1">my_pool = mp.Pool(processes=8)</p>
<p class="calibre1">result = my_pool.map(an_expensive_function, texts)</p>
<p class="calibre1">else:</p>
<p class="calibre1">result = map(an_expensive_function, texts)</p>
<p class="calibre1">print("Execution time: {}".format(datetime.now() - t1)) The Pool class represents a pool of worker processes; they stand by, waiting until we submit some jobs to be done. </p>
<p class="calibre1">In order to use all of your processor cores, you need to create the same number as, or more than, the number of cores of your processor. Or, if you don’t want to fully load your computer processor, use fewer processes than the number of cores. This is done by changing the processes argument. </p>
<p class="calibre1">We put the code in an if block so we can easily switch between parallel and single processes. </p>
<p class="calibre1">2.  Run your code and see the difference:</p>
<p class="calibre1">Execution time: 0:00:08.373000</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The code ran approximately four times faster for me. </p>
<p class="calibre1">3.  Now, open your Task Manager, or your system monitor and open the CPU load</p>
<p class="calibre1"><a id="p428"/><img src="img/index-428_1.jpg" alt="Image 78" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-428_2.jpg" alt="Image 79" class="calibre2"/></p>
<p class="calibre1">graphs. </p>
<p class="calibre1">4.  Run the code again, using multi=True, and take a look at the CPU load graph: 5.  Change to multi=False and run it again. Inspect the graph now: Note that when using multiprocessing, all cores were fully occupied for a short period of time. However, when using a single process, some of the cores are partially occupied for a</p>
<p class="calibre1"><a id="p429"/>long time. This pattern may vary according to the computer architecture. </p>
<p class="calibre1"><a id="p430"/>
<a id="p431"/><img src="img/index-431_1.jpg" alt="Image 80" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Block iteration</b></p>
<p class="calibre1">The TIFF format is a versatile image format that can be customized for very diverse needs. The file is composed of a <b class="calibre3">Header</b>, at least one <b class="calibre3">Image File Directory, </b> and any amount of <b class="calibre3">Image Data</b>. Explaining it in a simple way, the header tells where the first directory is on the file. The directory contains information about the image, tells how to read the data related to it, and tells where the next directory is. Each combination of a directory and image data is an image, so a single TIFF file may have multiple images inside it. </p>
<p class="calibre1">Each image data (a whole image) contains blocks of data (that is, parts of the image) that can be read separately, each one representing a specific region of the image. This allows the user to read the image by chunks, just like we did. </p>
<p class="calibre1">The blocks of data are indivisible; in order to return data from an image, the program that is reading it needs to read at least one whole block. If the desired region is smaller than a block, the whole block will be read anyway, decoded, and cropped; the data will then be returned to the user. </p>
<p class="calibre1">The blocks of data can be in strips or in tiles. Strips contain data for an entire image row and may be one row or more in length. Tiles have width and length (which must be a multiple of 16) and are interesting because they allow us to retrieve specific regions with no need to read entire rows. </p>
<p class="calibre1">In our previous examples, we programmed a function that was able to read images one row at a time; now we will improve that function in order to read blocks of any size. This will allow us to make fancier stuff with the images in the upcoming topics. </p>
<p class="calibre1">This time, we will take a different approach to how we iterate the image. </p>
<p class="calibre1"><a id="p432"/>1.  Inside your Chapter10/experiments folder, create a new file named block_generator.py. </p>
<p class="calibre1">2.  Edit this file and insert the following code:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">import os</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">from osgeo import gdal, gdal_array</p>
<p class="calibre1">def create_blocks_list(crop_region, block_shape):</p>
<p class="calibre1">"""Creates a list of block reading coordinates. </p>
<p class="calibre1">:param crop_region: Offsets and shape of the region of interest. </p>
<p class="calibre1">(xoff, yoff, xsize, ysize)</p>
<p class="calibre1">:param block_shape: Width and height of each block. </p>
<p class="calibre1">""" </p>
<p class="calibre1">img_columns = crop_region[2]</p>
<p class="calibre1">img_rows = crop_region[3]</p>
<p class="calibre1">blk_width = block_shape[0]</p>
<p class="calibre1">blk_height = block_shape[1]</p>
<p class="calibre1"># Get the number of blocks. </p>
<p class="calibre1">x_blocks = int((img_columns + blk_width - 1) / blk_width)</p>
<p class="calibre1">y_blocks = int((img_rows + blk_height - 1) / blk_height)</p>
<p class="calibre1">print("Creating blocks list with {} blocks ({} x {}).".format(</p>
<p class="calibre1">x_blocks * y_blocks, x_blocks, y_blocks))</p>
<p class="calibre1">blocks = []</p>
<p class="calibre1">for block_column in range(0, x_blocks):</p>
<p class="calibre1"># Recalculate the shape of the rightmost block. </p>
<p class="calibre1">if block_column == x_blocks - 1:</p>
<p class="calibre1">valid_x = img_columns - block_column * blk_width</p>
<p class="calibre1">else:</p>
<p class="calibre1">valid_x = blk_width</p>
<p class="calibre1">xoff = block_column * blk_width + crop_region[0]</p>
<p class="calibre1"># loop through Y lines</p>
<p class="calibre1">for block_row in range(0, y_blocks):</p>
<p class="calibre1"># Recalculate the shape of the final block. </p>
<p class="calibre1">if block_row == y_blocks - 1:</p>
<p class="calibre1">valid_y = img_rows - block_row * blk_height</p>
<p class="calibre1">else:</p>
<p class="calibre1">valid_y = blk_height</p>
<p class="calibre1">yoff = block_row * blk_height + crop_region[1]</p>
<p class="calibre1">blocks.append((xoff, yoff, valid_x, valid_y))</p>
<p class="calibre1">return blocks</p>
<p class="calibre1">3.  Before some explanation, let’s see this function working. Add the if __name__ ==</p>
<p class="calibre1">'__main__': block at the end of the file with this code:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">blocks_list = create_blocks_list((0, 0, 1024, 1024), (32, 32)) pprint(blocks_list)</p>
<p class="calibre1">4.  Run the code. Since we are running a different file from before, remember to press <i class="calibre4">Alt</i> +  <i class="calibre4">Shift</i> +  <i class="calibre4">F10</i> to select the file to run. Check the output:</p>
<p class="calibre1"><a id="p433"/>Creating blocks list with 1024 blocks (32 x 32). </p>
<p class="calibre1">[(0, 0, 32, 32), </p>
<p class="calibre1">(0, 32, 32, 32), </p>
<p class="calibre1">(0, 64, 32, 32), </p>
<p class="calibre1">(0, 96, 32, 32), </p>
<p class="calibre1">(0, 128, 32, 32), </p>
<p class="calibre1">(0, 160, 32, 32), </p>
<p class="calibre1">(0, 192, 32, 32), </p>
<p class="calibre1">... </p>
<p class="calibre1">(992, 928, 32, 32), </p>
<p class="calibre1">(992, 960, 32, 32), </p>
<p class="calibre1">(992, 992, 32, 32)]</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">The sole purpose of this function is to create a list of block coordinates and dimensions; each item on the list contains the offset and the size of a block. We need the size because the blocks on the edges may be smaller than the desired size. </p>
<p class="calibre1">The intention of this design choice, instead of iterating through an image directly, was to hide this low-level functionality. This function is extensive and unintuitive; we don’t want it mixed with higher-level code, making our programs much cleaner. As a bonus, we may gain a little speed when iterating multiple images because the list only needs to be produced once. </p>
<p class="calibre1">1.  Now, let’s adapt the function to copy the image. To use the iteration by blocks, add this code to the file:</p>
<p class="calibre1">def copy_image(src_image, dst_image, block_shape):</p>
<p class="calibre1">try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1">src_dataset = gdal.Open(src_image)</p>
<p class="calibre1">cols = src_dataset.RasterXSize</p>
<p class="calibre1">rows = src_dataset.RasterYSize</p>
<p class="calibre1">driver = gdal.GetDriverByName('GTiff')</p>
<p class="calibre1">new_dataset = driver.Create(dst_image, cols, rows, </p>
<p class="calibre1">eType=gdal.GDT_UInt16)</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(src_dataset, new_dataset)</p>
<p class="calibre1">band = new_dataset.GetRasterBand(1)</p>
<p class="calibre1">blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks = len(blocks_list)</p>
<p class="calibre1">for index, block in enumerate(blocks_list, 1):</p>
<p class="calibre1">if index % 10 == 0:</p>
<p class="calibre1">print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)</p>
<p class="calibre1">band.WriteArray(block_data, block[0], block[1])</p>
<p class="calibre1"><a id="p434"/>2.  Edit the if __name__ == '__main__': block to test the code (we are also going to measure its execution time):</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">img_copy = "../output/B8_copy.tif" </p>
<p class="calibre1">t1 = datetime.now()</p>
<p class="calibre1">copy_image(img_path, img_copy, (1024, 1024))</p>
<p class="calibre1">print("Execution time: {}".format(datetime.now() - t1)) 3.  Now, run it and check the output:</p>
<p class="calibre1">Creating blocks list with 256 blocks (16 x 16). </p>
<p class="calibre1">Copying block 10 of 256. </p>
<p class="calibre1">Copying block 20 of 256…. </p>
<p class="calibre1">Copying block 240 of 256. </p>
<p class="calibre1">Copying block 250 of 256. </p>
<p class="calibre1">Execution time: 0:00:26.656000</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">We used blocks of 1024 by 1024 pixels to copy the image. The first thing to notice is that the process is extremely slow. This happened because we are reading blocks smaller than the size of the blocks in the image, resulting in a lot of reading and writing overhead. </p>
<p class="calibre1">So, let’s adapt our function in order to detect the block size and optimize the reading. </p>
<p class="calibre1">4.  Edit the copy_image function:</p>
<p class="calibre1"><b class="calibre3">def copy_image(src_image, dst_image, block_width=None, </b></p>
<p class="calibre1"><b class="calibre3">               block_height=None):</b></p>
<p class="calibre1">try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1">src_dataset = gdal.Open(src_image)</p>
<p class="calibre1">cols = src_dataset.RasterXSize</p>
<p class="calibre1">rows = src_dataset.RasterYSize</p>
<p class="calibre1"><b class="calibre3">    src_band = src_dataset.GetRasterBand(1)</b></p>
<p class="calibre1"><b class="calibre3">    src_block_size = src_band.GetBlockSize()</b></p>
<p class="calibre1"><b class="calibre3">    print("Image shape {}x{}px. Block shape {}x{}px.").format(</b></p>
<p class="calibre1"><b class="calibre3">        cols, rows, *src_block_size)</b></p>
<p class="calibre1"><b class="calibre3">    block_shape = (block_width or src_block_size[0], </b></p>
<p class="calibre1"><b class="calibre3">                   block_height or src_block_size[1])</b></p>
<p class="calibre1">driver = gdal.GetDriverByName('GTiff')</p>
<p class="calibre1">new_dataset = driver.Create(dst_image, cols, rows, </p>
<p class="calibre1">eType=gdal.GDT_UInt16)</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(src_dataset, new_dataset)</p>
<p class="calibre1"><a id="p435"/>    band = new_dataset.GetRasterBand(1)</p>
<p class="calibre1">blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) n_blocks = len(blocks_list)</p>
<p class="calibre1">for index, block in enumerate(blocks_list, 1):</p>
<p class="calibre1">if index % 10 == 0:</p>
<p class="calibre1">print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)</p>
<p class="calibre1">band.WriteArray(block_data, block[0], block[1])</p>
<p class="calibre1">We separated the block shape arguments into width and height, and made them optional. Then we got the size (shape) of the block that is defined in the image. If the block width or height are not passed as arguments, the image values are used instead. </p>
<p class="calibre1">We have a hint that this image is divided in stripes. Remember that when we copied the image one row at a time, it was fast. So, we are going to test reading multiple rows at a time. </p>
<p class="calibre1">5.  Edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">img_copy = "../output/B8_copy.tif" </p>
<p class="calibre1">t1 = datetime.now()</p>
<p class="calibre1">copy_image(img_path, img_copy, block_height=100)</p>
<p class="calibre1">print("Execution time: {}".format(datetime.now() - t1)) 6.  Run the code and see the difference:</p>
<p class="calibre1">Image shape 15401x15661px. Block shape 15401x1px. </p>
<p class="calibre1">Creating blocks list with 157 blocks (1 x 157). </p>
<p class="calibre1">Copying block 10 of 157. </p>
<p class="calibre1">Copying block 20 of 157. </p>
<p class="calibre1">Copying block 30 of 157…. </p>
<p class="calibre1">Copying block 130 of 157. </p>
<p class="calibre1">Copying block 140 of 157. </p>
<p class="calibre1">Copying block 150 of 157. </p>
<p class="calibre1">Execution time: 0:00:02.083000</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">It’s confirmed that, for Landsat 8 images, each block is one row of the image. And by reading whole lines, we achieved the same level of speed as before. </p>
<p class="calibre1">You can play with the block height parameter; instead of reading 100 lines, try reading 1</p>
<p class="calibre1">or 1,000 lines and see if it has any influence on the execution time. </p>
<p class="calibre1"><a id="p436"/>
<a id="p437"/><b class="calibre3">Improving the image resolution</b></p>
<p class="calibre1">In order to obtain a better image for visual analysis, we can combine different techniques to increase the image resolution. The first one changes the size of the image and recalculates the missing data by interpolation. The second one uses a band of higher resolution (band 8, in our case)—combined with bands in a lower resolution—to produce an improved true color map. </p>
<p class="calibre1"><a id="p438"/><b class="calibre3">Image resampling</b></p>
<p class="calibre1">Image resizing or resampling is a technique to change the size of the image. By doing this we change the number of pixels in it (that is, the number of samples) or vice-versa. </p>
<p class="calibre1">As the size of an image is increased, we need to give a value to pixels that didn’t exist before. This is done by interpolation; the new pixel value is given based on the value of its surrounding pixels. That’s why we needed two-dimensional chunks. </p>
<p class="calibre1">In our first trial, we will resample one 30m-resolution band into a 15m-resolution image. </p>
<p class="calibre1">Since we will perform a lot of tests, let’s start by creating a practical way of viewing and comparing our results. To do that we will crop the image and save it to disk so we can easily visualize the same region. </p>
<p class="calibre1">1.  Edit the imports at the beginning of the file:</p>
<p class="calibre1"># coding=utf-8</p>
<p class="calibre1">from datetime import datetime</p>
<p class="calibre1">import os</p>
<p class="calibre1">import itertools</p>
<p class="calibre1">import numpy as np</p>
<p class="calibre1">from pprint import pprint</p>
<p class="calibre1">import functools</p>
<p class="calibre1">import multiprocessing as mp</p>
<p class="calibre1">from osgeo import gdal, gdal_array</p>
<p class="calibre1">from images import adjust_values, compose_band_path</p>
<p class="calibre1">from images import create_color_composition</p>
<p class="calibre1">import cv2 as cv</p>
<p class="calibre1">2.  Add this new function to your file:</p>
<p class="calibre1">def crop_and_save(image_path, prefix=""):</p>
<p class="calibre1">dataset = gdal.Open(image_path)</p>
<p class="calibre1">array = dataset.ReadAsArray(4209, 11677, 348, 209)</p>
<p class="calibre1">array = adjust_values(array, (10000, 30000))</p>
<p class="calibre1">array = array.astype(np.ubyte)</p>
<p class="calibre1">preview_path, preview_file = os.path.split(image_path)</p>
<p class="calibre1">preview_file = "preview_" + prefix + preview_file cv.imwrite(os.path.join("../output/", preview_file), array) This time we will zoom the image to downtown Montreal, including the Mount Royal and the Old Port. As a reference, the next image is a high-resolution image extracted from Bing maps of our region of interest:</p>
<p class="calibre1"><a id="p439"/><img src="img/index-439_1.jpg" alt="Image 81" class="calibre2"/></p>
<p class="calibre1">3.  Now, add the resampling function to your file:</p>
<p class="calibre1">def resample_image(src_image, dst_image, </p>
<p class="calibre1">block_width=None, block_height=None, factor=2, </p>
<p class="calibre1">interpolation=cv.INTER_LINEAR):</p>
<p class="calibre1">"""Change image resolution by a factor. </p>
<p class="calibre1">:param src_image: Input image. </p>
<p class="calibre1">:param dst_image: Output image. </p>
<p class="calibre1">:param block_width: Width in pixels of the processing blocks. </p>
<p class="calibre1">:param block_height: Height in pixels of the processing blocks. </p>
<p class="calibre1">:param factor: Image size multiplier. </p>
<p class="calibre1">:param interpolation: Interpolation method. </p>
<p class="calibre1">""" </p>
<p class="calibre1">t1 = datetime.now()</p>
<p class="calibre1">print("Start processing -&gt; {}".format(dst_image)) try:</p>
<p class="calibre1">os.remove(dst_image)</p>
<p class="calibre1">except OSError:</p>
<p class="calibre1">pass</p>
<p class="calibre1">src_dataset = gdal.Open(src_image, gdal.GA_ReadOnly)</p>
<p class="calibre1">cols = src_dataset.RasterXSize</p>
<p class="calibre1">rows = src_dataset.RasterYSize</p>
<p class="calibre1">src_band = src_dataset.GetRasterBand(1)</p>
<p class="calibre1">src_block_size = src_band.GetBlockSize()</p>
<p class="calibre1"># print("Image shape {}x{}px. Block shape {}x{}px.").format(</p>
<p class="calibre1">#     cols, rows, *src_block_size)</p>
<p class="calibre1">block_shape = (block_width or src_block_size[0], </p>
<p class="calibre1">block_height or src_block_size[1])</p>
<p class="calibre1"><a id="p440"/>    driver = gdal.GetDriverByName('GTiff') new_dataset = driver.Create(dst_image, cols * factor, </p>
<p class="calibre1">rows * factor, </p>
<p class="calibre1">eType=gdal.GDT_UInt16)</p>
<p class="calibre1">gdal_array.CopyDatasetInfo(src_dataset, new_dataset)</p>
<p class="calibre1">band = new_dataset.GetRasterBand(1)</p>
<p class="calibre1">blocks_list = create_blocks_list((0, 0, cols, rows), block_shape) new_block_shape = (block_shape[0] * factor, </p>
<p class="calibre1">block_shape[1] * factor)</p>
<p class="calibre1">new_blocks_list = create_blocks_list((0, 0, </p>
<p class="calibre1">cols * factor, </p>
<p class="calibre1">rows * factor), </p>
<p class="calibre1">new_block_shape)</p>
<p class="calibre1">n_blocks = len(blocks_list)</p>
<p class="calibre1">for index, (block, new_block) in enumerate(</p>
<p class="calibre1">zip(blocks_list, new_blocks_list), 1):</p>
<p class="calibre1">#if index % 10 == 0:</p>
<p class="calibre1">#    print("Copying block {} of {}.".format(index, n_blocks)) block_data = src_dataset.ReadAsArray(*block)</p>
<p class="calibre1">block_data = cv.resize(block_data, dsize=(0, 0), </p>
<p class="calibre1">fx=factor, fy=factor, </p>
<p class="calibre1">interpolation=interpolation)</p>
<p class="calibre1">band.WriteArray(block_data, new_block[0], new_block[1])</p>
<p class="calibre1">return dst_image, t1</p>
<p class="calibre1">This function creates an output dataset that is scaled by the defined factor. It reads each block from the source image, changes its size by this same factor, and writes it to the output. Note that the size of the output block is also recalculated and scaled by the multiplying factor. The method of interpolation is optional and by default uses linear interpolation. </p>
<p class="calibre1">Instead of just testing this function, let’s generate previews of every possible interpolation method, so we can visually compare it and see which one returns the best result. Since we will do this using multiprocessing, we also need a callback function so we can time the execution of each job. </p>
<p class="calibre1">4.  Add this function to your file:</p>
<p class="calibre1">def processing_callback(args):</p>
<p class="calibre1">t2 = datetime.now() - args[1]</p>
<p class="calibre1">print("Done processing {}. {}".format(args[0], t2)) 5.  Finally, edit the if __name__ == '__main__': block:</p>
<p class="calibre1">if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">img_name = "LC80140282015270LGN00_B4.TIF" </p>
<p class="calibre1">img_path = os.path.join(base_path, img_name)</p>
<p class="calibre1">interpolation_methods = {</p>
<p class="calibre1">"nearest": cv.INTER_NEAREST, </p>
<p class="calibre1">"linear": cv.INTER_LINEAR, </p>
<p class="calibre1">"area": cv.INTER_AREA, </p>
<p class="calibre1"><a id="p441"/>        "bicubic": cv.INTER_CUBIC, </p>
<p class="calibre1">"lanczos": cv.INTER_LANCZOS4}</p>
<p class="calibre1">output_images = []</p>
<p class="calibre1">multi = True</p>
<p class="calibre1">my_pool = mp.Pool(processes=8)</p>
<p class="calibre1">total_t1 = datetime.now()</p>
<p class="calibre1">for name, inter_method in interpolation_methods.iteritems(): out_image = "../output/" + name + '_B4.tif' </p>
<p class="calibre1">output_images.append(out_image)</p>
<p class="calibre1">if multi:</p>
<p class="calibre1">my_pool.apply_async(</p>
<p class="calibre1">resample_image, (img_path, out_image), </p>
<p class="calibre1">{'block_height': 100, </p>
<p class="calibre1">'interpolation': inter_method}, </p>
<p class="calibre1">processing_callback)</p>
<p class="calibre1">else:</p>
<p class="calibre1">result = resample_image(img_path, out_image, </p>
<p class="calibre1">block_height=100, </p>
<p class="calibre1">interpolation=inter_method)</p>
<p class="calibre1">processing_callback(result)</p>
<p class="calibre1">if multi:</p>
<p class="calibre1"># Close the pool, no more jobs. </p>
<p class="calibre1">my_pool.close()</p>
<p class="calibre1"># Wait for all results to be ready. </p>
<p class="calibre1">my_pool.join()</p>
<p class="calibre1">print("Total time: {}".format(datetime.now() - total_t1)) map(crop_and_save, output_images)</p>
<p class="calibre1">Here we used another technique for adding jobs to a queue. With apply_assinc, we added each job one at a time, telling that we wanted the calculations to happen asynchronously. In the end, my_pool.join() make the program wait until all the jobs in the pool are complete. </p>
<p class="calibre1">6.  With multi = True (multiprocessing enabled), run the code and look at the output: Start processing -&gt; ../output/bicubic_B4.tif</p>
<p class="calibre1">Start processing -&gt; ../output/nearest_B4.tif</p>
<p class="calibre1">Start processing -&gt; ../output/lanczos_B4.tif</p>
<p class="calibre1">Start processing -&gt; ../output/linear_B4.tif</p>
<p class="calibre1">Start processing -&gt; ../output/area_B4.tif</p>
<p class="calibre1">Done processing ../output/nearest_B4.tif. 0:00:33.924000</p>
<p class="calibre1">Done processing ../output/area_B4.tif. 0:00:37.263000</p>
<p class="calibre1">Done processing ../output/linear_B4.tif. 0:00:37.700000</p>
<p class="calibre1">Done processing ../output/bicubic_B4.tif. 0:00:39.546000</p>
<p class="calibre1">Done processing ../output/lanczos_B4.tif. 0:00:41.361000</p>
<p class="calibre1">Total time: 0:00:42.264000</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">7.  Now, disable multiprocessing by setting multi = False and run the code again: Start processing -&gt; ../output/bicubic_B4.tif</p>
<p class="calibre1">Done processing ../output/bicubic_B4.tif. 0:00:02.827000</p>
<p class="calibre1">Start processing -&gt; ../output/nearest_B4.tif</p>
<p class="calibre1"><a id="p442"/>Done processing ../output/nearest_B4.tif. 0:00:07.841000</p>
<p class="calibre1">Start processing -&gt; ../output/lanczos_B4.tif</p>
<p class="calibre1">Done processing ../output/lanczos_B4.tif. 0:00:09.729000</p>
<p class="calibre1">Start processing -&gt; ../output/linear_B4.tif</p>
<p class="calibre1">Done processing ../output/linear_B4.tif. 0:00:09.160000</p>
<p class="calibre1">Start processing -&gt; ../output/area_B4.tif</p>
<p class="calibre1">Done processing ../output/area_B4.tif. 0:00:09.939000</p>
<p class="calibre1">Total time: 0:00:39.498000</p>
<p class="calibre1">Process finished with exit code 0</p>
<p class="calibre1">Comparing the output of both of the trials, we see a different pattern of execution. When using multiprocessing, all the processes are started, they take a long time to execute, and finish almost together. When not using multiprocessing, each process starts and finishes before the next one. </p>
<p class="calibre1">On my computer, it took longer to execute the code when using multiprocessing. This happened because our jobs used intense reading and writing and my hard drive was the <b class="calibre3">hardware bottleneck</b> and not the CPU. So, when using multiprocessing we added a lot of extra labor and also enforced concurrent reading and writing of files, reducing the HD</p>
<p class="calibre1">efficiency. </p>
<p class="calibre1">There is no way to overcome hardware bottlenecks when the hardware is used at full capacity. As happened in this example, we needed to write 2.30 GB of resampled image data, so the program will take at least the time needed to write 2.30 GB to disk. </p>
<p class="calibre1">The following screenshot of my task manager was taken during the program execution and illustrates the described situation:</p>
<p class="calibre1"><a id="p443"/><img src="img/index-443_1.jpg" alt="Image 82" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-443_2.jpg" alt="Image 83" class="calibre2"/></p>
<p class="calibre1">These results may vary from computer to computer, especially if you are using a configuration with more than one storage media, where the IO could also happen in parallel. </p>
<p class="calibre1">Open your output folder and see what we have:</p>
<p class="calibre1">Area interpolation:</p>
<p class="calibre1">Bicubic interpolation:</p>
<p class="calibre1"><a id="p444"/><img src="img/index-444_1.jpg" alt="Image 84" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-444_2.jpg" alt="Image 85" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-444_3.jpg" alt="Image 86" class="calibre2"/></p>
<p class="calibre1">Lanczos interpolation:</p>
<p class="calibre1">Linear interpolation:</p>
<p class="calibre1">Nearest interpolation:</p>
<p class="calibre1"><a id="p445"/><img src="img/index-445_1.jpg" alt="Image 87" class="calibre2"/></p>
<p class="calibre1"><img src="img/index-445_2.jpg" alt="Image 88" class="calibre2"/></p>
<p class="calibre1">And finally, look at band 8, the panchromatic band, with 15m resolution, as a reference:</p>
<p class="calibre1"><a id="p446"/><img src="img/index-446_1.jpg" alt="Image 89" class="calibre2"/></p>
<p class="calibre1"><b class="calibre3">Pan sharpening</b></p>
<p class="calibre1">With the resampling, we were able to produce images with pixels of 15 meters, but we’ve achieved little improvement in the details of the objects in the image. </p>
<p class="calibre1">To overcome this limitation, a technique called <b class="calibre3">pan sharpening</b> can be used to produce color images with a better resolution. The principle is to use the panchromatic band (Landsat band 8) to improve the resolution of the composition. </p>
<p class="calibre1">Here we will use a method that consists of changing the color representation of an image from RGB to HSV—Hue, Saturation, Value. </p>
<p class="calibre1">As can be seen from the image, the value component could be interpreted as the brightness or intensity of the color. So, after the color representation is transformed, the value component can to be replaced with the higher-resolution panchromatic band, resulting in an image with better definition. </p>
<p class="calibre1">To do that, we need to produce a true color composition with the RGB bands, like we did before, but this time with the resampled images. Then we change the color representation, replace the value component, transform the color representation back to RGB, and save the image to disk. </p>
<p class="calibre1">1.  Since we have most of the function ready, start by editing the if __name__ ==</p>
<p class="calibre1">'__main__': block. Remove the older tests and add this code:</p>
<p class="calibre1"><a id="p447"/>if __name__ == '__main__':</p>
<p class="calibre1">base_path = "../../data/landsat/" </p>
<p class="calibre1">base_name = 'LC80140282015270LGN00_B' </p>
<p class="calibre1">bands_numbers = [2, 3, 4]</p>
<p class="calibre1">bands_paths = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat(base_path), </p>
<p class="calibre1">itertools.repeat(base_name), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">output_images = list(itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat("../output/"), </p>
<p class="calibre1">itertools.repeat("15m_B"), </p>
<p class="calibre1">bands_numbers))</p>
<p class="calibre1"># 1) Resample RGB bands. </p>
<p class="calibre1">for source, destination in zip(bands_paths, output_images): resample_image(source, destination, block_height=200)</p>
<p class="calibre1"># 2) Create a true color composition with the resampled bands. </p>
<p class="calibre1"># This image is only for comparison. </p>
<p class="calibre1">create_color_composition(list(output_images), </p>
<p class="calibre1">'../output/preview_resampled_composition.tif', </p>
<p class="calibre1">(4209, 11677, 348, 209))</p>
<p class="calibre1"># 3) Crop all the bands. </p>
<p class="calibre1">output_images.append(</p>
<p class="calibre1">"../../data/landsat/LC80140282015270LGN00_B8.TIF") for source in output_images:</p>
<p class="calibre1">crop_and_save(source)</p>
<p class="calibre1"># 4) Use the cropped images for pan sharpening. </p>
<p class="calibre1">band8 = "../output/preview__LC80140282015270LGN00_B8.TIF" </p>
<p class="calibre1">bgr_bands = itertools.imap(</p>
<p class="calibre1">compose_band_path, </p>
<p class="calibre1">itertools.repeat("../output/"), </p>
<p class="calibre1">itertools.repeat("preview__15m_B"), </p>
<p class="calibre1">bands_numbers)</p>
<p class="calibre1">pan_sharpen(list(bgr_bands), </p>
<p class="calibre1">band8, "../output/pan_sharpened.tif")</p>
<p class="calibre1">The procedure to generate the iterator with the file names is the same as used before. </p>
<p class="calibre1">In Part 1, the resampling of the RGB bands will be made using the default linear interpolation. </p>
<p class="calibre1">In Part 2 we will create a true color composition with the resampled RGB bands. </p>
<p class="calibre1">We won’t use this image to perform the pan sharpening; we are creating it only to compare the results. </p>
<p class="calibre1">We crop all the bands in Part 3. By doing this, we are also adjusting the values of the grayscale from 16 bits to 8 bits. Finally, the pan sharpening is performed in Part 4. </p>
<p class="calibre1"><a id="p448"/><img src="img/index-448_1.jpg" alt="Image 90" class="calibre2"/></p>
<p class="calibre1">2.  Now add the pan_sharpen function to your file:</p>
<p class="calibre1">def pan_sharpen(bgr_bands, pan_band, out_img):</p>
<p class="calibre1">bgr_arrays = []</p>
<p class="calibre1"># Read the images into Numpy arrays. </p>
<p class="calibre1">for item in bgr_bands:</p>
<p class="calibre1">array = cv.imread(item, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)</p>
<p class="calibre1">bgr_arrays.append(array)    </p>
<p class="calibre1">pan_array = cv.imread(pan_band, flags=cv.CV_LOAD_IMAGE_GRAYSCALE)</p>
<p class="calibre1"># Create the RGB (BGR) composition and convert it to HSV. </p>
<p class="calibre1">bgr_composition = np.dstack(bgr_arrays)</p>
<p class="calibre1">hsv_composition = cv.cvtColor(bgr_composition, cv.COLOR_BGR2HSV)</p>
<p class="calibre1"># Split the bands and remove the original value component, </p>
<p class="calibre1"># we wont use it. </p>
<p class="calibre1">h, s, v = np.dsplit(hsv_composition, 3)</p>
<p class="calibre1">h, s = np.squeeze(h), np.squeeze(s)</p>
<p class="calibre1">del v</p>
<p class="calibre1"># Use the panchromatic band as the V component. </p>
<p class="calibre1">pan_composition = np.dstack((h, s, pan_array))</p>
<p class="calibre1"># Convert the image back to BGR and write it to the disk. </p>
<p class="calibre1">bgr_composition = cv.cvtColor(pan_composition, cv.COLOR_HSV2BGR) cv.imwrite(out_img, bgr_composition)</p>
<p class="calibre1">The process is simple. The joining and splitting of the bands is done with NumPy’s dstack and dsplit functions. The color conversion is done by the cvtcolor function. Note that OpenCV uses a sequence of BGR bands instead of RGB. </p>
<p class="calibre1">3.  Run the code and open the color compositions in the output folder to see the results. </p>
<p class="calibre1">The resampled composition:</p>
<p class="calibre1">The image with pan sharpening:</p>
<p class="calibre1"><a id="p449"/><img src="img/index-449_1.jpg" alt="Image 91" class="calibre2"/></p>
<p class="calibre1">I would say that we achieved impressive results. The pan sharpened image is very clear and we can easily identify the city’s features on it. </p>
<p class="calibre1"><a id="p450"/>
<a id="p451"/><b class="calibre3">Summary</b></p>
<p class="calibre1">In this chapter, we saw how to distribute jobs into multiple processor cores, allowing the program to use all the available computing power. </p>
<p class="calibre1">Although parallel processing is a great resource, we found in our examples that it’s not applicable for all situations. Specifically, when the bottleneck is not the CPU, multiprocessing may downgrade the program speed. </p>
<p class="calibre1">In the course of our examples, we took low-resolution satellite images and were able to increase their resolution and level of detail through resampling and pan sharpening, obtaining images of much greater value for visual analysis. </p>
<p class="calibre1"><a id="p452"/><b class="calibre3">Index</b></p>
<p class="calibre1"><b class="calibre3">A</b></p>
<p class="calibre1">abstraction / <a href="index_split_000.html#p148">Making data homogeneous</a></p>
<p class="calibre1">about /<a href="index_split_000.html#p148"> The concept of abstraction</a></p>
<p class="calibre1">Advanced Spaceborne Thermal Emission and Reflection Radiometer (ASTER) /</p>
<p class="calibre1"><a href="index_split_002.html#p286">Processing remote sensing images and data</a></p>
<p class="calibre1">alpha blending / <a href="index_split_002.html#p336">Blending images</a></p>
<p class="calibre1">app</p>
<p class="calibre1">integrating with /<a href="index_split_001.html#p221"> Integrating with the app</a></p>
<p class="calibre1">area of all countries</p>
<p class="calibre1"><a href="index_split_000.html#p92">calculating / Transforming the coordinate system and calculating the area of all</a></p>
<p class="calibre1"><a href="index_split_000.html#p92">countries</a></p>
<p class="calibre1">attributes and relations</p>
<p class="calibre1">filtering by / <a href="index_split_001.html#p212">Filtering by attributes and relations</a></p>
<p class="calibre1">attributes values</p>
<p class="calibre1">obtaining / <a href="index_split_001.html#p191">Getting the attributes’ values</a></p>
<p class="calibre1"><a id="p453"/><b class="calibre3">B</b></p>
<p class="calibre1">bands /<a href="index_split_002.html#p286"> Processing remote sensing images and data</a></p>
<p class="calibre1">basic statistics, raster data</p>
<p class="calibre1">about /<a href="index_split_002.html#p312"> Getting the basic statistics</a></p>
<p class="calibre1">data, preparing / <a href="index_split_002.html#p312">Preparing the data</a></p>
<p class="calibre1">simple information, printing /<a href="index_split_002.html#p312"> Printing simple information</a></p>
<p class="calibre1">output information, formatting / <a href="index_split_002.html#p312">Formatting the output information</a></p>
<p class="calibre1">quartiles, calculating / <a href="index_split_002.html#p312">Calculating quartiles, histograms, and other statistics</a></p>
<p class="calibre1">histograms, calculating /<a href="index_split_002.html#p312"> Calculating quartiles, histograms, and other statistics</a></p>
<p class="calibre1"><a href="index_split_002.html#p312">other statistics, calculating / Calculating quartiles, histograms, and other</a></p>
<p class="calibre1"><a href="index_split_002.html#p312">statistics</a></p>
<p class="calibre1">making, lazy property /<a href="index_split_002.html#p312"> Making statistics a lazy property</a></p>
<p class="calibre1">block iteration</p>
<p class="calibre1">about /<a href="#p430"> Block iteration</a></p>
<p class="calibre1">book project</p>
<p class="calibre1">creating / <a href="index_split_000.html#p84">Creating the book project</a></p>
<p class="calibre1"><a id="p454"/><b class="calibre3">C</b></p>
<p class="calibre1">closest point</p>
<p class="calibre1">searching / <a href="index_split_000.html#p134">Finding the closest point</a></p>
<p class="calibre1">code comments</p>
<p class="calibre1">about /<a href="index_split_000.html#p103"> Documenting your code</a></p>
<p class="calibre1">code profiling</p>
<p class="calibre1">about /<a href="index_split_002.html#p354"> Code profiling</a></p>
<p class="calibre1">color classified images</p>
<p class="calibre1">creating / <a href="index_split_002.html#p325">Creating color classified images</a></p>
<p class="calibre1">right colors, selecting for map / <a href="index_split_002.html#p325">Choosing the right colors for a map</a></p>
<p class="calibre1">context manager /<a href="index_split_000.html#p112"> Downloading data from a URL</a></p>
<p class="calibre1">coordinate system</p>
<p class="calibre1"><a href="index_split_000.html#p92">transforming / Transforming the coordinate system and calculating the area of</a></p>
<p class="calibre1"><a href="index_split_000.html#p92">all countries</a></p>
<p class="calibre1">countries</p>
<p class="calibre1">sorting, by area size / <a href="index_split_000.html#p98">Sort the countries by area size</a></p>
<p class="calibre1">current location</p>
<p class="calibre1">setting / <a href="index_split_000.html#p130">Setting your current location</a></p>
<p class="calibre1"><a id="p455"/><b class="calibre3">D</b></p>
<p class="calibre1">data</p>
<p class="calibre1">making homogeneous /<a href="index_split_000.html#p148"> Making data homogeneous</a></p>
<p class="calibre1">importing /<a href="index_split_002.html#p356"> Generating the tables and importing data</a></p>
<p class="calibre1">filtering / <a href="index_split_002.html#p356">Filtering the data</a></p>
<p class="calibre1">searching for /<a href="#p385"> Searching for data and crossing information</a></p>
<p class="calibre1">filtering, boundaries used /<a href="#p385"> Filtering using boundaries</a></p>
<p class="calibre1">database</p>
<p class="calibre1">information, storing on / <a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1">populating, with real data / <a href="#p368">Populating the database with real data</a></p>
<p class="calibre1">database inserts</p>
<p class="calibre1">optimizing / <a href="#p368">Optimizing database inserts</a></p>
<p class="calibre1">data parsing</p>
<p class="calibre1">optimizing / <a href="#p368">Optimizing data parsing</a></p>
<p class="calibre1">digital elevation models (DEM)</p>
<p class="calibre1">about /<a href="index_split_002.html#p286"> Processing remote sensing images and data</a></p>
<p class="calibre1">reference /<a href="index_split_002.html#p286"> Processing remote sensing images and data</a></p>
<p class="calibre1">docstrings</p>
<p class="calibre1">about /<a href="index_split_000.html#p103"> Documenting your code</a></p>
<p class="calibre1"><a id="p456"/><b class="calibre3">E</b></p>
<p class="calibre1">ElementTree / <a href="#p368">Populating the database with real data</a></p>
<p class="calibre1">ESRI shapefile / <a href="index_split_000.html#p142">Representing geographic data</a></p>
<p class="calibre1">execution time</p>
<p class="calibre1">measuring /<a href="index_split_002.html#p347"> Measuring execution time</a></p>
<p class="calibre1"><a id="p457"/><b class="calibre3">F</b></p>
<p class="calibre1">file</p>
<p class="calibre1">opening / <a href="index_split_000.html#p122">Opening the file and getting its contents</a></p>
<p class="calibre1">contents, obtaining /<a href="index_split_000.html#p122"> Opening the file and getting its contents</a></p>
<p class="calibre1">content, preparing for analysis / <a href="index_split_000.html#p122">Preparing the content for analysis</a></p>
<p class="calibre1">filters</p>
<p class="calibre1">chaining /<a href="index_split_001.html#p217"> Chaining filters</a></p>
<p class="calibre1">first example</p>
<p class="calibre1">programming / <a href="index_split_000.html#p88">Programming and running your first example</a></p>
<p class="calibre1">running /<a href="index_split_000.html#p88"> Programming and running your first example</a></p>
<p class="calibre1">function</p>
<p class="calibre1">combining, into application /<a href="index_split_000.html#p126"> Combining functions into an application</a></p>
<p class="calibre1"><a id="p458"/><b class="calibre3">G</b></p>
<p class="calibre1">GDAL</p>
<p class="calibre1">about /<a href="index_split_000.html#p62"> Installing GDAL and OGR</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p62"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p62">Ubuntu Linux</a></p>
<p class="calibre1">geocache point</p>
<p class="calibre1">abstracting / <a href="index_split_000.html#p148">Abstracting the geocache point</a></p>
<p class="calibre1">geocaching app</p>
<p class="calibre1">basic application structure, building /<a href="index_split_000.html#p103"> Building the basic application structure</a></p>
<p class="calibre1">application tree structure, creating / <a href="index_split_000.html#p103">Creating the application tree structure</a></p>
<p class="calibre1">functions /<a href="index_split_000.html#p103"> Functions and methods</a></p>
<p class="calibre1">methods /<a href="index_split_000.html#p103"> Functions and methods</a></p>
<p class="calibre1">code, documenting /<a href="index_split_000.html#p103"> Documenting your code</a></p>
<p class="calibre1">application entry point, creating / <a href="index_split_000.html#p103">Creating the application entry point</a></p>
<p class="calibre1">geocaching data</p>
<p class="calibre1">downloading / <a href="index_split_000.html#p112">Downloading geocaching data</a></p>
<p class="calibre1">direct download / <a href="index_split_000.html#p112">Downloading geocaching data</a></p>
<p class="calibre1">REST API / <a href="index_split_000.html#p112">Downloading geocaching data</a></p>
<p class="calibre1">sources / <a href="index_split_000.html#p112">Geocaching data sources</a></p>
<p class="calibre1">information, fetching from REST API / <a href="index_split_000.html#p112">Fetching information from a REST API</a></p>
<p class="calibre1">downloading, from URL /<a href="index_split_000.html#p112"> Downloading data from a URL</a></p>
<p class="calibre1">downloading manually / <a href="index_split_000.html#p112">Downloading data manually</a></p>
<p class="calibre1">download link /<a href="index_split_000.html#p112"> Downloading data manually</a></p>
<p class="calibre1">abstracting / <a href="index_split_000.html#p148">Abstracting geocaching data</a></p>
<p class="calibre1">importing /<a href="index_split_000.html#p154"> Importing geocaching data</a></p>
<p class="calibre1">GPX attributes, reading / <a href="index_split_000.html#p154">Reading GPX attributes</a></p>
<p class="calibre1">homogeneous data, returning /<a href="index_split_000.html#p154"> Returning the homogeneous data</a></p>
<p class="calibre1">converting, into Geocache objects / <a href="index_split_000.html#p154">Converting the data into Geocache objects</a></p>
<p class="calibre1">multiple sources, merging / <a href="index_split_000.html#p154">Merging multiple sources of data</a></p>
<p class="calibre1">GeoDjango /<a href="index_split_002.html#p356"> Creating an Object Relational Mapping</a></p>
<p class="calibre1">geographic data</p>
<p class="calibre1">representing / <a href="index_split_000.html#p142">Representing geographic data</a></p>
<p class="calibre1">geometries</p>
<p class="calibre1">representing / <a href="index_split_000.html#p142">Representing geometries</a></p>
<p class="calibre1">geometry relationships</p>
<p class="calibre1">about /<a href="index_split_001.html#p203"> Geometry relationships</a></p>
<p class="calibre1">touches /<a href="index_split_001.html#p203"> Touches</a></p>
<p class="calibre1">crosses / <a href="index_split_001.html#p203">Crosses</a></p>
<p class="calibre1">contains /<a href="index_split_001.html#p203"> Contains</a></p>
<p class="calibre1">within /<a href="index_split_001.html#p203"> Within</a></p>
<p class="calibre1">equals or almost equals /<a href="index_split_001.html#p203"> Equals or almost equals</a></p>
<p class="calibre1">intersects / <a href="index_split_001.html#p203">Intersects</a></p>
<p class="calibre1">disjoint / <a href="index_split_001.html#p203">Disjoint</a></p>
<p class="calibre1"><a id="p459"/>geo objects</p>
<p class="calibre1">exporting / <a href="index_split_001.html#p259">Exporting geo objects</a></p>
<p class="calibre1">global interpreter lock (GIL)</p>
<p class="calibre1">pan sharpening /<a href="#p424"> Multiprocessing basics</a></p>
<p class="calibre1">GPX format /<a href="index_split_000.html#p142"> Representing geographic data</a></p>
<p class="calibre1"><a id="p460"/><b class="calibre3">H</b></p>
<p class="calibre1">hardware bottleneck / <a href="#p436">Image resampling</a></p>
<p class="calibre1">hill shading /<a href="index_split_002.html#p286"> Creating a shaded relief image</a></p>
<p class="calibre1">histogram</p>
<p class="calibre1">for colorizing maps /<a href="index_split_002.html#p339"> Using the histogram to colorize the image</a></p>
<p class="calibre1"><a id="p461"/><b class="calibre3">I</b></p>
<p class="calibre1">IDE</p>
<p class="calibre1">about /<a href="index_split_000.html#p80"> Installing an IDE</a></p>
<p class="calibre1">installing /<a href="index_split_000.html#p80"> Installing an IDE</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p80"> Windows</a></p>
<p class="calibre1">installing, on Linux / <a href="index_split_000.html#p80">Linux</a></p>
<p class="calibre1">image compositions</p>
<p class="calibre1">creating / <a href="#p412">Creating image compositions</a></p>
<p class="calibre1">true color compositions / <a href="#p412">True color compositions</a></p>
<p class="calibre1">specific regions, processing /<a href="#p412"> Processing specific regions</a></p>
<p class="calibre1">false color compositions /<a href="#p412"> False color compositions</a></p>
<p class="calibre1">image processing pipeline</p>
<p class="calibre1">building /<a href="index_split_002.html#p300"> Building an image processing pipeline</a></p>
<p class="calibre1">image resolution</p>
<p class="calibre1">improving /<a href="#p436"> Improving the image resolution</a></p>
<p class="calibre1">image resampling /<a href="#p436"> Image resampling</a></p>
<p class="calibre1">pan sharpening /<a href="#p436"> Pan sharpening</a></p>
<p class="calibre1">images</p>
<p class="calibre1">representing / <a href="index_split_002.html#p277">Understanding how images are represented</a></p>
<p class="calibre1">opening, with OpenCV / <a href="index_split_002.html#p277">Opening images with OpenCV</a></p>
<p class="calibre1">numerical types /<a href="index_split_002.html#p277"> Knowing numerical types</a></p>
<p class="calibre1">blending / <a href="index_split_002.html#p336">Blending images</a></p>
<p class="calibre1">memory usage / <a href="#p399">Memory and images</a></p>
<p class="calibre1">processing, by chunks /<a href="#p403"> Processing images in chunks</a></p>
<p class="calibre1">opening, GDAL used / <a href="#p403">Using GDAL to open images</a></p>
<p class="calibre1">iterating through, whole image /<a href="#p403"> Iterating through the whole image</a></p>
<p class="calibre1">iterables /<a href="#p403"> Iterating through the whole image</a></p>
<p class="calibre1">iterator /<a href="#p403"> Iterating through the whole image</a></p>
<p class="calibre1"><a id="p462"/><b class="calibre3">J</b></p>
<p class="calibre1">Java Topology Suite (JTS)</p>
<p class="calibre1">about /<a href="index_split_001.html#p180"> Using Shapely to handle geometries</a></p>
<p class="calibre1">JSON (JavaScript Object Notation) /<a href="index_split_000.html#p142"> Representing geographic data</a></p>
<p class="calibre1"><a id="p463"/><b class="calibre3">L</b></p>
<p class="calibre1">Landsat 8 images</p>
<p class="calibre1">about /<a href="#p392"> Getting Landsat 8 images</a></p>
<p class="calibre1">obtaining / <a href="#p392">Getting Landsat 8 images</a></p>
<p class="calibre1">lazy evaluation /<a href="index_split_002.html#p312"> Making statistics a lazy property</a></p>
<p class="calibre1">lines</p>
<p class="calibre1">importing /<a href="index_split_001.html#p194"> Importing lines</a></p>
<p class="calibre1">Linux</p>
<p class="calibre1">IDE, installing /<a href="index_split_000.html#p80"> Linux</a></p>
<p class="calibre1"><a id="p464"/><b class="calibre3">M</b></p>
<p class="calibre1">Map Maker app</p>
<p class="calibre1">creating / <a href="index_split_001.html#p263">Creating the Map Maker app</a></p>
<p class="calibre1">PythonDatasource, using / <a href="index_split_001.html#p263">Using PythonDatasource</a></p>
<p class="calibre1">using, with filtering / <a href="index_split_001.html#p263">Using the app with filtering</a></p>
<p class="calibre1">Mapnik</p>
<p class="calibre1">about /<a href="index_split_000.html#p68"> Installing Mapnik</a>, <a href="index_split_000.html#p68">Windows, </a> <a href="index_split_001.html#p227">Knowing Mapnik</a></p>
<p class="calibre1">installing /<a href="index_split_000.html#p68"> Installing Mapnik</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p68"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p68">Ubuntu Linux</a></p>
<p class="calibre1">experiments, performing with /<a href="index_split_001.html#p227"> Knowing Mapnik</a></p>
<p class="calibre1">map, making with pure Python / <a href="index_split_001.html#p227">Making a map with pure Python</a></p>
<p class="calibre1">map, making with style sheet / <a href="index_split_001.html#p227">Making a map with a style sheet</a></p>
<p class="calibre1">maps</p>
<p class="calibre1">styling / <a href="index_split_001.html#p241">Styling maps</a></p>
<p class="calibre1">style options / <a href="index_split_001.html#p241">Styling maps</a></p>
<p class="calibre1">layers, adding /<a href="index_split_001.html#p241"> Adding layers to the map</a></p>
<p class="calibre1">massive data</p>
<p class="calibre1">importing /<a href="#p368"> Importing massive amount of data</a></p>
<p class="calibre1">memoization / <a href="index_split_002.html#p312">Making statistics a lazy property</a></p>
<p class="calibre1">memorization / <a href="index_split_001.html#p198">Converting the spatial reference system and units</a></p>
<p class="calibre1">mosaicking /<a href="index_split_002.html#p286"> Mosaicking images</a></p>
<p class="calibre1">multiple attributes</p>
<p class="calibre1">filtering by / <a href="index_split_001.html#p217">Filtering by multiple attributes</a></p>
<p class="calibre1">multiprocessing</p>
<p class="calibre1">basics / <a href="#p424">Multiprocessing basics</a></p>
<p class="calibre1">about /<a href="#p424"> Multiprocessing basics</a></p>
<p class="calibre1"><a id="p465"/><b class="calibre3">N</b></p>
<p class="calibre1">new functionality</p>
<p class="calibre1">integrating, into application /<a href="index_split_001.html#p169"> Integrating new functionality into the application</a></p>
<p class="calibre1">Noun Project</p>
<p class="calibre1">reference /<a href="index_split_001.html#p241"> Point styles</a></p>
<p class="calibre1">Numpy</p>
<p class="calibre1">about /<a href="index_split_000.html#p58"> Installing NumPy</a></p>
<p class="calibre1">installing /<a href="index_split_000.html#p58"> Installing NumPy</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p58"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p58">Ubuntu Linux</a></p>
<p class="calibre1">Numpy documentation</p>
<p class="calibre1">reference /<a href="index_split_002.html#p286"> Mosaicking images</a></p>
<p class="calibre1"><a id="p466"/><b class="calibre3">O</b></p>
<p class="calibre1">Object Relational Mapping (ORM)</p>
<p class="calibre1">creating / <a href="index_split_002.html#p356">Creating an Object Relational Mapping</a></p>
<p class="calibre1">environment, preparing / <a href="index_split_002.html#p356">Preparing the environment</a></p>
<p class="calibre1">models, changing /<a href="index_split_002.html#p356"> Changing our models</a></p>
<p class="calibre1">manager, customizing / <a href="index_split_002.html#p356">Customizing a manager</a></p>
<p class="calibre1">OGR drivers</p>
<p class="calibre1">about /<a href="index_split_000.html#p62"> Installing GDAL and OGR</a></p>
<p class="calibre1">Opencaching Nodes /<a href="index_split_000.html#p112"> Geocaching data sources</a></p>
<p class="calibre1">Open Computer Vision (OpenCV) package / <a href="index_split_001.html#p234">Automatically previewing the map</a></p>
<p class="calibre1">OpenCV</p>
<p class="calibre1">about /<a href="index_split_000.html#p53"> OpenCV</a></p>
<p class="calibre1">Open Geospatial Consortium (OGC)</p>
<p class="calibre1">about /<a href="index_split_001.html#p174"> Knowing well-known text</a></p>
<p class="calibre1">OpenStreetMap / <a href="index_split_000.html#p142">Representing geometries</a></p>
<p class="calibre1">OpenStreetMap points of interest</p>
<p class="calibre1">importing /<a href="#p368"> Importing OpenStreetMap points of interest</a></p>
<p class="calibre1">OpenStreetMap wiki</p>
<p class="calibre1">URL / <a href="#p385">Searching for data and crossing information</a></p>
<p class="calibre1">Operational Land Imager (OLI) / <a href="#p392">Working with satellite images</a></p>
<p class="calibre1">other packages</p>
<p class="calibre1">installing, from pip /<a href="index_split_000.html#p76"> Installing other packages directly from pip</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p76"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p76">Ubuntu Linux</a></p>
<p class="calibre1">Overpass API /<a href="#p368"> Importing OpenStreetMap points of interest</a></p>
<p class="calibre1"><a id="p467"/><b class="calibre3">P</b></p>
<p class="calibre1">painter model /<a href="index_split_001.html#p241"> Polygon style</a></p>
<p class="calibre1">pan sharpening /<a href="#p436"> Pan sharpening</a></p>
<p class="calibre1">PEP-8</p>
<p class="calibre1"><a href="index_split_000.html#p92">about / Transforming the coordinate system and calculating the area of all</a></p>
<p class="calibre1"><a href="index_split_000.html#p92">countries</a></p>
<p class="calibre1"><a href="index_split_000.html#p92">URL / Transforming the coordinate system and calculating the area of all</a></p>
<p class="calibre1"><a href="index_split_000.html#p92">countries</a></p>
<p class="calibre1">pixel</p>
<p class="calibre1">about /<a href="index_split_002.html#p277"> Understanding how images are represented</a></p>
<p class="calibre1">points of interest (POI) / <a href="#p368">Importing OpenStreetMap points of interest</a></p>
<p class="calibre1">polygons</p>
<p class="calibre1">working with / <a href="index_split_001.html#p174">Working with polygons</a></p>
<p class="calibre1">importing /<a href="index_split_001.html#p183"> Importing polygons</a></p>
<p class="calibre1">Postgis extension /<a href="index_split_002.html#p356"> Storing information on a database</a></p>
<p class="calibre1">PostgreSQL</p>
<p class="calibre1">URL / <a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1">PostgreSQL database /<a href="index_split_002.html#p356"> Storing information on a database</a></p>
<p class="calibre1">Poços de Caldas /<a href="index_split_002.html#p286"> Processing remote sensing images and data</a></p>
<p class="calibre1">processing pipeline /<a href="index_split_002.html#p300"> Building an image processing pipeline</a></p>
<p class="calibre1">profiling /<a href="index_split_002.html#p347"> Measuring execution time</a></p>
<p class="calibre1">Python</p>
<p class="calibre1">installing /<a href="index_split_000.html#p45"> Installing Python</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p45"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p45">Ubuntu Linux</a></p>
<p class="calibre1">Python glossary</p>
<p class="calibre1">reference /<a href="index_split_001.html#p254"> Using Python objects as a source of data</a></p>
<p class="calibre1">Python objects</p>
<p class="calibre1">using, as source of data /<a href="index_split_001.html#p254"> Using Python objects as a source of data</a></p>
<p class="calibre1">Python package</p>
<p class="calibre1">about /<a href="index_split_000.html#p50"> Python packages and package manager</a></p>
<p class="calibre1">package manager / <a href="index_split_000.html#p50">Python packages and package manager</a></p>
<p class="calibre1">repository, for Windows / <a href="index_split_000.html#p50">The repository of Python packages for Windows</a></p>
<p class="calibre1">installing /<a href="index_split_000.html#p53"> Installing packages and required software</a></p>
<p class="calibre1">required software / <a href="index_split_000.html#p53">Installing packages and required software</a></p>
<p class="calibre1">installation, for Windows /<a href="index_split_000.html#p53"> Windows</a></p>
<p class="calibre1">installation, for Ubuntu Linux /<a href="index_split_000.html#p53"> Ubuntu Linux</a></p>
<p class="calibre1"><a id="p468"/><b class="calibre3">R</b></p>
<p class="calibre1">raster data</p>
<p class="calibre1">basic statistics /<a href="index_split_002.html#p312"> Getting the basic statistics</a></p>
<p class="calibre1">RasterData class</p>
<p class="calibre1">creating / <a href="index_split_002.html#p300">Creating a RasterData class</a></p>
<p class="calibre1">relief shading /<a href="index_split_002.html#p286"> Creating a shaded relief image</a></p>
<p class="calibre1">remote sensing images</p>
<p class="calibre1">processing /<a href="index_split_002.html#p286"> Processing remote sensing images and data</a></p>
<p class="calibre1">mosaicking / <a href="index_split_002.html#p286">Mosaicking images</a></p>
<p class="calibre1">values, adjusting /<a href="index_split_002.html#p286"> Adjusting the values of the images</a></p>
<p class="calibre1">cropping / <a href="index_split_002.html#p286">Cropping an image</a></p>
<p class="calibre1">shaded relief image, creating /<a href="index_split_002.html#p286"> Creating a shaded relief image</a></p>
<p class="calibre1">REST (Representational State Transfer) /<a href="index_split_000.html#p112"> Downloading geocaching data</a></p>
<p class="calibre1">reStructuredText</p>
<p class="calibre1">reference /<a href="index_split_000.html#p103"> Documenting your code</a></p>
<p class="calibre1"><a id="p469"/><b class="calibre3">S</b></p>
<p class="calibre1">satellite images</p>
<p class="calibre1">about /<a href="#p392"> Working with satellite images</a></p>
<p class="calibre1">working with / <a href="#p392">Working with satellite images</a></p>
<p class="calibre1">Scalable Vector Graphics (SVG) file /<a href="index_split_001.html#p241"> Point styles</a></p>
<p class="calibre1">Shapely</p>
<p class="calibre1">about /<a href="index_split_000.html#p72"> Installing Shapely, </a><a href="index_split_001.html#p180"> Using Shapely to handle geometries</a></p>
<p class="calibre1">installing, on Windows /<a href="index_split_000.html#p72"> Windows</a></p>
<p class="calibre1">installing, on Ubuntu Linux / <a href="index_split_000.html#p72">Ubuntu Linux</a></p>
<p class="calibre1">for handling geometries /<a href="index_split_001.html#p180"> Using Shapely to handle geometries</a></p>
<p class="calibre1">spaghetti data /<a href="index_split_000.html#p142"> Representing geometries</a></p>
<p class="calibre1">Spatialite extension / <a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1">spatial reference system</p>
<p class="calibre1">units, converting /<a href="index_split_001.html#p198"> Converting the spatial reference system and units</a></p>
<p class="calibre1">SpatiLite /<a href="index_split_000.html#p142"> Representing geographic data</a></p>
<p class="calibre1">SQLite database / <a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1">statistics</p>
<p class="calibre1">showing, with colors / <a href="index_split_002.html#p339">Showing statistics with colors</a></p>
<p class="calibre1">style options, maps</p>
<p class="calibre1">map style /<a href="index_split_001.html#p241"> Map style</a></p>
<p class="calibre1">polygon style /<a href="index_split_001.html#p241"> Polygon style</a></p>
<p class="calibre1">line styles /<a href="index_split_001.html#p241"> Line styles</a></p>
<p class="calibre1">text styles /<a href="index_split_001.html#p241"> Text styles</a></p>
<p class="calibre1">point styles /<a href="index_split_001.html#p241"> Point styles</a></p>
<p class="calibre1">SVG transformations</p>
<p class="calibre1">reference /<a href="index_split_001.html#p241"> Point styles</a></p>
<p class="calibre1"><a id="p470"/><b class="calibre3">T</b></p>
<p class="calibre1">tables</p>
<p class="calibre1">generating /<a href="index_split_002.html#p356"> Generating the tables and importing data</a></p>
<p class="calibre1">test data</p>
<p class="calibre1">removing / <a href="#p368">Removing the test data</a></p>
<p class="calibre1">Thermal Infrared Sensor (TIRS) / <a href="#p392">Working with satellite images</a></p>
<p class="calibre1">TIFF format /<a href="#p430"> Block iteration</a></p>
<p class="calibre1"><a id="p471"/><b class="calibre3">U</b></p>
<p class="calibre1">U.S Geological Survey (USGS) EarthExplorer /<a href="#p392"> Getting Landsat 8 images</a></p>
<p class="calibre1">Ubuntu</p>
<p class="calibre1">URL / <a href="index_split_002.html#p356">Storing information on a database</a></p>
<p class="calibre1">Ubuntu Linux</p>
<p class="calibre1">Python, installing /<a href="index_split_000.html#p45"> Ubuntu Linux</a></p>
<p class="calibre1">Python package, installing / <a href="index_split_000.html#p53">Ubuntu Linux</a></p>
<p class="calibre1">Numpy, installing / <a href="index_split_000.html#p58">Ubuntu Linux</a></p>
<p class="calibre1">GDAL, installing /<a href="index_split_000.html#p62"> Ubuntu Linux</a></p>
<p class="calibre1">Mapnik, installing /<a href="index_split_000.html#p68"> Ubuntu Linux</a></p>
<p class="calibre1">Shapely, installing /<a href="index_split_000.html#p72"> Ubuntu Linux</a></p>
<p class="calibre1">other packages, installing /<a href="index_split_000.html#p76"> Ubuntu Linux</a></p>
<p class="calibre1">utility functions</p>
<p class="calibre1">creating, for generating maps /<a href="index_split_001.html#p234"> Creating utility functions to generate maps</a></p>
<p class="calibre1">data source, changing at runtime /<a href="index_split_001.html#p234"> Changing the data source at runtime</a></p>
<p class="calibre1">map, previewing automatically /<a href="index_split_001.html#p234"> Automatically previewing the map</a></p>
<p class="calibre1"><a id="p472"/><b class="calibre3">W</b></p>
<p class="calibre1">well-known binary (WKB)</p>
<p class="calibre1">about /<a href="index_split_001.html#p174"> Knowing well-known text</a></p>
<p class="calibre1">well-known text (WKT)</p>
<p class="calibre1">about /<a href="index_split_001.html#p174"> Knowing well-known text</a></p>
<p class="calibre1">Windows</p>
<p class="calibre1">Python, installing /<a href="index_split_000.html#p45"> Windows</a></p>
<p class="calibre1">Python package, installing / <a href="index_split_000.html#p53">Windows</a></p>
<p class="calibre1">Numpy, installing / <a href="index_split_000.html#p58">Windows</a></p>
<p class="calibre1">GDAL, installing /<a href="index_split_000.html#p62"> Windows</a></p>
<p class="calibre1">Mapnik, installing /<a href="index_split_000.html#p68"> Windows</a></p>
<p class="calibre1">Shapely, installing /<a href="index_split_000.html#p72"> Windows</a></p>
<p class="calibre1">other packages, installing /<a href="index_split_000.html#p76"> Windows</a></p>
<p class="calibre1">IDE, installing /<a href="index_split_000.html#p80"> Windows</a></p>
<p class="calibre1"><a id="outline"/></p>


<p class="calibre1">
<h1 class="calibre5" id="calibre_pb_0">Document Outline</h1>
<ul class="calibre6">
<li class="calibre7"><a href="index_split_000.html#p13">Geospatial Development By Example with Python</a></li>
<li class="calibre7"><a href="index_split_000.html#p15">Credits</a></li>
<li class="calibre7"><a href="index_split_000.html#p17">About the Author</a></li>
<li class="calibre7"><a href="index_split_000.html#p19">About the Reviewers</a></li>
<li class="calibre7"><a href="index_split_000.html#p21">www.PacktPub.com</a></li>
<li class="calibre7"><a href="index_split_000.html#p23">Support files, eBooks, discount offers, and more</a></li>
<li class="calibre7"><a href="index_split_000.html#p24">Why subscribe? </a></li>
<li class="calibre7"><a href="index_split_000.html#p25">Free access for Packt account holders</a></li>
<li class="calibre7"><a href="index_split_000.html#p26">Preface</a></li>
<li class="calibre7"><a href="index_split_000.html#p28">What this book covers</a></li>
<li class="calibre7"><a href="index_split_000.html#p30">What you need for this book</a></li>
<li class="calibre7"><a href="index_split_000.html#p32">Who this book is for</a></li>
<li class="calibre7"><a href="index_split_000.html#p34">Conventions</a></li>
<li class="calibre7"><a href="index_split_000.html#p36">Reader feedback</a></li>
<li class="calibre7"><a href="index_split_000.html#p38">Customer support</a></li>
<li class="calibre7"><a href="index_split_000.html#p40">Downloading the example code</a></li>
<li class="calibre7"><a href="index_split_000.html#p41">Downloading the color images of this book</a></li>
<li class="calibre7"><a href="index_split_000.html#p42">Errata</a></li>
<li class="calibre7"><a href="index_split_000.html#p43">Piracy</a></li>
<li class="calibre7"><a href="index_split_000.html#p44">Questions</a></li>
<li class="calibre7"><a href="index_split_000.html#p45">1. Preparing the Work Environment</a></li>
<li class="calibre7"><a href="index_split_000.html#p47">Installing Python</a></li>
<li class="calibre7"><a href="index_split_000.html#p48">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p49">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p50">Python packages and package manager</a></li>
<li class="calibre7"><a href="index_split_000.html#p52">The repository of Python packages for Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p53">Installing packages and required software</a></li>
<li class="calibre7"><a href="index_split_000.html#p55">OpenCV</a></li>
<li class="calibre7"><a href="index_split_000.html#p56">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p57">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p58">Installing NumPy</a></li>
<li class="calibre7"><a href="index_split_000.html#p60">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p61">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p62">Installing GDAL and OGR</a></li>
<li class="calibre7"><a href="index_split_000.html#p66">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p67">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p68">Installing Mapnik</a></li>
<li class="calibre7"><a href="index_split_000.html#p70">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p71">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p72">Installing Shapely</a></li>
<li class="calibre7"><a href="index_split_000.html#p74">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p75">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p76">Installing other packages directly from pip</a></li>
<li class="calibre7"><a href="index_split_000.html#p78">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p79">Ubuntu Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p80">Installing an IDE</a></li>
<li class="calibre7"><a href="index_split_000.html#p82">Windows</a></li>
<li class="calibre7"><a href="index_split_000.html#p83">Linux</a></li>
<li class="calibre7"><a href="index_split_000.html#p84">Creating the book project</a></li>
<li class="calibre7"><a href="index_split_000.html#p88">Programming and running your first example</a></li>
<li class="calibre7"><a href="index_split_000.html#p92">Transforming the coordinate system and calculating the area of all countries</a></li>
<li class="calibre7"><a href="index_split_000.html#p98">Sort the countries by area size</a></li>
<li class="calibre7"><a href="index_split_000.html#p101">Summary</a></li>
<li class="calibre7"><a href="index_split_000.html#p103">2. The Geocaching App</a></li>
<li class="calibre7"><a href="index_split_000.html#p105">Building the basic application structure</a></li>
<li class="calibre7"><a href="index_split_000.html#p106">Creating the application tree structure</a></li>
<li class="calibre7"><a href="index_split_000.html#p107">Functions and methods</a></li>
<li class="calibre7"><a href="index_split_000.html#p108">Documenting your code</a></li>
<li class="calibre7"><a href="index_split_000.html#p109">Creating the application entry point</a></li>
<li class="calibre7"><a href="index_split_000.html#p112">Downloading geocaching data</a></li>
<li class="calibre7"><a href="index_split_000.html#p114">Geocaching data sources</a></li>
<li class="calibre7"><a href="index_split_000.html#p115">Fetching information from a REST API</a></li>
<li class="calibre7"><a href="index_split_000.html#p117">Downloading data from a URL</a></li>
<li class="calibre7"><a href="index_split_000.html#p119">Downloading data manually</a></li>
<li class="calibre7"><a href="index_split_000.html#p122">Opening the file and getting its contents</a></li>
<li class="calibre7"><a href="index_split_000.html#p125">Preparing the content for analysis</a></li>
<li class="calibre7"><a href="index_split_000.html#p126">Combining functions into an application</a></li>
<li class="calibre7"><a href="index_split_000.html#p130">Setting your current location</a></li>
<li class="calibre7"><a href="index_split_000.html#p134">Finding the closest point</a></li>
<li class="calibre7"><a href="index_split_000.html#p140">Summary</a></li>
<li class="calibre7"><a href="index_split_000.html#p142">3. Combining Multiple Data Sources</a></li>
<li class="calibre7"><a href="index_split_000.html#p144">Representing geographic data</a></li>
<li class="calibre7"><a href="index_split_000.html#p146">Representing geometries</a></li>
<li class="calibre7"><a href="index_split_000.html#p148">Making data homogeneous</a></li>
<li class="calibre7"><a href="index_split_000.html#p150">The concept of abstraction</a></li>
<li class="calibre7"><a href="index_split_000.html#p151">Abstracting the geocache point</a></li>
<li class="calibre7"><a href="index_split_000.html#p153">Abstracting geocaching data</a></li>
<li class="calibre7"><a href="index_split_000.html#p154">Importing geocaching data</a></li>
<li class="calibre7"><a href="index_split_000.html#p158">Reading GPX attributes</a></li>
<li class="calibre7"><a href="index_split_001.html#p163">Returning the homogeneous data</a></li>
<li class="calibre7"><a href="index_split_001.html#p165">Converting the data into Geocache objects</a></li>
<li class="calibre7"><a href="index_split_001.html#p167">Merging multiple sources of data</a></li>
<li class="calibre7"><a href="index_split_001.html#p169">Integrating new functionality into the application</a></li>
<li class="calibre7"><a href="index_split_001.html#p172">Summary</a></li>
<li class="calibre7"><a href="index_split_001.html#p174">4. Improving the App Search Capabilities</a></li>
<li class="calibre7"><a href="index_split_001.html#p176">Working with polygons</a></li>
<li class="calibre7"><a href="index_split_001.html#p177">Knowing well-known text</a></li>
<li class="calibre7"><a href="index_split_001.html#p180">Using Shapely to handle geometries</a></li>
<li class="calibre7"><a href="index_split_001.html#p183">Importing polygons</a></li>
<li class="calibre7"><a href="index_split_001.html#p191">Getting the attributes' values</a></li>
<li class="calibre7"><a href="index_split_001.html#p194">Importing lines</a></li>
<li class="calibre7"><a href="index_split_001.html#p198">Converting the spatial reference system and units</a></li>
<li class="calibre7"><a href="index_split_001.html#p203">Geometry relationships</a></li>
<li class="calibre7"><a href="index_split_001.html#p205">Touches</a></li>
<li class="calibre7"><a href="index_split_001.html#p206">Crosses</a></li>
<li class="calibre7"><a href="index_split_001.html#p207">Contains</a></li>
<li class="calibre7"><a href="index_split_001.html#p208">Within</a></li>
<li class="calibre7"><a href="index_split_001.html#p209">Equals or almost equals</a></li>
<li class="calibre7"><a href="index_split_001.html#p210">Intersects</a></li>
<li class="calibre7"><a href="index_split_001.html#p211">Disjoint</a></li>
<li class="calibre7"><a href="index_split_001.html#p212">Filtering by attributes and relations</a></li>
<li class="calibre7"><a href="index_split_001.html#p217">Filtering by multiple attributes</a></li>
<li class="calibre7"><a href="index_split_001.html#p219">Chaining filters</a></li>
<li class="calibre7"><a href="index_split_001.html#p221">Integrating with the app</a></li>
<li class="calibre7"><a href="index_split_001.html#p225">Summary</a></li>
<li class="calibre7"><a href="index_split_001.html#p227">5. Making Maps</a></li>
<li class="calibre7"><a href="index_split_001.html#p229">Knowing Mapnik</a></li>
<li class="calibre7"><a href="index_split_001.html#p230">Making a map with pure Python</a></li>
<li class="calibre7"><a href="index_split_001.html#p232">Making a map with a style sheet</a></li>
<li class="calibre7"><a href="index_split_001.html#p234">Creating utility functions to generate maps</a></li>
<li class="calibre7"><a href="index_split_001.html#p236">Changing the data source at runtime</a></li>
<li class="calibre7"><a href="index_split_001.html#p239">Automatically previewing the map</a></li>
<li class="calibre7"><a href="index_split_001.html#p241">Styling maps</a></li>
<li class="calibre7"><a href="index_split_001.html#p243">Map style</a></li>
<li class="calibre7"><a href="index_split_001.html#p244">Polygon style</a></li>
<li class="calibre7"><a href="index_split_001.html#p246">Line styles</a></li>
<li class="calibre7"><a href="index_split_001.html#p248">Text styles</a></li>
<li class="calibre7"><a href="index_split_001.html#p249">Adding layers to the map</a></li>
<li class="calibre7"><a href="index_split_001.html#p252">Point styles</a></li>
<li class="calibre7"><a href="index_split_001.html#p254">Using Python objects as a source of data</a></li>
<li class="calibre7"><a href="index_split_001.html#p259">Exporting geo objects</a></li>
<li class="calibre7"><a href="index_split_001.html#p263">Creating the Map Maker app</a></li>
<li class="calibre7"><a href="index_split_002.html#p267">Using PythonDatasource</a></li>
<li class="calibre7"><a href="index_split_002.html#p273">Using the app with filtering</a></li>
<li class="calibre7"><a href="index_split_002.html#p275">Summary</a></li>
<li class="calibre7"><a href="index_split_002.html#p277">6. Working with Remote Sensing Images</a></li>
<li class="calibre7"><a href="index_split_002.html#p279">Understanding how images are represented</a></li>
<li class="calibre7"><a href="index_split_002.html#p282">Opening images with OpenCV</a></li>
<li class="calibre7"><a href="index_split_002.html#p284">Knowing numerical types</a></li>
<li class="calibre7"><a href="index_split_002.html#p286">Processing remote sensing images and data</a></li>
<li class="calibre7"><a href="index_split_002.html#p289">Mosaicking images</a></li>
<li class="calibre7"><a href="index_split_002.html#p294">Adjusting the values of the images</a></li>
<li class="calibre7"><a href="index_split_002.html#p296">Cropping an image</a></li>
<li class="calibre7"><a href="index_split_002.html#p298">Creating a shaded relief image</a></li>
<li class="calibre7"><a href="index_split_002.html#p300">Building an image processing pipeline</a></li>
<li class="calibre7"><a href="index_split_002.html#p303">Creating a RasterData class</a></li>
<li class="calibre7"><a href="index_split_002.html#p310">Summary</a></li>
<li class="calibre7"><a href="index_split_002.html#p312">7. Extract Information from Raster Data</a></li>
<li class="calibre7"><a href="index_split_002.html#p314">Getting the basic statistics</a></li>
<li class="calibre7"><a href="index_split_002.html#p316">Preparing the data</a></li>
<li class="calibre7"><a href="index_split_002.html#p317">Printing simple information</a></li>
<li class="calibre7"><a href="index_split_002.html#p319">Formatting the output information</a></li>
<li class="calibre7"><a href="index_split_002.html#p321">Calculating quartiles, histograms, and other statistics</a></li>
<li class="calibre7"><a href="index_split_002.html#p323">Making statistics a lazy property</a></li>
<li class="calibre7"><a href="index_split_002.html#p325">Creating color classified images</a></li>
<li class="calibre7"><a href="index_split_002.html#p329">Choosing the right colors for a map</a></li>
<li class="calibre7"><a href="index_split_002.html#p336">Blending images</a></li>
<li class="calibre7"><a href="index_split_002.html#p339">Showing statistics with colors</a></li>
<li class="calibre7"><a href="index_split_002.html#p342">Using the histogram to colorize the image</a></li>
<li class="calibre7"><a href="index_split_002.html#p345">Summary</a></li>
<li class="calibre7"><a href="index_split_002.html#p347">8. Data Miner App</a></li>
<li class="calibre7"><a href="index_split_002.html#p350">Measuring execution time</a></li>
<li class="calibre7"><a href="index_split_002.html#p354">Code profiling</a></li>
<li class="calibre7"><a href="index_split_002.html#p356">Storing information on a database</a></li>
<li class="calibre7"><a href="index_split_002.html#p358">Creating an Object Relational Mapping</a></li>
<li class="calibre7"><a href="index_split_002.html#p359">Preparing the environment</a></li>
<li class="calibre7"><a href="index_split_002.html#p360">Changing our models</a></li>
<li class="calibre7"><a href="index_split_002.html#p360">Customizing a manager</a></li>
<li class="calibre7"><a href="index_split_002.html#p365">Generating the tables and importing data</a></li>
<li class="calibre7"><a href="index_split_002.html#p367">Filtering the data</a></li>
<li class="calibre7"><a href="index_split_003.html#p368">Importing massive amount of data</a></li>
<li class="calibre7"><a href="index_split_003.html#p370">Optimizing database inserts</a></li>
<li class="calibre7"><a href="index_split_003.html#p373">Optimizing data parsing</a></li>
<li class="calibre7"><a href="index_split_003.html#p376">Importing OpenStreetMap points of interest</a></li>
<li class="calibre7"><a href="index_split_003.html#p380">Removing the test data</a></li>
<li class="calibre7"><a href="index_split_003.html#p381">Populating the database with real data</a></li>
<li class="calibre7"><a href="index_split_003.html#p385">Searching for data and crossing information</a></li>
<li class="calibre7"><a href="index_split_003.html#p388">Filtering using boundaries</a></li>
<li class="calibre7"><a href="index_split_003.html#p390">Summary</a></li>
<li class="calibre7"><a href="index_split_003.html#p392">9. Processing Big Images</a></li>
<li class="calibre7"><a href="index_split_003.html#p394">Working with satellite images</a></li>
<li class="calibre7"><a href="index_split_003.html#p396">Getting Landsat 8 images</a></li>
<li class="calibre7"><a href="index_split_003.html#p399">Memory and images</a></li>
<li class="calibre7"><a href="index_split_003.html#p403">Processing images in chunks</a></li>
<li class="calibre7"><a href="index_split_003.html#p405">Using GDAL to open images</a></li>
<li class="calibre7"><a href="index_split_003.html#p408">Iterating through the whole image</a></li>
<li class="calibre7"><a href="index_split_003.html#p412">Creating image compositions</a></li>
<li class="calibre7"><a href="index_split_003.html#p414">True color compositions</a></li>
<li class="calibre7"><a href="index_split_003.html#p417">Processing specific regions</a></li>
<li class="calibre7"><a href="index_split_003.html#p419">False color compositions</a></li>
<li class="calibre7"><a href="index_split_003.html#p422">Summary</a></li>
<li class="calibre7"><a href="index_split_003.html#p424">10. Parallel Processing</a></li>
<li class="calibre7"><a href="index_split_003.html#p426">Multiprocessing basics</a></li>
<li class="calibre7"><a href="index_split_003.html#p430">Block iteration</a></li>
<li class="calibre7"><a href="index_split_003.html#p436">Improving the image resolution</a></li>
<li class="calibre7"><a href="index_split_003.html#p438">Image resampling</a></li>
<li class="calibre7"><a href="index_split_003.html#p446">Pan sharpening</a></li>
<li class="calibre7"><a href="index_split_003.html#p450">Summary</a></li>
<li class="calibre7"><a href="index_split_003.html#p452">Index</a></li>
</ul></p>
</body></html>