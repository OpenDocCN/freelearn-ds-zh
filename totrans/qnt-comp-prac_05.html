<html><head></head><body>
		<div id="_idContainer367">
			<h1 id="_idParaDest-129"><em class="italic"><a id="_idTextAnchor128"/>Chapter 5</em>: Touring the IBM Quantum<span class="superscript">®</span> Hardware with Qiskit<span class="superscript">®</span> </h1>
			<p>In the previous chapters, we have mainly used built-in and local quantum computer simulators of various forms, but we also connected and ran some of our quantum programs on actual IBM quantum computers. In this chapter, we will take a closer look at these backends, down to the level of actual physical qubits.</p>
			<p>We will take a quick tour of the IBM Quantum® lab by using both IBM Quantum Experience® and Qiskit® to access data about the available hardware. Among these things, we will look at the graphical view of the layout of the quantum chips, some physical aspects of quantum computers such as the T1 and T2 decoherence parameters, some basic and advanced error metrics, the way the available qubits can interact among themselves, and more.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>What are the IBM Quantum® machines?</li>
				<li>Locating the available backends</li>
				<li>Comparing backends</li>
				<li>Finding the least busy backend</li>
				<li>Visualizing the backends</li>
				<li>Exploring a selected backend using Qiskit®</li>
			</ul>
			<p>Throughout this chapter, we will generally use the Bell state program that we have used before, in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, as its ideal results, <img alt="" src="image/Formula_05_001.png"/> and <img alt="" src="image/Formula_05_002.png"/>, are known to us, and we can use them to make comparisons between runs on different machines and different sets of qubits.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
			<p>Before you begin working on the quantum programs in this chapter, make sure that you have completed all the steps in <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>, especially the <em class="italic">Installing your API key and accessing your provider</em> recipe.</p>
			<p>The quantum programs that we discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter05</a>.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>What are the IBM Quantum<span class="superscript">®</span> machines?</h1>
			<p>This section is less of a recipe and rather more of a basic overview of the quantum components and processes <a id="_idIndexMarker268"/>that you will be encountering. If you'd rather jump ahead and start coding right away, then go to the next recipe.</p>
			<p>With Qiskit®, you can <a id="_idIndexMarker269"/>run your quantum programs on two types of quantum computers: <strong class="bold">simulators</strong> and <strong class="bold">IBM Quantum® hardware</strong>. The <a id="_idIndexMarker270"/>simulators run either <em class="italic">locally</em> or in the <em class="italic">cloud</em> on IBM hardware. Generally speaking, running a simulator in the cloud gives you greater power and performance; <strong class="source-inline">ibmq_qasm_simulator</strong> – available online – lets you run fairly deep quantum programs on up to <em class="italic">32 qubits</em>. Your local simulator performance depends on your hardware; remember that simulating a quantum computer gets exponentially harder with each qubit added. </p>
			<p>The actual IBM quantum computer hardware is located in an IBM lab and is accessed through the cloud. There are good reasons for this, so let's walk through this recipe on how to set up and run a quantum computer with the superconducting qubits that IBM Quantum® provides.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Getting ready</h2>
			<p>Superconducting quantum computers are extremely sensitive to noise such as electromagnetic radiation, sound waves, and heat. An isolated environment equipped with cryogenic cooling provides a location with as little disturbance as possible.</p>
			<p>Quantum computers may use so-called <strong class="bold">Josephson junctions</strong> kept at cryogenic temperatures and manipulated by microwave pulses. Ordinary people do not possess this kind of hardware, so, in this book, we will use the freely available IBM quantum computers in the cloud for our quantum programming.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>How to do it...</h2>
			<p>The following <a id="_idIndexMarker271"/>steps are a very high-level description of the process of running your quantum program on an actual IBM quantum computer:</p>
			<ol>
				<li>Write a quantum program in your local Qiskit® environment or on IBM Quantum Experience®.</li>
				<li>Send your program through the cloud to be queued at IBM Quantum®.<p>The IBM cloud® model for quantum computing means that you will not have unrestricted access to the machines. This is a time-share system where everyone gets a some access sort of like a classical time-share system that used to be the norm in the early days of computing. The analogy is not too bad. </p></li>
				<li>Your program now gets <strong class="bold">transpiled</strong> into a program that can run on the machine you have chosen.<p>When you run your quantum program, it gets interpreted by the software, and the fairly complex high-level gate architecture gets transpiled into a basic quantum program that consists of a set of basis gates only: <strong class="source-inline">u1</strong>, <strong class="source-inline">u2</strong>, <strong class="source-inline">u3</strong>, <strong class="source-inline">id</strong>, and <strong class="source-inline">cx</strong>. It turns out that all quantum programs that you write can be expressed using only these gates.</p><p>As a part of the transpiling, your circuit might change size and depth somewhat, as single gates are converted <a id="_idIndexMarker272"/>into sets of gates depending on the backend that you run your program on. Simply speaking, the size of a circuit is the raw number of gates that are used, and the depth is the length of the circuit from left to right, which roughly translates into how many parallel operations the quantum computer has to do to run your program. Your original program structure might have to change to accommodate the physical layout of the chip that you are running on.</p></li>
				<li>The gates of your transpiled program are coded into wave packages.<p>Now that your code has been converted into components that can be run on the chip, these components are translated into microwave packages that can be sent down to the quantum chip. Each gate can be seen as a rotation of the qubit Bloch vector around three axes, and each angle can be coded as a microwave pulse at different frequencies and durations.</p></li>
				<li>The quantum chip is reset.<p>Before we can do any quantum computing on the chip, its qubits need to be reset to their ground states. This is done by sending a specific microwave pulse to each qubit, much like when sending your gates to the qubits, which is described in the next step.</p></li>
				<li>Your coded gates are then sent to the qubits.<p>Each gate is sent to its corresponding qubit as a <em class="italic">wave package</em> on top of a GHz carrier wave tuned exactly to the frequency of the receiving qubit. We now leave behind what is called the <strong class="bold">room temperature electronics</strong> and enter the cryogenic environment. The signal that encodes the gate travels down into the innards of the quantum computer through successively cooler layers, finally reaching the quantum chip at 15 millikelvin – much colder than outer space. By the end of the journey, the wave package finally ends up impinging the qubit through a microwave resonator to change the state of the qubit.</p><p>This is repeated for each gate that you apply to each qubit and is what constitutes running the quantum program on the backend.</p></li>
				<li>The qubit is now read.<p>And by the end of the program, a certain type of wave package interferes with the resonator, and the resulting package interference is then sent back up the stack, through successively warmer layers and then out into the room-temperature electronics.</p><p>The interference is interpreted as a <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong>, and thus the result of your program is registered. At this state, the delicate balance of your resonating qubit has been destroyed – the qubit no longer behaves quantum mechanically and needs to be reset to ground state before we can use it again.</p></li>
			</ol>
			<p>This whole <a id="_idIndexMarker273"/>process is repeated by the number of shots that you have ordered, and all results are stored in the cloud. Finally, your complete run is packaged and sent back to you, if you had the patience to wait, as well as being stored for later retrieval.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>How it works...</h2>
			<p>Most of the steps mentioned earlier are highly automated. You only have to write your quantum programs <a id="_idIndexMarker274"/>and send them off, then IBM Quantum® will do the rest and your qubit measurements are returned as ones or zeros.</p>
			<p>As you can see, there are several steps where you can step in and dictate how things are done, for example, selecting the backend, picking the qubits to use based on qubit parameters, deciding the number of shots to run, and more. In this chapter, we will walk through how to dig out the hardware information and configuration parameters from the IBM Quantum® machines.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>See also</h2>
			<ul>
				<li>For <a id="_idIndexMarker275"/>more information about the IBM Quantum® hardware, see <a href="https://www.research.ibm.com/ibm-q/technology/devices/">https://www.research.ibm.com/ibm-q/technology/devices/</a></li>
				<li>You can also read this article on <em class="italic">Superconducting Qubits and the Physics of Josephson Junctions</em> by John M. Martinis and Kevin Osborne at NIST: <a href="https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf">https://web.physics.ucsb.edu/~martinisgroup/classnotes/finland/LesHouchesJunctionPhysics.pdf</a></li>
				<li>Also, here is a delightful Medium article on <em class="italic">QC – How to build a Quantum Computer with Superconducting Circuit?</em> by Jonathan Hui: <a href="https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd">https://medium.com/@jonathan_hui/qc-how-to-build-a-quantum-computer-with-superconducting-circuit-4c30b1b296cd</a></li>
			</ul>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Locating the available backends</h1>
			<p>In Qiskit®, a backend <a id="_idIndexMarker276"/>represents the system on which you run your quantum program. A <strong class="bold">backend</strong> can be <a id="_idIndexMarker277"/>a simulator, like the local Aer simulator that we have used earlier. If you want to run your quantum programs on real quantum computers instead of on your local simulator, you must identify an IBM Quantum® machine as a backend to use, and then configure your quantum program to use it.</p>
			<p>Let's see the steps of what we'll be doing:</p>
			<ol>
				<li value="1">Start by importing the required classes and methods and load your account information. In this case, we use the IBMQ class, which contains the main hardware-related functions.</li>
				<li>Take a look at the machines that are available to your account. </li>
				<li>Select a generally available backend.</li>
				<li>Create and run a Bell state quantum program on the selected backend.</li>
				<li>Select a simulator backend and run the Bell state quantum program again for comparison.</li>
			</ol>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Getting ready</h2>
			<p>In this recipe, we will use the IBMQ <strong class="source-inline">provider.backends()</strong> method to identify and filter available backends <a id="_idIndexMarker278"/>to run your programs and then use the <strong class="source-inline">provider.get_backend()</strong> method to select the backend. In the example that follows, we will use the <strong class="source-inline">ibmqx2</strong> and <strong class="source-inline">ibmq_qasm_simulator</strong> backends. We will then run a small quantum program on one of the hardware backends, and then on the simulator backend.</p>
			<p>The Python file in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r1_identifying_backends.py</a>.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>How to do it...</h2>
			<ol>
				<li value="1">As always, we start by importing the Qiskit® classes and methods to use:<p class="source-code">from qiskit import IBMQ, QuantumCircuit, execute</p><p class="source-code">from qiskit.tools.monitor import job_monitor</p></li>
				<li>Before you can start using the <strong class="source-inline">IBMQ</strong> class and the backend methods (if not already set), you must set the provider that is associated with your account:<p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>The <strong class="source-inline">provider.backends()</strong> method is used to locate the IBM Quantum® backends that are available to your IBM Quantum® account. With that information, you can later set the backend that you want to run your quantum program on by using the <strong class="source-inline">provider.get_backend()</strong> method:<p class="source-code">print(provider.backends(operational=True, </p><p class="source-code">    simulator=False))</p></li>
				<li>The preceding code might give an output similar to the following:<p class="source-code">Available backends:</p><p class="source-code">[&lt;IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_16_melbourne') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_vigo') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_valencia') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_london') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_burlington') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_essex') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_armonk') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_santiago') from IBMQ(hub='ibm-q', group='open', project='main')&gt;] </p><p class="callout-heading">The IBM Quantum® simulator</p><p class="callout">See how the list also includes a simulator. This simulator runs on powerful IBM hardware and will be able to manage both more qubits and more complex quantum programs than both your local simulator and the IBM Quantum® backends that you have access to.</p><p>We are <a id="_idIndexMarker279"/>using filtering here to get only the backends that we are interested in. For example, as we are only interested in physical machines, we will filter by the <strong class="source-inline">simulator</strong> parameter: </p><p class="source-code">&gt;&gt;&gt; provider.backends(simulator=False)</p><p>Alternatively, you can use complex filtering such as lambda functions:</p><p class="source-code">&gt;&gt;&gt; provider.backends(filters=lambda x: not x.configuration().simulator)</p><p>We are also only interested in backends that are not down for maintenance. To do this, we filter by the <strong class="source-inline">operational</strong> parameter:</p><p class="source-code">&gt;&gt;&gt; provider.backends(operational=True, simulator=False)</p><p>Or else, you can use the following code:</p><p class="source-code">&gt;&gt;&gt; provider.backends(filters=lambda x: not x.configuration().simulator and x.status().operational)</p></li>
				<li>So, with this in mind, when you want to run your quantum program on an IBM Quantum® machine, you need to specify the backend to run on, and for this, you can use the <strong class="source-inline">get_backend()</strong> method. Let's manually select a backend from our previous list, for example, <strong class="source-inline">ibmqx2</strong>:<p class="source-code">backend = provider.get_backend('ibmqx2')</p><p class="source-code">print("\nSelected backend:", backend.name())</p></li>
				<li>The preceding code should give the following result:<p class="source-code">Out[]: Selected backend: ibmqx2</p></li>
				<li>Now, with a backend selected, you can execute jobs on the backend with the command <strong class="source-inline">job = execute(&lt;your_quantum_circuit&gt;, backend)</strong>. In this case, we will use the following command:<p class="source-code">job = execute(qc, backend, shots=1000)</p></li>
				<li>We <a id="_idIndexMarker280"/>can now create the circuit to test:<p class="source-code">qc = QuantumCircuit(2,2)</p><p class="source-code">qc.h(0)</p><p class="source-code">qc.cx(0,1)</p><p class="source-code">qc.measure([0,1],[0,1])</p><p class="source-code">print("\nQuantum circuit:")</p><p class="source-code">print(qc)</p><p class="source-code">job = execute(qc, backend, shots=1000)</p><p class="source-code">job_monitor(job)</p><p class="source-code">result = job.result()</p><p class="source-code">counts = result.get_counts(qc)</p><p class="source-code">print("\nResults:", counts)</p></li>
				<li>The sample code should give a result similar to this:<div class="IMG---Figure" id="_idContainer341"><img alt="Figure 5.1 – Output of the Bell quantum circuit on the selected backend" src="image/Figure_5.1_B14436.jpg"/></div><p class="figure-caption">Figure 5.1 – Output of the Bell quantum circuit on the selected backend</p></li>
				<li>To select <a id="_idIndexMarker281"/>the IBM Quantum® simulator as the backend, and run the circuit on that one, you can do the following:<p class="source-code">print(provider.backends(operational=True,</p><p class="source-code">    simulator=True))</p><p class="source-code">backend = provider.get_backend('ibmq_qasm_simulator')</p><p class="source-code">job = execute(qc, backend, shots=1000)</p><p class="source-code">job_monitor(job)</p><p class="source-code">result = job.result()</p><p class="source-code">counts = result.get_counts(qc)</p><p class="source-code">print("\nSimulator results:", counts)</p></li>
				<li>The preceding code should give the following result:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer342">
					<img alt="Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator backend" src="image/Figure_5.2_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Output of the Bell quantum circuit on the ibmq_qasm_simulator backend</p>
			<p>So, we have now identified the IBM Quantum® backends that are available to us and run a quantum program on a backend that we selected, and on a simulator backend. In the next recipe, <em class="italic">Comparing backends</em>, we will do a simple performance comparison of the available backends.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>There's more…</h2>
			<p>You can also use the <strong class="source-inline">backends()</strong> method to look at the simulator backends that you have at your disposal on your locally installed Qiskit® environment. First, start by importing the <strong class="source-inline">Aer</strong> simulator class and then use the <strong class="source-inline">backends()</strong> method to take a look at the available backends:</p>
			<p class="source-code">from qiskit import Aer</p>
			<p class="source-code">Aer.backends()</p>
			<p>The preceding <a id="_idIndexMarker282"/>code should give the following result:</p>
			<p class="source-code">Out[]: [&lt;QasmSimulator('qasm_simulator') from AerProvider()&gt;,</p>
			<p class="source-code"> &lt;StatevectorSimulator('statevector_simulator') from </p>
			<p class="source-code"> AerProvider()&gt;,</p>
			<p class="source-code"> &lt;UnitarySimulator('unitary_simulator') from AerProvider()&gt;,</p>
			<p class="source-code"> &lt;PulseSimulator('pulse_simulator') from AerProvider()&gt;]</p>
			<p>These are all simulators:</p>
			<ul>
				<li><strong class="source-inline">'qasm_simulator'</strong>: This simulator lets you run your quantum programs and get results returned as if you were running on a perfect quantum computer with no errors and no noise.</li>
				<li><strong class="source-inline">'statevector_simulator'</strong>: With this one, you can simulate what the statevector for your qubits looks like throughout your circuit.</li>
				<li><strong class="source-inline">'unitary_simulator'</strong>: This simulator lets you create the unitary matrix for your circuit.</li>
				<li><strong class="source-inline">'pulse_simulator'</strong>: This simulator lets you simulate sending discrete pulses to a qubit.</li>
			</ul>
			<p>We have already seen <strong class="source-inline">'qasm_simulator'</strong> and <strong class="source-inline">'statevector_simulator'</strong> used in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, and we will take a closer look at <strong class="source-inline">'unitary_simulator'</strong> as a part of <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>See also</h2>
			<ul>
				<li>For more <a id="_idIndexMarker283"/>information about the available IBM Quantum® systems: <a href="https://www.ibm.com/quantum-computing/technology/systems/">https://www.ibm.com/quantum-computing/technology/systems/</a>.</li>
				<li>You can also use Python help using <strong class="source-inline">help(IBMQ)</strong> and <strong class="source-inline">help(provider.backends)</strong> to find more information about these Qiskit® methods.</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Comparing backends</h1>
			<p>The IBM Quantum® backends are all slightly different, from the number of qubits to the individual behavior and interaction <a id="_idIndexMarker284"/>between these. Depending on how you write your quantum program, you might want to run the code on a machine with certain characteristics. </p>
			<p>The backend information that is returned by IBMQ is just a plain Python list and you can juggle the returned data with any other list. For example, you can write a Python script that finds the available IBM Quantum® backends, then run a quantum program on each of the backends and compare the results in a diagram that shows a rough measure of the <em class="italic">quality</em> of the backends' qubits.</p>
			<p>In this recipe, we will use a simple Python loop to run a succession of identical Bell-state quantum programs on the available IBM Quantum® backends to get a rough estimate of the performance of the backends.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Getting ready</h2>
			<p>The file required for this recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r2_comparing_backends.py</a>.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>How to do it…</h2>
			<p>Let's take a look at how to compare backends:</p>
			<ol>
				<li value="1">First, we import the required classes and methods. <p>In this case, we use the IBMQ library, which contains the main hardware-related functions. We also import the classes to build quantum circuits, monitor jobs, and display results. And then load the stored account API key and get the provider:</p><p class="source-code">from qiskit import IBMQ, QuantumCircuit, execute</p><p class="source-code">from qiskit.tools.monitor import job_monitor</p><p class="source-code">from qiskit.visualization import plot_histogram</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>Now, we will <a id="_idIndexMarker285"/>create the quantum program for which we know the expected results.<p>For example, a Bell state program, which will give the results <img alt="" src="image/Formula_05_003.png"/> and <img alt="" src="image/Formula_05_004.png"/> only on a perfect quantum computer:</p><p class="source-code">qc = QuantumCircuit(2,2)</p><p class="source-code">qc.h(0)</p><p class="source-code">qc.cx(0,1)</p><p class="source-code">qc.measure([0,1],[0,1])</p></li>
				<li>The preceding code should give the following result:<div class="IMG---Figure" id="_idContainer345"><img alt="Figure 5.3 – A Bell state quantum circuit&#13;&#10;" src="image/Figure_5.3_B14436.jpg"/></div><p class="figure-caption">Figure 5.3 – A Bell state quantum circuit</p></li>
				<li>Now, we will get all available and operational backends, including the IBM Quantum® simulator <a id="_idIndexMarker286"/>to use as a benchmark:<p class="source-code">backends = provider.backends(filters=lambda b:</p><p class="source-code">    b.configuration().n_qubits &gt; 1 and</p><p class="source-code">        b.status().operational)</p><p class="source-code">print("\nAvailable backends:", backends)</p><p class="callout-heading">Filtering out single-qubit backends</p><p class="callout">See how we are using a filter here, to only include backends with more than 1 qubit. The reason for this is that our code requires two operational qubits and the code will fail if we run it on a backend with just one. One of the available IBM Quantum® machines—<strong class="source-inline">ibmq_armonk</strong>—is a quantum computer with just 1 qubit; we do not want to use that one and use the filter to remove it from our list of backends. The purpose of the <strong class="source-inline">ibmq_armonk</strong> backend is to experiment with qubit pulse programming, which is beyond the scope of this book. </p></li>
				<li>The preceding code might give the following result:<p class="source-code">Available backends: [&lt;IBMQSimulator('ibmq_qasm_simulator') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmqx2') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_16_melbourne') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_vigo') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_ourense') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_valencia') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_london') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_burlington') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_essex') from IBMQ(hub='ibm-q', group='open', project='main')&gt;, &lt;IBMQBackend('ibmq_santiago') from IBMQ(hub='ibm-q', group='open', project='main')&gt;]</p></li>
				<li>Then, we will <a id="_idIndexMarker287"/>run the simple quantum program on these backends in order. The resulting counts are stored in a dictionary that we call <strong class="source-inline">counts</strong>:<p class="source-code">counts = {}</p><p class="source-code">for n in range(0, len(backends)):</p><p class="source-code">    print('Run on:', backends[n])</p><p class="source-code">    job = execute(qc, backends[n], shots=1000)</p><p class="source-code">    job_monitor(job)</p><p class="source-code">    result = job.result()</p><p class="source-code">    counts[backends[n].name()] = result.get_counts(qc)</p><p class="callout-heading">Get in line</p><p class="callout">Running four quantum programs on several different machines might take a while, depending on the number of other users actively using the backends, and the number of jobs that are queued up. For example, running this program on eight backends and one simulator might take about an hour on a typical Sunday evening.</p></li>
				<li>The preceding code might give the following result:<p class="source-code">Run on: ibmq_qasm_simulator</p><p class="source-code">Job Status: job has successfully run</p><p class="source-code">Run on: ibmqx2</p><p class="source-code">Job Status: job has successfully run</p><p class="source-code">Run on: ibmq_16_melbourne</p><p class="source-code">Job Status: job has successfully run</p><p class="source-code">...</p><p class="source-code">Run on: ibmq_essex</p><p class="source-code">Job Status: job has successfully run</p><p class="source-code">Run on: ibmq_santiago</p><p class="source-code">Job Status: job has successfully run</p></li>
				<li>Now that <a id="_idIndexMarker288"/>the jobs are running, we can print out and then plot the results using the following code:<p class="source-code">print("\nRaw results:", counts)</p><p class="source-code">#Optionally define the histogram colors.</p><p class="source-code">colors = ['green','darkgreen','red','darkred','orange',</p><p class="source-code">    'yellow','blue','darkblue','purple']</p><p class="source-code">#Plot the counts dictionary values in a histogram, using</p><p class="source-code">#the counts dictionary keys as legend.</p><p class="source-code">display(plot_histogram(list(counts.values()),</p><p class="source-code">    title = "Bell results on all available backends</p><p class="source-code">    legend=list(counts), color = colors[0:len(backends)],</p><p class="source-code">    bar_labels = True)</p></li>
				<li>The preceding code might give the following result:<p class="source-code">Raw results: {'ibmq_qasm_simulator': {'00': 510, '11': 490}, 'ibmqx2': {'00': 434, '01': 77, '10': 39, '11': 450}, 'ibmq_16_melbourne': {'00': 474, '01': 42, '10': 48, '11': 436}, 'ibmq_vigo': {'00': 512, '01': 18, '10': 42, '11': 428}, 'ibmq_ourense': {'00': 494, '01': 26, '10': 19, '11': 461}, 'ibmq_valencia': {'00': 482, '01': 31, '10': 30, '11': 457}, 'ibmq_london': {'00': 463, '01': 48, '10': 39, '11': 450}, 'ibmq_burlington': {'00': 385, '01': 182, '10': 84, '11': 349}, 'ibmq_essex': {'00': 482, '01': 46, '10': 24, '11': 448}, 'ibmq_santiago': {'00': 514, '01': 17, '10': 17, '11': 452}}</p></li>
			</ol>
			<p>These raw results show how well each backend ran the program. The <strong class="source-inline">ibmq-qasm-simulator</strong> represents the ideal results on a simulated universal quantum computer; the other results show how the program ran on actual IBM Quantum® backends. A perfect quantum computer would get results similar to the simulator, resulting in values for <img alt="" src="image/Formula_05_005.png"/> and <img alt="" src="image/Formula_05_006.png"/> only:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer348">
					<img alt="Figure 5.4 – Graphical view of the Bell results&#13;&#10;" src="image/Figure_5.4_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Graphical view of the Bell results</p>
			<p>What we have created here is a simple comparison of the available IBM Quantum® backends using a <em class="italic">basic 2-qubit Bell state quantum program</em>. On a perfect quantum computer, we only expect the results – <img alt="" src="image/Formula_05_007.png"/> and <img alt="" src="image/Formula_05_008.png"/> – which is <a id="_idIndexMarker289"/>indeed what we see for <strong class="source-inline">ibmq_qasm_simulator</strong>. Like we discussed in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level </em><em class="italic">with Terra</em>, for real <strong class="bold">Noisy Intermediate-Scale Quantum </strong>(<strong class="bold">NISQ</strong>) machines, we expect some noise and a mixed result, consisting of <img alt="" src="image/Formula_05_009.png"/>, <img alt="" src="image/Formula_05_010.png"/>, <img alt="" src="image/Formula_05_011.png"/>, and <img alt="" src="image/Formula_05_012.png"/> for the IBM Quantum® hardware.</p>
			<p>Generally <a id="_idIndexMarker290"/>speaking, the smaller the <img alt="" src="image/Formula_05_013.png"/> and <img alt="" src="image/Formula_05_014.png"/> bars are, the better the backends perform, but there are many factors at play. These will be explored later in this chapter and in <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Your Quantum Act with Ignis</em>.</p>
			<p>Also, keep in mind that we are only comparing the default execution of your quantum programs here. Different qubit configurations, readout errors, qubit connection issues, and other errors that occur with real hardware play a part and make the results somewhat random.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>There's more</h2>
			<p>In this recipe, we ran our quantum program on almost all available backends. As you saw in the<em class="italic"> Locating the available backends</em> recipe, you can also filter the backends. This recipe required at least two qubits to run, so we added a filter to include backends with more than one qubit:</p>
			<p class="source-code">backends = provider.backends(filters=lambda b: b.configuration().n_qubits &gt; 1 and b.status().operational)</p>
			<p>You can use the filter capability for other reasons; for example, to run on only 5-qubit machines, filter by the number of qubits:</p>
			<p class="source-code"># Get all available and operational backends.</p>
			<p class="source-code">backends = provider.backends(n_qubits=5)</p>
			<p>You can now see how the available backends behave, and how busy some of them might be. Time to figure out <a id="_idIndexMarker291"/>a way to speed up your quantum program executions by finding the backend with the shortest queue. </p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Finding the least busy backend</h1>
			<p>When you <a id="_idIndexMarker292"/>run your quantum program on an IBM Quantum® backend, you will quickly realize that you might not be the only one attempting to use that same backend at the same time. Depending on the time and day of the week, and the type and purpose of the quantum programs being run, not all IBM Quantum® machines are used to the same degree.</p>
			<p>If you are not concerned with which machine you should run the code on, you can use the <strong class="source-inline">least_busy</strong> method to automatically find the best backend to run your programs on. The least busy status of a backend generally means that you have the least wait time, but this is not necessarily true. Some programs run longer than others, and queues (just like in the supermarket) might move at different speeds.</p>
			<p>Let's take a look at the following steps:</p>
			<ol>
				<li value="1">Start by importing the required <strong class="source-inline">IBMQ</strong> and <strong class="source-inline">least_busy</strong> methods and load our account.</li>
				<li>Use the <strong class="source-inline">least_busy</strong> method to automatically select the generally available least busy backend, and the least busy backend with 5 qubits.</li>
				<li>Finally, let's display the overview data for all backends to verify that the backends that we selected are indeed the least busy backends.</li>
			</ol>
			<p>The <strong class="source-inline">least_busy</strong> method is convenient if we do not want to wait for our execution but might not be the best option. Qiskit® has given us the name of the least busy backend. We can now trust Qiskit® and run our quantum code on that backend, or, depending on our purposes, we might choose another backend to run on. It might turn out that the least busy <a id="_idIndexMarker293"/>backend is a machine with noisy qubits or short T1 or T2 that doesn't suit our purposes. </p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r3_least_busy.py</a>.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>How to do it...</h2>
			<p>What <strong class="source-inline">least_busy</strong> is looking for are backends that include a <strong class="source-inline">pending_jobs</strong> parameter. If you add additional filtering features that exclude the actual least busy backend, the method will return the backend with the least pending jobs that meet the filtering criteria.</p>
			<p>Let's take a look:</p>
			<ol>
				<li value="1">Start by importing the required <strong class="source-inline">IBMQ</strong> and <strong class="source-inline">least_busy</strong> methods, and load our account:<p class="source-code">from qiskit import IBMQ</p><p class="source-code">from qiskit.providers.ibmq import least_busy</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>Now we can ask IBM Quantum® which backend is least busy, and set our <strong class="source-inline">backend</strong> parameter accordingly:<p class="source-code">backend = least_busy(provider.backends(simulator=False))</p><p class="source-code">print("Least busy backend:", backend.name())</p><p>The preceding code might give the following result:</p><p class="source-code">Out[]: </p><p class="source-code">Least busy backend: ibmq_armonk</p><p>In this example, the least busy backend turned out to be <strong class="source-inline">ibmq_armonk</strong>, which is a 1-qubit machine designed for pulse testing. This is not the backend that you want to run your multi-qubit circuits on.</p></li>
				<li>Filter <a id="_idIndexMarker294"/>the least busy results.<p>You can feed the <strong class="source-inline">least_busy</strong> method a filtered list of backends, for example, to only include 5-qubit machines, or just call the method with the unfiltered <strong class="source-inline">provider.backends()</strong> function, like in the following example:</p><p class="source-code">filtered_backend = least_busy(provider.backends(</p><p class="source-code">    n_qubits=5, operational=True, simulator=False))</p><p class="source-code">print("\nLeast busy 5-qubit backend:",</p><p class="source-code">    filtered_backend.name())</p><p>The preceding code might give the following output:</p><p class="source-code">Out[]: </p><p class="source-code">Least busy 5-qubit backend: ibmq_santiago</p><p>There we go – this is the least busy backend with five qubits.</p></li>
				<li>To check that the method selected the best backend, we can use the <strong class="source-inline">backend_overview()</strong> method to take a look at the number of pending jobs for the available backends: <p class="source-code">from qiskit.tools.monitor import backend_overview</p><p class="source-code">print("\nAll backends overview:\n")</p><p class="source-code">backend_overview()</p><p>The preceding code might give the following result:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer357">
					<img alt="Figure 5.5 – All available backends with no filtering" src="image/Figure_5.5_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – All available backends with no filtering</p>
			<p>Keep an eye on the <strong class="bold">Least busy</strong> parameter. As you can see, the number of pending jobs is the smallest for the least busy backend.</p>
			<p>So, the takeaway of this recipe is that you can automate which backend you run your quantum programs on, but that the returned <a id="_idIndexMarker295"/>backend might not be what you want if you need to run your program on a specific number of qubits. If this is the case, filter the search by the number of qubits to get the backend with the shortest queue. </p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Visualizing the backends</h1>
			<p>Now that we have started poking at various parameters of the IBM Quantum® backends, it would be helpful to have a <a id="_idIndexMarker296"/>simple way of getting a visual overview of the quantum chips and various important parameters, such as how the qubits are interconnected, which connections are better than others, what the quality of each qubit is, and so on. Qiskit® comes with visualizations built in.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor148"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r4_backend_vis.py</a>.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>How to do it...</h2>
			<p>We will use three methods of the <strong class="source-inline">qiskit.visualization</strong> package to look over the backends: <strong class="source-inline">plot_gate_map()</strong>, <strong class="source-inline">plot_error_map()</strong>, and <strong class="source-inline">plot_circuit_layout()</strong>. For the last one, we also need to <em class="italic">transpile</em> a quantum circuit using the <strong class="source-inline">transpile()</strong> method to then display which qubits Qiskit® is mapping your gates to on the backend.</p>
			<p>Let's look at the following steps:</p>
			<ol>
				<li value="1">Start by importing the required <strong class="source-inline">qiskit</strong> and <strong class="source-inline">qiskit.visualization</strong> methods, and load our account:<p class="source-code">from qiskit import IBMQ, QuantumCircuit, transpile</p><p class="source-code">from qiskit.providers.ibmq import least_busy</p><p class="source-code"># Import the backend visualization methods</p><p class="source-code">from qiskit.visualization import plot_gate_map,</p><p class="source-code">plot_error_map, plot_circuit_layout</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>Grab and get all available IBM Quantum® backends that have more than 1 qubit and that are not simulators:<p class="source-code">available_backends = provider.backends(filters=lambda b:</p><p class="source-code">    b.configuration().n_qubits &gt; 1 and b.status().</p><p class="source-code">        operational)</p><p class="source-code">print("{0:20} {1:&lt;10}".format("Name","#Qubits"))</p><p class="source-code">print("{0:20} {1:&lt;10}".format("----","-------"))</p><p class="source-code">for n in range(0, len(available_backends)):</p><p class="source-code">    backend = provider.get_backend(str(available_</p><p class="source-code">        backends[n]))</p><p class="source-code">    print("{0:20} {1:&lt;10}".format(backend.name(),</p><p class="source-code">        backend.configuration().n_qubits))</p></li>
				<li>Select the backend that you want to take a look at:<p class="source-code">backend_input = input("Enter the name of a backend, or X</p><p class="source-code">    for the least busy:")</p><p class="source-code">if backend_input not in ["X","x"]:</p><p class="source-code">    backend = provider.get_backend(backend_input)</p><p class="source-code">else:</p><p class="source-code">    backend = least_busy(provider.backends(</p><p class="source-code">        filters=lambda b: b.configuration().n_qubits &gt; 1</p><p class="source-code">            and b.status().operational))</p></li>
				<li>Now, let's <a id="_idIndexMarker297"/>display the gate map and the error map for the backend:<p class="source-code">print("\nQubit data for backend:",backend.status().</p><p class="source-code">    backend_name)</p><p class="source-code">display(plot_gate_map(backend, plot_directed=True))</p><p class="source-code">display(plot_error_map(backend))</p><p>This first visualization shows the logical layout of the backend, optionally with the permitted direction of communication between the qubits displayed (<strong class="source-inline">plot_directed=True</strong>).</p><p>Consider this example: <strong class="source-inline">display(plot_gate_map(backend, plot_directed=True))</strong>.</p><p>The preceding code might give the following output for <strong class="source-inline">ibmq_burlington</strong>:</p><div class="IMG---Figure" id="_idContainer358"><img alt="Figure 5.6 – The gate map for ibmq_burlington" src="image/Figure_5.6_B14436.jpg"/></div><p class="figure-caption">Figure 5.6 – The gate map for ibmq_burlington</p><p>With the <a id="_idIndexMarker298"/>error map visualization, you get a view of the readout error and CX error rates for the backend. This map gives you an indication of the quality of the qubits for providing accurate readout results, and for correctly executing on the <strong class="bold">controlled-NOT</strong> <strong class="bold">(CX)</strong> gates between two qubits:</p><div class="IMG---Figure" id="_idContainer359"><img alt="Figure 5.7 – The error map form ibmq_burlington" src="image/Figure_5.7_B14436.jpg"/></div><p class="figure-caption">Figure 5.7 – The error map form ibmq_burlington</p></li>
				<li>And finally, create <a id="_idIndexMarker299"/>a Bell circuit, transpile it, and use it to display the circuit layout:<p class="source-code"># Create and transpile a 2 qubit Bell circuit</p><p class="source-code">qc = QuantumCircuit(2)</p><p class="source-code">qc.h(0)</p><p class="source-code">qc.cx(0,1)</p><p class="source-code">display(qc.draw('mpl'))</p><p class="source-code">qc_transpiled = transpile(qc, backend=backend, </p><p class="source-code">    optimization_level=3)</p><p class="source-code">display(qc_transpiled.draw('mpl'))</p><p class="source-code"># Display the circuit layout for the backend.</p><p class="source-code">display(plot_circuit_layout(qc_transpiled, backend, </p><p class="source-code">    view='physical'))</p><p>The circuit layout is a little bit more complex, as it not only takes a backend as input, but you must also feed it the transpiled quantum circuit that you want to run on it. </p><p>For example, still on <strong class="source-inline">ibmq_burlington</strong>, we might want to run a Bell circuit. </p><p>The preceding code might give the following result:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer360">
					<img alt="Figure 5.8 – A Bell quantum circuit with two qubits" src="image/Figure_5.8_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8 – A Bell quantum circuit with two qubits</p>
			<p>The transpiled <a id="_idIndexMarker300"/>circuit tells us that we will run the circuit on qubits 0 and 1. As we started out with a 2-qubit circuit, we gave the transpiler the option to assign any two qubits to our circuit:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer361">
					<img alt="Figure 5.9 – The transpiled Bell circuit&#13;&#10;" src="image/Figure_5.9_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9 – The transpiled Bell circuit</p>
			<p>The circuit layout shows us the expected qubit assignment:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer362">
					<img alt="Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit 1&#13;&#10;" src="image/Figure_5.10_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – The CX gate in the Bell circuit is mapped from qubit 0 to qubit 1</p>
			<p>The view illustrates what the physical chip looks like, in a symbolic way with no technical details.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>There's more...</h2>
			<p>We have <a id="_idIndexMarker301"/>seen the visualization steps in Qiskit®. You can also get the same information in IBM Quantum Experience®. </p>
			<p>Let's take a look:</p>
			<ol>
				<li value="1">Log in to IBM Quantum Experience® at <a href="https://quantum-computing.ibm.com">https://quantum-computing.ibm.com</a>.</li>
				<li>On the <strong class="bold">Welcome</strong> page, on the right-hand side, you'll see a list of the available backends:<div class="IMG---Figure" id="_idContainer363"><img alt="Figure 5.11 – The IBM Quantum Experience® home page" src="image/Figure_5.11_B14436.jpg"/></div><p class="figure-caption">Figure 5.11 – The IBM Quantum Experience® home page</p></li>
				<li>Click on <a id="_idIndexMarker302"/>the backend that you are interested in, for example, <strong class="source-inline">ibmq_burlington</strong>, to see the chip layout and additional information:<div class="IMG---Figure" id="_idContainer364"><img alt="Figure 5.12 – Details of the ibmq_burlington chip" src="image/Figure_5.12_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.12 – Details of the ibmq_burlington chip</p>
			<p>Here's a <a id="_idIndexMarker303"/>short list of the different pieces of data that you can see for the selected chip:</p>
			<ul>
				<li><strong class="bold">Online or offline</strong>: Is the backend currently available?</li>
				<li><strong class="bold">The current queue</strong>: How many people are using the backend at the moment? This number gives you a rough estimate of how busy the backend is, and how long it might take before your program will run.</li>
				<li><strong class="bold">Providers</strong>: This will be <strong class="bold">open</strong> for the freely available backends.</li>
				<li><strong class="bold">A blueprint view of the actual quantum chip</strong>: The view illustrates what the physical chip looks like, in a symbolic way with no technical details.</li>
				<li><strong class="bold">A connectivity map</strong>: The arrows between the qubits illustrate how they can be connected using 2-qubit gates such as the <strong class="bold">CNOT</strong> (also known as <strong class="bold">controlled-NOT</strong>, or <strong class="bold">CX</strong>) gate. The connection can be made from the qubit where the arrow starts to the qubit where it ends.</li>
				<li><strong class="bold">Single-qubit error rate</strong>: This is a measure of the quality of the qubit. It is a summary of the error rate of the qubit itself and the readout error. Basically, this is the probability that a qubit in one state will be read as the other state.</li>
				<li><strong class="bold">CNOT error rate</strong>: This is the measure of the quality of the qubit connection. It is the probability that two entangled qubits will read the opposite of the entanglement.</li>
				<li><strong class="bold">Number of qubits</strong>: The number of available qubits.</li>
				<li><strong class="bold">Online since</strong>: The date and time that the machine came online.</li>
				<li><strong class="bold">Maximum shots</strong>: The maximum number of shots you can run on the backend.</li>
				<li><strong class="bold">Quantum volume</strong>: The measured quantum volume for the backend. The quantum volume is IBM's suggested benchmark for measuring the performance of today's quantum computers.</li>
				<li><strong class="bold">Basis gates</strong>: These are the generic gates that are used to build quantum programs on the chip. Generally speaking, these are <strong class="source-inline">u1</strong>, <strong class="source-inline">u2</strong>, <strong class="source-inline">u3</strong>, <strong class="source-inline">cx</strong>, and <strong class="source-inline">id</strong>. With these gates, you can build all other quantum gates that are supported by Qiskit®. </li>
			</ul>
			<p>You can use <a id="_idIndexMarker304"/>the visualized IBM Quantum® information as guidance for writing and executing your quantum programs, and also include aspects such as the qubit properties and error map to fine-tune your programs for a specific backend. However, in a pure, non-user interface Qiskit® environment, you might want to access this data without having to resort to a user interface. This is all covered in the next recipe, where we dig out this data directly in Qiskit®.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor151"/>See also</h2>
			<p>For a good overview and explanation of the quantum volume concept, see the Medium article: <em class="italic">What Is Quantum Volume, Anyway?</em> by Ryan F. Mandelbaum, senior technical writer, IBM Quantum® and Qiskit®: <a href="https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f">https://medium.com/qiskit/what-is-quantum-volume-anyway-a4dff801c36f</a></p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Exploring a selected backend using Qiskit<span class="superscript">®</span></h1>
			<p>Exploring backend data visually is a handy but strictly manual process. Sometimes you might want to include backend <a id="_idIndexMarker305"/>information in your program logic when running your programs, for example, to select the appropriate backend or dynamically apply your gates on the best qubits. To <a id="_idIndexMarker306"/>do this, we can pull this data directly from the available backend information by using Qiskit®.</p>
			<p>In this recipe, we will use the <strong class="source-inline">backend.configuration()</strong>, <strong class="source-inline">backend.status()</strong>, and <strong class="source-inline">backend.properties()</strong> methods to retrieve and list the available and operational backends, with some important configuration data such as the number of qubits, the maximum number of experiments you can run, and the number of pending jobs in the queue. We will also dig out some important qubit parameters such as T1, T2, frequency, and readout error for a selected backend.</p>
			<p>Okay, let's take a look at how it is done:</p>
			<ol>
				<li value="1">Start by importing the IBMQ class and load our account.</li>
				<li>Get all available and operational backends.</li>
				<li>Fish out and print the backend criteria, such as the name, number of qubits, max number of experiments, and pending jobs to compare.</li>
				<li>Select the least busy backend with five qubits.</li>
				<li>Print out qubit properties for the selected backend.</li>
			</ol>
			<p>You can now take a closer look at the selected properties of the backend and, for example, use this information to decide which backend you want to run your programs on.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter05/ch5_r5_explore.py</a>.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>How to do it...</h2>
			<p>Depending <a id="_idIndexMarker307"/>on the type of quantum program that you are writing, certain aspects of the backend might be important to you, and you might want to include these directly when you <a id="_idIndexMarker308"/>code your program. For example, you might be interested in the qubits with the smallest gate errors and readout errors, or if you are running deep circuits, you might be interested in long T1 and T2 times:</p>
			<ol>
				<li value="1">Like always, let's start by importing the IBMQ class and load our account:<p class="source-code">from qiskit import IBMQ</p><p class="source-code">from qiskit.providers.ibmq import least_busy</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>Get all available backends.<p>We will use simple Python scripting to compare the available backends based on different criteria – the name, number of qubits, maximum allowed number of experiments per day, and number of pending jobs. First, we need a list of the available backends:</p><p class="source-code">available_backends = provider.backends(operational=True)</p></li>
				<li>Fish out some backend parameters to compare.<p>To find the parameters, we loop through the list and print out four selected parameters for each backend – <strong class="source-inline">name</strong>, <strong class="source-inline">n_qubits</strong>, <strong class="source-inline">max_experiments</strong>, and <strong class="source-inline">pending_jobs</strong>:</p><p class="source-code">print("{0:20} {1:&lt;10} {2:&lt;10} {3:&lt;10}".format("Name",</p><p class="source-code">    "#Qubits","Max exp.","Pending jobs"))</p><p class="source-code">print("{0:20} {1:&lt;10} {2:&lt;10} {3:&lt;10}".format("----","---</p><p class="source-code">    ----","--------","------------"))</p><p class="source-code">for n in range(0, len(available_backends)):</p><p class="source-code">    backend = provider.get_backend(str(</p><p class="source-code">        available_backends[n]))</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10} {3:&lt;10}".</p><p class="source-code">        format(backend.name(),</p><p class="source-code">        backend.configuration().n_qubits,</p><p class="source-code">            backend.configuration().</p><p class="source-code">        max_experiments,backend.status().pending_jobs))</p><p>The <a id="_idIndexMarker309"/>preceding code might give the following result:</p><div class="IMG---Figure" id="_idContainer365"><img alt="Figure 5.13 – The available backends with selected parameters displayed&#13;&#10;" src="image/Figure_5.13_B14436.jpg"/></div><p class="figure-caption">Figure 5.13 – The available backends with selected parameters displayed</p></li>
				<li>Now, we <a id="_idIndexMarker310"/>can dig in and take a look at some of the available qubit data for the least busy backend with five qubits, such as the T1 and T2 decoherence values, the frequency, and the readout error for the qubits. <p>For this exercise, we can write another simple Python <strong class="source-inline">for</strong> loop that prints the properties of the backend's qubits, such as name, value, and unit for the relevant data entry.</p><p>We will loop through the number of qubits of the backend (<strong class="source-inline">least_busy_backend.configuration().n_qubits</strong>) and then the number of property parameters for each qubit (<strong class="source-inline">len(least_busy_backend.properties().qubits[0])</strong>):</p><p class="source-code">least_busy_backend = least_busy(provider.backends(</p><p class="source-code">    n_qubits=5,operational=True, simulator=False))</p><p class="source-code">print("\nQubit data for backend:",</p><p class="source-code">    least_busy_backend.status().backend_name)</p><p class="source-code">for q in range (0,</p><p class="source-code">    least_busy_backend.configuration().n_qubits):</p><p class="source-code">    print("\nQubit",q,":")</p><p class="source-code">    for n in range (0, len(least_busy_backend.</p><p class="source-code">        properties().qubits[0])):</p><p class="source-code">        print(least_busy_backend.properties().qubits[q]</p><p class="source-code">            [n].name,"=",least_busy_backend.properties().</p><p class="source-code">            qubits[q][n].value,</p><p class="source-code">            least_busy_backend.properties()</p><p class="source-code">            .qubits[q][n].unit)</p><p>The <a id="_idIndexMarker311"/>preceding <a id="_idIndexMarker312"/>code should give a result similar to the following:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer366">
					<img alt="Figure 5.14 – Qubit details for a selected backend" src="image/Figure_5.14_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – Qubit details for a selected backend </p>
			<p>With that, we all <a id="_idIndexMarker313"/>of a sudden know much more about our qubits. They are <a id="_idIndexMarker314"/>not just logical entities anymore, but concrete physical objects, albeit physical objects behaving quantum mechanically. In the <em class="italic">Comparing qubits on a chip</em> recipe of <a href="B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220"><em class="italic">Chapter 8</em></a>, <em class="italic">Cleaning Up Your Quantum Act with Ignis</em>, we will take a look at how you can use the <strong class="source-inline">backend.properties().gates</strong> information in your own programs.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor155"/>There's more...</h2>
			<p>In this <a id="_idIndexMarker315"/>recipe, we have looked at a selected subset of <a id="_idIndexMarker316"/>backend and qubit properties. With Qiskit®, you can dig out a lot more information by using the following methods:</p>
			<ul>
				<li><strong class="source-inline">backend.configuration()</strong><p><strong class="source-inline">backend_name</strong></p><p><strong class="source-inline">backend_version</strong></p><p><strong class="source-inline">n_qubits</strong></p><p><strong class="source-inline">basis_gates</strong></p><p><strong class="source-inline">gates</strong></p><p><strong class="source-inline">local</strong></p><p><strong class="source-inline">simulator</strong></p><p><strong class="source-inline">conditional</strong></p><p><strong class="source-inline">open_pulse</strong></p><p><strong class="source-inline">memory</strong></p><p><strong class="source-inline">max_shots</strong></p></li>
				<li><strong class="source-inline">backend.status()</strong><p><strong class="source-inline">backend_name</strong></p><p><strong class="source-inline">backend_version</strong></p><p><strong class="source-inline">operational</strong></p><p><strong class="source-inline">pending_jobs</strong></p><p><strong class="source-inline">status_msg</strong></p></li>
				<li><strong class="source-inline">backend.properties()</strong><p><strong class="source-inline">backend_name</strong></p><p><strong class="source-inline">backend_version </strong></p><p><strong class="source-inline">last_update_date </strong></p><p><strong class="source-inline">qubits</strong></p><p><strong class="source-inline">gates</strong></p><p><strong class="source-inline">general</strong></p><p class="callout-heading">Tip</p><p class="callout">To print out the full list of value for each method, use the <strong class="source-inline">to_dict()</strong> parameter. For example: <strong class="source-inline">backend.configuration().to_dict()</strong></p></li>
			</ul>
			<p>Try to <a id="_idIndexMarker317"/>modify the sample code to look up specific parameters such as the <a id="_idIndexMarker318"/>following:</p>
			<ul>
				<li>The backend name</li>
				<li>The basis gates available for the backend</li>
				<li>The qubit coupling map that specifies how the individual qubits can communicate</li>
				<li>A list of the gates and their properties for the backend</li>
			</ul>
		</div>
	</body></html>