- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Quantum Logic Gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum logic gates are very similar to their classical counterparts in that
    they are used to perform operations by manipulating the qubits in such a way that
    the results serve to provide a solution. Of course, that’s about as far as the
    comparison can go. Classical gates transition the state of a bit from one to the
    other by a single operation, in this case, flipping the bit value from 0 to 1,
    or vice versa. **Quantum gates**, sometimes referred to as **qubit gates**, are
    different in part because they perform linear transformations on one or more qubits
    in a complex vector space to transition them from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing classical logic gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding unitary operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding single-qubit gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding multi-qubit gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding non-reversible operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will have gained knowledge about the fundamental
    operations that can be performed on both single and multiple qubits. But before
    we dive right in, let’s discuss the format with which I’ll try to explain each
    qubit gate. First, from a learning perspective, some people tend to learn quicker
    when content is presented purely with mathematics; others prefer visual aids such
    as graphs; others still prefer a more intuitive approach with analogies and examples.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, I shall do my best to ensure that each gate is presented
    by combining as many of these learning styles as possible. This will be done by
    providing not only the mathematical representation of each qubit gate, but also
    a visual representation, and of course, the source code to run the qubit gate
    operation and its result.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss linear transformations of matrices in the **Hilbert
    space**, so it is highly recommended that you should know the basics of linear
    algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of the qubit and how its states are represented on a Bloch sphere,
    **QSphere**, or mathematically, is recommended as this chapter will perform complex
    linear transitions of those qubit states. Knowledge of basic classical single-bit
    and multi-bit gates is also recommended, but not required, as there is a refresher
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing classical logic gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will serve as a refresher for classical logic gates such as **AND**,
    **OR**, **NOR**, and so on. If you are familiar with this subject, you can either
    skim through it to refresh your memory or skip it entirely and jump to the next
    section. *Otherwise, let’s get logical!*
  prefs: []
  type: TYPE_NORMAL
- en: '**Logic gates** are defined as a device, electronic or otherwise, that implements
    a logical (usually Boolean) operation. Single-bit and two-bit gates have one or
    two inputs, respectively. Each input bit value is a state value of either 0 or
    1\. The operation carried out on the input varies by the type of gate. Each gate
    operation is usually described using logic truth tables, as illustrated in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gate** | **Operation** | **Input****A B** | **Output****Y** | **Graphical
    Representation** |'
  prefs: []
  type: TYPE_TB
- en: '| **Buffer** | Outputs the same value as the input | 01 | 01 | ![](img/Table_06_01_icon-09.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **NOT** | Reverses the input state | 01 | 10 | ![](img/Table_06_01_icon-08.png)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **AND** | Outputs a 1 if and only if both inputs are 1, otherwise output
    is 0 | 0 00 11 01 1 | 0001 | ![](img/Table_06_01_icon-07.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **OR** | Outputs a 0 if and only if none of the inputs is 1, otherwise output
    is 1 | 0 00 11 01 1 | 0111 | ![](img/Table_06_01_icon-06.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **XOR** | Outputs a 1 if and only if both inputs are different, otherwise
    output is 0 | 0 00 11 01 1 | 0110 | ![](img/Table_06_01_icon-05.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **NAND** | Outputs a 0 if and only if both inputs are 1, otherwise output
    is 1 | 0 00 11 01 1 | 1110 | ![](img/Table_06_01_icon-03.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **NOR** | Outputs a 1 if and only if both inputs are 0, otherwise outputs
    a 0 | 0 00 11 01 1 | 1000 | ![](img/Table_06_01_icon-02.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **XNOR** | Outputs a 1 if and only if inputs are both either 0 or 1, otherwise
    outputs 0 | 0 00 11 01 1 | 1001 | ![](img/Table_06_01_icon-01.png) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Classical logic gates'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table lists some of the common classical gates, descriptions of
    the operation that each gate performs on the input state, the result (output)
    of the gate operation, and their graphical representations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider some things of note regarding classical bits that will help you
    later understand the differences they have compared to **quantum bits** (**qubits**).
    First is that there are only two single-bit gates, the buffer and the NOT gate.
    Among these two, only the NOT gate performs a Boolean operation on the classical
    bit by flipping the bit value of the input, so if the input to the NOT gate was
    a 0, then the output would be a 1\. On the other hand, the buffer gate simply
    outputs the same value as the input. All the other gates operate on two input
    bit values that output a single value, which is determined by the gate’s Boolean
    operation. For example, if both input values to an AND gate are 1, it will output
    a 1\. Otherwise, the output will be 0.
  prefs: []
  type: TYPE_NORMAL
- en: One problem, however, particularly with regard to the two-bit gates, is that
    if you only have access to the output, then the information about the input is
    lost. For example, if you obtain the result from an AND bit and the value is 0,
    *could you tell what the input values were for A and B (the inputs)?* Unfortunately,
    the answer to this question is no. The input information is lost because the output
    does not include any information about the input value, which renders the gates
    irreversible. Likewise, with other two-bit gates, if I gave you just the output
    value of the gate, you could not tell me with 100% certainty what the input values
    were.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversibility** is a unique property that qubit gates have, in that you can
    reverse the operation of the qubit gate to obtain the previous state. This is
    also because the second postulate of quantum mechanics states that transformations
    between quantum states must be unitary, therefore reversible. We see this when
    we apply a Hadamard gate to a single qubit in the ground state 0; if we apply
    another Hadamard gate after the first one, then the state of the qubit returns
    to the ground state 0\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, to close our discussion on classical gates, we’ll discuss **universal
    logic gates**. These gates are the type of gates used to create other logic gates.
    **NOR** and **NAND** gates are good examples of universal gates in that they can
    be used to create NOT and AND gates. Let’s take a look at the following diagram
    that illustrates creating a NOT gate (inverter) by using a NAND gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Using a NAND gate to create a NOT gate ](img/B18420_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Using a NAND gate to create a NOT gate'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, by wiring both inputs of the NAND gate together, forming a single
    input (**A**), this logically creates a NOT gate that flips the value of the input.
    Computational systems having universal gates is an important feature as it provides
    the ability to compose complex logical circuits to solve problems. This of course
    led to the creation of integrated circuits, which are specialized circuits used
    to compute problems or to perform specific operations such as an adder or a counter,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed the functionality of classical gates, we can continue
    to the next section where we will cover the basics of quantum logic gates. There,
    we will also see some similarities and some unique properties that they display
    with regard to the classical bit.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quantum unitary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unitary operators** are defined as a unitary transformation of a rigid body
    rotation of the Hilbert space. When these unitary operators are applied to the
    basis states of the Hilbert space, for example, the ![](img/B18420_05_004.png)
    and ![](img/B18420_05_005.png) state, the results transform the state vector position
    but it does not change its length. Let’s see what this means for a qubit. The
    basis states of a qubit are mapped on the Hilbert space ![](img/B18420_06_003.png)
    as described in *Chapter 5*, *Understanding a Qubit*, ![](img/B18420_06_004.png)
    and ![](img/B18420_06_005.png), where ![](img/B18420_06_006.png), and ![](img/B18420_06_007.png)
    are linear transformations that preserve orthogonality over unitary transformations.
    We’ll wrap our heads around this definition a bit by looking at this mathematically
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A linear transformation on a complex vector space can be described by a 2x2
    matrix, **U**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, if we obtain the complex transpose of the matrix U as ![](img/B18420_06_009.png),
    by transposing the matrix U and applying the complex conjugate, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we can say that the matrix U is unitary if ![](img/B18420_06_011.png),
    where I represents the Identity matrix ![](img/B18420_06_012.png), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_013.png)'
  prefs: []
  type: TYPE_IMG
- en: An intuitive way to think of this is to just imagine unitary transformation
    simply as rotations of the complex vector space that preserve the length of the
    original vector. The rotation of the complex vector space further ensures that
    quantum transformations are not just unitary operations but are also **reversible
    operations** as they would rotate around a specified axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reversibility of quantum gates** is realized by unitary transformations.
    As seen in the previous unitary equation, if you have a unitary operator **U**
    applied to a qubit via a gate, then by applying the complex conjugate ![](img/B18420_06_009.png)
    of the unitary operator to the qubit via a second gate, the result would be equivalent
    to applying an Identity matrix to the original vector.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be if you were to trigger an operation that would rotate
    the vector space around the *x* axis by an angle π, and you then apply the complex
    conjugate of that operation, then you’ll return to the original position from
    which you started. This reversible functionality is something that is not possible
    with some classical-bit gates we mentioned earlier, such as an AND gate.
  prefs: []
  type: TYPE_NORMAL
- en: With quantum unitary transformations, there is no loss of information. Should
    you need to return to the previous state, you would merely have to use their conjugate
    transpose, in reverse order, and you’d get back to where you originally started.
    We will see some interesting examples of reversibility in all gates.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special case operator that is not reversible, the **measurement**
    operator, which we will learn about in the *Understanding non-reversible operators*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand unitary and reversible operators, we can get down to
    learning about quantum gates.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding single-qubit gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start digging into the description of quantum gates, let’s simplify
    the format so it’s easy to both understand and reference. Intuitively, the easiest
    way to imagine the operation of each gate is by rotating the vector that ends
    on the surface of the Bloch sphere around a specified axis. Recall as well that
    the Bloch sphere always starts with the unit vector set to the initial state.
    The initial state is set when the quantum circuit is first created; in this case,
    it is initialized to the basis state ![](img/B18420_06_015.png) (the north pole
    of the Bloch sphere), as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing dome  Description automatically generated](img/B18420_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Bloch sphere representation of the basis state ![](img/B18420_06_015.png)'
  prefs: []
  type: TYPE_NORMAL
- en: One thing that will help us understand some of the labels we will see in the
    gate’s truth table is to define the values of each axis, where each axis is referred
    to as **basis elements**. For example, we can see from the previous figure that
    the *z* axis has the north pole labeled as ![](img/B18420_06_015.png) and the
    south pole as ![](img/B18420_06_018.png). These two points form the computational
    basis elements for the basis state vectors ![](img/B18420_06_015.png) and ![](img/B18420_06_018.png).
    However, we do not yet have labels for the *x* or *y* axes. Let’s define them
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each basis element (axis) has a positive and negative side that originates
    at the center of the Bloch sphere. Each basis has a name associated with each
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computational** for the *z* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hadamard** for the *x* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular** for the *y* axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The x basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The -x basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The y basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The -y basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The z basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The -z basis has a label defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The labels are also illustrated at the ends of each axis in the following Bloch
    sphere diagram, where the dotted line indicates the negative direction of the
    axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Basis state labels of each axis of a Bloch sphere ](img/B18420_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Basis state labels of each axis of a Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: Each gate we apply in the code snippets will operate on the qubit starting from
    the initial |![](img/B18420_06_027.png) state. There are some gates you will see
    that we will have to prepare into a superposition state using an H gate to see
    the effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, by transitioning the vector down onto the *x* axis, and then
    applying a Z gate rotation, you can then more clearly see the rotation take effect.
    Details on how this is done will be in the description of—yes, you guessed it—the
    Z gate. But for now, let’s open the helper file and review one of the functions
    that will help us visualize the gates without having to write so much code, and
    handle some of the repetitive functions such as executing and visualizing the
    circuits. This way, we will just create the quantum circuits, add the gates, and
    execute the circuits using a function that will return the results and the images
    to visualize the results and the circuit diagrams. To start, let’s review the
    function titled `execute_circuit_sv` from our helper file that will handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will return the four components: state vector results, the
    circuit diagram, and both the QSphere and the Bloch sphere. We will use each of
    these to illustrate each state vector result, each gate on a circuit, and the
    visual representation.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can focus on the quantum gates and their effect on the qubits, and not
    so much on executing the circuits or displaying the results.
  prefs: []
  type: TYPE_NORMAL
- en: Hadamard (H) gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **H** gate is one of the most commonly used quantum gates. It’s not surprising
    as this is the gate that places the quantum state of the qubit into a complex
    linear superposition of the two basis states. This is what establishes the superposition
    of all qubits that are leveraged by most quantum algorithms. It is denoted as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_028.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the state
    vector of the qubit along the *x* axis and *z* axis by ![](img/B18420_06_029.png)
    (90°), causing the state vector to be in a complex linear superposition of ![](img/B18420_06_015.png)
    and ![](img/B18420_06_018.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.5 – Truth table of a Hadamard operation ](img/Table_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.2: Truth table of a Hadamard operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue and create a new notebook and add a circuit using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add an H gate to the qubit, and execute it on the backend, the same
    as we did in the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the following state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the H gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the **H** gate added to the qubit, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Circuit diagram with an H gate ](img/B18420_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Circuit diagram with an H gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_06_015.png) or
    ![](img/B18420_06_018.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing building, dome  Description automatically generated](img/B18420_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: H gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has an equal probability of being either ![](img/B18420_06_015.png)
    or ![](img/B18420_06_018.png). The tip of the vectors, as you’ll notice, have
    the same diameter, indicating visually that both have equal probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: H gate QSphere representation'
  prefs: []
  type: TYPE_NORMAL
- en: The Hadamard (H) gate is a unique gate. We will see this gate many more times
    in this chapter and future chapters—having the ability to negate a state vector,
    also referred to as a phase kick, is very useful in many quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Pauli gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first group of single-qubit gates we will discuss are commonly referred
    to as **Pauli matrix** gates, named after the physicist Wolfgang Pauli. The complex
    matrix representation of the four gates, **I**, **X**, **Y**, and **Z**, are defined
    as *2 x 2* complex matrices, which are both Hermitian and unitary and are represented
    by the Greek letter sigma ![](img/B18420_06_036.png), respectively. When the conjugate
    transpose of a complex N x N matrix is equal to itself, then such a matrix is
    known as a Hermitian matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Identity matrix is subscripted with a 0, and the *x, y, z* subscripts
    can also be represented as ![](img/B18420_06_037.png).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the easiest of the gates, the Identity gate.
  prefs: []
  type: TYPE_NORMAL
- en: Identity (I) Pauli gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **I gate**, also known as the **Identity gate,** is a gate that does not
    perform any operation on the qubit. It does not change the state of the qubit.
    Mathematically, this is represented as an Identity matrix, hence the name of the
    gate. This equation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_038.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The truth table for this gate shows that the input and output have the same
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.2 – Truth table of Identity gate ](img/Table_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.3: Truth table of Identity gate'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of an Identity gate is generally used mathematically to illustrate
    certain properties of operations, as we did earlier in this chapter to prove that
    unitary operators are reversible. In that example, the Identity matrix was used
    to illustrate that multiplying a unitary operator with its complex conjugate would
    produce the same output as applying no operation, or an Identity matrix, to the
    qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next gate section.
  prefs: []
  type: TYPE_NORMAL
- en: NOT (X) Pauli gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **X gate** is also called the NOT gate because of the similar effect it
    has on the basis states as its classical-bit gate counterpart. One notable difference
    is that the X gate moves the state vector from one basis state to the other, as
    illustrated in *Table 6.4*. Visualizing this operation can be seen via the Bloch
    sphere result as a rotation of the vector from the initial state, ![](img/B18420_06_015.png).
    Because of its spherical presentation, we refer to operations as rotations around
    some axis, in this case, the X gate is a π (180° ) rotation about the *x* axis,
    which is represented by the Pauli X-gate operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *x* axis by ![](img/B18420_06_041.png) (180), hence if the input is
    ![](img/B18420_06_015.png), then the output is ![](img/B18420_06_018.png), and
    vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.3 – Truth table of X (NOT) gate  ](img/Table_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.4: Truth table of X (NOT) gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a circuit by following the next steps to include in our notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add an X gate to it, and execute it using our helper function to do
    the heavy lifting for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit, which we expect should
    represent ![](img/B18420_06_044.png), where *a*=0 and *b*=1, as shown in the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to draw the circuit diagram for the X gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the **X** gate added to the qubit, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – X gate ](img/B18420_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: X gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Bloch sphere representation has changed the state of the qubit from ![](img/B18420_06_015.png)to
    ![](img/B18420_06_018.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing building, dome  Description automatically generated](img/B18420_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: X gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere represents the transition of the quantum state of the qubit from
    ![](img/B18420_06_015.png) to ![](img/B18420_06_018.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with low confidence](img/B18420_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: X gate QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the X gate serves as a good example that quantum gates can
    also be used to perform the same operations as classical gates. One other thing
    you will notice from the QSphere result is the color wheel that represents the
    phase of the state vector, which in this case is blue to indicate it’s in phase
    (0).
  prefs: []
  type: TYPE_NORMAL
- en: Y Pauli gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Y gate** is a rotation around the *y* axis by ![](img/B18420_06_041.png)
    (180°), shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the following truth table illustrates that the operation rotates the
    input around the *y* axis by ![](img/B18420_06_041.png) (180°), hence if the input
    to the gate is ![](img/B18420_06_015.png), then the output from the gate is ![](img/B18420_06_018.png)
    and vice versa; note the phase difference where ![](img/B18420_06_015.png) has
    the phase at *i*, and ![](img/B18420_06_018.png) has a phase shift, indicated
    by the *-i*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.4 – Truth table representing phase rotation of y axis ](img/Table_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.5: Truth table representing phase rotation of the y axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a circuit by using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a Y gate to it, and execute it using our helper function, which
    provides the quantum circuit and the visual representations of each circuit we
    execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the Y gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code displays the circuit diagram with the Y gate added to the
    qubit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Y gate ](img/B18420_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Y gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed from ![](img/B18420_05_004.png)
    to ![](img/B18420_05_005.png); however, the rotation was done around the *y* axis
    as opposed to the *x* axis, and the result, in this case, is the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing building, dome  Description automatically generated](img/B18420_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Y gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell. Of course,
    you can also use `bloch_sphere` to view the Bloch sphere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has transitioned the state of the qubit from |![](img/B18420_06_027.png)
    to |![](img/B18420_04_055.png). Note that the colors indicating states might be
    different based on your system settings or as they could change over time in the
    code itself when visualized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Y gate QSphere ](img/B18420_06_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Y gate QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: The Y gate, as we can see from the results, operates very similarly to the X
    gate, at least when the origin of the state vector is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s proceed to the final Pauli gate.
  prefs: []
  type: TYPE_NORMAL
- en: Z gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Z gate** is also commonly referred to as a **phase gate**, mostly because
    rather than rotating along the vertical axis as the X and Y gates do, the Z gate
    rotates along the longitude of the Hilbert space, hence the phase of the Hilbert
    space. This is denoted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_060.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *z* axis by ![](img/B18420_06_041.png) (180°). If the rotation initializes
    from the ![](img/B18420_06_015.png) basis state, then the phase does not change;
    however, if the input initializes from the ![](img/B18420_06_018.png) state, then
    the output is a phase shift of *p* to ![](img/B18420_06_064.png). This negation
    is a very important feature that you will see in many quantum algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.6 – Truth table of a phase shift around the x axis  ](img/Table_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.6: Truth table of a phase shift around the x axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a circuit for the Z gate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we place the qubit into a superposition state using the H gate, and
    then add a Z gate operator to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit. Note that depending on
    how you have things set up, the very small values may be truncated to 0\. If this
    is not set, you may see a very small value, such as `0.00000000e+00j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the Z gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the H gate removed, so don’t think you
    have to include the H gate in order to use the Z gate—as mentioned earlier, the
    H gate was just added to illustrate the operational effect of the gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Circuit diagram with a Z gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state between
    ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png); however, it is on the
    negative side of the *x* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing dome, building  Description automatically generated](img/B18420_06_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.14: Z gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has an equal probability of being |![](img/B18420_06_027.png)
    and |![](img/B18420_04_055.png); however, the |![](img/B18420_04_055.png) state
    you see is out of phase by ![](img/B18420_06_041.png), as illustrated in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.15: Z gate QSphere representation after first applying an H gate'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, the Z gate provides a way to perform
    a phase shift on a qubit, causing the state of the qubit to change its sign from
    positive to negative. If you want to see this for yourself, then try the following.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the code you ran earlier to execute an X gate. In that example, we started
    with the qubit initially at the basis state |![](img/B18420_06_027.png), and we
    then applied an X gate that resulted in the state |![](img/B18420_04_055.png).
    Now, add another line after adding the X gate and include the Z gate. You’ll notice
    that the result is the same, |![](img/B18420_04_055.png), only now you’ll notice
    that the state result is negative. I’ll leave it to you to try it out for yourself
    and observe the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next section, where we will discuss **phase gates**.
  prefs: []
  type: TYPE_NORMAL
- en: Phase gates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Phase gates are what we use to map |![](img/B18420_04_055.png) to ![](img/B18420_06_075.png)|![](img/B18420_04_055.png),
    where ![](img/B18420_06_075.png) is Euler’s equation. This does not have an effect
    on the probability of measuring a |![](img/B18420_06_027.png) or a |![](img/B18420_04_055.png);
    however, it does affect the phase of the quantum state. This may not make sense
    just yet, but once you start learning about some advanced features that leverage
    phase shifts, it will be very clear. For now, let’s learn about the gates that
    operate the various phase shifts on a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: S gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **S gate** is like a Z gate; the only difference is the amount by which
    the state vector is rotating. For the S gate, that rotation is ![](img/B18420_06_029.png).
    The matrix representation of the S gate is described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_081.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *z* axis by ![](img/B18420_06_029.png) (90°), hence if the input is
    |![](img/B18420_04_055.png), then the output is a phase shift of ![](img/B18420_06_084.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.7 – Truth table representing phase rotation S  ](img/Table_06_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.7: Truth table representing phase rotation S'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow these steps to create a circuit with an S gate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The truth table is best illustrated by placing the vector onto the *x* axis
    first; we will add an H gate first before appending the S gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the S gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram where we added an H gate to induce superposition
    and then apply the **S** gate to the qubit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Circuit with a S gate ](img/B18420_06_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.16: Circuit with an S gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_06_015.png)or
    ![](img/B18420_06_018.png) but with a phase shift of ![](img/B18420_06_087.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, building, dome, aircraft  Description automatically
    generated](img/B18420_06_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.17: S gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has an equal probability of being ![](img/B18420_06_015.png)
    and ![](img/B18420_06_018.png) with a phase shift of ![](img/B18420_06_087.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, radar chart  Description automatically generated](img/B18420_06_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.18: S gate, ![](img/B18420_06_029.png) phase rotation on the QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: As the S gate transitions the state to the positive Z axis by ![](img/B18420_06_029.png),
    we will now see how to transition the state to the negative Z axis by ![](img/B18420_06_029.png).
  prefs: []
  type: TYPE_NORMAL
- en: S† (dagger) gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ![](img/B18420_06_094.png) gate is the same as the S gate, except it rotates
    in the opposite, or negative, direction. Hence the results are the same, but negated.
    The matrix representation illustrates this by including the negative in the phase
    shift:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_095.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *z* axis by ![](img/B18420_06_096.png) (-90). As with the S gate, if
    the input is the ![](img/B18420_06_015.png) state, then the output is ![](img/B18420_06_015.png),
    but if the input is the ![](img/B18420_06_018.png) state, the output is a phase
    rotation in the negative direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.8 – Truth table representation of phase gate  ](img/Table_06_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.8: Truth table representation of phase gate ![](img/B18420_06_100.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is best illustrated by placing the qubit into a superposition first with
    an H gate. We then create a circuit diagram for ![](img/B18420_06_094.png) gate
    by using these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an H gate first before appending the ![](img/B18420_06_094.png)
    (`sdg`) gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the ![](img/B18420_06_094.png) gate, run the
    following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the ![](img/B18420_06_094.png) gate
    added to the qubit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Circuit with a  gate ](img/B18420_06_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.19: Circuit with an ![](img/B18420_06_094.png) gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_06_015.png) or
    ![](img/B18420_06_018.png) with a phase shift of ![](img/B18420_06_108.png) or
    ![](img/B18420_06_096.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing dome, building  Description automatically generated](img/B18420_06_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.20: ![](img/B18420_06_094.png) gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has an equal probability of being ![](img/B18420_06_015.png)
    and ![](img/B18420_06_015.png) with a phase shift of ![](img/B18420_06_108.png)
    or ![](img/B18420_06_096.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.21: ![](img/B18420_06_094.png) gate, ![](img/B18420_06_096.png) phase
    rotation on the QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the circuit with an ![](img/B18420_06_094.png) gate
    and can shift the phase of the qubit in opposite directions and are not limited
    to a single direction to apply phase shifts, we will move on to the next section,
    which will help us understand how to create a circuit with a T gate.
  prefs: []
  type: TYPE_NORMAL
- en: T gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **T gate** is the same as the S gate, only the rotation is ![](img/B18420_06_118.png).
    The matrix representation of the gate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_119.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *z* axis by ![](img/B18420_06_118.png) (45°), hence if the input is
    the ![](img/B18420_06_015.png) state, then the output will be the same. If the
    input is ![](img/B18420_06_018.png), however, then the output would be a phase
    rotation of ![](img/B18420_06_118.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.9 – Truth table representation of phase gate T  ](img/Table_06_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.9: Truth table representation of phase gate T'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all phase gates, it’s best to begin in a superposition state, so we
    will start by including a Hadamard gate, then we will create a circuit using the
    T gate, as illustrated in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add an H gate before appending the T gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the T gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the **T** gate added to the qubit, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Circuit representation of the T gate ](img/B18420_06_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.22: Circuit representation of the T gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_05_004.png) or
    ![](img/B18420_05_005.png), and transitioned the phase of the state by ![](img/B18420_06_118.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing dome, building  Description automatically generated](img/B18420_06_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.23: ![](img/B18420_06_094.png) gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has transitioned the phase of the state by ![](img/B18420_06_118.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.24: T gate, ![](img/B18420_06_118.png) phase rotation on the QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the S gate, we will want to rotate in all directions, so let’s take
    a look at a phase gate that transitions the state of the qubit in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: T† (dagger) gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ![](img/B18420_06_130.png) gate has the same phase rotation as the T gate,
    that is, ![](img/B18420_06_118.png), only in the opposite direction. Its matrix
    representation is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_132.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following truth table illustrates that the operation rotates the input
    around the *z* axis by ![](img/B18420_06_133.png) (-45 °), so if the input is
    |![](img/B18420_06_027.png), then the output is |![](img/B18420_06_027.png). If
    the input is |![](img/B18420_04_055.png), then the output is a negative rotation
    of ![](img/B18420_06_133.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.10 – Truth table representation of phase gate  ](img/Table_06_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.10: Truth table representation of phase gate ![](img/B18420_06_138.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This too is best illustrated by placing the vector onto the *x* axis first,
    so we will create a circuit using the ![](img/B18420_06_130.png) gate by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add an H gate before then appending the ![](img/B18420_06_130.png)
    (`tdg`) gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit, where you will notice
    that the imaginary number is now negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the ![](img/B18420_06_130.png) gate, run the
    following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the ![](img/B18420_06_130.png) gate
    added to the qubit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_06_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.25: Circuit representation using a ![](img/B18420_06_130.png) gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_05_004.png) or
    ![](img/B18420_05_005.png), and has transitioned the state of the qubit by ![](img/B18420_06_133.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing building, dome  Description automatically generated](img/B18420_06_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.26: ![](img/B18420_06_130.png) gate, ![](img/B18420_06_133.png) phase
    rotation on the Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has transitioned the state of the qubit by ![](img/B18420_06_133.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.27: ![](img/B18420_06_130.png) gate, ![](img/B18420_06_133.png) phase
    transition on the QSphere'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding gates, as you might have noticed, have predetermined rotation
    angles from the horizontal or vertical axis to help you set the state of the qubit.
    If you wish to specify the angle of rotation yourself, the following rotation
    gates allow you to specify the angle by which to rotate around a given axis. Like
    the other gates, these rotation gates are also reversible and unitary.
  prefs: []
  type: TYPE_NORMAL
- en: Rx gate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of **Rx gates** as your custom rotation gates. Note that I used
    the term *rotate* and not *flip*. This is because visualizing the operation of
    the quantum gates is usually done via the QSphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its spherical presentation, we refer to operations as rotations
    around the axis by ![](img/B18420_06_152.png) (we will see this clearly in the
    following code examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_153.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By applying a Y rotation, we get the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_154.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, a Z rotation will yield the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_155.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll create a circuit using one of the rotation gates – let’s go with the
    Rz gate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will rotate along the *z* axis by ![](img/B18420_06_156.png). We’ll
    be using the `math` library to `import` `pi`, and our friendly H gate will be
    applied to help illustrate the phase shift:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we examine the state vector results by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the state vector values of the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the Rz gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This displays the circuit diagram with the **Rz** gate added to the qubit,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B18420_06_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.28: Circuit representation using an Rz gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed into a superposition state, which
    means it will have an equal probability result of ![](img/B18420_05_004.png) or
    ![](img/B18420_05_005.png) and has rotated the state by a phase of ![](img/B18420_06_156.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing building, dome  Description automatically generated](img/B18420_06_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.29: RZ gate Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the QSphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The QSphere, as you can see, has transitioned the state by a phase of ![](img/B18420_06_156.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.30: RZ gate QSphere transitioned phase of π/6'
  prefs: []
  type: TYPE_NORMAL
- en: These rotation gates help us provide specific gate rotations around each axis.
  prefs: []
  type: TYPE_NORMAL
- en: There are other universal gates that imitate the function of a custom gate using
    a more general alternative, so let’s review them next.
  prefs: []
  type: TYPE_NORMAL
- en: Universal U gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **U gate**, as mentioned earlier in the book, is used in order to define
    a universal quantum system where you would need to ensure that the quantum system
    adheres to certain criteria, the most popular of which are the **DiVincenzo criteria**
    one of which states that it should have a universal set of quantum gates.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how, in a classical system, both NOR and NAND gates are considered
    classical universal gates. In a quantum system, the **U** gate is defined as a
    universal gate, due to its ability to provide multiple degrees of freedom to rotate
    about the Hilbert space of a qubit. The U gate has parameter fields that determine
    how much the state vector should move along the given axis. Let’s look at them
    individually first, and then we’ll apply each gate to a qubit to examine the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **U** gate has three parameters that are applied as rotations on all axes,
    that is, the *x* axis, *y* axis, and *z* axis, respectively. The matrix representation
    of the U gate is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_161.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding equation, ![](img/B18420_06_162.png), ![](img/B18420_06_163.png),
    and ![](img/B18420_06_164.png) are the angles of rotation in radians as described
    in the preceding ![](img/B18420_06_165.png) equation. Note that for the U gate
    to remain a unitary operation, that is, ![](img/B18420_06_166.png), the angles
    must be confined to the range ![](img/B18420_06_167.png), and ![](img/B18420_06_168.png).
    We can also see these ranges in the U matrix, where these values lie in the arguments
    of the matrix, which leaves the phase l to also have a range of ![](img/B18420_06_169.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a circuit that implements the U gate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a single-qubit circuit and apply the U gate to it with
    each angle set to ![](img/B18420_06_029.png). We’ll reuse our state vector helper
    function, `execute_circuit_sv`, so we can extract the state vector results, and
    the QSphere to visualize the state vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result value we shall see is set to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that for convenience, I replaced the value `4.32978028e-17` from the results
    with a `0`, because the number is too small and insignificant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected circuit diagram for **U** is as follows, with the parameters listed
    at the bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing diagram  Description automatically generated](img/B18420_06_31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.31: The U gate set with all rotation parameters to ![](img/B18420_06_029.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to view the Bloch sphere representation, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Bloch sphere representation has changed so that the state is set after all
    parameters have applied the specified rotation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, building, dome  Description automatically generated](img/B18420_06_32.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.32: U gate, Bloch sphere representation with all parameters set to
    ![](img/B18420_06_029.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The QSphere representation, produced by executing the `qsphere` command, is
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_06_33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.33: The QSphere representation of the U gate set with all parameters
    to ![](img/B18420_06_029.png)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can apply various angles to the U gate in order to set the
    state of the qubit into any point in the Hilbert space. This also allows you to
    initialize the state of a qubit using the U gate to set the state.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know that single-qubit gates provide many ways to create a complex linear
    combination of their basis states, but manipulation of a single qubit alone is
    not enough to carry out the functionality that most quantum algorithms require.
    One such example is **quantum entanglement**. This is where multi-qubit gates
    come into play. Let’s learn about those in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multi-qubit gates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in *Chapter 5, Understanding the Qubit*, two or more qubits can
    combine their states by their **tensor product**, sometimes referred to as the
    **Kronecker product**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the multi-qubit gates and how they operate
    on the qubits similarly to how single-qubit gates do, which includes them being
    unitary and reversible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the descriptions and examples uniform, the following descriptions of
    the multi-qubit gates will be presented the same way as the single-qubit gates.
    We will open the helper file again and review another function titled `execute_circuit_returns`.
    The helper function will have a few differences, the first of which will be the
    Qiskit primitive Sampler to run our circuits. We are using this for now so that
    you don’t use up your quantum hardware allotted time on these simple circuits.
    Save the hardware for the fun work later in this book. Also, just like the previous
    helper function we used for single qubit gates, this will return multiple values
    including: total counts, circuit diagram, and histogram (or distribution) of results.
    Let’s review the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of switching over to the Sampler primitive is not that we can’t
    use the state vector simulator; it’s primarily so we can observe some of the interesting
    characteristics of our circuit and the gates. For those who wish to use the state
    vector simulator, do not worry. There will be some challenges in the *Questions*
    section at the end of this chapter that will allow you to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference you will see is that we are no longer using the Bloch sphere
    or QSphere to visualize the quantum states. Rather, we will replace them with
    a `histogram` plot of the quasi-distribution, which is a dict-like class for representing
    the quasi-probabilities. For each circuit we will be creating, we will include
    more than one qubit, as these multi-qubit gates all operate on two or more qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have reviewed our helper function, let’s move on to the next set
    of gates, the **multi-qubit gates**, **specifically 2-qubit gates**. These include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **CNOT** gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Toffoli** gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Swap** gate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn about these gates in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: CNOT two-qubit gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **CNOT gate**, often referred to as a **Control-NOT** gate, is similar to
    the **XOR** classical-bit gate in that if you provide two input states of either
    0 or 1, the results will be the same as if the input states were run through an
    XOR gate. The CNOT gate is composed of two parts.
  prefs: []
  type: TYPE_NORMAL
- en: The first part is the **Control**, which is connected to one of the qubits,
    and is what triggers the CNOT gate to perform an operation on the other qubit
    connected to the other end of the CNOT gate, the **Target**.
  prefs: []
  type: TYPE_NORMAL
- en: The Target is an operation that will be performed on the other qubit; in this
    case, it’s a **NOT** operation. Recall from the previous section on single-qubit
    gates that the NOT gate rotates the qubit about the *x* axis by ![](img/B18420_06_041.png).
    The CNOT gate is one of the more commonly used multi-qubit gates as it is how
    qubits get entangled.
  prefs: []
  type: TYPE_NORMAL
- en: The CNOT gate is also described as a **Control-X** (**CX**) gate since the target
    is often coded as an X operation. You will see this CX gate convention when running
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The matrix representation of a CNOT gate is a *4 x 4* matrix due to the tensor
    product of two qubits, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_175.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the top-left *2 x 2* quadrant of the CNOT matrix represents an Identity
    matrix, I, and the bottom-right *2 x 2* quadrant represents the **X** matrix.
    This matrix describes the state when the first qubit, q[0], is the Target and
    the second qubit, q[1], is the Control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following truth table illustrates that when the Control qubit (the left
    side of the input vector) is 0, there is no change to the Target qubit (the right
    side of the input vector). When the Control qubit is set to 1, then the Target
    qubit operation is enabled and therefore rotates the Target qubit around the *x*
    axis by π (that is, 180°):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.11 – Truth table representation of CNOT gate ](img/Table_06_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 6.11: Truth table representation of CNOT gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a circuit, add a CNOT gate, and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by creating a two-qubit quantum circuit and applying a Hadamard
    gate on the first qubit, and a CNOT gate on the two qubits, where the Control
    is set to the first qubit and the Target is set to the second qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will review the result counts by running the following cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the count results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To draw the circuit diagram for the CNOT gate, run the following in a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following circuit diagram illustrates the CNOT gate, where the Control
    is q[0] and the Target is q[1]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_06_34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.34: Circuit representation using a CNOT gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the histogram results with the counts after executing the previous
    circuit, enter the following into a cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following illustrates the results including an H gate. The following graph
    shows the probabilities of the results being either 00 or 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_06_35.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.35: Histogram representation of CNOT results from circuit, where the
    y axis represents the quasi-probabilities of the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The results from the previous circuit illustrate how the CNOT gates can be used
    to entangle two qubits, where one qubit can control the operation of another qubit,
    in this case, applying a NOT gate to the target qubit.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, I will clarify what the entanglement of multiple qubits
    means. There are other Control gates that implement other operations, such as
    **Control-Y** (**CY**), **Control-Z** (**CZ**), **Control-H** (**CH**), and more.
    These gates all share the same characteristics as the CNOT (**CX**, **Control-X**)
    gate in that they have a Source and Target. The main difference, as you can imagine,
    is the operation that the Target would follow. For the CNOT gate, the Target would
    operate with an X gate, and naturally, a Control-Y gate would operate a Y gate
    on the Target qubit. Try out a few for yourself and see how the results differ.
    Notice that the operations will be the same as if you run the single gate to the
    Target gate.
  prefs: []
  type: TYPE_NORMAL
- en: The last multi-qubit gate we will focus on, which is also used in a variety
    of quantum algorithms, is the **Toffoli** gate.
  prefs: []
  type: TYPE_NORMAL
- en: Toffoli multi-qubit gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Toffoli** gate is named after Tommaso Toffoli, an Italian-American professor
    in computer and electrical engineering at Boston University. This gate is very
    similar to the multi-qubit Control gates mentioned earlier, only this gate has
    multiple Controls and a single Target, which in this case is a NOT gate. To simplify
    the description of multi-control gates, they are written out in the following
    format: **CCX**. This is to indicate it is a dual-controlled Control-Not gate,
    and a **CCCX** is a triple-controlled Control-Not gate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general matrix representation of a Toffoli gate is an *8 x 8* matrix because
    of the tensor product of three qubits, as illustrated in the following matrix.
    Notice that the first three diagonal *2 x 2* matrix blocks are the Identity matrix
    and the last *2 x 2* matrix (bottom right) is a NOT gate representation that flips
    the qubit. Note that the matrix for the Toffoli gate in Qiskit is slightly different
    as it increases the matrix size by 2^n, where *n* is the number of qubits onto
    which the gate is applied. In this case, we have 2³ since we have a three-qubit
    gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s run this gate to see the results of it on our quantum circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by creating a three-qubit quantum circuit and applying a `CCX`
    (Toffoli) gate, where the first two qubits are the control qubits, and the third
    qubit is the target qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of executing this circuit will be no surprise, and consists of 8
    possible states since we are running everything on a three-qubit circuit, which
    means 2³ basis states, where the last state, 111, is the only one set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s visualize the Bloch sphere in a new cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![A picture containing text, dome, building  Description automatically generated](img/B18420_06_36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.36: Bloch sphere representation from the Toffoli (CCX) gate circuit
    results'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let’s see our results on the QSphere with the `qsphere` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, dome  Description automatically generated](img/B18420_06_37.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.37: Qsphere representation from the Toffoli (CCX) gate circuit results'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the above results, the final state is ![](img/B18420_06_177.png),
    as expected, since the qubits all start in the ![](img/B18420_06_178.png) state,
    but as the control qubits are each set to ![](img/B18420_05_005.png), this sets
    the target qubit, a NOT gate, to enable and, therefore, change the state of the
    target qubit q[2] to the ![](img/B18420_05_005.png) state, therefore rendering
    the results ![](img/B18420_06_177.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit diagram for the Toffoli gate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.31 – Circuit representation of a Toffoli (CCX) gate ](img/B18420_06_38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.38: Circuit representation of a Toffoli (CCX) gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the base gates are used to create this three-qubit gate. In a
    new cell, run the `decompose` function of the quantum circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will result in the following illustration of all the gates needed to create
    a single Toffoli gate. Note that this may be different as this was how it was
    displayed at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.32 – Gates necessary to create a Toffoli (CCX) gate ](img/B18420_06_39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.39: Gates necessary to create a Toffoli (CCX) gate'
  prefs: []
  type: TYPE_NORMAL
- en: This looks very complicated. You can see that the use of the various single-qubit
    and multi-qubit gates used to represent this one gate are quite complex. In this
    example, you can see the use of H, CNOT, and ![](img/B18420_06_130.png) gates.
    There are other multi-qubit gates that leverage single and two-qubit gates in
    order to operate. The Toffoli gate allows us to operate on multiple qubits, which
    we shall see later on when we start to delve into quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a gate we would use to swap information between one qubit and
    another.
  prefs: []
  type: TYPE_NORMAL
- en: Swap gate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **swap gate** is used to swap two qubit values. The matrix representation
    of the swap gate is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_183.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s create a circuit and implement this by swapping two qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set the first qubit to the ![](img/B18420_06_015.png) state and the
    second qubit to the ![](img/B18420_06_018.png) state. Then, we will invoke a swap
    between the two using the `swap` gate and verify the results of each qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By viewing the resulting diagram of the circuit (`img`) you will see a circuit
    diagram of the swap gate as shown here, just after the X gate we included for
    comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.33 – Circuit diagram of an X gate followed by a Swap gate ](img/B18420_06_40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.40: Circuit diagram of an X gate followed by a Swap gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before viewing the Bloch sphere and QSphere result for each qubit, let’s take
    a moment to review what we expect to see. Our two qubits are first initialized
    to the ![](img/B18420_06_015.png) state, and we then applied an X gate to the
    second qubit (q1) to change its state to ![](img/B18420_06_018.png). Finally,
    we added a Swap gate to swap the value of q[0] and q[1], which would result in
    ![](img/B18420_06_188.png) and ![](img/B18420_06_189.png). Let’s see the results
    of both the Bloch sphere and QSphere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, dome, building  Description automatically generated](img/B18420_06_41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.41: Bloch sphere representation of a Swap gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the results you see swap the value of one qubit with the other, which
    ends up with qubit 0 with the value we set or qubit 1, and vice versa. Let’s now
    look at the QSphere results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_06_42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.42: QSphere representation after applying the Swap gate'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent! The results, as we can see in the previous diagram, show that the
    state vectors for both qubits are set as expected, with ![](img/B18420_06_188.png)
    and ![](img/B18420_06_191.png).
  prefs: []
  type: TYPE_NORMAL
- en: This is a good opportunity to describe how the order of the qubit results is
    displayed in the Bra-Ket notation. Note from the values in the QSphere in the
    previous figure that the qubit at position 0 (the right-most value) is set to
    one and the qubit at position 1 is set to zero. This is the Bra-Ket qubit order.
    As more qubits are added, they are therefore appended to the left of the previous
    qubits, for example, ![](img/B18420_06_192.png)
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about multi-qubit gates, namely, CNOT and Toffoli
    gates. We also learned about an extra gate, that is, the Swap gate.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with single-qubit and multi-qubit gates, let’s review
    the non-reversible measurement operators.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the measurement operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **non-reversible operator** is an operator that is applied on a qubit(s),
    and if applying the same operator again on the same qubits, then the results will
    not return the qubits to the same state that they had prior to applying the operator.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover the non-reversible operators, specifically the measurement
    operator, and the reasons why they are just as important as the other operators
    discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Measurement** is an operator that instructs the quantum system to measure
    the quantum state of the system. Before we dive into how we include the measurement
    instruction in our quantum circuits, let’s first define what is meant by measuring
    the quantum state of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that measurement outcomes are in general probabilistic. What we lose in
    information is the complex amplitude of each computational basis state, into which
    we can encode information. At best, we can rerun and measure the circuit multiple
    times to at least get statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from quantum mechanics that the information about a quantum system
    is impossible to access, specifically the measurement of the qubit’s complex amplitudes.
    For example, let’s say that we have a qubit in a superposition state ![](img/B18420_06_193.png),
    where the complex amplitudes sum to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_06_194.png)'
  prefs: []
  type: TYPE_IMG
- en: A measurement of the preceding cannot provide the complex amplitude information
    in ![](img/B18420_06_195.png). What the measurement of a qubit returns is the
    basis ![](img/B18420_06_196.png) with a probability ![](img/B18420_06_197.png)
    of the state ![](img/B18420_06_193.png) in the standard basis.
  prefs: []
  type: TYPE_NORMAL
- en: We viewed an example of this earlier when describing the Hadamard gate. When
    we set the qubit in a complex linear combination of a|![](img/B18420_06_027.png)
    and b|![](img/B18420_04_055.png), where a and b are the complex amplitudes of
    the basis states, the measurement result was based on the probability ![](img/B18420_06_201.png)
    of measuring ![](img/B18420_06_015.png) and ![](img/B18420_06_203.png) of measuring
    |![](img/B18420_04_055.png), which for a Hadamard gate results in 50%, or ![](img/B18420_06_205.png).
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note about measuring the state of a system is that once
    you measure it, the quantum information of the system is lost. What this means
    is that by measuring the qubit(s), the state will collapse into one of the two
    basis states, ![](img/B18420_06_015.png) or ![](img/B18420_06_018.png), based
    on the amplitude of the components, ![](img/B18420_06_195.png) and ![](img/B18420_06_209.png),
    of the quantum state. After the measurement, you no longer have the information
    contained in a and b to do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to try to measure the same qubit that you just measured, the result
    will be the same as the first measurement but will not set the qubit back to the
    quantum state in which it was prior to the measurement. Therefore, measurement
    is a non-reversible operator.
  prefs: []
  type: TYPE_NORMAL
- en: Once the measurement is completed, the result is then sent over to the classical
    bit, which will return the information back to the classical system. Now that
    we understand how the measurement works and what the results of the measurements
    are, let’s run some code to see it at work!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a Bell state circuit (we covered these in detail
    in *Chapter 4*, *Understanding Basic Quantum Computing Principles*), which contains
    a Hadamard followed by a CNOT gate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add the measurement function, `measure_all(),` at the end of
    the circuit, which will automatically map the results of measuring the qubits
    to their respective classical bits. We will also add Hadamard and CNOT gates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now view our results by entering the following in a new cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Our helper function also included the `histogram` plot, which helps visualize
    the preceding results. To view the histogram, enter the following into the next
    cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is the following histogram plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_06_43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.43: Histogram chart of measured results'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s see what the circuit looks like with the measurement operators added.
    Run the following in another cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the end of the circuit illustrated in the following diagram, you will see
    that the measurement operators were added to all qubits. You’ll see that the labels
    for the classical bits are titled **measure**, and the qubits are mapped to their
    respective bits labeled by the index numbers where the measurement terminates
    onto the classical bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.36 – Measurement operators added to a quantum circuit ](img/B18420_06_44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.44: Measurement operators added to a quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: The barrier is added there just for convenience to visualize where the circuit
    operations end and where the measurement will commence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `measure_all()` function is a nice and convenient way to apply measurement
    operators to your quantum circuit. You can also apply a `measurement` operator
    to each qubit separately and at separate times, or you can arrange the mapping
    using a list if you wish to change the assignment of a qubit to a classical bit.
    Let’s rewrite our function again, only this time we’ll add the measurement operators
    individually for the first circuit (`qc1`) and then do the same with the second
    circuit (`qc2`) using a list. This way you can see the various ways in which you
    can apply measurement operators, either to all at once, or just to measure certain
    qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After executing the code, display the two images (`img` and `img2`) in separate
    cells and notice that both circuits appear the same with respect to the measurement
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about non-reversible operators. We also created
    a simple two-qubit circuit using a measurement operator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned all the various ways you can operate on both single
    and multiple qubits. The operations provide various vector states that each qubit
    can rotate into. You also learned how to visualize the gates on a circuit and
    learned to decompose them down to universal gates so you can realize the information
    that is passed onto the quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: You have now understood how these gates operate on qubits. You now have skills
    that will greatly help you understand how gates are used in many quantum algorithms
    to position the vectors in the Hilbert space of each qubit to help resolve various
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the **Quantum Information Science Kit**
    (**Qiskit**), pronounced *kiss-kit* (depending on who you ask, it may also be
    pronounced *kwis-kit*). Qiskit provides, besides many of the objects and functions
    we have been using so far to manipulate qubits, other functionality that helps
    to create quantum algorithms, mitigate against noise found in near-term devices,
    and produce quantum algorithms for users to leverage without having to learn about
    them at the gate level.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the multi-qubit gates, try flipping the Source and Target. Do you see a
    difference when you decompose the circuit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompose all the gates for both single and multi-qubit circuits. What do you
    notice about how the universal gates are constructed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the Toffoli gate where the target is the center qubit of a three-qubit
    circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompose the Toffoli gate. How many gates in total are used to construct it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the Toffoli gate along with a Hadamard gate to a state vector simulator
    and compare the results to that from the Sampler primitive. What differences do
    you see and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you wanted to sort three qubits in the opposite direction, which gates would
    you use and in which order?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_6.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code261762599683826593.png)'
  prefs: []
  type: TYPE_IMG
