<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Geospatial Data</h1></div></div></div><p>In this chapter, we will focus on the data used for geospatial analysis. You will learn more about the nature of geospatial data, and discover some of the major websites you can use to obtain geospatial datasets for free. We will then look at the ways in which you can read and write geospatial data using Python.</p><p>In particular, this chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why having high quality geospatial data is important</li><li class="listitem" style="list-style-type: disc">The various types of geospatial data you are likely to encounter</li><li class="listitem" style="list-style-type: disc">Major sources of freely-available geospatial datasets</li><li class="listitem" style="list-style-type: disc">How to read and write geospatial data using the GDAL/OGR library</li><li class="listitem" style="list-style-type: disc">How to work with Spatial Reference Systems</li><li class="listitem" style="list-style-type: disc">Geospatial data errors and how to fix them</li></ul></div><p>Let's start by looking at why having high-quality geospatial data is important.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Geospatial data quality</h1></div></div></div><p>Imagine that you are writing a <a id="id74" class="indexterm"/>program where you need to display the location of each city and town on top of a raster basemap. You dutifully obtain a nice raster datasource to use for the basemap, and then search the Internet for a source of city and town data. You choose the <a id="id75" class="indexterm"/>
<strong>National Geospatial Intelligence Service</strong> (<strong>NGIS</strong>) website to download a database of place names, which you then draw onto your map. This database includes, among other things, the latitude and longitude of each place name:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Location</p>
</th><th style="text-align: left" valign="bottom">
<p>Latitude</p>
</th><th style="text-align: left" valign="bottom">
<p>Longitude</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Abache</p>
</td><td style="text-align: left" valign="top">
<p>7.3551</p>
</td><td style="text-align: left" valign="top">
<p>7.6407</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Abacheke</p>
</td><td style="text-align: left" valign="top">
<p>5.50372</p>
</td><td style="text-align: left" valign="top">
<p>6.729519</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Abacher</p>
</td><td style="text-align: left" valign="top">
<p>13.816667</p>
</td><td style="text-align: left" valign="top">
<p>20.816667</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Abacheri</p>
</td><td style="text-align: left" valign="top">
<p>14.183333</p>
</td><td style="text-align: left" valign="top">
<p>41.5</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Abachi</p>
</td><td style="text-align: left" valign="top">
<p>7.3551</p>
</td><td style="text-align: left" valign="top">
<p>7.6407</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>...and so on</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>So far so good, but when your<a id="id76" class="indexterm"/> program is complete, the locations look suspiciously regular when the user zooms in on your map:</p><div><img src="img/B04102_02_01.jpg" alt="Geospatial data quality"/></div><p>If you were to draw a grid on top of this map, you can see exactly what the problem is:</p><div><img src="img/B04102_02_02.jpg" alt="Geospatial data quality"/></div><p>As you can see, the<a id="id77" class="indexterm"/> locations are regularly spaced—despite there being lots of precision in the latitude and longitude values, they are actually only accurate to about two decimal places. In the previous image, which shows part of the Netherlands, this can misplace the location by almost a kilometer.</p><p>This is just one example of the type of thing that can go wrong if you don't use high-quality geospatial data. Another example often crops up when performing <a id="id78" class="indexterm"/>
<strong>point-in-polygon</strong> calculations—that is, when attempting to decide if a given point is inside or outside a given polygon:</p><div><img src="img/B04102_02_03.jpg" alt="Geospatial data quality"/></div><p>If the polygon represents, for example, the outline of a country, then you can use a point-in-polygon calculation to see if the given location is inside the country's border. This is often used to <a id="id79" class="indexterm"/>
<strong>geolocate</strong> a given point (that is, match a point with one or more known locations).</p><p>Now, when you attempt to <a id="id80" class="indexterm"/>geolocate a point that is close to the edge of the polygon, you can easily end up with geolocation errors if your polygons are not sufficiently detailed:</p><div><img src="img/B04102_02_04.jpg" alt="Geospatial data quality"/></div><p>In the preceding image, the dot represents a point to be geolocated. This point is a valid location within San Francisco, but because the polygon is not detailed enough, the point is outside the San Francisco city polygon, and so the geolocation fails.</p><p>This problem is particularly acute when using polygons that cover larger areas, such as state or country outlines. Because of the size of the polygon in these cases, precision is often sacrificed.</p><p>You might think that the answer to this problem is to have a more detailed polygon—that is, to use more points to make up the polygon's outline so that it more accurately represents the desired outline (in this case, the San Francisco coastline). However, more detail is not always better. The more detailed a polygon is, the longer it will take to process—and if there are too many points, your program might crash because of the excessive amount of data that you are trying to process.</p><p>There are ways to solve this<a id="id81" class="indexterm"/> problem; for example, by breaking large polygons into smaller pieces, or by <strong>buffering</strong><a id="id82" class="indexterm"/> the polygon to include points close to the edge. But the important thing to realize is that high-quality data does not always mean highly precise data; it means data that is <em>appropriate</em> to the purpose you want to use it for.</p><p>We will now continue our exploration of geospatial concepts by looking at the various types of geospatial data you are likely to encounter.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Types of geospatial data</h1></div></div></div><p>In the previous<a id="id83" class="indexterm"/> chapter, we looked briefly at some of the more common formats used to store and transfer raster and vector geospatial data. Let's now look at some of the more important types of geospatial data you are likely to encounter.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Shapefiles</h2></div></div></div><p>As we saw in the <a id="id84" class="indexterm"/>previous chapter, a <a id="id85" class="indexterm"/>shapefile is a collection of files on disk, which together hold a set of geospatial features along with their attributes and geometries. For example, the following illustration shows the data stored in a typical shapefile:</p><div><img src="img/B04102_02_05.jpg" alt="Shapefiles"/></div><p>Because the shapefile format has been around for many years, and dates back to the dBase days, a single shapefile is made up of several individual files. Typically, these files are combined into a ZIP archive for distribution.</p><p>Shapefiles are<a id="id86" class="indexterm"/> hugely <a id="id87" class="indexterm"/>popular because they make it so easy to store and distribute geospatial data. Practically every GIS system and library that works with geospatial data is able to understand the shapefile format.</p><p>Shapefiles, however, do have some<a id="id88" class="indexterm"/> disadvantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unlike almost every other geospatial data format, the names of the attributes within a shapefile are case sensitive. This can cause problems when your code works with data in another format (for example, in a database), but suddenly stops when you attempt to access the attributes within a shapefile.</li><li class="listitem" style="list-style-type: disc">All the geometries stored in a single shapefile must be of the same type. This means, for example, that you can't have some features represented by a line while other features are represented by points. More seriously, this causes problems when working with composite geometries such as MultiLines or MultiPolygons, or when attempting to store geometry collections within a shapefile.</li><li class="listitem" style="list-style-type: disc">While shapefiles <a id="id89" class="indexterm"/>allow you to read through the features sequentially, there<a id="id90" class="indexterm"/> is generally no support for spatial indexing. This means that you cannot perform searches based on a feature's position on the Earth's surface. For example, answering questions such as "which countries are within 1,000 km of London?" requires you to check each feature in turn, which is not particularly efficient.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Well-known text</h2></div></div></div><p>The <strong>well-known text</strong> (<strong>WKT</strong>)<a id="id91" class="indexterm"/> format is not <a id="id92" class="indexterm"/>generally used to store geospatial data. Instead, it is used to transfer geometries from one format to another. We saw an example of this in the previous chapter, where we extracted a geometry using the OGR library, and then converted it into WKT so that we could recreate it as a Shapely geometry object.</p><p>WKT is a very compact and easy-to-use format. For example, the following WKT string defines a point geometry in the middle of Central Park in New York City:</p><div><pre class="programlisting">POINT(-73.967344 40.782148)</pre></div><p>As you can see, the point is represented as an <em>x</em> (longitude) value, a single space, and then the <em>y</em> (latitude) value. The same general format is used to represent the coordinates of a polygon. For example, the following is a polygon in WKT format, this time defining the approximate outline of Central Park:</p><div><pre class="programlisting">POLYGON((-73.973057 40.764356, -73.981898 40.768094, -73.958209 40.800621, -73.949282 40.796853, -73.973057 40.764356))</pre></div><p>Apart from using WKT to transfer data between different systems and libraries, you will also find WKT strings handy when you need to quickly hardwire a geometry into your Python code. For example, the following code shows how you could quickly create a Shapely polygon for testing:</p><div><pre class="programlisting">p = shapely.wkt.loads("POLYGON((23.4 38.9, 23.5 38.9, 23.5 38.8, 23.4 38.9))")</pre></div><p>The WKT format is also <a id="id93" class="indexterm"/>useful if you want to store geometry data<a id="id94" class="indexterm"/> in a text file, for example to temporarily save the output of your analysis to disk so you can load it into another program for further processing.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Well-known binary</h2></div></div></div><p>The <strong>well-known binary</strong> (<strong>WKB</strong>)<a id="id95" class="indexterm"/> format is the binary <a id="id96" class="indexterm"/>equivalent of WKT. WKB is generally only used to transfer and store geospatial data within a database. In the WKB format, the coordinates are stored as double-precision floating-point numbers, and numeric codes are used to represent the type of geometry. This format is quicker for a computer to read and write than WKT, though of course the format can't be comprehended easily by a human.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Spatial databases</h2></div></div></div><p>Just as ordinary <a id="id97" class="indexterm"/>databases are used to store large amounts of data and let users make efficient queries against that data, a <strong>spatial database</strong> is a database which is designed to store geometries and perform efficient queries based on each geometry's position in space. For example, you could quickly find all road traffic incidents that occurred within 20 miles of a given point, or find the closest island to your current location.</p><div><img src="img/B04102_02_06.jpg" alt="Spatial databases"/></div><p>Setting up and using a spatial database is a rather complex task. There are several different types of spatial database available. Among the freely available options, the lightweight <strong>SpatiaLite</strong> database<a id="id98" class="indexterm"/> and the powerful-but-complex <strong>PostGIS</strong> database<a id="id99" class="indexterm"/> are the most popular choices.</p><p>After creating a database, you<a id="id100" class="indexterm"/> will have to configure the database to work with spatial data. You will also need to use the database's own syntax to store and query your spatial data—how you do this will vary depending on which database you use.</p><p>Regardless of the type of database you are using, attempting to retrieve a spatial geometry will generally return either a WKT format string, or raw binary data in WKB format. You can then convert these into a different format (for example, a Shapely geometry object) for processing.</p><p>Of course, with the power available in a spatial database, and particularly the spatial manipulation and query functions built into PostGIS, you may not need to do any spatial analysis beyond what is possible within the database itself. For example, once you have asked the database to identify all the road traffic incidents within a given radius, you would generally just retrieve non-spatial information about each of these incidents. All of the spatial processing is done within the database itself, and once you have found the desired set of records, you would retrieve and work with the results just like you would in a non-spatial database.</p><p>We will return to the topic of spatial databases in <a class="link" href="ch03.html" title="Chapter 3. Spatial Databases">Chapter 3</a>, <em>Spatial Databases</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Geospatial microformats</h2></div></div></div><p>The so-called <strong>geospatial microformats</strong> <a id="id101" class="indexterm"/>are typically used by APIs to send and receive geospatial data. Various companies and organizations have defined their own standards for transmitting geospatial data, and so a number of common formats have been developed over time. If you use an API that uses one of these microformats, you will need to become familiar with these data formats.</p><p>There are two geospatial microformats that we will look at here: <strong>GeoJSON</strong> and <strong>GML</strong>.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec01"/>GeoJSON</h3></div></div></div><p>GeoJSON (<a class="ulink" href="http://geojson.org">http://geojson.org</a>) is <a id="id102" class="indexterm"/>an open <a id="id103" class="indexterm"/>standard used to <a id="id104" class="indexterm"/>represent geospatial data structures as <a id="id105" class="indexterm"/>
<strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) objects. For example, the following GeoJSON-format string is used to represent a point geometry:</p><div><pre class="programlisting">{"type": "Point", "coordinates": [-73.967344, 40.782148]}</pre></div><p>Because GeoJSON is built on top of the JSON standard, you can use the <code class="literal">json</code> standard Python library to convert between GeoJSON-formatted strings and Python dictionaries. This makes it particularly<a id="id106" class="indexterm"/> easy to use GeoJSON in your Python programs.</p><p>The GeoJSON<a id="id107" class="indexterm"/> standard includes support for the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Representing any standard geometry object (Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon and GeometryCollection) as a GeoJSON string.</li><li class="listitem" style="list-style-type: disc">Storing a feature as a GeoJSON string, including the feature's geometry, any number of attributes (called <strong>properties</strong><a id="id108" class="indexterm"/> in GeoJSON), and an optional spatial reference system.</li><li class="listitem" style="list-style-type: disc">Using existing XML schemas and processing tools. Because the GML format is based on XML, you can use existing XML parsers and validators to process GML data. You can also create an application-specific XML schema, defining your own extensions to the GML standard, and then use existing XML libraries to work with that schema.</li></ul></div><p>The GeoJSON format is widely supported by software that works with geospatial data. Indeed, the GDAL/OGR library includes support for reading and writing GeoJSON-format data, as does the Mapnik library we will be using later on to generate maps.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec02"/>GML</h3></div></div></div><p>
<strong>Geography Markup Language</strong> (<strong>GML</strong>) is an XML-based format to store <a id="id109" class="indexterm"/>geometries and features in textual form. GML <a id="id110" class="indexterm"/>is a complex and sophisticated standard. Because it is based on XML, GML-formatted data tends to be quite verbose. For example, the following GML string represents a minimal point geometry:</p><div><pre class="programlisting">&lt;gml:Point&gt;
    &lt;gml:pos&gt;40.782148 -73.967344&lt;/gml:pos&gt;
&lt;/gml:Point&gt;</pre></div><p>GML includes support for the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Representing point, LineString, and polygon geometries.<div><div><h3 class="title"><a id="note04"/>Note</h3><p>Version 3.0 of the GML standard adds support for raster-format data.</p></div></div></li><li class="listitem" style="list-style-type: disc">Defining features, and storing attributes for each feature.</li><li class="listitem" style="list-style-type: disc">Associating more than one geometry with each feature; for example, a feature may have an outline, a bounding box, and a centroid, all defined as geometries associated with the feature.</li><li class="listitem" style="list-style-type: disc">Defining the spatial reference system used by the geometry.</li><li class="listitem" style="list-style-type: disc">Profiles that allow you to use a subset of the GML standard for particular sets of data; for example, the GML Simple Features Profile limits the data to representing geometries and their associated properties.</li><li class="listitem" style="list-style-type: disc">Using existing XML schemas and processing tools because the GML format is based on XML; for example, you could define an application-specific XML schema defining your own extensions to the GML standard, and then use XML parsers and validators on your GML data.</li></ul></div><p>The GML standard<a id="id111" class="indexterm"/> was developed by the <a id="id112" class="indexterm"/>
<strong>Open Geospatial Consortium</strong> (<strong>OGC</strong>), and has now been accepted as an <a id="id113" class="indexterm"/>ISO standard. GML is heavily used by the various web standards defined by the OGC, and you will use GML whenever you want to access an API that follows one of these standards, such as the Web Features Service.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Digital elevation models</h2></div></div></div><p>A <strong>Digital Elevation Model</strong> (<strong>DEM</strong>)<a id="id114" class="indexterm"/> is a fascinating way of representing the curves and contours of the Earth's surface as raster-format data. As we mentioned in the previous chapter, raster-format geospatial data divides the world up into <strong>cells</strong><a id="id115" class="indexterm"/> and associates information with each cell. In a DEM, each cell contains information about the elevation of the Earth's surface at that point. For example, consider the following elevation data, taken from a typical DEM file:</p><div><pre class="programlisting">2874  2871  2874  2933  2995  3022  3028  3031  3035  3031
2874  2871  2874  2933  2992  3012  3025  3028  3031  3028
2871  2871  2877  2932  2989  3007  3018  3025  3023  3020
2872  2871  2886  2935  2975  2997  3010  3020  3022  3023
2871  2879  2903  2942  2965  2991  3005  3015  3022  3026
2871  2887  2930  2972  2992  2998  3013  3023  3029  3031
2880  2899  2941  2992  3005  3005  3021  3028  3033  3039
2896  2920  2956  3000  3013  3019  3019  3028  3037  3042
2915  2939  2981  3008  3017  3026  3028  3028  3036  3044
2928  2952  2986  3024  3029  3034  3038  3034  3031  3044
2936  2960  3009  3040  3044  3046  3049  3044  3037  3044
2943  2977  3041  3051  3051  3051  3051  3051  3037  3046
2960  3029  3051  3051  3051  3051  3051  3050  3044  3049</pre></div><p>This data is extracted from a DEM file for Forked Horn Butte, Oregon. Each number measures the elevation above sea level, in feet. If these elevation values are plotted in three dimensions, the shape of the Earth's surface is revealed, as seen here:</p><div><img src="img/B04102_02_07.jpg" alt="Digital elevation models"/></div><p>This is only a tiny part <a id="id116" class="indexterm"/>of the overall DEM file, but it does show you how DEM files encode the shape of the Earth's surface.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>DEM files also have what is called a <a id="id117" class="indexterm"/>
<strong>no-data value</strong>. This is a special height value that indicates that there is no elevation value at that point. No-data values are used where you don't want to record or show an elevation value for certain parts of the DEM. For example, a country-specific DEM file would use the no-data value for all areas beyond that country's border.</p></div></div><p>A digital elevation model is often used as a building-block to construct useful images of the Earth's surface. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Different colors can be associated with different height bands, using a technique called <a id="id118" class="indexterm"/><strong>color mapping</strong>. If the right set of colors is selected, the result can almost look like a photograph showing different bands of vegetation, bare earth, rock, and snow.</li><li class="listitem" style="list-style-type: disc">A <strong>shaded relief</strong> image<a id="id119" class="indexterm"/> can be generated from the elevation data. This mimics the effect of having a light source (such as the sun) shine onto the Earth's surface, revealing depth and creating shadows and highlights so that the generated image looks almost like a photograph of the Earth taken from space.</li><li class="listitem" style="list-style-type: disc"><strong>Contour lines</strong> can <a id="id120" class="indexterm"/>be generated by smoothing the DEM data and running it through a program such as <code class="literal">gdal_contour</code>, which is provided as part of the GDAL library.</li></ul></div><p>Often, several of these generated images are merged to produce a more realistic-looking effect. These derived images are then used as background maps upon which geospatial data is overlaid.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Raster basemaps</h2></div></div></div><p>Rather than constructing your images<a id="id121" class="indexterm"/> from a DEM file, you can use pre-generated images for your basemaps. These basemaps are often very sophisticated. For example, underwater areas may be drawn using a color map in varying shades of blue to indicate the depth of the water, while the area above sea level is drawn using shaded relief imagery combined with vegetation and elevation-based coloring to produce a realistic-looking effect.</p><p>The following image shows a typical basemap of this type:</p><div><img src="img/B04102_02_08.jpg" alt="Raster basemaps"/></div><p>These basemaps are simply image files with associated georeferencing information. The georeferencing information identifies the area of the Earth covered by the basemap. This is often done by specifying the latitude and longitude for the top-left and bottom-right corners of the image. Using these points, it is possible to position the image accurately on the Earth's surface, allowing <a id="id122" class="indexterm"/>geospatial data to be drawn in the correct position on top of the basemap, and also allowing the correct part of the basemap to be drawn based on which area of the Earth's surface you wish to display.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Multiband raster files</h2></div></div></div><p>As mentioned in the previous<a id="id123" class="indexterm"/> chapter, raster-format geospatial data can store more than just images. The raster information might consist of values such as the elevation (as we saw earlier in the section on Digital Elevation Models), soil type, average rainfall, population density, and the like.</p><p>Raster-format data files are not limited to storing just one piece of information. A single file can hold multiple <strong>bands</strong><a id="id124" class="indexterm"/> of raster data, as shown in the following illustration:</p><div><img src="img/B04102_02_09.jpg" alt="Multiband raster files"/></div><p>Every band has a value for each cell, so for a given (x, y) location, band 1 will hold a value, band 2 will hold a value, and so on. The meaning of the values stored in each band depends entirely on the raster file you are using; you will need to refer to the documentation for that raster file to see what is being stored in each band.</p><p>Sometimes, the multiple bands can be combined to produce a color. For example, you can download raster data captured by <a id="id125" class="indexterm"/>Landsat satellites (see <a class="ulink" href="http://landsatlook.usgs.gov">http://landsatlook.usgs.gov</a> for details) that includes a red, green and blue color component in three separate bands. Additional bands contain infrared and <em>panchromatic</em> values, which can also be useful in certain circumstances.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Sources of freely available geospatial data</h1></div></div></div><p>Now that you understand the <a id="id126" class="indexterm"/>importance of having the appropriate geospatial data and have learned about the major types of data that you will want to use, let's look at some of the places where you can obtain the data you'll need.</p><p>There are some situations where you may need to purchase geospatial datasets. One example of this is when looking for ZIP code boundaries in the USA; this information is proprietary to the<a id="id127" class="indexterm"/> US Postal Service (USPS), and accurate versions can only be obtained by purchasing a suitable dataset from a vendor licensed by the USPS to sell this data. However, this is the exception: in almost every other case, you can obtain, modify, and use geospatial data for free.</p><p>Let's now take a look at some of the major websites you will want to use when looking for geospatial data.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Natural Earth Data</h2></div></div></div><p>The <a id="id128" class="indexterm"/>Natural Earth Data<a id="id129" class="indexterm"/> website (<a class="ulink" href="http://naturalearthdata.com">http://naturalearthdata.com</a>) is a comprehensive source of<a id="id130" class="indexterm"/> high-quality and freely available geospatial data. In terms of vector-format data, files are provided in high, medium, and low resolutions. Two different types of vector data are provided:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Cultural data</strong>: This <a id="id131" class="indexterm"/>includes polygons for country, state or <a id="id132" class="indexterm"/>province, urban areas, and park outlines, as well as point and LineString data for populated places, roads, and railways.<div><img src="img/4102_02_10.jpg" alt="Natural Earth Data"/></div></li><li class="listitem" style="list-style-type: disc"><strong>Physical data</strong>: This includes<a id="id133" class="indexterm"/> polygons and LineStrings for land<a id="id134" class="indexterm"/> masses, coastlines, oceans, minor islands, reefs, rivers, and lakes.<div><img src="img/B04102_02_11.jpg" alt="Natural Earth Data"/></div></li></ul></div><p>In terms of raster-format data, Natural Earth Data provides five different types of raster basemaps at both 1:10 million and 1:50 million scale.</p><div><img src="img/B04102_02_12.jpg" alt="Natural Earth Data"/></div><p>These image files are provided as georeferenced TIFF images, making it easy to use them as raster basemaps in your Python programs.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>OpenStreetMap</h2></div></div></div><p>OpenStreetMap (<a class="ulink" href="http://openstreetmap.org">http://openstreetmap.org</a>) is a <a id="id135" class="indexterm"/>huge collaborative effort to create <a id="id136" class="indexterm"/>and make available geospatial<a id="id137" class="indexterm"/> map data. The website describes it as a "free editable map of the whole world made by people like you". It has positioned itself as a direct competitor to Google Maps. The following image shows part of the street map for the city of Rotorua, New Zealand, based on data from OpenStreetMap:</p><div><img src="img/B04102_02_13.jpg" alt="OpenStreetMap"/></div><p>Unfortunately, OpenStreetMap <a id="id138" class="indexterm"/>uses its own XML-based format to store geospatial data. If you want, you can download the entire OpenStreetMap database, called <code class="literal">Planet.osm</code>, and then use a spatial database to access this information. In most cases, however, you will want to use an extract from the OpenStreetMap database, already converted into a more standard format such as a shapefile.</p><p>You can find a list of sites that provide <a id="id139" class="indexterm"/>OpenStreetMap data extracts at <a class="ulink" href="http://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts">http://wiki.openstreetmap.org/wiki/Planet.osm#Country_and_area_extracts</a>.</p><p>OpenStreetMap can be very useful if you want to manipulate street maps, or use a street map as the backdrop to display other geospatial data.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>US Census Bureau</h2></div></div></div><p>The <a id="id140" class="indexterm"/>United States <a id="id141" class="indexterm"/>Census Bureau has made available a large amount of geospatial data under the name<a id="id142" class="indexterm"/> <strong>TIGER</strong> (<strong>Topologically Integrated Geographic Encoding and Referencing System</strong>). The TIGER datasets include streets, railways, rivers, lakes, geographic boundaries, and legal and statistical areas, such as states, school districts, and urban boundaries.</p><p>TIGER<a id="id143" class="indexterm"/> data is available in shapefile format, and can be downloaded from <a class="ulink" href="http://www.census.gov/geo/maps-data/data/tiger.html">http://www.census.gov/geo/maps-data/data/tiger.html</a>.</p><p>Because it is produced by the US Government, TIGER data only covers the United States and its protectorates (that is, Puerto Rico, American Samoa, the Northern Mariana Islands, Guam, and the US Virgin Islands). For these areas, however, TIGER is an excellent source of accurate geospatial data.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>World Borders Dataset</h2></div></div></div><p>We used this<a id="id144" class="indexterm"/> dataset in the <a id="id145" class="indexterm"/>previous chapter. While it is <a id="id146" class="indexterm"/>very simple, the World Borders Dataset (<a class="ulink" href="http://thematicmapping.org/downloads/world_borders.php">http://thematicmapping.org/downloads/world_borders.php</a>) provides useful country outlines in the form of a shapefile. The shapefile includes attributes for the name of the country, relevant ISO, FIPS, and UN identification codes, a UN-based region and subregion classification, and the country's population and land area.</p><p>The simplicity of the World Borders Dataset makes it an attractive choice for many geospatial applications that need a basic map of the entire world.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>GLOBE</h2></div></div></div><p>The <a id="id147" class="indexterm"/>
<strong>Global Land One-Kilometer Base Elevation</strong> (<strong>GLOBE</strong>) dataset is an international effort to produce high-quality, medium-resolution DEM data covering the entire world. Each cell within the raster DEM file represents the elevation of a square on the Earth's surface which is 30 arc-seconds of longitude and 30 arc-seconds of latitude. This equates to a square measuring approximately one kilometer on each side.</p><p>The main website of the <a id="id148" class="indexterm"/>GLOBE project can be found at <a class="ulink" href="http://www.ngdc.noaa.gov/mgg/topo/globe.html">http://www.ngdc.noaa.gov/mgg/topo/globe.html</a>. Note that if you download one of the premade "tiles" covering an area of the Earth's surface, you will also need to download the associated header (<code class="literal">.hdr</code>) file that georeferences the DEM data. These header files can be downloaded from <a class="ulink" href="http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr">http://www.ngdc.noaa.gov/mgg/topo/elev/esri/hdr</a>.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Since we are going to need some sample DEM data later in this chapter, go ahead and download the <code class="literal">E</code> tile now. Then go to the link provided to download the associated header file. You should end up with two files, named <code class="literal">e10g</code> and <code class="literal">e10g.hdr</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>National Elevation Dataset</h2></div></div></div><p>The <a id="id149" class="indexterm"/>National Elevation Dataset (<a class="ulink" href="http://ned.usgs.gov">http://ned.usgs.gov</a>) provides<a id="id150" class="indexterm"/> high-resolution DEM data for the Continental United States, Alaska, Hawaii, and other US territories. Depending on the area you are looking at, each cell in the DEM dataset corresponds to an area of between 3 and 60 meters square. This is much higher resolution than the 1 kilometer squares used by the GLOBE project.</p><p>The National Elevation Dataset is an excellent choice if you want to produce your own shaded relief basemaps for the USA. All the files are available in a variety of formats, including GeoTIFF and ArcGRID, both of which can be processed using GDAL.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Reading and writing geospatial data using Python</h1></div></div></div><p>Since we will be <a id="id151" class="indexterm"/>using the GDAL/OGR library to access <a id="id152" class="indexterm"/>geospatial data, let's take a closer look at how you <a id="id153" class="indexterm"/>can read and write both vector-format and<a id="id154" class="indexterm"/> raster-format data using this library.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Reading vector data</h2></div></div></div><p>In the previous chapter, we <a id="id155" class="indexterm"/>wrote a simple program that reads the features out of a shapefile. Here is a copy of that program:</p><div><pre class="programlisting">import osgeo.ogr
shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)
for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    feature_name = feature.GetField("NAME")
    geometry = feature.GetGeometryRef()
    geometry_type = geometry.GetGeometryName()
    print i, feature_name, geometry_type</pre></div><p>Let's take a closer look at how this program works, and more generally, how to read vector-format data using the OGR library.</p><p>When reading geospatial data, the <code class="literal">osgeo.ogr.Open()</code> function takes just a single parameter: the name of the dataset to open. The OGR library loops through all of the different drivers it supports until it finds one that is able to read this dataset. The driver then creates a new <code class="literal">OGRDataSource</code> object that provides access to the contents of that dataset, and the <code class="literal">Open()</code> function returns this object to the caller.</p><p>All of this has the effect of setting the <code class="literal">shapefile</code> variable to the OGR datasource. The OGR datasource consists of one or more <a id="id156" class="indexterm"/>
<strong>layers</strong>, each representing a distinct set of data. For example, a <strong>Countries</strong> datasource may have a layer for the country's terrain, a layer containing roads, <a id="id157" class="indexterm"/>another layer with the country's city boundaries, another for regional borders, and so on.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Remember that shapefiles can only have a single layer. To represent these different pieces of information using shapefiles, you would have to have a separate shapefile for each of these different pieces of data.</p></div></div><p>As you can see in the preceding code sample, you use the <code class="literal">GetLayer()</code> method to retrieve a layer from the datasource; the returned object is an instance of the <code class="literal">OGRLayer</code> class. There is also a handy <code class="literal">GetLayerCount()</code> method which returns the number of layers in the datasource.</p><p>Each layer has a <strong>spatial reference system</strong><a id="id158" class="indexterm"/> that tells you how to interpret the individual coordinates within the layer, as well as a list of <strong>features</strong><a id="id159" class="indexterm"/> containing the actual data. Don't worry if you don't know what a spatial reference system is; you will learn all about this in the <em>Dealing with spatial reference systems</em> section later in this chapter.</p><p>We can iterate over the various features within the layer using the <code class="literal">GetFeatureCount()</code> and <code class="literal">GetFeature()</code> methods. As you might expect, each feature is represented by an instance of the <code class="literal">ogr.Feature</code> class.</p><p>Each feature has a unique <strong>ID</strong>, which can be retrieved using the <code class="literal">GetFID()</code> method, as well as a <strong>geometry</strong> and a list of <strong>attributes</strong>. We retrieve the geometry (an instance of <code class="literal">OGRGeometry</code>) using the <code class="literal">GetGeometryRef()</code> method, and we can access the feature's attributes using the <code class="literal">GetField()</code> method.</p><p>Using these various classes and methods, you can iterate over the various features within a vector datasource, retrieving the geometry and attributes (as well as the ID) for each feature in turn. The wonderful thing about all this, though, is that it doesn't matter what format your data is in: you use exactly the same process to read data out of a shapefile as you would use to read it from a spatial database using the OGR library's PostGIS database driver. The OGR library hides all the details of how to read different data formats, and gives you a simple high-level interface to read vector-format data from any datasource.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Writing vector data</h2></div></div></div><p>Writing geospatial <a id="id160" class="indexterm"/>data to a vector-format file is almost as simple as reading it. There are, however, a couple of extra steps you have to take. Let's write a simple Python program that creates a shapefile and then saves some example data into it. This program will teach you all the things you need to know about writing vector-format data using OGR.</p><p>Creating a vector-format dataset using OGR involves the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we create the destination file by selecting an OGR driver and telling that driver to create the new datasource:<div><pre class="programlisting">from osgeo import ogr
driver = ogr.GetDriverByName("ESRI Shapefile")
dstFile = driver.CreateDataSource("test-shapefile")</pre></div></li><li class="listitem">We then create a <strong>spatial reference</strong> object <a id="id161" class="indexterm"/>that defines how the coordinates in the dataset should be interpreted:<div><pre class="programlisting">from osgeo import osr
spatialReference = osr.SpatialReference()
spatialReference.SetWellKnownGeogCS("WGS84")</pre></div><p>As you can see, we use the <code class="literal">osr</code> module to define a spatial reference, and then set it to<a id="id162" class="indexterm"/> the "well-known" spatial reference with the code <code class="literal">WGS84</code>.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>WGS84 is the standard used for latitude and longitude values. We will look at this in detail in the section on <em>Dealing with spatial reference systems</em> later in this chapter.</p></div></div></li><li class="listitem">We then add a layer to the destination file to hold the layer's data:<div><pre class="programlisting">layer = dstFile.CreateLayer("layer", spatialReference)</pre></div><p>As you can see, each layer has its own spatial reference, so we have to pass the spatial reference we defined earlier when we create the layer.</p></li><li class="listitem">The next step is to define the various attributes that the destination file will store for each feature. Let's define a field called <code class="literal">NAME</code>:<div><pre class="programlisting">field = ogr.FieldDefn("NAME", ogr.OFTString)
field.setWidth(100)
layer.CreateField(field)</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Notice that we define the field name in uppercase. This is because we are writing to a shapefile, which has case-sensitive attribute names and typically defines the attributes in uppercase. Using the uppercase attribute names in shapefiles will help avoid problems later on.</p></div></div></li></ol></div><p>This completes the creation of the file itself. Now let's make up some example data and save it into the file. This involves the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's define a simple <a id="id163" class="indexterm"/>polygon to represent the feature's geometry. We'll use the WKT format to make this easy:<div><pre class="programlisting">wkt = "POLYGON((23.4 38.9, 23.5 38.9, 23.5 38.8, 23.4 38.9))"
polygon = ogr.CreateGeometryFromWkt(wkt)</pre></div></li><li class="listitem">We next create the OGR <code class="literal">Feature</code> object that will represent the feature, and set the geometry and attributes as desired:<div><pre class="programlisting">feature = ogr.Feature(layer.GetLayerDefn())
feature.SetGeometry(polygon)
feature.SetField("NAME", "My Polygon")</pre></div></li><li class="listitem">We can then add the feature to the layer:<div><pre class="programlisting">layer.CreateFeature(feature)
feature.Destroy()</pre></div><p>Notice the call to <code class="literal">feature.Destroy()</code>. This may seem odd, but this releases the memory used by the feature, which also happens to write the feature's details into the shapefile.</p></li><li class="listitem">Finally, we close the destination file by calling the <code class="literal">Destroy()</code> method:<div><pre class="programlisting">dstFile.Destroy()</pre></div><p>This closes the destination file and makes sure that everything has been saved to disk.</p></li></ol></div><p>As with reading vector-format data, this code isn't limited to just creating a shapefile. OGR allows you to create geospatial data in many different formats, and you use the same classes and method names no matter what format you are using.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Reading raster data</h2></div></div></div><p>To read raster-format <a id="id164" class="indexterm"/>geospatial data, you use the GDAL library. Let's see how this is done using the DEM data from the <code class="literal">E</code> tile we downloaded earlier.</p><p>Make sure the <code class="literal">e10g</code> and <code class="literal">e10g.hdr</code> files are both in a convenient directory, and then create a Python script in the same directory. We'll start by entering the following in this script:</p><div><pre class="programlisting">from osgeo import gdal
dem_file = gdal.Open("e10g")</pre></div><p>As you can see, we use the <code class="literal">gdal.Open()</code> function to open the raster data file. As we mentioned earlier, a raster datasource can consist of multiple bands of data. To see how many bands there are in the file, you can use <code class="literal">RasterCount</code>:</p><div><pre class="programlisting">num_bands = dem_file.RasterCount</pre></div><p>For this DEM file, there is only one band; we'll get a reference to this band using the <code class="literal">GetRasterBand()</code> method:</p><div><pre class="programlisting">band = dem_file.GetRasterBand(1)</pre></div><p>Note that band numbers start at 1, rather than the usual 0. The result is a <code class="literal">gdal.Band</code> object. While you can use various methods of the Band class to read the contents of the raster band as raw sequences of bytes, the easiest way to extract the data from the raster band is to convert it <a id="id165" class="indexterm"/>into a NumPy array:</p><div><pre class="programlisting">data = band.ReadAsArray()</pre></div><div><div><h3 class="title"><a id="note10"/>Note</h3><p>NumPy<a id="id166" class="indexterm"/> is automatically installed if you use the Mac OS X installer for GDAL. On other platforms, you may need to install it yourself. NumPy can be<a id="id167" class="indexterm"/> found at <a class="ulink" href="http://numpy.org">http://numpy.org</a>.</p></div></div><p>You can then use the NumPy array-handling methods to extract the data from this array. To see how this is done, let's read through the array and calculate a histogram of elevation values from the DEM data:</p><div><pre class="programlisting">num_rows,num_cols = data.shape

histogram = {} # Maps elevation to number of occurrences of that elevation.

for row in range(num_rows):
    for col in range(num_cols):
        elevation = int(data[row, col])
        try:
            histogram[elevation] += 1
        except KeyError:
            histogram[elevation] = 1

for elevation in sorted(histogram.keys()):
    print elevation, histogram[elevation]</pre></div><p>As you can see, reading data out of a NumPy array is quite easy.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>There is one small part of our program that may be confusing. Note that we use:</p><div><pre class="programlisting">elevation = int(data[row, col])</pre></div><p>As well as extracting the elevation from the NumPy array, we also typecast it to an integer. We do this <a id="id168" class="indexterm"/>because <code class="literal">data</code> is a NumPy array that returns a <code class="literal">numpy.uint16</code> value for each entry in the array. NumPy will automatically convert this into an integer as necessary, but doing this slows our program down. Since these values are integers already, we simply convert the elevation to a regular integer right away. This improves the speed of our program by about an order of magnitude—which is important when you are dealing with large amounts of data as we are here.</p></div></div><p>If you run this program, you'll see a list of the unique elevation values and how often that elevation occurred within the DEM file:</p><div><pre class="programlisting">
<strong>% python readRaster.py</strong>
<strong>-500 53081919</strong>
<strong>-84 1</strong>
<strong>-83 8</strong>
<strong>-82 9</strong>
<strong>-81 17</strong>
<strong>...</strong>
<strong>5241 1</strong>
<strong>5295 1</strong>
<strong>5300 1</strong>
<strong>5443 1</strong>
</pre></div><p>Notice the negative elevation values. Most of these are because certain areas of the USA (for example Death Valley) are below sea level. However, there is one elevation value, <code class="literal">-500</code>, that is not a real elevation value. This is the <strong>no-data value</strong> that we mentioned earlier.</p><p>You can avoid adding this to the histogram by adding the following highlighted lines to your program:</p><div><pre class="programlisting">...
histogram = {} # maps elevation to number of occurrences of that elevation.
<strong>no_data = int(band.GetNoDataValue())</strong>

for row in range(num_rows):
    for col in range(num_cols):
        elevation = int(data[row, col])
        <strong>if elevation == no_data: continue</strong>
        try:
            ...</pre></div><p>Using NumPy in this way, it is relatively straightforward to read through the contents of a raster-format datasource. Let's now see what is involved in writing raster-format data.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Writing raster data</h2></div></div></div><p>To write raster-format<a id="id169" class="indexterm"/> data, we need to generate some sample data, tell GDAL how to georeference each cell within the data to a point on the Earth's surface, and then save the data to disk. Let's work through this one step at a time.</p><div><ol class="orderedlist arabic"><li class="listitem">We'll start by creating the raster-format data file. We'll use the <code class="literal">EHdr</code> format, which is shorthand for an ESRI header-labeled file—this is the same file format we used when we read through the DEM data earlier.<div><div><h3 class="title"><a id="note13"/>Note</h3><p>As usual, GDAL makes it easy to work with different data formats; the same code will work no matter what format you select.</p></div></div><p>Here is the code to create the EHdr-format raster data file:</p><div><pre class="programlisting">from osgeo import gdal
driver = gdal.GetDriverByName("EHdr")
dstFile = driver.Create("Example Raster", 180, 360, 1, gdal.GDT_Int16)</pre></div><p>The parameters to the <code class="literal">Create()</code> method are the name of the file, the number of cells across and down, the number of raster bands, and the type of data to store in each cell.</p></li><li class="listitem">We next need to tell GDAL which spatial reference system to use for the file. In this case, we'll use the same <code class="literal">WGS84</code> reference system we encountered earlier; if you remember, this means that our coordinates are made up of latitude and longitude values. Here is the relevant code:<div><pre class="programlisting">from osgeo import osr

spatialReference = osr.SpatialReference()
spatialReference.SetWellKnownGeogCS("WGS84")

dstFile.SetProjection(spatialReference.ExportToWkt())</pre></div></li><li class="listitem">We'll next need to georeference the raster data onto the surface of the Earth. This is done using a<a id="id170" class="indexterm"/> <strong>georeferencing transform</strong>. There are many options you can use when defining a georeferencing transform, allowing you to do sophisticated things such as flipping the raster data or rotating it. In this case, however, all we need to do is tell GDAL where the top-left cell should be positioned, and how large each cell is going to be:<div><pre class="programlisting">originX    = -180
originY    = 90
cellWidth  = 0.25
cellHeight = 0.25

geoTransform = [originX, cellWidth, 0, originY, 0, -cellHeight]
dstFile.SetGeoTransform(geoTransform)</pre></div><p>In this example code, we have set the top-left cell to be at <code class="literal">latitude=90</code>, <code class="literal">longitude=-180</code>, and have defined each cell to cover 1/4 of a degree of latitude and longitude.</p></li><li class="listitem">We're now ready to <a id="id171" class="indexterm"/>create our raster-format data and save it to the file. Let's generate an array of 360 rows and 180 columns, where each value is a random number between 1 and 100:<div><pre class="programlisting">import random

data = []
for row in range(360):
    row_data = []
    for col in range(180):
        row_data.append(random.randint(1, 100))
    data.append(row_data)</pre></div><p>We can then convert this array into a NumPy array, where each entry in the array is a 16-bit signed integer:</p><div><pre class="programlisting">import numpy
array = numpy.array(data, dtype=numpy.int16)</pre></div><p>This data can then be saved into the file:</p><div><pre class="programlisting">band.WriteArray(array)</pre></div></li><li class="listitem">Finally, let's define a no-data value, and close the file to save everything to disk:<div><pre class="programlisting">band.SetNoDataValue(-500)
del dstFile</pre></div></li></ol></div><p>Running this program will create a new raster-format file on disk, complete with a header (<code class="literal">.hdr</code>) file and information about how to georeference our (random) data onto the surface of the Earth. Except for the addition of a spatial reference system and a georeferencing transform, the process of writing geospatial data is almost as simple as reading it.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>You can actually use both a spatial reference system and a geotransform when reading raster data from a file too—we just skipped that step to keep it simple. Later on, when we want to position cells exactly onto a point on the Earth's surface, we'll use both of these concepts while reading raster-format data.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Dealing with spatial reference systems</h1></div></div></div><p>One of the things that can <a id="id172" class="indexterm"/>be quite confusing when you start working with geospatial data is the notion of a <strong>spatial reference system</strong>. Imagine that you're running a search-and-rescue operation, and are given the location of a plane crash as a coordinate, for example:</p><div><pre class="programlisting">(-114.93, 12.478)</pre></div><p>What do these numbers mean? Are these values a latitude and longitude, or are they perhaps a number of kilometers away from a given reference point? Without understanding how these coordinates translate to a point on the Earth's surface, you'd have no way of knowing where to send your rescuers.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Spatial reference systems are sometimes referred to as coordinate reference systems. Don't worry: these two terms refer to the same thing.</p></div></div><p>To understand the concept of spatial reference systems, you first need to learn a bit about mapping theory. Maps are an attempt to draw the three-dimensional surface of the Earth on a two-dimensional Cartesian plane:</p><div><img src="img/B04102_02_14.jpg" alt="Dealing with spatial reference systems"/></div><p>To convert the Earth's surface into a two-dimensional plane, you need to use a mathematical process known as <strong>projection</strong>. The thing is, it is mathematically impossible to have a perfect projection: shapes are going to be distorted, areas will be misrepresented, or the distance between points will be incorrect.</p><p>Because of this imperfection, a large number of different map projections have been developed over the years. Some map projections are quite accurate for certain areas of the world, but are inaccurate elsewhere. Other map projections preserve the shape of the continents while misrepresenting distance and areas, and so on.</p><p>Whenever you work with geospatial data, you will need to have answers to the following three questions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which mathematical model has been used to define the shape of the Earth?</li><li class="listitem" style="list-style-type: disc">Have the coordinates been projected onto a map?</li><li class="listitem" style="list-style-type: disc">If so, what projection has been used?</li></ul></div><p>Knowing the answers <a id="id173" class="indexterm"/>to these three questions will allow you to know the exact location that a given set of coordinates refers to. As you can imagine, knowing the answers to these questions is vital to the success of any geospatial analysis.</p><p>A spatial reference system encapsulates the answers to these three questions. Let's take a look at a couple of common spatial reference systems to see how they work.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>WGS84</h2></div></div></div><p>
<strong>WGS84</strong><a id="id174" class="indexterm"/> stands for World Geodetic System 1984, and<a id="id175" class="indexterm"/> is a global standard used to represent points on the surface of the Earth. It uses an accurate mathematical model of the Earth's shape, along with standards that define coordinates in terms of what we call latitude and longitude. Taken together, the WGS84 spatial reference system provides a complete system to describe points on the Earth's surface.</p><p>Let's take a closer look at how WGS84 defines the latitude and longitude values. Given a point on the Earth's surface, the latitude and longitude are calculated by drawing an imaginary line from the center of the Earth out to the desired point:</p><div><img src="img/B04102_02_15.jpg" alt="WGS84"/></div><p>You can then<a id="id176" class="indexterm"/> measure the<a id="id177" class="indexterm"/> latitude as the angle in the north-south direction between this line and a line going out to the equator:</p><div><img src="img/B04102_02_16.jpg" alt="WGS84"/></div><p>Similarly, the longitude can be calculated as the angle between this line in the east-west direction and a line going out to zero degrees (which is based on the location of Greenwich, England):</p><div><img src="img/B04102_02_17.jpg" alt="WGS84"/></div><p>As you can see, longitude<a id="id178" class="indexterm"/> and <a id="id179" class="indexterm"/>latitude values are based on the desired point's position on the Earth's surface. WGS84 is the prototypical example of an <a id="id180" class="indexterm"/>
<strong>unprojected</strong> coordinate system. It's a very common format for geospatial data, and in many cases you will only be working with data in this format.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Universal Transverse Mercator</h2></div></div></div><p>
<strong>Universal Transverse Mercator</strong> (<strong>UTM</strong>)<a id="id181" class="indexterm"/> is a very <a id="id182" class="indexterm"/>common standard used to represent coordinates on a flat Cartesian plane. UTM is not a single map projection, but is rather a sequence of sixty different projections called <a id="id183" class="indexterm"/>
<strong>zones</strong>, where each zone covers a narrow slice of the Earth's surface:</p><div><img src="img/B04102_02_18.jpg" alt="Universal Transverse Mercator"/></div><p>For any given <a id="id184" class="indexterm"/>UTM zone, the <a id="id185" class="indexterm"/>coordinates are measured as "northing" and "easting" values, which correspond to the number of meters north or east of a given reference point. The reference point is calculated so that the northing and easting values will always be positive.</p><p>Because the UTM projections are based on a two-dimensional map, these are examples of a <a id="id186" class="indexterm"/>
<strong>projected</strong> coordinate system.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Describing spatial reference systems</h2></div></div></div><p>Whenever you work with <a id="id187" class="indexterm"/>geospatial data, you need to know which spatial reference system you are using. Often, when generating maps or reading and writing geospatial data, you will need to build an <code class="literal">osr.SpatialReference</code> object or its equivalent to describe the spatial reference system you are using.</p><p>One of the easiest ways to describe a spatial reference system is by name. We saw this earlier when we created a spatial reference object using the well-known name, like this:</p><div><pre class="programlisting">spatialReference = osr.SpatialReference()
spatialReference.SetWellKnownGeogCS("WGS84")</pre></div><p>Another common way to describe a spatial reference system is to use the <strong>EPSG</strong> code. EPSG is a standards body that maintains a database of all known spatial reference systems, and assigns a unique numeric code to each one. You can find t<a id="id188" class="indexterm"/>he EPSG website at <a class="ulink" href="http://www.epsg-registry.org">http://www.epsg-registry.org</a>. For example, the EPSG code for WGS84 is 4326, so you could also create a WGS84 spatial reference object using the following Python code:</p><div><pre class="programlisting">spatialReference = osr.SpatialReference()
spatialReference.ImportFromEPSG(4326)</pre></div><p>Finally, you can use the WKT format string to define a spatial reference system. The GDAL/OGR library makes it <a id="id189" class="indexterm"/>easy to import and export spatial reference systems using WKT. For example:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; spatialReference = osr.SpatialReference()</strong>
<strong>&gt;&gt;&gt; spatialReference.ImportFromEPSG(4326)</strong>
<strong>&gt;&gt;&gt; print spatialReference.ExportToWkt()</strong>
<strong>GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]</strong>
</pre></div><p>There is also an <code class="literal">ImportFromWkt()</code> method, which lets you define a spatial reference object using a WKT definition string.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Transforming coordinates</h2></div></div></div><p>As well as knowing which <a id="id190" class="indexterm"/>spatial reference system you are using, it is also important at times to be able to transform geospatial data from one spatial reference system to another. For example, if you want to use Shapely to calculate the intersection between two polygons, and the polygons use different spatial reference systems, you are going to need to convert them into the same spatial reference system before the intersection will work.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Remember that Shapely is a <em>geometry</em> manipulation library. It doesn't know about spatial reference systems, so you need to deal with this yourself.</p></div></div><p>To transform a geometry from one spatial reference system to another, you can use the <code class="literal">osr.CoordinateTransformation</code> class. Let's see how this is done:</p><div><pre class="programlisting">src_spatialReference = osr.SpatialReference()
src_spatialReference.SetWellKnownGeogCS("WGS84")

dst_spatialReference = osr.SpatialReference()
dst_spatialReference.SetUTM(10)

transform = osr.CoordinateTransformation(src_spatialReference, dst_spatialReference)

geometry.Transform(transform)</pre></div><p>You first define the two spatial reference systems, and then create the coordinate transformation to convert from one to the other. Then you can simply call the <code class="literal">Transform()</code> method to convert the geometry from the source spatial reference system into the destination spatial reference system.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Calculating lengths and areas</h2></div></div></div><p>Now that we understand the <a id="id191" class="indexterm"/>basics of spatial reference systems and<a id="id192" class="indexterm"/> how to transform data from one spatial reference system to another, we can finally solve the problem we encountered in <a class="link" href="ch01.html" title="Chapter 1. Geospatial Analysis and Techniques">Chapter 1</a>, <em>Geospatial Analysis and Techniques</em>. If you remember, while looking at the calculations we could do with the Shapely library, we found that we could not accurately calculate lengths and areas for geospatial data that used longitude and latitude values.</p><p>Let's take another look at this problem, and how we can use coordinate transformations to solve these problems.</p><p>Let's define a simple polygon that defines the approximate outline of Central Park in New York:</p><div><pre class="programlisting">import shapely.wkt
wkt = "POLYGON((-73.973057 40.764356, -73.981898 40.768094, -73.958209 40.800621, -73.949282 40.796853, -73.973057 40.764356))"
outline = shapely.wkt.loads(wkt)</pre></div><p>We used this polygon as an example in the section on well-known text earlier in this chapter.</p><p>If we were to ask Shapely to calculate the area of this geometry, it would calculate the mathematical area covered by this polygon:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; print outline.area</strong>
<strong>0.000377902804</strong>
</pre></div><p>Unfortunately, the resulting number is in "square degrees", which is a meaningless number. This is because Shapely doesn't know about map projections—it simply treats each coordinate value as a number. To calculate the area of this polygon in real units, we have to convert from unprojected lat/long coordinates into what is called an "equal area" map projection that measures coordinates in meters. We can then ask Shapely to calculate the area, and the result will be in square meters. Let's see how we can do this using a combination of OGR and Shapely:</p><div><ol class="orderedlist arabic"><li class="listitem">First off, we create an OGR geometry object using the WKT definition for our outline:<div><pre class="programlisting">from osgeo import ogr
polygon = ogr.CreateGeometryFromWkt(wkt)</pre></div></li><li class="listitem">We next need to define a coordinate transformation from WGS84 into a projected coordinate system that uses meters. We will use the <strong>World Mollweide</strong> projection (EPSG code 54009), which is an equal-area projection that is fairly accurate worldwide:<div><pre class="programlisting">from osgeo import osr

src_spatialReference = osr.SpatialReference()
src_spatialReference.ImportFromEPSG(4326)

dst_spatialReference = osr.SpatialReference()
dst_spatialReference.ImportFromEPSG(54009)

transform = osr.CoordinateTransformation(src_spatialReference, dst_spatialReference)</pre></div></li><li class="listitem">We can then transform the OGR geometry from WGS84 into World Mollweide projection, convert it back into a Shapely geometry, and finally ask Shapely to calculate the polygon's area:<div><pre class="programlisting">polygon.Transform(transform)

outline = shapely.wkt.loads(polygon.ExportToWkt())
print outline.area</pre></div></li></ol></div><p>The result is an accurate<a id="id193" class="indexterm"/> figure for the area of Central<a id="id194" class="indexterm"/> Park (as accurate as the original polygon outline will allow), measured in square meters. You could then convert this area into square miles or any other unit you wished to use.</p><p>In this example, we used an equal-area projection. To accurately calculate lengths, you would have to use an equidistant map projection covering the area of the Earth that you are interested in. Alternatively, you can make use of the <code class="literal">PyProj</code> library to calculate distances for unprojected coordinates; we will look at <code class="literal">PyProj</code> in detail in <a class="link" href="ch05.html" title="Chapter 5. Analyzing Geospatial Data">Chapter 5</a>, <em>Analyzing Geospatial Data</em>.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Geospatial data errors and how to fix them</h1></div></div></div><p>As you start working with<a id="id195" class="indexterm"/> geospatial data, you will soon discover that things don't always work the way you expect them to. OGR may crash when attempting to save a geometry into a shapefile, or Shapely may cause a system error when calculating the intersection of two polygons. While this can be frustrating, there are ways to solve these problems once you understand what causes them.</p><p>Geospatial data, and libraries such as GDAL/OGR and Shapely, are based around a mathematical model of how a geometry should be structured. Problems occur when your geospatial data doesn't meet this mathematical ideal. Let's take a look at what a mathematically-correct geometry looks like.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Points</h2></div></div></div><p>While a coordinate is simply a pair of <a id="id196" class="indexterm"/>numbers, the range of acceptable values is limited. Imagine, for example, the following point geometries, which use WGS84 (that is, latitude and longitude coordinates):</p><div><pre class="programlisting">POINT(-0.076 51.506)
POINT(2.295 48.858)
POINT(37.784 -122.402)</pre></div><p>These points are supposed to represent the location of the Tower of London, the Eiffel Tower, and the Moscone Center in San Francisco. However, the third Point geometry has been defined incorrectly, by swapping the latitude and longitude. This location has been set to longitude=37.784 and latitude=-122.402. But latitude values can only be in the range -90 to +90, and so this Point geometry is invalid.</p><p>Of course, all geometries are <a id="id197" class="indexterm"/>made up of coordinates, and so a polygon, for example, might have just one out-of-range coordinate, which could cause your program to crash. When constructing or manipulating geometries, you will sometimes need to add code to check that the coordinates are all valid, and adjust the geometry if necessary.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>LineStrings</h2></div></div></div><p>A LineString<a id="id198" class="indexterm"/> geometry consists of a list of coordinates, with a straight line segment drawn from one coordinate to the next:</p><div><img src="img/B04102_02_19.jpg" alt="LineStrings"/></div><p>However, if you try to define a LineString with only one coordinate, or a LineString with two coordinates that happen to be the same, then your LineString geometry will be mathematically invalid and can cause your program to crash.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Linear Rings</h2></div></div></div><p>A Linear Ring<a id="id199" class="indexterm"/> is a LineString where the starting and ending points are the same:</p><div><img src="img/B04102_02_20.jpg" alt="Linear Rings"/></div><p>Linear Rings are <a id="id200" class="indexterm"/>used to enclose an area of space, and are the building blocks of polygon geometries. For a Linear Ring to be valid, it must have at least three coordinates, and the line segments cannot touch or cross.</p><p>The following illustration shows two examples of mathematically invalid Linear Rings:</p><div><img src="img/B04102_02_21.jpg" alt="Linear Rings"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Polygons</h2></div></div></div><p>A polygon geometry<a id="id201" class="indexterm"/> is made up of one or more Linear Rings: the first Linear Ring defines the outline of the Polygon, while additional Linear Rings define holes within the Polygon's interior. For example:</p><div><img src="img/B04102_02_22.jpg" alt="Polygons"/></div><p>However, this <a id="id202" class="indexterm"/>mathematically-ideal representation of a polygon breaks down if the interior rings overlap, touch each other, or touch the polygon's exterior. If any of these things happen, your polygon becomes invalid and your program may well crash.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>MultiPolygons</h2></div></div></div><p>A MultiPolygon<a id="id203" class="indexterm"/> geometry, as the name suggests, is a collection of two or more polygons. MultiPolygons are mathematically invalid if two of their polygons touch along an edge—in this case, the two polygons should have been merged into one larger polygon, and so the MultiPolygon is considered to be invalid.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>Fixing invalid geometries</h2></div></div></div><p>Even if your geometry data<a id="id204" class="indexterm"/> is valid to start with, geometries can become invalid when you manipulate them. For example, if you attempt to split a polygon in two, or merge LineString geometries together, the result can sometimes be invalid.</p><p>Now that you understand the ways in which a geometry can be invalid, let's look at some tricks to fix them. First off, you can ask Shapely if it thinks the geometry is valid or not by checking the <code class="literal">is_valid</code> attribute:</p><div><pre class="programlisting">if not geometry.is_valid:
    ....</pre></div><p>Similarly, you can use the <code class="literal">IsValid()</code> method to check if an OGR geometry object is valid or not:</p><div><pre class="programlisting">if not geometry.IsValid():
    ...</pre></div><p>Unfortunately, these two validity checks are not perfect: sometimes you'll find that a geometry is identified as valid even though it isn't. When this happens, you'll have to add a <code class="literal">try...except</code> clause to your program to catch a crash, and then try to fix the geometries yourself before trying again.</p><p>When a geometry is not valid, your first port of call will be the <code class="literal">buffer(0)</code> technique. The <code class="literal">buffer()</code> operation is one which expands a geometry to include all points within a certain distance of the original geometry, for example:</p><div><img src="img/B04102_02_23.jpg" alt="Fixing invalid geometries"/></div><p>By calling <code class="literal">buffer(0)</code>, you are telling Shapely (or OGR) to construct a new copy of the geometry that includes all points within a zero distance of the geometry. This effectively rebuilds the geometry from scratch, and will often turn an invalid geometry back into a valid one.</p><p>This doesn't always <a id="id205" class="indexterm"/>work, unfortunately. There are times when <code class="literal">buffer()</code> is unable to rebuild a complex geometry without crashing. In that case, you may need to split the geometry into individual pieces, and then check each piece in turn to see if it was the cause of the crash. You can then exclude the misbehaving piece from the geometry when you rebuild it. The following is an example piece of Python code that attempts to repair an invalid Shapely geometry using this technique:</p><div><pre class="programlisting">def fix_geometry(geometry):
    buffer_worked = True
    try:
        geometry = geometry.buffer(0)
    except:
        buffer_worked = False

    if buffer_worked:
        return geometry

    polygons = []
    if geometry.geom_type == "Polygon":
        polygons.append(geometry)
    elif geometry.geom_type == "MultiPolygon":
        polygons.extend(geometry.geoms)

    fixed_polygons = []
    for n,polygon in enumerate(polygons):
        if not linear_ring_is_valid(polygon.exterior):
            continue # Unable to fix.

        interiors = []
        for ring in polygon.interiors:
            if linear_ring_is_valid(ring):
                interiors.append(ring)

        fixed_polygon = shapely.geometry.Polygon(polygon.exterior,
                                                 interiors)

        try:
            fixed_polygon = fixed_polygon.buffer(0)
        except:
            continue

        if fixed_polygon.geom_type == "Polygon":
            fixed_polygons.append(fixed_polygon)
        elif fixed_polygon.geom_type == "MultiPolygon":
            fixed_polygons.extend(fixed_polygon.geoms)

    if len(fixed_polygons) &gt; 0:
        return shapely.geometry.MultiPolygon(fixed_polygons)
    else:
        return None # Unable to fix.

def linear_ring_is_valid(ring):
    points = set() # Set of (x,y) tuples.

    for x,y in ring.coords:
        points.add((x,y))

    if len(points) &lt; 3:
        return False
    else:
        return True</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Remember <a id="id206" class="indexterm"/>that this code works with Shapely geometries. If you have an OGR geometry, you can convert it into a Shapely geometry using <code class="literal">shapely.wkt.loads(ogrGeometry.ExportToWkt())</code>.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we looked more closely at the data used for geospatial analysis. We saw why having high-quality geospatial data is important, the various types of geospatial data you are likely to encounter, and the major websites which provide quality geospatial data for free. We then looked at how to read and write both vector and raster format geospatial data using GDAL and OGR, and learned about spatial reference systems. Finally, we looked at the ways in which geospatial data can become invalid, and how to fix it.</p><p>In the next chapter, we will look at spatial databases and how they can be used as a powerful tool for geospatial analysis.</p></div></div>
</body></html>