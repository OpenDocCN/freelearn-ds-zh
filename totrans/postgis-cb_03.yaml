- en: Working with Vector Data – The Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with GPS data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing invalid geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GIS analysis with spatial joins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring distances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging polygons using a common attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing intersections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipping geometries to deploy data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying geometries with PostGIS topology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will work with a set of PostGIS functions and vector datasets.
    You will first take a look at how to use PostGIS with GPS data—you will import
    such datasets using `ogr2ogr` and then compose polylines from point geometries
    using the `ST_MakeLine` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you will see how PostGIS helps you find and fix invalid geometries with
    functions such as `ST_MakeValid`, `ST_IsValid`, `ST_IsValidReason`, and `ST_IsValidDetails`.
  prefs: []
  type: TYPE_NORMAL
- en: You will then learn about one of the most powerful elements of a spatial database,
    spatial joins. PostGIS provides you with a rich set of operators, such as `ST_Intersects`,
    `ST_Contains`, `ST_Covers`, `ST_Crosses`, and `ST_DWithin`, for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will use the `ST_Simplify` and `ST_SimplifyPreverveTopology`
    functions to simplify (generalize) geometries when you don't need too many details.
    While this function works well on linear geometries, topological anomalies may
    be introduced for polygonal ones. In such cases, you should consider using an
    external GIS tool such as `GRASS`.
  prefs: []
  type: TYPE_NORMAL
- en: You will then have a tour of PostGIS functions to make distance measurements—`ST_Distance`,
    `ST_DistanceSphere`, and `ST_DistanceSpheroid` are on the way.
  prefs: []
  type: TYPE_NORMAL
- en: One of the recipes explained in this chapter will guide you through the typical
    GIS workflow to merge polygons based on a common attribute; you will use the `ST_Union`
    function for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: You will then learn how to clip geometries using the `ST_Intersection` function,
    before deep diving into the **PostGIS topology** in the last recipe that was introduced
    in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GPS data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will work with GPS data. This kind of data is typically
    saved in a `.gpx` file. You will import a bunch of `.gpx` files to PostGIS from
    **RunKeeper**, a popular social network for runners.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an account on RunKeeper, you can export your `.gpx` files and process
    them by following the instructions in this recipe. Otherwise, you can use the
    RunKeeper `.gpx` files included in the `runkeeper-gpx.zip` file located in the
    `chp03` directory available in the code bundle for this book.
  prefs: []
  type: TYPE_NORMAL
- en: You will first create a `bash` script for importing the `.gpx` files to a PostGIS
    table, using `ogr2ogr`. After the import is completed, you will try to write a
    couple of SQL queries and test some very useful functions, such as `ST_MakeLine`
    to generate polylines from point geometries, `ST_Length` to compute distance,
    and `ST_Intersects` to perform a spatial join operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extract the `data/chp03/runkeeper-gpx.zip` file to `working/chp03/runkeeper_gpx`.
    In case you haven't been through [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data In and Out of PostGIS*, be sure to have the `countries` dataset in
    the PostGIS database.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, be sure of the format of the `.gpx` files that you need to import to
    PostGIS. Open one of them and check the file structure—each file must be in the
    XML format composed of just one `<trk>` element, which contains just one `<trkseg>`
    element, which contains many `<trkpt>` elements (the points stored from the runner''s
    GPS device). Import these points to a PostGIS `Point` table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new schema named `chp03` to store the data for all the recipes in
    this chapter, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `chp03.rk_track_points` table in PostgreSQL by executing the following
    command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create the following script to import all of the `.gpx` files in the `chp03.rk_track_points`
    table using the GDAL `ogr2ogr` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the Linux version (name it `working/chp03/import_gpx.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the command for macOS (name it `working/chp03/import_gpx.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Windows version (name it `working/chp03/import_gpx.bat`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux and macOS, don''t forget to assign execution permission to the script
    before running it. Then, run the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, just double-click on the `.bat` file or run it from the command
    prompt using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a polyline table containing a single runner''s track details using
    the `ST_MakeLine` function. Assume that on each distinct day, the runner had just
    one training session. In this table, you should include the start and end times
    of the track details as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Before querying the created tables, don''t forget to add spatial indexes to
    both of the tables to improve their performance, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you try to open both the spatial tables on a desktop GIS on any given day,
    you should see that the points from the `rk_track_points` table compose a single
    polyline geometry record in the `tracks` table, as shown in the following screenshot:![](img/75e2ab83-d45c-4356-a7a4-96d40fb6f75f.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you open all the tracks from a desktop GIS (such as QGIS), you will see
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/976a2634-7f01-406a-b31f-9ba46e78f269.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, query the `tracks` table to get a report of the total distance run (in
    km) by the runner for each month. For this purpose, use the `ST_Length` function,
    as shown in the following query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3c37c7e0-6d36-4fba-b9fc-5e3fef87ace9.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a spatial join between the `tracks` and `countries` tables, and again
    using the `ST_Length` function as follows, you will get a report of the distance
    run (in km) by the runner, per country:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/397cdfbd-2aee-4418-a918-909e96d7a0ea.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.gpx` files store all the points' details in the WGS 84 spatial reference
    system; therefore, we created the `rk_track_points` table with SRID (4326).
  prefs: []
  type: TYPE_NORMAL
- en: After creating the `rk_track_points` table, we imported all of the `.gpx` files
    in the `runkeeper_gpx` directory using a bash script. The bash script iterates
    all of the files with the extension `*.gpx` in the `runkeeper_gpx` directory.
    For each of these files, the script runs the `ogr2ogr` command, importing the
    `.gpx` files to PostGIS using the GPX GDAL driver (for more details, go to [http://www.gdal.org/drv_gpx.html](http://www.gdal.org/drv_gpx.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GDAL''s abstraction, a `.gpx` file is an OGR data source composed of
    several layers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/630b3479-afb7-4e3e-bcb8-af32f7a96042.png)'
  prefs: []
  type: TYPE_IMG
- en: In the `.gpx` files (OGR data sources), you have just the `tracks` and `track_points`
    layers. As a shortcut, you could have imported just the `tracks` layer using `ogr2ogr`,
    but you would need to start from the `track_points` layer in order to generate
    the `tracks` layer itself, using some PostGIS functions. This is why in the `ogr2ogr`
    section in the bash script, we imported to the `rk_track_points` PostGIS table
    the point geometries from the `track_points` layer, plus a couple of useful attributes,
    such as `elevation` and `timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the records were imported, we fed a new polylines table named `tracks`
    using a subquery and selected all of the point geometries and their dates and
    times from the `rk_track_points` table, grouped by date and with the geometries
    aggregated using the `ST_MakeLine` function. This function was able to create
    linestrings from point geometries (for more details, go to [http://www.postgis.org/docs/ST_MakeLine.html](http://www.postgis.org/docs/ST_MakeLine.html)).
  prefs: []
  type: TYPE_NORMAL
- en: You should not forget to sort the points in the subquery by `datetime`; otherwise,
    you will obtain an irregular linestring, jumping from one point to the other and
    not following the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the `tracks` table, we tested the two spatial queries.
  prefs: []
  type: TYPE_NORMAL
- en: At first, you got a month-by-month report of the total distance run by the runner.
    For this purpose, you selected all of the track records grouped by date (year
    and month), with the total distance obtained by summing up the lengths of the
    single tracks (obtained with the `ST_Length` function). To get the year and the
    month from the `run_date` function, you used the PostgreSQL `EXTRACT` function.
    Be aware that if you measure the distance using geometries in the WGS 84 system,
    you will obtain it in degree units. For this reason, you have to project the geometries
    to a planar metric system designed for the specific region from which the data
    will be projected.
  prefs: []
  type: TYPE_NORMAL
- en: For large-scale areas, such as in our case where we have points that span all
    around Europe, as shown in the last query results, a good option is to use the
    `geography` data type introduced with PostGIS 1.5\. The calculations may be slower,
    but are much more accurate than in other systems. This is the reason why you cast
    the geometries to the `geography` data type before making measurements.
  prefs: []
  type: TYPE_NORMAL
- en: The last spatial query used a spatial join with the `ST_Intersects` function
    to get the name of the country for each track the runner ran (with the assumption
    that the runner didn't run cross-border tracks). Getting the total distance run
    per country is just a matter of aggregating the selection on the `country_name`
    field and aggregating the track distances with the PostgreSQL `SUM` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing invalid geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will often find invalid geometries in your PostGIS database. These invalid
    geometries could compromise the functioning of PostGIS itself and any external
    tool using it, such as QGIS and MapServer. PostGIS, being compliant with the OGC
    Simple Feature Specification, must manage and work with valid geometries.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, PostGIS 2.0 offers you the `ST_MakeValid` function, which together
    with the `ST_IsValid`, `ST_IsValidReason`, and `ST_IsValidDetails` functions,
    is the ideal toolkit for inspecting and fixing geometries within the database.
    In this recipe, you will learn how to fix a common case of invalid geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unzip the `data/TM_WORLD_BORDERS-0.3.zip` file into your working directory, `working/chp3`.
    Import the shapefile in PostGIS with the `shp2pgsql` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The file is also included with the name of `wborders` since for some operating
    systems, it does not work with the characters of `TM_WORLD_BORDERS-0.3.shp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to perform to complete this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, investigate whether or not any geometry is invalid in the imported table.
    As you can see in the following query, using the `ST_IsValid` and `ST_IsValidReason`
    functions, we find four invalid geometries that are all invalid for the same reason—ring
    self-intersection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9d492d78-48dd-4e87-95a7-244ff828e14c.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now concentrate on just one of the invalid geometries, for example, in the
    multipolygon geometry representing Russia. Create a table containing just the
    ring generating the invalidity, selecting the table using the point coordinates
    given in the `ST_IsValidReason` response in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ST_MakeValid` requires GEOS 3.3.0 or higher; check whether or not your system
    supports it using the `PostGIS_full_version` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12ed12e5-57a6-44a6-831c-e467f4687927.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, using the `ST_MakeValid` function, add a new record in the previously
    created table with the valid version of the same geometry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this geometry on your desktop GIS; the invalid geometry has just one self-intersecting
    ring that produces a hole in its internal. While this is accepted in the ESRI
    shapefile format specification (that was the original dataset you imported), the
    OGC standard does not allow for the self-intersecting ring, so neither does PostGIS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e410c76-e985-41de-b887-b34dd0790b6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in the `invalid_geometries` table, you have the invalid and valid versions
    of the polygon. It is easy to figure out that the self-intersecting ring was removed
    by `ST_MakeValid` adding one supplementary ring to the original polygon, which
    resulted in a valid geometry, according to the OGC standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/572c141e-3931-4af7-83c7-d1f7f2e2fcb0.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have identified the problem and its solution, don''t forget to
    fix all the other invalid geometries in the `countries` table by executing the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A smart way to not have invalid geometries in the database at all is by adding
    a `CHECK` constraint on the table to check for validity. This will increase the
    computation time when updating or inserting new geometries, but will keep your
    dataset valid. For example, in the `countries` table, this can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ALTER TABLE chp03.countries`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD CONSTRAINT geometry_valid_check`'
  prefs: []
  type: TYPE_NORMAL
- en: '`CHECK (ST_IsValid(the_geom));`'
  prefs: []
  type: TYPE_NORMAL
- en: Many times in real use cases, though, you will need to remove such a constraint
    in order to be able to import records from a different source. After making validations
    with the `ST_MakeValid` function, you can safely add the constraint again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of reasons why an invalid geometry could result in your database;
    for example, rings composed of polygons must be closed and cannot self-intersect
    or share more than one point with another ring.
  prefs: []
  type: TYPE_NORMAL
- en: After importing the `country` shapefile using the `ST_IsValid` and `ST_IsValidReason`
    functions, you will have figured out that four of the imported geometries are
    invalid, all because their polygons have self-intersecting rings.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a good way to investigate the invalid multipolygon geometry is
    by decomposing the polygon in to its component rings and checking out the invalid
    ones. For this purpose, we have exported the geometry of the ring causing the
    invalidity, using the `ST_GeometryN` function, which is able to extract the *n*^(th)
    ring from the polygon. We coupled this function with the useful PostgreSQL `generate_series`
    function to iterate all of the rings composing the geometry, selecting the desired
    one using the `ST_Intersects` function.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the reason why this ring generates the invalidity is that it is
    self-intersecting and produces a hole in the polygon. While this adheres to the
    shapefile specification, it doesn't adhere to the OGC specification.
  prefs: []
  type: TYPE_NORMAL
- en: By running the `ST_MakeValid` function, PostGIS has been able to make the geometry
    valid, generating a second ring. Remember that the `ST_MakeValid` function is
    available only with the latest PostGIS compiled with the latest GEOS (3.3.0+).
    If that is not the setup for your working box and you cannot upgrade (upgrading
    is always recommended!), you can follow the techniques used in the past and discussed
    in a very popular, excellent presentation by *Paul Ramsey* at [http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/](http://blog.opengeo.org/2010/09/08/tips-for-the-postgis-power-user/).
  prefs: []
  type: TYPE_NORMAL
- en: GIS analysis with spatial joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joins for regular SQL tables have the real power in a relational database, and
    spatial joins are one of the most impressive features of a spatial database engine
    such as PostGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, it is possible to correlate information from different layers on
    the basis of the geometric relation of each feature from the input layers. In
    this recipe, we will take a tour of some common use cases of spatial joins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, import some data to be used as a test bed in PostGIS. Download the `.kmz`
    file containing information about 2012 global earthquakes from the USGS website
    at [http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz](http://earthquake.usgs.gov/earthquakes/eqarchives/epic/kml/2012_Earthquakes_ALL.kmz).
    Save it in the `working/chp03` directory (alternatively, you can use the copy
    of this file included in the code bundle provided with this book).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A `.kmz` file is a collection of `.kml` files packaged with the ZIP compressor.
    Therefore, after unzipping the file (you may need to change the `.kmz` file extension
    to `.zip`), you may notice that it is composed of just a single `.kml` file. This
    file, which is in the GDAL abstraction, constitutes an OGR KML data source composed
    of nine different layers and containing 3D point geometries. Each layer contains
    earthquake data for each distinct earthquake magnitude:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09c70540-c0dc-4a8b-9153-fad43b3d0333.png)'
  prefs: []
  type: TYPE_IMG
- en: Import all of those layers in a PostGIS table named `chp03.earthquakes` simultaneously
    by executing one of the following scripts using the `ogr2ogr` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the Linux version (name it `import_eq.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Windows version (name it `import_eq.bat`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following script (for Linux, you need to add `execute` permissions
    to it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To maintain consistency with the book''s conventions, rename the geometric
    column `wkb_geometry` (the default geometry output name in `ogr2ogr`) to `the_geom`,
    as illustrated in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the `cities` shapefile for the USA from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the `states` shapefile for the USA from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/statesp020_nt00032.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will see for yourself the power of spatial SQL by solving
    a series of typical problems using spatial joins:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, query PostGIS to get the number of registered earthquakes in 2012 by
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/68f320cb-5d1f-4930-8e52-6cb8eaca5a9a.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make it just a bit more complex, query PostGIS to get the number of
    earthquakes, grouped per magnitude, that are no further than 200 km from the cities
    in the USA that have more than 1 million inhabitants; execute the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3a3620ef-98f6-4376-bea3-ac7b00b7001d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As a variant of the previous query, executing the following code gives you
    a complete list of earthquakes along with their distance from the city (in meters):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/4fcabdc0-6870-4f69-b0e6-c368d572f5b6.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, ask PostGIS for the city count and the total population in each state
    by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3952b72d-a6be-4a23-b81d-a0d7a732c746.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final test, use a spatial join to update an existing table. You need to
    add the information in the `state_fips` field to the `earthquake` table from the
    `states` table. First, to host that kind of information, you need to create a
    column as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can update the new column using a spatial join, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spatial joins are one of the key features that unleash the spatial power of
    PostGIS. For a regular join, it is possible to relate entities from two distinct
    tables using a common field. For a spatial join, it is possible to relate features
    from two distinct spatial tables using any spatial relationship function, such
    as `ST_Contains`, `ST_Covers`, `ST_Crosses`, and `ST_DWithin`.
  prefs: []
  type: TYPE_NORMAL
- en: In the first query, we used the `ST_Intersects` function to join the earthquake
    points to their respective state. We grouped the query by the `state` column to
    obtain the number of earthquakes in the state.
  prefs: []
  type: TYPE_NORMAL
- en: In the second query, we used the `ST_DWithin` function to relate each city to
    the earthquake points within a 200 km distance of it. We filtered out the cities
    with a population of less than 1 million inhabitants and grouped them by city
    name and earthquake magnitude to get a report of the number of earthquakes per
    city and by magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: The third query is similar to the second one, except it doesn't group per city
    and by magnitude. The distance is computed using the `ST_Distance` function. Note
    that as feature coordinates are stored in WGS 84, you need to cast the geometric
    column to a spheroid and use the spheroid to get the distance in meters. Alternatively,
    you could project the geometries to a planar system that is accurate for the area
    we are studying in this recipe (in this case, the *ESPG:2163*, *US National Atlas
    Equal Area* would be a good choice) using the `ST_Transform` function. However,
    in the case of large areas like the one we've dealt with in this recipe, casting
    to geography is generally the best option as it gives more accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth query uses the `ST_Intersects` function. In this case, we grouped
    by the `state` column and used two aggregation SQL functions (`SUM` and `COUNT`)
    to get the desired results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last query, you update a spatial table using the results of
    a spatial join. The concept behind this is like that of the previous query, except
    that it is in the context of an `UPDATE` SQL command.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be many times when you will need to generate a less detailed and
    lighter version of a vector dataset, as you may not need very detailed features
    for several reasons. Think about a case where you are going to publish the dataset
    to a website and performance is a concern, or maybe you need to deploy the dataset
    to a colleague who does not need too much detail because they are using it for
    a large-area map. In all these cases, GIS tools include implementations of **simplification
    algorithms** that reduce unwanted details from a given dataset. Basically, these
    algorithms reduce the vertex numbers comprised in a certain tolerance, which is
    expressed in units measuring distance.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, PostGIS provides you with the `ST_Simplify` and `ST_SimplifyPreserveTopology`
    functions. In many cases, they are the right solutions for simplification tasks,
    but in some cases, especially for polygonal features, they are not the best option
    out there and you will need a different GIS tool, such as `GRASS` or the new PostGIS
    topology support.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to do to complete this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the PostgreSQL `search_path` variable such that all your newly created
    database objects will be stored in the `chp03` schema, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you need a less-detailed version of the `states` layer for your mapping
    website or to deploy to a client; you could consider using the `ST_SimplifyPreserveTopology`
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command works quickly, using a variant of the **Douglas-Peucker**
    algorithm, and effectively reduces the vertex number. But the resulting polygons,
    in some cases, are not adjacent any more. If you zoom in at any polygon border,
    you should notice something shown in the following screenshot: there are holes
    and overlaps along the shared border between two polygons. This is because PostGIS
    is using the OGC Simple Feature model, which doesn''t implement topology, so the
    function just removes the redundant vertex without taking the adjacent polygons
    into consideration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98800160-9449-4ed8-8204-a0037db378d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It looks like the `ST_SimplifyPreserveTopology` function, while working well
    with linear features, produces topological anomalies with polygons. In case you
    want topological simplification, another approach is the following code suggested
    by *Paul Ramsey* ([http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons](http://gis.stackexchange.com/questions/178/simplifying-adjacent-polygons))
    and improved in a *Webspaces* blog post ([http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise](http://webspaces.net.nz/page.php?view=polygon-dissolve-and-generalise)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This approach seems to work smoothly, but if you try to increment the simplifying
    tolerance from 150 to, let's say, 500 meters, you will again end up with topological
    anomalies (test this yourself). A better approach would be to use the PostGIS
    topology (you will do this in the *Simplifying geometries with PostGIS topology*
    recipe) or an external GIS tool that is able to manage topological operations
    the way `GRASS` can. For this recipe, you will use the `GRASS` approach.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install `GRASS` on your system if you don''t have it. Then, create a directory
    to contain the `GRASS` database (in `GRASS` jargon, a `GISDBASE`), as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, start `GRASS` by typing `grass` in the Linux command prompt or by double-clicking
    on the GRASS GUI icon in Windows (Start | All Programs | OSGeo4W | GRASS GIS 6.4.3
    | GRASS 6.4.3 GUI) or on Applications in macOS. You will be prompted to select
    the `grass_db` database as the GIS data directory but should instead select the
    one you created in the previous step.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Location Wizard button, create a location named `postgis_cookbook`
    with the title `PostGIS Cookbook` (`GRASS` uses subdirectories named locations,
    where all of the data is kept in the same coordinate system, map projection, and
    geographical boundaries).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the new location, select the EPSG with SRID 2163 as the spatial
    reference system (you need to select the Select EPSG code of spatial reference
    system option under Choose method for creating a new location).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now start `GRASS` by clicking on the Start GRASS button. The program's command
    line will start as shown in the following screenshot:![](img/01a70de2-a7c1-40f7-92ca-6d5994ef953e.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `states` PostGIS spatial table to the `GRASS` location. To do so,
    use the `v.in.ogr GRASS` command, which will then use the OGR PostgreSQL driver
    (in fact, the PostGIS connection string syntax is the same):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`GRASS` will import the OGR PostGIS table and simultaneously build the topology
    for this layer, which is composed of points, lines, areas, and so on. The `v.info`
    command can be used in combination with the `-c` option to check the attributes
    table and get more information on the imported layer, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/92ffb6e9-703e-430f-8fdf-6ccb5743daee.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'Now, you can simplify the polygon geometries using the `v.generalizeGRASS` command
    with a tolerance (threshold) of 500 meters. If you are using the same dataset
    used in this recipe, you will end up with 47,191 vertices from the original 346,914
    vertices, composing 1,919 polygons (areas) from the original 2,895 polygons:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Export the results back to PostGIS using the `v.out.ogr` command (the `v.in.ogr`
    counterpart) as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Now, open a desktop GIS and check for differences between the geometry simplification
    performed by the `ST_SimplifyPreserveTopology` PostGIS function and `GRASS`. There
    should be no holes or overlaps at shared polygon borders. In the following screenshot,
    the original layer boundaries are in red, the boundaries built by `ST_SimplifyPreserveTopology`
    are in blue, and those built by `GRASS` are in green:![](img/060b961d-896d-4c37-895b-26c439c6ff7b.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ST_Simplify` PostGIS function is able to simplify and generalize either
    a (simple or multi) linear or polygonal geometry using the Douglas-Peucker algorithm
    (for more details, go to [http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)).
    Since it can create invalid geometries in some cases, it is recommended that you
    use its evolved version—the `ST_SimplifyPreserveTopology` function—which will
    produce only valid geometries.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: While the functions are working well with (multi) linear geometries, in the
    case of (multi) polygons, they will most likely create topological anomalies such
    as overlaps and holes at shared polygon borders.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get a valid, topologically simplified dataset, there are the following two
    choices at the time of writing:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Performing the simplified process on an external GIS tool such as `GRASS`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new PostGIS topological support
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While you will see the new PostGIS topological features in the *Simplifying
    geometries with PostGIS topology* recipe, in this one you have been using `GRASS`
    to perform the simplification process.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We opened `GRASS`, created a GIS data directory and a project location, and
    then imported in the `GRASS` location, the polygonal PostGIS table using the `v.ogr.in`
    command, based on GDAL/OGR as the name suggests.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Until this point, you have been using the `GRASS v.generalize` command to perform
    the simplification of the dataset using a tolerance (threshold) expressed in meters.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: After simplifying the dataset, you imported it back to PostGIS using the `v.ogr.out
    GRASS` command and then opened the derived spatial table in a desktop GIS to see
    whether or not the process was performed in a topologically correct way.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Measuring distances
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will check out the PostGIS functions needed for distance
    measurements (`ST_Distance` and its variants) and find out how considering the
    earth's curvature makes a big difference when measuring distances between distant
    points.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should import the shapefile representing the cities from the USA that we
    generated in a previous recipe (the PostGIS table named `chp03.cities`). In case
    you haven''t done so, download that shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/) website
    at [http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz)
    (this archive is also included in the code bundle available with this book) and
    import it to PostGIS:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to perform to complete this recipe are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, use the `ST_Distance` function to calculate the distances between cities
    in the USA that have more than 1 million inhabitants using the Spherical Mercator
    planar projection coordinate system (EPSG:900913, EPSG:3857, or EPSG:3785; all
    of these SRID representations are equivalent). Use the `ST_Transform` function
    as follows to convert the point coordinates from longitude latitude degrees (as
    the coordinates are originally in EPSG:4326) to a planar metric system if you
    want the results in meters:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/425da6aa-4cd1-4b21-b65e-eea04e1449a3.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now write the same query as we did in the previous recipe, but in a more compact
    expression using a PostgreSQL **Common Table Expression** (**CTE**):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'For large distances such as in this case, it is not correct to use a planar
    spatial reference system, but you should make the calculations taking into consideration
    the earth''s curvature. For example, the previously used Mercator planar system,
    while it is very good to use for map outputs, is very bad for measuring distances
    and areas as it assesses directions. For this purpose, it would be better to use
    a spatial reference system that is able to measure distance. You can also use
    the `ST_Distance_Sphere` or `ST_Distance_Spheroid` functions (the first being
    quicker, but less accurate, as it performs calculations on a sphere and not a
    spheroid). An even better option is converting the geometries to the geography
    data type, so you can use `ST_Distance` directly, as it will automatically make
    the calculations using the spheroid. Note that this is exactly equivalent to using
    `ST_DistanceSpheroid`. Try to check the difference between the various approaches,
    using the same query as before:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/0f7e7db6-3a36-43d1-8c4b-29218c0681e2.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE51]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You can easily verify from the output that there is a big difference with using
    the planar system (EPSG:900913, as in the `d_900913` column) instead of systems
    that take into consideration the curvature of the earth.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to compute the minimum Cartesian distance between two points, you
    can use the PostGIS `ST_Distance` function. This function accepts two-point geometries
    as input parameters and these geometries must be specified in the same **spatial
    reference system**.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If the two input geometries are using different spatial references, you can
    use the `ST_Transform` function on one or both of them to make them consistent
    with a single spatial reference system.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To get better results, you should consider the earth's curvature, which is mandatory
    when measuring large distances, and use the `ST_Distance_Sphere` or the `ST_Distance_Spheroid`
    functions. Alternatively, use `ST_Distance`, but cast the input geometries to
    the **geography spatial data type**, which is optimized for this kind of operation.
    The geography type stores the geometries in WGS 84 longitude latitude degrees,
    but it always returns the measurements in meters.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, you have used a PostgreSQL CTE, which is a handy way to provide
    a subquery in the context of the main query. You can consider a CTE as a temporary
    table used only within the scope of the main query.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Merging polygons using a common attribute
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many cases in GIS workflows where you need to merge a polygonal dataset
    based on a common attribute. A typical example is merging the European administrative
    areas (which you can see at [http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics](http://en.wikipedia.org/wiki/Nomenclature_of_Territorial_Units_for_Statistics)),
    starting from **Nomenclature des Units Territoriales Statistiques** (**NUTS**)
    level 4 to obtain the subsequent levels up to NUTS level 1, using the NUTS code
    or merging the USA counties layer using the state code to obtain the states layer.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: PostGIS lets you perform this kind of processing operation with the `ST_Union`
    function.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the USA countries shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/) website
    at [http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/co2000p020_nt00157.tar.gz)
    (this archive is also included in the code bundle provided with this book) and
    import it in PostGIS as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to perform to complete this recipe are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, check the imported table by running the following commands:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/788d8e93-ee09-4743-b564-769622356040.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now perform the merging operation based on the `state_fips` field, using the
    `ST_Union` PostGIS function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The following screenshot shows how the output PostGIS layer looks in a desktop
    GIS; the aggregate counties have successfully been composed by their respective
    state (indicated by the thick blue border):![](img/fb9f84b5-447f-498f-ad80-68d4c6ed1576.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You have been using the `ST_Union` PostGIS function to make a polygon merge
    on a common attribute. This function can be used as an aggregate PostgreSQL function
    (such as `SUM`, `COUNT`, `MIN`, and `MAX`) on the layer's geometric field, using
    the common attribute in the `GROUP BY` clause.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that `ST_Union` can also be used as a non-aggregate function to perform
    the union of two geometries (which are the two input parameters).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Computing intersections
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: One typical GIS geoprocessing workflow is to compute intersections generated
    by intersecting linear geometries.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: PostGIS offers a rich set of functions for solving this particular type of problem
    and you will have a look at them in this recipe.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the Rivers + lake centerlines dataset of North
    America and Europe with a scale 1:10m. Download the `rivers` dataset from the
    following `naturalearthdata.com` website (or use the ZIP file included in the
    code bundle provided with this book):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip](http://www.naturalearthdata.com/http//www.naturalearthdata.com/download/10m/physical/ne_10m_rivers_lake_centerlines.zip)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Or find it on the following website:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://www.naturalearthdata.com/downloads/10m-physical-vectors/](http://www.naturalearthdata.com/downloads/10m-physical-vectors/)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extract the shapefile to your working directory `chp03/working`. Import the
    shapefile in PostGIS using `shp2pgsql` as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to perform to complete this recipe are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, perform a self-spatial join between your `MultiLineString` dataset and
    the PostGIS `ST_Intersects` function and find intersections in the join context
    with the `ST_Intersection` PostGIS function. The following is the basic query,
    resulting in 1,448 records being selected:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You may hastily assume that all of the intersections are single points, but
    this is not the case; if you check the geometry type of the geometric intersections
    using the `ST_GeometryType` function, you have three different cases of intersection,
    resulting in the following geometries:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `ST_POINT` geometry for a simple intersection between two linear geometries.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An `ST_MultiPoint` geometry, if two linear geometries intersect each other at
    more points.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: An `ST_GeometryCollection` geometry in cases where the two `MultiLineString`
    objects intersect and share part of the line. In such a case, the geometry collection
    is composed of `ST_Point` and/or `ST_Line` geometries.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check the different cases with a query, shown as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/533aad33-1f44-4cb4-85d7-9bd94691ee92.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE59]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'First, try to compute the intersection for just the first two cases (intersections
    composed of the `ST_Point` and `ST_MultiPoint` geometries). Just generate a table
    with the `Point` and `MultiPoint` geometries, excluding the records that have
    an intersection composed of a geometric collection. By executing the following
    commands, 1,444 of the 1,448 records are imported (the four records with geometry
    collections are ignored using the `ST_GeometryType` function):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In case you want to import the points from the geometry collection too (but
    just the points, ignoring the eventual linestrings), one way to go about it is
    by using the `ST_CollectionExtract` function in the context of a `SELECT``CASE`
    PostgreSQL conditional statement; this way, you can import all the 1,448 intersections
    as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You may see the difference between the two processes, counting the total number
    of points in each of the generated tables, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In the following screenshot (taken from QGIS), you may notice the generated
    intersections generated by both approaches. In the case of the `intersection_all`
    layer, you will notice that some more intersections have been computed (in red):![](img/5a880965-4a30-4972-b6f9-03b988419711.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Layers of river intersections visualized in QGIS
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using a self-spatial join of a linear PostGIS spatial layer to
    find intersections generated by the features of that layer.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To generate the self-spatial join, we used the `ST_Intersects` function. This
    way, we found that all of the features have at least an intersection in their
    respective geometries.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the same self-spatial join context, we found out the intersections, using
    the `ST_Intersection` function.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The problem is that the computed intersections are not always single points.
    In fact, two intersecting lines can produce the origin for a single-point geometry
    (`ST_Point`) if the two lines just intersect once. But, the two intersecting lines
    can produce the origin for a point collection (`ST_MultiPoint`) or even a geometric
    collection if the two lines intersect at more points and/or share common parts.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As our target was to compute all the point intersections (`ST_Point` and `ST_MultiPoint`)
    using the `ST_GeometryType` function, we filtered out the values using a SQL `SELECT
    CASE` construct where the feature had a `GeometryCollection` geometry, for which
    we extracted just the points (and not the eventual linestrings) using the `ST_CollectionExtract`
    function (`parameter type = 1`) from the composing collections.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we compared the two result sets, both with plain SQL and a desktop
    GIS. The intersecting points computed filtered out the geometric collections from
    the output geometries and the intersecting points computed from all the geometries
    generated from the intersections, including the `GeometryCollection` features.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Clipping geometries to deploy data
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: A common GIS use case is clipping a big dataset into small portions (subsets),
    with each perhaps representing an area of interest. In this recipe, you will export
    from a PostGIS layer representing the rivers in the world, with one distinct shapefile
    composed of rivers for each country. For this purpose, you will use the `ST_Intersection`
    function.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure that you have imported in PostGIS the same river dataset (a shapefile)
    that was used in the previous recipe.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to take to complete this recipe are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, you will create a view to clip the river geometries for each country
    using the `ST_Intersection` and `ST_Intersects` functions. Name the view `rivers_clipped_by_country`:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a directory named `rivers` as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create the following scripts to export a `rivers` shapefile for each country.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the Linux version (name it `export_rivers.sh`):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the Windows version (name it `export_rivers.bat`):'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: For Windows users
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The script uses the `grep` and `awk` Linux commands, so you will need to download
    their Windows versions from [http://unxutils.sourceforge.net/](http://unxutils.sourceforge.net/).
    The script was tested with the `UnxUpdates.zip` file (which includes `gawk`, but
    not `awk`), but you are welcome to download the full version available at [https://sourceforge.net/projects/unxutils/](https://sourceforge.net/projects/unxutils/).
    Also remember to include the folder with the executable files on the Windows path.
    There's a chance that you already have them installed in your system if you have
    installed OSGeo4W, a binary distribution of a broad set of open source, geospatial
    software for win32 environments. You can find it at [http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Windows, run the batch file:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run the following script (in Linux or macOS, you need to assign `execute`
    permissions to the script before running the shell file):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You could eventually skip the creation of the `rivers_clipped_by_country` view
    by replacing the `ogr2ogr` statement in the previous script with the following
    command (`ogr2ogr` passes the content of the `-sql` option directly to PostGIS);
    use `%%f` for Windows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ogr2ogr rivers/rivers_$f.shp PG:"dbname=''postgis_cookbook'' user=''me'' password=''mypassword''"
    -sql "SELECT r.name, c.iso2, ST_Intersection(r.the_geom, c.the_geom) AS the_geom
    FROM chp03.countries AS c JOIN chp03.rivers AS r ON ST_Intersects(r.the_geom,
    c.the_geom) WHERE c.iso2 = ''$f''"`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Check the output with `ogrinfo` or a desktop GIS. The following screenshot shows
    how the output looks in QGIS; we have added the original PostGIS `chp03.rivers`
    layer and a couple of the generated shapefiles:![](img/dc5c0ed4-c4bd-43de-a354-d248e33ca342.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `ST_Intersection` function to clip one dataset from another.
    In this recipe, you first created a view, where you performed a spatial join between
    a polygonal layer (countries) and a linear layer (rivers) using the `ST_Intersects`
    function. In the context of the spatial join, you have used the `ST_Intersection`
    function to generate a snapshot of the rivers in every country.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You have then created a bash script in which you iterated every single country
    and pulled out to a shapefile the clipped rivers for that country, using `ogr2ogr`
    and the previously created view as the input layer.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To iterate the countries in the script, you have been using `ogrinfo` with the
    `-sql` option, using a SQL `SELECT DISTINCT` statement. You have used a combination
    of the `grep` and `awk` Linux commands, piped together to get every single country
    code. The `grep` command is a utility for searching plaintext datasets for lines
    matching a regular expression, while `awk` is an interpreted programming language
    designed for text processing and typically used as a data extraction and reporting
    tool.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Simplifying geometries with PostGIS topology
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous recipe, we used the `ST_SimplifyPreserveTopology` function to
    try to generate a simplification of a polygonal PostGIS layer.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, while that function works well for linear layers, it produces
    topological anomalies (overlapping and holes) in shared polygon borders. You used
    an external toolset (`GRASS`) to generate a valid topological simplification.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In this recipe, you will use the PostGIS topology support to perform the same
    task within the spatial database, without needing to export the dataset to a different
    toolset.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, perform the following steps:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Be sure that you have PostGIS topology support enabled in your database instance.
    This support is packaged as a separate extension and, if you are using PostgreSQL
    9.1 or newer versions, you can install it using the following SQL `CREATE EXTENSION`
    command:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Download the administrative area archive for Hungary from the `gadm.org` website
    at [http://gadm.org/country](http://gadm.org/country) (or use the copy included
    in the code bundle provided with this book).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the `HUN_adm1.shp` shapefile from the archive to your working directory,
    `working/chp03`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the shapefile to PostGIS using a tool such as `ogr2ogr` or `shp2pgsql`,
    as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'After the import process is completed, you can check the count using the following
    command; note that this spatial table consists of 20 multipolygons, each representing
    one administrative area in Hungary:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/0257f42c-5d33-4cd0-ad04-581f630b2918.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE72]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps you need to take to complete this recipe are as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All functions and tables associated with the topology module are installed
    in a schema named `topology`, so let''s add it to the search path to avoid prefixing
    it before every `topology` function or object:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you will use the `CreateTopology` function to create a new `topology` schema
    named `hu_topo` in which you will import the 20 administrative areas from the
    `hungary` table. In PostGIS topology, all the topology entities and relations
    needed for one topology schema are stored in a single PostgreSQL schema using
    the same spatial reference system. You will name this schema `hu_topo` and use
    the EPSG:3857 spatial reference (the one used in the original shapefile):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Note how a record has been added to the `topology.topology` table in the following
    code:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/907e7558-c19e-4349-a68f-c3372087b596.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE76]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Also note that four tables and one view, which are needed for storing and managing
    the topology, have been generated in the schema named `hu_topo`, created from
    the `CreateTopology` function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/57fcdf33-578f-49f7-98a0-8b5ab182a381.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE78]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the initial information for the created topology using the `topologysummary`
    function, as follows; still, none of the topologic entities (nodes, edges, faces,
    and so on) are initialized:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/02280017-3cd2-4ad0-8b3f-7af9cd4bfa24.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE80]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new PostGIS table as follows for storing the topological administrative
    boundaries:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a topological geometry column to this table as follows, using the `AddTopoGeometryColumn`
    function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the polygons from the non-topological `hungary` spatial table to the
    topological table, using the `toTopoGeom` function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the following code to check out how the content of the topology schema
    has been modified by the `toTopoGeom` function; you would expect to have 20 faces,
    one for each Hungarian administrative area, but instead there are 92:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/698f067b-bfbd-4c6e-bf65-5fdb46f8167e.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: 'The problem is easily identifiable by analyzing the `hu_topo.face` table or
    using a desktop GIS. If you sort the polygons from this table by area, using the
    `ST_Area` function, you will notice after the details of the first polygon, which
    has 1 null area (used by the topology screenshot in the next step) and 20 large
    areas (each representing one administrative area), that there are 77 very small
    polygons generated by topological anomalies (polygon overlaps and holes):'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/167416ff-d3a3-45e6-bb14-ec4a9a1bd452.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE86]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: You can eventually look at the built topology elements (nodes, edges, faces,
    and topological geometries, or topogeoms) using a desktop GIS. The following screenshot
    shows how they look in QGIS:![](img/85c159b9-4d66-4148-a1ca-326b71643541.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now you will rebuild the topology using a small tolerance value—1 meter—as
    an additional parameter to the `CreateTopology` function, in order to get rid
    of the unnecessary faces (the tolerance will collapse the vertex together, eliminating
    the small polygons). First, drop your topology schema with the `DropTopology`
    function and the topological table with the `DROP TABLE` command, and rebuild
    both of them using a topology tolerance of 1 meter, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you check the information related to the topology using the `topologysummary`
    function as follows, you can see that there is one face per administrative boundary
    and the previous 72 faces generated by topological anomalies have been eliminated,
    leaving only 20:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/d75f81c3-2397-441c-90d1-15e22c38b671.png)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE89]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, simplify the polygons of the `topo_polygons` table using a tolerance
    of 500 meters, as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to update the original `hungary` table using a join with the
    `hu_topo_polygons` table by running the following commands:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The simplification process should have worked smoothly and produced a valid
    topological dataset. The following screenshot shows how the reduced topology looks
    (in red) compared to the original one (in black):![](img/e9fdda00-3e16-4eb9-9adb-cd9aba73f140.png)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a new PostGIS topology schema using the `CreateTopology` function.
    This function creates a new PostgreSQL schema where all the topological entities
    are stored.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can have more topological schemas within the same spatial database, each
    being contained in a different PostgreSQL schema. The PostGIS `topology.topology`
    table manages all the metadata for all the topological schemas.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Each topological schema is composed of a series of tables and views to manage
    the topological entities (such as edge, edge data, face, node, and topogeoms)
    and their relations.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can have a quick look at the description of a single topological schema using
    the `topologysummary` function, which summarizes the main metadata information-name,
    SRID, and precision; the number of nodes, edges, faces, topogeoms, and topological
    layers; and, for each topological layer, the geometry type, and the number of
    topogeoms.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: After creating the topology schema, we created a new PostGIS table and added
    to it a topological geometry column (`topogeom` in PostGIS topology jargon) using
    the `AddTopoGeometryColumn` function.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We then used the `ST_ChangeEdgeGeom` function to alter the geometries for the
    topological edges, using the `ST_SimplifyPreserveTopology` function, with a tolerance
    of 500 meters, and checked that this function, used in the context of a topological
    schema, produces topologically correct results for polygons too.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
