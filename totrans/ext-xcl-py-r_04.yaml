- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Automating Further – Task Scheduling and Email
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步自动化 - 任务调度和电子邮件
- en: Sometimes, we can spend countless hours tediously creating, formatting, and
    emailing Excel spreadsheets. Well, fret no more! With the power of programming,
    specifically R or Python, you can effortlessly automate these mundane tasks and
    reclaim your precious time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能会花费无数个小时耐心地创建、格式化和发送 Excel 电子表格。但是，别担心！有了编程的力量，特别是 R 或 Python，您可以轻松自动化这些繁琐的任务，并重新获得宝贵的时间。
- en: 'Imagine this: you have a list of sales data that needs to be organized into
    a professional-looking spreadsheet and sent to multiple recipients via email.
    Instead of slogging through manual data entry and formatting, you can leverage
    the prowess of R or Python to simplify your workflow.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：您有一份需要整理成专业外观的销售额数据列表，并通过电子邮件发送给多个收件人。与其手动进行数据输入和格式化，您可以利用 R 或 Python 的强大功能简化您的工作流程。
- en: In R, you can use the amazing `taskscheduleR` package to schedule tasks and
    run your script automatically at specified times. With this, you can set up a
    recurring job to generate your Excel spreadsheets and send them out without lifting
    a finger. For emailing, you can employ the `RDCOMClient`, `Windows365R`, or `blastula`
    packages, which allow you to interact with Outlook and Gmail directly. This means
    you can compose and send emails with the attached spreadsheets effortlessly, customizing
    the content and recipients as needed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，您可以使用惊人的 `taskscheduleR` 包来安排任务，并在指定时间自动运行您的脚本。有了这个，您可以设置一个重复的任务来生成您的
    Excel 电子表格并发送它们，无需动手。对于电子邮件，您可以使用 `RDCOMClient`、`Windows365R` 或 `blastula` 包，这些包允许您直接与
    Outlook 和 Gmail 交互。这意味着您可以轻松地编写和发送带有附件的电子邮件，并根据需要自定义内容和收件人。
- en: But wait, Python enthusiasts! Fear not, for you, too, can achieve the same level
    of automation magic. In Python, you can utilize the `pywin32` library to send
    out beautifully formatted emails via Gmail. It seamlessly integrates with your
    code, enabling you to attach your Excel spreadsheets and customize the email’s
    content and recipients with ease.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Python 爱好者们，不要担心，您也可以达到同样的自动化魔法水平。在 Python 中，您可以使用 `pywin32` 库通过 Gmail 发送格式优美的电子邮件。它与您的代码无缝集成，使您能够轻松地附加
    Excel 电子表格并自定义电子邮件的内容和收件人。
- en: By harnessing the power of R or Python, along with `taskscheduleR`, `RDCOMClient`,
    `Windows365R`, or `blastula`, you can become the hero of your office, delivering
    accurate, visually appealing spreadsheets promptly, all while sipping your coffee.
    Say goodbye to mind-numbing repetition and hello to efficient automation. Let
    your creativity flourish as you unlock the power of R or Python to conquer the
    world of Excel spreadsheets and email distribution with confidence and ease!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 R 或 Python 的力量，结合 `taskscheduleR`、`RDCOMClient`、`Windows365R` 或 `blastula`，您可以成为办公室的英雄，迅速提供准确、视觉上吸引人的电子表格，同时品尝您的咖啡。告别令人厌烦的重复工作，迎接高效的自动化。让您的创造力蓬勃发展，解锁
    R 或 Python 的力量，自信且轻松地征服 Excel 电子表格和电子邮件分发的世界！
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Installing and understanding the `taskscheduleR` library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和理解 `taskscheduleR` 库
- en: Using `RDCOMClient`, `Windows365R`, and `blastula` for email in Outlook or Gmail
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RDCOMClient`、`Windows365R` 和 `blastula` 在 Outlook 或 Gmail 中进行电子邮件操作
- en: Scheduling Python scripts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排 Python 脚本
- en: Email notifications and automation with Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 进行电子邮件通知和自动化
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204)。
- en: 'You will need to install the following new R and Python packages:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装以下新的 R 和 Python 包：
- en: '`Blastula`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blastula`'
- en: '`Windows365R`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Windows365R`'
- en: '`schedule==1.2.0`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule==1.2.0`'
- en: '`apscheduler==3.10.1`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apscheduler==3.10.1`'
- en: Installing and understanding the tasksheduleR library
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和理解 tasksheduleR 库
- en: 'The `taskscheduleR` R package allows you to schedule R scripts or processes
    with the Windows task scheduler. This means that you can automate R processes
    on specific time points from within R itself. The package is basically a wrapper
    around the `Schtasks.exe` functionality. `Schtasks.exe` is a command line tool
    that allows you to create, delete, query, change, run, and finish scheduled tasks
    on a local or remote computer. To use `taskscheduleR`, you first need to install
    the package from CRAN. Once the package is installed, you can use the following
    functions to schedule R scripts:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskscheduleR` R包允许您使用Windows任务计划程序安排R脚本或进程。这意味着您可以在R内部自动执行特定时间点的R进程。该包基本上是`Schtasks.exe`功能的包装器。`Schtasks.exe`是一个命令行工具，允许您在本地或远程计算机上创建、删除、查询、更改、运行和完成计划任务。要使用`taskscheduleR`，您首先需要从CRAN安装该包。一旦安装了包，您就可以使用以下函数来安排R脚本：'
- en: '`taskscheduler_create()`: This function creates a new scheduled task.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskscheduler_create()`: 此函数创建一个新的计划任务。'
- en: '`taskscheduler_remove()`: This function removes an existing scheduled task.
    If you are using version 1.8, then the function is `taskscheduler_delete()`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskscheduler_remove()`: 此函数删除现有的计划任务。如果您使用的是版本1.8，则该函数为`taskscheduler_delete()`。'
- en: '`taskscheduler_get()`: This function gets the information about an existing
    scheduled task.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskscheduler_get()`: 此函数获取现有计划任务的信息。'
- en: 'The `taskscheduler_create()` function takes a number of arguments, including
    the name of the scheduled task, the R script to run, and the schedule to run the
    script. For example, the following code would create a scheduled task that runs
    the R script `my_scheduled_excel_script.R` every day at 10:00 am:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskscheduler_create()`函数接受多个参数，包括计划任务名称、要运行的R脚本和运行脚本的计划。例如，以下代码将创建一个每天上午10:00运行R脚本`my_scheduled_excel_script.R`的计划任务：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also use the GUI to create tasks for the job scheduler by installing
    `miniUI` and `shiny`. This will install the add-in capability of the package,
    allowing you to easily create jobs without writing a single line of code. Here
    is the code you can use if you want to install the preceding packages listed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过安装`miniUI`和`shiny`来使用GUI为作业调度器创建任务。这将安装包的附加功能，让您可以轻松创建任务而无需编写任何代码。如果您想安装前面列出的包，可以使用以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we see how to create scripts for this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看如何创建这些脚本。
- en: Creating sample scripts
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建示例脚本
- en: The first thing we need to do is create a script that can be run via the Windows
    task scheduler. Let’s keep the script simple and just print `Hello` and the current
    date and time using the R function `Sys.time()`. After this is done, we can then
    create a couple of jobs that will run the script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个可以通过Windows任务计划程序运行的脚本。让我们保持脚本简单，只使用R函数`Sys.time()`打印`Hello`和当前日期和时间。完成此操作后，我们就可以创建几个将运行脚本的作业。
- en: 'Here is the `hello_world.R` script:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`hello_world.R`脚本：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line of code, `library("tcltk")`, loads the `tcltk` package, which
    provides functions for creating and interacting with **graphical user interfaces**
    (**GUIs**) in R.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码，`library("tcltk")`，加载了`tcltk`包，该包提供了在R中创建和与**图形用户界面**（**GUIs**）交互的函数。
- en: The second line of code, `tkmessageBox()`, creates a message box. The message
    box is a pop-up window that displays a message and allows the user to take some
    action, such as clicking a button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码，`tkmessageBox()`，创建一个消息框。消息框是一个弹出窗口，显示一条消息并允许用户采取某些操作，例如点击按钮。
- en: 'The arguments to the `tkmessageBox()` function are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkmessageBox()`函数的参数如下：'
- en: '`title`: The title of the message box.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 消息框的标题。'
- en: '`message`: The message that will be displayed in the message box.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 将在消息框中显示的消息。'
- en: '`type`: The type of message box. The possible values are `ok`, `okcancel`,
    `yesno`, `yesnocancel`, `retrycancel`, and `abortretryignore`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`: 消息框的类型。可能的值有`ok`、`okcancel`、`yesno`、`yesnocancel`、`retrycancel`和`abortretryignore`。'
- en: In this case, the type of message box is `ok`, which means that the user can
    only click an `ok` button to close the message box.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息框的类型是`ok`，这意味着用户只能点击一个`ok`按钮来关闭消息框。
- en: 'The third line of code, `paste0("Hello, it is: ", Sys.time())`, creates a string
    that will be displayed in the message box. The string includes the current time,
    which is obtained from the `Sys.time()` function.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '第三行代码，`paste0("Hello, it is: ", Sys.time())`，创建一个将在消息框中显示的字符串。该字符串包括从`Sys.time()`函数获取的当前时间。'
- en: When this code is run, a message box will pop up that displays the current time
    and an `ok` button. The user can click the **OK** button to close the message
    box.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，将弹出一个消息框，显示当前时间和一个 `ok` 按钮。用户可以点击 **OK** 按钮关闭消息框。
- en: 'Here is a screenshot of what the message box will look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是消息框外观的截图：
- en: '![Figure 4.1 – Hello world message box](img/B19142_04_1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Hello world 消息框](img/B19142_04_1.jpg)'
- en: Figure 4.1 – Hello world message box
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Hello world 消息框
- en: 'Now, let’s make a couple of scripts that will pop this message up on a screen
    on schedule. Here is one that will run this hourly:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写几个脚本，它们将在预定时间在屏幕上弹出此消息。以下是一个每小时运行一次的脚本：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of code, `taskscheduler_create()`, calls the `taskscheduler_create()`
    function from the `taskscheduleR` package. The `taskscheduleR` package provides
    functions for creating and managing Windows task scheduler jobs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行，`taskscheduler_create()`，调用了来自 `taskscheduleR` 包的 `taskscheduler_create()`
    函数。`taskscheduleR` 包提供了用于创建和管理 Windows 任务调度器作业的函数。
- en: 'The `taskscheduler_create()` function takes the following three arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskscheduler_create()` 函数接受以下三个参数：'
- en: '`taskname`: The name of the task scheduler job'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`taskname`：任务调度器作业的名称'
- en: '`rscript`: The path to the R script that will be run by the task scheduler
    job'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rscript`：任务调度器作业将要运行的 R 脚本的路径'
- en: '`schedule`: The schedule for the task scheduler job'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule`：任务调度器作业的调度'
- en: In this case, the task name is `Hello World Hourly`, the R script is `hello_world.R`,
    and the schedule is `"HOURLY"`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，任务名称是 `Hello World Hourly`，R 脚本是 `hello_world.R`，调度是 `"HOURLY"`。
- en: The second line of code, `taskname = "Hello World Hourly"`, sets the task name
    to `Hello World Hourly`. The task name is a unique identifier for the task scheduler
    job.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二行，`taskname = "Hello World Hourly"`，将任务名称设置为 `Hello World Hourly`。任务名称是任务调度器作业的唯一标识符。
- en: The third line of code, `rscript = "hello_world.R"`, sets the path to the R
    script that will be run by the task scheduler job. The R script must be saved
    in a location that is accessible by the task scheduler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第三行，`rscript = "hello_world.R"`，设置了任务调度器作业将要运行的 R 脚本的路径。R 脚本必须保存在任务调度器可以访问的位置。
- en: The fourth line of code, `schedule = "HOURLY"`, sets the schedule for the task
    scheduler job. The schedule is a string that specifies when the task scheduler
    job will run. The schedule `"HOURLY"` means that the task scheduler job will run
    every hour. When this code is run, a new task scheduler job will be created that
    runs the `hello_world.R` R script every hour.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第四行，`schedule = "HOURLY"`，设置了任务调度器作业的调度。调度是一个字符串，指定了任务调度器作业何时运行。调度 `"HOURLY"`
    表示任务调度器作业将每小时运行一次。当运行此代码时，将创建一个新的任务调度器作业，每小时运行 `hello_world.R` R 脚本。
- en: Now, we will move on to using `RDCOMClient` for Outlook if you are not using
    Microsoft 365\. This will allow us to script sending emails inside of other processes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你不使用 Microsoft 365，我们将继续使用 `RDCOMClient` 来操作 Outlook。这将使我们能够在其他进程中编写发送电子邮件的脚本。
- en: RDCOMClient for Outlook
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Outlook 的 RDCOMClient
- en: 'As we have seen, `RDCOMClient` is a powerful R package that allows you to interact
    with Microsoft Outlook using the COM interface. With `RDCOMClient`, you can automate
    tasks in Outlook, such as sending emails, accessing folders, managing appointments,
    and more. Sending emails via Outlook using `RDCOMClient` is straightforward and
    can be achieved by following a few steps. Here is the script for it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`RDCOMClient` 是一个强大的 R 包，它允许你通过 COM 接口与 Microsoft Outlook 进行交互。使用 `RDCOMClient`，你可以自动化
    Outlook 中的任务，例如发送电子邮件、访问文件夹、管理约会等。通过 `RDCOMClient` 使用 Outlook 发送电子邮件非常简单，只需遵循几个步骤即可。以下是相应的脚本：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let us now understand each line of the preceding code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在理解前面代码的每一行：
- en: First, you need to install and load the `RDCOMClient` package in your R environment.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要在 R 环境中安装并加载 `RDCOMClient` 包。
- en: Once installed, load the package using the `library()` function.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装，使用 `library()` 函数加载该包。
- en: Next, create a new Outlook application object using the `COMCreate()` function.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `COMCreate()` 函数创建一个新的 Outlook 应用程序对象。
- en: This creates a connection to the Outlook application. Now, you can create a
    new email object using the `OutApp$CreateItem()` method and specify the email
    type as `olMailItem`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将建立与 Outlook 应用程序的连接。现在，你可以使用 `OutApp$CreateItem()` 方法创建一个新的电子邮件对象，并指定电子邮件类型为
    `olMailItem`。
- en: 'Next, you can set various properties of the email, such as the recipient, subject,
    body, attachments, and more. Here’s an example of how you can set these properties:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以设置电子邮件的各种属性，例如收件人、主题、正文、附件等。以下是如何设置这些属性的示例：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After setting the desired properties, you can send the email using the `Send()`
    method, and that’s it!
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置所需的属性后，您可以使用`Send()`方法发送电子邮件，然后就可以结束了！
- en: The email will be sent from your Outlook account to the specified recipient(s)
    with the configured properties. Remember to release the COM object and terminate
    the connection once you are done.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电子邮件将从您的Outlook账户发送到指定的收件人，并带有配置的属性。记得在完成操作后释放COM对象并终止连接。
- en: This ensures that the resources are properly released.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了资源得到适当的释放。
- en: By using `RDCOMClient`, you can automate email-sending tasks in Outlook directly
    from R, enabling you to streamline your workflow and save time. It provides a
    convenient way to integrate R with Outlook and leverage its features programmatically.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`RDCOMClient`，您可以直接从R中自动化Outlook中的电子邮件发送任务，从而让您的工作流程更加流畅并节省时间。它提供了一个方便的方法将R与Outlook集成，并允许以编程方式利用其功能。
- en: Now, we will delve into the `Microsoft365R` and `blastula` packages, which work
    in tandem. This will be instead of using the `RDCOMClient` library, with the reason
    being that Microsoft365R works for those that are using Microsoft Azure instead
    of a generic SMTP connection via Outlook.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨`Microsoft365R`和`blastula`这两个协同工作的包。这将替代使用`RDCOMClient`库，原因在于`Microsoft365R`适用于使用Microsoft
    Azure而不是通过Outlook的通用SMTP连接的用户。
- en: Using the Microsoft365R and blastula packages
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Microsoft365R和blastula包
- en: We are now going to go over two packages that can be used in conjunction with
    each other to create emails via Outlook from Microsoft. These packages are Microsoft365R
    and blastula. Let’s look at them in the following sections.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍两个可以相互配合使用以通过Microsoft Outlook创建电子邮件的包。这些包是Microsoft365R和blastula。让我们在接下来的部分中查看它们。
- en: Microsoft365R
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft365R
- en: '**Microsoft365R** is an R library that provides an interface to Microsoft 365
    (formerly known as Office 365) cloud services. It is built on top of the AzureGraph
    package, which provides a high-level abstraction for interacting with the Microsoft
    Graph API. Microsoft365R currently supports the following Microsoft 365 services:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft365R**是一个R库，它提供了一个接口来访问Microsoft 365（以前称为Office 365）云服务。它建立在`AzureGraph`包之上，该包为与Microsoft
    Graph API交互提供了高级抽象。目前，`Microsoft365R`支持以下Microsoft 365服务：'
- en: Teams
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Teams
- en: Outlook
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Outlook
- en: SharePoint Online
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SharePoint Online
- en: OneDrive
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OneDrive
- en: The library provides several top-level client functions for accessing each of
    these services. For example, the `get_personal_onedrive()` function can be used
    to access your personal OneDrive account, and the `get_business_outlook()` function
    can be used to access your work or school Outlook account.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该库为访问每个这些服务提供了几个顶级客户端函数。例如，`get_personal_onedrive()`函数可以用来访问您的个人OneDrive账户，而`get_business_outlook()`函数可以用来访问您的工作或学校Outlook账户。
- en: Microsoft365R also provides several helper functions for working with the Microsoft
    Graph API. For example, the `list_drive_contents()` function can be used to list
    the contents of a OneDrive drive, and the `send_email()` function can be used
    to send an email from Outlook.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft365R还提供了一些用于处理Microsoft Graph API的辅助函数。例如，`list_drive_contents()`函数可以用来列出OneDrive驱动器的内容，而`send_email()`函数可以用来从Outlook发送电子邮件。
- en: The library is well-documented and provides several examples to help you get
    started. It is also actively maintained and updated with new features and bug
    fixes on a regular basis.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该库有良好的文档记录，并提供了一些示例来帮助您开始使用。它还定期积极维护和更新，包括新功能和错误修复。
- en: 'Here are some of the benefits of using Microsoft365R:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Microsoft365R的一些好处如下：
- en: It provides a simple and easy-to-use interface for accessing Microsoft 365 cloud
    services
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个简单易用的界面，用于访问Microsoft 365云服务
- en: It is built on top of the `AzureGraph` package, which provides a high-level
    abstraction for interacting with the Microsoft Graph API
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它建立在`AzureGraph`包之上，该包为与Microsoft Graph API交互提供了高级抽象
- en: If you are looking for an R library that provides an easy way to access Microsoft
    365 cloud services, then Microsoft365R is a great option. It is well-documented
    in the package vignettes, actively maintained, and supports a wide range of Microsoft
    365 services. We will only be focusing on its use for Outlook.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个提供访问 Microsoft 365 云服务的 R 库，那么 Microsoft365R 是一个不错的选择。它在包的 vignettes
    中有很好的文档记录，积极维护，并支持广泛的 Microsoft 365 服务。我们将只关注其 Outlook 的使用。
- en: The blastula package
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: blastula 包
- en: 'The `blastula` R package is a tool that makes it easy to produce and send HTML
    email from R. You can use Markdown text, block-based components, and even HTML
    fragments to create email messages with three content areas: a body, header, and
    a footer. The package also provides functions to set up `install.packages("blastula")`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`blastula` R 包是一个工具，它使得从 R 生成和发送 HTML 电子邮件变得容易。你可以使用 Markdown 文本、基于块的组件，甚至
    HTML 片段来创建包含三个内容区域的电子邮件消息：正文、页眉和页脚。该包还提供了设置 `install.packages("blastula")` 的函数。'
- en: 'Some of the advantages of using blastula over other email packages are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 blastula 而不是其他电子邮件包的一些优点如下：
- en: It allows you to use Markdown text, block-based components, and even HTML in
    order to create professional and potentially computed document emails. You can
    achieve this in the body, the header, and the footer of the email.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你使用 Markdown 文本、基于块的组件，甚至 HTML 来创建专业且可能计算出的文档电子邮件。你可以在电子邮件的正文、页眉和页脚中实现这一点。
- en: The package also provides functions to set up SMTP access credentials and send
    email through a traditional SMTP server, or, if you are a RStudio Connect user,
    you can send emails via RStudio Connect.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该包还提供了设置 SMTP 访问凭证和通过传统 SMTP 服务器发送电子邮件的功能，或者如果你是 RStudio Connect 用户，你可以通过 RStudio
    Connect 发送电子邮件。
- en: The resulting email will look great on any display.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的电子邮件在任何显示器上看起来都会很棒。
- en: The syntax is intuitive, allowing you to code quickly and effectively while
    making your primary focus the message of the email itself.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法直观，让你可以快速有效地编写代码，同时将主要关注点放在电子邮件本身的信息上。
- en: 'Here is an example of using `blastula` to create and send a simple HTML email
    message:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 `blastula` 创建和发送简单 HTML 电子邮件消息的示例：
- en: First, we need to load the `blastula` package with `library(blastula)` and `library(glue)`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 `library(blastula)` 和 `library(glue)` 加载 `blastula` 包。
- en: 'Next, we can use the `compose_email()` function to create the email message.
    We can supply Markdown text to the body argument to be rendered in HTML; for example,
    see the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用 `compose_email()` 函数创建电子邮件消息。我们可以向正文参数提供 Markdown 文本以在 HTML 中渲染；例如，参见以下：
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can preview the email message in the viewer by calling the email object:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用电子邮件对象在查看器中预览电子邮件消息：
- en: '[PRE7]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can send the email message through an SMTP server using the `smtp_send()`
    function. We need to provide the recipient’s email address, the sender’s email
    address, the subject line, and the credentials for the SMTP server:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `smtp_send()` 函数通过 SMTP 服务器发送电子邮件消息。我们需要提供收件人的电子邮件地址、发件人的电子邮件地址、主题行和
    SMTP 服务器的凭证：
- en: '[PRE8]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `creds_file()` function is a helper function that creates a credentials
    file for SMTP access.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`creds_file()` 函数是一个辅助函数，用于为 SMTP 访问创建凭证文件。'
- en: 'We can use the `create_smtp_creds_file()` function to generate this file interactively:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 `create_smtp_creds_file()` 函数交互式地生成此文件：
- en: '[PRE9]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will prompt us to enter our password and a two-factor authentication code
    (if enabled) for Gmail. The credentials file will be saved in a secure location
    and can be reused for future email messages.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提示我们输入我们的密码和两步验证码（如果已启用）以访问 Gmail。凭证文件将保存在安全位置，并可以用于未来的电子邮件消息。
- en: Now that we have gone over both packages separately, let’s see how we can use
    them together in a fashion that could be a bit more robust and streamlined.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经单独了解了这两个包，让我们看看如何将它们结合起来使用，以实现更稳健和流畅的效果。
- en: 'Here is a full script, and then we will discuss how it works:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完整的脚本，然后我们将讨论它是如何工作的：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s go over each part of the script to understand what is happening.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一查看脚本中的每个部分，以了解正在发生的事情。
- en: First, we must install both the `blastula` and `Microsoft365R` packages.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装 `blastula` 和 `Microsoft365R` 包。
- en: Then, we call those libraries into the current session using the `library()`
    function.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用 `library()` 函数将那些库调用到当前会话中。
- en: We then create a variable called `outlb` that holds the variable for the `get_business_outlook()`
    function.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为 `outlb` 的变量，用于存储 `get_business_outlook()` 函数的变量。
- en: We then create the body of the email. We can write the email using Markdown
    syntax.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建电子邮件的主体。我们可以使用 Markdown 语法编写电子邮件。
- en: After we make the body of the email, we then create a variable to hold the email
    itself that is created using the function `compose_email()`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建电子邮件的主体之后，我们接着创建一个变量来保存使用 `compose_email()` 函数创建的电子邮件本身。
- en: From here, we then add the attachment and send the email.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们添加附件并发送电子邮件。
- en: The email is sent using the configured work/school email account retrieved earlier.
    So, in conclusion, these lines of code install the necessary packages, load the
    required libraries, retrieve the work/school email account, compose an email using
    the `blastula` package, add an attachment to the email, and finally, send the
    email using the `Microsoft365R` package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件是通过配置的工作/学校电子邮件账户发送的。因此，总的来说，这些代码行安装必要的包，加载所需的库，检索工作/学校电子邮件账户，使用 `blastula`
    包编写电子邮件，向电子邮件添加附件，并最终使用 `Microsoft365R` 包发送电子邮件。
- en: You have learned about scheduling and email integration in R. Now, let’s have
    a look at how the same can be achieved in Python!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了 R 中的安排和电子邮件集成。现在，让我们看看如何在 Python 中实现相同的功能！
- en: Scheduling Python scripts
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排 Python 脚本
- en: Automation is not limited to executing scripts manually; it also involves scheduling
    them to run at specific intervals or events. Scheduling Python scripts allows
    you to automate repetitive tasks, perform periodic data updates, generate reports,
    and carry out system maintenance without manual intervention.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化不仅限于手动执行脚本；它还涉及在特定间隔或事件中安排它们运行。安排 Python 脚本允许你自动化重复性任务，执行定期数据更新，生成报告，以及执行系统维护，而无需人工干预。
- en: In this section, we will explore various techniques and tools to schedule Python
    scripts and achieve efficient and timely execution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨安排 Python 脚本的多种技术和工具，以实现高效和及时的执行。
- en: By the end of this section, you will have a comprehensive understanding of various
    scheduling techniques and tools available for Python scripts. You will be equipped
    with the knowledge and skills to schedule your Python scripts effectively, automate
    routine tasks, and maximize your productivity. Whether you are running scripts
    on Windows or Unix-like systems, this chapter will empower you to implement reliable
    and efficient Python script scheduling solutions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将全面了解适用于 Python 脚本的多种安排技术和工具。你将具备有效安排 Python 脚本、自动化常规任务并最大化生产力的知识和技能。无论你是在
    Windows 或类 Unix 系统上运行脚本，这一章节都将赋予你实施可靠且高效的 Python 脚本安排解决方案的能力。
- en: Introduction to Python script scheduling
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 脚本安排简介
- en: We will start by discussing the importance of scheduling Python scripts and
    its benefits in streamlining workflows. You will learn why scheduling is crucial
    for automating tasks and how it can save time and effort. We will also highlight
    real-world scenarios where Python script scheduling is commonly applied.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论安排 Python 脚本的重要性及其在简化工作流程中的益处。你将了解为什么安排对于自动化任务至关重要，以及它如何节省时间和精力。我们还将强调
    Python 脚本安排在实际场景中的常见应用。
- en: Scheduling Python scripts plays a vital role in automating tasks and improving
    workflow efficiency. By scheduling scripts to run at specific intervals or events,
    you can eliminate the need for manual execution and ensure timely and accurate
    data processing, report generation, and system maintenance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安排 Python 脚本在自动化任务和提升工作流程效率方面发挥着至关重要的作用。通过安排脚本在特定间隔或事件中运行，你可以消除手动执行的需求，并确保及时准确的数据处理、报告生成和系统维护。
- en: 'In this section, we will explore the importance of Python script scheduling
    and highlight its benefits in the various domains listed as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Python 脚本安排的重要性，并强调其在以下列出的各个领域的益处：
- en: '**Automating repetitive tasks**: Many tasks in data processing, analysis, and
    reporting involve repetitive actions. Scheduling Python scripts allows you to
    automate these tasks, reducing the time and effort required for manual execution.
    Whether it’s fetching data from external sources, performing calculations, generating
    reports, or updating databases, scheduling scripts ensures consistent and reliable
    automation.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化重复性任务**：数据处理、分析和报告中的许多任务都涉及重复操作。安排 Python 脚本允许你自动化这些任务，减少手动执行所需的时间和精力。无论是从外部来源获取数据、执行计算、生成报告还是更新数据库，安排脚本都能确保一致可靠的自动化。'
- en: '**Periodic data updates**: In many applications, data need to be regularly
    updated from external sources or refreshed from internal systems. Python script
    scheduling enables you to define a schedule for fetching, transforming, and updating
    data automatically. By specifying the desired frequency, you can ensure that your
    data remain up to date without manual intervention.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期数据更新**：在许多应用中，数据需要定期从外部来源更新或从内部系统刷新。Python 脚本安排使您能够定义自动获取、转换和更新数据的计划。通过指定所需的频率，您可以确保数据保持最新，无需人工干预。'
- en: '**Generating reports**: Reports are often generated periodically, such as daily,
    weekly, or monthly. With Python script scheduling, you can automate the generation
    of reports by scheduling the script to run at specific intervals. This ensures
    that the reports are produced consistently and delivered on time, saving valuable
    time and effort.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成报告**：报告通常定期生成，如每日、每周或每月。使用 Python 脚本安排，您可以通过安排脚本在特定间隔运行来自动化报告的生成。这确保了报告的持续生成和准时交付，节省了宝贵的时间和精力。'
- en: '**System maintenance**: Python script scheduling is not limited to data-related
    tasks; it can also be used for system maintenance activities. From performing
    backups and database maintenance to running system checks and executing routine
    cleanup tasks, scheduling Python scripts enables you to keep your systems running
    smoothly without manual intervention.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统维护**：Python 脚本安排不仅限于数据相关任务；它还可以用于系统维护活动。从执行备份和数据库维护到运行系统检查和执行常规清理任务，安排
    Python 脚本使您能够在无需人工干预的情况下保持系统平稳运行。'
- en: '**Real-world scenarios**: Python script scheduling finds application in various
    industries and domains. For example, in ecommerce, scripts can be scheduled to
    update product inventory, synchronize prices, and generate sales reports. In finance,
    scheduled scripts can fetch stock market data, calculate portfolio performance,
    and generate financial statements. In IT operations, scripts can be scheduled
    for system monitoring, log analysis, and automated incident response. These are
    just a few examples of how Python script scheduling can be leveraged to enhance
    productivity and efficiency across different domains.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际场景**：Python 脚本安排在各个行业和领域都有应用。例如，在电子商务中，脚本可以安排更新产品库存、同步价格和生成销售报告。在金融领域，安排的脚本可以抓取股市数据、计算投资组合表现和生成财务报表。在
    IT 运营中，脚本可以安排进行系统监控、日志分析和自动事件响应。这些只是 Python 脚本安排如何在不同领域提高生产力和效率的几个例子。'
- en: By understanding the importance of Python script scheduling and its benefits,
    you can identify opportunities to automate tasks, streamline workflows, and improve
    overall productivity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解 Python 脚本安排的重要性及其益处，您可以识别自动化任务、简化工作流程和提高整体生产力的机会。
- en: In the following sections, we will explore different methods and tools for scheduling
    Python scripts, providing you with the knowledge and techniques to implement effective
    and reliable automation solutions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨用于安排 Python 脚本的不同方法和工具，为您提供实施有效且可靠的自动化解决方案的知识和技术。
- en: Built-in scheduling options
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置安排选项
- en: Python provides built-in scheduling options on both Windows and Unix-like systems
    without the need for external libraries. These options provide a convenient and
    lightweight way to schedule and execute your Python scripts at predefined intervals.
    In this section, we will explore the built-in scheduling options and discuss their
    features, usage, and limitations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 Windows 和 Unix-like 系统上提供内置的安排选项，无需外部库。这些选项提供了一种方便且轻量级的方式来安排和执行您的 Python
    脚本，在预定义的间隔内运行。在本节中，我们将探讨内置的安排选项，并讨论其特性、用法和限制。
- en: We will explore **Windows Task Scheduler** and **crontab** on Unix-like systems.
    You will learn how to set up scheduled tasks using these native scheduling tools,
    specify the frequency of execution, and configure various options to meet your
    specific requirements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨 **Windows 任务计划程序** 和 Unix-like 系统上的 **crontab**。您将学习如何使用这些原生安排工具设置计划任务，指定执行频率，并配置各种选项以满足您的特定需求。
- en: 'Here is a list of the built-in options and their key features:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是内置选项及其关键特性的列表：
- en: cron (Unix-like systems)
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cron（Unix-like 系统）
- en: 'The following are the key features of cron:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是 cron 的关键特性：
- en: cron is a time-based job scheduler available on Unix-like operating systems,
    including Linux and macOS
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cron 是一种基于时间的作业安排程序，可在 Unix-like 操作系统上使用，包括 Linux 和 macOS
- en: It allows you to schedule recurring tasks by specifying the time, date, and
    frequency using a cron expression
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您通过指定时间、日期和频率使用cron表达式来安排重复的任务
- en: cron provides flexibility in defining schedules, such as running scripts at
    specific times, on specific days of the week, or at regular intervals
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cron提供了定义计划的灵活性，例如在特定时间、特定周几或定期运行脚本
- en: It is widely supported and has been the de facto standard for scheduling tasks
    on Unix-like systems for many years
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它得到了广泛的支持，并且多年来一直是类Unix系统上调度任务的既定标准
- en: While cron is not a Python-specific tool, you can use it to schedule the execution
    of Python scripts by specifying the appropriate command line invocation
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然cron不是Python特定的工具，但您可以通过指定适当的命令行调用来使用它来安排Python脚本的执行
- en: Windows Task Scheduler (Windows systems)
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows任务计划程序（Windows系统）
- en: 'The following points list the features of Windows systems:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了Windows系统的特性：
- en: Windows Task Scheduler is the built-in task scheduling tool provided by the
    Windows operating system
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows任务计划程序是Windows操作系统提供的内置任务调度工具
- en: It allows you to schedule tasks to run at specific times or events on Windows
    machines
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许您在Windows机器上安排在特定时间或事件运行的任务
- en: You can create scheduled tasks through the graphical user interface or using
    the command line tool `schtasks`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过图形用户界面或使用命令行工具`schtasks`创建计划任务
- en: Windows Task Scheduler provides a range of options for defining triggers, such
    as specific times, daily, weekly, or monthly schedules, or even based on system
    events
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows任务计划程序提供了一系列定义触发器的选项，例如特定时间、每日、每周或每月的计划，甚至基于系统事件
- en: It offers a user-friendly interface for managing scheduled tasks, including
    setting up dependencies, priority settings, and error handling
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个用户友好的界面来管理计划任务，包括设置依赖关系、优先级设置和错误处理
- en: Python’s time.sleep() function
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python的`time.sleep()`函数
- en: 'This is a list of the key features of the `time.sleep()` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`time.sleep()`函数的关键特性列表：
- en: While not specifically designed for scheduling tasks, Python’s built-in `time`
    module provides a simple way to introduce delays between script executions
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Python的内置`time`模块并非专门设计用于调度任务，但它提供了一种简单的方法来在脚本执行之间引入延迟
- en: The `time.sleep()` function pauses the script for a specified number of seconds,
    allowing you to control the timing between script runs
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.sleep()`函数暂停脚本指定的秒数，允许您控制脚本运行之间的时间间隔'
- en: While this option lacks the sophistication and advanced features of dedicated
    scheduling tools, it can be useful for simple cases where a fixed delay is sufficient
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然此选项缺乏专用调度工具的复杂性和高级功能，但在需要固定延迟的简单情况下可能很有用
- en: However, keep in mind that using `time.sleep()` as a scheduling mechanism may
    not be suitable for precise or complex scheduling requirements
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，请注意，使用`time.sleep()`作为调度机制可能不适合精确或复杂的调度需求
- en: It’s important to note that these built-in scheduling options have their strengths
    and limitations. They are suitable for many use cases but may not provide the
    advanced features and flexibility required for complex scheduling scenarios. In
    such cases, external libraries and tools can offer more robust solutions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些内置的调度选项有其优点和局限性。它们适用于许多用例，但可能不提供复杂调度场景所需的先进功能和灵活性。在这种情况下，外部库和工具可以提供更稳健的解决方案。
- en: In the next section, we will explore some popular third-party libraries for
    scheduling Python scripts, providing additional features and customization options.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些流行的第三方库，用于调度Python脚本，提供额外的功能和定制选项。
- en: Third-party scheduling libraries
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方调度库
- en: While Python’s built-in scheduling options can handle many common scheduling
    tasks, there are several third-party libraries available that provide more advanced
    features and customization options. These libraries offer greater flexibility
    and control over scheduling Python scripts, allowing you to handle complex scheduling
    scenarios with ease.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python的内置调度选项可以处理许多常见的调度任务，但还有几个第三方库可用，它们提供了更多高级功能和定制选项。这些库提供了更大的灵活性和对调度Python脚本的控件，使您能够轻松处理复杂的调度场景。
- en: In this section, we will explore some popular third-party scheduling libraries
    and discuss their features and benefits. We will cover topics such as defining
    schedules using cron-like syntax, handling time zones, and managing concurrent
    execution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些流行的第三方调度库，并讨论它们的功能和优势。我们将涵盖使用类似cron的语法定义调度、处理时区和管理并发执行等主题。
- en: schedule
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: schedule
- en: 'Here are the features and benefits of the `schedule` library:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`schedule`库的功能和优势：
- en: The `schedule` library is a lightweight Python library that simplifies the process
    of scheduling tasks
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule`库是一个轻量级的Python库，简化了任务调度的过程。'
- en: It offers an intuitive and easy-to-use API for defining schedules using a fluent
    interface
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一个直观且易于使用的API，用于使用流畅的接口定义调度。
- en: The library supports various scheduling options, such as specific times, intervals,
    and cron-like expressions
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库支持各种调度选项，如特定时间、间隔和类似cron的表达式。
- en: '`schedule` allows you to execute functions, methods, or even shell commands
    at the defined schedule'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule`允许您在定义的调度下执行函数、方法，甚至shell命令。'
- en: It is designed to be simple and lightweight, making it suitable for smaller
    projects or cases where a minimalistic scheduling solution is desired
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被设计得简单轻量，适合小型项目或需要最小化调度解决方案的情况。
- en: 'Here is an easy-to-demonstrate usage of `schedule` in Python:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在Python中使用`schedule`的简单示例：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we import the `schedule` library and define a function called
    `job()`, which prints a message. We then use the `schedule.every().day.at(08:00).do(job)`
    syntax to schedule the `job` function to run every day at 8:00 am. Finally, we
    use a `while` loop to continuously check for pending scheduled jobs and execute
    them. Note that this solution means the console is `blocked`, meaning the Python
    process running this infinite loop will not be available for other tasks. To stop
    the scheduler, simply interrupt the kernel/console or kill the underlying Python
    process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们导入`schedule`库并定义一个名为`job()`的函数，该函数打印一条消息。然后，我们使用`schedule.every().day.at(08:00).do(job)`语法来安排`job`函数每天早上8:00运行。最后，我们使用一个`while`循环来持续检查待处理的计划任务并执行它们。请注意，这种解决方案意味着控制台被`blocked`，即运行这个无限循环的Python进程将无法执行其他任务。要停止调度器，只需中断内核/控制台或终止底层的Python进程。
- en: You can customize the scheduling behavior by using different methods provided
    by the `schedule` library, such as `.every().day.at()`, `.every().monday`, `.every().hour`,
    and more. Additionally, you can schedule jobs to run at specific intervals or
    combine multiple scheduling patterns as per your requirements.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`schedule`库提供的不同方法来自定义调度行为，例如`.every().day.at()`、`.every().monday`、`.every().hour`等。此外，您可以根据需求安排在特定间隔运行的任务，或者组合多个调度模式。
- en: Let’s have a look at `APScheduler` next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`APScheduler`。
- en: Advanced Python Scheduler (APScheduler)
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级Python调度器 (APScheduler)
- en: 'Here are the features and benefits of `APScheduler`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`APScheduler`的功能和优势：
- en: '**Advanced Python Scheduler** (**APScheduler**) is another popular choice for
    scheduling tasks in Python'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级Python调度器**（**APScheduler**）是Python中调度任务的另一个流行选择。'
- en: It provides a rich set of features, including various trigger types, such as
    intervals, cron expressions, and date-based triggers
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一套丰富的功能，包括各种触发类型，如间隔、cron表达式和基于日期的触发器。
- en: APScheduler supports multiple job stores, including in-memory, SQL databases,
    and Redis
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler支持多种作业存储，包括内存、SQL数据库和Redis。
- en: It offers advanced scheduling options, such as job coalescing, distributed scheduling,
    and time zone support
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了高级调度选项，如作业合并、分布式调度和时间支持。
- en: APScheduler has a well-documented API and is widely used in various applications,
    ranging from simple scripts to complex web applications
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APScheduler具有完善的文档，并被广泛应用于各种应用中，从简单的脚本到复杂的Web应用。
- en: 'Here’s a sample code snippet demonstrating how to schedule tasks using the
    `APScheduler` library:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`APScheduler`库安排任务的示例代码片段：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the preceding example, we understand the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们可以理解以下内容：
- en: We first import the `BlockingScheduler` class from the `apscheduler.schedulers.blocking`
    module. Then, we create an instance of the scheduler using `BlockingScheduler()`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`apscheduler.schedulers.blocking`模块中导入`BlockingScheduler`类。然后，我们使用`BlockingScheduler()`创建调度器的一个实例。
- en: Next, we define a function called `send_email()`, which represents the task
    of sending an email. Inside this function, you can write the code to send an email
    or perform any other desired action.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为`send_email()`的函数，它代表发送电子邮件的任务。在这个函数内部，您可以编写发送电子邮件或执行任何其他所需操作的代码。
- en: To schedule the task, we use the `add_job()` method of the scheduler. In this
    case, we specify the `send_email` function as the task to be executed. We also
    provide the scheduling parameters using the `interval` option, which indicates
    that the task should be executed at regular intervals. In this example, we set
    it to run every hour (`hours=1`).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调度任务，我们使用调度器的`add_job()`方法。在这种情况下，我们将`send_email`函数指定为要执行的任务。我们还通过`interval`选项提供调度参数，该选项表示任务应定期执行。在这个例子中，我们将其设置为每小时运行一次（`hours=1`）。
- en: Finally, we start the scheduler by calling the `start()` method. This will initiate
    the scheduler and begin executing the tasks according to the defined schedule.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`start()`方法来启动调度器。这将初始化调度器并开始根据定义的日程执行任务。
- en: The `APScheduler` library provides various scheduling options, such as fixed
    intervals, cron expressions, date/time triggers, and more. You can customize the
    scheduling behavior according to your specific requirements by exploring the documentation
    and using the appropriate scheduling options provided by APScheduler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`APScheduler`库提供了各种调度选项，例如固定间隔、cron表达式、日期/时间触发器等。您可以通过查阅文档并使用APScheduler提供的适当调度选项来根据您的具体需求自定义调度行为。'
- en: Next up, let’s have a look at the Celery package for completeness’ sake.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了完整性，让我们看一下Celery包。
- en: Celery
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Celery
- en: 'The following are the features and benefits of Celery:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Celery的功能和好处：
- en: Celery is a distributed task queue library that can be used for both task execution
    and scheduling
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Celery是一个用于任务执行和调度的分布式任务队列库。
- en: It provides a robust and scalable solution for scheduling Python tasks across
    multiple workers or machines
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为在多个工作者或机器上跨多个Python任务提供了一种强大且可扩展的解决方案。
- en: Celery supports various scheduling options, including intervals, crontab-like
    expressions, and more
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Celery支持各种调度选项，包括间隔、类似crontab的表达式等。
- en: It offers advanced features such as task prioritization, result tracking, retries,
    and task chaining
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了高级功能，如任务优先级、结果跟踪、重试和任务链。
- en: Celery integrates well with message brokers such as **RabbitMQ**, **Redis**,
    or **Apache Kafka**, providing reliable and scalable task-scheduling capabilities
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Celery与消息代理如**RabbitMQ**、**Redis**或**Apache Kafka**很好地集成，提供了可靠且可扩展的任务调度能力。
- en: 'By using the Celery scheduler, you can automate the execution of tasks based
    on specific schedules, allowing you to perform recurring or time-based operations
    in your application. Configuring and deploying Celery apps is beyond the scope
    of this book, though, so it only stands here for completeness’ sake. You can consult
    the official documentation if you wish to delve deeper: [https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html](https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Celery调度器，您可以根据特定的日程自动化任务的执行，允许您在应用程序中执行周期性或基于时间的操作。不过，配置和部署Celery应用程序超出了本书的范围，所以这里仅为了完整性而提及。如果您想深入了解，可以查阅官方文档：[https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html](https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html)。
- en: These third-party scheduling libraries provide powerful and flexible solutions
    for scheduling Python scripts. Depending on your specific requirements and the
    complexity of your scheduling tasks, you can choose the library that best fits
    your needs. Each library has its own strengths and capabilities, so it’s important
    to evaluate them based on your project’s requirements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些第三方调度库为调度Python脚本提供了强大且灵活的解决方案。根据您的具体需求和调度任务的复杂性，您可以选择最适合您需求的库。每个库都有其自身的优势和功能，因此根据您项目的需求进行评估非常重要。
- en: In the next section, we will explore practical examples of using these libraries
    to schedule Python scripts for various use cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用这些库来为各种用例调度Python脚本的实际示例。
- en: Best practices and considerations for robust automation
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于强大自动化方案的最佳实践和考虑因素
- en: When working with scheduling Python scripts, it’s essential to follow best practices
    and consider various factors to ensure efficient and reliable automation. This
    section provides insights into the best practices and considerations for scheduling
    Python scripts effectively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当与调度 Python 脚本一起工作时，遵循最佳实践并考虑各种因素对于确保高效和可靠的自动化至关重要。本节提供了关于有效调度 Python 脚本的最佳实践和考虑因素的见解。
- en: These best practices will help you create robust and maintainable scheduled
    tasks. Let’s discuss these best practices in the following sections.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践将帮助您创建强大且可维护的计划任务。让我们在以下章节中讨论这些最佳实践。
- en: Error handling and logging
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理和日志记录
- en: 'Here are the best practices for error handling and logging:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是错误处理和日志记录的最佳实践：
- en: Implement robust error-handling mechanisms to handle any unexpected exceptions
    and errors that may occur during script execution
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施强大的错误处理机制来处理脚本执行过程中可能发生的任何意外异常和错误
- en: Use logging frameworks to capture detailed information about script execution,
    including errors, warnings, and information messages
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志框架来捕获有关脚本执行的详细信息，包括错误、警告和信息消息
- en: Proper error handling and logging allow you to diagnose issues, track script
    performance, and ensure that scheduled tasks are executed as expected
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确的错误处理和日志记录允许您诊断问题、跟踪脚本性能并确保计划任务按预期执行
- en: Resource management
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源管理
- en: 'Here are the best practices for resource management:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是资源管理的最佳实践：
- en: Consider the resources required by your scheduled Python scripts, such as CPU,
    memory, and disk space
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑您计划中的 Python 脚本所需的资源，例如 CPU、内存和磁盘空间
- en: Optimize resource usage by identifying and minimizing any resource-intensive
    operations or bottlenecks
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过识别和最小化任何资源密集型操作或瓶颈来优化资源使用
- en: Ensure that your scripts release resources properly to avoid resource leaks
    or conflicts
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的脚本正确释放资源，以避免资源泄漏或冲突
- en: Security considerations
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全考虑
- en: 'Here are the best practices for security considerations:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是安全考虑的最佳实践：
- en: Evaluate the security implications of scheduling Python scripts, especially
    if they involve sensitive data or interact with external systems
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估调度 Python 脚本的安全影响，特别是如果它们涉及敏感数据或与外部系统交互
- en: Implement necessary security measures, such as encrypting credentials, securing
    API endpoints, and adhering to authentication and authorization protocols
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施必要的安全措施，例如加密凭证、保护 API 端点以及遵守身份验证和授权协议
- en: Regularly review and update security measures to mitigate potential risks and
    vulnerabilities
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审查和更新安全措施以减轻潜在的风险和漏洞
- en: Testing and validation
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试和验证
- en: 'Here are the best practices for testing and validation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是测试和验证的最佳实践：
- en: Thoroughly test and validate your scheduled Python scripts to ensure their correctness
    and reliability
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细测试和验证您的计划 Python 脚本，以确保它们的正确性和可靠性
- en: Perform unit testing, integration testing, and end-to-end testing to verify
    that your scripts function as expected and handle various scenarios
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行单元测试、集成测试和端到端测试，以验证脚本按预期工作并处理各种场景
- en: Consider creating a staging environment where you can test scheduled tasks before
    deploying them to a production environment
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑创建一个预演环境，在那里您可以测试计划任务，然后再将它们部署到生产环境
- en: Monitoring and alerting
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控和警报
- en: 'Here are the best practices for monitoring and alerting:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是监控和警报的最佳实践：
- en: Establish monitoring and alerting mechanisms to track the execution status of
    scheduled tasks
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立监控和警报机制以跟踪计划任务的执行状态
- en: Monitor the performance and health of your scheduling system, including script
    execution times, resource usage, and any potential errors or failures
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控调度系统的性能和健康状况，包括脚本执行时间、资源使用以及任何潜在的错误或故障
- en: Configure alerts to notify you when tasks fail, enabling prompt intervention
    and troubleshooting
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置警报，以便在任务失败时通知您，以便进行快速干预和故障排除
- en: Documentation and maintenance
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档和维护
- en: 'Here are the best practices for documentation and maintenance:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是文档和维护的最佳实践：
- en: Document the scheduling process, including the configuration, dependencies,
    and any specific instructions for managing scheduled tasks
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录调度过程，包括配置、依赖关系以及管理计划任务的具体说明
- en: Maintain an up-to-date schedule of your scheduled Python scripts, including
    the frequency and expected outcomes of each task
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护您计划中的 Python 脚本的最新日程安排，包括每个任务的频率和预期结果
- en: Regularly review and update your scheduling setup, scripts, and dependencies
    to adapt to changing requirements and technologies
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期审查和更新你的计划设置、脚本和依赖项，以适应不断变化的需求和技术。
- en: By following these best practices and considering the relevant factors, you
    can ensure the reliability, efficiency, and security of your scheduled Python
    scripts. Incorporating these considerations into your scheduling workflow will
    contribute to the smooth execution of tasks and help you maintain a well-structured
    and sustainable automation system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践并考虑相关因素，你可以确保计划 Python 脚本的可靠性、效率和安全性。将这些考虑因素纳入你的计划工作流程将有助于任务的顺利执行，并帮助你维护一个结构良好且可持续的自动化系统。
- en: In the next section, we will explore practical examples and use cases that illustrate
    the application of these best practices and considerations in real-world scenarios.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨实际示例和应用案例，说明这些最佳实践和考虑因素在现实场景中的应用。
- en: 'By completing this section on scheduling Python scripts, you have gained valuable
    knowledge and skills in automating and managing the execution of your scripts.
    Let’s summarize what you have learned:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本节关于安排 Python 脚本的内容，你获得了自动化和管理脚本执行的有价值知识和技能。让我们总结一下你所学到的内容：
- en: You explored the various built-in scheduling options available in different
    operating systems, such as cron jobs on Unix-like systems and Task Scheduler on
    Windows, enabling you to schedule Python scripts at specific times or intervals
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你探讨了不同操作系统中可用的各种内置计划选项，例如类 Unix 系统上的 cron 作业和 Windows 上的任务计划程序，使你能够安排在特定时间或间隔运行
    Python 脚本。
- en: You discovered third-party scheduling libraries, such as `APScheduler` and `Schedule`,
    which provide more advanced scheduling capabilities, such as cron-like expressions
    and interval-based scheduling
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发现了第三方计划库，如 `APScheduler` 和 `Schedule`，它们提供了更高级的计划功能，例如类似 cron 的表达式和基于间隔的计划。
- en: You understood the best practices for scheduling Python scripts, including error
    handling, resource management, security considerations, testing, validation, monitoring,
    and alerting, as well as documentation and maintenance
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解了安排 Python 脚本的最佳实践，包括错误处理、资源管理、安全考虑、测试、验证、监控和警报，以及文档和维护。
- en: Through practical examples and use cases, you gained hands-on experience in
    implementing and managing scheduled Python scripts, ensuring the efficient and
    reliable automation of your tasks
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实际示例和应用案例，你获得了实施和管理计划 Python 脚本的实际经验，确保你的任务自动化高效且可靠。
- en: By mastering the concepts and techniques covered in this section, you are now
    equipped to schedule Python scripts effectively, automate repetitive tasks, and
    streamline your workflow. The ability to schedule scripts opens a world of possibilities
    for automating various processes, increasing productivity, and freeing up valuable
    time for more critical tasks.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过掌握本节涵盖的概念和技术，你现在可以有效地安排 Python 脚本，自动化重复性任务，并简化你的工作流程。能够安排脚本为自动化各种流程、提高生产力和为更关键的任务节省宝贵时间打开了新的可能性。
- en: In the next section, we will delve into the exciting realm of email notifications
    and explore how you can enhance your automation workflows by integrating email
    functionality into your Python scripts.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨令人兴奋的电子邮件通知领域，并探讨如何通过将电子邮件功能集成到你的 Python 脚本中，增强你的自动化工作流程。
- en: Email notifications and automation with Python
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 进行电子邮件通知和自动化
- en: 'Much like scheduling Python scripts, email notifications and automation can
    make your daily work much more efficient. This section will cover the basics,
    such as the motivation behind using emails from Python, moving on to setting up
    the environment and sending basic emails, and then covering a real-life use case:
    sending email notifications for script status.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与安排 Python 脚本类似，电子邮件通知和自动化可以使你的日常工作更加高效。本节将涵盖基础知识，例如使用 Python 发送电子邮件的动机，接着介绍设置环境和发送基本电子邮件，然后讨论一个实际应用案例：发送脚本状态电子邮件通知。
- en: Introduction to email notifications in Python
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中电子邮件通知简介
- en: Email notifications play a crucial role in automation by providing timely updates,
    alerts, and reports. In this section, we will explore the significance of integrating
    email functionality into your Python scripts. We’ll discuss various use cases
    where email notifications can be beneficial, and we’ll delve into the advantages
    they offer for streamlining workflows and enhancing communication.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件通知在自动化中发挥着至关重要的作用，通过提供及时更新、警报和报告。在本节中，我们将探讨将电子邮件功能集成到您的Python脚本中的重要性。我们将讨论电子邮件通知可以带来益处的各种用例，并深入探讨它们在简化工作流程和增强沟通方面的优势。
- en: 'Let’s start with the most basic considerations: why would you do this?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的考虑开始：你为什么要这样做？
- en: Use cases and benefits of integrating email functionality into your scripts
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成电子邮件功能到您的脚本的使用案例和优势
- en: 'Email notifications are versatile and can be applied to a wide range of scenarios.
    Some common use cases include the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件通知具有多功能性，可以应用于各种场景。以下是一些常见的用例：
- en: '**Task completion notifications**: These send notifications to indicate the
    successful completion of a task or process, helping to keep stakeholders informed
    and reassuring them that everything is running smoothly.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务完成通知**：这些通知发送给利益相关者，表明任务或过程的成功完成，有助于让他们了解一切进展顺利。'
- en: '**Error and exception reporting**: This involves alerting relevant team members
    or administrators when errors or exceptions occur during script execution, allowing
    for prompt troubleshooting and issue resolution.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误和异常报告**：这涉及到在脚本执行过程中发生错误或异常时向相关团队成员或管理员发出警报，以便进行及时的故障排除和问题解决。'
- en: '**Progress updates**: This provides periodic progress updates to stakeholders
    or clients, ensuring transparency and maintaining open lines of communication.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进度更新**：这为利益相关者或客户提供定期的进度更新，确保透明度并保持开放的沟通渠道。'
- en: '**Data analysis reports**: These automate the generation and delivery of data
    analysis reports via email, saving time and effort by eliminating the need for
    manual report creation and distribution.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分析报告**：这些通过电子邮件自动生成和发送数据分析报告，通过消除手动报告创建和分发的需求来节省时间和精力。'
- en: '**System monitoring**: This involves setting up email notifications to monitor
    system status, such as server uptime, disk space usage, or application performance.
    Immediate alerts can help address potential issues before they impact operations.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统监控**：这涉及到设置电子邮件通知以监控系统状态，例如服务器正常运行时间、磁盘空间使用情况或应用程序性能。即时警报可以帮助在问题影响操作之前解决潜在问题。'
- en: 'By incorporating email notifications into your Python scripts, you can benefit
    from the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将电子邮件通知集成到您的Python脚本中，您可以享受到以下好处：
- en: '**Realtime updates**: Stay informed about the progress, status, and results
    of automated tasks'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时更新**：了解自动化任务的进度、状态和结果'
- en: '**Enhanced collaboration**: Facilitate communication and collaboration among
    team members by providing timely notifications'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强协作**：通过提供及时的通知，促进团队成员之间的沟通和协作'
- en: '**Error detection and resolution**: Receive alerts about errors or exceptions
    in your scripts, enabling you to identify and resolve issues quickly'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检测和解决**：接收有关脚本中错误或异常的警报，使您能够快速识别和解决问题'
- en: '**Customization and personalization**: Tailor email notifications to suit your
    specific requirements, including content, formatting, and recipients'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制和个人化**：根据您的具体要求定制电子邮件通知，包括内容、格式和收件人'
- en: '**Streamlined workflows**: Automate the delivery of reports, updates, and alerts,
    saving time and effort in manual distribution'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化工作流程**：自动化报告、更新和警报的交付，节省手动分发的时间和精力'
- en: Throughout this section, we will explore the various aspects of email notifications
    in Python, empowering you to leverage this powerful communication tool within
    your automation workflows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Python中电子邮件通知的各个方面，使您能够利用这一强大的通信工具在自动化工作流程中。
- en: Let’s dive in and explore how to set up and use email functionality effectively.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨如何有效地设置和使用电子邮件功能。
- en: Setting up email services
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置电子邮件服务
- en: Before diving into sending email notifications from Python, it’s essential to
    set up the necessary email services to establish a connection between your script
    and the email server.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨从Python发送电子邮件通知之前，设置必要的电子邮件服务以在您的脚本和电子邮件服务器之间建立连接是至关重要的。
- en: By the end of this section, you will have a clear understanding of how to set
    up email services for your Python scripts. You’ll be equipped with the necessary
    knowledge to choose the right email service provider, obtain the required SMTP
    server credentials, configure secure connections, and test the connection. With
    your email services in place, you’ll be ready to move on to the next steps of
    sending email notifications seamlessly from your Python scripts.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，您将清楚地了解如何为您的 Python 脚本设置电子邮件服务。您将具备选择合适的电子邮件服务提供商、获取所需的 SMTP 服务器凭据、配置安全连接以及测试连接的必要知识。一旦您的电子邮件服务就绪，您就可以继续从您的
    Python 脚本中无缝发送电子邮件通知的下一步了。
- en: Let’s get started and set up your email services effectively.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，有效地设置您的电子邮件服务。
- en: In this section, we will cover the steps involved in configuring email services,
    including the following aspects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍配置电子邮件服务所需的步骤，包括以下方面。
- en: Choosing an email service provider
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择电子邮件服务提供商
- en: There are several email service providers available, each offering different
    features and options. In this section, we will be using Gmail as an example but
    the code can easily be adapted to other providers, such as Microsoft Exchange,
    as well.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的电子邮件服务提供商有多种，每个都提供不同的功能和选项。在本节中，我们将以 Gmail 为例，但代码可以轻松地适应其他提供商，例如 Microsoft
    Exchange 等。
- en: Obtaining SMTP server credentials
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 SMTP 服务器凭据
- en: To send emails programmatically, it’s important to obtain the SMTP server credentials
    provided by your email service provider. These credentials are essential for establishing
    a connection with the email server and sending emails securely.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式发送电子邮件，重要的是获取您的电子邮件服务提供商提供的 SMTP 服务器凭据。这些凭据对于与电子邮件服务器建立连接和发送安全电子邮件至关重要。
- en: In this section, we’ll guide you through the process of acquiring the necessary
    information to configure your email settings effectively.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将指导您获取配置电子邮件设置所需的信息。
- en: '`smtp.example.com` or `mail.example.com`. Make sure you verify the correct
    SMTP server address for your specific email service.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smtp.example.com` 或 `mail.example.com`。请确保您验证了您特定电子邮件服务的正确 SMTP 服务器地址。'
- en: '**Port number**: The port number specifies the communication endpoint for the
    SMTP server. Common port numbers for SMTP communication include 25, 465 (for SSL/TLS
    encrypted connections), and 587 (for STARTTLS encrypted connections). Your email
    service provider will specify the appropriate port number to use for sending emails.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口号**：端口号指定了 SMTP 服务器的通信端点。SMTP 通信的常见端口号包括 25、465（用于 SSL/TLS 加密连接）和 587（用于
    STARTTLS 加密连接）。您的电子邮件服务提供商将指定用于发送电子邮件的适当端口号。'
- en: '**Authentication details**: To authenticate yourself with the SMTP server,
    you will need to provide a username and password. These credentials are used to
    establish a secure connection and ensure that only authorized users can send emails.
    Your email service provider will provide you with the necessary authentication
    details. In some cases, an API key or access token may be required for authentication
    instead of a traditional username and password.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证详情**：为了通过 SMTP 服务器进行认证，您需要提供用户名和密码。这些凭据用于建立安全连接并确保只有授权用户可以发送电子邮件。您的电子邮件服务提供商将为您提供必要的认证详情。在某些情况下，可能需要
    API 密钥或访问令牌而不是传统的用户名和密码进行认证。'
- en: It’s important to note that the process of obtaining SMTP server credentials
    may vary depending on your email service provider. Some providers offer specific
    instructions or account settings where you can find the required information.
    If you’re unsure about where to find your SMTP server credentials, it’s recommended
    that you consult the documentation or support resources provided by your email
    service provider.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，获取 SMTP 服务器凭据的过程可能因您的电子邮件服务提供商而异。一些提供商提供特定的说明或账户设置，您可以在其中找到所需信息。如果您不确定在哪里找到您的
    SMTP 服务器凭据，建议您咨询您的电子邮件服务提供商提供的文档或支持资源。
- en: By obtaining the SMTP server credentials, you’ll be equipped with the necessary
    information to establish a connection with the email server and send emails programmatically.
    This allows you to leverage the power of Python to automate email notifications,
    updates, and other communication tasks within your applications or scripts.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取 SMTP 服务器凭据，您将具备与电子邮件服务器建立连接和以编程方式发送电子邮件的必要信息。这使您能够利用 Python 的力量在您的应用程序或脚本中自动化电子邮件通知、更新和其他通信任务。
- en: Testing the connection
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试连接
- en: To ensure a successful setup, it’s important to test the connection between
    your Python script and the email server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保成功设置，测试您的Python脚本与电子邮件服务器之间的连接是非常重要的。
- en: In the next section, we’ll demonstrate how to perform a connection test by sending
    a test email using the provided SMTP server credentials. This will help verify
    that the connection is established correctly and that your script can communicate
    with the email server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何通过使用提供的SMTP服务器凭据发送测试电子邮件来执行连接测试。这将有助于验证连接是否正确建立，并且您的脚本可以与电子邮件服务器通信。
- en: Sending basic emails
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送基本电子邮件
- en: 'Now that we have set up our email services, we can proceed to the next step:
    sending basic emails from Python.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了电子邮件服务，我们可以继续下一步：从Python发送基本电子邮件。
- en: By the end of this section, you will have a solid understanding of how to send
    basic emails from Python. You’ll know how to import the required libraries, create
    email messages, establish a connection with the email server, and send the email
    using the SMTP protocol. With this knowledge, you’ll be able to send simple text-based
    emails from your Python scripts and lay the foundation for more advanced email
    notifications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，您将深入了解如何从Python发送基本电子邮件。您将了解如何导入所需的库、创建电子邮件消息、与电子邮件服务器建立连接以及使用SMTP协议发送电子邮件。有了这些知识，您将能够从您的Python脚本中发送基于文本的简单电子邮件，并为更高级的电子邮件通知打下基础。
- en: In this section, we will explore the fundamental concepts and techniques for
    sending emails programmatically.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨发送电子邮件的基本概念和技术。
- en: Importing the required libraries
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入所需的库
- en: To send emails from Python, we need to import the necessary libraries that provide
    email-related functionality. Ahead, we’ll discuss popular libraries, such as `smtplib`
    and `email.mime`, which offer convenient features for creating and sending emails.
    We’ll guide you through the installation process and demonstrate how to import
    these libraries into your Python script.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Python发送电子邮件，我们需要导入提供电子邮件相关功能的必要库。接下来，我们将讨论流行的库，如`smtplib`和`email.mime`，它们为创建和发送电子邮件提供了便利的功能。我们将指导您完成安装过程，并演示如何将这些库导入到您的Python脚本中。
- en: Creating the email message
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建电子邮件消息
- en: Before sending an email, we need to construct the email message, which includes
    the sender, recipient, subject, and body of the email. We’ll show you how to create
    an email message using the `email.mime` library, allowing you to customize various
    aspects of the email, such as adding attachments or setting HTML content. We’ll
    provide code examples and explanations to help you understand the structure and
    components of an email message.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送电子邮件之前，我们需要构建电子邮件消息，这包括发件人、收件人、主题和邮件正文。我们将向您展示如何使用`email.mime`库创建电子邮件消息，允许您自定义电子邮件的各个方面，例如添加附件或设置HTML内容。我们将提供代码示例和解释，以帮助您理解电子邮件消息的结构和组件。
- en: Establishing the connection
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立连接
- en: To send an email, we need to establish a connection with the email server using
    the SMTP protocol. We’ll demonstrate how to establish a connection using the SMTP
    server credentials obtained earlier. We’ll guide you through the process of creating
    an SMTP object, setting up the connection, and handling any potential errors or
    exceptions that may arise during the establishment of the connection.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们需要使用SMTP协议与电子邮件服务器建立连接。我们将演示如何使用之前获得的SMTP服务器凭据建立连接。我们将指导您完成创建SMTP对象、设置连接和处理在建立连接过程中可能出现的任何潜在错误或异常的过程。
- en: Sending the email
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: Once the connection is established, we can proceed to send the email. We’ll
    demonstrate how to use the `smtplib` library to send an email message. We’ll cover
    the necessary steps, including authenticating with the email server, specifying
    the sender and recipient addresses, and invoking the `sendmail()` method. We’ll
    also discuss error handling and provide best practices for ensuring the successful
    delivery of the email.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，我们就可以继续发送电子邮件。我们将演示如何使用`smtplib`库发送电子邮件消息。我们将涵盖必要的步骤，包括通过电子邮件服务器进行身份验证、指定发件人和收件人地址以及调用`sendmail()`方法。我们还将讨论错误处理，并提供确保电子邮件成功投递的最佳实践。
- en: 'The preceding sections are the steps that are implemented in the following
    code sample:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分是以下代码示例中实现的步骤：
- en: '[PRE13]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From this code example, we can observe the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从此代码示例中，我们可以观察到以下内容：
- en: We first import the `smtplib` library to establish an SMTP connection and the
    `MIMEText` and `MIMEMultipart` classes from the `email.mime` module for creating
    the email message.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`smtplib`库以建立SMTP连接，并从`email.mime`模块导入`MIMEText`和`MIMEMultipart`类以创建电子邮件消息。
- en: Next, we define the SMTP server details, including the server address, port,
    and the credentials (username and password) required for authentication.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义SMTP服务器详情，包括服务器地址、端口以及用于身份验证的凭据（用户名和密码）。
- en: We then create a `MIMEMultipart` object called message, which represents the
    email message. We set the sender and recipient addresses, as well as the subject
    of the email.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为message的`MIMEMultipart`对象，它代表电子邮件消息。我们设置发送者和接收者地址，以及电子邮件的主题。
- en: Then, we send the email using the `send_message()` method of the SMTP server
    object, passing the message as an argument.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，我们使用SMTP服务器对象的`send_message()`方法发送电子邮件，将消息作为参数传递。
- en: Remember to replace the placeholder values (`your_smtp_server` and `your_username`).
    To add the email body, we create a `MIMEText` object called body and attach it
    to the message.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得替换占位符值（`your_smtp_server`和`your_username`）。为了添加电子邮件正文，我们创建一个名为body的`MIMEText`对象并将其附加到消息中。
- en: Afterward, we establish a connection with the email server using the `smtplib.SMTP`
    class, passing the server address and port as arguments. We start the TLS encryption
    using the `starttls()` method.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`smtplib.SMTP`类通过传递服务器地址和端口作为参数与电子邮件服务器建立连接。我们使用`starttls()`方法启动TLS加密。
- en: Next, we log in to the email server using the `login()` method and provide the
    username and password.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`login()`方法登录电子邮件服务器，并提供用户名和密码。
- en: Finally, use `your_password`, `sender@example.com`, and `recipient@example.com`
    with your actual SMTP server details and email addresses.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`your_password`、`sender@example.com`和`recipient@example.com`替换占位符值，并使用你实际的SMTP服务器详情和电子邮件地址。
- en: By following this code example, you’ll be able to send basic emails using the
    `smtplib` and `email.mime` libraries in Python.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循此代码示例，你将能够使用Python中的`smtplib`和`email.mime`库发送基本的电子邮件。
- en: Sending email notifications for script status
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送脚本状态电子邮件通知
- en: In this section, you’ll learn how to define triggers, implement email notification
    logic, customize email content, and handle email delivery and errors effectively.
    With these skills, you’ll be able to enhance the monitoring and reporting capabilities
    of your scripts and stay informed about the progress and outcomes of your automated
    processes.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何定义触发器、实现电子邮件通知逻辑、自定义电子邮件内容，以及有效地处理电子邮件投递和错误。掌握这些技能后，你将能够增强脚本的监控和报告功能，并了解自动化流程的进度和结果。
- en: By the end of this section, you will have a clear understanding of how to incorporate
    email notifications into your Python scripts to receive updates on script execution
    and status.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将清楚地了解如何将电子邮件通知集成到Python脚本中，以接收脚本执行和状态的更新。
- en: One of the key use cases for email notifications in Python is to receive updates
    on the status of your scripts or processes. In this section, we will delve into
    the process of sending email notifications to keep track of the execution and
    status of your scripts. By implementing this functionality, you can stay informed
    about the progress and outcomes of your automated processes and take the necessary
    actions when needed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Python中电子邮件通知的一个关键用例是接收脚本或进程的状态更新。在本节中，我们将深入了解发送电子邮件通知以跟踪脚本执行和状态的过程。通过实现此功能，你可以在需要时了解自动化流程的进度和结果，并采取必要的行动。
- en: To begin, let’s explore the steps involved in sending email notifications for
    script status.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探讨发送脚本状态电子邮件通知所涉及的步骤。
- en: Defining triggers
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义触发器
- en: Before we can send email notifications, we need to define triggers that determine
    when the notifications should be sent. Triggers can be based on specific conditions
    or events that occur during script execution. For example, you may want to send
    an email notification when a script completes successfully, encounters an error,
    or reaches a specific milestone. By defining triggers, you have full control over
    when and under what circumstances email notifications are sent.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够发送电子邮件通知之前，我们需要定义触发器，以确定何时发送通知。触发器可以基于脚本执行期间发生的特定条件或事件。例如，你可能希望在脚本成功完成、遇到错误或达到特定里程碑时发送电子邮件通知。通过定义触发器，你可以完全控制电子邮件通知的发送时间和条件。
- en: Implementing email notification logic
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现电子邮件通知逻辑
- en: Once the triggers are defined, we can proceed to implement the logic for sending
    email notifications. This involves incorporating the necessary code within your
    script to check the triggers and initiate the email-sending process. You will
    need to import the required libraries, establish a connection with the email server,
    and customize the email content. The logic should be designed to efficiently handle
    the sending of email notifications based on the specified triggers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了触发器，我们就可以继续实现发送电子邮件通知的逻辑。这需要在你的脚本中包含必要的代码来检查触发器并启动电子邮件发送过程。你需要导入所需的库，与电子邮件服务器建立连接，并自定义电子邮件内容。逻辑应该设计得能够高效地根据指定的触发器处理发送电子邮件通知。
- en: Customizing email content
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义电子邮件内容
- en: To provide relevant and informative content in your email notifications, you
    can customize various aspects of the email, such as the subject, body, and any
    additional details. The content can include information about the script’s execution
    status, error messages, relevant data or statistics, and any other details that
    are important for understanding the script’s progress. By customizing the email
    content, you can ensure that recipients have the necessary information to take
    appropriate actions or make informed decisions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在电子邮件通知中提供相关和有价值的内容，你可以自定义电子邮件的各个方面，如主题、正文以及任何附加细节。内容可以包括有关脚本执行状态、错误消息、相关数据或统计信息以及任何其他对理解脚本进度重要的细节。通过自定义电子邮件内容，你可以确保收件人获得采取适当行动或做出明智决策所必需的信息。
- en: Handling email delivery and errors
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理电子邮件投递和错误
- en: Sending emails involves interacting with email servers, and various factors
    can affect the successful delivery of emails. It’s important to handle potential
    issues such as network connectivity problems, email server errors, or recipient
    email address errors. By implementing error-handling mechanisms, you can gracefully
    handle email delivery issues and ensure that notifications are sent reliably.
    Additionally, logging and error reporting can be useful for troubleshooting and
    diagnosing any email-related problems that may occur.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件涉及与电子邮件服务器的交互，各种因素都可能影响电子邮件的成功投递。处理潜在问题，如网络连接问题、电子邮件服务器错误或收件人电子邮件地址错误，非常重要。通过实施错误处理机制，你可以优雅地处理电子邮件投递问题，并确保通知可靠地发送。此外，日志记录和错误报告对于故障排除和诊断可能发生的任何电子邮件相关问题非常有用。
- en: In summary, by implementing email notifications for script status, you can stay
    informed about the progress and outcomes of your automated processes. You have
    the flexibility to define triggers, customize email content, and handle potential
    email delivery issues effectively. This functionality enhances the monitoring
    and reporting capabilities of your scripts and enables you to take timely actions
    based on the script’s status. With these techniques in place, you can confidently
    automate your processes while staying updated on their execution.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，通过实现脚本状态的电子邮件通知，你可以了解自动化过程的进度和结果。你可以灵活地定义触发器、自定义电子邮件内容，并有效地处理潜在的电子邮件投递问题。这种功能增强了脚本监控和报告能力，并使你能够根据脚本的状态及时采取行动。有了这些技术，你可以在保持对执行情况更新的同时，自信地自动化你的流程。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the sections on scheduling and email notifications in Python, you have gained
    a comprehensive understanding of the key concepts. You have learned about different
    scheduling options for Python scripts, including built-in options and third-party
    libraries such as `schedule` and `APScheduler`. The chapter also emphasizes the
    importance of following best practices for email notifications, such as error
    handling, resource management, security considerations, testing, monitoring, documentation,
    and maintenance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的调度和电子邮件通知章节中，你已经对关键概念有了全面的理解。你学习了Python脚本的不同调度选项，包括内置选项和第三方库，如`schedule`和`APScheduler`。本章还强调了遵循电子邮件通知最佳实践的重要性，例如错误处理、资源管理、安全考虑、测试、监控、文档和维护。
- en: You can now recognize the value of email notifications in providing timely updates
    on the status and results of processes in automated systems. We have explored
    Python’s powerful libraries and modules, such as `smtplib` and `email.mime`, which
    enable the creation and customization of email messages. Additionally, you have
    acquired the knowledge required to set up email services by configuring SMTP servers,
    authentication credentials, and other relevant settings. We have also learned
    about packages in R, such as `tasksheduleR`, `blastula`, and `Microsoft365R`,
    that will perform these functions as well. They have a solid and simple syntax,
    which makes them very powerful tools.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够认识到电子邮件通知在提供自动化系统中流程状态和结果及时更新方面的价值。我们已经探讨了 Python 的强大库和模块，例如 `smtplib`
    和 `email.mime`，它们能够创建和定制电子邮件消息。此外，您已经获得了通过配置 SMTP 服务器、认证凭证和其他相关设置来设置电子邮件服务所需的知识。我们还了解了
    R 中的包，如 `tasksheduleR`、`blastula` 和 `Microsoft365R`，它们也将执行这些功能。它们具有坚实且简单的语法，这使得它们成为非常强大的工具。
- en: With a solid understanding of the basics, you have learned how to construct
    simple email messages with the necessary headers and content to implement basic
    email functionality. You have also discovered the versatility of email notifications
    in providing updates on script execution, including success, failure, or specific
    events. Now that you are armed with these insights, readers are well-equipped
    to integrate email notifications effectively into their Python projects.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在对基础知识有了坚实的理解之后，您已经学会了如何构建简单的电子邮件消息，包括必要的头信息和内容，以实现基本的电子邮件功能。您还发现了电子邮件通知在提供脚本执行更新方面的多功能性，包括成功、失败或特定事件。现在，您已经拥有了这些见解，读者将能够有效地将电子邮件通知集成到他们的
    Python 项目中。
- en: By completing this chapter, you should have gained a comprehensive understanding
    of scheduling Python scripts and email notifications in Python. You have learned
    when and how to use various scheduling tools, set up email services, and send
    basic emails. In the next chapter, we will learn how to format Excel with Python
    and R.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，您应该已经对在 Python 中安排脚本和电子邮件通知有了全面的理解。您已经学会了何时以及如何使用各种调度工具，设置电子邮件服务，并发送基本电子邮件。在下一章中，我们将学习如何使用
    Python 和 R 格式化 Excel。
- en: 'Part 2: Making It Pretty – Formatting, Graphs, and More'
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：美化效果 – 格式化、图表及其他
- en: In this part, we delve into enhancing the visual appeal and functionality of
    your Excel sheets. You will learn how to format your data elegantly using libraries
    such as `styledTables`, `tablaxlsx`, `excelR`, `basictabler`, and `tidyxl` in
    R and `pandas` and `openpyxl` in Python. You will discover techniques to seamlessly
    insert `ggplot2` and `matplotlib` graphs into your Excel sheets, bringing your
    data to life. Additionally, you will master the art of creating pivot tables using
    `tidyquant` in R and `win32com` and `pypiwin32` in Python, along with advanced
    summary table creation using `{gt}`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将深入了解增强 Excel 工作表的视觉吸引力和功能。您将学习如何使用 `styledTables`、`tablaxlsx`、`excelR`、`basictabler`
    和 `tidyxl` 等库在 R 中以及 `pandas` 和 `openpyxl` 在 Python 中优雅地格式化您的数据。您将发现将 `ggplot2`
    和 `matplotlib` 图表无缝插入 Excel 工作表中的技术，使您的数据生动起来。此外，您将掌握使用 R 中的 `tidyquant`、Python
    中的 `win32com` 和 `pypiwin32` 创建数据透视表的艺术，以及使用 `{gt}` 创建高级汇总表。
- en: 'This part has the following chapters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B19142_05.xhtml#_idTextAnchor099), *Formatting Your Excel Sheet*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19142_05.xhtml#_idTextAnchor099), *格式化您的 Excel 工作表*'
- en: '[*Chapter 6*](B19142_06.xhtml#_idTextAnchor119), *Inserting ggplot2/matplotlib
    Graphs*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19142_06.xhtml#_idTextAnchor119), *插入 ggplot2/matplotlib 图表*'
- en: '[*Chapter 7*](B19142_07.xhtml#_idTextAnchor145), *Pivot Tables and Summary
    Tables*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19142_07.xhtml#_idTextAnchor145), *数据透视表和汇总表*'
