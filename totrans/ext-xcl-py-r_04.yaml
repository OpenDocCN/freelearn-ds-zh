- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Further – Task Scheduling and Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we can spend countless hours tediously creating, formatting, and
    emailing Excel spreadsheets. Well, fret no more! With the power of programming,
    specifically R or Python, you can effortlessly automate these mundane tasks and
    reclaim your precious time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this: you have a list of sales data that needs to be organized into
    a professional-looking spreadsheet and sent to multiple recipients via email.
    Instead of slogging through manual data entry and formatting, you can leverage
    the prowess of R or Python to simplify your workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: In R, you can use the amazing `taskscheduleR` package to schedule tasks and
    run your script automatically at specified times. With this, you can set up a
    recurring job to generate your Excel spreadsheets and send them out without lifting
    a finger. For emailing, you can employ the `RDCOMClient`, `Windows365R`, or `blastula`
    packages, which allow you to interact with Outlook and Gmail directly. This means
    you can compose and send emails with the attached spreadsheets effortlessly, customizing
    the content and recipients as needed.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, Python enthusiasts! Fear not, for you, too, can achieve the same level
    of automation magic. In Python, you can utilize the `pywin32` library to send
    out beautifully formatted emails via Gmail. It seamlessly integrates with your
    code, enabling you to attach your Excel spreadsheets and customize the email’s
    content and recipients with ease.
  prefs: []
  type: TYPE_NORMAL
- en: By harnessing the power of R or Python, along with `taskscheduleR`, `RDCOMClient`,
    `Windows365R`, or `blastula`, you can become the hero of your office, delivering
    accurate, visually appealing spreadsheets promptly, all while sipping your coffee.
    Say goodbye to mind-numbing repetition and hello to efficient automation. Let
    your creativity flourish as you unlock the power of R or Python to conquer the
    world of Excel spreadsheets and email distribution with confidence and ease!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and understanding the `taskscheduleR` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `RDCOMClient`, `Windows365R`, and `blastula` for email in Outlook or Gmail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling Python scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email notifications and automation with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter%204).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to install the following new R and Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blastula`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Windows365R`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schedule==1.2.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apscheduler==3.10.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and understanding the tasksheduleR library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `taskscheduleR` R package allows you to schedule R scripts or processes
    with the Windows task scheduler. This means that you can automate R processes
    on specific time points from within R itself. The package is basically a wrapper
    around the `Schtasks.exe` functionality. `Schtasks.exe` is a command line tool
    that allows you to create, delete, query, change, run, and finish scheduled tasks
    on a local or remote computer. To use `taskscheduleR`, you first need to install
    the package from CRAN. Once the package is installed, you can use the following
    functions to schedule R scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`taskscheduler_create()`: This function creates a new scheduled task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`taskscheduler_remove()`: This function removes an existing scheduled task.
    If you are using version 1.8, then the function is `taskscheduler_delete()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`taskscheduler_get()`: This function gets the information about an existing
    scheduled task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `taskscheduler_create()` function takes a number of arguments, including
    the name of the scheduled task, the R script to run, and the schedule to run the
    script. For example, the following code would create a scheduled task that runs
    the R script `my_scheduled_excel_script.R` every day at 10:00 am:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the GUI to create tasks for the job scheduler by installing
    `miniUI` and `shiny`. This will install the add-in capability of the package,
    allowing you to easily create jobs without writing a single line of code. Here
    is the code you can use if you want to install the preceding packages listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we see how to create scripts for this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sample scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is create a script that can be run via the Windows
    task scheduler. Let’s keep the script simple and just print `Hello` and the current
    date and time using the R function `Sys.time()`. After this is done, we can then
    create a couple of jobs that will run the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `hello_world.R` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code, `library("tcltk")`, loads the `tcltk` package, which
    provides functions for creating and interacting with **graphical user interfaces**
    (**GUIs**) in R.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code, `tkmessageBox()`, creates a message box. The message
    box is a pop-up window that displays a message and allows the user to take some
    action, such as clicking a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments to the `tkmessageBox()` function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: The title of the message box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message`: The message that will be displayed in the message box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: The type of message box. The possible values are `ok`, `okcancel`,
    `yesno`, `yesnocancel`, `retrycancel`, and `abortretryignore`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the type of message box is `ok`, which means that the user can
    only click an `ok` button to close the message box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third line of code, `paste0("Hello, it is: ", Sys.time())`, creates a string
    that will be displayed in the message box. The string includes the current time,
    which is obtained from the `Sys.time()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: When this code is run, a message box will pop up that displays the current time
    and an `ok` button. The user can click the **OK** button to close the message
    box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of what the message box will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Hello world message box](img/B19142_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Hello world message box
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a couple of scripts that will pop this message up on a screen
    on schedule. Here is one that will run this hourly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code, `taskscheduler_create()`, calls the `taskscheduler_create()`
    function from the `taskscheduleR` package. The `taskscheduleR` package provides
    functions for creating and managing Windows task scheduler jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `taskscheduler_create()` function takes the following three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`taskname`: The name of the task scheduler job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rscript`: The path to the R script that will be run by the task scheduler
    job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schedule`: The schedule for the task scheduler job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the task name is `Hello World Hourly`, the R script is `hello_world.R`,
    and the schedule is `"HOURLY"`.
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code, `taskname = "Hello World Hourly"`, sets the task name
    to `Hello World Hourly`. The task name is a unique identifier for the task scheduler
    job.
  prefs: []
  type: TYPE_NORMAL
- en: The third line of code, `rscript = "hello_world.R"`, sets the path to the R
    script that will be run by the task scheduler job. The R script must be saved
    in a location that is accessible by the task scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth line of code, `schedule = "HOURLY"`, sets the schedule for the task
    scheduler job. The schedule is a string that specifies when the task scheduler
    job will run. The schedule `"HOURLY"` means that the task scheduler job will run
    every hour. When this code is run, a new task scheduler job will be created that
    runs the `hello_world.R` R script every hour.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will move on to using `RDCOMClient` for Outlook if you are not using
    Microsoft 365\. This will allow us to script sending emails inside of other processes.
  prefs: []
  type: TYPE_NORMAL
- en: RDCOMClient for Outlook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, `RDCOMClient` is a powerful R package that allows you to interact
    with Microsoft Outlook using the COM interface. With `RDCOMClient`, you can automate
    tasks in Outlook, such as sending emails, accessing folders, managing appointments,
    and more. Sending emails via Outlook using `RDCOMClient` is straightforward and
    can be achieved by following a few steps. Here is the script for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now understand each line of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to install and load the `RDCOMClient` package in your R environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once installed, load the package using the `library()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a new Outlook application object using the `COMCreate()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates a connection to the Outlook application. Now, you can create a
    new email object using the `OutApp$CreateItem()` method and specify the email
    type as `olMailItem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you can set various properties of the email, such as the recipient, subject,
    body, attachments, and more. Here’s an example of how you can set these properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After setting the desired properties, you can send the email using the `Send()`
    method, and that’s it!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The email will be sent from your Outlook account to the specified recipient(s)
    with the configured properties. Remember to release the COM object and terminate
    the connection once you are done.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This ensures that the resources are properly released.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By using `RDCOMClient`, you can automate email-sending tasks in Outlook directly
    from R, enabling you to streamline your workflow and save time. It provides a
    convenient way to integrate R with Outlook and leverage its features programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will delve into the `Microsoft365R` and `blastula` packages, which work
    in tandem. This will be instead of using the `RDCOMClient` library, with the reason
    being that Microsoft365R works for those that are using Microsoft Azure instead
    of a generic SMTP connection via Outlook.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Microsoft365R and blastula packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to go over two packages that can be used in conjunction with
    each other to create emails via Outlook from Microsoft. These packages are Microsoft365R
    and blastula. Let’s look at them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft365R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microsoft365R** is an R library that provides an interface to Microsoft 365
    (formerly known as Office 365) cloud services. It is built on top of the AzureGraph
    package, which provides a high-level abstraction for interacting with the Microsoft
    Graph API. Microsoft365R currently supports the following Microsoft 365 services:'
  prefs: []
  type: TYPE_NORMAL
- en: Teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SharePoint Online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OneDrive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library provides several top-level client functions for accessing each of
    these services. For example, the `get_personal_onedrive()` function can be used
    to access your personal OneDrive account, and the `get_business_outlook()` function
    can be used to access your work or school Outlook account.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft365R also provides several helper functions for working with the Microsoft
    Graph API. For example, the `list_drive_contents()` function can be used to list
    the contents of a OneDrive drive, and the `send_email()` function can be used
    to send an email from Outlook.
  prefs: []
  type: TYPE_NORMAL
- en: The library is well-documented and provides several examples to help you get
    started. It is also actively maintained and updated with new features and bug
    fixes on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the benefits of using Microsoft365R:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a simple and easy-to-use interface for accessing Microsoft 365 cloud
    services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is built on top of the `AzureGraph` package, which provides a high-level
    abstraction for interacting with the Microsoft Graph API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are looking for an R library that provides an easy way to access Microsoft
    365 cloud services, then Microsoft365R is a great option. It is well-documented
    in the package vignettes, actively maintained, and supports a wide range of Microsoft
    365 services. We will only be focusing on its use for Outlook.
  prefs: []
  type: TYPE_NORMAL
- en: The blastula package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `blastula` R package is a tool that makes it easy to produce and send HTML
    email from R. You can use Markdown text, block-based components, and even HTML
    fragments to create email messages with three content areas: a body, header, and
    a footer. The package also provides functions to set up `install.packages("blastula")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of using blastula over other email packages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to use Markdown text, block-based components, and even HTML in
    order to create professional and potentially computed document emails. You can
    achieve this in the body, the header, and the footer of the email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package also provides functions to set up SMTP access credentials and send
    email through a traditional SMTP server, or, if you are a RStudio Connect user,
    you can send emails via RStudio Connect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting email will look great on any display.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is intuitive, allowing you to code quickly and effectively while
    making your primary focus the message of the email itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of using `blastula` to create and send a simple HTML email
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to load the `blastula` package with `library(blastula)` and `library(glue)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we can use the `compose_email()` function to create the email message.
    We can supply Markdown text to the body argument to be rendered in HTML; for example,
    see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can preview the email message in the viewer by calling the email object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can send the email message through an SMTP server using the `smtp_send()`
    function. We need to provide the recipient’s email address, the sender’s email
    address, the subject line, and the credentials for the SMTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `creds_file()` function is a helper function that creates a credentials
    file for SMTP access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the `create_smtp_creds_file()` function to generate this file interactively:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will prompt us to enter our password and a two-factor authentication code
    (if enabled) for Gmail. The credentials file will be saved in a secure location
    and can be reused for future email messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone over both packages separately, let’s see how we can use
    them together in a fashion that could be a bit more robust and streamlined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a full script, and then we will discuss how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s go over each part of the script to understand what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: First, we must install both the `blastula` and `Microsoft365R` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call those libraries into the current session using the `library()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a variable called `outlb` that holds the variable for the `get_business_outlook()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create the body of the email. We can write the email using Markdown
    syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we make the body of the email, we then create a variable to hold the email
    itself that is created using the function `compose_email()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we then add the attachment and send the email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The email is sent using the configured work/school email account retrieved earlier.
    So, in conclusion, these lines of code install the necessary packages, load the
    required libraries, retrieve the work/school email account, compose an email using
    the `blastula` package, add an attachment to the email, and finally, send the
    email using the `Microsoft365R` package.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned about scheduling and email integration in R. Now, let’s have
    a look at how the same can be achieved in Python!
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling Python scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation is not limited to executing scripts manually; it also involves scheduling
    them to run at specific intervals or events. Scheduling Python scripts allows
    you to automate repetitive tasks, perform periodic data updates, generate reports,
    and carry out system maintenance without manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore various techniques and tools to schedule Python
    scripts and achieve efficient and timely execution.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a comprehensive understanding of various
    scheduling techniques and tools available for Python scripts. You will be equipped
    with the knowledge and skills to schedule your Python scripts effectively, automate
    routine tasks, and maximize your productivity. Whether you are running scripts
    on Windows or Unix-like systems, this chapter will empower you to implement reliable
    and efficient Python script scheduling solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Python script scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by discussing the importance of scheduling Python scripts and
    its benefits in streamlining workflows. You will learn why scheduling is crucial
    for automating tasks and how it can save time and effort. We will also highlight
    real-world scenarios where Python script scheduling is commonly applied.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling Python scripts plays a vital role in automating tasks and improving
    workflow efficiency. By scheduling scripts to run at specific intervals or events,
    you can eliminate the need for manual execution and ensure timely and accurate
    data processing, report generation, and system maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will explore the importance of Python script scheduling
    and highlight its benefits in the various domains listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automating repetitive tasks**: Many tasks in data processing, analysis, and
    reporting involve repetitive actions. Scheduling Python scripts allows you to
    automate these tasks, reducing the time and effort required for manual execution.
    Whether it’s fetching data from external sources, performing calculations, generating
    reports, or updating databases, scheduling scripts ensures consistent and reliable
    automation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Periodic data updates**: In many applications, data need to be regularly
    updated from external sources or refreshed from internal systems. Python script
    scheduling enables you to define a schedule for fetching, transforming, and updating
    data automatically. By specifying the desired frequency, you can ensure that your
    data remain up to date without manual intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generating reports**: Reports are often generated periodically, such as daily,
    weekly, or monthly. With Python script scheduling, you can automate the generation
    of reports by scheduling the script to run at specific intervals. This ensures
    that the reports are produced consistently and delivered on time, saving valuable
    time and effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System maintenance**: Python script scheduling is not limited to data-related
    tasks; it can also be used for system maintenance activities. From performing
    backups and database maintenance to running system checks and executing routine
    cleanup tasks, scheduling Python scripts enables you to keep your systems running
    smoothly without manual intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-world scenarios**: Python script scheduling finds application in various
    industries and domains. For example, in ecommerce, scripts can be scheduled to
    update product inventory, synchronize prices, and generate sales reports. In finance,
    scheduled scripts can fetch stock market data, calculate portfolio performance,
    and generate financial statements. In IT operations, scripts can be scheduled
    for system monitoring, log analysis, and automated incident response. These are
    just a few examples of how Python script scheduling can be leveraged to enhance
    productivity and efficiency across different domains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding the importance of Python script scheduling and its benefits,
    you can identify opportunities to automate tasks, streamline workflows, and improve
    overall productivity.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore different methods and tools for scheduling
    Python scripts, providing you with the knowledge and techniques to implement effective
    and reliable automation solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in scheduling options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides built-in scheduling options on both Windows and Unix-like systems
    without the need for external libraries. These options provide a convenient and
    lightweight way to schedule and execute your Python scripts at predefined intervals.
    In this section, we will explore the built-in scheduling options and discuss their
    features, usage, and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore **Windows Task Scheduler** and **crontab** on Unix-like systems.
    You will learn how to set up scheduled tasks using these native scheduling tools,
    specify the frequency of execution, and configure various options to meet your
    specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the built-in options and their key features:'
  prefs: []
  type: TYPE_NORMAL
- en: cron (Unix-like systems)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the key features of cron:'
  prefs: []
  type: TYPE_NORMAL
- en: cron is a time-based job scheduler available on Unix-like operating systems,
    including Linux and macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to schedule recurring tasks by specifying the time, date, and
    frequency using a cron expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cron provides flexibility in defining schedules, such as running scripts at
    specific times, on specific days of the week, or at regular intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is widely supported and has been the de facto standard for scheduling tasks
    on Unix-like systems for many years
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While cron is not a Python-specific tool, you can use it to schedule the execution
    of Python scripts by specifying the appropriate command line invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Task Scheduler (Windows systems)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following points list the features of Windows systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Task Scheduler is the built-in task scheduling tool provided by the
    Windows operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows you to schedule tasks to run at specific times or events on Windows
    machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create scheduled tasks through the graphical user interface or using
    the command line tool `schtasks`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Task Scheduler provides a range of options for defining triggers, such
    as specific times, daily, weekly, or monthly schedules, or even based on system
    events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers a user-friendly interface for managing scheduled tasks, including
    setting up dependencies, priority settings, and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s time.sleep() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a list of the key features of the `time.sleep()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: While not specifically designed for scheduling tasks, Python’s built-in `time`
    module provides a simple way to introduce delays between script executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `time.sleep()` function pauses the script for a specified number of seconds,
    allowing you to control the timing between script runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this option lacks the sophistication and advanced features of dedicated
    scheduling tools, it can be useful for simple cases where a fixed delay is sufficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, keep in mind that using `time.sleep()` as a scheduling mechanism may
    not be suitable for precise or complex scheduling requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that these built-in scheduling options have their strengths
    and limitations. They are suitable for many use cases but may not provide the
    advanced features and flexibility required for complex scheduling scenarios. In
    such cases, external libraries and tools can offer more robust solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore some popular third-party libraries for
    scheduling Python scripts, providing additional features and customization options.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party scheduling libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Python’s built-in scheduling options can handle many common scheduling
    tasks, there are several third-party libraries available that provide more advanced
    features and customization options. These libraries offer greater flexibility
    and control over scheduling Python scripts, allowing you to handle complex scheduling
    scenarios with ease.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore some popular third-party scheduling libraries
    and discuss their features and benefits. We will cover topics such as defining
    schedules using cron-like syntax, handling time zones, and managing concurrent
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: schedule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the features and benefits of the `schedule` library:'
  prefs: []
  type: TYPE_NORMAL
- en: The `schedule` library is a lightweight Python library that simplifies the process
    of scheduling tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers an intuitive and easy-to-use API for defining schedules using a fluent
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The library supports various scheduling options, such as specific times, intervals,
    and cron-like expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schedule` allows you to execute functions, methods, or even shell commands
    at the defined schedule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is designed to be simple and lightweight, making it suitable for smaller
    projects or cases where a minimalistic scheduling solution is desired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an easy-to-demonstrate usage of `schedule` in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we import the `schedule` library and define a function called
    `job()`, which prints a message. We then use the `schedule.every().day.at(08:00).do(job)`
    syntax to schedule the `job` function to run every day at 8:00 am. Finally, we
    use a `while` loop to continuously check for pending scheduled jobs and execute
    them. Note that this solution means the console is `blocked`, meaning the Python
    process running this infinite loop will not be available for other tasks. To stop
    the scheduler, simply interrupt the kernel/console or kill the underlying Python
    process.
  prefs: []
  type: TYPE_NORMAL
- en: You can customize the scheduling behavior by using different methods provided
    by the `schedule` library, such as `.every().day.at()`, `.every().monday`, `.every().hour`,
    and more. Additionally, you can schedule jobs to run at specific intervals or
    combine multiple scheduling patterns as per your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at `APScheduler` next.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Python Scheduler (APScheduler)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the features and benefits of `APScheduler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced Python Scheduler** (**APScheduler**) is another popular choice for
    scheduling tasks in Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a rich set of features, including various trigger types, such as
    intervals, cron expressions, and date-based triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APScheduler supports multiple job stores, including in-memory, SQL databases,
    and Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers advanced scheduling options, such as job coalescing, distributed scheduling,
    and time zone support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APScheduler has a well-documented API and is widely used in various applications,
    ranging from simple scripts to complex web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a sample code snippet demonstrating how to schedule tasks using the
    `APScheduler` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding example, we understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the `BlockingScheduler` class from the `apscheduler.schedulers.blocking`
    module. Then, we create an instance of the scheduler using `BlockingScheduler()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define a function called `send_email()`, which represents the task
    of sending an email. Inside this function, you can write the code to send an email
    or perform any other desired action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To schedule the task, we use the `add_job()` method of the scheduler. In this
    case, we specify the `send_email` function as the task to be executed. We also
    provide the scheduling parameters using the `interval` option, which indicates
    that the task should be executed at regular intervals. In this example, we set
    it to run every hour (`hours=1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we start the scheduler by calling the `start()` method. This will initiate
    the scheduler and begin executing the tasks according to the defined schedule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `APScheduler` library provides various scheduling options, such as fixed
    intervals, cron expressions, date/time triggers, and more. You can customize the
    scheduling behavior according to your specific requirements by exploring the documentation
    and using the appropriate scheduling options provided by APScheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, let’s have a look at the Celery package for completeness’ sake.
  prefs: []
  type: TYPE_NORMAL
- en: Celery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the features and benefits of Celery:'
  prefs: []
  type: TYPE_NORMAL
- en: Celery is a distributed task queue library that can be used for both task execution
    and scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a robust and scalable solution for scheduling Python tasks across
    multiple workers or machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celery supports various scheduling options, including intervals, crontab-like
    expressions, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers advanced features such as task prioritization, result tracking, retries,
    and task chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celery integrates well with message brokers such as **RabbitMQ**, **Redis**,
    or **Apache Kafka**, providing reliable and scalable task-scheduling capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By using the Celery scheduler, you can automate the execution of tasks based
    on specific schedules, allowing you to perform recurring or time-based operations
    in your application. Configuring and deploying Celery apps is beyond the scope
    of this book, though, so it only stands here for completeness’ sake. You can consult
    the official documentation if you wish to delve deeper: [https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html](https://docs.celeryq.dev/en/stable/userguide/periodic-tasks.html).'
  prefs: []
  type: TYPE_NORMAL
- en: These third-party scheduling libraries provide powerful and flexible solutions
    for scheduling Python scripts. Depending on your specific requirements and the
    complexity of your scheduling tasks, you can choose the library that best fits
    your needs. Each library has its own strengths and capabilities, so it’s important
    to evaluate them based on your project’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore practical examples of using these libraries
    to schedule Python scripts for various use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and considerations for robust automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with scheduling Python scripts, it’s essential to follow best practices
    and consider various factors to ensure efficient and reliable automation. This
    section provides insights into the best practices and considerations for scheduling
    Python scripts effectively.
  prefs: []
  type: TYPE_NORMAL
- en: These best practices will help you create robust and maintainable scheduled
    tasks. Let’s discuss these best practices in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling and logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for error handling and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement robust error-handling mechanisms to handle any unexpected exceptions
    and errors that may occur during script execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use logging frameworks to capture detailed information about script execution,
    including errors, warnings, and information messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper error handling and logging allow you to diagnose issues, track script
    performance, and ensure that scheduled tasks are executed as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for resource management:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the resources required by your scheduled Python scripts, such as CPU,
    memory, and disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize resource usage by identifying and minimizing any resource-intensive
    operations or bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that your scripts release resources properly to avoid resource leaks
    or conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for security considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the security implications of scheduling Python scripts, especially
    if they involve sensitive data or interact with external systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement necessary security measures, such as encrypting credentials, securing
    API endpoints, and adhering to authentication and authorization protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly review and update security measures to mitigate potential risks and
    vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for testing and validation:'
  prefs: []
  type: TYPE_NORMAL
- en: Thoroughly test and validate your scheduled Python scripts to ensure their correctness
    and reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform unit testing, integration testing, and end-to-end testing to verify
    that your scripts function as expected and handle various scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider creating a staging environment where you can test scheduled tasks before
    deploying them to a production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for monitoring and alerting:'
  prefs: []
  type: TYPE_NORMAL
- en: Establish monitoring and alerting mechanisms to track the execution status of
    scheduled tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor the performance and health of your scheduling system, including script
    execution times, resource usage, and any potential errors or failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure alerts to notify you when tasks fail, enabling prompt intervention
    and troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation and maintenance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the best practices for documentation and maintenance:'
  prefs: []
  type: TYPE_NORMAL
- en: Document the scheduling process, including the configuration, dependencies,
    and any specific instructions for managing scheduled tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain an up-to-date schedule of your scheduled Python scripts, including
    the frequency and expected outcomes of each task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly review and update your scheduling setup, scripts, and dependencies
    to adapt to changing requirements and technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices and considering the relevant factors, you
    can ensure the reliability, efficiency, and security of your scheduled Python
    scripts. Incorporating these considerations into your scheduling workflow will
    contribute to the smooth execution of tasks and help you maintain a well-structured
    and sustainable automation system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore practical examples and use cases that illustrate
    the application of these best practices and considerations in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'By completing this section on scheduling Python scripts, you have gained valuable
    knowledge and skills in automating and managing the execution of your scripts.
    Let’s summarize what you have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: You explored the various built-in scheduling options available in different
    operating systems, such as cron jobs on Unix-like systems and Task Scheduler on
    Windows, enabling you to schedule Python scripts at specific times or intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You discovered third-party scheduling libraries, such as `APScheduler` and `Schedule`,
    which provide more advanced scheduling capabilities, such as cron-like expressions
    and interval-based scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You understood the best practices for scheduling Python scripts, including error
    handling, resource management, security considerations, testing, validation, monitoring,
    and alerting, as well as documentation and maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through practical examples and use cases, you gained hands-on experience in
    implementing and managing scheduled Python scripts, ensuring the efficient and
    reliable automation of your tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By mastering the concepts and techniques covered in this section, you are now
    equipped to schedule Python scripts effectively, automate repetitive tasks, and
    streamline your workflow. The ability to schedule scripts opens a world of possibilities
    for automating various processes, increasing productivity, and freeing up valuable
    time for more critical tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve into the exciting realm of email notifications
    and explore how you can enhance your automation workflows by integrating email
    functionality into your Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Email notifications and automation with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like scheduling Python scripts, email notifications and automation can
    make your daily work much more efficient. This section will cover the basics,
    such as the motivation behind using emails from Python, moving on to setting up
    the environment and sending basic emails, and then covering a real-life use case:
    sending email notifications for script status.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to email notifications in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Email notifications play a crucial role in automation by providing timely updates,
    alerts, and reports. In this section, we will explore the significance of integrating
    email functionality into your Python scripts. We’ll discuss various use cases
    where email notifications can be beneficial, and we’ll delve into the advantages
    they offer for streamlining workflows and enhancing communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the most basic considerations: why would you do this?'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases and benefits of integrating email functionality into your scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Email notifications are versatile and can be applied to a wide range of scenarios.
    Some common use cases include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task completion notifications**: These send notifications to indicate the
    successful completion of a task or process, helping to keep stakeholders informed
    and reassuring them that everything is running smoothly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error and exception reporting**: This involves alerting relevant team members
    or administrators when errors or exceptions occur during script execution, allowing
    for prompt troubleshooting and issue resolution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Progress updates**: This provides periodic progress updates to stakeholders
    or clients, ensuring transparency and maintaining open lines of communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data analysis reports**: These automate the generation and delivery of data
    analysis reports via email, saving time and effort by eliminating the need for
    manual report creation and distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System monitoring**: This involves setting up email notifications to monitor
    system status, such as server uptime, disk space usage, or application performance.
    Immediate alerts can help address potential issues before they impact operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By incorporating email notifications into your Python scripts, you can benefit
    from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Realtime updates**: Stay informed about the progress, status, and results
    of automated tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced collaboration**: Facilitate communication and collaboration among
    team members by providing timely notifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error detection and resolution**: Receive alerts about errors or exceptions
    in your scripts, enabling you to identify and resolve issues quickly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization and personalization**: Tailor email notifications to suit your
    specific requirements, including content, formatting, and recipients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined workflows**: Automate the delivery of reports, updates, and alerts,
    saving time and effort in manual distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this section, we will explore the various aspects of email notifications
    in Python, empowering you to leverage this powerful communication tool within
    your automation workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and explore how to set up and use email functionality effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up email services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into sending email notifications from Python, it’s essential to
    set up the necessary email services to establish a connection between your script
    and the email server.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a clear understanding of how to set
    up email services for your Python scripts. You’ll be equipped with the necessary
    knowledge to choose the right email service provider, obtain the required SMTP
    server credentials, configure secure connections, and test the connection. With
    your email services in place, you’ll be ready to move on to the next steps of
    sending email notifications seamlessly from your Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started and set up your email services effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the steps involved in configuring email services,
    including the following aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an email service provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several email service providers available, each offering different
    features and options. In this section, we will be using Gmail as an example but
    the code can easily be adapted to other providers, such as Microsoft Exchange,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining SMTP server credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To send emails programmatically, it’s important to obtain the SMTP server credentials
    provided by your email service provider. These credentials are essential for establishing
    a connection with the email server and sending emails securely.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll guide you through the process of acquiring the necessary
    information to configure your email settings effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`smtp.example.com` or `mail.example.com`. Make sure you verify the correct
    SMTP server address for your specific email service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port number**: The port number specifies the communication endpoint for the
    SMTP server. Common port numbers for SMTP communication include 25, 465 (for SSL/TLS
    encrypted connections), and 587 (for STARTTLS encrypted connections). Your email
    service provider will specify the appropriate port number to use for sending emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication details**: To authenticate yourself with the SMTP server,
    you will need to provide a username and password. These credentials are used to
    establish a secure connection and ensure that only authorized users can send emails.
    Your email service provider will provide you with the necessary authentication
    details. In some cases, an API key or access token may be required for authentication
    instead of a traditional username and password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that the process of obtaining SMTP server credentials
    may vary depending on your email service provider. Some providers offer specific
    instructions or account settings where you can find the required information.
    If you’re unsure about where to find your SMTP server credentials, it’s recommended
    that you consult the documentation or support resources provided by your email
    service provider.
  prefs: []
  type: TYPE_NORMAL
- en: By obtaining the SMTP server credentials, you’ll be equipped with the necessary
    information to establish a connection with the email server and send emails programmatically.
    This allows you to leverage the power of Python to automate email notifications,
    updates, and other communication tasks within your applications or scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure a successful setup, it’s important to test the connection between
    your Python script and the email server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll demonstrate how to perform a connection test by sending
    a test email using the provided SMTP server credentials. This will help verify
    that the connection is established correctly and that your script can communicate
    with the email server.
  prefs: []
  type: TYPE_NORMAL
- en: Sending basic emails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have set up our email services, we can proceed to the next step:
    sending basic emails from Python.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a solid understanding of how to send
    basic emails from Python. You’ll know how to import the required libraries, create
    email messages, establish a connection with the email server, and send the email
    using the SMTP protocol. With this knowledge, you’ll be able to send simple text-based
    emails from your Python scripts and lay the foundation for more advanced email
    notifications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the fundamental concepts and techniques for
    sending emails programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the required libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To send emails from Python, we need to import the necessary libraries that provide
    email-related functionality. Ahead, we’ll discuss popular libraries, such as `smtplib`
    and `email.mime`, which offer convenient features for creating and sending emails.
    We’ll guide you through the installation process and demonstrate how to import
    these libraries into your Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the email message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before sending an email, we need to construct the email message, which includes
    the sender, recipient, subject, and body of the email. We’ll show you how to create
    an email message using the `email.mime` library, allowing you to customize various
    aspects of the email, such as adding attachments or setting HTML content. We’ll
    provide code examples and explanations to help you understand the structure and
    components of an email message.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To send an email, we need to establish a connection with the email server using
    the SMTP protocol. We’ll demonstrate how to establish a connection using the SMTP
    server credentials obtained earlier. We’ll guide you through the process of creating
    an SMTP object, setting up the connection, and handling any potential errors or
    exceptions that may arise during the establishment of the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the connection is established, we can proceed to send the email. We’ll
    demonstrate how to use the `smtplib` library to send an email message. We’ll cover
    the necessary steps, including authenticating with the email server, specifying
    the sender and recipient addresses, and invoking the `sendmail()` method. We’ll
    also discuss error handling and provide best practices for ensuring the successful
    delivery of the email.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding sections are the steps that are implemented in the following
    code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From this code example, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the `smtplib` library to establish an SMTP connection and the
    `MIMEText` and `MIMEMultipart` classes from the `email.mime` module for creating
    the email message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we define the SMTP server details, including the server address, port,
    and the credentials (username and password) required for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a `MIMEMultipart` object called message, which represents the
    email message. We set the sender and recipient addresses, as well as the subject
    of the email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we send the email using the `send_message()` method of the SMTP server
    object, passing the message as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember to replace the placeholder values (`your_smtp_server` and `your_username`).
    To add the email body, we create a `MIMEText` object called body and attach it
    to the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterward, we establish a connection with the email server using the `smtplib.SMTP`
    class, passing the server address and port as arguments. We start the TLS encryption
    using the `starttls()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we log in to the email server using the `login()` method and provide the
    username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, use `your_password`, `sender@example.com`, and `recipient@example.com`
    with your actual SMTP server details and email addresses.
  prefs: []
  type: TYPE_NORMAL
- en: By following this code example, you’ll be able to send basic emails using the
    `smtplib` and `email.mime` libraries in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Sending email notifications for script status
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to define triggers, implement email notification
    logic, customize email content, and handle email delivery and errors effectively.
    With these skills, you’ll be able to enhance the monitoring and reporting capabilities
    of your scripts and stay informed about the progress and outcomes of your automated
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you will have a clear understanding of how to incorporate
    email notifications into your Python scripts to receive updates on script execution
    and status.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key use cases for email notifications in Python is to receive updates
    on the status of your scripts or processes. In this section, we will delve into
    the process of sending email notifications to keep track of the execution and
    status of your scripts. By implementing this functionality, you can stay informed
    about the progress and outcomes of your automated processes and take the necessary
    actions when needed.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let’s explore the steps involved in sending email notifications for
    script status.
  prefs: []
  type: TYPE_NORMAL
- en: Defining triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can send email notifications, we need to define triggers that determine
    when the notifications should be sent. Triggers can be based on specific conditions
    or events that occur during script execution. For example, you may want to send
    an email notification when a script completes successfully, encounters an error,
    or reaches a specific milestone. By defining triggers, you have full control over
    when and under what circumstances email notifications are sent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing email notification logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the triggers are defined, we can proceed to implement the logic for sending
    email notifications. This involves incorporating the necessary code within your
    script to check the triggers and initiate the email-sending process. You will
    need to import the required libraries, establish a connection with the email server,
    and customize the email content. The logic should be designed to efficiently handle
    the sending of email notifications based on the specified triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing email content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide relevant and informative content in your email notifications, you
    can customize various aspects of the email, such as the subject, body, and any
    additional details. The content can include information about the script’s execution
    status, error messages, relevant data or statistics, and any other details that
    are important for understanding the script’s progress. By customizing the email
    content, you can ensure that recipients have the necessary information to take
    appropriate actions or make informed decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling email delivery and errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sending emails involves interacting with email servers, and various factors
    can affect the successful delivery of emails. It’s important to handle potential
    issues such as network connectivity problems, email server errors, or recipient
    email address errors. By implementing error-handling mechanisms, you can gracefully
    handle email delivery issues and ensure that notifications are sent reliably.
    Additionally, logging and error reporting can be useful for troubleshooting and
    diagnosing any email-related problems that may occur.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, by implementing email notifications for script status, you can stay
    informed about the progress and outcomes of your automated processes. You have
    the flexibility to define triggers, customize email content, and handle potential
    email delivery issues effectively. This functionality enhances the monitoring
    and reporting capabilities of your scripts and enables you to take timely actions
    based on the script’s status. With these techniques in place, you can confidently
    automate your processes while staying updated on their execution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sections on scheduling and email notifications in Python, you have gained
    a comprehensive understanding of the key concepts. You have learned about different
    scheduling options for Python scripts, including built-in options and third-party
    libraries such as `schedule` and `APScheduler`. The chapter also emphasizes the
    importance of following best practices for email notifications, such as error
    handling, resource management, security considerations, testing, monitoring, documentation,
    and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: You can now recognize the value of email notifications in providing timely updates
    on the status and results of processes in automated systems. We have explored
    Python’s powerful libraries and modules, such as `smtplib` and `email.mime`, which
    enable the creation and customization of email messages. Additionally, you have
    acquired the knowledge required to set up email services by configuring SMTP servers,
    authentication credentials, and other relevant settings. We have also learned
    about packages in R, such as `tasksheduleR`, `blastula`, and `Microsoft365R`,
    that will perform these functions as well. They have a solid and simple syntax,
    which makes them very powerful tools.
  prefs: []
  type: TYPE_NORMAL
- en: With a solid understanding of the basics, you have learned how to construct
    simple email messages with the necessary headers and content to implement basic
    email functionality. You have also discovered the versatility of email notifications
    in providing updates on script execution, including success, failure, or specific
    events. Now that you are armed with these insights, readers are well-equipped
    to integrate email notifications effectively into their Python projects.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, you should have gained a comprehensive understanding
    of scheduling Python scripts and email notifications in Python. You have learned
    when and how to use various scheduling tools, set up email services, and send
    basic emails. In the next chapter, we will learn how to format Excel with Python
    and R.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Making It Pretty – Formatting, Graphs, and More'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we delve into enhancing the visual appeal and functionality of
    your Excel sheets. You will learn how to format your data elegantly using libraries
    such as `styledTables`, `tablaxlsx`, `excelR`, `basictabler`, and `tidyxl` in
    R and `pandas` and `openpyxl` in Python. You will discover techniques to seamlessly
    insert `ggplot2` and `matplotlib` graphs into your Excel sheets, bringing your
    data to life. Additionally, you will master the art of creating pivot tables using
    `tidyquant` in R and `win32com` and `pypiwin32` in Python, along with advanced
    summary table creation using `{gt}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19142_05.xhtml#_idTextAnchor099), *Formatting Your Excel Sheet*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19142_06.xhtml#_idTextAnchor119), *Inserting ggplot2/matplotlib
    Graphs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19142_07.xhtml#_idTextAnchor145), *Pivot Tables and Summary
    Tables*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
