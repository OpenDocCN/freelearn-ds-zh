- en: Chapter 2. Accessing Geodata
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 访问地理数据
- en: 'All GIS processing must start with geographic data, so we begin our application
    by building the capacity to interact with, load, and save various geographic file
    formats. This chapter is divided into a vector and raster section, and in each
    section, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GIS处理都必须从地理数据开始，因此我们开始构建与各种地理文件格式交互、加载和保存的能力。本章分为向量和平铺部分，在每一部分中，我们将涵盖以下内容：
- en: Firstly, we create a data interface which means understanding data structures
    and how to interact with them.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个数据接口，这意味着理解数据结构以及如何与之交互。
- en: Secondly and thirdly, any format-specific differences are outsourced to separate
    loader and saver modules.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次和第三，任何特定格式的差异都外包给单独的加载器和保存器模块。
- en: This is a lot of functionality to fit into one chapter, but by working your
    way through, you will learn a lot about data structures, and file formats, and
    end up with a solid foundation for your application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一个章节中包含了很多功能，但通过逐步工作，你将学会很多关于数据结构和文件格式的东西，并最终为你的应用程序打下坚实的基础。
- en: The approach
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: In our efforts to build data access in this chapter, we focus on simplicity,
    understanding, and lightweight libraries. We create standardized data interfaces
    for vector and raster data so that we can use the same methods and expect the
    same results on any data, without worrying about file format differences. They
    are not necessarily optimized for speed or memory efficiency as they load entire
    files into memory at once.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力构建本章中的数据访问时，我们关注简洁性、可理解性和轻量级库。我们为向量和平铺数据创建了标准化的数据接口，这样我们就可以在任何数据上使用相同的方法并期望得到相同的结果，而不用担心文件格式差异。它们并不一定针对速度或内存效率进行优化，因为它们会一次性将整个文件加载到内存中。
- en: In our choice of third-party libraries for loading and saving, we focus on format-specific
    ones, so that we can pick and choose which formats to support and thus maintain
    a lightweight application. This requires some more work but allows us to learn
    intricate details about file formats.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们选择用于加载和保存的第三方库时，我们专注于格式特定的库，这样我们就可以选择支持哪些格式，从而保持应用程序的轻量级。这需要更多的工作，但允许我们了解关于文件格式的复杂细节。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the size is not an issue in your application, you may wish to instead use
    the more powerful **GDAL** library, which can single-handedly load and save a
    much wider range of both vector and raster formats. To use GDAL, I suggest downloading
    and installing a precompiled version from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal).
    On top of GDAL, the packages **Fiona** ([http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona))
    and **Rasterio** ([http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio](http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio))
    provide a more convenient and Pythonic interface to GDAL's functionality for vector
    and raster data, respectively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的应用程序中大小不是问题，您可能希望改用更强大的**GDAL**库，该库可以单独加载和保存更广泛的向量和平铺格式。要使用GDAL，我建议从[http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal](http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal)下载并安装预编译版本。在GDAL之上，**Fiona**([http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona](http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona))和**Rasterio**([http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio](http://www.lfd.uci.edu/~gohlke/pythonlibs/#rasterio))这两个包提供了更方便和Pythonic的接口，分别用于GDAL的向量和平铺数据功能。
- en: Vector data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量数据
- en: 'We begin by adding support for vector data. We will be creating three submodules
    inside our `vector` package: `data`, `loader`, and `saver`. To make these accessible
    from their parent vector package, we need to import it in `vector/__init__.py`
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加对向量数据的支持。我们将在`vector`包内部创建三个子模块：`data`、`loader`和`saver`。为了使它们可以从父向量包中访问，我们需要在`vector/__init__.py`中导入它，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A data interface for vector data
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量数据的数据接口
- en: The first thing we want is a data interface that we can conveniently interact
    with. This data interface will be contained in a module of its own, so create
    this module now and save it as `vector/data.py`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想要的是一个可以方便交互的数据接口。这个数据接口将包含在其自己的模块中，所以现在创建这个模块并将其保存为`vector/data.py`。
- en: 'We start off with a few basic imports, including compatibility functions for
    Shapely (which we installed in [Chapter 1](ch01.html "Chapter 1. Preparing to
    Build Your Own GIS Application"), *Preparing to Build Your Own GIS Application*)
    and the spatial indexing abilities of **Rtree**, a package we will install later.
    Note that vector data loading and saving, are handled by separate modules that
    we have not yet created, but since they are accessed through our data interface,
    we need to import them here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先进行一些基本的导入，包括Shapely的兼容性函数（我们在[第1章](ch01.html "第1章. 准备构建您自己的GIS应用程序")中安装了它，*准备构建您自己的GIS应用程序*）和**Rtree**包的空间索引能力，这是一个我们稍后将要安装的包。请注意，矢量数据的加载和保存由我们尚未创建的单独模块处理，但由于它们通过我们的数据接口访问，因此我们需要在这里导入它们：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您购买的所有Packt Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The vector data structure
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矢量数据结构
- en: 'Geographic vector data can be thought of as a table of data. Each row in the
    table is an observation (say, a country), and holds one or more attributes, or
    piece of information for that observation (say, population). In a vector data
    structure, rows are known as a **features**, and have additional geometry definitions
    (coordinates that define, say, the shape and location of a country). An overview
    of the structure may therefore look something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 地理矢量数据可以被视为一个数据表。表中的每一行是一个观测值（例如，一个国家），并包含一个或多个属性，或关于该观测值的信息（例如，人口）。在矢量数据结构中，行被称为**要素**，并具有额外的几何定义（定义国家形状和位置的坐标）。因此，结构的概述可能看起来像这样：
- en: '![The vector data structure](img/5407OS_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![矢量数据结构](img/5407OS_02_01.jpg)'
- en: In our implementation of the vector data structure, we therefore create the
    interface as a `VectorData` class. To create and populate a `VectorData` instance
    with data, we can give it a `filepath` argument that it loads via the loader module
    that we create later. We also allow for optional keyword arguments to pass to
    the loader, which as we shall see includes the ability to specify text encoding.
    Alternatively, an empty `VectorData` instance can be created by not passing it
    any arguments. While creating an empty instance, it is possible to specify the
    geometry type of the entire data instance (meaning, it can only hold either polygon,
    line, or point geometries), otherwise it will set the data type based on the geometry
    type of the first feature that is added.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的矢量数据结构实现中，我们创建了一个名为`VectorData`的接口。为了创建并填充一个`VectorData`实例，我们可以提供一个`filepath`参数，它将通过我们稍后创建的加载模块来加载。我们还允许传递可选的关键字参数给加载器，这将包括指定文本编码的能力。或者，可以通过不传递任何参数来创建一个空的`VectorData`实例。在创建空实例时，可以指定整个数据实例的几何类型（这意味着它只能包含多边形、线或点几何），否则它将根据添加的第一个要素的几何类型设置数据类型。
- en: In addition to storing the fieldnames and creating features from rows and geometries,
    a `VectorData` instance remembers the `filepath` origin of the loaded data if
    applicable, and the **Coordinate Reference System** (**CRS**) which defaults to
    unprojected WGS84 if not specified.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储字段名和从行和几何形状创建要素外，`VectorData`实例还记住加载数据的`filepath`源（如果适用），以及默认为未投影WGS84的**坐标参考系统**（**CRS**），如果没有指定。
- en: To store the features, rather than using lists or dictionaries, we use an **ordered**
    dictionary that allows us to identify each feature with a unique ID, sort the
    features, and perform fast and frequent feature lookups. To ensure that each feature
    in `VectorData` has a unique ID, we define a unique ID generator and attach independent
    ID generator instances to each `VectorData` instance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储要素，而不是使用列表或字典，我们使用一个**有序**字典，它允许我们使用唯一的ID来识别每个要素，对要素进行排序，并执行快速频繁的要素查找。为了确保`VectorData`中的每个要素都有一个唯一的ID，我们定义了一个唯一的ID生成器，并将独立的ID生成器实例附加到每个`VectorData`实例上。
- en: 'To let us interact with the `VectorData` instance, we add various magic methods
    to enable standard Python operations such as getting the number of features in
    the data, looping through them, and getting and setting them through indexing
    their ID. Finally, we include a convenient `add_feature` and `copy` method. Take
    a look at the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够与`VectorData`实例进行交互，我们添加了各种魔法方法来启用标准的Python操作，例如获取数据中的特征数量、遍历它们以及通过它们的ID进行索引来获取和设置它们。最后，我们还包括了一个方便的`add_feature`和`copy`方法。请看以下代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we load or add features, they are stored in a `Feature` class with a link
    to its parent `VectorData` class. For the sake of simplicity, maximum interoperability,
    and memory efficiency, we choose to store feature geometries in the popular and
    widely supported **GeoJSON** format, which is just a Python dictionary structure
    formatted according to certain rules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载或添加特征时，它们被存储在一个带有其父`VectorData`类链接的`Feature`类中。为了简化、最大程度地提高互操作性和内存效率，我们选择以流行的和广泛支持的**GeoJSON**格式存储特征几何形状，它只是一个根据某些规则格式化的Python字典结构。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GeoJSON is a human-readable textual representation to describe various vector
    geometries, such as points, lines, and polygons. For the full specification, go
    to [http://geojson.org/geojson-spec.html](http://geojson.org/geojson-spec.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON是一种人类可读的文本表示形式，用于描述各种矢量几何形状，如点、线和多边形。有关完整规范，请访问[http://geojson.org/geojson-spec.html](http://geojson.org/geojson-spec.html)。
- en: 'We make sure to give the `Feature` class some magic methods to support standard
    Python operations, such as easy getting and setting of attributes through fieldname
    indexing using the position of the desired field in the feature''s parent list
    of fields to fetch the relevant row value. A `get_shapely` method to return the
    Shapely geometry representation and `copy` method will also be useful for later.
    The following code explains the `Feature` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保给`Feature`类一些魔法方法来支持标准的Python操作，例如通过使用特征父字段列表中所需字段的位置通过字段名索引轻松获取和设置属性。一个返回Shapely几何表示的`get_shapely`方法和一个`copy`方法也将对以后很有用。以下代码解释了`Feature`类：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Computing bounding boxes
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算边界框
- en: 'Although we now have the basic structure of vector data, we want some additional
    convenience methods. For vector data, it is frequently useful to know the **bounding
    box** of each feature, which is an aggregated geographical description of a feature
    represented as a sequence of four coordinates `[xmin, ymin, xmax, ymax]`. Computing
    the bounding box can be computationally expensive, so we allow the `Feature` instance
    to receive a precomputed bounding box upon instantiation if available. In the
    Feature''s `__init__` method, we therefore add to what we have already written:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在已经有了矢量数据的基本结构，但我们还想添加一些额外的便利方法。对于矢量数据，知道每个特征的**边界框**通常非常有用，它是一个以四个坐标的序列`[xmin,
    ymin, xmax, ymax]`表示的特征的聚合地理描述。计算边界框可能计算成本较高，因此我们允许`Feature`实例在实例化时接收一个预计算的边界框（如果可用）。因此，在`Feature`的`__init__`方法中，我们添加了以下内容：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This bounding box can also be cached or stored, for later use, so that we can
    just keep referring to that value after we have computed it. Using the `@property`
    descriptor, before we define the `Feature` class''s `bbox` method, allows us to
    access the bounding box as a simple value or attribute even though it is computed
    as several steps in a method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此边界框也可以缓存或存储，以供以后使用，这样我们就可以在计算后只需引用该值。使用`@property`描述符，在我们定义`Feature`类的`bbox`方法之前，允许我们将边界框作为简单值或属性访问，尽管它是在方法中的几个步骤中计算的：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the bounding box for the entire collection of features in the `VectorData`
    class is also useful, so we create a similar routine at the `VectorData` level,
    except we do not care about caching because a `VectorData` class will frequently
    lose or gain new features. We want the bounding box to always be up to date. Add
    the following dynamic property to the `VectorData` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`VectorData`类中整个特征集合的边界框也非常有用，因此我们在`VectorData`级别创建了一个类似的例程，但我们不关心缓存，因为`VectorData`类会频繁地丢失或获得新的特征。我们希望边界框始终保持最新。向`VectorData`类添加以下动态属性：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Spatial indexing
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空间索引
- en: 'Finally, we add a spatial indexing structure that nests the bounding boxes
    of overlapping features inside each other so that feature locations can be tested
    and retrieved faster. For this, we will use the Rtree library. Perform the following
    steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个空间索引结构，将重叠特征的边界框嵌套在一起，以便可以更快地测试和检索特征位置。为此，我们将使用Rtree库。执行以下步骤：
- en: Go to [http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree](http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree](http://www.lfd.uci.edu/~gohlke/pythonlibs/#rtree)。
- en: Download the wheel file appropriate for our system, currently `Rtree-0.8.2.-cp27-none-win32.whl`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适合我们系统的wheel文件，目前是`Rtree-0.8.2.-cp27-none-win32.whl`。
- en: To install the package on Windows, open your command line and type `C:/Python27/Scripts/pip
    install path/to/Rtree-0.8.2.-cp27-none-win32.whl`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上安装该软件包，打开您的命令行并输入`C:/Python27/Scripts/pip install path/to/Rtree-0.8.2.-cp27-none-win32.whl`。
- en: To verify that the installation has worked, open an interactive Python shell
    window and type `import rtree`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证安装是否成功，请打开一个交互式Python shell窗口并输入`import rtree`。
- en: Note
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rtree is only one type of spatial index. Another common one is a **Quad Tree**
    index, whose main advantage is faster updating of the index if you need to change
    it often. `PyQuadTree` is a pure-Python implementation created by the author,
    which you can install in the command line as `C:/Python27/Scripts/pip install
    pyquadtree`.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rtree只是空间索引的一种类型。另一种常见的是**四叉树**索引，其主要优势是在需要经常更改索引时，更新索引的速度更快。`PyQuadTree`是由作者创建的一个纯Python实现，您可以在命令行中通过以下方式安装：`C:/Python27/Scripts/pip
    install pyquadtree`。
- en: 'Since spatial indexes rely on bounding boxes, which as we said before can be
    computationally costly, we only create the spatial index if the user specifically
    asks for it. Therefore, let''s create a `VectorData` class method that will make
    a spatial index from the Rtree library, populate it by inserting the bounding
    boxes of each feature and their ID, and store it as a property. This is shown
    in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间索引依赖于边界框，正如我们之前所说的，这可能会带来计算成本，因此我们仅在用户明确请求时创建空间索引。因此，让我们创建一个`VectorData`类方法，该方法将从Rtree库创建空间索引，通过插入每个特征的边界框及其ID来填充它，并将其存储为属性。以下代码片段展示了这一过程：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once created, Rtree''s spatial index has two main methods that can be used
    for fast spatial lookups. The spatial lookups only return the IDs of the matches,
    so we use those IDs to fetch the actual feature instances from the matched IDs.
    Given a target bounding box, the first method finds features that overlap it,
    while the other method loops through the *n* nearest features in the order of
    closest to furthest away. In case the target bounding box is not in the required
    `[xmin, ymin,xmax,ymax]` format, we force it that way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，Rtree的空间索引有两个主要方法可用于快速空间查找。空间查找仅返回匹配项的ID，因此我们使用这些ID从匹配的ID中获取实际的特征实例。给定一个目标边界框，第一个方法找到与之重叠的特征，而另一个方法则按从最近到最远的顺序遍历最近的*n*个特征。如果目标边界框不是所需的`[xmin,
    ymin,xmax,ymax]`格式，我们将强制将其转换为该格式：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Loading vector files
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载矢量文件
- en: 'So far, we have not defined the routine that actually loads data from a file
    into our `VectorData` interface. This is contained in a separate module as `vector/loader.py`.
    Start off the module by importing the necessary modules (don''t worry if you have
    never heard of them before, we will install them shortly):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有定义从文件加载数据到我们的`VectorData`接口的例程。这包含在一个单独的模块中，作为`vector/loader.py`。首先导入必要的模块（如果你之前从未听说过它们，不要担心，我们很快就会安装它们）：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The main point of the loader module is to use a function, which we call `from_file()`,
    that takes a filepath and automatically detects which file type it is. It then
    loads it with the appropriate routine. Once loaded, it returns the information
    that our `VectorData` class expects: fieldnames, a list of row lists, a list of
    GeoJSON dictionaries of the geometries, and CRS information. An optional encoding
    argument determines the text encoding of the file (which the user will have to
    know or guess in advance), but more on that later. Go ahead and make it now:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 加载模块的主要目的是使用一个函数，我们称之为`from_file()`，它接受一个文件路径并自动检测其文件类型。然后，它使用适当的例程加载该文件。一旦加载，它就返回我们的`VectorData`类期望的信息：字段名、行列表、几何形状的GeoJSON字典列表以及CRS信息。一个可选的编码参数确定文件的文本编码（用户将必须事先知道或猜测），但关于这一点我们稍后再说。现在就动手做吧：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Shapefile
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shapefile
- en: To deal with the shapefile format, an old but very commonly used vector file
    format, we use the popular and lightweight **PyShp** library. To install it in
    the command line just type `C:/Python27/Scripts/pip install pyshp`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理老式但非常常用的矢量文件格式——shapefile格式，我们使用了流行的轻量级**PyShp**库。在命令行中安装它，只需输入`C:/Python27/Scripts/pip
    install pyshp`。
- en: Inside the `from_file` function, we first detect if the file is in the shapefile
    format and then run our routine for loading it. The routine starts using the PyShp
    module to get access to the file contents through a `shapereader` object. Using
    the `shapereader` object, we extract the name (the first item) from each field
    information tuple, and exclude the first field which is always a deletion flag
    field. The rows are loaded by looping the `shapereader` object's `iterRecords`
    method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`from_file`函数内部，我们首先检测文件是否为shapefile格式，然后运行我们的加载程序。该程序开始使用PyShp模块通过`shapereader`对象获取文件内容。使用`shapereader`对象，我们从每个字段信息元组中提取名称（第一个项目），并排除第一个字段，该字段始终是删除标志字段。通过循环`shapereader`对象的`iterRecords`方法来加载行。
- en: Loading geometries is slightly more complicated because we want to perform some
    additional steps. PyShp, like most packages, can format its geometries as GeoJSON
    dictionaries via its shape object's `__geo_interface__` property. Now, remember
    from the earlier *Spatial indexing* section, calculating the individual bounding
    boxes for each individual feature can be costly. One of the benefits of the shapefile
    format is that each shape's bounding box is stored as part of the shapefile format.
    Therefore, we take advantage of the fact that they are already calculated for
    us and stored as a part of the GeoJSON dictionary that we send to initiate our
    `VectorData` class. We create a `getgeoj` function that adds the bounding box
    information to the GeoJSON dictionary if it is available (point shapes for instance,
    do not have a `bbox` attribute) and use it on each shape that we get from the
    `shapereader` object's `iterShapes` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 加载几何形状稍微复杂一些，因为我们想执行一些额外的步骤。PyShp，像大多数包一样，可以通过其shape对象的`__geo_interface__`属性将几何形状格式化为GeoJSON字典。现在，记得从之前的*空间索引*部分，计算每个单独特征的边界框可能很昂贵。shapefile格式的优点之一是每个形状的边界框都作为shapefile格式的一部分存储。因此，我们利用它们已经为我们计算并存储为GeoJSON字典的一部分这一事实，该字典是我们发送以启动我们的`VectorData`类。我们创建一个`getgeoj`函数，如果可用（例如，点形状没有`bbox`属性），则将边界框信息添加到GeoJSON字典中，并使用它来处理我们从`shapereader`对象的`iterShapes`方法获取的每个形状。
- en: Next, the shapefile formats have an optional `.prj` file containing projection
    information, so we also try to read this information if it exists, or default
    to unprojected WGS84 if not. Finally, we have the function return the loaded fields,
    rows, geometries, and projection so our data module can use them to build a `VectorData`
    instance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，shapefile格式有一个可选的`.prj`文件，包含投影信息，因此如果存在，我们也尝试读取此信息，如果不存在，则默认为未投影的WGS84。最后，我们让函数返回加载的字段、行、几何形状和投影，以便我们的数据模块可以使用它们来构建一个`VectorData`实例。
- en: 'Here is the final code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最终的代码：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: GeoJSON
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GeoJSON
- en: GeoJSON is a more recent file format than the shapefile format, due to its simplicity
    it is widely used, especially by web applications. The library we will use to
    read them is `PyGeoj`, created by the author. To install it, in the command line,
    type `C:/Python27/Scripts/pip install pygeoj`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON格式比shapefile格式更新，由于其简单性，它被广泛使用，尤其是在网络应用程序中。我们将使用的库来读取它们是作者创建的`PyGeoj`。要安装它，在命令行中，输入`C:/Python27/Scripts/pip
    install pygeoj`。
- en: To detect GeoJSON files, there is no rule as to what their filename extension
    should be, but it tends to be either `.geojson` or just `.json`. We then load
    the GeoJSON file into a PyGeoj object. The GeoJSON features don't need to have
    all the same fields, so we use a convenience method that gets only the fieldnames
    that are common to all features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测GeoJSON文件，没有关于它们的文件名扩展名的规则，但它们通常为`.geojson`或仅仅是`.json`。然后我们将GeoJSON文件加载到一个PyGeoj对象中。GeoJSON特征不需要具有所有相同的字段，所以我们使用一个方便的方法，只获取所有特征共有的字段名。
- en: 'Rows are loaded by looping the features and accessing the `properties` attribute.
    This PyGeoj object''s geometries consist purely of GeoJSON dictionaries, same
    as our own data structure, so we just load the geometries as is. Finally, we return
    all the loaded information. Refer to the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过循环特征并访问`properties`属性来加载行。这个PyGeoj对象的几何形状纯粹由GeoJSON字典组成，与我们的数据结构相同，所以我们只需按原样加载几何形状。最后，我们返回所有加载的信息。请参考以下代码：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: File format not supported
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持的文件格式
- en: 'Since we do not intend to support any additional file formats for now, we add
    an `else` clause returning an unsupported file format exception if the file path
    didn''t match any of the previous formats:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前不打算支持任何额外的文件格式，如果文件路径与之前任何格式都不匹配，我们添加一个`else`子句，返回一个不支持的文件格式异常：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Saving vector data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存矢量数据
- en: 'To enable saving our vector data back to the file, create a module called `vector/saver.py`.
    At the top of the script, we import the necessary modules:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的矢量数据保存回文件，创建一个名为`vector/saver.py`的模块。在脚本顶部，我们导入必要的模块：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The main purpose of the saver module is a simple `to_file` function, which will
    do the saving for us. We do not allow a CRS projection argument, as that will
    require a way to format projections according to different standards which, to
    my knowledge, can currently only be done using GDAL, which we opted not to use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 保存模块的主要目的是一个简单的`to_file`函数，它将为我们执行保存操作。我们不允许CRS投影参数，因为这将需要一个根据不同标准格式化投影的方法，据我所知，目前只能使用GDAL来完成，而我们选择不使用它。
- en: 'Now, a common difficulty faced when saving files containing text is that you
    must remember to encode your **Unicode** type text (text with fancy non-English
    characters) back into machine-readable byte strings, or if they are Python objects
    such as dates, we want to get their byte-string representation. Therefore, the
    first thing we do is create a quick function that will do this for us, using the
    text encoding argument from the `to_file` function. So far, our code looks like
    this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保存包含文本的文件时遇到的一个常见困难是，你必须记得将你的**Unicode**类型文本（带有花哨的非英语字符的文本）编码回机器可读的字节字符串，或者如果它们是Python对象，如日期，我们希望得到它们的字节字符串表示。因此，我们首先创建一个快速函数来完成这项工作，使用`to_file`函数的文本编码参数。到目前为止，我们的代码如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Shapefile
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状文件
- en: For saving vector data to the shapefile format, once we have created a `shapewriter`
    object, we first want to detect and set all the fields with the correct value
    types. Instead of dealing with potential type mismatches, we just check whether
    all valid values in each field are numeric, and if not, we force to text type.
    In the end, we assign to each field, a field tuple with a cleaned and encoded
    fieldname (shapefiles do not allow names longer than 10 characters or that contain
    spaces), the value type (where *C* stands for text characters and *N* for numbers),
    the maximum text length, and the decimal precision for numbers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将矢量数据保存到形状文件格式，一旦我们创建了`shapewriter`对象，我们首先想要检测并设置所有字段以正确的值类型。为了避免处理潜在的类型不匹配，我们只需检查每个字段中所有有效值是否为数值型，如果不是，则强制转换为文本类型。最后，我们将一个清理并编码的字段名（形状文件不允许名称超过10个字符或包含空格）的字段元组、值类型（其中*C*代表文本字符，*N*代表数字）、最大文本长度以及数字的十进制精度分配给每个字段。
- en: Once this is done, we can start writing our file. Unfortunately, PyShp currently
    has no ready-made way to save geometries directly from GeoJSON dictionaries, so
    we first create a function to do this conversion. Doing this requires making an
    empty PyShp shape instance and setting the correct `shapeType` property. The `points`
    attribute is a continuous list of all coordinate points, which for multigeometries
    is separated at the index positions indicated in the `parts` attribute.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以开始编写我们的文件。不幸的是，PyShp目前没有直接从GeoJSON字典保存几何形状的现成方法，所以我们首先创建一个执行此转换的函数。这样做需要创建一个空的PyShp形状实例并设置正确的`shapeType`属性。`points`属性是所有坐标点的连续列表，对于多几何形状，它在`parts`属性中指示的索引位置处分开。
- en: 'We can then loop all our features, use our function to convert GeoJSON into
    PyShp shape instances, append those to the writer''s `_shapes` list, encode and
    add the feature''s row with the `record` method, and finish up by saving. The
    entire code is shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以遍历所有我们的要素，使用我们的函数将GeoJSON转换为PyShp形状实例，将它们追加到编写者的`_shapes`列表中，使用`record`方法编码并添加要素的行，最后保存。整个代码如下所示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: GeoJSON
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GeoJSON
- en: 'Saving GeoJSON is slightly more straightforward to implement with the PyGeoj
    package. We start by creating a new `geojwriter` object, following which we loop
    all of our features, encode Unicode text to byte strings, add them to the `geojwriter`
    instance, and save once finished:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyGeoj包保存GeoJSON稍微简单一些。我们首先创建一个新的`geojwriter`对象，然后遍历所有我们的要素，将Unicode文本编码为字节字符串，将它们添加到`geojwriter`实例中，完成后保存：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: File format not supported
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持的文件格式
- en: 'Finally, we add an `else` clause to provide a message that the user attempted
    to save to a file format, for which saving is not yet supported:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个 `else` 子句来提供一个消息，说明用户尝试保存到尚未支持保存的文件格式：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Raster data
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栅格数据
- en: 'Now that we have implemented a data structure for loading and saving vector
    data, we can proceed to do the same for raster data. As stated earlier, we will
    be creating three submodules inside our `raster` package: `data`, `loader`, and
    `saver`. To make these accessible from their parent raster package, we need to
    import it in `raster/__init__.py` as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了加载和保存矢量数据的数据结构，我们可以继续为栅格数据做同样的事情。如前所述，我们将在 `raster` 包内创建三个子模块：`data`、`loader`
    和 `saver`。为了使它们可以从其父 `raster` 包中访问，我们需要在 `raster/__init__.py` 中导入它，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A data interface for raster data
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栅格数据的数据接口
- en: 'Raster data has a very different structure that we must accommodate, and we
    begin by making its data interface. The code for this interface will be contained
    in a module of its own inside the raster folder. To create this module now, save
    it as `raster/data.py`. Start it out with a few basic imports, including the loader
    and saver modules that we have not yet created and PIL which we installed in [Chapter
    1](ch01.html "Chapter 1. Preparing to Build Your Own GIS Application"), *Preparing
    to Build Your Own GIS Application*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格数据具有非常不同的结构，我们必须适应，我们首先从其数据接口开始。此接口的代码将包含在栅格文件夹内的一个单独的模块中。要创建此模块，现在将其保存为 `raster/data.py`。从几个基本的导入开始，包括我们尚未创建的加载器和保存器模块，以及我们在第
    1 章（[第 1 章. 准备构建您自己的 GIS 应用程序](ch01.html "Chapter 1. Preparing to Build Your Own
    GIS Application")）中安装的 PIL，*准备构建您自己的 GIS 应用程序*：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The raster data structure
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栅格数据结构
- en: 'A raster consists of one or more grids of data referred to as **bands**. These
    grids and the values in each of their **cells** represent how a piece of information
    flows across space-like pixels in a photograph:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格由一个或多个称为 **波段** 的数据网格组成。这些网格以及它们每个 **单元格** 中的值表示信息如何在照片中类似像素的空间中流动：
- en: '![The raster data structure](img/5407OS_02_02.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![栅格数据结构](img/5407OS_02_02.jpg)'
- en: Given raster data's similarities with imagery data, we take advantage of our
    existing PIL imaging library that we imported earlier and use it for our application's
    raster data structure. Its C-based code makes it fast and memory-efficient, and
    it already contains a lot of the pixel-based raster functionality that we want
    to be able to do eventually.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于栅格数据与影像数据的相似性，我们利用之前导入的现有 PIL 影像库，并将其用于我们应用程序的栅格数据结构。其基于 C 的代码使其运行速度快且内存效率高，并且它已经包含了我们最终想要实现的大多数基于像素的栅格功能。
- en: At the top level, our `RasterData` class contains some raster metadata and one
    or more **Band** layers, which are just wrappers around pixel image data containers.
    When creating a new `RasterData` class, we usually load from a file path. The
    actual loading is outsourced to a loader module we create later, which returns
    a dictionary of various metadata about the raster (`info`), a list of one or more
    bands (`bands`), and the definition of its coordinate reference system (`crs`).
    We can also create a new `RasterData` class from non-spatial data based on a list
    of lists representing a grid or an ordinary image file, in which case it is up
    to us to define its CRS and geospatial metadata (we return to this shortly).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层，我们的 `RasterData` 类包含一些栅格元数据和一个或多个 **Band** 层，这些层只是像素图像数据容器的包装器。当创建一个新的 `RasterData`
    类时，我们通常从文件路径加载。实际的加载工作将外包给稍后创建的加载模块，该模块返回有关栅格的各种元数据字典（`info`）、一个包含一个或多个波段（`bands`）的列表以及其坐标参考系统（`crs`）的定义。我们还可以根据表示网格或普通图像文件的列表列表从非空间数据创建一个新的
    `RasterData` 类，在这种情况下，定义其坐标参考系统（`crs`）和地理空间元数据（我们稍后回到这一点）取决于我们。
- en: The `Band` class is where the actual values are stored. We keep one reference
    to a PIL image (`img`) so that we can use its various imagery processing methods,
    and one reference to the image's pixel access object (`cells`) so we can tinker
    directly with individual pixels. Each pixel is accessed as a `Cell` class instance,
    which provides a convenience method for its row/column position.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Band` 类是实际值存储的地方。我们保留对 PIL 图像（`img`）的一个引用，以便我们可以使用其各种影像处理方法，并保留对图像像素访问对象（`cells`）的一个引用，这样我们就可以直接与单个像素进行交互。每个像素都作为
    `Cell` 类的一个实例来访问，它提供了一个方便的方法来获取其行/列位置。'
- en: 'Look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Positioning the raster in coordinate space
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在坐标空间中定位栅格
- en: 'We are not done yet. While the gridded structure of our raster bands gives
    us a sense of the relative location of each value within the grid, it does not
    say anything about their real-world geographical position in the same way that
    a `Feature` geometry''s coordinates does. This is why we need additional geospatial
    metadata about the raster. To position our values in geographic space, there are
    two ways this can be specified in our `info` metadata dictionary:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。虽然我们的栅格波段的结构网格给我们一个关于每个值在网格中相对位置的感觉，但它并没有说明它们在现实世界中的地理位置，就像`Feature`几何坐标那样。这就是为什么我们需要关于栅格的额外地理空间元数据。为了在地理空间中定位我们的值，我们可以在`info`元数据字典中指定两种方式：
- en: We need to translate one of the cells (`xy_cell`) to a geographic or projected
    coordinate (`xy_geo`) and specify the coordinate width and height of its cells
    (`cellwidth` and `cellheight`) so that we can move and resize the raster. These
    are essentially just components of the transform coefficients described next.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将其中一个单元格（`xy_cell`）转换为地理或投影坐标（`xy_geo`），并指定其单元格的坐标宽度和高度（`cellwidth`和`cellheight`），以便我们可以移动和调整栅格的大小。这些实际上是接下来描述的变换系数的组成部分。
- en: In some cases, such as aerial imagery taken along some arbitrary direction,
    it might not be enough to move and resize the raster. We may also need to rotate
    and possibly skew the raster. To do this, we need a set of affine transform coefficients
    (`transform_ceoffs`), so we can recalculate the position of each and every cell
    to end up with the warped image. This is also known as a **geotransform**.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，例如沿任意方向拍摄的一些航空影像，仅仅移动和调整栅格可能不够。我们可能还需要旋转和可能倾斜栅格。为此，我们需要一组仿射变换系数（`transform_ceoffs`），这样我们就可以重新计算每个单元格的位置，最终得到扭曲的图像。这也被称为**地理变换**。
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is also a third possibility, by using a sample of geocoded points, which
    can then be approximated using a non-linear transformation, but we do not cover
    this method. For more on positioning rasters in coordinate space, check out: [http://www.remotesensing.org/geotiff/spec/geotiff2.6.html](http://www.remotesensing.org/geotiff/spec/geotiff2.6.html).'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有一种第三种可能性，即使用地理编码点的样本，然后可以使用非线性变换来近似，但我们不涉及这种方法。有关在坐标空间中定位栅格的更多信息，请参阅：[http://www.remotesensing.org/geotiff/spec/geotiff2.6.html](http://www.remotesensing.org/geotiff/spec/geotiff2.6.html)。
- en: 'The following diagram illustrates how a set of geotransform coefficients might
    offset, scale, and rotate a raster dataset to position it in coordinate space,
    which usually requires flipping the *y* axis:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了如何通过一组地理变换系数来偏移、缩放和旋转栅格数据集，以便在坐标空间中定位它，这通常需要翻转*y*轴：
- en: '![Positioning the raster in coordinate space](img/5407OS_02_03.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![在坐标空间中定位栅格](img/5407OS_02_03.jpg)'
- en: One last aspect of raster data that should be considered is where in each cell
    the coordinate offsets are anchored; either at the cell center or any of its four
    corners. We store this information as `xy_anchor`. However, as the difference
    is very small, we choose not to do anything with it for our simple application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应考虑栅格数据的一个方面，即每个单元格中坐标偏移的锚定位置；要么在单元格中心，要么在其四个角中的任何一个。我们将此信息存储为`xy_anchor`。然而，由于差异非常小，我们选择不对我们的简单应用进行任何操作。
- en: 'Based on the provided geospatial metadata, we must first calculate the regular
    and inverse transform coefficients (`update_geotransform()`) so that we can map
    back and forth between cell positions and spatial coordinates (`cell_to_geo()`
    and `geo_to_cell()`). With this foundation, we can get further information about
    the bounding box of the raster (`bbox`). Most importantly, we allow repositioning/warping
    the raster (and its nodata mask that we create later) into a new raster that reflects
    its real-world location within a specified bounding box and at a specified width/height
    resolution (`positioned()`). This repositioning is easy to implement by transforming
    from the old to the new coordinate bounding box using PIL''s quad transform. Let''s
    add these functionalities to the `RasterData` structure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据提供的地理空间元数据，我们首先必须计算正则和逆变换系数（`update_geotransform()`），以便我们可以将单元格位置和空间坐标（`cell_to_geo()`和`geo_to_cell()`）相互映射。有了这个基础，我们可以获取有关栅格边界框（`bbox`）的更多信息。最重要的是，我们允许重新定位/扭曲栅格（以及我们稍后创建的nodata掩码）到一个新的栅格，该栅格反映了其在指定边界框内以及指定宽度和高度分辨率下的实际位置。这种重新定位可以通过使用PIL的quad变换从旧坐标边界框转换到新坐标边界框来实现。让我们将这些功能添加到`RasterData`结构中：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Nodata masking
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nodata掩码
- en: 'Sometimes cells in a raster contain missing data, so each `RasterData` class
    will define a `nodata_value` in its `info` metadata dictionary if specified. This
    is important because these `nodata` cells have to be ignored while visualizing
    or performing operations. Therefore, in our data interface, we need to create
    an additional image grid that knows the location of missing values so that we
    can use it with PIL to mask or hide away those values. This mask is accessed as
    a dynamic property that we cache for repeated use. Refer to the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时栅格中的单元格包含缺失数据，因此如果指定，每个`RasterData`类将在其`info`元数据字典中定义一个`nodata_value`。这很重要，因为这些`nodata`单元格在可视化或执行操作时必须被忽略。因此，在我们的数据接口中，我们需要创建一个额外的图像网格，它知道缺失值的位置，这样我们就可以使用PIL来屏蔽或隐藏这些值。这个屏蔽可以通过一个动态属性访问，我们将其缓存以供重复使用。参考以下代码：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Loading raster data
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载栅格数据
- en: 'Now, it is time to add the loading to the `Raster` class. Unfortunately, besides
    GDAL, there are not many independent file format libraries that focus on loading
    geographic raster formats. Nevertheless, we are still able to make a minimal loader
    of the common GeoTIFF file format based on PIL. We initiate the module with some
    imports and save it as `raster/loader.py`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将加载功能添加到`Raster`类中。不幸的是，除了GDAL之外，没有很多独立的文件格式库专注于加载地理栅格格式。尽管如此，我们仍然能够基于PIL制作一个针对常见GeoTIFF文件格式的最小加载器。我们通过一些导入初始化模块，并将其保存为`raster/loader.py`：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main purpose of our loader module is to provide a `from_file` function that
    returns the necessary pieces to our raster data structure. Before we get into
    loading each raster file format, we begin with a function to read metadata from
    the ESRI world file format that sometimes accompany raster files. The world file
    is a very simple text file containing six values defining the affine geotransform
    metadata discussed previously, and its filename extension is either `.wld` or
    a variation on the image file type it accompanies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们加载模块的主要目的是提供一个`from_file`函数，该函数返回必要的组件到我们的栅格数据结构。在我们开始加载每种栅格文件格式之前，我们首先从一个函数开始，该函数用于从有时伴随栅格文件的ESRI世界文件格式中读取元数据。世界文件是一个非常简单的文本文件，包含六个值，定义了之前讨论的仿射地理变换元数据，其文件名扩展名为`.wld`或伴随图像文件类型的变体。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With support for this world file, we can easily allow the loading and saving
    of image-like raster formats with PIL, such as `.png`, `.bmp`, `.gif`, or `.jpg`,
    but we do not do so in this book. The world file also sometimes comes with the
    ESRI ASCII raster format, a simple text file format, that is easy to understand
    and implement.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于支持此世界文件，我们可以轻松地使用PIL加载和保存类似图像的栅格格式，如`.png`、`.bmp`、`.gif`或`.jpg`，但本书中我们不这样做。世界文件有时还附带ESRI
    ASCII栅格格式，这是一种简单的文本文件格式，易于理解和实现。
- en: 'Take a look at the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: GeoTIFF
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GeoTIFF
- en: GeoTIFF is a geographic extension of the flexible TIFF image file format, with
    the only difference being additional geo-specific metadata tags. PIL can read
    TIFF files along with their metadata tags, but once we fully load or access the
    image contents, PIL makes it format-neutral by stripping away any format-specific
    info. Therefore, you must extract the geo tags before you do anything with the
    image. Once extracted, it is up to us to interpret the tag codes, because PIL
    does not know about the GeoTIFF specification. We extract tags relating to the
    geotransform, nodata value, and the name and text-encoded tags of the CRS (there
    are numerous other CRS-specific tags, but it will be too much to deal with all
    of them here). Finally, we split the image into its individual bands in case it
    is a composite RGB raster, and return the info metadata, band tuples, and CRS.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: GeoTIFF是灵活的TIFF图像文件格式的地理扩展，唯一的区别是增加了额外的地理特定元数据标签。PIL可以读取包含元数据标签的TIFF文件，但一旦我们完全加载或访问图像内容，PIL就会通过去除任何格式特定的信息使其格式中立。因此，在处理图像之前，你必须提取地理标签。一旦提取，就由我们来解释标签代码，因为PIL不了解GeoTIFF规范。我们提取与地理变换、无数据值以及CRS（坐标参考系统）的名称和文本编码标签相关的标签（还有许多其他CRS特定的标签，但在这里处理所有这些标签会太多）。最后，如果图像是复合RGB栅格，我们将图像分割成其单独的波段，并返回信息元数据、波段元组以及CRS。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full-GeoTIFF specification can be found online at [http://www.remotesensing.org/geotiff/spec/contents.html](http://www.remotesensing.org/geotiff/spec/contents.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的GeoTIFF规范可以在以下网址在线找到：[http://www.remotesensing.org/geotiff/spec/contents.html](http://www.remotesensing.org/geotiff/spec/contents.html)。
- en: 'Refer to the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: File format not supported
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持的文件格式
- en: 'As with the vector loader, we raise an exception if an attempt to load an unsupported
    raster file format has been made, using the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与矢量加载器类似，如果尝试加载不支持的栅格文件格式，我们将抛出异常，如下所示：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Saving raster data
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存栅格数据
- en: 'Finally, we want to save our raster data back to file, so we create a new module
    called `raster/saver.py`. We start out with some imports as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望将我们的栅格数据保存回文件，因此我们创建了一个名为 `raster/saver.py` 的新模块。我们开始时进行了一些导入，如下所示：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the main `to_file` function, we define a cross-format function to combine
    raster bands into a final image ready to be saved, and a basic method for creating
    the `worldfile` containing geotransform:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `to_file` 函数内部，我们定义了一个跨格式函数，用于将栅格波段组合成最终图像以便保存，以及创建包含地理变换的 `worldfile` 的基本方法：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: GeoTIFF
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GeoTIFF
- en: Next, we allow saving to GeoTIFF using PIL. Until recently, saving GeoTIFF with
    PIL was not possible. This was because PIL had not implemented saving TIFF tags
    of type `float` or `double`, this would lead to errors because most GeoTIFF tags
    are double values. A recent user contribution added the required support for double
    tags, and by the time you read this, PIL's Pillow fork should have hopefully incremented
    to a new stable version 2.8.2.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们允许使用 PIL 保存到 GeoTIFF。直到最近，使用 PIL 保存 GeoTIFF 是不可能的。这是因为 PIL 没有实现保存类型为 `float`
    或 `double` 的 TIFF 标签，这会导致错误，因为大多数 GeoTIFF 标签都是双精度浮点值。最近的一个用户贡献添加了对双精度标签所需的支持，并且在你阅读这篇文章的时候，PIL
    的 Pillow 分支应该已经希望升级到一个新的稳定版本 2.8.2。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If Pillow is still on version 2.8.1, you will have to add this support yourself
    by modifying your PIL package in `site-packages`. After opening PIL''s `TiffImagePlugin.py`
    file, you will see that the `ImageFileDirectory` class has a `save` method starting
    at around line 483\. This method loops through all the provided tags with several
    `if` statements checking for different tag value types. Between the `if` statements
    commented as `untyped data` and `string data`, you must add a new `if` statement
    with the following code for floats and doubles, and remember to save your changes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Pillow 仍然是版本 2.8.1，您将不得不自己通过修改 `site-packages` 中的 PIL 包来添加此支持。在打开 PIL 的 `TiffImagePlugin.py`
    文件后，您会看到 `ImageFileDirectory` 类有一个从大约第 483 行开始的 `save` 方法。此方法通过几个 `if` 语句遍历所有提供的标签，检查不同的标签值类型。在注释为
    `未类型化数据` 和 `字符串数据` 的 `if` 语句之间，您必须添加一个新的 `if` 语句，并使用以下代码为浮点数和双精度浮点数添加，并记得保存您的更改：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The actual saving procedure is implemented by leveraging some less well-known
    features of PIL. In order to save our raster's metadata as tags in the file itself,
    we must refer to PIL's `TiffImagePlugin` module, disable its use of the LibTIFF
    library, and create an empty `ImageFileDirectory` class to hold the tags. Each
    added tag value is set by index setting the tag container and must be followed
    by index setting the tag value type on the container's `tagtype` property.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的保存过程是通过利用 PIL 一些不太为人所知的功能来实现的。为了将我们的栅格元数据作为文件本身的标签保存，我们必须参考 PIL 的 `TiffImagePlugin`
    模块，禁用其对 LibTIFF 库的使用，并创建一个空的 `ImageFileDirectory` 类来保存标签。每个添加的标签值都通过索引设置标签容器，必须在容器上
    `tagtype` 属性的索引设置标签值类型之后设置。
- en: 'Once all the geotransform, nodata, and projection tags are set, we simply combine
    the band images into one and pass the tag container as an extra argument to the
    final `save()` call:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有地理变换、无数据和投影标签都设置好，我们只需将波段图像组合成一个，并将标签容器作为额外参数传递给最终的 `save()` 调用：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: File format not supported
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持的文件格式
- en: 'These are the only raster file formats we allow saving to for now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只允许保存到以下这些栅格文件格式：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'In this chapter, we built the core foundation of our application. In each of
    our `vector` and `raster` folders, we created three new modules that allow us
    to access, edit, and share some popular geographic data formats. Our folder structure
    should, therefore, look something like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了我们应用程序的核心基础。在我们的每个 `vector` 和 `raster` 文件夹中，我们创建了三个新的模块，使我们能够访问、编辑和共享一些流行的地理数据格式。因此，我们的文件夹结构应该看起来像这样：
- en: '![Summary](img/5407OS_02_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![概要](img/5407OS_02_04.jpg)'
- en: This is the minimum we will need for any type of GIS application. We can theoretically,
    at this point, make a minimalistic application focused only on loading and handling
    file formats. In the next chapter, we jump straight into making the visual interface
    application, so we can have a real interactive application up and running as soon
    as possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们任何类型的 GIS 应用程序所需的最小内容。从理论上讲，到目前为止，我们可以创建一个仅关注加载和处理文件格式的最小化应用程序。在下一章中，我们将直接进入制作可视化界面应用程序，以便我们能够尽快拥有一个真正的交互式应用程序。
