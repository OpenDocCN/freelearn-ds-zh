["```py\n> psql py_geoan_cb -c \"create extension pgrouting\"\n\n```", "```py\n>ogr2ogr -a_srs EPSG:3857 -lco \"SCHEMA=geodata\" -lco \"COLUMN_TYPES=type=varchar,type_id=integer\" -nlt MULTILINESTRING -nln ch08_e01_networklines -f PostgreSQL \"PG:host=localhost port=5432 user=pluto dbname=py_geoan_cb password=secret\" geodata/shp/e01_network_lines_3857.shp\n\n```", "```py\nALTER TABLE geodata.ch08_e01_networklines ADD COLUMN source INTEGER;\nALTER TABLE geodata.ch08_e01_networklines ADD COLUMN target INTEGER;\nALTER TABLE geodata.ch08_e01_networklines ADD COLUMN cost DOUBLE PRECISION;\nALTER TABLE geodata.ch08_e01_networklines ADD COLUMN length DOUBLE PRECISION;\nUPDATE geodata.ch08_e01_networklines set length = ST_Length(wkb_geometry);\n\n```", "```py\nSELECT public.pgr_createTopology('geodata.ch08_e01_networklines',\n 0.0001, 'wkb_geometry', 'ogc_fid');\n\n```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    import psycopg2\n    import json\n    from geojson import loads, Feature, FeatureCollection\n\n    db_host = \"localhost\"\n    db_user = \"pluto\"\n    db_passwd = \"secret\"\n    db_database = \"py_geoan_cb\"\n    db_port = \"5432\"\n\n    # connect to DB\n    conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,\n                            password=db_passwd, database=db_database)\n\n    # create a cursor\n    cur = conn.cursor()\n\n    start_x = 1587927.204\n    start_y = 5879726.142\n    end_x = 1587947.304\n    end_y = 5879611.257\n\n    # find the start node id within 1 meter of the given coordinate\n    # used as input in routing query start point\n    start_node_query = \"\"\"\n        SELECT id FROM geodata.ch08_e01_networklines_vertices_pgr AS p\n        WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1);\"\"\"\n\n    # locate the end node id within 1 meter of the given coordinate\n    end_node_query = \"\"\"\n        SELECT id FROM geodata.ch08_e01_networklines_vertices_pgr AS p\n        WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1);\n        \"\"\"\n\n    # get the start node id as an integer\n    cur.execute(start_node_query, (start_x, start_y))\n    sn = int(cur.fetchone()[0])\n\n    # get the end node id as an integer\n    cur.execute(end_node_query, (end_x, end_y))\n    en = int(cur.fetchone()[0])\n\n    # pgRouting query to return our list of segments representing\n    # our shortest path Dijkstra results as GeoJSON\n    # query returns the shortest path between our start and end nodes above\n    # using the python .format string syntax to insert a variable in the query\n    routing_query = '''\n        SELECT seq, id1 AS node, id2 AS edge, ST_Length(wkb_geometry) AS cost,\n               ST_AsGeoJSON(wkb_geometry) AS geoj\n          FROM pgr_dijkstra(\n            'SELECT ogc_fid as id, source, target, st_length(wkb_geometry) as cost\n             FROM geodata.ch08_e01_networklines',\n            {start_node},{end_node}, FALSE, FALSE\n          ) AS dij_route\n          JOIN  geodata.ch08_e01_networklines AS input_network\n          ON dij_route.id2 = input_network.ogc_fid ;\n      '''.format(start_node=sn, end_node=en)\n\n    # run our shortest path query\n    cur.execute(routing_query)\n\n    # get entire query results to work with\n    route_segments = cur.fetchall()\n\n    # empty list to hold each segment for our GeoJSON output\n    route_result = []\n\n    # loop over each segment in the result route segments\n    # create the list for our new GeoJSON\n    for segment in route_segments:\n        geojs = segment[4]\n        geojs_geom = loads(geojs)\n        geojs_feat = Feature(geometry=geojs_geom, properties={'nice': 'route'})\n        route_result.append(geojs_feat)\n\n    # using the geojson module to create our GeoJSON Feature Collection\n    geojs_fc = FeatureCollection(route_result)\n\n    # define the output folder and GeoJSON file name\n    output_geojson_route = \"../geodata/ch08_shortest_path_pgrouting.geojson\"\n\n    # save geojson to a file in our geodata folder\n    def write_geojson():\n        with open(output_geojson_route, \"w\") as geojs_out:\n            geojs_out.write(json.dumps(geojs_fc))\n\n    # run the write function to actually create the GeoJSON file\n    write_geojson()\n\n    # clean up and close database curson and connection\n    cur.close()\n    conn.close()\n    ```", "```py\n>> pip install networkx\n\n```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    import networkx as nx\n    import numpy as np\n    import json\n    from shapely.geometry import asLineString, asMultiPoint\n\n    def get_path(n0, n1):\n        \"\"\"If n0 and n1 are connected nodes in the graph,\n        this function will return an array of point\n        coordinates along the line linking\n        these two nodes.\"\"\"\n\n        return np.array(json.loads(nx_list_subgraph[n0][n1]['Json'])['coordinates'])\n\n    def get_full_path(path):\n        \"\"\"\n        Create numpy array line result\n        :param path: results of nx.shortest_path function\n        :return: coordinate pairs along a path\n        \"\"\"\n        p_list = []\n        curp = None\n        for i in range(len(path)-1):\n            p = get_path(path[i], path[i+1])\n            if curp is None:\n                curp = p\n            if np.sum((p[0]-curp)**2) > np.sum((p[-1]-curp)**2):\n                p = p[::-1, :]\n            p_list.append(p)\n            curp = p[-1]\n        return np.vstack(p_list)\n\n    def write_geojson(outfilename, indata):\n        \"\"\"\n        create GeoGJSOn file\n        :param outfilename: name of output file\n        :param indata: GeoJSON\n        :return: a new GeoJSON file\n        \"\"\"\n\n        with open(outfilename, \"w\") as file_out:\n            file_out.write(json.dumps(indata))\n\n    if __name__ == '__main__':\n\n        # use Networkx to load a Noded shapefile\n        # returns a graph where each node is a coordinate pair\n        # and the edge is the line connecting the two nodes\n\n        nx_load_shp = nx.read_shp(\"../geodata/shp/e01_network_lines_3857.shp\")\n\n        # A graph is not always connected, so we take the largest connected subgraph\n        # by using the connected_component_subgraphs function.\n        nx_list_subgraph = list(nx.connected_component_subgraphs(nx_load_shp.to_undirected()))[0]\n\n        # get all the nodes in the network\n        nx_nodes = np.array(nx_list_subgraph.nodes())\n\n        # output the nodes to a GeoJSON file to view in QGIS\n        network_nodes = asMultiPoint(nx_nodes)\n        write_geojson(\"../geodata/ch08_final_netx_nodes.geojson\",\n                      network_nodes.__geo_interface__)\n\n        # this number represents the nodes position\n        # in the array to identify the node\n        start_node_pos = 30\n        end_node_pos = 21\n\n        # Compute the shortest path. Dijkstra's algorithm.\n        nx_short_path = nx.shortest_path(nx_list_subgraph,\n                                         source=tuple(nx_nodes[start_node_pos]),\n                                         target=tuple(nx_nodes[end_node_pos]),\n                                         weight='distance')\n\n        # create numpy array of coordinates representing result path\n        nx_array_path = get_full_path(nx_short_path)\n\n        # convert numpy array to Shapely Linestring\n        out_shortest_path = asLineString(nx_array_path)\n\n        write_geojson(\"../geodata/ch08_final_netx_sh_path.geojson\",\n                      out_shortest_path.__geo_interface__)\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    import psycopg2\n    import shapefile\n    import json\n    import shapely.geometry as geometry\n    from geojson import loads, Feature, FeatureCollection\n    from shapely.geometry import asShape\n\n    # database connection\n    db_host = \"localhost\"\n    db_user = \"pluto\"\n    db_passwd = \"secret\"\n    db_database = \"py_geoan_cb\"\n    db_port = \"5432\"\n\n    # connect to DB\n    conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,\n                            password=db_passwd, database=db_database)\n    cur = conn.cursor()\n\n    def write_geojson(outfilename, indata):\n        with open(outfilename, \"w\") as geojs_out:\n            geojs_out.write(json.dumps(indata))\n\n    # center point for creating our distance polygons\n    x_start_coord = 1587926.769\n    y_start_coord = 5879726.492\n\n    # query including two variables for the x, y POINT coordinate\n    start_node_query = \"\"\"\n        SELECT id\n        FROM geodata.ch08_e01_networklines_vertices_pgr AS p\n        WHERE ST_DWithin(the_geom,\n          ST_GeomFromText('POINT({0} {1})',3857),1);\n          \"\"\".format(x_start_coord, y_start_coord)\n\n    # get the start node id as an integer\n    # pass the variables\n    cur.execute(start_node_query)\n    start_node_id = int(cur.fetchone()[0])\n\n    combined_result = []\n\n    hallways = shapefile.Reader(\"../geodata/shp/e01_hallways_union_3857.shp\")\n    e01_hallway_features = hallways.shape()\n    e01_hallway_shply = asShape(e01_hallway_features)\n\n    # time in seconds\n    evac_times = [10, 20, 30, 60]\n\n    def generate_evac_polys(start_node_id, evac_times ):\n        \"\"\"\n\n        :param start_node_id: network node id to start from\n        :param evac_times: list of times in seconds\n        :return: none, generates GeoJSON files\n        \"\"\"\n\n        for evac_time in evac_times:\n\n            distance_poly_query = \"\"\"\n                SELECT seq, id1 AS node, cost, ST_AsGeoJSON(the_geom)\n                    FROM pgr_drivingDistance(\n                            'SELECT ogc_fid AS id, source, target,\n                                ST_Length(wkb_geometry)/5000*60*60 AS cost\n                             FROM geodata.ch08_e01_networklines',\n                            {0}, {1}, false, false\n                    ) as ev_dist\n                    JOIN geodata.ch08_e01_networklines_vertices_pgr\n                    AS networklines\n                    ON ev_dist.id1 = networklines.id;\n                \"\"\".format(start_node_id, evac_time)\n\n            cur.execute(distance_poly_query)\n            # get entire query results to work with\n            distance_nodes = cur.fetchall()\n\n            # empty list to hold each segment for our GeoJSON output\n            route_results = []\n\n            # loop over each segment in the result route segments\n            # create the list of our new GeoJSON\n            for dist_node in distance_nodes:\n                sequence = dist_node[0]     # sequence number\n                node = dist_node[1]         # node id\n                cost = dist_node[2]         # cost value\n                geojs = dist_node[3]        # geometry\n                geojs_geom = loads(geojs) # create geojson geom\n                geojs_feat = Feature(geometry=geojs_geom,\n                        properties={'sequence_num': sequence,\n                        'node':node, 'evac_time_sec':cost,\n                        'evac_code': evac_time})\n                # add each point to total including all points\n                combined_result.append(geojs_feat)\n                # add each point for individual evacuation time\n                route_results.append(geojs_geom)\n\n            # geojson module creates GeoJSON Feature Collection\n            geojs_fc = FeatureCollection(route_results)\n\n            # create list of points for each evac time\n            evac_time_pts = [asShape(route_segment) for route_segment in route_results]\n\n            # create MultiPoint from our list of points for evac time\n            point_collection = geometry.MultiPoint(list(evac_time_pts))\n\n            # create our convex hull polyon around evac time points\n            convex_hull_polygon = point_collection.convex_hull\n\n            # intersect convex hull with hallways polygon (ch = convex hull)\n            cvex_hull_intersect = e01_hallway_shply.intersection(convex_hull_polygon)\n\n            # export convex hull intersection to geojson\n            cvex_hull = cvex_hull_intersect.__geo_interface__\n\n            # for each evac time we create a unique GeoJSON polygon\n            output_ply = \"../geodata/ch08-03_dist_poly_\" + str(evac_time) + \".geojson\"\n\n            write_geojson(output_ply, cvex_hull)\n\n            output_geojson_route = \"../geodata/ch08-03_dist_pts_\" + str(evac_time) + \".geojson\"\n\n            # save GeoJSON to a file in our geodata folder\n            write_geojson(output_geojson_route, geojs_fc )\n\n    # create or set of evac GeoJSON polygons based\n    # on location and list of times in seconds\n    generate_evac_polys(start_node_id, evac_times)\n\n    # final result GeoJSON\n    final_res = FeatureCollection(combined_result)\n\n    # write to disk\n    write_geojson(\"../geodata/ch08-03_final_dist_poly.geojson\", final_res)\n\n    # clean up and close database cursor and connection\n    cur.close()\n    conn.close()\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    from shapely.geometry import LineString\n    from shapely.geometry import MultiLineString\n    from scipy.spatial import Voronoi\n    import numpy as np\n\n    class Centerline(object):\n        def __init__(self, inputGEOM, dist=0.5):\n            self.inputGEOM = inputGEOM\n            self.dist = abs(dist)\n\n        def create_centerline(self):\n            \"\"\"\n            Calculates the centerline of a polygon.\n\n            Densifies the border of a polygon which is then represented\n            by a Numpy array of points necessary for creating the\n            Voronoi diagram. Once the diagram is created, the ridges\n            located within the polygon are joined and returned.\n\n            Returns:\n                a MultiLinestring located within the polygon.\n            \"\"\"\n\n            minx = int(min(self.inputGEOM.envelope.exterior.xy[0]))\n            miny = int(min(self.inputGEOM.envelope.exterior.xy[1]))\n\n            border = np.array(self.densify_border(self.inputGEOM, minx, miny))\n\n            vor = Voronoi(border)\n            vertex = vor.vertices\n\n            lst_lines = []\n            for j, ridge in enumerate(vor.ridge_vertices):\n                if -1 not in ridge:\n                    line = LineString([\n                        (vertex[ridge[0]][0] + minx, vertex[ridge[0]][1] + miny),\n                        (vertex[ridge[1]][0] + minx, vertex[ridge[1]][1] + miny)])\n\n                    if line.within(self.inputGEOM) and len(line.coords[0]) > 1:\n                        lst_lines.append(line)\n\n            return MultiLineString(lst_lines)\n\n        def densify_border(self, polygon, minx, miny):\n            \"\"\"\n            Densifies the border of a polygon by a given factor\n            (by default: 0.5).\n\n            The function tests the complexity of the polygons\n            geometry, i.e. does the polygon have holes or not.\n            If the polygon doesn't have any holes, its exterior\n            is extracted and densified by a given factor.\n            If the polygon has holes, the boundary of each hole \n            as well as its exterior is extracted and densified\n            by a given factor.\n\n            Returns:\n                a list of points where each point is \n                represented\n                by a list of its\n                reduced coordinates.\n\n            Example:\n                [[X1, Y1], [X2, Y2], ..., [Xn, Yn]\n            \"\"\"\n\n            if len(polygon.interiors) == 0:\n                exterior_line = LineString(polygon.exterior)\n                points = self.fixed_interpolation(exterior_line, minx, miny)\n\n            else:\n                exterior_line = LineString(polygon.exterior)\n                points = self.fixed_interpolation(exterior_line, minx, miny)\n\n                for j in range(len(polygon.interiors)):\n                    interior_line = LineString(polygon.interiors[j])\n                    points += self.fixed_interpolation(interior_line, minx, miny)\n\n            return points\n\n        def fixed_interpolation(self, line, minx, miny):\n            \"\"\"\n            A helping function which is used in densifying\n            the border of a polygon.\n\n            It places points on the border at the specified \n            distance. By default the distance is 0.5 (meters)\n            which means that the first point will be placed\n            0.5 m from the starting point, the second point\n            will be placed at the distance of 1.0 m from the\n            first point, etc. Naturally, the loop breaks when\n            the summarized distance exceeds\n            the length of the line.\n\n            Returns:\n                a list of points where each point is\n                represented by\n                a list of its reduced coordinates.\n\n            Example:\n                [[X1, Y1], [X2, Y2], ..., [Xn, Yn]\n            \"\"\"\n\n            count = self.dist\n            newline = []\n\n            startpoint = [line.xy[0][0] - minx, line.xy[1][0] - miny]\n            endpoint = [line.xy[0][-1] - minx, line.xy[1][-1] - miny]\n            newline.append(startpoint)\n\n            while count < line.length:\n                point = line.interpolate(count)\n                newline.append([point.x - minx, point.y - miny])\n                count += self.dist\n\n            newline.append(endpoint)\n\n            return newline\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    import json\n    import shapefile\n    from shapely.geometry import asShape, mapping\n    from centerline import Centerline\n\n    def write_geojson(outfilename, indata):\n        with open(outfilename, \"w\") as file_out:\n            file_out.write(json.dumps(indata))\n\n    def create_shapes(shapefile_path):\n        '''\n        Create our Polygon\n        :param shapefile_path: full path to shapefile\n        :return: list of Shapely geometries\n        '''\n        in_ply = shapefile.Reader(shapefile_path)\n        ply_shp = in_ply.shapes()\n\n        out_multi_ply = [asShape(feature) for feature in ply_shp]\n\n        print \"converting to MultiPolygon: \"\n\n        return out_multi_ply\n\n    def generate_centerlines(polygon_shps):\n        '''\n        Create centerlines\n        :param polygon_shps: input polygons\n        :return: dictionary of linestrings\n        '''\n        dct_centerlines = {}\n\n        for i, geom in enumerate(polygon_shps):\n            print \" now running Centerline creation\"\n            center_obj = Centerline(geom, 0.5)\n            center_line_shply_line = center_obj.create_centerline()\n            dct_centerlines[i] = center_line_shply_line\n\n        return dct_centerlines\n\n    def export_center(geojs_file, centerlines):\n        '''\n        Write output to GeoJSON file\n        :param centerlines: input dictionary of linestrings\n        :return: write to GeoJSON file\n        '''\n        with open(geojs_file, 'w') as out:\n\n            for i, key in enumerate(centerlines):\n                geom = centerlines[key]\n                newline = {'id': key, 'geometry': mapping(geom), 'properties': {'id': key}}\n\n                out.write(json.dumps(newline))\n\n    if __name__ == '__main__':\n\n        input_hallways = \"../geodata/shp/e01_hallways_small_3857.shp\"\n        # run our function to create Shapely geometries\n        shply_ply_halls = create_shapes(input_hallways)\n\n        # create our centerlines\n        res_centerlines = generate_centerlines(shply_ply_halls)\n        print \"now creating centerlines geojson\"\n\n        # define output file name and location\n        outgeojs_file = '../geodata/04_centerline_results_final.geojson'\n\n        # write the output GeoJSON file to disk\n        export_center(outgeojs_file, res_centerlines)\n    ```", "```py\n    ogr2ogr -a_srs EPSG:3857 -lco \"SCHEMA=geodata\" -lco \"COLUMN_TYPES=type=varchar,type_id=integer\" -nlt MULTILINESTRING -nln ch08_e01_networklines -f PostgreSQL \"PG:host=localhost port=5432 user=postgres dbname=py_geoan_cb password=air\" geodata/shp/e01_network_lines_3857.shp\n\n    ```", "```py\n    ogr2ogr -a_srs EPSG:3857 -lco \"SCHEMA=geodata\" -lco \"COLUMN_TYPES=type=varchar,type_id=integer\" -nlt MULTILINESTRING -nln ch08_e02_networklines -f PostgreSQL \"PG:host=localhost port=5432 user=postgres dbname=py_geoan_cb password=air\" geodata/shp/e02_network_lines_3857.shp\n\n    ```", "```py\n    ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN source INTEGER;\n    ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN target INTEGER;\n    ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN cost DOUBLE PRECISION;\n    ALTER TABLE geodata.ch08_e01_networklines ADD COLUMN length DOUBLE PRECISION;\n    UPDATE geodata.ch08_e01_networklines set length = ST_Length(wkb_geometry);\n\n    ```", "```py\n    ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN source INTEGER;\n    ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN target INTEGER;\n    ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN cost DOUBLE PRECISION;\n    ALTER TABLE geodata.ch08_e02_networklines ADD COLUMN length DOUBLE PRECISION;\n    UPDATE geodata.ch08_e02_networklines set length = ST_Length(wkb_geometry);\n\n    ```", "```py\n    psql -U username -d py_geoan_cb -a -f pgr_pointtoid3d.sql\n\n    ```", "```py\n    psql -U username -d py_geoan_cb -a -f pgr_createTopology3d.sql\n\n    ```", "```py\n    psql -U username -d py_geoan_cb -a -f indrz_create_3d_networklines.sql\n\n    ```", "```py\n-- if not, go ahead and update\n-- make sure tables dont exist\n\ndrop table if exists geodata.ch08_e01_networklines_routing;\ndrop table if exists geodata.ch08_e02_networklines_routing;\n\n-- convert to 3d coordinates with EPSG:3857\nSELECT ogc_fid, ST_Force_3d(ST_Transform(ST_Force_2D(st_geometryN(wkb_geometry, 1)),3857)) AS wkb_geometry,\n type_id, cost, length, 0 AS source, 0 AS target\n INTO geodata.ch08_e01_networklines_routing\n FROM geodata.ch08_e01_networklines;\n\nSELECT ogc_fid, ST_Force_3d(ST_Transform(ST_Force_2D(st_geometryN(wkb_geometry, 1)),3857)) AS wkb_geometry,\n type_id, cost, length, 0 AS source, 0 AS target\n INTO geodata.ch08_e02_networklines_routing\n FROM geodata.ch08_e02_networklines;\n\n-- fill the 3rd coordinate according to their floor number\nUPDATE geodata.ch08_e01_networklines_routing SET wkb_geometry=ST_Translate(ST_Force_3Dz(wkb_geometry),0,0,1);\nUPDATE geodata.ch08_e02_networklines_routing SET wkb_geometry=ST_Translate(ST_Force_3Dz(wkb_geometry),0,0,2);\n\nUPDATE geodata.ch08_e01_networklines_routing SET length =ST_Length(wkb_geometry);\nUPDATE geodata.ch08_e02_networklines_routing SET length =ST_Length(wkb_geometry);\n\n-- no cost should be 0 or NULL/empty\nUPDATE geodata.ch08_e01_networklines_routing SET cost=1 WHERE cost=0 or cost IS NULL;\nUPDATE geodata.ch08_e02_networklines_routing SET cost=1 WHERE cost=0 or cost IS NULL;\n\n-- update unique ids ogc_fid accordingly\nUPDATE geodata.ch08_e01_networklines_routing SET ogc_fid=ogc_fid+100000;\nUPDATE geodata.ch08_e02_networklines_routing SET ogc_fid=ogc_fid+200000;\n\n-- merge all networkline floors into a single table for routing\nDROP TABLE IF EXISTS geodata.networklines_3857;\nSELECT * INTO geodata.networklines_3857 FROM\n(\n(SELECT ogc_fid, wkb_geometry, length, type_id, length*o1.cost as total_cost,\n 1 as layer FROM geodata.ch08_e01_networklines_routing o1) UNION\n(SELECT ogc_fid, wkb_geometry, length, type_id, length*o2.cost as total_cost,\n 2 as layer FROM geodata.ch08_e02_networklines_routing o2))\nas foo ORDER BY ogc_fid;\n\nCREATE INDEX wkb_geometry_gist_index\n ON geodata.networklines_3857 USING gist (wkb_geometry);\n\nCREATE INDEX ogc_fid_idx\n ON geodata.networklines_3857 USING btree (ogc_fid ASC NULLS LAST);\n\nCREATE INDEX network_layer_idx\n ON geodata.networklines_3857\n USING hash\n (layer);\n\n-- create populate geometry view with info\nSELECT Populate_Geometry_Columns('geodata.networklines_3857'::regclass);\n\n-- update stairs, ramps and elevators to match with the next layer\nUPDATE geodata.networklines_3857 SET wkb_geometry=ST_AddPoint(wkb_geometry,\n ST_EndPoint(ST_Translate(wkb_geometry,0,0,1)))\n WHERE type_id=3 OR type_id=5 OR type_id=7;\n-- remove the second last point\nUPDATE geodata.networklines_3857 SET wkb_geometry=ST_RemovePoint(wkb_geometry,ST_NPoints(wkb_geometry) - 2)\n WHERE type_id=3 OR type_id=5 OR type_id=7;\n\n-- add columns source and target\nALTER TABLE geodata.networklines_3857 add column source integer;\nALTER TABLE geodata.networklines_3857 add column target integer;\nALTER TABLE geodata.networklines_3857 OWNER TO postgres;\n\n-- we dont need the temporary tables any more, delete them\nDROP TABLE IF EXISTS geodata.ch08_e01_networklines_routing;\nDROP TABLE IF EXISTS geodata.ch08_e02_networklines_routing;\n\n-- remove route nodes vertices table if exists\nDROP TABLE IF EXISTS geodata.networklines_3857_vertices_pgr;\n-- building routing network vertices (fills source and target columns in those new tables)\nSELECT public.pgr_createTopology3d('geodata.networklines_3857', 0.0001, 'wkb_geometry', 'ogc_fid');\n\n```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    import psycopg2\n    import json\n    from geojson import loads, Feature, FeatureCollection\n\n    db_host = \"localhost\"\n    db_user = \"pluto\"\n    db_passwd = \"secret\"\n    db_database = \"py_geoan_cb\"\n    db_port = \"5432\"\n\n    # connect to DB\n    conn = psycopg2.connect(host=db_host, user=db_user, port=db_port,\n                            password=db_passwd, database=db_database)\n\n    # create a cursor\n    cur = conn.cursor()\n\n    # define our start and end coordinates in EPSG:3857\n    # set start and end floor level as integer 0,1,2 for example\n    x_start_coord = 1587848.414\n    y_start_coord = 5879564.080\n    start_floor = 2\n\n    x_end_coord = 1588005.547\n    y_end_coord = 5879736.039\n    end_floor = 2\n\n    # find the start node id within 1 meter of the given coordinate\n    # select from correct floor level using 3D Z value\n    # our Z Value is the same as the floor number as an integer\n    # used as input in routing query start point\n    start_node_query = \"\"\"\n        SELECT id FROM geodata.networklines_3857_vertices_pgr AS p\n        WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1)\n        AND ST_Z(the_geom) = %s;\"\"\"\n\n    # locate the end node id within 1 meter of the given coordinate\n    end_node_query = \"\"\"\n        SELECT id FROM geodata.networklines_3857_vertices_pgr AS p\n        WHERE ST_DWithin(the_geom, ST_GeomFromText('POINT(%s %s)',3857), 1)\n        AND ST_Z(the_geom) = %s;\"\"\"\n\n    # run our query and pass in the 3 variables to the query\n    # make sure the order of variables is the same as the \n    # order in your query\n    cur.execute(start_node_query, (x_start_coord, y_start_coord, start_floor))\n    start_node_id = int(cur.fetchone()[0])\n\n    # get the end node id as an integer\n    cur.execute(end_node_query, (x_end_coord, y_end_coord, end_floor))\n    end_node_id = int(cur.fetchone()[0])\n\n    # pgRouting query to return our list of segments representing\n    # our shortest path Dijkstra results as GeoJSON\n    # query returns the shortest path between our start and end nodes above\n    # in 3D traversing floor levels and passing in the layer value = floor\n\n    routing_query = '''\n        SELECT seq, id1 AS node, id2 AS edge, ST_Length(wkb_geometry) AS cost, layer,\n               ST_AsGeoJSON(wkb_geometry) AS geoj\n          FROM pgr_dijkstra(\n            'SELECT ogc_fid as id, source, target, st_length(wkb_geometry) AS cost, layer\n             FROM geodata.networklines_3857',\n            %s, %s, FALSE, FALSE\n          ) AS dij_route\n          JOIN  geodata.networklines_3857 AS input_network\n          ON dij_route.id2 = input_network.ogc_fid ;\n      '''\n\n    # run our shortest path query\n    cur.execute(routing_query, (start_node_id, end_node_id))\n\n    # get entire query results to work with\n    route_segments = cur.fetchall()\n\n    # empty list to hold each segment for our GeoJSON output\n    route_result = []\n\n    # loop over each segment in the result route segments\n    # create the list of our new GeoJSON\n    for segment in route_segments:\n        print segment\n        seg_cost = segment[3]     # cost value\n        layer_level = segment[4]  # floor number\n        geojs = segment[5]        # geojson coordinates\n        geojs_geom = loads(geojs) # load string to geom\n        geojs_feat = Feature(geometry=geojs_geom, properties={'floor': layer_level, 'cost': seg_cost})\n        route_result.append(geojs_feat)\n\n    # using the geojson module to create our GeoJSON Feature Collection\n    geojs_fc = FeatureCollection(route_result)\n\n    # define the output folder and GeoJSON file name\n    output_geojson_route = \"../geodata/ch08_indoor_3d_route.geojson\"\n\n    # save geojson to a file in our geodata folder\n    def write_geojson():\n        with open(output_geojson_route, \"w\") as geojs_out:\n            geojs_out.write(json.dumps(geojs_fc))\n\n    # run the write function to actually create the GeoJSON file\n    write_geojson()\n\n    # clean up and close database curson and connection\n    cur.close()\n    conn.close()\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    def format_walk_time(walk_time):\n        \"\"\"\n        takes argument: float walkTime in seconds\n        returns argument: string time  \"xx minutes xx seconds\"\n        \"\"\"\n        if walk_time > 0.0:\n            return str(int(walk_time / 60.0)) + \" minutes \" + str(int(round(walk_time % 60))) + \" seconds\"\n        else:\n            return \"Walk time is less than zero! Something is wrong\"\n\n    def calc_distance_walktime(rows):\n        \"\"\"\n        calculates distance and walk_time.\n        rows must be an array of linestrings --> a route, retrieved from the DB.\n        rows[5]: type of line (stairs, elevator, etc)\n        rows[3]: cost as length of segment\n        returns a dict with key/value pairs route_length, walk_time\n        \"\"\"\n\n        route_length = 0\n        walk_time = 0\n\n        for row in rows:\n\n            route_length += row[3]\n            #calculate walk time\n            if row[5] == 3 or row[5] == 4:  # stairs\n                walk_speed = 1.2 # meters per second m/s\n            elif row[5] == 5 or row[5] == 6:  # elevator\n                walk_speed = 1.1  # m/s\n            else:\n                walk_speed = 1.39 # m/s\n\n            walk_time += (row[3] / walk_speed)\n\n        length_format = \"%.2f\" % route_length\n        real_time = format_walk_time(walk_time)\n        print {\"route_length\": length_format, \"walk_time\": real_time}\n    ```", "```py\n    {'walk_time': '4 minutes 49 seconds', 'route_length': '397.19'}\n\n    ```"]