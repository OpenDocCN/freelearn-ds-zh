<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Transition with Style"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Transition with Style</h1></div></div></div><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating a single element</li><li class="listitem" style="list-style-type: disc">Animating multiple elements</li><li class="listitem" style="list-style-type: disc">Using ease</li><li class="listitem" style="list-style-type: disc">Using tweening</li><li class="listitem" style="list-style-type: disc">Using transition chaining</li><li class="listitem" style="list-style-type: disc">Using transition filter</li><li class="listitem" style="list-style-type: disc">Listening to transitional events</li><li class="listitem" style="list-style-type: disc">Implementing custom interpolator</li><li class="listitem" style="list-style-type: disc">Working with timer</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Introduction</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>"A <a id="id303" class="indexterm"/>picture is worth a thousand words."</p></blockquote></div><p>This age-old wisdom is arguably one of the most important cornerstones of data visualization. Animation <a id="id304" class="indexterm"/>on the other hand is generated using a series of still images in quick succession. Human eye-and-brain complex, through positive afterimage, phi phenomenon, and beta movement is able to create an illusion of continuous imagery. As Rick Parent put it perfectly in his brilliant work <span class="emphasis"><em>Computer Animation Algorithms and Techniques</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p>Images <a id="id305" class="indexterm"/>can quickly convey a large amount of information because the human visual system is a sophisticated information processor. It follows, then, that moving images have the potential to convey even more information in a short time. Indeed, the human visual system has evolved to provide for survival in an ever-changing world; it is designed to notice and interpret movement.</p><p>-Parent R. 2012</p></blockquote></div><p>This is indeed the main goal of animation used in data visualization projects. In this chapter, we will focus on the mechanics of<a id="id306" class="indexterm"/> <span class="strong"><strong>D3 transition</strong></span>, covering topics from the basics to more advanced ones, such as custom interpolation and timer-based transition. Mastering transition is not only going to add many bells and whistles to your otherwise dry visualization, but will also provide a powerful toolset to your visualization and otherwise hard-to-visualize attributes, such as trending and differences.</p><div class="section" title="What is Transition?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec100"/>What is Transition?</h2></div></div></div><p>D3 transition<a id="id307" class="indexterm"/> offers the ability to create computer animation with HTML and SVG elements on a web page. D3 transition implements an animation called<a id="id308" class="indexterm"/> <span class="strong"><strong>Interpolation-based Animation</strong></span>. Computer's are especially well equipped for value interpolation, and therefore, most of the computer animations are interpolation-based. As its name suggests, the foundation for such animation capability is value interpolation.</p><p>If you recall, we have already covered D3 interpolators and interpolation functions in detail in <a class="link" href="ch04.html" title="Chapter 4. Tipping the Scales">Chapter 4</a>, <span class="emphasis"><em>Tipping the Scales</em></span>. Transition is built on top of interpolation and scales to provide the ability to change values over time, which produces animation. Each transition can be defined using a start and end value (also called <span class="strong"><strong>key frames</strong></span>
<a id="id309" class="indexterm"/> in animation), while different algorithms and interpolators will fill in the intermediate values frame-by-frame (also called "in-betweening" or simply "tweening"). At the first glance, if you are not already familiar with animation algorithms and techniques, this seems to be a somewhat less controlled way of creating an animation. However, it is quite the opposite in reality; interpolation-based transitions can provide direct and specific expectations about the motion produced down to each and every frame, thus offering tremendous control to the animator with simplicity. In fact, D3 transition API is so well-designed that, in most cases, only a couple of lines of code are enough to implement animations you need in a data visualization project. Now, let's get our hands dirty and try out some transitions to further improve our understanding on this topic.</p></div></div></div>
<div class="section" title="Animating a single element"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Animating a single element</h1></div></div></div><p>In this recipe, we will first take a look at the simplest case of transition—interpolating attributes on a single element over time to produce a simple animation.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec101"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec102"/>How to do it...</h2></div></div></div><p>The code necessary to <a id="id310" class="indexterm"/>perform this simple transition is extremely short; good news for any animator:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var body = d3.select("body"), 
        duration = 5000;

    body.append("div") // &lt;-A
            .classed("box", true)
            .style("background-color", "#e9967a") // &lt;-B
        .<span class="strong"><strong>transition() // &lt;-C</strong></span>
<span class="strong"><strong>        .duration(duration) // &lt;-D</strong></span>
            .style("background-color", "#add8e6") // &lt;-E
            .style("margin-left", "600px") // &lt;-F
            .style("width", "100px")
            .style("height", "100px");
&lt;/script&gt; </pre></div><p>This code produces a moving, shrinking, and color-changing square, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/2162OS_06_01.jpg" alt="How to do it..."/><div class="caption"><p>Single element transition</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec103"/>How it works...</h2></div></div></div><p>You might be surprised to see that the extra code we have added to enable this animation is only on line <code class="literal">C</code> and <code class="literal">D</code>:</p><div class="informalexample"><pre class="programlisting">    body.append("div") // &lt;-A
            .classed("box", true)
            .style("background-color", "#e9967a") // &lt;-B
            .<span class="strong"><strong>transition() // &lt;-C</strong></span>
<span class="strong"><strong>            .duration(duration) // &lt;-D</strong></span>
</pre></div><p>First on<a id="id311" class="indexterm"/> line <code class="literal">C</code>, we call the <code class="literal">d3.selection.transition</code> function to define a transition. Then, the <code class="literal">transition</code> function returns a transition-bound selection that still represents the same element(s) in the current selection. But now, it is equipped with additional functions and allows further customization of the transitional behavior. Line <code class="literal">C</code> returns a transition-bound selection of the <code class="literal">div</code> element we created on line <code class="literal">A</code>.</p><p>On line <code class="literal">D</code>, we set the duration of the transition to <code class="literal">5000</code> milliseconds using the <code class="literal">duration()</code> function. This <a id="id312" class="indexterm"/>function also returns the current transition-bound selection, thus allowing function chaining. As we have mentioned at the start of this chapter, interpolation-based animations usually only require specifying the start and end values while letting interpolators and algorithms fill the intermediate values over time. D3 transition treats all values set before calling the <code class="literal">transition</code> function as start values, with values set after the <code class="literal">transition</code> function call as end values. Hence in our example:</p><div class="informalexample"><pre class="programlisting">.style("background-color", "#e9967a") // &lt;-B</pre></div><p>The <code class="literal">background-color</code> style defined on line <code class="literal">B</code> is treated as the start value for transition. All styles set in the following lines are treated as end values:</p><div class="informalexample"><pre class="programlisting">.style("background-color", "#add8e6") // &lt;-E
.style("margin-left", "600px") // &lt;-F
.style("width", "100px")
.style("height", "100px");</pre></div><p>At this point, you might be asking, <span class="emphasis"><em>why these start and end values are not symmetric?</em></span>. D3 transition does not require every interpolated value to have explicit start and end values. If the start value is missing, then it will try to use the computed style, and if the end value is missing then the value will be treated as a constant. Once the transition starts, D3 will automatically pick the most suitable registered interpolator for each value. In our example, an RGB color interpolator will be used in line <code class="literal">E</code>, while a string interpolator—which internally uses number interpolators to interpolate embedded numbers—will be used for the rest of the style values. Here we will list the interpolated style values with their start and end values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">background-color</code>: The start value <code class="literal">#e9967a</code> is greater than end value <code class="literal">#add8e6</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">margin-left</code>: The start value is a computed style and is greater than end value <code class="literal">600px</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>: The start value<a id="id313" class="indexterm"/> is a computed style and it's greater than the end value <code class="literal">100px</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: The start value is a computed style and greater than the end value <code class="literal">100px</code></li></ul></div></div></div>
<div class="section" title="Animating multiple elements"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Animating multiple elements</h1></div></div></div><p>A more elaborate data<a id="id314" class="indexterm"/> visualization requires animating multiple elements instead of a single element, as demonstrated in the previous recipe. More importantly, these transitions often need to be driven by data and coordinated with other elements within the same visualization. In this recipe, we will see how a data-driven multielement transition can be created to generate a moving bar chart. New bars are added over time while the chart shifts from right to left with a smooth transition.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec105"/>How to do it...</h2></div></div></div><p>As expected, this recipe is slightly larger than the previous one, however, not by that much. Let's take a look at the code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var id= 0, 
        data = [], 
        duration = 500, 
        chartHeight = 100, 
        chartWidth = 680;

for(var i = 0; i &lt; 20; i++){ 
    push(data);   
}

    function render(data) {
        var selection = d3.select("body")
                .selectAll("div.v-bar")
<span class="strong"><strong>                .data(data, function(d){return d.id;}); // &lt;-A</strong></span>

        // enter
        selection.enter()
                .append("div")
                    .attr("class", "v-bar")
                    .style("position", "fixed")
<span class="strong"><strong>                    .style("top", chartHeight + "px")</strong></span>
<span class="strong"><strong>                    .style("left", function(d, i){</strong></span>
<span class="strong"><strong>                        return barLeft(i+1) + "px"; // &lt;-B</strong></span>
<span class="strong"><strong>                    })</strong></span>
<span class="strong"><strong>                    .style("height", "0px") // &lt;-C</strong></span>
                .append("span");

        // update
        selection
<span class="strong"><strong>            .transition().duration(duration) // &lt;-D</strong></span>
<span class="strong"><strong>                .style("top", function (d) { </strong></span>
<span class="strong"><strong>                    return chartHeight - barHeight(d) + "px"; </strong></span>
<span class="strong"><strong>                })</strong></span>
<span class="strong"><strong>                .style("left", function(d, i){</strong></span>
<span class="strong"><strong>                    return barLeft(i) + "px";</strong></span>
<span class="strong"><strong>                })</strong></span>
<span class="strong"><strong>                .style("height", function (d) { </strong></span>
<span class="strong"><strong>                    return barHeight(d) + "px"; </strong></span>
<span class="strong"><strong>                })</strong></span>
                .select("span")
                    .text(function (d) {return d.value;});

        // exit
        selection.exit()
<span class="strong"><strong>                .transition().duration(duration) // &lt;-E</strong></span>
<span class="strong"><strong>                .style("left", function(d, i){</strong></span>
<span class="strong"><strong>                    return barLeft(-1) + "px"; //&lt;-F</strong></span>
<span class="strong"><strong>                })</strong></span>
<span class="strong"><strong>                .remove(); // &lt;-G</strong></span>
    }

<span class="strong"><strong>    function push(data) {</strong></span>
<span class="strong"><strong>        data.push({</strong></span>
<span class="strong"><strong>            id: ++id, </strong></span>
<span class="strong"><strong>            value: Math.round(Math.random() * chartHeight)</strong></span>
<span class="strong"><strong>        });</strong></span>
<span class="strong"><strong>    }</strong></span>
    
<span class="strong"><strong>function barLeft(i) {</strong></span>
<span class="strong"><strong>    // start bar position is i * (barWidth + gap)</strong></span>
<span class="strong"><strong>        return i * (30 + 2);</strong></span>
<span class="strong"><strong>    }</strong></span>

<span class="strong"><strong>    function barHeight(d) {</strong></span>
<span class="strong"><strong>        return d.value;</strong></span>
<span class="strong"><strong>    }</strong></span>

    setInterval(function () {
        data.shift();
        push(data);
        render(data);
    }, 2000);

    render(data);

    d3.select("body")
       .append("div")
           .attr("class", "baseline")
           .style("position", "fixed")
           .style("top", chartHeight + "px")
           .style("left", "0px")
           .style("width", chartWidth + "px");
&lt;/script&gt;</pre></div><p>The preceding code<a id="id315" class="indexterm"/> generates a sliding bar chart in your web browser, as shown in the following screenshots:</p><div class="mediaobject"><img src="graphics/2162OS_06_02.jpg" alt="How to do it..."/><div class="caption"><p>Sliding bar chart</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec106"/>How it works...</h2></div></div></div><p>On the surface, this <a id="id316" class="indexterm"/>example seems to be quite complex with complicated effects. Every second a new bar needs to be created and animated while the rest of the bars need to slide over precisely. The beauty of D3 set-oriented functional API is that it works exactly the same way no matter how many elements you are manipulating; therefore, once you understand the mechanics, you will realize this recipe is not so much different than the previous one.</p><p>First step, we created a data-bound selection for a number of vertical bars (on line <code class="literal">A</code>), which can then be used in a classic enter-update-exit D3 pattern:</p><div class="informalexample"><pre class="programlisting">var selection = d3.select("body")
                .selectAll("div.v-bar")
                .data(data, function(d){return d.id;}); // &lt;-A</pre></div><p>One thing we have not touched so far is the second parameter in the <code class="literal">d3.selection.data</code> function. Here, we know that this function is called an <span class="strong"><strong>object-identity function</strong></span>. The<a id="id317" class="indexterm"/> purpose of using this function is to provide object constancy. What it means in simple terms is that we want the binding between data and visual element to be stable. In order to achieve object constancy, each datum needs to have a unique identifier. Once the ID is provided, D3 will ensure if a <code class="literal">div</code> element is bound to <code class="literal">{id: 3, value: 45}</code>. Then, the next time when the update selection is computed, the same <code class="literal">div</code> element will be used for the datum with the same <code class="literal">id</code>, though this time the value might get changed, for example, <code class="literal">{id: 3, value: 12}</code>. Object constancy is crucial in this recipe; without object constancy, the sliding effect will not work.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>If you are interested to know more about object constancy, please check this excellent writing by Mike Bostock, the creator of D3 at the following link:</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>
<a class="ulink" href="http://bost.ocks.org/mike/constancy/">http://bost.ocks.org/mike/constancy/</a>
</p></div></div><p>The second step is to <a id="id318" class="indexterm"/>create these vertical bars with the <code class="literal">d3.selection.enter</code> function and compute the <code class="literal">left</code> position for each bar based on the index number (see line <code class="literal">B</code>):</p><div class="informalexample"><pre class="programlisting">        // enter
        selection.enter()
                .append("div")
                    .attr("class", "v-bar")
                    .style("position", "fixed")
                    .style("top", chartHeight + "px")
                    .style("left", function(d, i){
                        return barLeft(i+1) + "px"; // &lt;-B
                    })
                    .style("height", "0px") // &lt;-C
                .append("span");</pre></div><p>Another point worth mentioning here is that in the <code class="literal">enter</code> section, we have not called transition yet, which means any value we specify here will be used as the start value in a transition. If you notice on line <code class="literal">C</code>, bar <code class="literal">height</code> is set to <code class="literal">0px</code>. This enables the animation of bars growing from zero height to the target <code class="literal">height</code>. At the same time, the same logic is applied to the <code class="literal">left</code> position of the bar (see line <code class="literal">B</code>) and was set to <code class="literal">barLeft(i+1)</code>, thus enabling the sliding transition we desired.</p><div class="informalexample"><pre class="programlisting">        // update
        selection
            .transition().duration(duration) // &lt;-D
                .style("top", function (d) { 
                    return chartHeight - barHeight(d) + "px"; 
                })
                .style("left", function(d, i){
                    return barLeft(i) + "px";
                })
                .style("height", function (d) { 
                    return barHeight(d) + "px"; 
                })
                .select("span")
                    .text(function (d) {return d.value;});</pre></div><p>After completing the <code class="literal">enter</code> section, now we can take care of the <code class="literal">update</code> section, where the transition is defined. First of all, we want to introduce transition for all updates, therefore, we invoke the <code class="literal">transition</code> function before any style change is applied (see line <code class="literal">D</code>). Once the transition-bound selection is created, we applied the following style transitions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"top"</code>: <code class="literal">chartHeight + "px" &gt; chartHeight - barHeight(d)+"px"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">"left"</code>: <code class="literal">barLeft(i+1) + "px" &gt; barLeft(i) + "px"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">"height"</code>: <code class="literal">"0px" &gt; barHeight(d) + "px"</code></li></ul></div><p>The aforementioned <a id="id319" class="indexterm"/>three style transitions are all you need to do to handle new bars as well as every existing bar and their sliding effect. Finally, the last case we need to handle here is the <code class="literal">exit</code> case, when a bar is no longer needed. So, we want to keep the number of bars constant on the page. This is handled in the <code class="literal">exit</code> section:</p><div class="informalexample"><pre class="programlisting">        // exit
        selection.exit()
                .transition().duration(duration) // &lt;-E
                .style("left", function(d, i){
                    return barLeft(-1) + "px"; // &lt;-F
                })
                .remove(); // &lt;-G</pre></div><p>So far in this book, prior to this chapter, we have always called the <code class="literal">remove()</code> function<a id="id320" class="indexterm"/> immediately after the <code class="literal">d3.selection.exit</code> function. This immediately removes the elements that are no longer needed. In fact, the <code class="literal">exit()</code> function<a id="id321" class="indexterm"/> also returns a selection, and therefore, can be animated before calling the <code class="literal">remove()</code> function. This is exactly what we did here, starting a transition on line <code class="literal">E</code> using the <code class="literal">exit</code> selection; then we animated the left value with the following transition change:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">left</code>: <code class="literal">barLeft(i) + "px" &gt; barLeft(i-1) + "px"</code></li></ul></div><p>Since we are always removing the left-most bar, this transition moves the bar left and out of the SVG canvas, then removes it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The <code class="literal">exit</code> transition is not necessarily limited to simple transitions, such as the one we have shown in this recipe. In some visualization, it could be as elaborate as the <code class="literal">update</code> transition.</p></div></div><p>Once the <code class="literal">render</code> function is in place with the defined transition, all that is left is to simply update the data and re-render our bar chart every second using the <code class="literal">setInterval</code> function. Now this<a id="id322" class="indexterm"/> completes our example.</p></div></div>
<div class="section" title="Using ease"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Using ease</h1></div></div></div><p>Transition can be thought of as a function of time. It is a function that maps time progression into numeric value progression, which then results in object motion (if the numeric value is used for positioning) or morphing (if the value is used to describe other visual attributes). Time always travels at a constant pace; in other words time progression is uniform (unless you are doing visualization near a black hole of course), however, the resulting value progression does not need to be uniform. <span class="strong"><strong>Easing</strong></span> <a id="id323" class="indexterm"/>is a standard technique to provide flexibility and control to this kind of mapping. When a transition generates a uniform value progression, it is called <a id="id324" class="indexterm"/>
<span class="strong"><strong>linear</strong></span> <span class="strong"><strong>easing</strong></span>. D3 provides support for different types of easing capabilities, and in this recipe, we will explore different built-in D3 easing functions, as well as how to implement custom easing functions with D3 transition.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec107"/>Getting Ready</h2></div></div></div><p>Open your local copy of the <a id="id325" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec108"/>How to do it...</h2></div></div></div><p>In the following code example, we will demonstrate how transition easing can be customized on an element-by-element basis:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
<span class="strong"><strong>    var data = [ // &lt;-A</strong></span>
<span class="strong"><strong>            "linear", "cubic", "cubic-in-out", </strong></span>
<span class="strong"><strong>            "sin", "sin-out", "exp", "circle", "back", </strong></span>
<span class="strong"><strong>            "bounce",</strong></span>
<span class="strong"><strong>            function(t){ // &lt;-B</strong></span>
<span class="strong"><strong>                return t * t;</strong></span>
<span class="strong"><strong>            }</strong></span>
<span class="strong"><strong>        ],</strong></span>
        colors = d3.scale.category10();

    d3.select("body").selectAll("div")
<span class="strong"><strong>            .data(data) // &lt;-C</strong></span>
        .enter()
        .append("div")
            .attr("class", "fixed-cell")
            .style("top", function (d, i) {
                return i * 40 + "px";
            })
            .style("background-color", function (d, i) {
                return colors(i);
            })
            .style("color", "white")
            .style("left", "500px")
            .text(function (d) {
                if(typeof d === 'function') return "custom";
                return d;
            });

<span class="strong"><strong>    d3.selectAll("div").each(function(d){</strong></span>
<span class="strong"><strong>        d3.select(this)</strong></span>
<span class="strong"><strong>            .transition().ease(d) // &lt;-D</strong></span>
<span class="strong"><strong>            .duration(1500)</strong></span>
<span class="strong"><strong>            .style("left", "10px");</strong></span>
<span class="strong"><strong>    });</strong></span>
&lt;/script&gt;</pre></div><p>The preceding code<a id="id326" class="indexterm"/> produces a set of moving boxes with different easing effects. The following screenshot is captured at the time the easing effect takes place:</p><div class="mediaobject"><img src="graphics/2162OS_06_03.jpg" alt="How to do it..."/><div class="caption"><p>Different easing effects</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec109"/>How it works...</h2></div></div></div><p>In this recipe, we have<a id="id327" class="indexterm"/> shown a number of different built-in D3 ease functions and their effects on transition. Let's take a look at how it is done. First, we have created an array to store different ease modes we want to demonstrate:</p><div class="informalexample"><pre class="programlisting">var data = [ // &lt;-A
        "linear", 
          "cubic", 
          "cubic-in-out", 
        "sin", 
          "exp", 
          "circle", 
          "back", 
        "bounce",
        function(t){ // &lt;-B
            return t * t;
        }
        ]</pre></div><p>While all the built-in ease functions are defined simply using their name, the last element of this array is a custom easing function<a id="id328" class="indexterm"/> (<span class="strong"><strong>quadric easing</strong></span>). Then afterwards, a set of <code class="literal">div</code> elements created using this data array and a transition with different easing functions was created for each of the <code class="literal">div</code> element, respectively, moving them from <code class="literal">("left", "500px")</code> to <code class="literal">("left", "10px")</code>.</p><div class="informalexample"><pre class="programlisting">d3.selectAll("div").each(function(d){
        d3.select(this)
            .transition().ease(d) // &lt;-D
            .duration(1500)
            .style("left", "10px");
    });</pre></div><p>At this point, you might be asking, <span class="emphasis"><em>Why did we not just specify easing using a function as we normally would have done for any other D3 attributes?</em></span>
</p><div class="informalexample"><pre class="programlisting">    .transition().ease(function(d){return d;}) // does not work
    .duration(1500)
    .style("left", "10px");</pre></div><p>The reason is that it does not work on the<a id="id329" class="indexterm"/> <code class="literal">ease()</code> function. What we have shown on line <code class="literal">D</code> is a workaround of this limitation, though in real-world projects it is fairly rare that you will need to customize easing behavior on a per-element basis.</p><div class="blockquote"><blockquote class="blockquote"><p>Note that it is not possible to customize the easing function per-element or per-attribute;</p><p>D3 Wiki (2013, August)</p></blockquote></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>Another way to get around this limitation is by using custom tweening, which we will cover in the next recipe.</p></div></div><p>As seen on line <code class="literal">D</code>, <a id="id330" class="indexterm"/>specifying different ease function for D3 transition is very straight forward; all you need to do is call the <code class="literal">ease()</code> function on a transition-bound selection. If the pass-in parameter is a string, then D3 will try to find the matching function using the name; if not found it will default to <span class="strong"><strong>linear</strong></span>. On top of named built-in ease functions, D3 also provides ease mode modifiers that you can combine with any ease function to achieve additional effects, for example, <span class="strong"><strong>sin-out</strong></span> or <span class="strong"><strong>quad-out-in</strong></span>. Available <a id="id331" class="indexterm"/>ease mode modifiers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>in</strong></span>: default</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>out</strong></span>: reversed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>in-out</strong></span>: reflected</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>out-in</strong></span>: reversed and reflected</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>The default ease effect used by D3 is <span class="strong"><strong>cubic-in-out</strong></span>.</p><p>For the list of supported D3 ease functions please refer to the following link:</p><p>
<a class="ulink" href="https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease">https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease</a>
</p></div></div><p>When a custom ease function is used, the function is expected to take the current parametric time value as its parameter in the range of <code class="literal">[0, 1]</code>.</p><div class="informalexample"><pre class="programlisting">function(t){ // &lt;-B
  return t * t;
}</pre></div><p>In our example, we <a id="id332" class="indexterm"/>have implemented a simple quadric easing function, which is actually available as a built-in D3 ease function, and is named as <span class="strong"><strong>quad</strong></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>For more information on easing and Penner's equations (most of the modern JavaScript framework implementations including D3 and jQuery) check out the following link:</p><p>
<a class="ulink" href="http://www.robertpenner.com/easing/">http://www.robertpenner.com/easing/</a>
</p></div></div></div></div>
<div class="section" title="Using tweening"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Using tweening</h1></div></div></div><p>
<span class="strong"><strong>Tween</strong></span>
<a id="id333" class="indexterm"/> comes from the word "inbetween", which is a common practice performed in traditional animation where after key frames were created by the master animator, less experienced animators were used to generate frames in between the key frames. This phrase is borrowed in modern computer-generated animation and it refers to the technique or algorithm controlling how the "inbetween" frames are generated. In this recipe, we will examine how the D3 transition supports tweening.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec110"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec111"/>How to do it...</h2></div></div></div><p>In the following code example, we will create a custom tweening function to animate a button label through nine <a id="id334" class="indexterm"/>discrete integral numbers:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var body = d3.select("body"), duration = 5000;
    
    body.append("div").append("input")
        .attr("type", "button")
        .attr("class", "countdown")
        .attr("value", "0")
        .style("width", "150px")
        .transition().duration(duration).ease("linear")
            .style("width", "400px")
            .attr("value", "9");
    
    body.append("div").append("input")
        .attr("type", "button")
        .attr("class", "countdown")
        .attr("value", "0")
<span class="strong"><strong>        .transition().duration(duration).ease("linear")</strong></span>
<span class="strong"><strong>            .styleTween("width", widthTween) // &lt;- A</strong></span>
<span class="strong"><strong>            .attrTween("value", valueTween); // &lt;- B</strong></span>
            
            
<span class="strong"><strong>    function widthTween(a){</strong></span>
<span class="strong"><strong>        var interpolate = d3.scale.quantize()</strong></span>
<span class="strong"><strong>            .domain([0, 1])</strong></span>
<span class="strong"><strong>            .range([150, 200, 250, 350, 400]);</strong></span>
    
<span class="strong"><strong>        return function(t){</strong></span>
<span class="strong"><strong>            return interpolate(t) + "px";</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>    }</strong></span>
    
<span class="strong"><strong>    function valueTween(){</strong></span>
<span class="strong"><strong>        var interpolate = d3.scale.quantize() // &lt;-C</strong></span>
<span class="strong"><strong>            .domain([0, 1])</strong></span>
<span class="strong"><strong>            .range([1, 2, 3, 4, 5, 6, 7, 8, 9]);</strong></span>
    
<span class="strong"><strong>        return function(t){ // &lt;-D</strong></span>
<span class="strong"><strong>            return interpolate(t);</strong></span>
<span class="strong"><strong>        };</strong></span>
    }        
&lt;/script&gt;</pre></div><p>The preceding code generates two buttons morphing at a very different rate, and the following screenshot is taken while this process is going on:</p><div class="mediaobject"><img src="graphics/2162OS_06_04.jpg" alt="How to do it..."/><div class="caption"><p>Tweening</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec112"/>How it works...</h2></div></div></div><p>In this recipe, the first<a id="id335" class="indexterm"/> button was created using simple transition with linear easing:</p><div class="informalexample"><pre class="programlisting">body.append("div").append("input")
        .attr("type", "button")
        .attr("class", "countdown")
        .attr("value", "0")
        .style("width", "150px")
        .transition().duration(duration).ease("linear")
            .style("width", "400px")
            .attr("value", "9");</pre></div><p>The transition changes the button's width from <code class="literal">"150px"</code> to <code class="literal">"400px"</code>, while changing its value from <code class="literal">"0"</code> to <code class="literal">"9"</code>. As expected, this transition simply relies on continuous linear interpolation of these values using D3 string interpolator. In comparison, the second button has the effect of changing these values in chunks. Moving from 1 to 2, then to 3, and so on up to 9. This is achieved using D3 tweening support with <code class="literal">attrTween</code> and <code class="literal">styleTween</code> functions. Let's first take a look at how the button value tweening works:</p><div class="informalexample"><pre class="programlisting">.transition().duration(duration).ease("linear")
            .styleTween("width", widthTween) // &lt;- A
            .attrTween("value", valueTween); // &lt;- B</pre></div><p>In the preceding code snippet, we can see that instead of setting the end value for the value attribute as we have done in the case of the first button, we use <code class="literal">attrTween</code> function and offered a tweening function <code class="literal">valueTween</code>, which is implemented as the following:</p><div class="informalexample"><pre class="programlisting">function valueTween(){
    var interpolate = d3.scale.quantize() // &lt;-C
        .domain([0, 1])
        .range([1, 2, 3, 4, 5, 6, 7, 8, 9]);
        
    return function(t){ // &lt;-D
        return interpolate(t);
    };
}        </pre></div><p>In D3, a tween <a id="id336" class="indexterm"/>function is expected to be a factory function, which constructs the actual function that will be used to perform the tweening. In this case, we have defined a <code class="literal">quantize</code> scale that maps the domain <code class="literal">[0, 1]</code> to a discrete integral range of <code class="literal">[1, 9]</code>, on line <code class="literal">C</code>. The actual tweening function defined on line <code class="literal">D</code> simply interpolates the parametric time value using the quantize scale which generates the jumping integer effect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Quantize scales are a variant of linear scale with a discrete range rather than continuous. For more information on quantize scales, please visit the following link:</p><p>
<a class="ulink" href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize">https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize</a>
</p></div></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec113"/>There's more...</h2></div></div></div><p>At this point we have touched upon all three concepts related to transition: ease, tween, and interpolation. Typically, D3 transition is defined and driven through all the three levels shown in the following sequence diagram:</p><div class="mediaobject"><img src="graphics/2162OS_06_05.jpg" alt="There's more..."/><div class="caption"><p>Drivers of transition</p></div></div><p>As we have shown through multiple recipes, D3 transition supports customization in all three levels. This gives us tremendous flexibility to customize the transition behavior exactly the way we want.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>Though custom tween is usually implemented using interpolation, there is no limit to what you can do in your own tween function. It is entirely possible to generate custom tween without using D3 interpolator at all.</p></div></div><p>We used linear easing in this recipe to highlight the effect of tweening, however, D3 fully supports <a id="id337" class="indexterm"/>
<span class="strong"><strong>eased tweening</strong></span>, meaning that you can combine any of the ease functions we have demonstrated in the previous recipe with your custom tween to generate even more complex transition effects.</p></div></div>
<div class="section" title="Using transition chaining"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Using transition chaining</h1></div></div></div><p>The first four recipes in this chapter are focused on single transition controls in D3, including custom easing and tweening functions. However, sometimes regardless of how much easing or tweening you do, a single transition is just not enough, for instance, you want to simulate teleporting a <code class="literal">div</code> element by first squeezing the <code class="literal">div</code> element into a beam, then passing the beam to a different position on the web page, and finally restoring the <code class="literal">div</code> to its original size. In this recipe, we will see exactly how this type of transition can be achieved using <a id="id338" class="indexterm"/>
<span class="strong"><strong>transition chaining</strong></span>.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec115"/>How to do it...</h2></div></div></div><p>Our simple teleportation <a id="id339" class="indexterm"/>transition code is surprisingly short:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var body = d3.select("body");
        
<span class="strong"><strong>    function teleport(s){</strong></span>
<span class="strong"><strong>        s.transition().duration(300) // &lt;-A</strong></span>
<span class="strong"><strong>            .style("width", "200px")</strong></span>
<span class="strong"><strong>            .style("height", "1px")</strong></span>
<span class="strong"><strong>        .transition().duration(100) // &lt;-B</strong></span>
<span class="strong"><strong>            .style("left", "600px")</strong></span>
<span class="strong"><strong>        .transition().duration(300) // &lt;-C</strong></span>
<span class="strong"><strong>            .style("left", "800px")</strong></span>
<span class="strong"><strong>            .style("height", "80px")</strong></span>
<span class="strong"><strong>            .style("width", "80px");</strong></span>
<span class="strong"><strong>    }</strong></span>
    
    body.append("div")    
            .style("position", "fixed")
            .style("background-color", "steelblue")
            .style("left", "10px")
            .style("width", "80px")
            .style("height", "80px")
<span class="strong"><strong>            .call(teleport); // &lt;-D      </strong></span>
&lt;/script&gt; </pre></div><p>The preceding code performs a <code class="literal">div</code> teleportation:</p><div class="mediaobject"><img src="graphics/2162OS_06_06.jpg" alt="How to do it..."/><div class="caption"><p>DIV teleportation via transition chaining</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec116"/>How it works...</h2></div></div></div><p>This simple <a id="id340" class="indexterm"/>teleportation effect was achieved by chaining a few transitions together. In D3, when transitions are chained, they are guaranteed to be executed only after the previous transition reaches its completion state. Now, let's see how this is done in the code:</p><div class="informalexample"><pre class="programlisting">function teleport(s){
    s.transition().duration(300) // &lt;-A
        .style("width", "200px")
        .style("height", "1px")
    .transition().duration(100) // &lt;-B
        .style("left", "600px")
    .transition().duration(300) // &lt;-C
        .style("left", "800px")
        .style("height", "80px")
        .style("width", "80px");
};</pre></div><p>The first transition was defined and initiated on line <code class="literal">A</code> (compression), then on line <code class="literal">B</code> a second transition (beaming) was created, and finally the third transition is chained on line <code class="literal">C</code> (restoration). Transition chaining is a powerful yet simple technique to orchestrate a complex transition effect by stitching simple transitions together. Finally in this recipe, we have also shown a basic example on re-usable composite transition effect by wrapping the teleportation transition in a function and then applying it on a selection using the <code class="literal">d3.selection.call</code> function (see line <code class="literal">D</code>). Re-usable transition effect is essential to following the DRY<a id="id341" class="indexterm"/> (Don't Repeat Yourself) principle, especially when the animation in your visualization becomes more elaborate.</p></div></div>
<div class="section" title="Using transition filter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Using transition filter</h1></div></div></div><p>Under some circumstances, you might find it necessary to selectively apply transition to a subset of a certain selection. In this recipe, we will explore this effect using data-driven transition filtering techniques.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec117"/>Getting Ready</h2></div></div></div><p>Open your local copy of the <a id="id342" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec118"/>How to do it...</h2></div></div></div><p>In this recipe, we will move a set of <code class="literal">div</code> elements (or boxes) across the web page from right to left. After moving all the boxes to the left, we selectively move only the boxes that are marked with <span class="strong"><strong>Cat</strong></span> back, so they won't fight each other. Let's see the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var data = ["Cat", "Dog", "Cat", "Dog", "Cat", "Dog", "Cat", "Dog"],
        duration = 1500;

    d3.select("body").selectAll("div")
            .data(data)
        .enter()
        .append("div")
            .attr("class", "fixed-cell")
            .style("top", function (d, i) {
                return i * 40 + "px";
            })
            .style("background-color", "steelblue")
            .style("color", "white")
            .style("left", "500px")
            .text(function (d) {
                return d;
            })
<span class="strong"><strong>            .transition() // &lt;- A</strong></span>
<span class="strong"><strong>                .duration(duration)</strong></span>
<span class="strong"><strong>                    .style("left", "10px")</strong></span>
<span class="strong"><strong>            .filter(function(d){return d == "Cat";}) // &lt;- B</strong></span>
<span class="strong"><strong>                .transition() // &lt;- C</strong></span>
<span class="strong"><strong>                .duration(duration)</strong></span>
<span class="strong"><strong>                    .style("left", "500px");</strong></span>
&lt;/script&gt;</pre></div><p>Here is what the page<a id="id343" class="indexterm"/> looks like after the transition:</p><div class="mediaobject"><img src="graphics/2162OS_06_07.jpg" alt="How to do it..."/><div class="caption"><p>Transition filtering</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec119"/>How it works...</h2></div></div></div><p>The initial setup of this recipe is quite simple, since we want to keep the plumbing as minimal as possible which will help you focus on the core of the technique. We have a data array containing interlaced strings of <code class="literal">"Cat"</code> and <code class="literal">"Dog"</code>. Then a set of <code class="literal">div</code> boxes are created for the data and a transition was created (see line <code class="literal">A</code>) to move all the boxes across the web page to the left-hand side. So far, it is a simple example of a multi-element transition with no surprises yet:</p><div class="informalexample"><pre class="programlisting">.transition() // &lt;- A
.duration(duration)
    .style("left", "10px")
.filter(function(d){return d == "Cat";}) // &lt;- B
.transition() // &lt;- C
.duration(duration)
    .style("left", "500px");</pre></div><p>Then on line <code class="literal">B</code>, <code class="literal">d3.selection.filter</code> function is used to generate a subselection containing only the "cat" boxes. Remember, D3 transition is still a selection (transition-bound selection), therefore, the <code class="literal">d3.selection.filter</code> function works exactly the same way as on a regular selection. Once the subselection is generated by the <code class="literal">filter</code> function, we can apply a <a id="id344" class="indexterm"/>secondary transition (see line <code class="literal">C</code>) to this subselection alone. The <code class="literal">filter</code> function returns a transition-bound subselection; therefore, the second transition created on line <code class="literal">C</code> is actually generating a transition chain. It will only be triggered after the first transition reaches its completion. By using combinations of transition chaining and filtering we can generate some really interesting data-driven animations; it is a useful tool to have in any data visualizer's toolset.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec120"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For recipes on D3 data-driven selection filtering, please see the <span class="emphasis"><em>Filtering with data</em></span> recipe <a class="link" href="ch03.html" title="Chapter 3. Dealing with Data">Chapter 3</a>, <span class="emphasis"><em>Dealing with Data</em></span></li><li class="listitem" style="list-style-type: disc">Read about API doc for the <code class="literal">selection.filter</code> function at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">https://github.com/mbostock/d3/wiki/Selections#wiki-filter</a></li></ul></div></div></div>
<div class="section" title="Listening to transitional events"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Listening to transitional events</h1></div></div></div><p>Transition chaining gives you <a id="id345" class="indexterm"/>the ability to trigger secondary transitions after the initial transition reaches its completion state; however, sometimes you might need to trigger certain action other than a transition, or maybe do something else during the transition. This is what transition event listeners are designed for, they are the topic of this recipe.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec121"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec122"/>How to do it...</h2></div></div></div><p>In this recipe, we will demonstrate how to display different captions on an animated <code class="literal">div</code> element based on its transition state. Obviously, this example can easily be extended to perform more meaningful tasks using the same technique:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var body = d3.select("body"), duration = 3000;

    var div = body.append("div")
            .classed("box", true)
            .style("background-color", "steelblue")
            .style("color", "white")
<span class="strong"><strong>            .text("waiting") // &lt;-A</strong></span>
<span class="strong"><strong>        .transition().duration(duration) // &lt;-B</strong></span>
<span class="strong"><strong>                .delay(1000) // &lt;-C</strong></span>
<span class="strong"><strong>                .each("start", function(){ // &lt;-D</strong></span>
<span class="strong"><strong>                    console.log(arguments);</strong></span>
<span class="strong"><strong>                    d3.select(this).text(function (d, i) {</strong></span>
<span class="strong"><strong>                        return "transitioning";</strong></span>
<span class="strong"><strong>                    });</strong></span>
<span class="strong"><strong>                })</strong></span>
<span class="strong"><strong>                .each("end", function(){ // &lt;-E</strong></span>
<span class="strong"><strong>                    d3.select(this).text(function (d, i) {</strong></span>
<span class="strong"><strong>                        return "done";</strong></span>
<span class="strong"><strong>                    });</strong></span>
<span class="strong"><strong>                })</strong></span>
            .style("margin-left", "600px");
&lt;/script&gt;</pre></div><p>The preceding code <a id="id346" class="indexterm"/>produces the following visual output where a box appears with <span class="strong"><strong>waiting</strong></span> label; it moves to the right with the label changed to <span class="strong"><strong>transitioning</strong></span> and when it's done, it stops moving and changes its label to <span class="strong"><strong>done</strong></span>:</p><div class="mediaobject"><img src="graphics/2162OS_06_08.jpg" alt="How to do it..."/><div class="caption"><p>Transition event handling</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec123"/>How it works...</h2></div></div></div><p>In this recipe, we constructed a single <code class="literal">div</code> element with a simple horizontal-movement transition, which, when initiated, also changes the label based on what transition state it is in. Let's first take a look at how we manage to display the <span class="strong"><strong>waiting</strong></span> label:</p><div class="informalexample"><pre class="programlisting">var div = body.append("div")
            .classed("box", true)
            .style("background-color", "steelblue")
            .style("color", "white")
            .text("waiting") // &lt;-A
        .transition().duration(duration) // &lt;-B
                .delay(1000) // &lt;-C</pre></div><p>The <span class="strong"><strong>waiting</strong></span> label is <a id="id347" class="indexterm"/>set on line <code class="literal">A</code> before the transition is defined on line <code class="literal">B</code>, however, we also specified a delay for the transition thus showing the <span class="strong"><strong>waiting</strong></span> label before the transition is initiated. Next, let's find out how we were able to display the <span class="strong"><strong>transitioning</strong></span> label during the transition:</p><div class="informalexample"><pre class="programlisting">.each("start", function(){ // &lt;-D
    d3.select(this).text(function (d, i) {
        return "transitioning";
    });
})</pre></div><p>This is achieved by calling the <code class="literal">each()</code> function and selecting its first parameter set as <code class="literal">"start"</code> event name with an event listener function passed in as the second parameter. The <code class="literal">this</code> reference of the event listener function points to the current selected element, hence, can be wrapped by D3 and further manipulated. The transition <code class="literal">"end"</code> event is handled in an identical manner:</p><div class="informalexample"><pre class="programlisting">.each("end", function(){ // &lt;-E
    d3.select(this).text(function (d, i) {
        return "done";
    });
})</pre></div><p>The only difference here is that the event name is passed into the <code class="literal">each()</code> function.</p></div></div>
<div class="section" title="Implementing a custom interpolator"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Implementing a custom interpolator</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Tipping the Scales">Chapter 4</a>, <span class="emphasis"><em>Tipping the Scales</em></span>, we explored how custom interpolators can be implemented in D3. In this recipe, we will demonstrate how this technique can be combined with D3 transition to generate special transition effects by leveraging custom interpolation.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec124"/>Getting Ready</h2></div></div></div><p>Open your local copy of the <a id="id348" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html</a>
</p><p>This recipe builds on top of what we have discussed in the <span class="emphasis"><em>Implementing a custom interpolator</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Tipping the Scales">Chapter 4</a>, <span class="emphasis"><em>Tipping the Scales</em></span>. If you are not familiar with the concept of custom interpolation, please review the related recipe before proceeding with this one.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec125"/>How to do it...</h2></div></div></div><p>Let's look at the code of the <code class="literal">custom-interpolator-transition.html</code> file and see how it works:</p><div class="informalexample"><pre class="programlisting"> &lt;script type="text/javascript"&gt;
<span class="strong"><strong>    d3.interpolators.push(function(a, b) { // &lt;-A</strong></span>
<span class="strong"><strong>      var re = /^([a-z])$/, ma, mb;</strong></span>
<span class="strong"><strong>      if ((ma = re.exec(a)) &amp;&amp; (mb = re.exec(b))) {</strong></span>
<span class="strong"><strong>        a = a.charCodeAt(0);</strong></span>
<span class="strong"><strong>        var delta = a - b.charCodeAt(0);</strong></span>
<span class="strong"><strong>        return function(t) {</strong></span>
<span class="strong"><strong>          return String.fromCharCode(Math.ceil(a - delta * t));</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>    });</strong></span>
        
    var body = d3.select("body");
            
    var countdown = body.append("div").append("input");
    
    countdown.attr("type", "button")
        .attr("class", "countdown")
<span class="strong"><strong>        .attr("value", "a") // &lt;-B</strong></span>
<span class="strong"><strong>        .transition().ease("linear") // &lt;-C</strong></span>
<span class="strong"><strong>        .duration(4000).delay(300)</strong></span>
<span class="strong"><strong>        .attr("value", "z"); // &lt;-D</strong></span>
&lt;/script&gt;</pre></div><p>The preceding code generates one ticking box that starts from <span class="strong"><strong>a</strong></span> and finishes at <span class="strong"><strong>z</strong></span>:</p><div class="mediaobject"><img src="graphics/2162OS_06_09.jpg" alt="How to do it..."/><div class="caption"><p>Transition with custom interpolation</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec126"/>How it works...</h2></div></div></div><p>First thing we did in this<a id="id349" class="indexterm"/> recipe is register a custom interpolator that is identical to the alphabet interpolator we discussed in <a class="link" href="ch04.html" title="Chapter 4. Tipping the Scales">Chapter 4</a>, <span class="emphasis"><em>Tipping the Scales</em></span>:</p><div class="informalexample"><pre class="programlisting">d3.interpolators.push(function(a, b) { // &lt;-A
      var re = /^([a-z])$/, ma, mb;
      if ((ma = re.exec(a)) &amp;&amp; (mb = re.exec(b))) {
        a = a.charCodeAt(0);
        var delta = a - b.charCodeAt(0);
        return function(t) {
          return String.fromCharCode(Math.ceil(a - delta * t));
        };
      }
});</pre></div><p>Once the custom interpolator is registered, the transition part has pretty much no custom logic at all. Since it's based on the value that needs to be interpolated and transitioned upon, D3 will automatically pick the correct interpolator to perform the task:</p><div class="informalexample"><pre class="programlisting">countdown.attr("type", "button")
        .attr("class", "countdown")
        .attr("value", "a") // &lt;-B
        .transition().ease("linear") // &lt;-C
        .duration(4000).delay(300)
        .attr("value", "z"); // &lt;-D</pre></div><p>As we can see in the preceding code snippet, the start value is <code class="literal">"a"</code>, defined on line <code class="literal">B</code>. Afterwards, a standard D3 transition is created on line <code class="literal">C</code> and finally all we had to do is set the end value to <code class="literal">"z"</code> on line <code class="literal">D</code>, then D3 and our custom interpolator takes care of the rest.</p></div></div>
<div class="section" title="Working with timer"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Working with timer</h1></div></div></div><p>So far in this chapter we have discussed various topics on D3 transition. At this point you might be asking the question, <span class="emphasis"><em>What is powering D3 transition that is generating the animated frames?</em></span>
</p><p>In this recipe, we will explore a low-level D3 timer function<a id="id350" class="indexterm"/> that you can leverage to create your own custom animation from scratch.</p><div class="section" title="Getting Ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec127"/>Getting Ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html</a>
</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec128"/>How to do it...</h2></div></div></div><p>In this recipe, we will create a custom animation that does not rely on D3 transition or interpolation at all; essentially a custom animation created from scratch. Let's look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var body = d3.select("body");
            
    var countdown = body.append("div").append("input");
    
    countdown.attr("type", "button")
        .attr("class", "countdown")
        .attr("value", "0");
        
    function countup(target){ // &lt;-A
        d3.timer(function(){ // &lt;-B
            var value = countdown.attr("value");
            if(value == target) return true;  // &lt;-C
            countdown.attr("value", ++value); // &lt;-D            
        });
    }
    
    function reset(){
        countdown.attr("value", 0);
    }
&lt;/script&gt;

&lt;div class="control-group"&gt;
    &lt;button onclick="countup(100)"&gt;
        Start
    &lt;/button&gt;
    &lt;button onclick="reset()"&gt;
        Clear
    &lt;/button&gt;
&lt;/div&gt;</pre></div><p>The preceding code <a id="id351" class="indexterm"/>generates a box where a timer is set to <span class="strong"><strong>0</strong></span>, and by clicking on <span class="strong"><strong>Start</strong></span> the timer increases until it reaches <span class="strong"><strong>100</strong></span> and stops, as shown in the following:</p><div class="mediaobject"><img src="graphics/2162OS_06_10.jpg" alt="How to do it..."/><div class="caption"><p>Custom timer-based animation</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec129"/>How it works...</h2></div></div></div><p>In this example, we have constructed a custom animation that moves integer from 0 to 100. For such a simple animation, of course we could have accomplished it using D3 transition and tweening. However, a simple example like this avoids any distraction from the technique itself. Additionally, even in this simple example, the timer-based solution is arguably simpler and more flexible than a typical transition-based solution. The power house of this animation lies in the<a id="id352" class="indexterm"/> <code class="literal">countup</code> function (see line <code class="literal">A</code>):</p><div class="informalexample"><pre class="programlisting">function countup(target){ // &lt;-A
        d3.timer(function(){ // &lt;-B
            var value = countdown.attr("value");
            if(value == target) return true;  // &lt;-C
            countdown.attr("value", ++value); // &lt;-D            
        });
    }</pre></div><p>As we have shown in this example, the key to understanding this recipe lies in the <code class="literal">d3.timer</code> function.</p><p>This <code class="literal">d3.timer(function, [delay], [mark])</code> starts a custom timer function and invokes the given function repeatedly, until the function returns <code class="literal">true</code>. There is no way to stop the timer once it is started, so the programmer must make sure the function eventually returns <code class="literal">true</code>. Optionally, you can also specify a <span class="strong"><strong>delay</strong></span>
<a id="id353" class="indexterm"/> as well as a <a id="id354" class="indexterm"/>
<span class="strong"><strong>mark</strong></span>. The<a id="id355" class="indexterm"/> delay starts from the mark and when the mark is not specified, <code class="literal">Date.now</code> will be used as the mark. The following illustration shows the temporal relationship we discussed here:</p><div class="mediaobject"><img src="graphics/2162OS_06_11.jpg" alt="How it works..."/></div><p>In our implementation, the custom <code class="literal">timer</code> function increases button caption by one, every time it is called (see line <code class="literal">D</code>) and returns <code class="literal">true</code> when the value reaches <code class="literal">100</code>, and therefore the the timer is terminated (see line <code class="literal">C</code>).</p><p>Internally, D3 transition uses the same timer function to generate its animation. At this point, you might be asking what is the difference between using <code class="literal">d3.timer</code> and using animation frame directly. The answer is that the <code class="literal">d3.timer</code> actually uses animation frame if the browser supports it, otherwise, it is smart enough to fall back to use the <code class="literal">setTimeout</code> function, thus freeing you from worrying about browser's support.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec130"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information on <code class="literal">d3.timer</code>, please visit its API at the following link:<p>
<a class="ulink" href="https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer">https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer</a>
</p></li></ul></div></div></div></body></html>