- en: 9 Calling External APIs to Enrich Your Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw an example of how to enrich the data you already
    have with external information. In that instance, the data was provided via CSV
    files, but this is not always the case. Very often, the data useful for enrichment
    is exposed via external **Application Programming Interfaces** (**APIs**), most
    frequently in the form of web service endpoints. Power BI allows you to read data
    from a web service via a dedicated UI, but most of the time it is unusable. Therefore,
    you have to resort to writing **M code** to get it done. Writing M code isn't
    too difficult, but it’s not that straightforward either. You also have to be careful
    not to write code that leads to refresh issues when publishing the report to the
    Power BI service. Moreover, in Power BI, it is not possible to parallelize more
    than one call to the same web service in order to reduce waiting time when retrieving
    data. Adopting Python or R to get data from a web service solves all these issues
    very easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a web service is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering for Bing Maps Web Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding addresses using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geocoding addresses using R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing web services using Power BI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter requires you to have a working internet connection and **Power
    BI Desktop** already installed on your machine. You must have properly configured
    the R and Python engines and IDEs as outlined in *Chapter 2*, *Configuring R with
    Power BI*, and *Chapter 3*, *Configuring Python with Power BI*.
  prefs: []
  type: TYPE_NORMAL
- en: What a web service is
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the course of your work as an analyst, you may need to retrieve data through
    an API, exposed by a system within your network, for example. However, this is
    a rare case, since today almost all external data sources are exposed as **web
    services**, even within a company.
  prefs: []
  type: TYPE_NORMAL
- en: Web services are the most common and popular way of communicating information
    between heterogeneous information systems. A web service is basically a software
    module hosted on a server that is available over the internet to provide data
    to specific requests from a client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mostly two types of design models for web services: **Simple Object
    Access Protocol** (**SOAP**) and **REpresentational State Transfer** (**REST**).'
  prefs: []
  type: TYPE_NORMAL
- en: SOAP relies heavily on **XML** and defines a highly typed messaging structure
    through schemas. All messages exchanged between the service and the client are
    all encoded through **Web Service Definition Language** (**WSDL**), which, in
    turn, is based on the XML format. One of the most important aspects of WSDL is
    that it defines a binding contract between the service provider and each service
    consumer. Therefore, any change to the API involves a change to be made to the
    client. Nowadays, almost everything that matters runs on HTTP. But keep in mind
    that, in addition to HTTP, SOAP can take advantage of any other transport protocol
    (such as SMTP and TCP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST is becoming the default design model for all public APIs. It is an architecture
    that relies exclusively on the HTTP protocol (as opposed to SOAP). It doesn’t
    use WSDL contracts and is, therefore, more flexible and faster to implement. REST
    can handle data in any format, such as XML or YAML, but the most used is surely
    **JSON**. Unlike SOAP, which is function-driven, REST is very **data-driven**.
    It is for this reason that all web services used for data enrichment are **RESTful**
    (take a look at the references for more details) and can generate output in any
    format – not only JSON but also CSV, or **Really Simple Syndication** (**RSS**),
    for example! Basically, REST offers a lighter method of interacting with the service,
    using URLs in most cases to receive or send information. The exposed basic methods
    are `GET`, `POST`, `PUT`, and `DELETE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quite often, you will have heard about web service **endpoints**. In general,
    a web service works by accepting `GET` requests from the client and providing
    responses to them. Considering a REST API, an endpoint is a URL at which the web
    service can be accessed by a client application. A web service can provide more
    than one endpoint. If you consider **Bing Maps REST Services**, for example, the
    endpoint used for geocoding is as follows: `dev.virtualearth.net/REST/v1/Locations`.
    The one used instead to provide a route between two waypoints is this one: `dev.virtualearth.net/REST/v1/Routes`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that it's clear what a web service is and what the meaning of the technical
    terms that often come with it is, we can move on to showing you how to use a RESTful
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Registering for Bing Maps Web Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we will use Bing Maps Web Services as an example. Therefore,
    you need to create a free Bing Maps Basic Key via your Microsoft account. The
    necessary steps to do so are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://www.microsoft.com/en-us/maps/create-a-bing-maps-key](https://www.microsoft.com/en-us/maps/create-a-bing-maps-key),
    select the **Basic Key** option just after the main banner, and then click on
    **Get a free Basic key** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next **Welcome** page, click on **Sign in** and use your Microsoft Account
    to log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, you will be notified that this is the first time your email
    is being used to authenticate in the **Bing Maps Dev Center**. Click on **Yes,
    let's create a new account** to create a new account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your account details on the next page and click **Create**. After that,
    you’ll be logged in to the Dev Center, and you’ll see some claims on the page
    saying **Announcement** and **Important reminder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On that page, under the **My account** menu, click on **My keys**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be prompted with a form asking for a new key . Just fill the required
    fields, entering `geocoding-test` in the **Application name** field, and leaving
    `Basic` as **Key type** and `Dev/Test` as **Application type**. Then, click on
    **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A page will appear to confirm that the key has been created, such as the following
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Bing Maps key confirmation](img/file227.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.1 – Bing Maps key confirmation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Show key** to see the key you’ll use in the next examples and copy
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following URL in your browser URL bar, replacing the `<your-bing-maps-api-key>`
    string with your key: [http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=<your-bing-maps-api-key>](http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=%3Cyour-bing-maps-api-key%3E).
    Then, press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some browsers, such as Firefox, prettify JSON responses returned by web services.
    In your case, if all goes well, you should see a result such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the
    browser](img/file228.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the
    browser
  prefs: []
  type: TYPE_NORMAL
- en: Great! You’ve just geocoded an address passed as a query parameter to the Bing
    Maps Locations API! Let's now see how to use Python to automate this process.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding addresses using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll show you how to make calls to the Bing Maps Locations
    API using both a direct call to the URL via the `GET` method (which is ultimately
    equivalent to the example call you made earlier via the browser) and a dedicated
    Python **Software Development Kit** (**SDK**) that facilitates the query.
  prefs: []
  type: TYPE_NORMAL
- en: Using an explicit GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to receive geocoding data for an address from the Bing API, we need
    to make a request to the web service by passing the address of interest as a parameter.
    The parameters are passed through appropriate concatenation of the parameters
    with the URL of the endpoint. In our case, the full format of the endpoint URL
    useful for geocoding an address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – URL format of a GET request to the Bing Maps Locations API](img/file229.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – URL format of a GET request to the Bing Maps Locations API
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of each string token you can see in *Figure
    9.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base_url`: The endpoint URL string, that is, `http://dev.virtualearth.net/REST/v1/Locations/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`: The string of the address that you want to geocode, transformed
    using the *percent encoding* technique to avoid using special characters in the
    final URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTH_KEY`: Your Bing key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the URL has been built in this way, it can be used to make a `GET` request
    via the `get()` method of the `requests` module. After getting the data as a result
    of the request, you’ll capture the content of the web service response containing
    JSON, and from that, you can extract the values of interest. For example, in order
    to extract the `formattedAddress` value, you have to navigate into the data structure,
    as shown in *Figure 9.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Visual structure of the Bing Maps Locations API response](img/file230.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Visual structure of the Bing Maps Locations API response
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can navigate your JSON variable `data`, in the same way to get that
    value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From *Figure 9.4*, you can see that the resources node can contain more than
    one subnode, identified with an integer. This is because sometimes the geocoding
    engine cannot exactly identify the geographic point from the passed address and
    therefore returns more than one result. The `estimatedTotal` attribute indicates
    the number of possible geocodes identified. For simplicity, we have extracted
    from the JSON the last identified resource, which is the one with the highest
    identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the answer in JSON format, from the request, you can also extract other
    values, such as the reason for the state of the answer (useful to understand whether
    the `GET` operation is successful or not), the complete content of the answer
    in text format, and the URL used for the `GET` request. You will need the `requests`,
    `urllib`, `json`, `pandas`, and `time` modules. The latter is used to measure
    the geocoding execution time of all addresses in the dataset. Everything can be
    encapsulated in a handy function called `bing_geocode_via_address()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code chunks contained in this section are available in the `01-geocoding-with-python.py`
    file inside the `Chapter09\Python` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have a list of addresses to geocode in a pandas DataFrame, it makes
    sense to write a handy function that takes as input a DataFrame row and the column
    name in which the address is stored. It will invoke the previous function to get
    geocoding values to add to the current row and will return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test these functions using the test dataset at this link: [http://bit.ly/geocoding-test-addresses](http://bit.ly/geocoding-test-addresses).
    It’s also available in the `Chapter09` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to simply pass the previous function as a parameter to the addresses''
    DataFrame `apply()` method to apply it to each of its rows, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the Bing Maps services key is set using the `os.environ.get(''BINGMAPS_API_KEY'')`
    function call. This way of accessing sensitive data avoids having to write it
    in plain text in the code. So, it must have been previously written to the `BINGMAPS_API_KEY`
    environment variable. You can also do this with Python via the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, however, each time you restart Visual Studio Code, that variable
    will be lost. To have it permanently available, you must set up a user variable
    environment directly through your operating system. In Windows, you can follow
    this guide: [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable).
    Once added, you must restart Visual Studio Code to make it visible to your code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We preferred to load the CSV file directly into the Python script. It would
    have been equivalent to first loading the CSV file via the Power BI **Text/CSV**
    connector and then adding a transformation step that would run the Python code
    we just analyzed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The geocoding operation takes about 34 seconds for 120 addresses. Part of the
    content of the final DataFrame is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Content of the geocoded DataFrame](img/file231.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Content of the geocoded DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: Impressive! You geocoded as many as 120 addresses with just a few lines of Python
    code in 34 seconds. But did you know that you can also parallelize `GET` requests
    by geocoding all your addresses in less time? Let's see how you can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Using an explicit GET request in parallel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as you learned in *Chapter 8*, *Loading Large Datasets beyond the Available
    RAM in Power BI*, the Swiss army knife that allows you to parallelize your computations
    in Python is Dask. The great thing is that a Dask DataFrame exposes the `apply()`
    method, which has the same functionality as a pandas DataFrame’s `apply()`function,
    with the difference that it is parallelized. Therefore, the code used in the previous
    section is practically reusable with a few minor modifications to achieve significantly
    reduced execution times. You can find the full script in the `02-geocoding-parallel-with-python.py`
    file in the `Chapter09\Python` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When the API requires it, it is preferable to provide multiple inputs using
    **batch mode**, rather than making multiple calls in parallel. However, if batch
    mode is not covered by the API, multiple parallel calls are the only way to improve
    execution times. The Bing Maps Locations API supports batch mode, but for demonstration
    purposes, we preferred to adopt the multiple call technique.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `enrich_with_geocoding()` and `bing_geocode_via_address()` functions remain
    as they are. Instead, the Dask DataFrame is introduced already at the data reading
    stage, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, a Dask DataFrame is divided into many partitions, where each partition
    is a pandas DataFrame. Now, it happens that when the data is not a large amount,
    it may be loaded in a single partition by `read_csv()`. In fact, if you run the
    following code: `ddf.npartitions`, you will see that it returns `1`. It is for
    this reason that in cases such as this, it is necessary to repartition the Dask
    DataFrame into an appropriate number of partitions to benefit from parallelism,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following applies to the number of partitions in a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is no precise rule for determining the ideal number of partitions in a
    DataFrame. The formula used earlier is effective for the dataset we are considering
    here and has been determined empirically.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'At this point, you have to simply invoke the `apply()` method of the Dask DataFrame
    by passing it the `enrich_with_geocoding()` function, as you did with the `apply()`
    method of the pandas DataFrame in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we had to specify the expected metadata of the output. This is
    because many operations on DataFrames rely on knowing the name and type of the
    column. Internally, Dask DataFrame does its best to propagate this information
    through all operations. Usually, this is done by evaluating the operation on a
    small sample of dummy data. Sometimes, however, this operation can fail in user-defined
    functions (such as in the case of `apply`). In these cases, many functions support
    an optional `meta` keyword, which allows you to specify the metadata directly,
    avoiding the inference step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dask DataFrame’s `apply()` method now supports only the `axis=1` mode (row-wise).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You’ve just defined a lazy transformation. To actually perform it, you must
    use the `compute()` function, so in this case, you can measure the time it takes
    to geocode all the addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The end result is stunning: 120 addresses were geocoded in *just 3.5 seconds*
    versus 35 seconds for sequential code! You have achieved a 10x improvement in
    running time thanks to Dask!'
  prefs: []
  type: TYPE_NORMAL
- en: As you've seen in this section and the previous one, the most uncomfortable
    part of the code is perhaps retrieving every single value from the JSON returned
    by the web service (the logic in the `bing_geocode_via_address()` function), because
    you have to know in advance the structure of the result obtained. However, there
    are Python modules that contain functions that facilitate interaction with specific
    web services. Let's see how to use the `Geocoder` library, which simplifies the
    adoption of the most widely used geocoding providers, such as those of Google
    and Bing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Geocoder library in parallel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Geocoder** module ([https://geocoder.readthedocs.io/](https://geocoder.readthedocs.io/))
    is a simple and consistent geocoding library written in Python. It makes consistent
    responses from expected geocoding providers using a unique JSON schema. Some of
    the providers available are Google, Bing, Mapbox, and TomTom.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install the Geocoder library in the `pbi_powerquery_env`
    environment. You can do that by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Anaconda prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the `pbi_powerquery_env` environment by entering this command: `conda
    activate pbi_powerquery_env`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Geocoder library by entering this command: `pip install geocoder`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Thanks to Geocoder, the `GET` request for an address is simply transformed
    into the command `r = geocoder.bing(address, key = AUTH_KEY)`. And the great thing
    is that the returned object, `r`, already contains the attributes useful for geocoding,
    such as `r.address`, `r.lat`, or `r.lng`. Therefore, the `bing_geocode_via_address()`
    function you encountered in the previous sections is embarrassingly simplified,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Geocoder selects the most appropriate match if the geocoding operation
    returns more than one match, saving you from further headaches. The option to
    return multiple results is currently an in-progress development. In more recent
    versions of the package, it is possible to pass the `MaxRows` parameter with a
    value greater than one to the geocoding functions to obtain as many possible results
    as the value passed. In this way, it is the analyst who can choose the outcome
    that meets their needs.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete script that uses the Geocoder library to geocode addresses
    in parallel in the `03-geocoding-parallel-using-sdk-with-python.py` file in the
    `Chapter09\Python` folder.
  prefs: []
  type: TYPE_NORMAL
- en: You can now understand that having an SDK available that is designed to simplify
    your life in using a specific API is a major boon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the overarching principles we always suggest is to *avoid reinventing
    the wheel* every time you need it. If you need to accomplish a goal (in our case,
    geocoding an address), most likely someone before you has already thought of it
    and perhaps shared a library with the community that simplifies your life. Always
    spend a half-hour searching the web for possible pre-existing solutions that can
    smartly solve your problem. In addition to saving valuable time, you avoid the
    risk of going crazy with complexities that others have already overcome for you.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although we knew of the existence of the Geocoder library, we still wanted to
    show you how to make `GET` requests to the web service from scratch in the previous
    sections. This is because it is not certain that SDKs exist for all web services
    that you may need in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how to get the same results using R.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding addresses using R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have just learned how to query a web service via raw `GET` requests to the
    endpoint and via a handy SDK using Python. As you can already guess, you can also
    do both with R. Let's see how it’s done.
  prefs: []
  type: TYPE_NORMAL
- en: Using an explicit GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The package that allows calls to URLs in R is `httr` (installed by default
    with the engine). Making a `GET` request simply translates to `GET(your_url)`
    thanks to it. As you have already seen in the previous sections, **percent encoding**
    must be applied to the address to be passed as a web parameter to the Bing Maps
    Locations API endpoint. The function that allows you to apply this type of encoding
    to a string is found in the `RCurl` package and is named `curlPercentEncode()`.
    In addition, the handy `tictoc` package will be used to measure run times. Both
    the `RCurl` and `tictoc` packages need to be installed, as shown in the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open RStudio and make sure it is referencing your latest CRAN R engine in **Global
    Options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Console** window and enter this command: `install.packages("RCurl")`.
    Then press *Enter* key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter this command: `install.packages("tictoc")`. Then press **Enter**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, once you have defined the `base_url` and `AUTH_KEY` variables
    specific to the web service to query, it is enough to execute the following code
    to obtain the result of a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `str_glue()` function of the `stringr` package has been used to concatenate
    the strings. Note that also, in this case, the `AUTH_KEY` variable is set from
    an environment variable using `AUTH_KEY = Sys.getenv(''BINGMAPS_API_KEY'')`. This
    means that the environment variable must be set beforehand. You can set it directly
    in your R session using the following R script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, however, each time you restart RStudio, that variable will be lost.
    To have it permanently available, you must set up a user variable environment
    directly through your operating system. In Windows, you can follow this guide:
    [https://phoenixnap.com/kb/windows-set-environment-variable](https://phoenixnap.com/kb/windows-set-environment-variable).
    Once added, you must restart RStudio to make it visible to your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have obtained the result of the request, you can proceed to parse the
    JSON content to obtain the desired geocoding values. Everything that was taken
    into account for parsing the result in the previous sections still applies. So
    again, you will have to handle the multiple results that some geocoding operations
    might return. As already done for the Python scripts used previously, all this
    logic can be encapsulated into the `bing_geocode_via_address()` function in R
    that returns a list of values obtained as a result of geocoding a passed address.
    You can find the code in the `01-geocoding-with-r.R` file in the `R\Chapter09`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have loaded the contents of the `geocoding_test_data.csv` file into
    the `tbl_orig` tibble and selected the columns of interest in `tbl`, you will
    exploit the convenience of the `purrr` package''s `map()` function to execute
    the previous defined `bing_geocode_via_address()` function for each address extracted
    from the tibble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note how we used the `pull()` function to transform the `full_address` tibble
    column into a vector and then passed it as a parameter to the `map_dfr()` function,
    which only accepts lists or vectors as input. You may be wondering what the `map_dfr()`
    function is for. It is part of the `purrr` family of `map()` functions. While
    `map()` returns a list of results (each obtained by applying the input function
    to each element of the input vector) as output, `map_dfr()` directly binds rows
    when each element of the `map()` output is a named DataFrame, list, or vector.
    So the final result of `map_dfr()` is a DataFrame/tibble composed of the elements
    returned by the input function arranged row by row. The whole logic is wrapped
    by the pair of functions, `tic()` and `toc()`. By running the entire block of
    code (from `tic()` to `toc()` inclusive), you can get the execution time of the
    code inside very conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there is no need in this case for an intermediate
    function such as `enrich_with_geocoding()` that accepts the individual lines of
    the tibble as a parameter. Since the `bing_geocode_via_address()` function returns
    a named list, the `map_dfr()` function manages to interpret it correctly and bind
    it into a single tibble.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We preferred to load the CSV file directly into the R script. It would have
    been equivalent to first loading the CSV file via the Power BI **Text/CSV** connector
    and then adding a transformation step that would run the R code we just analyzed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since `map_dfr()` only returns a tibble of geocoding values, you have to bind
    this tibble to the initial `tbl` one in order to have a single enriched tibble.
    For this reason, we used the function `bind_cols(tbl, .)`, where the parameter
    `.` denotes the tibble of geocoding values passed as a parameter by the piping
    operation. That said, the whole geocoding operation takes about 30 seconds (which
    is comparable to the result obtained with Python), and the final tibble will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Content of the geocoded DataFrame](img/file232.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Content of the geocoded DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: Well done! You were able to geocode addresses via the web service even with
    R. Easy, right? Are you now curious to learn how to do this by taking advantage
    of the parallelism provided by your machine? Let's see how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Using an explicit GET request in parallel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as in Python, we had to use the Dask module to parallelize computations;
    in R, we need to introduce a new package to achieve the same thing. The new package
    is called `furrr` ([https://furrr.futureverse.org/](https://furrr.futureverse.org/))
    and is intended to combine the expressive power of the `purrr` family of mapping
    functions with the parallel processing capabilities provided by the **future**
    package ([https://future.futureverse.org/](https://future.futureverse.org/)).
    Both the `furrr` and `future` packages are part of an interesting framework called
    **Futureverse** ([https://www.futureverse.org/](https://www.futureverse.org/)),
    which aims to parallelize existing R code in the simplest way. In practical terms,
    `furrr` allows you to replace the `map()` and `map_*()` functions of `purrr` with
    the `future_map()` and `future_map_*()` functions of `furrr` with minimal effort,
    and your code will magically run in parallel. Keep in mind that the future engine
    is also the backend used by the `disk.frame` packages you learned about in *Chapter
    8*, *Loading Large Datasets beyond the Available RAM in Power BI*.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to install the `furrr` package. Just run the command
    `install.packages("furrr")` in the RStudio’s **Console** window and that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply what has just been said to the code analyzed in the previous section,
    it is enough to modify the last part of it as follows to obtain the same result
    (and obviously loading the `furrr` library instead of `purrr`), but while parallelizing
    the computations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `availableCores()` function, it is possible to identify the number
    of virtual processors present on the machine. It is good practice not to use all
    of them as it can make the machine unresponsive. The `plan()` function of a future
    instance allows you to define the strategy with which the future engine performs
    the calculations (synchronously or asynchronously). It also allows you to define
    the number of workers that will work in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generally, the default strategy used on Windows machines is **multisession**
    and it works fine running the code in RStudio. We found that with this strategy,
    Power BI cannot handle the multiple sessions generated to parallelize computations.
    Instead, we found that selecting the **cluster** strategy, despite the machine
    being unique, allows Power BI to complete the computations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another minimal change was to declare the `base_url` and `AUTH` variables associated
    with the web service directly in the function invoked by `future_map_dfr()` instead
    of in the main code for simplicity. Passing variables to functions invoked via
    `furrr` is done slightly differently than in standard practice (follow this link:
    [https://furrr.futureverse.org/articles/articles/gotchas.html](https://furrr.futureverse.org/articles/articles/gotchas.html)),
    and we wanted to avoid adding minimal complexity so as not to distract from the
    main concept.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full script in the `02-geocoding-parallel-with-r.R` file in
    the `Chapter09\R` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the code, you will get impressive results: 120 addresses were geocoded
    in *just 3 seconds* versus 30 seconds for sequential code! Also, in this case,
    you achieved a 10x improvement in running time thanks to `furrr`! Simple as that,
    right?'
  prefs: []
  type: TYPE_NORMAL
- en: You can further simplify the code you just ran by adopting a geocoding package
    that does the bulk of the work for you in invoking the web service. Let's see
    what this is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tidygeocoder package in parallel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tidygeocoder` ([https://jessecambon.github.io/tidygeocoder/](https://jessecambon.github.io/tidygeocoder/))
    package provides a unified high-level interface for a selection of supported geocoder
    services and returns results in tibble format. Some of the providers available
    are Google, Mapbox, TomTom, and Bing (starting with version 1.0.3).
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you need to install it. If you want to install the latest version,
    remember to reset the snapshot repository using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can simply run the `install.packages("tidygeocoder")` command in the
    Console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to Tidygeocoder, the `GET` request for an address is simply transformed
    into the `details_tbl <- geo(address, method = ''bing'', full_results = TRUE)`
    command, and the great thing is that the returned object, `r`, already contains
    the attributes useful for geocoding, such as `details_tbl$bing_address.formattedAddress`.
    Therefore, the `bing_geocode_via_address()` function you encountered in the previous
    sections is embarrassingly simplified, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also, in this case, the tidygeocoder package selects the most appropriate match
    if the geocoding operation returns more than one, saving you from further headaches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that Tidygeocoder assumes that the `BINGMAPS_API_KEY` environment variable
    has been set and uses it to log in to the web service.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can find the complete script that uses the Geocoder library to geocode addresses
    in parallel in the `03-geocoding-parallel-using-sdk-with-r.R` file in the `Chapter09\R`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you've probably figured out by now, using SDKs available to the community
    makes your life easier and is a winning choice. If an SDK for a specific web service
    is not available, you still learned how to make a raw `GET` request with R.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the benefits of what we've learned so far by implementing
    web service data enrichment solutions with R and Python in Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing web services using Power BI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Power BI already has default features that allow you to access the data exposed
    by a web service into Power Query. There are two main modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Via GUI (click on **Get data**, then **Web**, and then you can set advanced
    options if needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the M language, using the `Web.Contents()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the GUI is very cumbersome and almost always it does not lead to
    the desired results. The only way to effectively connect to a web service using
    native Power BI features is to write M code. Writing code in M is not too difficult.
    However, there are some complications in using the `Web.Contents()` function that
    arise when publishing a report that makes use of it to the Power BI service. In
    short, it is necessary to be careful when you have to build the URL to use in
    the `GET` request in a dynamic way, making use of the **relative path** and the
    **query options**. If you do not use this particular construct, the service will
    not be able to refresh the data. Moreover, the Power BI service does not allow
    you to securely store sensitive data, such as the API key, forcing you to embed
    this information into your code. In addition to that, multiple calls to an endpoint
    cannot be made in parallel using M.
  prefs: []
  type: TYPE_NORMAL
- en: It is for the reasons listed above that we suggest using R or Python to access
    web services, especially if SDKs are available to facilitate their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the following restriction applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the report that uses web service data has to be published to the Power BI
    service, you can only query web services through Power Query and not within R
    visuals because the environment used by them on the service is not exposed on
    the internet.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That said, in order to be able to geolocate addresses using the Bing Maps Locations
    API in Power BI using the scripts we provide, the following clause applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You must define the `BINGMAPS_API_KEY` environment variable as a user environment
    variable on your operating system to use the geocoding script we’ll provide for
    Power BI. If the report that makes use of the data extracted from the web service
    will be published to the Power BI service, make sure to create the same environment
    variable on the data gateway machine as well.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, let's see how to extract data from a web service in Power BI with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding addresses in Power BI with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Power BI, we will use the Python code that calls the web service through
    the Geocoder SDK and exploits the parallelism thanks to Dask. The code to be used
    is practically identical to that already analyzed previously. Therefore, it is
    enough to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and make sure it references the `pbi_powerquery_env` environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Get data**, search and select **Python script**, and then copy the
    script you can find in the `04-geocoding-parallel-using-sdk-in-power-bi-with-python.py`
    file into the `Chapter09\Python` folder. Make sure to edit the path to the `geocoding_test_data.csv`
    file. Then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a few seconds, you will see the **Navigator** window appear, where you
    can select the `enriched_df` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – The enriched_df DataFrame loaded in Power BI](img/file233.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.7 – The enriched_df DataFrame loaded in Power BI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on **Load**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You just queried the Bing Maps Locations API from within Power BI in parallel
    using Python! Easy, right?
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to do the same thing with R. Let's see how to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Geocoding addresses in Power BI with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Power BI, we will use the R code that calls the web service through the
    Tidygeocoder SDK and that exploits the parallelism thanks to the `furrr` package.
    The code to be used is practically identical to that already analyzed previously.
    Therefore, it is enough to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Power BI Desktop and make sure it references your latest CRAN R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Get data**, search and select **Python script**, and then copy the
    script you can find in the `04-geocoding-parallel-using-sdk-in-power-bi-with-r.R`
    file into the `Chapter09\R` folder. Make sure to edit the path to the `geocoding_test_data.csv`
    file. Then click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a few seconds, you will see the **Navigator** window appear, where you
    can select the `tbl_enriched` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI](img/file234.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on **Load**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You just queried the Bing Maps Locations API from within Power BI in parallel
    using R too!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to query RESTful web services using Python
    and R. In addition to learning how to execute raw `GET` requests with both languages,
    you've also learned how to parallelize multiple calls to the same endpoint by
    taking advantage of the multithreading capabilities of your machine. Moreover,
    you've also come across some SDKs of the Bing Maps Locations API, both for Python
    and R, which make accessing the data much easier. Finally, you've seen how all
    of this is easily implemented in Power BI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll see how to enrich your data by applying complex
    algorithms to the data you already have. In this way, you will create new variables
    that give a new light to your data, making it more useful to reach your goal.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For additional reading, check out the following books and articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '*What RESTful actually means* ([https://codewords.recurse.com/issues/five/what-restful-actually-means](https://codewords.recurse.com/issues/five/what-restful-actually-means))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Bing Maps REST Services* ([https://docs.microsoft.com/en-us/bingmaps/rest-services](https://docs.microsoft.com/en-us/bingmaps/rest-services))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A Future for R: A Comprehensive Overview* ([https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html](https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*[VIDEO] Accessing API and web service data using Power Query* ([https://www.youtube.com/watch?v=SoJ52o7ni2A](https://www.youtube.com/watch?v=SoJ52o7ni2A))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Invoking M Functions In Parallel Using List.ParallelInvoke()* ([https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/](https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/))'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
