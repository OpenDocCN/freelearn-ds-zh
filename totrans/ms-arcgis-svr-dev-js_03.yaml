- en: Chapter 3. The Dojo Widget System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developers at Esri created the ArcGIS JavaScript API using the Dojo framework.
    Dojo provides a large assortment of tools, libraries, and UI controls that work
    across multiple browsers. Any developer can create custom applications with UI
    elements that work well together using Dojo and the ArcGIS JavaScript API. Also,
    Dojo provides the AMD tools necessary to develop your own custom widgets, libraries,
    and controls.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we've reviewed the ArcGIS API for JavaScript, and
    we've written a small application using the API. We've even incorporated some
    basic principles of AMD into a single page application. What we've done so far
    would work great with a smaller application.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens when applications get larger? Are we going to implement a single
    script to load all the components we need for a larger application? How are we
    going to extend the functionality of our website? What if we update our libraries
    and something breaks? Are we going to hunt through several thousand lines of code
    in one monolithic JavaScript file to find the parts that need to be changed?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take advantage of the Dojo framework and create a custom
    widget for our application. Through that process, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The background of the Dojo framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the `dojo`, `dijit`, and `dojox` module packages have to offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and use our own custom modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create widgets (modules with UI components), and how to extend them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief history of the Dojo framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dojo framework began in 2004 with initial work at Informatica. Alex Russell,
    David Schontzler, and Dylan Schiemann contributed the first lines of code for
    the project. As work on the code continued, other developers were brought in and
    lent their input into the direction of the framework. The project grew so large
    that the founders created the Dojo Foundation to oversee the codebase and its
    intellectual properties. Since then, over 60 developers have contributed to the
    framework, and companies such as IBM and SitePen continue to use it today. For
    more information, visit at [http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html](http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html).
  prefs: []
  type: TYPE_NORMAL
- en: So what makes Dojo a framework, as opposed to a library? When this question
    was posed to the people at stack overflow ([http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library](http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library)),
    the most agreed upon answer centered on an inversion of control. When we use tools
    in a library, our code controls the flow of logic and activity. When we calculate
    a value, we update that value in each location that it's needed through our code.
    In a framework, however, the framework controls the behavior of the application.
    When a value is updated in a framework, it is the framework that updates that
    value wherever it is bound on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: The Dojo framework provides a number of HTML-based controls that we can load
    and use. Much in the way of CSS appearances and JavaScript behavior, is prewired
    into the control. After initial setup, our code instructs the framework where
    to send data when specific control events occur. We have no control when our functions
    are called, only what happens after they're called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to read more about frameworks and the inversion of control, Martin
    Fowler provides a good explanation of the subject on his blog at [http://martinfowler.com/bliki/InversionOfControl.html](http://martinfowler.com/bliki/InversionOfControl.html).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing dojo, dijit, and dojox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great care has been taken to organize the Dojo framework. When Dojo incorporated
    the AMD style of modules, many of the objects, methods, and properties were reorganized
    into logical folders and modules. Dojo is broken down into three main packages:
    **dojo**, **dijit**, and **dojox**. Let''s get an idea of what these three packages
    bring to the framework.'
  prefs: []
  type: TYPE_NORMAL
- en: The dojo package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dojo` package provides much of the base functionality needed to load, run,
    and tear down the various modules in our applications. The modules provide functions
    and tools that work across multiple browsers, including the dreaded older versions
    of Internet Explorer. For example, the developer doesn't have to handle events
    by trying `addEventListener()` for Chrome and `attachEvent()` for older IE, because
    it's handled behind the scenes by `dojo/on`. With the framework, you can get away
    from all the browser hacks, and focus on creating a good application.
  prefs: []
  type: TYPE_NORMAL
- en: The `dojo` package does not contain widgets, but it does contain the tools necessary
    to manipulate things within the widgets. Do you need to handle mouse clicks and
    touch events? Use the `dojo/mouse` and `dojo/touch` modules. Do you need a jQuery-like
    selector for your HTML? Load the `dojo/query` module. The dojo package provides
    modules for HTML DOM manipulation, arrays, AJAX, dates, event, and i18n, just
    to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: The dijit package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dijit` package provides visual elements (referred to as **dijits**) that
    integrate well with the `dojo` package. The elements created with the `dijit`
    package have been tested across multiple browsers. They provide a consistent user
    interface based on the CSS stylesheets loaded with the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Dojo framework is used and contributed to by many companies and developers,
    there are plenty of user controls available. Whether you''re creating a submission
    form, a calendar of events, or an executive dashboard, you can combine the dijits
    in this package in a way that suits your needs. Some of the more popular packages
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dijit/Calendar`: This provides an interactive HTML calendar control that works
    on both desktops and tablets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dijit/form`: A package containing stylized form elements such as buttons,
    checkboxes, dropdown menus, textboxes, and sliders. The form elements have a consistent
    look across older and newer browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dijit/layout`: A package containing controls that handle layouts. You can
    create simple containers, tab containers, accordion containers, and even containers
    that control the positions of other containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dijit/Tree`: A module that creates a collapsible tree menu which could be
    used, for instance, to show folder layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dijit` package contains more than user controls. It also provides the tools
    necessary to create your own custom dijits. Using the `dijit/_WidgetBase` module
    and assorted mixins, you can incorporate both HTML elements and existing dijits
    into your own custom `dijit`. Working with the `dijit` components can give the
    user a consistent experience throughout the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: The dojox package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to documentation on the Dojo framework ([http://dojotoolkit.org/reference-guide/1.10/dojox/info.html](http://dojotoolkit.org/reference-guide/1.10/dojox/info.html)),
    `dojox` provides extensions to Dojo. This part of the library deals with more
    experimental functionality, user interfaces, and testing features. Many parts
    of the library have matured due to extensive use, while other parts have been
    depreciated and are not under active development.
  prefs: []
  type: TYPE_NORMAL
- en: One of the useful subpackages in the `dojox` package is `dojox/mobile`. The
    `Dojox/mobile` package provides UI elements and controls that you can use in mobile
    applications. They have been tested on a wide variety of mobile browsers, and
    their styling can even mimic the style of native smartphone and tablet applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information regarding the `dojo`, `dijit`, and `dojox` packages in
    the Dojo framework, you can view tutorial documentation by going to: [http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/](http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/).'
  prefs: []
  type: TYPE_NORMAL
- en: The dojoConfig packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the built-in Dojo packages is great and all, but what about making your
    own custom package? You can create custom packages in your local folders, and
    reference them through your `dojoConfig` object. In the `dojoConfig` object, you
    can add a packages parameter that contains an array of JavaScript objects. Those
    package objects should contain a name attribute, which is a reference to your
    package, and a location attribute, which references the folder location. Here''s
    an example of a `dojoConfig` object with a reference to a custom package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding sample, the package `myapp` is referenced, and all the files
    for that package are loaded into the `myapp` folder under the current page. So,
    if this page was shown at `http://www.example.com/testmap/`, the `myapp` package
    could be found at `http://www.example.com/testmap/myapp`. When referencing the
    `Something` module in your `myapp` package, you would load the module like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Defining your widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Dojo's AMD style, there are two main ways to use AMD components. Using
    the `require()` function plays the script once, and then it's done. But if you
    want to create a module that can be used over and over again, you would want to
    `define()` the module, instead. The `define()` function creates one or more custom
    modules to be used by an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `define()` function takes a single argument, which could be any JavaScript
    object. Even `define("Hello World!")` is a valid module definition, though not
    that useful. You can create more useful ones by passing in objects or object constructors
    that perform tasks for your application. Review the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the module picks a random number from one to ten,
    It then returns a module with a `guess()` method that accepts a numeric value.
    Upon calling the `guess()` method, it alerts the user as to whether the guess
    was correct or not.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers entering JavaScript from more classical **Object-oriented** (**OO**)
    languages may have a difficult time embracing the language's prototype-based inheritance.
    In most OO languages, classes are defined at compilation, and sometimes inherit
    properties and methods from other base classes. In JavaScript objects, class-type
    objects are stored within the object's prototype, which holds the same shared
    properties and methods for multiple related objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dojo can ease the transition for these developers when they use the `dojo/_base/declare`
    module. The module creates Dojo-based classes, which can be used by other applications.
    Behind the scenes, it takes a class-like JavaScript object and converts it to
    a prototype-based constructor. This module couples well with the `define()` function
    to create custom `dojo` modules, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `declare()` function takes three arguments: the class name, the parent
    class, and the class properties object. The class name is an optional string that
    can be used to reference the class. The `declare()` function will turn the name
    into a global variable, so that the `dojo/parser` can write it into HTML when
    you reference the `dijit` package with a `data-dojo-type` attribute. If you do
    not plan to use the `dojo/parser` to write your widget into HTML, it''s highly
    recommended that you don''t use the first argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Class Inheritance through Dojo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second argument in the `declare()` function refers to the parent class.
    There are three possible ways to define the parent class. If the class you are
    creating does not have a parent class, it is said to have no inheritance. In that
    case, the parent class argument is null, as in the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second scenario, there is a parent class for the class you are creating.
    The parent could be another AMD module, or another declared item. The following
    example shows this by extending the `dijit/form/Button` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The third possible scenario involves multiple inheritance, where your class
    inherits properties and methods from multiple classes. For that, the parent class
    parameter will also accept an array of objects. The first item in the array is
    considered the base class, which provides the main construction parameters. The
    rest of the items in the list are referred to as "mixins". They don''t necessarily
    provide object construction functionality, but they add properties and methods
    that either complement, or override the existing base class. The following example
    shows multiple inheritance using a few libraries we''ll talk about later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with classes and inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the final argument of the `declare()` statement, the developer defines the
    different properties and methods contained in the class. The object properties
    can be anything from strings and numbers to lists, objects, and functions. Please
    review the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In objects created with the `declare()` statement, you have both static and
    instance properties. **Static** properties are properties that are shared by all
    objects that were created in the same way. **Instance** properties are properties
    that are unique to the object created. Properties defined within the class object
    are considered static, but every property initially assigned either within the
    constructor, or within another method, is considered an instance property.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `showNumber()` method and the `list` properties
    are static, while the `myNumber` property is an instance. That means every `myapp/Fibonacci`
    object will share the `showNumber()` method and the `list` array, but will have
    unique `myNumber` properties. For example, if five `myapp/Fibonacci` objects are
    created, each should contain the list value of `[1, 1, 2, 3, 5]`. Adding one more
    to the list will add to every Fibonacci list. The `myNumber` property is created
    in the constructor, therefore each object will have a unique value for that property.
  prefs: []
  type: TYPE_NORMAL
- en: When a class is created from a parent class, it has access to its parent's properties
    and methods. The new class can also overwrite those methods by having a new method
    with the same name in its constructor. For example, let's say a `HouseCat` object
    inherits from a `Feline` object, and they have their own versions of the `pounce()`
    method, If you call `HouseCat.pounce()`, it will only run the method described
    in `HouseCat`, and not in `Feline`. If you want to run the `Feline.pounce()` method
    within the call to `HouseCat.pounce()`, you would add `this.inherited(arguments)`
    within the `HouseCat.pounce()` method, to show when you want to run the parent
    class method.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Evented modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Evented` module lets your widgets publish events. When your module is declared
    with `Evented` as the parent class, it provides an `emit()` method for broadcasting
    that the event has occurred, and an `on()` method for listening to events. One
    example that can be found in the ArcGIS API would be the drawing toolbar. It doesn't
    display information, but it has the tools necessary to publish events.
  prefs: []
  type: TYPE_NORMAL
- en: The `emit()` method takes two arguments. The first is a string name that describes
    the event, such as `map-loaded` or `records-received`. The second is an object
    created and passed along with the event. The object could be anything you can
    create in JavaScript, but remember to keep the returned content similar, so that
    the methods listening for the event to occur don't miss it.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the _WidgetBase module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `_WidgetBase` module provides the base class necessary to create a `dijit`
    module. In itself, it's not a widget, but you can easily build a widget on top
    of it. The widget created with the `_WidgetBase` module is bound to an element
    in the HTML DOM, which can be referred to with its `domNode` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_WidgetBase` module also introduces a lifecycle to the widget. The lifecycle
    refers to how the widget is created, built up, used, and torn down. This module
    loads the following methods and events that occur within the lifecycle of the
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor`: This method is called on widget creation. There is no access
    to the template, but values can be assigned and arrays can be accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameters mixed into widget instance`: The parameters you passed into the
    object constructor, such as button labels, are added to the widget to overwrite
    any pre-existing values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postMixinProperties`: This is a step prior to rendering the widget HTML. If
    you need to change or correct any values passed into the parameters or something,
    this would be the time to do so.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buildRendering`: This is where the HTML templates are added in place of the
    existing node, if templating is being used. If you''re using the `_TemplatedMixin`
    module, the template string is loaded into the browser, rendered into HTML, and
    inserted in place of the existing `domNode`. Events bound in the HTML data-* attributes
    are assigned here, as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Custom setters are called`: If you have added custom setter functions, these
    will be called at this point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postCreate`: Now that the HTML has been rendered, this function can do more
    with it. Just be warned, the widget HTML may not be connected to the document
    yet. Also, if this widget contains child widgets, they may not have rendered yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startup`: This function can be called after all parsing and child-widget rendering
    has finished. It is usually used when the widget needs to resize itself through
    the `resize()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy`: This function is called when this widget is torn down and removed,
    either by closing the application, or whenever this function is called. The parent
    classes typically handle the tear down events on their own, but if you need to
    do anything unique before destroying the widget, this would be the function to
    extend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_WidgetBase` module has specialized getter and setter functions that allow
    you to perform specific tasks when you set a widget property. You can retrieve
    the values with the `get()` function and set these properties using the `set()`
    function. The first argument of both `get()` and `set()` is the name of the property,
    and the second argument in the `set()` method is the value. So, if you want to
    set the `name` of a widget, you would call `widget.set("name", "New Name")`. There
    is also a `watch()` method that can perform functions when a value changes through
    `set()`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with other _Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `_WidgetBase` module may not provide all the widget functionality your application
    will need. The `dijit` package provides mixins, or JavaScript object extensions,
    for your widget. These mixins can provide HTML templates, event handling for clicks,
    touches, focus, and a lack thereof, for example. Loading the right mixin with
    your application can save you a lot of behavior coding. Let's take a look at some
    of the ones we may use.
  prefs: []
  type: TYPE_NORMAL
- en: Adding _TemplatedMixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `_TemplatedMixin` module lets the module replace its existing HTML content
    with either a string template, or HTML from another source. The widget''s template
    string is assigned through the `templateString` property. This allows the widget
    to skip a possibly complicated `buildRendering` step. You can see an example of
    a `_TemplatedMixin` module call in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `templateString` property is being rendered, properties can pass back
    and forth between template and widget. Widget properties can be written to the
    template during the `buildRendering` phase by referencing the property name in
    the widget, and surrounding it with the `${}` wrapper. You can also assign node
    references and attach widget events using the HTML data attributes. The `data-dojo-attach-point`
    attribute lets the widget have a named property that connects to the template.
    The `data-dojo-attach-event` attribute attaches a `callback` method in the widget
    that is triggered when the event is occurs. You can view the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How should a developer lay out a template widget? The widget's template HTML
    should all be contained in a single HTML element. You can use a `<div>` tags,
    a `<table>` tags, or element tags you plan to enclose the template in. If the
    template contains more than one element at the base layer, the widget will not
    render and throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Adding _OnDijitClickMixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `_OnDijitClickMixin` module provides the ability for elements within your
    template to be "clicked". This works, not only with click events using the mouse,
    but through touch and keyboard events as well. Besides clicking and touching an
    element, the user can tab until the element is highlighted, then press the *Enter*
    or spacebar key to activate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `_OnDijitClickMixin` module is loaded, the developer can add event handlers
    to the `dijit` template through the `data-dojo-attach-event` attribute. Within
    this data attribute text value, add `ondijitclick:` followed by the name of your
    click event handler. You must have this event handler pointing to a valid function,
    or else the whole widget will fail to load. An example of a `dijit` template using
    the `clickMe(event) {}` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, the function within the click event handler should be ready
    to accept a one click event argument, and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: Adding _FocusMixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `_FocusMixin` module provides focus and blur events for your widget and
    its components. For instance, if you have a widget that takes up more room when
    it''s focused, you could add an `_onFocus()` event handler to the object like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when you want your widget to shrink back to its normal size,
    you would add an `_onBlur()` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The event system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event system within JavaScript is an important part of the language. JavaScript
    was designed to respond to events in the browser and events caused by users. A
    website may need to respond to the click of a user, or an AJAX response from a
    server. With the language, you can attach functions called event handlers to listen
    for events from certain elements in the page and the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the Dojo framework, events are listened to using the `dojo/on` module. When
    assigning an event listener, the module function call returns an object that lets
    you discontinue listening by calling the object's `remove()` method. Also, `dojo/on`
    has a `once()` method that fires the event once, when the event occurs, then automatically
    removes the event.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some older ArcGIS API samples still use Dojo's old event handler, `dojo.connect()`.
    Events handlers would be attached with `dojo.connect()`, and removed with `dojo.disconnect()`.
    The Dojo Foundation is currently depreciating `dojo.connect()`, and will drop
    it from their code when Dojo moves to version 2.0\. If you are maintaining old
    code, please start migrating all `dojo.connect()` to `dojo/on`. With the ArcGIS
    API, please pay attention to event names and results returned. Names may change
    from CamelCase to dash-separated, and while `dojo.connect()` can return more than
    one item in its callback, `dojo/on` only returns a single JavaScript object.
  prefs: []
  type: TYPE_NORMAL
- en: Events are created using `emit()`. This function takes in a string name of the
    event, and a JavaScript object you would want to pass to an event listener. The
    `emit()` method is available for widgets using the `dojo/Evented` module, and
    those built using the `dijit/_WidgetBase` module. It is also available through
    the `dojo/on` module, but `dojo/on.emit()` requires an HTML DOM before the event
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a grasp of the Dojo framework, let's build something with it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the basics of creating custom widgets, that is to say, dijits
    for our web applications, let's put our knowledge into practice. In this part
    of the chapter, we will transform the single-page application code we wrote in
    [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First
    Mapping Application* into a dijit that can be used with any map. We'll then use
    that `dijit` in a map application that can be expanded to include other dijits
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Picking up where we left off…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We finally received feedback from the Y2K Society about the census map we created
    in [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First
    Mapping Application*. They liked how the map worked, but felt it could use more
    polish. After a meeting with some group members, here is a list of their feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: The application should have sections at the top and the bottom to show titles
    and a little bit about the society
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colors should be warm and cheery, such as yellows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of the plain black line work of the census layer data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application should let us do more than simply look at census data. It should
    let us click on other buttons to do other things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The census information needs to be more organized and grouped logically in tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to comply with their requests, we will need to reorganize our application
    from [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your
    First Mapping Application*. To fix the issue, we''ll need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will create a new full page app with a header and footer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will modify the style of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will represent the census map service using custom symbology.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will add buttons to the header to launch the census popups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will move the `infoTemplate` data into separate HTML files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The file structure for our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to deliver a map that can do more than just show census data, we're
    going to use the tools provided by the Dojo framework. We'll use elements of Dojo
    to lay out the application, and turn our previous census map tool into its own
    widget. Instead of a single page application, where the HTML, CSS, and JavaScript
    are mashed together in the same file, we're going to separate the files into distinct
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by organizing the project folder. It's a good idea to separate the
    styling and scripts into separate folders. In our project folder, we'll add two
    subfolders to the project folder. We'll name them `css` and `js`, for the stylesheet
    and script files, respectively. Inside the `js` folder, we'll add another folder
    and name it `templates`. This is where our widget templates will go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main project folder, we''ll create an HTML page called `index.html`.
    Next, In the `css` folder, we''ll create a file called `y2k.css`, which will be
    our application stylesheet. We''ll create two JavaScript files in our `js` folder:
    one called `app.js` for our application, and another called `Census.js` for our
    widget. We''ll stub out template files in the `js`/`templates` folder for the
    census widget (`Census.html`), plus some templates for our popups. The files should
    look something like the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The file structure for our application](img/6459OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining the layout with Dojo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle the layout of the application, we'll use a couple of the modules within
    the `dijit/layout` package. This package has a number of UI containers with styled
    looks and built-in UI behavior that we don't have to reinvent. We'll add the layout
    elements and restyle them to fit our client's wishes. Let's look at the layout
    module found within the `dijit` package.
  prefs: []
  type: TYPE_NORMAL
- en: Framing the page with BorderContainer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `BorderContainer` container provides a common layout tool used with Dojo.
    The `BorderContainer` container is extended from the `LayoutContainer` module,
    which creates a layout that fills up the entire browser window without scrolling.
    The `LayoutContainer` module (and by extension, the `BorderContainer` module)
    allows content elements to be placed with a region attribute. The `BorderContainer`
    container adds borders, spacing, and resizing elements called splitters, which
    can be dragged to resize the content items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The regions that can be assigned to content dijits inside the `BorderContainer`
    container are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Center**: This positions the element at the center of the page, relative
    to the other items. One element must be assigned this value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top**: This positions the element above the center element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottom**: This positions the element below the center element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Right**: This positions the element to the right of the center element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Left**: This positions the element to the left of the center element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leading**: If the `dir` attribute of the page is set to "ltr" (left-to-right),
    the leading element is placed to the left of the center element. If the `dir`
    attribute is "rtl" (right-to-left), the leading element is placed on the right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trailing**: Layout is the opposite of the leading element, with "ltr" on
    the right, and "rtl" on the left.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BorderContainer` module, and its parent `LayoutContainer` module, have
    a design parameter that affects the containers surrounding the center element.
    When the `design` parameter is set to its default value of `headline`, the top
    and bottom panels take up the entire width of the container. The right, left,
    leading, and trailing panels shrink to fit between the top and bottom panels.
    Alternatively, you can set the `design` parameter to `sidebar`, and the panels
    on the sides will take up the entire height, while the top and bottom panels are
    squeezed in between them. The following figure shows example pages made with headline
    and sidebar designs. The `design` parameter was the only parameter changed in
    the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Framing the page with BorderContainer](img/6459OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: BorderContainer with 'headline' (left) and 'sidebar' (right) design attributes
    with ContentPanes
  prefs: []
  type: TYPE_NORMAL
- en: Inserting ContentPane
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ContentPane` tile provides the general container used in most desktop Dojo
    pages. `ContentPane` tiles can adjust to fit within their assigned places, and
    can expand and shrink as the user resizes the browser. `ContentPane` tiles can
    house HTML elements, such as other Dojo widgets and controls. They also have an
    `href` attribute which, when set, will load and render the content of another
    HTML page. The pages are loaded via **XMLHttpRequest** (**XHR**), therefore the
    loaded HTML should be on the same domain, due to cross-origin issues.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the layout of our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking at the requirements, we're going to use the `BorderContainer` containers
    and some `ContentPane` tiles to create the header, footer, and the content of
    the application. We'll take a standard HTML template pulling the necessary libraries,
    then add the `dijit` content.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your application''s folder, start by creating an HTML file called `index.html`.
    We''ll title it `Y2K Map`, and add the necessary meta tags and scripts to load
    the ArcGIS API for JavaScript. We''ll also load the dojo CSS stylesheet `nihilo.css`,
    to handle the styling of the base styling of the dojo elements in the application.
    In order to apply the style to our application, we''ll also add a class of `nihilo`
    to the body element of our HTML document. Finally, we''ll add a link to our `y2k.css`
    file, which we''ll create soon. Your HTML document should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the `BorderContainer` container and the `ContentPane` tiles
    inside the body tag. These will be built on basic `<div>` elements. We''ll give
    the `BorderContainer` container an `id` of `mainwindow`, a `ContentPane` tile
    at the top with an `id` of `header`, another `ContentPane` tile with an `id` of
    `map` where our map will go, and a `ContentPane` tile at the bottom with an `id`
    of `footer`. We''ll also add a little content to the header and footer, just to
    make it look nice. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the client wanted a place to add multiple functions, including our census
    search, we''ll add a location for buttons in the upperright-handcorner. We''ll
    create a button containing `<div>`, and insert our census button as a `dijit/form/Button`
    module. Using the `dijit` button will ensure that the styling of the part will
    go along with the styling of the widget. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the files work, we''ll need to add a link to the main script file we''ll
    run for our app. We''ll insert the `app.js` file as the last element inside the
    `<body>` tag, so that loading the file doesn''t cause the browser to block other
    downloads. In the following code, you can see where we insert this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `app.js` file, we''re going to do just enough to get the visuals.
    We''ll add to this file as we go. We''ll start with our normal `require()` statement,
    loading the modules for the `BorderContainer`, `ContentPane`, and `Button` elements.
    We''ll also pull in a module called `dojo/parser`, which will parse the Dojo data-markup
    in the HTML and turn it into application widgets. The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After all that work, our HTML should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Styling our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we run the application at this point, it won't look quite as expected. In
    fact, it'll look a lot like a white screen. That is because we haven't assigned
    a size to our page yet. In this case, the `ContentPane` tile styling creates positioned-looking
    panels, and absolute positioning takes the content out of the calculated page
    flow. Since there was nothing else to fill the height of the body, it collapsed
    to zero height.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick remedy to this issue is to update the styling of the HTML and the body
    tag. Open up `y2k.css` in your text editor and add the following lines of CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This CSS we applied makes the page fill up 100 percent of our browser window.
    Adding the border, margin, and padding takes away any possible formatting that
    different browsers may insert into the page. We added the font size because it's
    good practice to set the font size in pixels at the body level. Further font size
    assignments can be made relative to this, using the `em` unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play your page now, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling our application](img/6459OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s definitely progress, but we need to fulfil the other requirements of
    the application. First, the `#buttonbar` element would look better if we positioned
    it precisely in the top-right, and left a little gap for the **Census** button
    to be centered vertically. Next, we''ll add some yellow hues to the different
    panels, and round off the corners of the header and footer. We''ll end up with
    the following stylized shell for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling our application](img/6459OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make this happen, here''s the CSS we''ll add to our `y2k.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding our custom package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can use our custom package, we need to tell Dojo where it is. To
    do that, we''ll need to add a `dojoConfig` object before we load the ArcGIS JavaScript
    API. In the `dojoConfig` object, we''ll add a package array object, and tell it
    that the `y2k` modules are in the `js` folder. The script should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Setting up our app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to set up our application script and get things moving. We''ll
    open our `app.js` file and add the functionality for our map and our upcoming
    `Census` widget. We''ll start by adding references to the `esri/map` module and
    our `y2k/Census` widget. We''ll initialize our map just as we did in [Chapter
    1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First Mapping
    Application*, and we''ll create a new `Census` widget. Following the pattern of
    many dojo widgets, the `Census` widget constructor will take an options object
    for the first parameter, and a string reference to an HTML node within the `<div>`
    map as the second argument. We''ll fill in the options later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps you are wondering why some of the modules in our code start with capital
    letters, while others do not. Common JavaScript coding convention states that
    object constructors start with capital letters. The `Map` and `Census` modules
    make maps and census widgets, therefore they should be capitalized. Why the reference
    to the `esri/map` module isn't capitalized is a mystery, and a source of errors
    if you get it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Coding our widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to start piecing together our Census widget. To do that, we''ll use
    what we''ve learned about creating custom widgets from earlier in the chapter.
    Within the `Census.js` file, we''ll create a shell widget using the `define()`,
    `declare()`, and `_WidgetBase` modules. It should look something like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For our widget, we''ll want a template that instructs the user how to use the
    tool. It might also be a good idea to let the user close the tool, since we don''t
    want the map to be cluttered with multiple tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we need to load our template into our widget. To do that, we're
    going to implement another dojo module called `dojo/text`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some dojo/text!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dojo/text` module lets the module download any sort of text file as a
    string. The contents can be HTML, text, CSV, or any related text-based file. When
    loading the file using AMD, the format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `filename.extension` describes the file name,
    such as `report.txt`. The path shows the location of the file in relationship
    to the script. So a path of `./templates/file.txt` means that the file is located
    in the `templates` folder, which is a subfolder of the folder where this widget
    script has been located.
  prefs: []
  type: TYPE_NORMAL
- en: The exclamation point in our declaration means that the module has a plugin
    attribute that can automatically be called on load time. Otherwise, we would have
    to wait and call it after the module loaded in our script. Another module where
    we see this is `dojo/domReady`. The exclamation point activates that module, pausing
    our application until the HTML DOM is ready as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our application, it''s time to load our dijit template. The
    `_TemplatedMixin` module provides a property called `templateString`, which it
    reads from to build the HTML portion of the `dijit` package. We''ll use the `dojo/text`
    module to load HTML from our `Census.html` template, then insert the string created
    from that into the `templateString` property. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our dijit template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our template, we're going to take advantage of a few cool tricks in Dojo.
    The first trick is that we can mix property values into our widget through the
    same substitute templating we learned about in [Chapter 1](ch01.html "Chapter 1. Your
    First Mapping Application"), *Your First Mapping Application*. Second, we're going
    to take advantage of the `_OnDijitClickMixin` module to handle click events.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our template, we''re looking at creating something with a title (such as
    "Census"), some instructions, and a `close` button. We''ll assign a close button
    event handler through the `data-dojo-attach-event` attribute using `ondijitclick`.
    We''ll also assign a `baseClass` attribute from the widget to the CSS classes
    in the widget. If you haven''t created the `Census.html` file in your `template`
    folder, do so now. Then, enter the following HTML content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What errors in the template could possibly cause the widget not to load? If
    you are incorporating events, through the `data-dojo-attach-event` parameter,
    make sure the callback function in the template matches the name of the callback
    function in your dijit. Otherwise, the dijit will fail to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our code, we''ll assign a `baseClass` property, as well as functions
    for `hide()` and `show()`. Many dijits use those functions to control their visibility.
    Through those functions, we''ll set the display style attribute to either `none`
    or `block`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Working with the dijit constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll need to add onto the `dijit` constructor function, but first we need to
    think about what this dijit needs. Our original purpose for the dijit was to let
    the user click on the map and identify census locations. So, we'll need a map,
    and since we're identifying something, we'll need to supply a map service URL
    to the constructor of the `IdentifyTask` object.
  prefs: []
  type: TYPE_NORMAL
- en: Following the trends of most `dijit` constructors, our `dijit` constructor will
    accept an options object, and either an HTML DOM node, or a string `id` for that
    node. In the options object, we'll look for a map, and a `mapService` URL. The
    second argument in the constructor will be assigned as the dijit's `domNode`,
    or if it's a string, the appropriate node will be found based off the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our constructor, we''ll incorporate the map into the widget, and turn the
    `mapService` into an `IdentifyTask`. We''ll also add the `dojo/dom` module to
    provide a shortcut for the common JavaScript operation `document.getElementById()`,
    and use that to transform a string `id` into a DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Reusing our old code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking back at [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"),
    *Your First Mapping Application*, we were able to check out the map, click on
    it, and get some results. Wouldn't it be great if we could reuse some of that
    code? Well, with a few changes, we can reuse a lot of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to tackle is assigning our map click event. Since we
    don''t get to do it all the time, the most logical time to assign the map click
    event is when our dijit is visible. We''ll modify our show and hide functions
    so that they assign and remove the click handler, respectively. We''ll name the
    map-click event handler `_onMapClick()`. We''re also going to load the module
    `dojo/_base/lang`, which helps us with objects. We''ll use the `lang.hitch()`
    function to reassign a function''s `this` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, while JavaScript doesn't support private variables, the typical
    naming convention for JavaScript objects states that, if a property or method
    starts with an underscore (`_`) character, it's considered private by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our`_onMapClick()` method, we''ll reuse the click event code from [Chapter
    1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First Mapping
    Application*, with a few notable exceptions. Remember now that we''re not referencing
    the map as a variable, but as a property of the widget. The same thing is true
    for the `IdentifyTask`, and any other methods we may call in this dijit. To refer
    to properties and methods within a method, the variable must be preceded by `this`.
    In this case, this will refer to the widget, which we made sure of when we used
    the `dojo/_base/lang` library on the `_onMapClick()` call. If your application
    fails at the map click event, it''s probably because you didn''t properly assign
    the variable with the correct `this` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Loading more templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Y2K society had requested that we display the popups as something more organized
    and logical. In our web developer minds, nothing screams organized data more than
    a table. We can set up and organize tables for our templates, but creating those
    long strings to organize a long list of results would be daunting. Having HTML
    strings in our JavaScript code would be a pain to edit, since most IDEs and syntax-highlighting
    text editors don't highlight HTML in our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then we remember that we can load HTML into our JavaScript using the `dojo/text`
    module. If we define the content of our `InfoTemplates` using little HTML snippets,
    and load them using `dojo/text`, the process will be much more streamlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: I'll leave the contents of the HTML `infoTemplates` up to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our app.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We didn''t forget about our `app.js` file. We stubbed out the code for loading
    the map and the `Census` dijit, but we didn''t assign anything else. We need to
    assign a click event handler for `Census` button to toggle the visibility of the
    `Census` widget. For that, we''ll use the `dijit/registry` module to load the
    `dijit` button from its `id`. We''ll load the map and the `mapService` for the
    `Census` dijit, and add an event listener to the `Census` button click event that
    will show the `Census` widget. We''ll use the `dojo/_base/lang` module again to
    make sure the `Census.show()` function is properly applied to the `Census` dijit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our code, it should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to our app.js](img/6459OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we have learned about many of the features
    offered by the Dojo framework, which is packaged with the ArcGIS API for JavaScript.
    We've learned about the three major packages in Dojo, and how to use them to create
    applications. We learned how to create our own modules, and we modified an existing
    application to make a module that could be imported into any application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how the ArcGIS API for JavaScript communicates
    with ArcGIS Server through REST services.
  prefs: []
  type: TYPE_NORMAL
