- en: Chapter 3. The Dojo Widget System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. Dojo 小部件系统
- en: The developers at Esri created the ArcGIS JavaScript API using the Dojo framework.
    Dojo provides a large assortment of tools, libraries, and UI controls that work
    across multiple browsers. Any developer can create custom applications with UI
    elements that work well together using Dojo and the ArcGIS JavaScript API. Also,
    Dojo provides the AMD tools necessary to develop your own custom widgets, libraries,
    and controls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Esri 的开发者使用 Dojo 框架创建了 ArcGIS JavaScript API。Dojo 提供了大量工具、库和 UI 控件，这些控件可以在多个浏览器中工作。任何开发者都可以使用
    Dojo 和 ArcGIS JavaScript API 创建具有良好协作的 UI 元素的自定义应用程序。此外，Dojo 还提供了开发自己的自定义小部件、库和控件的
    AMD 工具。
- en: In the previous chapters, we've reviewed the ArcGIS API for JavaScript, and
    we've written a small application using the API. We've even incorporated some
    basic principles of AMD into a single page application. What we've done so far
    would work great with a smaller application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经回顾了 ArcGIS API for JavaScript，并使用该 API 编写了一个小型应用程序。我们甚至将 AMD 的基本原理整合到了一个单页应用程序中。到目前为止我们所做的一切对于一个小型应用程序来说都非常适用。
- en: But what happens when applications get larger? Are we going to implement a single
    script to load all the components we need for a larger application? How are we
    going to extend the functionality of our website? What if we update our libraries
    and something breaks? Are we going to hunt through several thousand lines of code
    in one monolithic JavaScript file to find the parts that need to be changed?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当应用程序变得更大时会发生什么？我们是否要实现一个单独的脚本以加载更大应用程序所需的全部组件？我们将如何扩展我们网站的功能？如果我们更新了库而某些东西出了问题怎么办？我们是否要在单个
    JavaScript 文件中的数千行代码中查找需要更改的部分？
- en: 'In this chapter, we''ll take advantage of the Dojo framework and create a custom
    widget for our application. Through that process, we''ll cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用 Dojo 框架为我们的应用程序创建一个自定义小部件。通过这个过程，我们将涵盖以下内容：
- en: The background of the Dojo framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dojo 框架的背景
- en: What the `dojo`, `dijit`, and `dojox` module packages have to offer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dojo`、`dijit` 和 `dojox` 模块包提供的内容'
- en: How to create and use our own custom modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用我们自己的自定义模块
- en: How to create widgets (modules with UI components), and how to extend them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建小部件（具有 UI 组件的模块），以及如何扩展它们
- en: A brief history of the Dojo framework
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dojo 框架的简要历史
- en: The Dojo framework began in 2004 with initial work at Informatica. Alex Russell,
    David Schontzler, and Dylan Schiemann contributed the first lines of code for
    the project. As work on the code continued, other developers were brought in and
    lent their input into the direction of the framework. The project grew so large
    that the founders created the Dojo Foundation to oversee the codebase and its
    intellectual properties. Since then, over 60 developers have contributed to the
    framework, and companies such as IBM and SitePen continue to use it today. For
    more information, visit at [http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html](http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Dojo 框架始于 2004 年，最初在 Informatica 进行工作。Alex Russell、David Schontzler 和 Dylan
    Schiemann 为该项目贡献了第一行代码。随着代码工作的继续，其他开发者被引入并提供了对框架方向的反馈。项目变得如此之大，以至于创始人创建了 Dojo
    基金会来监督代码库及其知识产权。从那时起，超过 60 名开发者为框架做出了贡献，IBM 和 SitePen 等公司至今仍在使用它。更多信息，请访问 [http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html](http://dojotoolkit.org/reference-guide/1.10/quickstart/introduction/history.html)。
- en: So what makes Dojo a framework, as opposed to a library? When this question
    was posed to the people at stack overflow ([http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library](http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library)),
    the most agreed upon answer centered on an inversion of control. When we use tools
    in a library, our code controls the flow of logic and activity. When we calculate
    a value, we update that value in each location that it's needed through our code.
    In a framework, however, the framework controls the behavior of the application.
    When a value is updated in a framework, it is the framework that updates that
    value wherever it is bound on the web page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么让 Dojo 成为一个框架，而不是一个库呢？当这个问题被提出给 Stack Overflow 的人时 ([http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library](http://stackoverflow.com/questions/3057526/framework-vs-toolkit-vs-library))，最一致的答案集中在控制反转上。当我们使用库中的工具时，我们的代码控制逻辑和活动的流程。当我们计算一个值时，我们通过我们的代码在需要该值的所有位置更新该值。然而，在框架中，框架控制应用程序的行为。当框架中的值被更新时，框架会在网页上绑定该值的任何位置更新该值。
- en: The Dojo framework provides a number of HTML-based controls that we can load
    and use. Much in the way of CSS appearances and JavaScript behavior, is prewired
    into the control. After initial setup, our code instructs the framework where
    to send data when specific control events occur. We have no control when our functions
    are called, only what happens after they're called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Dojo 框架提供了一些基于 HTML 的控件，我们可以加载和使用。CSS 外观和 JavaScript 行为的大部分内容都预先集成到控件中。在初始设置之后，我们的代码指示框架在特定控件事件发生时将数据发送到何处。当我们的函数被调用时，我们没有控制权，只有调用之后发生的事情。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to read more about frameworks and the inversion of control, Martin
    Fowler provides a good explanation of the subject on his blog at [http://martinfowler.com/bliki/InversionOfControl.html](http://martinfowler.com/bliki/InversionOfControl.html).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于框架和控制反转的信息，Martin Fowler 在他的博客上提供了对这个主题的良好解释，请访问 [http://martinfowler.com/bliki/InversionOfControl.html](http://martinfowler.com/bliki/InversionOfControl.html)。
- en: Introducing dojo, dijit, and dojox
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 dojo、dijit 和 dojox
- en: 'Great care has been taken to organize the Dojo framework. When Dojo incorporated
    the AMD style of modules, many of the objects, methods, and properties were reorganized
    into logical folders and modules. Dojo is broken down into three main packages:
    **dojo**, **dijit**, and **dojox**. Let''s get an idea of what these three packages
    bring to the framework.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Dojo 框架的组织非常用心。当 Dojo 集成 AMD 模块风格时，许多对象、方法和属性都被重新组织到逻辑文件夹和模块中。Dojo 被分解为三个主要包：**dojo**、**dijit**
    和 **dojox**。让我们了解这三个包为框架带来了什么。
- en: The dojo package
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The dojo package
- en: The `dojo` package provides much of the base functionality needed to load, run,
    and tear down the various modules in our applications. The modules provide functions
    and tools that work across multiple browsers, including the dreaded older versions
    of Internet Explorer. For example, the developer doesn't have to handle events
    by trying `addEventListener()` for Chrome and `attachEvent()` for older IE, because
    it's handled behind the scenes by `dojo/on`. With the framework, you can get away
    from all the browser hacks, and focus on creating a good application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`dojo` 包提供了加载、运行和卸载我们应用程序中各种模块所需的大部分基本功能。这些模块提供了跨多个浏览器（包括令人讨厌的旧版 Internet Explorer）工作的函数和工具。例如，开发者不需要通过尝试
    `addEventListener()`（用于 Chrome）和 `attachEvent()`（用于旧版 IE）来处理事件，因为 `dojo/on` 在幕后处理这些。有了这个框架，您可以摆脱所有的浏览器黑客技术，专注于创建一个好的应用程序。'
- en: The `dojo` package does not contain widgets, but it does contain the tools necessary
    to manipulate things within the widgets. Do you need to handle mouse clicks and
    touch events? Use the `dojo/mouse` and `dojo/touch` modules. Do you need a jQuery-like
    selector for your HTML? Load the `dojo/query` module. The dojo package provides
    modules for HTML DOM manipulation, arrays, AJAX, dates, event, and i18n, just
    to name a few.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`dojo` 包不包含小部件，但它包含操作小部件内事物所需的工具。您需要处理鼠标点击和触摸事件吗？请使用 `dojo/mouse` 和 `dojo/touch`
    模块。您需要一个类似 jQuery 的选择器来选择您的 HTML 吗？请加载 `dojo/query` 模块。`dojo` 包提供了用于 HTML DOM
    操作、数组、AJAX、日期、事件和 i18n 的模块，仅举几例。'
- en: The dijit package
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The dijit package
- en: The `dijit` package provides visual elements (referred to as **dijits**) that
    integrate well with the `dojo` package. The elements created with the `dijit`
    package have been tested across multiple browsers. They provide a consistent user
    interface based on the CSS stylesheets loaded with the library.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`dijit` 包提供了与 `dojo` 包良好集成的视觉元素（称为 **dijits**）。使用 `dijit` 包创建的元素已在多个浏览器上进行了测试。它们基于库中加载的
    CSS 样式表提供了一致的用户界面。'
- en: 'As the Dojo framework is used and contributed to by many companies and developers,
    there are plenty of user controls available. Whether you''re creating a submission
    form, a calendar of events, or an executive dashboard, you can combine the dijits
    in this package in a way that suits your needs. Some of the more popular packages
    include:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Dojo 框架被许多公司和开发者使用和贡献，因此有大量的用户控件可供选择。无论你是在创建提交表单、事件日历还是执行仪表板，你都可以以适合你需求的方式组合这个包中的
    dijits。一些更受欢迎的包包括：
- en: '`dijit/Calendar`: This provides an interactive HTML calendar control that works
    on both desktops and tablets.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dijit/Calendar`：这提供了一个在桌面和平板电脑上都能工作的交互式 HTML 日历控件。'
- en: '`dijit/form`: A package containing stylized form elements such as buttons,
    checkboxes, dropdown menus, textboxes, and sliders. The form elements have a consistent
    look across older and newer browsers.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dijit/form`：一个包含按钮、复选框、下拉菜单、文本框和滑块等样式化表单元素的包。这些表单元素在旧版和新版浏览器中具有一致的样式。'
- en: '`dijit/layout`: A package containing controls that handle layouts. You can
    create simple containers, tab containers, accordion containers, and even containers
    that control the positions of other containers.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dijit/layout`：一个包含处理布局的控件的包。你可以创建简单的容器、标签容器、手风琴容器，甚至可以控制其他容器位置的容器。'
- en: '`dijit/Tree`: A module that creates a collapsible tree menu which could be
    used, for instance, to show folder layouts.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dijit/Tree`：一个创建可折叠树菜单的模块，例如，可以用来显示文件夹布局。'
- en: The `dijit` package contains more than user controls. It also provides the tools
    necessary to create your own custom dijits. Using the `dijit/_WidgetBase` module
    and assorted mixins, you can incorporate both HTML elements and existing dijits
    into your own custom `dijit`. Working with the `dijit` components can give the
    user a consistent experience throughout the entire application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`dijit` 包不仅包含用户控件，还提供了创建自定义 dijits 所需的工具。使用 `dijit/_WidgetBase` 模块和混合，你可以将
    HTML 元素和现有的 dijits 集成到自己的自定义 `dijit` 中。与 `dijit` 组件一起工作可以为用户提供在整个应用程序中一致的使用体验。'
- en: The dojox package
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dojox 包
- en: According to documentation on the Dojo framework ([http://dojotoolkit.org/reference-guide/1.10/dojox/info.html](http://dojotoolkit.org/reference-guide/1.10/dojox/info.html)),
    `dojox` provides extensions to Dojo. This part of the library deals with more
    experimental functionality, user interfaces, and testing features. Many parts
    of the library have matured due to extensive use, while other parts have been
    depreciated and are not under active development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关于 Dojo 框架的文档（[http://dojotoolkit.org/reference-guide/1.10/dojox/info.html](http://dojotoolkit.org/reference-guide/1.10/dojox/info.html)），`dojox`
    为 Dojo 提供了扩展。这部分库处理更多实验性功能、用户界面和测试功能。由于广泛的使用，库的许多部分已经成熟，而其他部分已被弃用，并且不再处于积极开发中。
- en: One of the useful subpackages in the `dojox` package is `dojox/mobile`. The
    `Dojox/mobile` package provides UI elements and controls that you can use in mobile
    applications. They have been tested on a wide variety of mobile browsers, and
    their styling can even mimic the style of native smartphone and tablet applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`dojox` 包中的一个有用子包是 `dojox/mobile`。`Dojox/mobile` 包提供了可用于移动应用程序的 UI 元素和控制。它们已在各种移动浏览器上进行了测试，其样式甚至可以模仿原生智能手机和平板电脑应用程序的样式。'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information regarding the `dojo`, `dijit`, and `dojox` packages in
    the Dojo framework, you can view tutorial documentation by going to: [http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/](http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解 Dojo 框架中 `dojo`、`dijit` 和 `dojox` 包的更多信息，您可以访问教程文档：[http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/](http://dojotoolkit.org/documentation/tutorials/1.10/beyond_dojo/)。
- en: The dojoConfig packages
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DojoConfig 包
- en: 'Using the built-in Dojo packages is great and all, but what about making your
    own custom package? You can create custom packages in your local folders, and
    reference them through your `dojoConfig` object. In the `dojoConfig` object, you
    can add a packages parameter that contains an array of JavaScript objects. Those
    package objects should contain a name attribute, which is a reference to your
    package, and a location attribute, which references the folder location. Here''s
    an example of a `dojoConfig` object with a reference to a custom package:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的Dojo包是很好，但关于创建自己的自定义包怎么办？你可以在本地文件夹中创建自定义包，并通过`dojoConfig`对象引用它们。在`dojoConfig`对象中，你可以添加一个包含JavaScript对象数组的`packages`参数。这些包对象应该包含一个`name`属性，它是您包的引用，以及一个`location`属性，它是文件夹位置的引用。以下是一个包含对自定义包引用的`dojoConfig`对象示例：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding sample, the package `myapp` is referenced, and all the files
    for that package are loaded into the `myapp` folder under the current page. So,
    if this page was shown at `http://www.example.com/testmap/`, the `myapp` package
    could be found at `http://www.example.com/testmap/myapp`. When referencing the
    `Something` module in your `myapp` package, you would load the module like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，引用了`myapp`包，并且该包的所有文件都被加载到当前页面的`myapp`文件夹下。因此，如果这个页面在`http://www.example.com/testmap/`显示，那么`myapp`包可以在`http://www.example.com/testmap/myapp`找到。当在您的`myapp`包中引用`Something`模块时，您将按如下方式加载模块：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Defining your widget
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义您的部件
- en: With Dojo's AMD style, there are two main ways to use AMD components. Using
    the `require()` function plays the script once, and then it's done. But if you
    want to create a module that can be used over and over again, you would want to
    `define()` the module, instead. The `define()` function creates one or more custom
    modules to be used by an application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dojo的AMD风格，有两种主要方式来使用AMD组件。使用`require()`函数只播放一次脚本，然后完成。但如果你想要创建一个可以重复使用的模块，你将想要`define()`该模块。`define()`函数创建一个或多个自定义模块，供应用程序使用。
- en: 'The `define()` function takes a single argument, which could be any JavaScript
    object. Even `define("Hello World!")` is a valid module definition, though not
    that useful. You can create more useful ones by passing in objects or object constructors
    that perform tasks for your application. Review the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`define()`函数接受一个单一参数，它可以是任何JavaScript对象。即使是`define("Hello World!")`也是一个有效的模块定义，尽管不是那么有用。你可以通过传递执行应用程序任务的函数或对象构造函数来创建更有用的模块。请参阅以下示例：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the module picks a random number from one to ten,
    It then returns a module with a `guess()` method that accepts a numeric value.
    Upon calling the `guess()` method, it alerts the user as to whether the guess
    was correct or not.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，该模块从一到十中随机选择一个数字，然后返回一个带有`guess()`方法的模块，该方法接受一个数值。调用`guess()`方法时，它会向用户提示猜测是否正确。
- en: Declaring modules
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明模块
- en: Developers entering JavaScript from more classical **Object-oriented** (**OO**)
    languages may have a difficult time embracing the language's prototype-based inheritance.
    In most OO languages, classes are defined at compilation, and sometimes inherit
    properties and methods from other base classes. In JavaScript objects, class-type
    objects are stored within the object's prototype, which holds the same shared
    properties and methods for multiple related objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从更传统的**面向对象**（**OO**）语言进入JavaScript的开发者可能难以接受这种语言基于原型的继承机制。在大多数面向对象的语言中，类是在编译时定义的，有时会从其他基类继承属性和方法。在JavaScript对象中，类类型的对象存储在对象的原型中，这些原型为多个相关对象持有相同的共享属性和方法。
- en: 'Dojo can ease the transition for these developers when they use the `dojo/_base/declare`
    module. The module creates Dojo-based classes, which can be used by other applications.
    Behind the scenes, it takes a class-like JavaScript object and converts it to
    a prototype-based constructor. This module couples well with the `define()` function
    to create custom `dojo` modules, like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些开发者使用`dojo/_base/declare`模块时，Dojo可以帮助他们更容易地过渡。该模块创建基于Dojo的类，这些类可以被其他应用程序使用。在幕后，它将类似类的JavaScript对象转换为基于原型的构造函数。此模块与`define()`函数很好地配合，用于创建自定义的`dojo`模块，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `declare()` function takes three arguments: the class name, the parent
    class, and the class properties object. The class name is an optional string that
    can be used to reference the class. The `declare()` function will turn the name
    into a global variable, so that the `dojo/parser` can write it into HTML when
    you reference the `dijit` package with a `data-dojo-type` attribute. If you do
    not plan to use the `dojo/parser` to write your widget into HTML, it''s highly
    recommended that you don''t use the first argument.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare()` 函数接受三个参数：类名、父类和类属性对象。类名是一个可选的字符串，可以用来引用类。`declare()` 函数会将该名称转换为全局变量，以便当你在
    `data-dojo-type` 属性中引用 `dijit` 包时，`dojo/parser` 可以将其写入 HTML。如果你不打算使用 `dojo/parser`
    将你的小部件写入 HTML，强烈建议你不要使用第一个参数。'
- en: Class Inheritance through Dojo
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Dojo 进行类继承
- en: 'The second argument in the `declare()` function refers to the parent class.
    There are three possible ways to define the parent class. If the class you are
    creating does not have a parent class, it is said to have no inheritance. In that
    case, the parent class argument is null, as in the following statement:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare()` 函数的第二个参数指的是父类。定义父类有三种可能的方式。如果你创建的类没有父类，则称其没有继承。在这种情况下，父类参数为 null，如下面的语句所示：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the second scenario, there is a parent class for the class you are creating.
    The parent could be another AMD module, or another declared item. The following
    example shows this by extending the `dijit/form/Button` module:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种场景中，你创建的类有一个父类。这个父类可以是另一个 AMD 模块，或者另一个已声明的项。以下示例通过扩展 `dijit/form/Button`
    模块来展示这一点：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The third possible scenario involves multiple inheritance, where your class
    inherits properties and methods from multiple classes. For that, the parent class
    parameter will also accept an array of objects. The first item in the array is
    considered the base class, which provides the main construction parameters. The
    rest of the items in the list are referred to as "mixins". They don''t necessarily
    provide object construction functionality, but they add properties and methods
    that either complement, or override the existing base class. The following example
    shows multiple inheritance using a few libraries we''ll talk about later:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种可能的情况涉及多重继承，其中你的类从多个类继承属性和方法。为此，父类参数也将接受一个对象数组。数组中的第一个项目被认为是基类，它提供了主要的构造参数。列表中的其余项目被称为“混合”。它们不一定提供对象构造功能，但它们添加了属性和方法，这些属性和方法要么补充，要么覆盖现有的基类。以下示例展示了使用我们稍后将要讨论的几个库进行多重继承：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Dealing with classes and inheritance
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理类和继承
- en: 'In the final argument of the `declare()` statement, the developer defines the
    different properties and methods contained in the class. The object properties
    can be anything from strings and numbers to lists, objects, and functions. Please
    review the following code example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `declare()` 语句的最后一个参数中，开发者定义了类中包含的不同属性和方法。对象属性可以是字符串、数字、列表、对象或函数。请查阅以下代码示例：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In objects created with the `declare()` statement, you have both static and
    instance properties. **Static** properties are properties that are shared by all
    objects that were created in the same way. **Instance** properties are properties
    that are unique to the object created. Properties defined within the class object
    are considered static, but every property initially assigned either within the
    constructor, or within another method, is considered an instance property.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `declare()` 语句创建的对象中，你既有静态属性也有实例属性。**静态**属性是所有以相同方式创建的对象共享的属性。**实例**属性是创建的对象独有的属性。在类对象内部定义的属性被认为是静态的，但最初在构造函数或另一个方法中分配的每个属性都被认为是实例属性。
- en: In the preceding example, the `showNumber()` method and the `list` properties
    are static, while the `myNumber` property is an instance. That means every `myapp/Fibonacci`
    object will share the `showNumber()` method and the `list` array, but will have
    unique `myNumber` properties. For example, if five `myapp/Fibonacci` objects are
    created, each should contain the list value of `[1, 1, 2, 3, 5]`. Adding one more
    to the list will add to every Fibonacci list. The `myNumber` property is created
    in the constructor, therefore each object will have a unique value for that property.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`showNumber()` 方法和 `list` 属性是静态的，而 `myNumber` 属性是一个实例。这意味着每个 `myapp/Fibonacci`
    对象将共享 `showNumber()` 方法和 `list` 数组，但将具有独特的 `myNumber` 属性。例如，如果创建了五个 `myapp/Fibonacci`
    对象，每个对象都应该包含列表值 `[1, 1, 2, 3, 5]`。向列表中添加一个新元素将添加到每个斐波那契列表中。`myNumber` 属性是在构造函数中创建的，因此每个对象都将具有该属性的独特值。
- en: When a class is created from a parent class, it has access to its parent's properties
    and methods. The new class can also overwrite those methods by having a new method
    with the same name in its constructor. For example, let's say a `HouseCat` object
    inherits from a `Feline` object, and they have their own versions of the `pounce()`
    method, If you call `HouseCat.pounce()`, it will only run the method described
    in `HouseCat`, and not in `Feline`. If you want to run the `Feline.pounce()` method
    within the call to `HouseCat.pounce()`, you would add `this.inherited(arguments)`
    within the `HouseCat.pounce()` method, to show when you want to run the parent
    class method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当从父类创建一个类时，它可以访问其父类的属性和方法。新类也可以通过在其构造函数中拥有同名的新方法来覆盖这些方法。例如，假设一个 `HouseCat` 对象继承自
    `Feline` 对象，并且它们都有自己的 `pounce()` 方法版本，如果你调用 `HouseCat.pounce()`，它将只运行 `HouseCat`
    中描述的方法，而不是 `Feline` 中的方法。如果你想在 `HouseCat.pounce()` 调用中运行 `Feline.pounce()` 方法，你可以在
    `HouseCat.pounce()` 方法中添加 `this.inherited(arguments)`，以显示你想要运行父类方法的时间。
- en: Working with Evented modules
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Evented 模块一起工作
- en: The `Evented` module lets your widgets publish events. When your module is declared
    with `Evented` as the parent class, it provides an `emit()` method for broadcasting
    that the event has occurred, and an `on()` method for listening to events. One
    example that can be found in the ArcGIS API would be the drawing toolbar. It doesn't
    display information, but it has the tools necessary to publish events.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Evented` 模块允许你的小部件发布事件。当你的模块以 `Evented` 作为父类声明时，它提供了一个 `emit()` 方法来广播事件已发生，以及一个
    `on()` 方法来监听事件。在 ArcGIS API 中可以找到一个例子，那就是绘图工具栏。它不显示信息，但它有发布事件的必要工具。'
- en: The `emit()` method takes two arguments. The first is a string name that describes
    the event, such as `map-loaded` or `records-received`. The second is an object
    created and passed along with the event. The object could be anything you can
    create in JavaScript, but remember to keep the returned content similar, so that
    the methods listening for the event to occur don't miss it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`emit()` 方法接受两个参数。第一个是一个描述事件的字符串名称，例如 `map-loaded` 或 `records-received`。第二个是与事件一起创建和传递的对象。该对象可以是你在
    JavaScript 中创建的任何内容，但请记住保持返回内容相似，这样监听事件发生的方法就不会错过它。'
- en: An overview of the _WidgetBase module
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`_WidgetBase` 模块的概述'
- en: The `_WidgetBase` module provides the base class necessary to create a `dijit`
    module. In itself, it's not a widget, but you can easily build a widget on top
    of it. The widget created with the `_WidgetBase` module is bound to an element
    in the HTML DOM, which can be referred to with its `domNode` attribute.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`_WidgetBase` 模块提供了创建 `dijit` 模块所需的基类。它本身不是一个小部件，但你可以很容易地在它上面构建一个小部件。使用 `_WidgetBase`
    模块创建的小部件绑定到 HTML DOM 中的一个元素，可以通过其 `domNode` 属性来引用。'
- en: 'The `_WidgetBase` module also introduces a lifecycle to the widget. The lifecycle
    refers to how the widget is created, built up, used, and torn down. This module
    loads the following methods and events that occur within the lifecycle of the
    widget:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`_WidgetBase` 模块还引入了小部件的生命周期。生命周期指的是小部件的创建、构建、使用和销毁的方式。此模块加载以下在生命周期中发生的方法和事件：'
- en: '`constructor`: This method is called on widget creation. There is no access
    to the template, but values can be assigned and arrays can be accessed.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`: 这个方法在创建小部件时被调用。无法访问模板，但可以分配值和访问数组。'
- en: '`parameters mixed into widget instance`: The parameters you passed into the
    object constructor, such as button labels, are added to the widget to overwrite
    any pre-existing values.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`混合到小部件实例中的参数`：你传递给对象构造函数的参数，如按钮标签，被添加到小部件中，以覆盖任何现有的值。'
- en: '`postMixinProperties`: This is a step prior to rendering the widget HTML. If
    you need to change or correct any values passed into the parameters or something,
    this would be the time to do so.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postMixinProperties`：这是渲染小部件 HTML 之前的一个步骤。如果您需要更改或纠正传递给参数的任何值，或者进行其他操作，这将是一个进行这些操作的好时机。'
- en: '`buildRendering`: This is where the HTML templates are added in place of the
    existing node, if templating is being used. If you''re using the `_TemplatedMixin`
    module, the template string is loaded into the browser, rendered into HTML, and
    inserted in place of the existing `domNode`. Events bound in the HTML data-* attributes
    are assigned here, as well.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildRendering`：如果正在使用模板，这是在现有节点中添加 HTML 模板的地方。如果您正在使用 `_TemplatedMixin` 模块，模板字符串将被加载到浏览器中，渲染成
    HTML，并插入到现有的 `domNode` 位置。绑定在 HTML 数据-* 属性中的事件也在这里分配。'
- en: '`Custom setters are called`: If you have added custom setter functions, these
    will be called at this point.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Custom setters are called`：如果您添加了自定义设置函数，这些函数将在此时被调用。'
- en: '`postCreate`: Now that the HTML has been rendered, this function can do more
    with it. Just be warned, the widget HTML may not be connected to the document
    yet. Also, if this widget contains child widgets, they may not have rendered yet.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postCreate`：现在 HTML 已经渲染，这个函数可以对其进行更多操作。但请注意，小部件的 HTML 可能尚未连接到文档。此外，如果这个小部件包含子小部件，它们可能尚未渲染。'
- en: '`startup`: This function can be called after all parsing and child-widget rendering
    has finished. It is usually used when the widget needs to resize itself through
    the `resize()` method.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startup`：这个函数可以在所有解析和子小部件渲染完成后被调用。它通常用于小部件需要通过 `resize()` 方法调整大小时。'
- en: '`destroy`: This function is called when this widget is torn down and removed,
    either by closing the application, or whenever this function is called. The parent
    classes typically handle the tear down events on their own, but if you need to
    do anything unique before destroying the widget, this would be the function to
    extend.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`：当这个小部件被拆解并移除时，无论是关闭应用程序还是调用此函数时，都会调用此函数。父类通常自行处理拆解事件，但如果您在销毁小部件之前需要执行任何独特操作，这将是一个扩展函数的好时机。'
- en: The `_WidgetBase` module has specialized getter and setter functions that allow
    you to perform specific tasks when you set a widget property. You can retrieve
    the values with the `get()` function and set these properties using the `set()`
    function. The first argument of both `get()` and `set()` is the name of the property,
    and the second argument in the `set()` method is the value. So, if you want to
    set the `name` of a widget, you would call `widget.set("name", "New Name")`. There
    is also a `watch()` method that can perform functions when a value changes through
    `set()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`_WidgetBase` 模块提供了专门的获取和设置函数，允许您在设置小部件属性时执行特定任务。您可以使用 `get()` 函数检索值，并使用 `set()`
    函数设置这些属性。`get()` 和 `set()` 的第一个参数是属性的名称，而 `set()` 方法中的第二个参数是值。因此，如果您想设置小部件的 `name`，您将调用
    `widget.set("name", "New Name")`。还有一个 `watch()` 方法，可以在通过 `set()` 改变值时执行函数。'
- en: Working with other _Mixins
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他 `_Mixins` 一起工作
- en: The `_WidgetBase` module may not provide all the widget functionality your application
    will need. The `dijit` package provides mixins, or JavaScript object extensions,
    for your widget. These mixins can provide HTML templates, event handling for clicks,
    touches, focus, and a lack thereof, for example. Loading the right mixin with
    your application can save you a lot of behavior coding. Let's take a look at some
    of the ones we may use.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`_WidgetBase` 模块可能无法提供您应用程序所需的所有小部件功能。`dijit` 包为您的提供了混合，或 JavaScript 对象扩展，用于小部件。这些混合可以提供
    HTML 模板、点击、触摸、聚焦以及无聚焦的事件处理，例如。使用正确的混合与您的应用程序可以节省大量的行为编码。让我们看看我们可能会使用的一些混合。'
- en: Adding _TemplatedMixin
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `_TemplatedMixin`
- en: 'The `_TemplatedMixin` module lets the module replace its existing HTML content
    with either a string template, or HTML from another source. The widget''s template
    string is assigned through the `templateString` property. This allows the widget
    to skip a possibly complicated `buildRendering` step. You can see an example of
    a `_TemplatedMixin` module call in the following code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`_TemplatedMixin` 模块允许模块用字符串模板或来自另一个来源的 HTML 替换其现有的 HTML 内容。小部件的模板字符串通过 `templateString`
    属性分配。这允许小部件跳过可能复杂的 `buildRendering` 步骤。您可以在以下代码片段中看到一个 `_TemplatedMixin` 模块的调用示例：'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the `templateString` property is being rendered, properties can pass back
    and forth between template and widget. Widget properties can be written to the
    template during the `buildRendering` phase by referencing the property name in
    the widget, and surrounding it with the `${}` wrapper. You can also assign node
    references and attach widget events using the HTML data attributes. The `data-dojo-attach-point`
    attribute lets the widget have a named property that connects to the template.
    The `data-dojo-attach-event` attribute attaches a `callback` method in the widget
    that is triggered when the event is occurs. You can view the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `templateString` 属性的渲染，属性可以在模板和小部件之间来回传递。在 `buildRendering` 阶段，可以通过在组件中引用属性名并在其周围使用
    `${}` 包装器来将小部件属性写入模板。你还可以使用HTML数据属性分配节点引用并附加小部件事件。`data-dojo-attach-point` 属性允许小部件有一个命名属性，该属性连接到模板。`data-dojo-attach-event`
    属性在小部件中附加一个当事件发生时被触发的 `callback` 方法。你可以查看以下示例：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: How should a developer lay out a template widget? The widget's template HTML
    should all be contained in a single HTML element. You can use a `<div>` tags,
    a `<table>` tags, or element tags you plan to enclose the template in. If the
    template contains more than one element at the base layer, the widget will not
    render and throw an error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该如何布局一个模板小部件？小部件的模板HTML应该全部包含在一个单独的HTML元素中。你可以使用 `<div>` 标签、`<table>` 标签，或者你计划将模板包围在内的元素标签。如果模板在基础层包含多个元素，小部件将无法渲染并抛出错误。
- en: Adding _OnDijitClickMixin
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 _OnDijitClickMixin
- en: The `_OnDijitClickMixin` module provides the ability for elements within your
    template to be "clicked". This works, not only with click events using the mouse,
    but through touch and keyboard events as well. Besides clicking and touching an
    element, the user can tab until the element is highlighted, then press the *Enter*
    or spacebar key to activate it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`_OnDijitClickMixin` 模块允许你的模板中的元素能够“被点击”。这不仅适用于使用鼠标的点击事件，也适用于触摸和键盘事件。除了点击和触摸一个元素外，用户可以通过按制表符键直到元素被突出显示，然后按
    *Enter* 键或空格键来激活它。'
- en: 'If the `_OnDijitClickMixin` module is loaded, the developer can add event handlers
    to the `dijit` template through the `data-dojo-attach-event` attribute. Within
    this data attribute text value, add `ondijitclick:` followed by the name of your
    click event handler. You must have this event handler pointing to a valid function,
    or else the whole widget will fail to load. An example of a `dijit` template using
    the `clickMe(event) {}` function is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载了 `_OnDijitClickMixin` 模块，开发者可以通过 `data-dojo-attach-event` 属性向 `dijit` 模板添加事件处理器。在此数据属性文本值中，添加
    `ondijitclick:` 后跟你的点击事件处理器名称。你必须确保这个事件处理器指向一个有效的函数，否则整个小部件将无法加载。以下是一个使用 `clickMe(event)
    {}` 函数的 `dijit` 模板示例：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As a side note, the function within the click event handler should be ready
    to accept a one click event argument, and nothing else.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，点击事件处理器中的函数应该准备好接受一个单次点击事件参数，没有其他。
- en: Adding _FocusMixin
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 _FocusMixin
- en: 'The `_FocusMixin` module provides focus and blur events for your widget and
    its components. For instance, if you have a widget that takes up more room when
    it''s focused, you could add an `_onFocus()` event handler to the object like
    this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`_FocusMixin` 模块为你的小部件及其组件提供聚焦和失焦事件。例如，如果你有一个在聚焦时占用更多空间的小部件，你可以在对象中添加一个 `_onFocus()`
    事件处理器，如下所示：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the other hand, when you want your widget to shrink back to its normal size,
    you would add an `_onBlur()` event handler:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你想让小部件缩小回正常大小时，你将添加一个 `_onBlur()` 事件处理器：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The event system
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件系统
- en: The event system within JavaScript is an important part of the language. JavaScript
    was designed to respond to events in the browser and events caused by users. A
    website may need to respond to the click of a user, or an AJAX response from a
    server. With the language, you can attach functions called event handlers to listen
    for events from certain elements in the page and the browser.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的事件系统是该语言的重要组成部分。JavaScript 被设计为响应浏览器中的事件和用户引起的事件。一个网站可能需要响应用户的点击，或服务器的
    AJAX 响应。使用该语言，你可以将称为事件处理器的函数附加到页面和浏览器中某些元素上，以监听事件。
- en: In the Dojo framework, events are listened to using the `dojo/on` module. When
    assigning an event listener, the module function call returns an object that lets
    you discontinue listening by calling the object's `remove()` method. Also, `dojo/on`
    has a `once()` method that fires the event once, when the event occurs, then automatically
    removes the event.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dojo 框架中，使用 `dojo/on` 模块来监听事件。在分配事件监听器时，模块函数调用返回一个对象，您可以通过调用该对象的 `remove()`
    方法来停止监听。此外，`dojo/on` 有一个 `once()` 方法，当事件发生时，它会触发事件一次，然后自动删除该事件。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some older ArcGIS API samples still use Dojo's old event handler, `dojo.connect()`.
    Events handlers would be attached with `dojo.connect()`, and removed with `dojo.disconnect()`.
    The Dojo Foundation is currently depreciating `dojo.connect()`, and will drop
    it from their code when Dojo moves to version 2.0\. If you are maintaining old
    code, please start migrating all `dojo.connect()` to `dojo/on`. With the ArcGIS
    API, please pay attention to event names and results returned. Names may change
    from CamelCase to dash-separated, and while `dojo.connect()` can return more than
    one item in its callback, `dojo/on` only returns a single JavaScript object.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较老的 ArcGIS API 示例仍然使用 Dojo 的旧事件处理器，`dojo.connect()`。事件处理器将通过 `dojo.connect()`
    进行附加，并通过 `dojo.disconnect()` 移除。目前，Dojo 基金会正在弃用 `dojo.connect()`，并在 Dojo 升级到 2.0
    版本时将其从代码中删除。如果您正在维护旧代码，请开始将所有 `dojo.connect()` 迁移到 `dojo/on`。在使用 ArcGIS API 时，请注意事件名称和返回的结果。名称可能从驼峰式命名法变为以破折号分隔，虽然
    `dojo.connect()` 可以在其回调中返回多个项目，但 `dojo/on` 只返回一个 JavaScript 对象。
- en: Events are created using `emit()`. This function takes in a string name of the
    event, and a JavaScript object you would want to pass to an event listener. The
    `emit()` method is available for widgets using the `dojo/Evented` module, and
    those built using the `dijit/_WidgetBase` module. It is also available through
    the `dojo/on` module, but `dojo/on.emit()` requires an HTML DOM before the event
    name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是通过 `emit()` 创建的。此函数接受事件字符串名称和一个您希望传递给事件监听器的 JavaScript 对象。`emit()` 方法适用于使用
    `dojo/Evented` 模块的小部件，以及使用 `dijit/_WidgetBase` 模块构建的小部件。它也通过 `dojo/on` 模块提供，但
    `dojo/on.emit()` 在事件名称之前需要一个 HTML DOM。
- en: Now that we have a grasp of the Dojo framework, let's build something with it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了 Dojo 框架，让我们用它来构建一些东西。
- en: Creating our own widget
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的小部件
- en: Now that we know the basics of creating custom widgets, that is to say, dijits
    for our web applications, let's put our knowledge into practice. In this part
    of the chapter, we will transform the single-page application code we wrote in
    [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First
    Mapping Application* into a dijit that can be used with any map. We'll then use
    that `dijit` in a map application that can be expanded to include other dijits
    as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了创建自定义小部件的基础，也就是说，为我们的网络应用创建 dijit，让我们将我们的知识付诸实践。在本章的这一部分，我们将把我们在 [第
    1 章](ch01.html "第 1 章。您的第一个映射应用") 中编写的单页应用程序代码，*您的第一个映射应用*，转换为一个可以与任何地图一起使用的小部件。然后，我们将使用这个小部件在可以扩展以包含其他小部件的地图应用程序中。
- en: Picking up where we left off…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们上次停止的地方继续…
- en: 'We finally received feedback from the Y2K Society about the census map we created
    in [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First
    Mapping Application*. They liked how the map worked, but felt it could use more
    polish. After a meeting with some group members, here is a list of their feedback:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终收到了 Y2K 社会对我们在 [第 1 章](ch01.html "第 1 章。您的第一个映射应用") 中创建的人口普查地图的反馈。他们喜欢地图的工作方式，但觉得它需要更多的润色。在与一些小组成员会议后，以下是他们的反馈列表：
- en: The application should have sections at the top and the bottom to show titles
    and a little bit about the society
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该在顶部和底部有部分来显示标题和关于社会的简要信息
- en: The colors should be warm and cheery, such as yellows
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色应该是温暖和愉快的，例如黄色
- en: Get rid of the plain black line work of the census layer data
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摆脱人口普查图层数据的普通黑色线条
- en: The application should let us do more than simply look at census data. It should
    let us click on other buttons to do other things
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该让我们能够做的不仅仅是查看人口普查数据。它应该让我们点击其他按钮来做其他事情
- en: The census information needs to be more organized and grouped logically in tables
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口普查信息需要更加有组织和逻辑地分组在表格中
- en: 'In order to comply with their requests, we will need to reorganize our application
    from [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"), *Your
    First Mapping Application*. To fix the issue, we''ll need to do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足他们的要求，我们需要从 [第 1 章](ch01.html "第 1 章。您的第一个映射应用程序") *您的第一个映射应用程序* 重新组织我们的应用程序。为了解决这个问题，我们需要执行以下操作：
- en: We will create a new full page app with a header and footer.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的全页应用程序，包含页眉和页脚。
- en: We will modify the style of the application.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改应用程序的样式。
- en: We will represent the census map service using custom symbology.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用自定义符号表示人口普查地图服务。
- en: We will add buttons to the header to launch the census popups.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在页眉中添加按钮以启动普查弹出窗口。
- en: We will move the `infoTemplate` data into separate HTML files.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把 `infoTemplate` 数据移动到单独的 HTML 文件中。
- en: The file structure for our application
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们应用程序的文件结构
- en: In order to deliver a map that can do more than just show census data, we're
    going to use the tools provided by the Dojo framework. We'll use elements of Dojo
    to lay out the application, and turn our previous census map tool into its own
    widget. Instead of a single page application, where the HTML, CSS, and JavaScript
    are mashed together in the same file, we're going to separate the files into distinct
    components.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个不仅能显示人口普查数据的地图，我们将使用 Dojo 框架提供的工具。我们将使用 Dojo 的元素来布局应用程序，并将我们之前的普查地图工具转换为其自己的小部件。而不是将
    HTML、CSS 和 JavaScript 混合在同一文件中的单页应用程序，我们将将这些文件分离成独立的组件。
- en: Let's start by organizing the project folder. It's a good idea to separate the
    styling and scripts into separate folders. In our project folder, we'll add two
    subfolders to the project folder. We'll name them `css` and `js`, for the stylesheet
    and script files, respectively. Inside the `js` folder, we'll add another folder
    and name it `templates`. This is where our widget templates will go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组织项目文件夹开始。将样式和脚本分别放入不同的文件夹是一个好主意。在我们的项目文件夹中，我们将向项目文件夹添加两个子文件夹。我们将它们命名为 `css`
    和 `js`，分别用于样式表和脚本文件。在 `js` 文件夹内，我们将添加另一个文件夹并命名为 `templates`。这是我们的小部件模板将放置的地方。
- en: 'In the main project folder, we''ll create an HTML page called `index.html`.
    Next, In the `css` folder, we''ll create a file called `y2k.css`, which will be
    our application stylesheet. We''ll create two JavaScript files in our `js` folder:
    one called `app.js` for our application, and another called `Census.js` for our
    widget. We''ll stub out template files in the `js`/`templates` folder for the
    census widget (`Census.html`), plus some templates for our popups. The files should
    look something like the following folder structure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在主项目文件夹中，我们将创建一个名为 `index.html` 的 HTML 页面。接下来，在 `css` 文件夹中，我们将创建一个名为 `y2k.css`
    的文件，这将是我们的应用程序样式表。在我们的 `js` 文件夹中，我们将创建两个 JavaScript 文件：一个名为 `app.js` 的用于应用程序，另一个名为
    `Census.js` 的用于小部件。我们将在 `js`/`templates` 文件夹中为普查小部件（`Census.html`）创建模板文件，以及一些弹出窗口的模板。文件结构应类似于以下：
- en: '![The file structure for our application](img/6459OT_03_01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![我们应用程序的文件结构](img/6459OT_03_01.jpg)'
- en: Defining the layout with Dojo
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Dojo 定义布局
- en: To handle the layout of the application, we'll use a couple of the modules within
    the `dijit/layout` package. This package has a number of UI containers with styled
    looks and built-in UI behavior that we don't have to reinvent. We'll add the layout
    elements and restyle them to fit our client's wishes. Let's look at the layout
    module found within the `dijit` package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理应用程序的布局，我们将使用 `dijit/layout` 包内的几个模块。这个包包含许多具有样式外观和内置 UI 行为的 UI 容器，我们不需要重新发明。我们将添加布局元素并重新设计它们以满足客户的需求。让我们看看
    `dijit` 包内找到的布局模块。
- en: Framing the page with BorderContainer
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 BorderContainer 框架布局页面
- en: The `BorderContainer` container provides a common layout tool used with Dojo.
    The `BorderContainer` container is extended from the `LayoutContainer` module,
    which creates a layout that fills up the entire browser window without scrolling.
    The `LayoutContainer` module (and by extension, the `BorderContainer` module)
    allows content elements to be placed with a region attribute. The `BorderContainer`
    container adds borders, spacing, and resizing elements called splitters, which
    can be dragged to resize the content items.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorderContainer` 容器提供了 Dojo 中常用的布局工具。`BorderContainer` 容器是从 `LayoutContainer`
    模块扩展而来的，它创建了一个填充整个浏览器窗口而不需要滚动的布局。`LayoutContainer` 模块（以及通过扩展的 `BorderContainer`
    模块）允许使用区域属性放置内容元素。`BorderContainer` 容器添加了边框、间距和可调整大小的元素，称为分隔符，可以拖动以调整内容项的大小。'
- en: 'The regions that can be assigned to content dijits inside the `BorderContainer`
    container are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以分配给 `BorderContainer` 容器内部的内容 dijits 的区域如下：
- en: '**Center**: This positions the element at the center of the page, relative
    to the other items. One element must be assigned this value.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心**：将元素定位在页面中心，相对于其他项目。必须将此值分配给一个元素。'
- en: '**Top**: This positions the element above the center element.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶部**：将元素定位在中心元素的上方。'
- en: '**Bottom**: This positions the element below the center element.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底部**：将元素定位在中心元素的下方。'
- en: '**Right**: This positions the element to the right of the center element.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右侧**：将元素定位在中心元素的右侧。'
- en: '**Left**: This positions the element to the left of the center element.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧**：将元素定位在中心元素的左侧。'
- en: '**Leading**: If the `dir` attribute of the page is set to "ltr" (left-to-right),
    the leading element is placed to the left of the center element. If the `dir`
    attribute is "rtl" (right-to-left), the leading element is placed on the right.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**leading**：如果页面的 `dir` 属性设置为 "ltr"（从左到右），则 leading 元素放置在中心元素的左侧。如果 `dir` 属性为
    "rtl"（从右到左），则 leading 元素放置在右侧。'
- en: '**Trailing**: Layout is the opposite of the leading element, with "ltr" on
    the right, and "rtl" on the left.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾部**：布局与 leading 元素相反，"ltr" 在右侧，"rtl" 在左侧。'
- en: 'The `BorderContainer` module, and its parent `LayoutContainer` module, have
    a design parameter that affects the containers surrounding the center element.
    When the `design` parameter is set to its default value of `headline`, the top
    and bottom panels take up the entire width of the container. The right, left,
    leading, and trailing panels shrink to fit between the top and bottom panels.
    Alternatively, you can set the `design` parameter to `sidebar`, and the panels
    on the sides will take up the entire height, while the top and bottom panels are
    squeezed in between them. The following figure shows example pages made with headline
    and sidebar designs. The `design` parameter was the only parameter changed in
    the examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BorderContainer` 模块及其父模块 `LayoutContainer` 有一个设计参数会影响围绕中心元素的容器。当 `design`
    参数设置为默认值 `headline` 时，顶部和底部面板占据容器的整个宽度。右侧、左侧、leading 和 trailing 面板缩小以适应顶部和底部面板之间。或者，您可以将
    `design` 参数设置为 `sidebar`，侧面板将占据整个高度，而顶部和底部面板则被挤压在它们之间。以下图显示了使用 headline 和 sidebar
    设计的示例页面。示例中只更改了 `design` 参数：'
- en: '![Framing the page with BorderContainer](img/6459OT_03_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用 BorderContainer 边框容器框定页面](img/6459OT_03_02.jpg)'
- en: BorderContainer with 'headline' (left) and 'sidebar' (right) design attributes
    with ContentPanes
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 具有带有 'headline'（左侧）和 'sidebar'（右侧）设计属性的 BorderContainer
- en: Inserting ContentPane
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入内容面板
- en: The `ContentPane` tile provides the general container used in most desktop Dojo
    pages. `ContentPane` tiles can adjust to fit within their assigned places, and
    can expand and shrink as the user resizes the browser. `ContentPane` tiles can
    house HTML elements, such as other Dojo widgets and controls. They also have an
    `href` attribute which, when set, will load and render the content of another
    HTML page. The pages are loaded via **XMLHttpRequest** (**XHR**), therefore the
    loaded HTML should be on the same domain, due to cross-origin issues.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPane` 面板提供了在大多数桌面 Dojo 页面中使用的通用容器。`ContentPane` 面板可以调整以适应其分配的位置，并且可以根据用户调整浏览器大小而扩展和收缩。`ContentPane`
    面板可以容纳 HTML 元素，例如其他 Dojo 小部件和控制。它们还有一个 `href` 属性，当设置时，将加载并渲染另一个 HTML 页面的内容。由于跨域问题，页面通过
    **XMLHttpRequest** （**XHR**） 加载，因此加载的 HTML 应该在同一域上。'
- en: Modifying the layout of our application
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改我们应用程序的布局
- en: Looking at the requirements, we're going to use the `BorderContainer` containers
    and some `ContentPane` tiles to create the header, footer, and the content of
    the application. We'll take a standard HTML template pulling the necessary libraries,
    then add the `dijit` content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 观察需求后，我们将使用 `BorderContainer` 容器和一些 `ContentPane` 面板来创建应用程序的标题、页脚和内容。我们将使用标准的
    HTML 模板获取必要的库，然后添加 `dijit` 内容。
- en: 'In your application''s folder, start by creating an HTML file called `index.html`.
    We''ll title it `Y2K Map`, and add the necessary meta tags and scripts to load
    the ArcGIS API for JavaScript. We''ll also load the dojo CSS stylesheet `nihilo.css`,
    to handle the styling of the base styling of the dojo elements in the application.
    In order to apply the style to our application, we''ll also add a class of `nihilo`
    to the body element of our HTML document. Finally, we''ll add a link to our `y2k.css`
    file, which we''ll create soon. Your HTML document should look like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序文件夹中，首先创建一个名为`index.html`的HTML文件。我们将将其命名为`Y2K Map`，并添加必要的元标签和脚本以加载ArcGIS
    API for JavaScript。我们还将加载`dojo` CSS样式表`nihilo.css`，以处理应用程序中`dojo`元素的基本样式。为了将样式应用到我们的应用程序中，我们还将向我们的HTML文档的`body`元素添加一个`nihilo`类。最后，我们将添加一个链接到我们即将创建的`y2k.css`文件。你的HTML文档应该看起来像以下这样：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''ll add the `BorderContainer` container and the `ContentPane` tiles
    inside the body tag. These will be built on basic `<div>` elements. We''ll give
    the `BorderContainer` container an `id` of `mainwindow`, a `ContentPane` tile
    at the top with an `id` of `header`, another `ContentPane` tile with an `id` of
    `map` where our map will go, and a `ContentPane` tile at the bottom with an `id`
    of `footer`. We''ll also add a little content to the header and footer, just to
    make it look nice. Here is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`<body>`标签内添加`BorderContainer`容器和`ContentPane`瓷砖。这些将基于基本的`<div>`元素构建。我们将给`BorderContainer`容器一个`id`为`mainwindow`，顶部一个`ContentPane`瓷砖，其`id`为`header`，另一个`ContentPane`瓷砖，其`id`为`map`，我们的地图将放在这里，还有一个`ContentPane`瓷砖在底部，其`id`为`footer`。我们还会在标题和页脚中添加一些内容，使其看起来更美观。以下是一个示例：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since the client wanted a place to add multiple functions, including our census
    search, we''ll add a location for buttons in the upperright-handcorner. We''ll
    create a button containing `<div>`, and insert our census button as a `dijit/form/Button`
    module. Using the `dijit` button will ensure that the styling of the part will
    go along with the styling of the widget. Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户需要一个地方来添加多个功能，包括我们的普查搜索，我们将在右上角添加一个按钮位置。我们将创建一个包含`<div>`的按钮，并将我们的普查按钮作为`dijit/form/Button`模块插入。使用`dijit`按钮将确保该部分的样式将与小部件的样式保持一致。以下是一个示例：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To make the files work, we''ll need to add a link to the main script file we''ll
    run for our app. We''ll insert the `app.js` file as the last element inside the
    `<body>` tag, so that loading the file doesn''t cause the browser to block other
    downloads. In the following code, you can see where we insert this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文件正常工作，我们需要添加一个链接到我们将为应用程序运行的main脚本文件。我们将把`app.js`文件作为`<body>`标签内的最后一个元素插入，这样加载文件就不会阻止浏览器下载其他内容。在以下代码中，你可以看到我们插入的位置：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Within the `app.js` file, we''re going to do just enough to get the visuals.
    We''ll add to this file as we go. We''ll start with our normal `require()` statement,
    loading the modules for the `BorderContainer`, `ContentPane`, and `Button` elements.
    We''ll also pull in a module called `dojo/parser`, which will parse the Dojo data-markup
    in the HTML and turn it into application widgets. The code will be as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，我们将只做足够的事情来获得视觉效果。我们将随着工作的进行向此文件添加内容。我们将从正常的`require()`语句开始，加载`BorderContainer`、`ContentPane`和`Button`元素的模块。我们还将引入一个名为`dojo/parser`的模块，该模块将解析HTML中的Dojo数据标记并将其转换为应用程序小部件。代码如下：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After all that work, our HTML should look something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些工作后，我们的HTML应该看起来像以下这样：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Styling our application
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序样式
- en: If we run the application at this point, it won't look quite as expected. In
    fact, it'll look a lot like a white screen. That is because we haven't assigned
    a size to our page yet. In this case, the `ContentPane` tile styling creates positioned-looking
    panels, and absolute positioning takes the content out of the calculated page
    flow. Since there was nothing else to fill the height of the body, it collapsed
    to zero height.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，它看起来可能不会像预期的那样。事实上，它看起来就像一个空白屏幕。这是因为我们还没有为我们的页面分配大小。在这种情况下，`ContentPane`瓷砖的样式创建出定位外观的面板，绝对定位将内容从计算页面流程中移除。由于没有其他内容来填充`body`的高度，它就塌陷到零高度。
- en: 'A quick remedy to this issue is to update the styling of the HTML and the body
    tag. Open up `y2k.css` in your text editor and add the following lines of CSS:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的快速方法是更新HTML和`<body>`标签的样式。在你的文本编辑器中打开`y2k.css`，并添加以下CSS行：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This CSS we applied makes the page fill up 100 percent of our browser window.
    Adding the border, margin, and padding takes away any possible formatting that
    different browsers may insert into the page. We added the font size because it's
    good practice to set the font size in pixels at the body level. Further font size
    assignments can be made relative to this, using the `em` unit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的这个CSS使页面填充了浏览器窗口的100%。添加边框、边距和填充移除了不同浏览器可能插入页面的任何可能的格式化。我们添加了字体大小，因为在body级别设置像素字体大小是一种良好的实践。进一步的字体大小分配可以使用`em`单位相对于这个值进行。
- en: 'If you play your page now, you should see the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在播放你的页面，你应该看到以下输出：
- en: '![Styling our application](img/6459OT_03_03.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用样式](img/6459OT_03_03.jpg)'
- en: 'It''s definitely progress, but we need to fulfil the other requirements of
    the application. First, the `#buttonbar` element would look better if we positioned
    it precisely in the top-right, and left a little gap for the **Census** button
    to be centered vertically. Next, we''ll add some yellow hues to the different
    panels, and round off the corners of the header and footer. We''ll end up with
    the following stylized shell for our application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是进步，但我们还需要满足应用的其它要求。首先，如果我们将`#buttonbar`元素精确地定位在右上角，并为**人口普查**按钮留出一些垂直居中的空间，它会看起来更好。接下来，我们将在不同的面板上添加一些黄色色调，并使页眉和页脚的角落变得圆润。我们的应用最终将具有以下风格化的外壳：
- en: '![Styling our application](img/6459OT_03_04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![我们的应用样式](img/6459OT_03_04.jpg)'
- en: 'To make this happen, here''s the CSS we''ll add to our `y2k.css`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，这是我们将添加到`y2k.css`中的CSS：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Adding our custom package
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加我们的自定义包
- en: 'Before we can use our custom package, we need to tell Dojo where it is. To
    do that, we''ll need to add a `dojoConfig` object before we load the ArcGIS JavaScript
    API. In the `dojoConfig` object, we''ll add a package array object, and tell it
    that the `y2k` modules are in the `js` folder. The script should look something
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用自定义包之前，我们需要告诉Dojo它在哪。为此，我们将在加载ArcGIS JavaScript API之前添加一个`dojoConfig`对象。在`dojoConfig`对象中，我们将添加一个包数组对象，并告诉它`y2k`模块位于`js`文件夹中。脚本看起来可能像这样：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Setting up our app
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的应用
- en: 'Now we need to set up our application script and get things moving. We''ll
    open our `app.js` file and add the functionality for our map and our upcoming
    `Census` widget. We''ll start by adding references to the `esri/map` module and
    our `y2k/Census` widget. We''ll initialize our map just as we did in [Chapter
    1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First Mapping
    Application*, and we''ll create a new `Census` widget. Following the pattern of
    many dojo widgets, the `Census` widget constructor will take an options object
    for the first parameter, and a string reference to an HTML node within the `<div>`
    map as the second argument. We''ll fill in the options later:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置我们的应用脚本并开始移动。我们将打开我们的`app.js`文件，并添加地图和即将到来的`Census`小部件的功能。我们将像在[第1章](ch01.html
    "第1章。你的第一个映射应用")中做的那样添加对`esri/map`模块和我们的`y2k/Census`小部件的引用。我们将初始化地图，就像我们在[第1章](ch01.html
    "第1章。你的第一个映射应用")中做的那样，并创建一个新的`Census`小部件。遵循许多dojo小部件的模式，`Census`小部件构造函数将接受一个选项对象作为第一个参数，以及一个指向`<div>`地图内HTML节点的字符串引用作为第二个参数。我们将在稍后填写选项：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Perhaps you are wondering why some of the modules in our code start with capital
    letters, while others do not. Common JavaScript coding convention states that
    object constructors start with capital letters. The `Map` and `Census` modules
    make maps and census widgets, therefore they should be capitalized. Why the reference
    to the `esri/map` module isn't capitalized is a mystery, and a source of errors
    if you get it wrong.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你会想知道为什么我们代码中的一些模块以大写字母开头，而另一些则不是。常见的JavaScript编码约定指出，对象构造函数应以大写字母开头。`Map`和`Census`模块创建地图和人口普查小部件，因此它们应该大写。为什么对`esri/map`模块的引用没有大写仍然是个谜，如果你弄错了，这可能会成为错误的一个来源。
- en: Coding our widget
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的小部件
- en: 'We need to start piecing together our Census widget. To do that, we''ll use
    what we''ve learned about creating custom widgets from earlier in the chapter.
    Within the `Census.js` file, we''ll create a shell widget using the `define()`,
    `declare()`, and `_WidgetBase` modules. It should look something like the following
    code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始组装我们的人口普查小部件。为此，我们将使用本章前面学到的创建自定义小部件的知识。在`Census.js`文件中，我们将使用`define()`、`declare()`和`_WidgetBase`模块创建一个外壳小部件。它应该看起来像以下代码：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For our widget, we''ll want a template that instructs the user how to use the
    tool. It might also be a good idea to let the user close the tool, since we don''t
    want the map to be cluttered with multiple tools:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的小部件，我们希望有一个模板来指导用户如何使用工具。也许让用户关闭工具也是一个好主意，因为我们不希望地图被多个工具所杂乱：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, we need to load our template into our widget. To do that, we're
    going to implement another dojo module called `dojo/text`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要将我们的模板加载到我们的小部件中。为了做到这一点，我们将实现另一个名为`dojo/text`的dojo模块。
- en: Adding some dojo/text!
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一些`dojo/text`！
- en: 'The `dojo/text` module lets the module download any sort of text file as a
    string. The contents can be HTML, text, CSV, or any related text-based file. When
    loading the file using AMD, the format is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`dojo/text`模块允许模块以字符串的形式下载任何类型的文本文件。内容可以是HTML、文本、CSV或任何相关的基于文本的文件。当使用AMD加载文件时，格式如下：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the `filename.extension` describes the file name,
    such as `report.txt`. The path shows the location of the file in relationship
    to the script. So a path of `./templates/file.txt` means that the file is located
    in the `templates` folder, which is a subfolder of the folder where this widget
    script has been located.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`filename.extension`描述了文件名，例如`report.txt`。路径显示了文件相对于脚本的定位。因此，路径`./templates/file.txt`意味着该文件位于`templates`文件夹中，它是包含此小部件脚本文件夹的子文件夹。
- en: The exclamation point in our declaration means that the module has a plugin
    attribute that can automatically be called on load time. Otherwise, we would have
    to wait and call it after the module loaded in our script. Another module where
    we see this is `dojo/domReady`. The exclamation point activates that module, pausing
    our application until the HTML DOM is ready as well.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明中的感叹号表示该模块有一个插件属性，可以在加载时自动调用。否则，我们不得不等待并在我们的脚本中模块加载后调用它。我们看到这种情况的另一个模块是`dojo/domReady`。感叹号激活了该模块，暂停我们的应用程序，直到HTML
    DOM也准备好。
- en: 'Getting back to our application, it''s time to load our dijit template. The
    `_TemplatedMixin` module provides a property called `templateString`, which it
    reads from to build the HTML portion of the `dijit` package. We''ll use the `dojo/text`
    module to load HTML from our `Census.html` template, then insert the string created
    from that into the `templateString` property. It should look something like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序，现在是加载我们的dijit模板的时候了。`_TemplatedMixin`模块提供了一个名为`templateString`的属性，它从中读取以构建`dijit`包的HTML部分。我们将使用`dojo/text`模块从我们的`Census.html`模板中加载HTML，然后将从该字符串创建的字符串插入到`templateString`属性中。它看起来可能像这样：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Our dijit template
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的小部件模板
- en: For our template, we're going to take advantage of a few cool tricks in Dojo.
    The first trick is that we can mix property values into our widget through the
    same substitute templating we learned about in [Chapter 1](ch01.html "Chapter 1. Your
    First Mapping Application"), *Your First Mapping Application*. Second, we're going
    to take advantage of the `_OnDijitClickMixin` module to handle click events.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模板，我们将利用Dojo的一些酷技巧。第一个技巧是我们可以通过与我们在[第1章](ch01.html "第1章。您的第一个映射应用程序")中学习的相同替换模板，将属性值混合到我们的小部件中，*您的第一个映射应用程序*。其次，我们将利用`_OnDijitClickMixin`模块来处理点击事件。
- en: 'For our template, we''re looking at creating something with a title (such as
    "Census"), some instructions, and a `close` button. We''ll assign a close button
    event handler through the `data-dojo-attach-event` attribute using `ondijitclick`.
    We''ll also assign a `baseClass` attribute from the widget to the CSS classes
    in the widget. If you haven''t created the `Census.html` file in your `template`
    folder, do so now. Then, enter the following HTML content:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模板，我们正在考虑创建一个带有标题（例如“人口普查”），一些说明和一个`close`按钮的东西。我们将通过`data-dojo-attach-event`属性使用`ondijitclick`分配一个关闭按钮的事件处理程序。我们还将从小部件分配一个`baseClass`属性到小部件中的CSS类。如果你还没有在你的`template`文件夹中创建`Census.html`文件，现在就创建它。然后，输入以下HTML内容：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: What errors in the template could possibly cause the widget not to load? If
    you are incorporating events, through the `data-dojo-attach-event` parameter,
    make sure the callback function in the template matches the name of the callback
    function in your dijit. Otherwise, the dijit will fail to load.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中可能存在哪些错误会导致小部件无法加载？如果你通过`data-dojo-attach-event`参数合并事件，请确保模板中的回调函数与你的dijit中的回调函数名称匹配。否则，dijit将无法加载。
- en: 'Back in our code, we''ll assign a `baseClass` property, as well as functions
    for `hide()` and `show()`. Many dijits use those functions to control their visibility.
    Through those functions, we''ll set the display style attribute to either `none`
    or `block`, as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们将分配一个 `baseClass` 属性，以及 `hide()` 和 `show()` 函数。许多 dijit 使用这些函数来控制它们的可见性。通过这些函数，我们将显示样式属性设置为
    `none` 或 `block`，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Working with the dijit constructors
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 dijit 构造函数
- en: We'll need to add onto the `dijit` constructor function, but first we need to
    think about what this dijit needs. Our original purpose for the dijit was to let
    the user click on the map and identify census locations. So, we'll need a map,
    and since we're identifying something, we'll need to supply a map service URL
    to the constructor of the `IdentifyTask` object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要扩展 `dijit` 构造函数功能，但首先我们需要考虑这个 dijit 需要什么。我们最初创建 dijit 的目的是让用户点击地图并识别人口普查地点。因此，我们需要一个地图，由于我们要识别某些东西，我们需要向
    `IdentifyTask` 对象的构造函数提供地图服务 URL。
- en: Following the trends of most `dijit` constructors, our `dijit` constructor will
    accept an options object, and either an HTML DOM node, or a string `id` for that
    node. In the options object, we'll look for a map, and a `mapService` URL. The
    second argument in the constructor will be assigned as the dijit's `domNode`,
    or if it's a string, the appropriate node will be found based off the string.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随大多数 `dijit` 构造函数的趋势，我们的 `dijit` 构造函数将接受一个选项对象，以及一个 HTML DOM 节点或该节点的字符串 `id`。在选项对象中，我们将寻找一个映射和一个
    `mapService` URL。构造函数中的第二个参数将被分配为 dijit 的 `domNode`，如果它是一个字符串，则根据该字符串找到相应的节点。
- en: 'For our constructor, we''ll incorporate the map into the widget, and turn the
    `mapService` into an `IdentifyTask`. We''ll also add the `dojo/dom` module to
    provide a shortcut for the common JavaScript operation `document.getElementById()`,
    and use that to transform a string `id` into a DOM element:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的构造函数，我们将地图集成到小部件中，并将 `mapService` 转换为 `IdentifyTask`。我们还将添加 `dojo/dom`
    模块，以提供对常见 JavaScript 操作 `document.getElementById()` 的快捷方式，并使用它将字符串 `id` 转换为 DOM
    元素：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Reusing our old code
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复使用我们的旧代码
- en: Looking back at [Chapter 1](ch01.html "Chapter 1. Your First Mapping Application"),
    *Your First Mapping Application*, we were able to check out the map, click on
    it, and get some results. Wouldn't it be great if we could reuse some of that
    code? Well, with a few changes, we can reuse a lot of our code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 [第 1 章](ch01.html "Chapter 1. Your First Mapping Application")，*您的第一个映射应用程序*，我们能够查看地图，点击它，并获得一些结果。如果我们可以重用一些代码会怎么样？好吧，通过一些修改，我们可以重用大部分的代码。
- en: 'The first thing we need to tackle is assigning our map click event. Since we
    don''t get to do it all the time, the most logical time to assign the map click
    event is when our dijit is visible. We''ll modify our show and hide functions
    so that they assign and remove the click handler, respectively. We''ll name the
    map-click event handler `_onMapClick()`. We''re also going to load the module
    `dojo/_base/lang`, which helps us with objects. We''ll use the `lang.hitch()`
    function to reassign a function''s `this` statement:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的第一件事是分配我们的地图点击事件。由于我们并不总是有机会这样做，因此最合理的时间是在我们的 dijit 可见时分配地图点击事件。我们将修改我们的显示和隐藏函数，以便它们分别分配和移除点击处理程序。我们将命名地图点击事件处理程序为
    `_onMapClick()`。我们还将加载模块 `dojo/_base/lang`，它帮助我们处理对象。我们将使用 `lang.hitch()` 函数重新分配函数的
    `this` 语句：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As a side note, while JavaScript doesn't support private variables, the typical
    naming convention for JavaScript objects states that, if a property or method
    starts with an underscore (`_`) character, it's considered private by the developer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，虽然 JavaScript 不支持私有变量，但 JavaScript 对象的典型命名约定表明，如果一个属性或方法以下划线 (`_`) 字符开头，它被认为是开发者认为的私有。
- en: 'In our`_onMapClick()` method, we''ll reuse the click event code from [Chapter
    1](ch01.html "Chapter 1. Your First Mapping Application"), *Your First Mapping
    Application*, with a few notable exceptions. Remember now that we''re not referencing
    the map as a variable, but as a property of the widget. The same thing is true
    for the `IdentifyTask`, and any other methods we may call in this dijit. To refer
    to properties and methods within a method, the variable must be preceded by `this`.
    In this case, this will refer to the widget, which we made sure of when we used
    the `dojo/_base/lang` library on the `_onMapClick()` call. If your application
    fails at the map click event, it''s probably because you didn''t properly assign
    the variable with the correct `this` context:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`_onMapClick()`方法中，我们将重用[第1章](ch01.html "第1章。您的第一个映射应用程序")中“您的第一个映射应用程序”的点击事件代码，但有几点值得注意。现在请记住，我们不是将地图作为变量来引用，而是将其作为小部件的属性。对于`IdentifyTask`以及我们可能在这个dijit中调用的任何其他方法也是如此。要引用方法内的属性和方法，变量前面必须加上`this`。在这种情况下，`this`将引用小部件，我们在调用`_onMapClick()`时使用了`dojo/_base/lang`库来确保这一点。如果你的应用程序在地图点击事件失败，可能是因为你没有正确地分配带有正确`this`上下文的变量：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Loading more templates
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载更多模板
- en: The Y2K society had requested that we display the popups as something more organized
    and logical. In our web developer minds, nothing screams organized data more than
    a table. We can set up and organize tables for our templates, but creating those
    long strings to organize a long list of results would be daunting. Having HTML
    strings in our JavaScript code would be a pain to edit, since most IDEs and syntax-highlighting
    text editors don't highlight HTML in our JavaScript.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Y2K协会要求我们以更有组织和逻辑的方式显示弹出窗口。在我们的网络开发者心中，没有什么比表格更能体现组织良好的数据了。我们可以为我们的模板设置和组织表格，但创建那些用于组织长列表的长字符串会令人望而却步。在我们的JavaScript代码中包含HTML字符串将会很痛苦，因为大多数IDE和语法高亮文本编辑器都不会在我们的JavaScript中高亮显示HTML。
- en: 'But then we remember that we can load HTML into our JavaScript using the `dojo/text`
    module. If we define the content of our `InfoTemplates` using little HTML snippets,
    and load them using `dojo/text`, the process will be much more streamlined:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后我们记得我们可以使用`dojo/text`模块将HTML加载到我们的JavaScript中。如果我们使用小的HTML片段定义我们的`InfoTemplates`内容，并使用`dojo/text`加载它们，这个过程将会更加流畅：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: I'll leave the contents of the HTML `infoTemplates` up to you as an exercise.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我会将HTML `infoTemplates`的内容留给你作为练习。
- en: Back to our app.js
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到我们的app.js
- en: 'We didn''t forget about our `app.js` file. We stubbed out the code for loading
    the map and the `Census` dijit, but we didn''t assign anything else. We need to
    assign a click event handler for `Census` button to toggle the visibility of the
    `Census` widget. For that, we''ll use the `dijit/registry` module to load the
    `dijit` button from its `id`. We''ll load the map and the `mapService` for the
    `Census` dijit, and add an event listener to the `Census` button click event that
    will show the `Census` widget. We''ll use the `dojo/_base/lang` module again to
    make sure the `Census.show()` function is properly applied to the `Census` dijit:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有忘记我们的`app.js`文件。我们为加载地图和`Census` dijit编写了代码框架，但没有分配任何其他内容。我们需要为`Census`按钮分配一个点击事件处理程序来切换`Census`小部件的可见性。为此，我们将使用`dijit/registry`模块从其`id`加载`dijit`按钮。我们将加载地图和`Census`
    dijit的`mapService`，并添加一个事件监听器到`Census`按钮的点击事件，这将显示`Census`小部件。我们将再次使用`dojo/_base/lang`模块来确保`Census.show()`函数被正确地应用于`Census`
    dijit：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run our code, it should look something like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的代码时，它应该看起来像以下这样：
- en: '![Back to our app.js](img/6459OT_03_05.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![回到我们的app.js](img/6459OT_03_05.jpg)'
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Over the course of this chapter, we have learned about many of the features
    offered by the Dojo framework, which is packaged with the ArcGIS API for JavaScript.
    We've learned about the three major packages in Dojo, and how to use them to create
    applications. We learned how to create our own modules, and we modified an existing
    application to make a module that could be imported into any application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们学习了ArcGIS API for JavaScript中包含的Dojo框架提供的许多功能。我们了解了Dojo的三个主要包，以及如何使用它们来创建应用程序。我们学习了如何创建自己的模块，并且修改了一个现有的应用程序来创建一个可以被任何应用程序导入的模块。
- en: In the next chapter, we will learn how the ArcGIS API for JavaScript communicates
    with ArcGIS Server through REST services.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习ArcGIS API for JavaScript如何通过REST服务与ArcGIS Server通信。
