["```py\n>>> wkt = \"POLYGON ((-4.335556 57.373056,-4.676389 57.138611,-4.447778 57.324722,-4.349167 57.386944,-4.334444 57.379444,-4.335556 57.373056))\"\n>>> polygon = shapely.wkt.loads(wkt)\n>>> print polygon.area\n0.006077434151\n\n```", "```py\n        python setup.py build\n        sudo python.setup.py install\n\n        ```", "```py\n        import pyproj\n\n        ```", "```py\nimport pyproj\ngeod = pyproj.Geod(ellps=\"WGS84\")\nlat1 = -38.137\nlong1 = 176.349\nlat2 = -41.286\nlong2 = 174.776\nheading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)\nprint int(distance)\n```", "```py\nimport networkx\n\ngraph = networkx.Graph()\ngraph.add_edge(\"New York\", \"San Francisco\", weight=2908)\ngraph.add_edge(\"San Francisco\", \"Los Angeles\", weight=382)\ngraph.add_edge(\"Los Angeles\", \"New York\", weight=2776)\ngraph.add_edge(\"San Francisco\", \"Portland\", weight=635)\n\nprint networkx.shortest_path(graph, \"New York\", \"Portland\")\n```", "```py\n['New York', 'San Francisco', 'Portland']\n\n```", "```py\nimport pyproj\ngeod = pyproj.Geod(ellps=\"WGS84\")\n```", "```py\ndef get_coord(prompt):\n    while True:\t\n        s = raw_input(prompt + \" (lat,long): \")\n        if \",\" not in s: continue\n        s1,s2 = s.split(\",\", 1)\n        try:\t\n            latitude = float(s1.strip())\n        except ValueError:\n            continue\n        try:\n            longitude = float(s2.strip())\n        except ValueError:\n            continue\n        return latitude,longitude\nlat1,long1 = get_coord(\"Starting coordinate\")\nlat2,long2 = get_coord(\"Ending coordinate\")\n```", "```py\nheading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)\n```", "```py\nprint \"Heading = %0.2f degrees\" % heading1\nprint \"Inverse heading = %0.2f degrees\" % heading2\nprint \"Distance = %0.2f kilometers\" % (distance/1000)\n```", "```py\nStarting coordinate: 37.774929, -122.419416\nEnding coordinate: 34.052234, -118.243685\n\n```", "```py\nHeading = 136.38 degrees\nInverse heading = -41.17 degrees\nDistance = 559.04 kilometers\n\n```", "```py\ndef get_num(prompt):\n    while True:\n        s = raw_input(prompt + \": \")\n        try:\n            value = float(s)\n        except ValueError:\n            continue\n        return value\n```", "```py\nsLat,sLong = get_coord(\"Starting coordinate\")\ndistance = get_num(\"Distance in kilometers\") * 1000\nheading = get_num(\"Heading\")\n```", "```py\neLong,eLat,iHeading = geod.fwd(sLong, sLat, heading, distance)\n```", "```py\nprint \"End point = (%0.4f,%0.4f)\" % (eLat, eLong)\nprint \"Inverse heading = %0.2f degrees\" % iHeading\n```", "```py\nStarting coordinate (lat,long): 37.774929, -122.419416\nDistance in kilometers: 559.04\nHeading: 136.38\nEnd point = (34.0521,-118.2440)\nInverse heading = -41.17 degrees\n\n```", "```py\nimport osgeo.ogr\nimport shapely.wkt\nimport pyproj\n\ngeod = pyproj.Geod(ellps=\"WGS84\")\n\nshapefile = osgeo.ogr.Open(\"tl_2014_06_prisecroads.shp\")\nlayer = shapefile.GetLayer(0)\n\nfor i in range(layer.GetFeatureCount()):\n    feature = layer.GetFeature(i)\n    geometry = shapely.wkt.loads(\n        feature.GetGeometryRef().ExportToWkt())\n```", "```py\n    tot_length = 0\n    prev_long,prev_lat = geometry.coords[0]\n    for cur_long,cur_lat in geometry.coords[1:]:\n        heading1,heading2,distance = geod.inv(\n            prev_long, prev_lat, cur_long, cur_lat)\n        tot_length = tot_length + distance\n        prev_long,prev_lat = cur_long,cur_lat\n```", "```py\n    print feature.GetField(\"FULLNAME\"), int(tot_length)\n```", "```py\n$ python calc_lengths.py\nN Wheeler Ridge Rd 1616\nN Main St 1595\n...\n\n```", "```py\nTraceback (most recent call last):\n File \"calc_lengths.py\", line 23, in <module>\n prev_long,prev_lat = geometry.coords[0]\n File \"/Library/Frameworks/GEOS.framework/Versions/3/Python/2.7/shapely/geometry/base.py\", line 634, in coords\n \"Multi-part geometries do not provide a coordinate sequence\")\nNotImplementedError: Multi-part geometries do not provide a coordinate sequence\n\n```", "```py\n>>> geometry = shapely.wkt.loads(feature.GetGeometryRef().ExportToWkt())\n>>> print geometry.geom_type\nMultiLineString\n\n```", "```py\nimport osgeo.ogr\nimport shapely.wkt\nimport pyproj\n\ngeod = pyproj.Geod(ellps=\"WGS84\")\n\nshapefile = osgeo.ogr.Open(\"tl_2014_06_prisecroads.shp\")\nlayer = shapefile.GetLayer(0)\n\nfor i in range(layer.GetFeatureCount()):\n    feature = layer.GetFeature(i)\n    geometry = shapely.wkt.loads(\n        feature.GetGeometryRef().ExportToWkt())\n\n    lineStrings = []\n    if geometry.geom_type == \"LineString\":\n        lineStrings.append(geometry)\n    elif geometry.geom_type == \"MultiLineString\":\n        for lineString in geometry:\n            lineStrings.append(lineString)\n\n    tot_length = 0\n\n    for lineString in lineStrings:\n        prev_long,prev_lat = lineString.coords[0]\n        for cur_long,cur_lat in lineString.coords[1:]:\n            heading1,heading2,distance = geod.inv(\n                prev_long, prev_lat, cur_long, cur_lat)\n            tot_length = tot_length + distance\n            prev_long,prev_lat = cur_long,cur_lat\n\n    print feature.GetField(\"FULLNAME\"), int(tot_length)\n```", "```py\nlineString = polygon.exterior\n```", "```py\nimport osgeo.ogr\nimport shapely.wkt\nimport shapely.ops\nimport pyproj\n\nshapefile = osgeo.ogr.Open(\"TM_WORLD_BORDERS-0.3.shp\")\nlayer = shapefile.GetLayer(0)\n\nsrc_proj = pyproj.Proj(proj=\"longlat\", ellps=\"WGS84\", datum=\"WGS84\")\ndst_proj = pyproj.Proj(proj=\"moll\", lon_0=0, x_0=0, y_0=0, ellps=\"WGS84\", datum=\"WGS84\", units=\"m\")\n\ndef latlong_to_mollweide(longitude, latitude):\n    return pyproj.transform(src_proj, dst_proj,\n                            longitude, latitude)\n\nfor i in range(layer.GetFeatureCount()):\n    feature = layer.GetFeature(i)\n    wkt = feature.getGeometryRef().ExportToWkt()\n    geometry = shapely.wkt.loads(wkt)\n\n    transformed = shapely.ops.transform(latlong_to_mollweide,\n                                        geometry)\n    area = int(transformed.area/1000000)\n\n    print feature.GetField(\"NAME\"), area\n```", "```py\n$ python calc_areas.py\nAntigua and Barbuda 546\nAlgeria 2326137\nAzerbaijan 86014\nAlbania 28702\n...\n\n```", "```py\nbuffered_area = test_country['geom'].buffer(1000000)\nfor country in countries:\n    if country['geom'].intersects(buffered_area):\n        print \"%s is within 1000 km of %s\" % (country['name'], test_country['name'])\n```", "```py\nimport os\nimport os.path\nimport shutil\nimport osgeo.ogr\nimport osgeo.osr\nimport shapely.wkt\n\nSRC_SHAPEFILE = \"tl_2014_06_prisecroads.shp\"\n\nall_roads = []\nshapefile = osgeo.ogr.Open(SRC_SHAPEFILE)\nlayer = shapefile.GetLayer(0)\nfor i in range(layer.GetFeatureCount()):\n    feature = layer.GetFeature(i)\n    wkt = feature.GetGeometryRef().ExportToWkt()\n    geometry = shapely.wkt.loads(wkt)\n    all_roads.append(geometry)\n```", "```py\nsplit_roads = []\n\nfor i in range(len(all_roads)):\n    cur_road = all_roads[i]\n    crossroads = []\n    for j in range(len(all_roads)):\n        if i == j: continue\n        other_road = all_roads[j]\n        if cur_road.crosses(other_road):\n            crossroads.append(other_road)\n    if len(crossroads) > 0:\n        for other_road in crossroads:\n            cur_road = cur_road.difference(other_road)\n        if cur_road.geom_type == \"MultiLineString\":\n            for split_road in cur_road.geoms:\n                split_roads.append(split_road)\n        elif cur_road.geom_type == \"LineString\":\n            split_roads.append(cur_road)\n    else:\n        split_roads.append(cur_road)\n```", "```py\ndriver = osgeo.ogr.GetDriverByName(\"ESRI Shapefile\")\nif os.path.exists(\"split_roads\"):\n    shutil.rmtree(\"split_roads\")\nos.mkdir(\"split_roads\")\ndstFile = driver.CreateDataSource(\"split_roads/split_roads.shp\")\n\nspatialReference = osgeo.osr.SpatialReference()\nspatialReference.SetWellKnownGeogCS(\"WGS84\")\n\nlayer = dstFile.CreateLayer(\"Layer\", spatialReference)\n\nfor road in split_roads:\n    wkt = shapely.wkt.dumps(road)\n    linestring = osgeo.ogr.CreateGeometryFromWkt(wkt)\n\n    feature = osgeo.ogr.Feature(layer.GetLayerDefn())\n    feature.SetGeometry(linestring)\n\n    layer.CreateFeature(feature)\n    feature.Destroy()\n\ndstFile.Destroy()\n```", "```py\nimport shapely.wkt\nimport pyproj\nimport networkx\n```", "```py\ndef calc_distance(lat1, long1, lat2, long2):\n    geod = pyproj.Geod(ellps=\"WGS84\")\n    heading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)\n    return distance\n```", "```py\ndef calc_length(linestring):\n    tot_length = 0\n    prev_long,prev_lat = linestring.coords[0]\n    for cur_long,cur_lat in linestring.coords[1:]:\n        distance = calc_distance(prev_lat, prev_long,\n                                 cur_lat, cur_long)\n        tot_length = tot_length + distance\n        prev_long,prev_lat = cur_long,cur_lat\n    return int(tot_length)\n```", "```py\ndef get_coord(prompt):\n    while True:\n        s = raw_input(prompt + \" (lat,long): \")\n        if \",\" not in s: continue\n        s1,s2 = s.split(\",\", 1)\n        try:\n            latitude = float(s1.strip())\n        except ValueError:\n            continue\n        try:\n            longitude = float(s2.strip())\n        except ValueError:\n            continue\n        return latitude,longitude\n```", "```py\ndef find_closest_node(graph, latitude, longitude):\n    closest_node = None\n    min_distance = None\n    for node in graph.nodes():\n        distance = calc_distance(node[1], node[0],\n                                 latitude, longitude)\n        if closest_node == None:\n            closest_node = node\n            min_distance = distance\n        elif distance < min_distance:\n            closest_node = node\n            min_distance = distance\n    return closest_node\n```", "```py\ngraph = networkx.read_shp(\"split_roads/split_roads.shp\")\n```", "```py\ngraph = networkx.connected_component_subgraphs(graph.to_undirected()).next()\n```", "```py\nfor node1,node2 in graph.edges():\n    wkt = graph[node1][node2]['Wkt']\n    linestring = shapely.wkt.loads(wkt)\n    length = calc_length(linestring)\n    graph.edge[node1][node2]['length'] = length\n```", "```py\nstart_lat, start_long = get_coord(\"Starting Coordinate\")\nend_lat, end_long = get_coord(\"Ending Coordinate\")\n```", "```py\nstart_node = find_closest_node(graph, start_lat, start_long)\nend_node   = find_closest_node(graph, end_lat, end_long)\n```", "```py\npath = networkx.shortest_path(graph, start_node, end_node, \"length\")\n```", "```py\ntot_length = 0\nprev_node = path[0]\nfor cur_node in path[1:]:\n    edge = graph.edge[prev_node][cur_node]\n    print (str(prev_node) + \" -> \" + str(cur_node) +\n           \", length = \" + str(edge['length']))\n    tot_length = tot_length + edge['length']\n    prev_node = cur_node\nprint \"Total length = \" + str(tot_length)\n```", "```py\n$ python calc_shortest_path.py \nLoading road network into memory...\ngraph has 7976 nodes and 9709 edges\nCalculating road lengths...\n\n```", "```py\nStarting Coordinate (lat,long): 37.794189, -122.276469\nEnding Coordinate (lat,long): 35.281107, -120.661211\n\n```", "```py\nstart node = (-122.272515, 37.797457)\nend node = (-120.66285, 35.285892)\n(-122.272515, 37.797457) -> (-122.176834, 37.719054), length = 12528\n(-122.176834, 37.719054) -> (-122.176734, 37.718964), length = 13\n...\n(-120.663604, 35.286751) -> (-120.663466, 35.286594), length = 21\n(-120.663466, 35.286594) -> (-120.66285, 35.285892), length = 95\nTotal length = 358838\n\n```"]