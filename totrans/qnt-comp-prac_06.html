<html><head></head><body>
		<div><h1 id="_idParaDest-157"><em class="italic"><a id="_idTextAnchor156"/>Chapter 6</em>: Understanding the Qiskit® Gate Library</h1>
			<p>In this chapter, we will explore the quantum gates that are offered out of the Qiskit® box. By including a quantum gate library that features the most common gates, Qiskit® makes coding your circuits easy.</p>
			<p>Among the gates that we will look at are the Pauli X, Y, and Z gates used for basic qubit flips, the H (or Hadamard) gate used to create qubit superpositions, and the CX (controlled-NOT) gate used to create quantum entanglement. For a quick refresher, take a look at <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>. </p>
			<p>We will also look at the specialized S and T gates, spin our qubits with R gates, and then show how just a minimal set of U1, U2, U3, ID, and CX basis gates are used to translate the other gates for direct use with a quantum computer.</p>
			<p>We will stop by the multi-qubit gates and finally end our tour with a short look beneath the covers to see how the simple gates that we string out in the Qiskit® programs get translated into much more complex sets of basis gates by the transpiler before we can run them on a real quantum computer.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Visualizing quantum gates</li>
				<li>Flipping with the Pauli X, Y, and Z gates</li>
				<li>Creating superpositions with the H gate</li>
				<li>Fixed Z rotations with phase shift gates S, S†, T, and T†</li>
				<li>Free rotation around the axes with Rx, Ry, and Rz</li>
				<li>Building our circuits with the basis gates – U1, U2, U3, and ID</li>
				<li>Using gates on 2 qubits	</li>
				<li>Using gates on more than 2 qubits</li>
				<li>What your quantum circuit really looks like</li>
			</ul>
			<p>In these recipes, you will be exposed to quantum gate unitary matrixes and qubit state vectors, both of which we discussed mathematically in the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>. Feel free to jump back and test the math again if needed. </p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>The quantum programs that we discuss in this chapter can be found here:  <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter06</a>.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor158"/>Visualizing quantum gates</h1>
			<p>To help us <a id="_idIndexMarker319"/>understand quantum gates, we can use the <code>ch6_r1_quantum_gate_ui.py</code> sample program. </p>
			<p>This recipe differs a bit from the ones that we have seen so far. Up until now, we have mainly just used Qiskit® commands inside a Python wrapper, with no actual coding beyond that. This time, we start out by building a rudimentary Python implementation to create a very basic <em class="italic">before-after gate exploration UI</em>. When you run the program, it prompts you to select an initial qubit state and a gate to apply to your qubit; then it creates a visualization to show you the gate action on the qubit. </p>
			<p>The script builds your circuit for you and then shows the basic minimum circuit that supports the gate, the state vector, and a Bloch sphere or Q-sphere visualization that corresponds to the gate action. The visualization highlights the qubit's state before the gate, and how the state changes after the gate.</p>
			<p class="callout-heading">Hybrid classical/quantum programs</p>
			<p class="callout">So, what we are doing here is building a hybrid classical/quantum program, where we use Python to drive user input control, general logic, and presentation, and the Qiskit® components to access the quantum-related features. This is what we will be doing going forward in the following chapters.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/>Getting ready</h2>
			<p>Before we step into the visualizer, let's spend a second discussing a few basic qubit states that we can initialize our qubit in. You know two of them (<img alt="" src="img/Formula_06_001.png"/> and <img alt="" src="img/Formula_06_002.png"/>) well, but for an understanding of where on the Bloch sphere our qubit state vector points, here's a quick introduction of the <a id="_idIndexMarker320"/>rest with their Dirac ket description and a Bloch sphere reference:</p>
			<ul>
				<li><img alt="" src="img/Formula_06_003.png"/>: Straight up along the <em class="italic">z</em> axis</li>
				<li><img alt="" src="img/Formula_06_004.png"/>: Straight down along the <em class="italic">z</em> axis</li>
				<li><img alt="" src="img/Formula_06_005.png"/>: Out along the + <em class="italic">x</em> axis</li>
				<li><img alt="" src="img/Formula_06_006.png"/>: In along the - <em class="italic">x</em> axis</li>
				<li><img alt="" src="img/Formula_06_007.png"/>: Right along the + <em class="italic">y</em> axis</li>
				<li><img alt="" src="img/Formula_06_008.png"/>: Left along the - <em class="italic">y</em> axis</li>
			</ul>
			<div><div><img alt="Figure 6.1 – The initial qubit states mapped on the Bloch sphere" src="img/Figure_6.1_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The initial qubit states mapped on the Bloch sphere</p>
			<p>In this <a id="_idIndexMarker321"/>recipe, we will explore several interesting Qiskit® features:</p>
			<ul>
				<li><code>qiskit.visualization</code> class includes various methods to visualize your qubits and <a id="_idIndexMarker322"/>your circuits. In this recipe, we will use the following:<p><strong class="bold">Bloch sphere</strong>: Displays a single qubit as a Bloch sphere:</p><pre>plot_bloch_multivector(state_vector)</pre><p><strong class="bold">Q-sphere</strong>: Displays 1 or more qubits as a state probability vector on a sphere:</p><pre>plot_state_qsphere(state_vector)</pre></li>
				<li><strong class="bold">Initialize</strong>: Used to initialize a qubit to specific initial states:<pre>circuit.initialize(initial_vector,qubit)</pre></li>
				<li><strong class="bold">Statevector simulator</strong>: An <strong class="bold">Aer</strong> quantum simulator that is used to calculate the state vector of a qubit:<pre>Aer.get_backend('statevector_simulator')</pre></li>
				<li><strong class="bold">Unitary simulator</strong>: An <strong class="bold">Aer</strong> quantum simulator that lets you calculate the unitary matrix of a quantum circuit. If you use this simulator on a circuit that contains only a single gate, you can in essence pull out the matrix representation of<a id="_idIndexMarker323"/> that quantum gate:<pre>Aer.get_backend('unitary_simulator')</pre></li>
				<li><code>QuantumCircuit.from_qasm_str(qasm_string)</code> method that we explored in the <em class="italic">Moving between worlds</em> recipe in <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum® Experience – Drag and Drop Quantum Computing</em>.</li>
			</ul>
			<p>The code for the sample program is available here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>How to do it...</h2>
			<p>The sample program is a<a id="_idIndexMarker324"/> little convoluted but running it is straightforward. Each step is separated by an input step to select start states and gates, or by a simple <em class="italic">Hit Enter</em> before the next step rolls along:</p>
			<ol>
				<li>Run the <code>ch6_r1_quantum_gate_ui.py</code> sample file in your Python environment.<p>At the first prompt, enter the starting state for your first qubit. If you pick a gate that uses more than 1 qubit, such as the CX gate, the qubit state that you select here is for the controlling qubit. Your options are the following:</p><div><img alt="Figure 6.2 – The first prompt: Select a start state" src="img/Figure_6.2_B14436.jpg"/></div><pre># List our start states
start_states=["1","+","-","R","L","r","d"]
valid_start=["0"]+start_states</pre></li>
				<li>At the second prompt, enter the gate that you want to explore, for example <code>X</code>:<div><img alt="Figure 6.3 – The second prompt: Select a gate&#13;&#10;" src="img/Figure_6.3_B14436.jpg"/></div><pre># List our gates
rot_gates=["rx","ry","rz"]
unitary_gates=["u1","u2","u3"]
single_gates=["id","x","y","z","t","tdg","s","sdg","h"]
    +rot_gates
oneq_gates=single_gates+unitary_gates
control_gates=["cx","cy","cz","ch"]
twoq_gates=control_gates+["swap"]
all_gates=oneq_gates+twoq_gates+rot_gates+unitary_gates</pre><p>The program now uses the <code>get unitary()</code> function from the sample code on a blank circuit to <a id="_idIndexMarker326"/>retrieve and print the unitary matrix for the gate that you selected. </p><p>For an X gate, the output will look something like this:</p><div><img alt="Figure 6.4 – First output: The unitary for the gate" src="img/Figure_6.4_B14436.jpg"/></div><p class="figure-caption">Figure 6.4 – First output: The unitary for the gate</p><p>Compare this to the matrix version of the X gate that we calculated in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>:</p><div><img alt="" src="img/Formula_06_019.jpg"/></div><p>We are now ready for the meat of the program. </p></li>
				<li>Press <em class="italic">Enter</em> to create the initial setup.<p>The program calls the <code>qgate(gate,start)</code> function to set up the circuit based on your input. It uses the gate input with <code>create_circuit(n_qubits,start)</code> to set up a 1-qubit or 2-qubit circuit, and then uses the <code>qgate_out(circuit,start)</code> function to display the empty circuit. At <a id="_idIndexMarker327"/>this point, the circuit will only include an <code>initialized</code> qubit set to the starting state you selected, and if the input state is <img alt="" src="img/Formula_06_001.png"/>, then we do not need to initialize the circuit at all. </p><p>The <code>initialize()</code> method takes a vector of complex amplitudes and a target qubit as input and adds a circuit instruction that looks much like a gate. The complex amplitudes must be normalized, and in the program, we use the following to create the vector: <code>[a * complex(1, 0), b * complex(1, 0)]</code>. </p><p>The output should be something like the following:</p><p class="figure-caption"> </p><div><img alt="Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere&#13;&#10;" src="img/Figure_6.5_B14436.jpg"/></div><p class="figure-caption">Figure 6.5 – Second output: Initial circuit, state vector, and Bloch-sphere</p></li>
				<li>Press <em class="italic">Enter</em> again to <a id="_idIndexMarker328"/>add the gate you selected and display the end results after the gate.<p>The end result of the call to the <code>qgate(gate,start)</code> function was to return the complete circuit. We now use the <code>qgate_out(circuit,start)</code> function to display the final results, after the gate is applied. </p><p>Here is the expected output for an X gate, acting on a qubit initialized to <img alt="" src="img/Formula_06_021.png"/>:</p></li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img alt="Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after the gate " src="img/Figure_6.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Third output: Circuit, state vector, and Bloch sphere after the gate </p>
			<p>The result of the initial<a id="_idIndexMarker329"/> run is the qubit started out in the <img alt="" src="img/Formula_06_022.png"/> state, pointing straight up, and was then flipped by the X gate to <img alt="" src="img/Formula_06_002.png"/>, pointing straight down. </p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/>How it works...</h2>
			<p>In the program, we defined several functions that run the Qiskit® specific functionality of the program: </p>
			<ul>
				<li><code>get_psi(circuit)</code>: This is the same function that we introduced in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic"> Starting at the Ground Level with Terra</em>, with a slight twist. Instead of using it to directly plot the Bloch vector, we set it up to return the state vector so that we can use it elsewhere. The function takes as input a quantum circuit and returns the state vector of that circuit by using the <code>statevector_simulator</code> backend that is provided by Qiskit Aer:<pre>def get_psi(circuit):
    global psi
    backend = Aer.get_backend('statevector_simulator') 
    result = execute(circuit, backend).result()
    psi = result.get_statevector(circuit)
    return(psi)</pre></li>
				<li><code>get_unitary(circuit)</code>: This function takes as input a quantum circuit and returns the unitary <a id="_idIndexMarker330"/>matrix for that circuit by using the <code>unitary_simulator</code> Aer backend:<pre>def get_unitary(circuit):
    simulator = Aer.get_backend('unitary_simulator')
    result = execute(circuit, simulator).result()
    unitary = result.get_unitary(circuit)  
    return(unitary)  </pre></li>
				<li><code>create_circuit(n_qubits,start)</code>: This function creates a quantum circuit and initializes it to the start state that you selected. <p>We start by setting up the start vector based on the user input: <code>1</code>, <code>+</code>, <code>-</code>, <code>R</code>, <code>L</code>, <code>r</code>, or <code>d</code>:</p><pre>def create_circuit(n_qubits,start):
    if start=="1":
        initial_vector = [0,complex(1,0)]
    elif start=="+":
        # Create |+&gt; state
        initial_vector = [1/sqrt(2) * complex(1, 0),             1/sqrt(2) * complex(1, 0)]
    elif start=="-":
        # Create |-&gt; state
        initial_vector = [1/sqrt(2) * complex(1, 0),             -1/sqrt(2) * complex(1, 0)]
    elif start=="R":
        # Create <img alt="" src="img/Formula_06_024.png"/> state
        initial_vector = [1/sqrt(2) * complex(1, 0),            1*1.j/sqrt(2) * complex(1, 0)]
    elif start=="L":
        # Create <img alt="" src="img/Formula_06_025.png"/> state
        initial_vector = [1/sqrt(2) * complex(1, 0),            -1*1.j/sqrt(2) * complex(1, 0)]
    elif start=="r":
        # Create random initial vector
        theta=random.random()*pi
        phi=random.random()*2*pi
        a = cos(theta/2)
        b = cmath.exp(phi*1j)*sin(theta/2)
        initial_vector = [a * complex(1, 0),            b * complex(1, 0)]
    elif start=="d":
        a = cos(start_theta/2)
        b = cmath.exp(start_phi*1j)*sin(start_theta/2)
        initial_vector = [a * complex(1, 0),            b * complex(1, 0)]
    else:
        initial_vector = [complex(1,0),0]
    if start!="n":
        print("\nInitial vector for |"+start+"\u232A:")
        print(np.around(initial_vector, decimals = 3))   </pre><p>We then create the circuit for the specified number of qubits and initialize the qubit if the<a id="_idIndexMarker331"/> start state is not <img alt="" src="img/Formula_06_001.png"/>:</p><pre>    circuit = QuantumCircuit(n_qubits)
    if start in start_states:
        circuit.initialize(initial_vector,n_qubits-1)
    return(circuit)</pre></li>
				<li><code>qgate_out(circuit,start)</code>: In addition, we use the <code>print</code> functionality with some of the Qiskit® methods to create and save images of our circuits and the Bloch-sphere representations of the qubits:<pre>def qgate_out(circuit,start):
    # Print the circuit
    psi=get_psi(circuit)
    if start!="n":
        print("\nCircuit:")
        print("--------")
        print(circuit)
        print("\nState vector:")
        print("-------------")
        print(np.around(psi, decimals = 3))
        display(plot_bloch_multivector(psi))
        if circuit.num_qubits&gt;1 and gate 
            in control_gates:
            display(plot_state_qsphere(psi))
    return(psi)</pre></li>
				<li><code>qgate(gate,start)</code>: This function takes as input a gate and a start state, and then creates a quantum circuit from these. For single-qubit gates, the gate is added to the first qubit, and for 2-qubit gates, the second qubit is the controller qubit and the first qubit is the controlled qubit.<p>It then compares <a id="_idIndexMarker332"/>the input gate to the <code>oneq_gates</code> list, and promptly calls the <code>create_circuit()</code> function to create a 1-qubit or 2-qubit circuit. At this point, we also create the correct 1-qubit or 2-qubit QASM string that we use to append the selected gate to the circuit using the <code>from_qasm_str()</code> method that we started looking at in the <em class="italic">Moving between worlds</em> recipe in <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum Experience® – Quantum Drag and Drop</em>. As luck would have it, the QASM code for our gates corresponds one-to-one with the names of the gates. To add an <code>x</code> gate, we use the following command:</p><pre>circuit+=QuantumCircuit.from_qasm_str(qasm_string+gate+"    q[0];")</pre><p>Where the string addition is in the <code>from_qasm_string()</code> command:</p><pre>qasm_string+gate+" q[0];" </pre><p>This translates into the following code and appends the <code>x</code> <code>gate</code> to the circuit:</p><pre>OPENQASM 2.0; include "qelib1.inc"; 
qreg q[1];
x q[0];</pre><p>The <code>qgate()</code> function then returns the circuit and we can move on:</p><pre>def qgate(gate,start): 
    # If the gates require angles, add those to the QASM
    # code
    qasm_angle_gates={"rx":"rx("+str(theta)+") q[0];",        "ry":"ry("+str(theta)+") q[0];",
        "rz":"rz("+str(phi)+") q[0];",        "u1":"u1("+str(phi)+") q[0];",        "u2":"u2("+str(phi)+",
        "+str(lam)+") q[0];", 
        "u3":"u3("+str(theta)+",
        "+str(phi)+","+str(lam)+") q[0];"}
    # Create the circuits and then add the gate using 
    # QASM import 
    if gate in oneq_gates:
        circuit=create_circuit(1,start)
        qasm_string='OPENQASM 2.0; include "qelib1.inc";
            qreg q[1];'
    else: 
        circuit=create_circuit(2,start)
        qasm_string='OPENQASM 2.0; include "qelib1.inc";            qreg q[2];'
    qgate_out(circuit,start)    
    if gate in oneq_gates:
        if gate in rot_gates+unitary_gates:
            circuit+=QuantumCircuit.from_qasm_str(
                qasm_string+qasm_angle_gates[gate])
        else:
            circuit+=QuantumCircuit.from_qasm_str(
                qasm_string+gate+" q[0];")
    else:
        circuit+=QuantumCircuit.from_qasm_str(
            qasm_string+gate+" q[1],q[0];")   
    return(circuit)</pre></li>
			</ul>
			<p>So, now you are equipped with a little program that lets you set up very basic one-gate circuits and study the initial and final state vectors, see the unitary matrixes of the selected gates, and view<a id="_idIndexMarker333"/> how the gates make the Bloch vector move around, and visualize on a <strong class="bold">Q-sphere</strong> where <a id="_idIndexMarker334"/>the <strong class="bold">Bloch sphere</strong> is no longer enough. </p>
			<p>Now take this program for a spin by working your way through the rest of the recipes in this chapter to explore<a id="_idIndexMarker335"/> the base set of quantum gates that Qiskit® provides.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/>See also</h2>
			<p>For a quick interactive look at a single-qubit Bloch sphere representation and what certain gate operations do to it, take a look at the <strong class="bold">grok-bloch</strong> application by Qiskit Advocate<a id="_idIndexMarker336"/> James Weaver: <a href="https://github.com/JavaFXpert/grok-bloch">https://github.com/JavaFXpert/grok-bloch</a>. You can install and run it from your own Python environment or run it online here: <a href="https://javafxpert.github.io/grok-bloch/">https://javafxpert.github.io/grok-bloch/</a>.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/>Flipping with the Pauli X, Y, and Z gates</h1>
			<p>The<a id="_idIndexMarker337"/> Pauli <a id="_idIndexMarker338"/>X, Y, and Z gates all act on a single qubit, and perform <a id="_idIndexMarker339"/>an action similar to a classical NOT gate, which flips the value of a classical bit. For example, the X gate sends <img alt="" src="img/Formula_06_027.png"/> to <img alt="" src="img/Formula_06_028.png"/> and vice versa.</p>
			<p>As we shall see, the X gate is actually a rotation around the <em class="italic">x</em> axis of <img alt="" src="img/Formula_06_029.png"/> radians. The same is true for the Pauli Y and Z gates, but along the <em class="italic">y</em> and <em class="italic">z</em> axes correspondingly.</p>
			<p>Mathematically, the X, Y, and Z gates can be expressed as the following unitary matrixes:</p>
			<p><img alt="" src="img/Formula_06_030.png"/> <img alt="" src="img/Formula_06_031.png"/> <img alt="" src="img/Formula_06_032.png"/></p>
			<p>This recipe will serve as a sort of template for how to use the sample code that is provided in the chapter. The remaining recipes will largely gloss over the deeper details. </p>
			<p>Let's take a look at the Pauli X, Y, and Z gates by running the Quantum Gate UI sample program. It starts by setting up a plain quantum circuit with a single qubit initiated in a state that you select. The gate selected is then added to the circuit, and then the unitary simulator and state vector simulators are run to display the results in the form of a qubit state vector and the gate unitary matrix.</p>
			<p>The sample script is available at: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor165"/>How to do it...</h2>
			<ol>
				<li value="1">Run the <code>ch6_r1_quantum_gate_ui.py</code> sample program.</li>
				<li>Select a start state for your qubit.<p>The X <a id="_idIndexMarker340"/>and <a id="_idIndexMarker341"/>Y gates<a id="_idIndexMarker342"/> work well with <img alt="" src="img/Formula_06_0221.png"/> and <img alt="" src="img/Formula_06_023.png"/>, essentially acting as a NOT gate. </p><p>With <img alt="" src="img/Formula_06_035.png"/>), the X gate will do nothing, but the Y and Z gate will create a phase shift of <img alt="" src="img/Formula_06_036.png"/>, creating <img alt="" src="img/Formula_06_037.png"/>. </p><p>Also test <img alt="" src="img/Formula_06_038.png"/> and <img alt="" src="img/Formula_06_039.png"/> to see what they do. If you use the <strong class="bold">r</strong> (<strong class="bold">random</strong>) or <strong class="bold">d</strong> (<strong class="bold">define</strong>) inputs, then you can explore the gate rotations in more detail.</p></li>
				<li>When prompted, enter <code>x</code>, <code>y</code>, or <code>z</code> to select the gate to test.<p>We tested the X gate in the <em class="italic">Visualizing the quantum gates</em> recipe. Now take a look at the others.</p><p>The Z gate with a random start state might produce the following output: </p></li>
			</ol>
			<p class="figure-caption">  </p>
			<div><div><img alt="Figure 6.7 – The Z gate with a random start state" src="img/Figure_6.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – The Z gate with a random start state</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor166"/>There's more...</h2>
			<p>The Pauli <a id="_idIndexMarker343"/>gates <a id="_idIndexMarker344"/>cannot run directly on a quantum backend, but are <a id="_idIndexMarker345"/>automatically transpiled to the following unitary basis gates before you run your program:</p>
			<pre>x(qubit) = u3(3.141,0,3.141,qubit)
y(qubit) = u3(3.141,1.571,1.571,qubit)
z(qubit) = u1(3.141,qubit)</pre>
			<p>For<a id="_idIndexMarker346"/> more<a id="_idIndexMarker347"/> information, see<a id="_idIndexMarker348"/> the <em class="italic">Building our circuits with the basis gates – U1,U2, U3, and ID</em> and <em class="italic">What your quantum circuit really looks like</em> recipes in this chapter. </p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor167"/>Creating superpositions with the H gate</h1>
			<p>Now, let's<a id="_idIndexMarker349"/> revisit <a id="_idIndexMarker350"/>our old<a id="_idIndexMarker351"/> friend from <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, the <strong class="bold">Hadamard</strong> or <strong class="bold">H</strong> gate. This is a fairly specialized gate that we can use to make a generic qubit superposition. But there's more to it than that; we can also make use of the H gate to change the axis of measurement from the generic <em class="italic">z</em> (or computational) axis to the <em class="italic">x</em> axis to gain additional insights into the qubit behavior. More on that in the <em class="italic">There's more</em> section.</p>
			<p>The H gate can be expressed as the following unitary matrix:</p>
			<div><div><img alt="" src="img/Formula_06_040.jpg"/>
				</div>
			</div>
			<p>Unless you are really good at interpreting matrix operations, it might not be entirely clear just what this gate will do with your qubits. If we describe the behavior as a combination of 2 qubit rotations instead, things might become clearer. When you apply the Hadamard gate to your qubit, you run it through two rotations: first a <img alt="" src="img/Formula_06_041.png"/> rotation around the <em class="italic">y</em> axis, and then a <img alt="" src="img/Formula_06_042.png"/> rotation around the <em class="italic">x</em> axis.</p>
			<p>For a qubit in state <img alt="" src="img/Formula_06_043.png"/>, this means that we start at the North Pole, and then travel down to the equator, ending up at the <img alt="" src="img/Formula_06_044.png"/> location on the Bloch sphere, and finally just rotate around the <em class="italic">x</em> axis. Similarly, if you start at the South Pole at <img alt="" src="img/Formula_06_045.png"/>, you first move up to the equator but at the other extreme on the <em class="italic">x</em> axis, ending up at <img alt="" src="img/Formula_06_046.png"/>.</p>
			<p>If we do the matrix math for <img alt="" src="img/Formula_06_047.png"/>, we get the following:</p>
			<div><div><img alt="" src="img/Formula_06_048.jpg"/>
				</div>
			</div>
			<p>Now we can use the following Dirac ket notation: </p>
			<div><div><img alt="" src="img/Formula_06_049.jpg"/>
				</div>
			</div>
			<p class="figure-caption"><img alt="" src="img/Formula_06_050.png"/></p>
			<p>If we replace <em class="italic">a</em> and <em class="italic">b</em> with <img alt="" src="img/Formula_06_051.png"/> from above, we get: <img alt="" src="img/Formula_06_052.png"/> and <img alt="" src="img/Formula_06_053.png"/>, which corresponds to <img alt="" src="img/Formula_06_044.png"/>.</p>
			<p>If we apply the <a id="_idIndexMarker352"/>Hadamard gate to qubits in states other<a id="_idIndexMarker353"/> than pure <img alt="" src="img/Formula_06_055.png"/> and <img alt="" src="img/Formula_06_056.png"/>, we rotate the qubit to a new position. </p>
			<p>The sample script is available at: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>How to do it...</h2>
			<p>To explore the Hadamard gate, we run the Quantum Gate program that is described in the <em class="italic">Visualizing quantum gates</em> recipe:</p>
			<ol>
				<li value="1">Run the <code>ch6_r1_quantum_gate_ui.py</code> sample program.</li>
				<li>Select a start state for your qubit.<p>The H gate works well with <img alt="" src="img/Formula_06_057.png"/> and <img alt="" src="img/Formula_06_058.png"/>, placing you on the equator in an equal superposition. With <img alt="" src="img/Formula_06_059.png"/> and <img alt="" src="img/Formula_06_060.png"/>, the H gate will return the equal superposition to the corresponding computational states, <img alt="" src="img/Formula_06_0221.png"/> and <img alt="" src="img/Formula_06_023.png"/>. Try the <img alt="" src="img/Formula_06_063.png"/>, <img alt="" src="img/Formula_06_0391.png"/>, Random or Define inputs to explore the gate rotations in more detail. </p></li>
				<li>When prompted, enter <em class="italic">h</em> to select the gate to test. The H gate applied to <img alt="" src="img/Formula_06_0221.png"/> will produce the following output: </li>
			</ol>
			<p class="figure-caption"> </p>
			<div><div><img alt="Figure 6.8 – The H gate with |0&gt; start state&#13;&#10;" src="img/Figure_6.8_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The H gate with |0&gt; start state</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor169"/>There's more...</h2>
			<p>The Hadamard gate<a id="_idIndexMarker354"/> cannot run directly on a quantum <a id="_idIndexMarker355"/>backend, but is automatically transpiled to the following unitary basis gate before you run your program:</p>
			<pre>h(qubit)=u2(0,3.141,qubit)</pre>
			<p>For more information, see the <em class="italic">Building our circuits with the basis gates – U1,U2, U3, and ID</em> and <em class="italic">What your quantum circuit really looks like</em> recipes in this chapter.</p>
			<p>The Hadamard gate is also commonly used to change your measurement axis from the default (computational) <em class="italic">z</em> axis to the <em class="italic">x</em> axis. By measuring in the <em class="italic">x</em> axis, you can detect the qubit phase. </p>
			<p>To figure out the value of the phase, you must add one more measurement, this time along the <em class="italic">y</em> axis. To achieve this, you use the Hadamard gate in combination with the S dagger gate to shift over to Y. </p>
			<p>The way you can visualize the changing of the measurement basis is to picture us rotating the qubit to match up with the axis we want to measure, and then do a standard Z measurement. When we measure along the <em class="italic">x</em> axis, we rotate the qubit to face in the <img alt="" src="img/Formula_06_066.png"/> direction, and for the <em class="italic">y</em> axis to point, in the <img alt="" src="img/Formula_06_156.png"/> direction.</p>
			<p>Here are the gate<a id="_idIndexMarker356"/> combinations that you need to apply to <a id="_idIndexMarker357"/>measure along the three Bloch sphere<a id="_idIndexMarker358"/> axes:</p>
			<p><strong class="bold">Measure along z (computational basis):</strong></p>
			<div><div><img alt="Figure 6.9 - Measure along z" src="img/Figure_6.9_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.9 - Measure along z</p>
			<p><strong class="bold">Measure along x:</strong></p>
			<div><div><img alt="Figure6.10 - Measure along x" src="img/Figure_6.10_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure6.10 - Measure along x</p>
			<p><strong class="bold">Measure along y:</strong></p>
			<div><div><img alt="Figure 6.11 - Measure along y" src="img/Figure_6.11_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.11 - Measure along y</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor170"/>See also</h2>
			<p>For an example of measuring along different axes to measure the phase of a qubit, see the <em class="italic">Exploring quantum phase kickback</em> recipe of <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Fixed z rotations with phase shift gates S, <img alt="" src="img/Formula_06_0681.png"/>, T, and <img alt="" src="img/Formula_06_0691.png"/></h1>
			<p>The S, <img alt="" src="img/Formula_06_070.png"/>, T, and <img alt="" src="img/Formula_06_071.png"/> gates <a id="_idIndexMarker359"/>all perform rotations <a id="_idIndexMarker360"/>around<a id="_idIndexMarker361"/> the <em class="italic">z</em> axis<a id="_idIndexMarker362"/> of <a id="_idIndexMarker363"/>the qubit. This means that <a id="_idIndexMarker364"/>when <a id="_idIndexMarker365"/>you<a id="_idIndexMarker366"/> measure the qubit, there is no change in the probability of measuring the outcome as 1 or 0. What does change is the phase of the qubit. </p>
			<p class="callout-heading">The S-gate and T-gate are not their own inverses</p>
			<p class="callout">As the S and T gates perform set rotations around the <em class="italic">z</em> axis, they are not reversible. Adding two of these gates in a row does not negate them. Instead, Qiskit includes the S† and T† gates which serve as the reverse S and T gates. For a quick reminder, see the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>.</p>
			<p>Mathematically, the S and T gates can be expressed as the following unitary matrixes:</p>
			<p><img alt="" src="img/Formula_06_072.png"/> <img alt="" src="img/Formula_06_073.png"/> <img alt="" src="img/Formula_06_074.png"/> <img alt="" src="img/Formula_06_075.png"/></p>
			<p>The sample script is available at: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor172"/>How to do it...</h2>
			<p>To <a id="_idIndexMarker367"/>explore<a id="_idIndexMarker368"/> the<a id="_idIndexMarker369"/> phase <a id="_idIndexMarker370"/>shift <a id="_idIndexMarker371"/>gates, we <a id="_idIndexMarker372"/>run the <a id="_idIndexMarker373"/>Quantum<a id="_idIndexMarker374"/> Gate UI <a id="_idIndexMarker375"/>program that is described in the <em class="italic">Visualizing quantum gates</em> recipe:</p>
			<ol>
				<li value="1">Run the <code>ch6_r1_quantum_gate_ui.py</code> sample program.</li>
				<li>Select a start state for your qubit.<p>As these phase shift gates perform rotations around the <em class="italic">z</em> axis, there is very little point in using the default <img alt="" src="img/Formula_06_0221.png"/> or <img alt="" src="img/Formula_06_023.png"/> qubits, which are phaseless. Instead, pick a superposition state qubit such as <strong class="bold">+</strong>, <strong class="bold">-</strong>, <strong class="bold">L</strong>, <strong class="bold">R</strong>, <strong class="bold">r</strong>, or <strong class="bold">d</strong>. </p></li>
				<li>When prompted, enter <code>s</code>, <code>sdg</code>, <code>t</code>, or <code>tdg</code> to select the gate to test. The S gate on <img alt="" src="img/Formula_06_078.png"/> should produce the following output:<div><img alt="Figure 6.12 – The S gate with the  start state" src="img/Figure_6.12_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.12 – The S gate with the <img alt="" src="img/Formula_06_079.png"/> start state</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor173"/>There's more...</h2>
			<p>The phase shift gates cannot<a id="_idIndexMarker376"/> run directly on a quantum backend, but are automatically transpiled to the following unitary basis gates before you run your program:</p>
			<pre>s(qubit) = u1(1.570,qubit)
sdg(qubit) = u1(-1.570,qubit)
t(qubit) = u1(0.785,qubit)
tdg(qubit) = u1(-0.785,qubit)</pre>
			<p>For more information, see the <em class="italic">Building our circuits with the basis gates – U1,U2, U3, and ID</em> and <em class="italic">What your quantum circuit really looks like</em> recipes in this chapter. </p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor174"/>Free rotation around the axes with Rx, Ry, and Rz</h1>
			<p>While all <a id="_idIndexMarker377"/>the phase<a id="_idIndexMarker378"/> gates rotate around the <em class="italic">z</em> axis to<a id="_idIndexMarker379"/> change the phase of the qubit, the rotation gates perform rotations around the respective axes of the Bloch sphere. Rx and Ry rotate the qubit <img alt="" src="img/Formula_06_015.png"/> angle at the phase angle (<img alt="" src="img/Formula_06_080.png"/>) 0 and <img alt="" src="img/Formula_06_081.png"/> , and Rz rotates around Z, with the special case of <img alt="" src="img/Formula_06_082.png"/> and <img alt="" src="img/Formula_06_083.png"/>, corresponding to the S and T gates.</p>
			<p class="callout-heading">The R-gates are not their own inverses</p>
			<p class="callout">As the R-gates perform free rotations around the X, Y, or Z axes, they are not reversible. Adding two of these gates in a row does not negate them. For a quick reminder, see the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>.</p>
			<p>Mathematically, the<a id="_idIndexMarker380"/> R <a id="_idIndexMarker381"/>gates can <a id="_idIndexMarker382"/>be expressed as unitary matrixes:</p>
			<div><div><img alt="" src="img/Formula_06_084.jpg"/>
				</div>
			</div>
			<div><div><img alt="" src="img/Formula_06_085.jpg"/>
				</div>
			</div>
			<div><div><img alt="" src="img/Formula_06_086.jpg"/>
				</div>
			</div>
			<p>The sample script is available at: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor175"/>How to do it...</h2>
			<p>To explore the phase shift gates, we run the Quantum Gate program that is described in the <em class="italic">Visualizing the quantum gates</em> recipe: </p>
			<ol>
				<li value="1">Run the <code>ch6_r1_quantum_gate_ui.py</code> sample program.</li>
				<li>Select <a id="_idIndexMarker383"/>a start <a id="_idIndexMarker384"/>state<a id="_idIndexMarker385"/> for your qubit.<p>The R gates perform arbitrary rotations around the corresponding axes. </p><p>As all these gates perform rotations around the corresponding axes, play around with <img alt="" src="img/Formula_06_087.png"/> to get a feel for what rotates where. Then test with Random or Define to explore more exotic rotations.</p></li>
				<li>When prompted, enter <code>rx</code>, <code>ry</code>, or <code>rz</code> to select the gate to test.</li>
				<li>Enter the angle (<img alt="" src="img/Formula_06_088.png"/>) with which to rotate. The Rx gate, set to <img alt="" src="img/Formula_06_089.png"/> rotation on <img alt="" src="img/Formula_06_090.png"/>, should produce the following output:<div><img alt="Figure 6.13 – The Rx gate rotating  with the  start state" src="img/Figure_6.13_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.13 – The Rx gate rotating <img alt="" src="img/Formula_06_091.png"/> with the <img alt="" src="img/Formula_06_092.png"/> start state</p>
			<p>Now, test<a id="_idIndexMarker386"/> again<a id="_idIndexMarker387"/> using various rotation <a id="_idIndexMarker388"/>angles to see the behavior by entering the following values for the <img alt="" src="img/Formula_06_093.png"/> and/or <img alt="" src="img/Formula_06_094.png"/> angles:</p>
			<div><div><img alt="" src="img/Formula_06_095.jpg"/>
				</div>
			</div>
			<div><div><img alt="" src="img/Formula_06_096.jpg"/>
				</div>
			</div>
			<div><div><img alt="" src="img/Formula_06_097.jpg"/>
				</div>
			</div>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor176"/>There's more...</h2>
			<p>The Pauli gates <a id="_idIndexMarker389"/>cannot run directly on a quantum backend, but are automatically transpiled to the following unitary basis gates before you run your program:</p>
			<pre>rx(<img alt="" src="img/Formula_06_093.png"/>,qubit) = u3(<img alt="" src="img/Formula_06_099.png"/>,-1.507,1.507,qubit)
ry(<img alt="" src="img/Formula_06_093.png"/>,qubit) = u3(<img alt="" src="img/Formula_06_093.png"/>,0,0,qubit)
rz(<img alt="" src="img/Formula_06_094.png"/>,qubit) = u1(<img alt="" src="img/Formula_06_094.png"/>,qubit)</pre>
			<p>For more information, see the <em class="italic">Building our circuits with the basis gates – U1,U2, U3, and ID</em> and <em class="italic">What your quantum circuit really looks like</em> recipes in this chapter. </p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor177"/>Building our circuits with the basis gates – U1, U2, U3, and ID </h1>
			<p>Let's begin<a id="_idIndexMarker390"/> by<a id="_idIndexMarker391"/> exploring<a id="_idIndexMarker392"/> three <a id="_idIndexMarker393"/>of <a id="_idIndexMarker394"/>the<a id="_idIndexMarker395"/> gates<a id="_idIndexMarker396"/> that <a id="_idIndexMarker397"/>we recognize from <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®</em>. You will not be using these three basis gates, U1, U2, and U3, in your quantum programs. However, they serve as building blocks for all other single-qubit gates when you run your circuits on a quantum computer. In fact, every other single-qubit gate can be written using just the U3 gate. There is nothing explicitly stopping you from using them, but the gate collection that we will go through in the rest of the recipes covers all the ground that we need.</p>
			<p class="callout-heading">The U gates are not their own inverses</p>
			<p class="callout">As the U gates perform free rotations around the <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em> axes, they are generally not reversible. Adding two of these gates in a row does not negate them unless the rotations add up to complete rotations. For a quick reminder, see the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>.</p>
			<p>If you<a id="_idIndexMarker398"/> remember<a id="_idIndexMarker399"/> back <a id="_idIndexMarker400"/>when<a id="_idIndexMarker401"/> we<a id="_idIndexMarker402"/> explored <a id="_idIndexMarker403"/>the<a id="_idIndexMarker404"/> IBM Quantum® backends in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®</em>, we took a look at<a id="_idIndexMarker405"/> the so-called <strong class="bold">basis gates</strong> available for the hardware backend using the following command:</p>
			<pre>backend.configuration().basis_gates</pre>
			<p>It returned something like this:</p>
			<pre>['u1', 'u2', 'u3', 'cx', 'id']</pre>
			<p>The CX and ID gates are ordinary gates that you use in your programs, UX (Controlled NOT) to create entanglements, and ID to run a gate that leaves the qubit untouched (more on these later). The U1, U2, and U3 gates are different though. </p>
			<p>Remember from <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, how we can see a quantum gate as a rotation around the <img alt="" src="img/Formula_06_104.png"/> and <img alt="" src="img/Formula_06_105.png"/> angles. This is exactly what the U gates do, with one, two, and three inputs respectively. In fact, single-qubit U-gate rotations and CNOT gates constitute a universal gate set for quantum computing. And here, the Id gate is a special case of rotation, with no rotation at all.</p>
			<p>The key thing with the basis gates is that you can program your qubits directly on the hardware using them. All other gates are translated into basis gates and then executed as you will see when we discuss the transpiler.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor178"/>The U3 gate</h2>
			<p>The U3 gate is really the Swiss <a id="_idIndexMarker406"/>Army knife of quantum gates. It is the foundational unitary matrix for qubit manipulation. Every single-qubit manipulation that can be done can be done with the U3 gate, which can be expressed as the following unitary matrix:</p>
			<div><div><img alt="" src="img/Formula_06_106.jpg"/>
				</div>
			</div>
			<p>The three angles are as follows: </p>
			<ul>
				<li><img alt="" src="img/Formula_06_093.png"/>  = The polar angle between <img alt="" src="img/Formula_06_0221.png"/> and the state vector </li>
				<li><img alt="" src="img/Formula_06_109.png"/> = The longitudinal angle from the <em class="italic">x</em> axis (<img alt="" src="img/Formula_06_078.png"/>)</li>
				<li><img alt="" src="img/Formula_06_111.png"/> = The overall qubit phase angle (not visible on the Bloch sphere)</li>
			</ul>
			<p>The U2 and U1 gates are basically specializations of U3, just like the other quantum gates are specializations of the U gates in general. </p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor179"/>The U2 gate </h2>
			<p>With the U2 gate, you<a id="_idIndexMarker407"/> can manipulate two angles at the same time. The U2 gate is the same as the U3 gate with <img alt="" src="img/Formula_06_112.png"/>.</p>
			<p>The U2 gate can be expressed as the following unitary matrix:</p>
			<div><div><img alt="" src="img/Formula_06_113.jpg"/>
				</div>
			</div>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/>The U1 gate </h2>
			<p>With the U1 gate, you <a id="_idIndexMarker408"/>can rotate the phase of the qubit around the <em class="italic">z</em> axis. A special case of the U1 is the Rz gate, which has the same input. The U1 gate is the same as the U3 gate with <img alt="" src="img/Formula_06_114.png"/> and <img alt="" src="img/Formula_06_115.png"/>.</p>
			<p>The U1 gate can be expressed as the following unitary matrix:</p>
			<div><div><img alt="" src="img/Formula_06_116.jpg"/>
				</div>
			</div>
			<p>With these three gates, you can perform all possible single-qubit manipulations. They are not that user-friendly to read through and therefore Qiskit® includes translations of all relevant quantum gates for your programming ease. When you run your circuits, however, all the gates are translated into the collection of basis gates supported by the selected backend.</p>
			<p>The Pauli Id gate is a special gate that leaves the qubit in the same state as it was found. The gate can be expressed using the following matrix:</p>
			<p class="figure-caption"> <img alt="" src="img/Formula_06_117.png"/> = <img alt="" src="img/Formula_06_118.png"/>.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor181"/>Getting ready</h2>
			<p>The code for the sample program is available here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r2_u_animation.py</a>.</p>
			<p>In this recipe, we use the Pillow package to create, save, and merge images. For more information about Pillow, see <a href="https://pypi.org/project/Pillow/">https://pypi.org/project/Pillow/</a>.</p>
			<p class="callout-heading">Installing Pillow</p>
			<p class="callout">If you need to install Pillow in your environment, you can use the following commands:</p>
			<p class="callout"><code>(environment_name) … $  pip install --upgrade pip</code></p>
			<p class="callout"><code>(environment_name) … $  pip install --upgrade Pillow</code></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>How to do it...</h2>
			<p>In this recipe, we will visualize the rotations of the U gates on a Bloch sphere. As you already know, we can use the <code>plot_bloch_multivector()</code> and <code>plot_state_qsphere()</code> methods to visualize how our state vectors behave and what the possible outcomes are. These both provide static views of the qubit at one moment and of the U gates for a specific set of angles.</p>
			<p>In the sample program, you enter the angles input for your U gates, after which the program takes snapshots between 0 and the angle at a given resolution and produces an animated GIF that shows the movement of the qubit state vector on the Bloch sphere. </p>
			<p>Note that this<a id="_idIndexMarker409"/> animation<a id="_idIndexMarker410"/> doesn't<a id="_idIndexMarker411"/> really show you <a id="_idIndexMarker412"/>how a<a id="_idIndexMarker413"/> qubit <a id="_idIndexMarker414"/>vector<a id="_idIndexMarker415"/> moves when you <a id="_idIndexMarker416"/>apply the gate, but rather gives a view of how you can use the U gates to position your qubit state vector wherever you want:</p>
			<ol>
				<li value="1">Start by running the <code>ch6_r2_u_animation.py</code> script in your Python environment.</li>
				<li>At the prompts, enter the type of gate that you want to test, and then enter the required input angles for the gate. For the U3 gate, your input might look like this for <img alt="" src="img/Formula_06_119.png"/>:<pre>Animating the U gates
---------------------
Enter u3, u2, or u3:
u3
Enter <img alt="" src="img/Formula_06_120.png"/>:
1.57
Enter <img alt="" src="img/Formula_06_121.png"/>:
3.14
Enter <img alt="" src="img/Formula_06_122.png"/>:
0
Building animation...</pre><p>In the background, we are now calling the <code>create_images()</code> function, which <a id="_idIndexMarker417"/>takes <a id="_idIndexMarker418"/>the input<a id="_idIndexMarker419"/> you provided and then <a id="_idIndexMarker420"/>iteratively creates a set of circuits that<a id="_idIndexMarker421"/> iteratively<a id="_idIndexMarker422"/> apply the<a id="_idIndexMarker423"/> U gate you selected with the<a id="_idIndexMarker424"/> input angles divided into smaller angles as dictated by the <em class="italic">steps</em> parameter. Each circuit is then run through the statevector simulator in the <code>get_psi()</code> function that we created in the first recipe, <em class="italic">Visualizing the quantum gates</em>, and is finally saved as a Bloch sphere image and a Q-sphere image using <code>plot_bloch_multivector()</code> and <code>plot_state_qsphere()</code>. The images are continuously appended to two lists that will later be merged into an animation.</p><p>Here's how we build the function.</p><p>Start by setting the input parameters and all internal function variables:</p><pre>def create_images(gate,theta=0.0,phi=0.0,lam=0.0):
    steps=20.0
    theta_steps=theta/steps
    phi_steps=phi/steps
    lam_steps=lam/steps
    n, theta,phi,lam=0,0.0,0.0,0.0</pre><p>Then create the image and animation tools:</p><pre>    global q_images, b_images, q_filename, b_filename
    b_images=[]
    q_images=[]
    b_filename="animated_qubit"
    q_filename="animated_qsphere"</pre><p>Finally, run the image creation loop based on the input parameters:</p><pre>    while n &lt; steps+1:
        qc=QuantumCircuit(1)
        if gate=="u3":
            qc.u3(theta,phi,lam,0)
            title="U3: \u03B8 = "+str(round(theta,2))+"                \u03D5 = "+str(round(phi,2))+" \u03BB =                "+str(round(lam,2))
        elif gate=="u2":
            qc.u2(phi,lam,0)
            title="U2: \u03D5 = "+str(round(phi,2))+"                 \u03BB = "+str(round(lam,2))
        else:
            qc.h(0)
            qc.u1(phi,0)
            title="U1: \u03D5 = "+str(round(phi,2))
        # Get the statevector of the qubit 
        # Create Bloch sphere images
        plot_bloch_multivector(get_psi(qc),title).            savefig('images/bloch'+str(n)+'.png')
        imb = Image.open('images/bloch'+str(n)+'.png')
        b_images.append(imb)
        # Create Q-sphere images
        plot_state_qsphere(psi).savefig(
           'images/qsphere'+str(n)+'.png')
        imq = Image.open('images/qsphere'+str(n)+'.png')
        q_images.append(imq)
        # Rev our loop
        n+=1
        theta+=theta_steps
        phi+=phi_steps
        lam+=lam_steps</pre></li>
				<li>Create <a id="_idIndexMarker425"/>and<a id="_idIndexMarker426"/> save<a id="_idIndexMarker427"/> the<a id="_idIndexMarker428"/> animated <a id="_idIndexMarker429"/>GIFs.<p>The <a id="_idIndexMarker430"/>final<a id="_idIndexMarker431"/> step<a id="_idIndexMarker432"/> is to create the GIFs. Here we use the <code>save_gif(gate)</code> function to iterate through the image lists we created and let Pillow build the GIFs with our initial parameters. This is what we do:</p><pre>def save_gif(gate):
    duration=100
    b_images[0].save(gate+'_'+b_filename+'.gif',
               save_all=True,
               append_images=b_images[1:],
               duration=duration,
               loop=0)
    q_images[0].save(gate+'_'+q_filename+'.gif',
               save_all=True,
               append_images=q_images[1:],
               duration=duration,
               loop=0)
    print("Bloch sphere animation saved as: \n"+os.        getcwd()+"/"+gate+"_"+b_filename+".        gif"+"\nQsphere animation saved as: \n"+os.        getcwd()+"/"+gate+"_"+q_filename+".gif")</pre><p>The final Python output might look like this:</p><pre>Bloch sphere animation saved as: 
/&lt;path_to_your_directory&gt;/ch6/Recipes/u3_animated_qubit.gif
Qsphere animation saved as: 
/&lt;path_to_your_directory&gt;/ch6/Recipes/u3_animated_qsphere.gif</pre></li>
				<li>The <a id="_idIndexMarker433"/>final <a id="_idIndexMarker434"/>result <a id="_idIndexMarker435"/>will<a id="_idIndexMarker436"/> be<a id="_idIndexMarker437"/> two <a id="_idIndexMarker438"/>animated <a id="_idIndexMarker439"/>GIFs<a id="_idIndexMarker440"/> saved in the same directory as where you run your script. <p>You can now open the GIFs in an image viewer or web browser to take a look:</p><div><img alt="Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere&#13;&#10;" src="img/Figure_6.14_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption">  </p>
			<p class="figure-caption">Figure 6.14 – Still of animated GIFs of a Bloch sphere and a Q-sphere</p>
			<p>If you view the animated GIFs side by side and synchronized, the Q-sphere representation shows the relative probabilities and phase angle of the qubit as the U gate is applied to it. Play around with different angles and different loop parameters to see how you can make the animations work for you.</p>
			<p>If you set the angles in the range of 0 to <img alt="" src="img/Formula_06_123.png"/> and set your steps to a reasonably high number, you can create nice smooth looping effects. There is nothing stopping you from setting the angles really high though, which will result in fairly chaotic behavior in the animations. Have fun!</p>
			<p>When<a id="_idIndexMarker441"/> you<a id="_idIndexMarker442"/> test the <a id="_idIndexMarker443"/>U<a id="_idIndexMarker444"/> gates <a id="_idIndexMarker445"/>with <a id="_idIndexMarker446"/>the<a id="_idIndexMarker447"/> script, remember <a id="_idIndexMarker448"/>the following:</p>
			<ul>
				<li>U3 lets you point the qubit vector anywhere on the Bloch sphere using two angles, <img alt="" src="img/Formula_06_124.png"/> and <img alt="" src="img/Formula_06_125.png"/>. The third angle, <img alt="" src="img/Formula_06_111.png"/>, has no effect on the Bloch sphere representation. </li>
				<li>U2 is the same as U3 but with <img alt="" src="img/Formula_06_015.png"/> set to <img alt="" src="img/Formula_06_128.png"/> , which places the qubit vector on the equator. </li>
				<li>U1 is the same as U3 but with both <img alt="" src="img/Formula_06_124.png"/> and <img alt="" src="img/Formula_06_130.png"/> set to 0. A special case of U1 is Rz.</li>
			</ul>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>There's more...</h2>
			<p>Well, in this case, there's less not more. The sample script in this recipe will work in your local environment, but not very well in your IBM Quantum Experience® notebook environment as you do not have access to the underlying filesystem.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor184"/>Using gates on 2 qubits</h1>
			<p>Two-qubit <a id="_idIndexMarker449"/>gates <a id="_idIndexMarker450"/>such as controlled gates are slightly different from ordinary 1-qubit gates; they let you create interaction between your qubits. In general, this translates into using 1 qubit as the control qubit, and the other as the acted-on qubit. Mathematically, this is not super complex, but intuitively you might have to think once or twice about what is going on.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor185"/>Getting ready</h2>
			<p>The first 2-qubit gate that we'll touch on is the Controlled-NOT gate that we saw in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>. The CX gate is generally used to create entanglement between qubits if the control qubit is in a superposition.</p>
			<p>A CX gate where the controlling qubit is the second qubit and the controlled qubit the first can be expressed as the following matrix:</p>
			<div><div><img alt="" src="img/Formula_06_131.jpg"/>
				</div>
			</div>
			<p>This corresponds to the following circuit:</p>
			<div><div><img alt="Figure 6.15 – CX gate from q_1 to q_0&#13;&#10;" src="img/Figure_6.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – CX gate from q_1 to q_0</p>
			<p>The way you interpret this is to run the first or controlling qubit through an Id gate, leaving it untouched. The second, or controlled, qubit applies an X gate if the first qubit is 1.</p>
			<p>Here are two matrix calculations to demonstrate:</p>
			<div><div><img alt="" src="img/Formula_06_132.jpg"/>
				</div>
			</div>
			<p>Here, the first qubit is 1 and the second 0. The result is both qubits in 1:</p>
			<div><div><img alt="" src="img/Formula_06_133.jpg"/>
				</div>
			</div>
			<p>Here, both<a id="_idIndexMarker451"/> qubits are 1. The result is the first qubit is 1 and the <a id="_idIndexMarker452"/>second is 0.</p>
			<p>The CX gate is one of the basis gates of the IBM Quantum® backends. </p>
			<p class="callout-heading">Other CX matrices</p>
			<p class="callout">If the CX gate points the other way, with the first qubit as the controlling qubit, the matrix will look like this instead:</p>
			<p class="callout"><img alt="" src="img/Formula_06_134.png"/></p>
			<p class="callout">To convince yourself, do the calculation. For a quick refresher, see the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>.</p>
			<p>The sample script is available at: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r1_quantum_qate_ui.py</a>.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor186"/>How to do it...</h2>
			<p>Earlier, for the single-qubit gates, the Quantum Gate program set up a plain quantum circuit with one qubit initiated in the ground state <img alt="" src="img/Formula_06_0221.png"/>. When we start playing with multi-qubit gates, the program will initialize with both qubits in <img alt="" src="img/Formula_06_0221.png"/>. The gate selected is then run on the circuit, and results in the form of a qubit state vector and the gate unitary matrix are displayed.</p>
			<p>To explore the control gates, we run the Quantum Gate program that is described in the <em class="italic">Visualizing quantum gates</em> recipe:</p>
			<ol>
				<li value="1">Run the <code>ch6_r1_quantum_gate_ui.py</code> sample program.</li>
				<li>Select a<a id="_idIndexMarker453"/> start<a id="_idIndexMarker454"/> state for your controlling qubit.<p>The Cn gates use a single qubit as the controlling qubit and the other qubit as the controlled qubit. If the state of the controlling qubit is anything other than <img alt="" src="img/Formula_06_0221.png"/>, some action will be performed on the controlled qubit. </p><p>If you want to, then you can start by testing with <img alt="" src="img/Formula_06_0221.png"/>—just to verify that no action is performed and that the 2-qubit state doesn't change. Then test with start state <img alt="" src="img/Formula_06_139.png"/> to create a Bell state, as we did in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>. After you are done with this, play around with <img alt="" src="img/Formula_06_140.png"/>, Random or Define to explore other control states.</p></li>
				<li>When prompted, enter <code>cx</code>, <code>cy</code>, <code>cz</code>, or <code>ch</code> to select the gate to test. For example, a CX gate with the controlling qubit state <img alt="" src="img/Formula_06_078.png"/> will generate the following output:<div><img alt="Figure 6.16 – CX gate with the start state |+&gt;&#13;&#10;" src="img/Figure_6.16_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 6.16 – CX gate with the start state |+&gt;</p>
			<p>Here, notice that <a id="_idIndexMarker455"/>the Bloch sphere representation makes no sense after <a id="_idIndexMarker456"/>the CX gate has been applied. The qubits are now entangled, and we can get no further individual information from them. In this case, we display the Q-sphere interpretation for clarification, where the initial Q-sphere indicates equal probabilities of getting states <img alt="" src="img/Formula_06_142.png"/> and <img alt="" src="img/Formula_06_143.png"/>, and after the X gate, equal probabilities of getting <img alt="" src="img/Formula_06_144.png"/>, as expected for a Bell state.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor187"/>How it works...</h2>
			<p>The CX gate is just one of many possible two-qubit control gates. Among the others built into Qiskit® are the CY and CZ gates:</p>
			<div><div><img alt="" src="img/Formula_06_145.jpg"/>
				</div>
			</div>
			<div><div><img alt="" src="img/Formula_06_146.jpg"/>
				</div>
			</div>
			<p>Or why not a controlled Hadamard gate?</p>
			<div><div><img alt="" src="img/Formula_06_147.jpg"/>
				</div>
			</div>
			<p>Another handy <a id="_idIndexMarker457"/>2-qubit gate is the SWAP gate that swaps the value of the<a id="_idIndexMarker458"/> first and second qubit. In this case, there is no entanglement and the individual qubits remain individuals: </p>
			<div><div><img alt="" src="img/Formula_06_148.jpg"/>
				</div>
			</div>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor188"/>There's more...</h2>
			<p>The two-qubit gates can<a id="_idIndexMarker459"/> also be written as a combination of basis gates. For example, this is how you can code the CY gate:</p>
			<pre>qc.u1(-1.507,0)
qc.cx(1,0)
qc.u1(1.507,0)</pre>
			<p>For more information, and to test-transpile the other Cn gates, see the <em class="italic">What your quantum circuit really looks like</em> recipe. </p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor189"/>See also</h2>
			<p><em class="italic">Quantum Computation and Quantum Information</em>, 10th Anniversary Edition, Michael A. Nielsen &amp; Isaac L. Chuang, <em class="italic">Chapter 4.3 Controlled operations</em>.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor190"/>Using gates on more than 2 qubits</h1>
			<p>In addition to the <a id="_idIndexMarker460"/>single-qubit and two-qubit gates, Qiskit® also <a id="_idIndexMarker461"/>supports 3- and more qubit gates. We will use one of them, the Toffoli gate when we build the 3-qubit Grover search algorithm circuit in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>. We are including the Fredkin gate for completeness and will not be using it in any other examples; feel free to try it out.</p>
			<p>The multi-qubit gates in this recipe use 2, more, and 1 controlling qubit respectively:</p>
			<ul>
				<li><strong class="bold">Toffoli</strong>: Controlled-controlled<a id="_idIndexMarker462"/> NOT (<strong class="bold">CCX</strong>), which takes 2 qubits as input and flips the third if both controlling qubits are set.</li>
				<li><strong class="bold">MCX</strong>: Multi-controlled <a id="_idIndexMarker463"/>NOT takes a number of qubits (controlling) as input and flips the controlled qubit if all are set.<p>There is (in principle) no limit to the number of controlling qubits that you can use with your gates. In the 4- and more qubit Grover search algorithm circuit in <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a><em class="italic">, Grover's Search Algorithm</em>, we build a 4-qubit <strong class="bold">CCCX</strong> <strong class="bold">controlled-controlled-controlled</strong> gate by using the <strong class="bold">MCX</strong> gate. </p></li>
				<li><strong class="bold">Fredkin</strong>: Controlled<a id="_idIndexMarker464"/> SWAP, (<strong class="bold">CSWAP</strong>), which takes a single qubit as input and swaps the other two if the controlling qubit is set.</li>
			</ul>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor191"/>How to do it...</h2>
			<p>In your quantum programs, use the following sample code to implement these 3-qubit gates.</p>
			<h3>Toffoli</h3>
			<p>The Toffoli or <strong class="bold">CCX</strong> gate is<a id="_idIndexMarker465"/> represented by the following unitary matrix with the second and third qubits controlling the first qubit:</p>
			<div><div><img alt="" src="img/Formula_06_149.jpg"/>
				</div>
			</div>
			<p>The following code implements the CCX gate:</p>
			<pre>from qiskit import QuantumCircuit
qc=QuantumCircuit(3)
qc.ccx(2,1,0)
print(qc)</pre>
			<p>And the circuit looks like this:</p>
			<p class="figure-caption"> </p>
			<div><div><img alt="Figure 6.17 – The Toffoli gate&#13;&#10;" src="img/Figure_6.17_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – The Toffoli gate</p>
			<p class="callout-heading">Other CCX matrixes</p>
			<p class="callout">Just like for the CX gate, the matrix will look different depending on which qubits you should use to control. For example, here is the matrix for a CCX gate where the first and second qubits control the third:</p>
			<p class="callout"><img alt="" src="img/Formula_06_150.png"/></p>
			<p class="callout">To convince yourself, do the calculation. </p>
			<h3>MCX</h3>
			<p>The MCX gate is used to <a id="_idIndexMarker466"/>build general controlled-NOT gates with more than one controlling gate. The Toffoli (CCX) gate is a special example where this is an already coded gate. For controlled-NOT gates with more than 2 controlling qubits, you can use the MCX gate.</p>
			<p>The following code implements the MCX gate as a CCCX gate with second, third, and fourth qubits controlling the first qubit:</p>
			<pre>from qiskit import QuantumCircuit
qc=QuantumCircuit(4)
qc.mcx([1,2,3],0)
print(qc)</pre>
			<p>And the circuit looks like this:</p>
			<div><div><img alt="Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)" src="img/Figure_6.18_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – The MCX gate for 3 controlling qubits (CCCX)</p>
			<h3>Fredkin</h3>
			<p>The Fredkin <a id="_idIndexMarker467"/>or <strong class="bold">CSWAP</strong> gate is represented by the following unitary matrix with the controlling third qubit swapping the first and second qubits:</p>
			<div><div><img alt="" src="img/Formula_06_151.jpg"/>
				</div>
			</div>
			<p>The following code implements the CSWAP gate:</p>
			<pre>from qiskit import QuantumCircuit
qc=QuantumCircuit(3)
qc.cswap(2,1,0)
print(qc)</pre>
			<p>And the circuit looks like this:</p>
			<div><div><img alt="Figure 6.19 – The Fredkin gate&#13;&#10;" src="img/Figure_6.19_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – The Fredkin gate</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor192"/>There's more...</h2>
			<p>Just like the other gates that we have looked at in this chapter, the Toffoli and Fredkin gates are included with the basic set of Qiskit® gates. However, they are not basis gates, which means that they need to be rewritten using a set of basis gates, such as <strong class="bold">u1</strong>, <strong class="bold">u2</strong>, <strong class="bold">u3</strong>, <strong class="bold">id</strong>, and <strong class="bold">cx</strong>. This is called <strong class="bold">transpiling</strong> and is what we will be doing in the next recipe, <em class="italic">What your quantum circuit really looks like</em>. But we're jumping ahead just a little here and displaying the complexity of constructing these alluringly simple gates. Do try them out in the next recipe.</p>
			<h3>Toffoli constructed from basis gates</h3>
			<p>The Toffoli <a id="_idIndexMarker468"/>gate can be entered as a single gate<a id="_idIndexMarker469"/> in Qiskit®, which leads you to believe that the execution of the gate will correspond to <em class="italic">a single time step</em> just like the other gates: </p>
			<div><div><img alt="Figure 6.20 – A single Toffoli gate built from 10+ basis gates&#13;&#10;" src="img/Figure_6.20_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – A single Toffoli gate built from 10+ basis gates</p>
			<p>When we unravel the CCX like this, we see that the truth is slightly worse than just one time step; the<a id="_idIndexMarker470"/> single gate is translated into a circuit<a id="_idIndexMarker471"/> depth of 11.</p>
			<h3>Fredkin constructed from basis gates</h3>
			<p>Much like the <a id="_idIndexMarker472"/>Toffoli gate, Fredkin might be<a id="_idIndexMarker473"/> transpiled into a large number of basis gates when executed on a hardware backend: </p>
			<div><div><img alt="Figure 6.21 – A single Fredkin gate built from 20+ basis gates&#13;&#10;" src="img/Figure_6.21_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – A single Fredkin gate built from 20+ basis gates</p>
			<p>For a single <a id="_idIndexMarker474"/>Fredkin gate, the circuit depth goes <a id="_idIndexMarker475"/>from 1 to 22. Not everything is easy to do on a quantum computer.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor193"/>What your quantum circuit really looks like</h1>
			<p>In <a href="B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a>, <em class="italic">IBM Quantum Experience® – Quantum Drag and Drop</em>, and <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®</em>, we touched on the concept of <code>u1</code>, <code>u2</code>, <code>u3</code>, <code>id</code>, and <code>cx</code>. We discussed these gates in the previous recipes of this chapter and even listed how the other gates can be written as implementations or combinations of these. </p>
			<p>In this recipe, we will take a look at some other aspects of the transpiling of circuits, such as the following:</p>
			<ul>
				<li>Simple transpiling of common gates to basis gates</li>
				<li>Transpiling for a simulator</li>
				<li>Transpiling your circuit if it doesn't match the physical layout of the backend<p class="callout-heading">One-qubit backend basis gates</p><p class="callout">Most IBM Quantum® backends have the following basis gates: <code>u1</code>, <code>u2</code>, <code>u3</code>, <code>id</code>, and <code>cx</code>. One-qubit backends such as <code>ibmq_armonk</code> have no use for multi-qubit gates such as CX, which is not included. If you set your backend to <code>ibmq_armonk</code> and run the following command, you will get the corresponding output:<code>&gt;&gt;&gt; backend.configuration().basis_gates Out: ['id', 'u1', 'u2', 'u3']</code>.</p></li>
			</ul>
			<p>When we execute a quantum program on an IBM quantum computer, our code is first transpiled down to the core basis gates (<code>u1</code>, <code>u2</code>, <code>u3</code>, <code>id</code>, and <code>cx</code>) that we can execute directly on the hardware. </p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor194"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter06/ch6_r3_transpiler.py</a>.</p>
			<p>This is how we build our Python sample:</p>
			<ol>
				<li value="1">First, we import the needed classes and methods, including <code>transpile</code>:<pre>from qiskit import QuantumCircuit, IBMQ
from qiskit.compiler import transpile
from qiskit.providers.ibmq import least_busy</pre><p>We also load our account, if needed, and set up a backend with <code>5</code> qubits:</p><pre>if not IBMQ.active_account():
    IBMQ.load_account()
provider = IBMQ.get_provider()
backend = least_busy(provider.backends(n_qubits=5,    operational=True, simulator=False)) </pre></li>
				<li>Let's take a look<a id="_idIndexMarker478"/> at the basis gates and coupling map for the selected backend. The coupling map specifies the possible qubit connections for two-qubit circuits:<pre>print("Basis gates for:", backend)
print(backend.configuration().basis_gates)
print("Coupling map for:", backend)
print(backend.configuration().coupling_map)</pre><p>The preceding code should result in an output similar to the following:</p><div><img alt="Figure 6.22 – Basis gates and CX coupling map for a backend&#13;&#10;" src="img/Figure_6.22_B14436.jpg"/></div><p class="figure-caption">Figure 6.22 – Basis gates and CX coupling map for a backend</p><p>For a single qubit gates transpiling, the coupling map is not important. This changes when we write quantum programs that use two-qubit gates.</p></li>
				<li>We then set up the <code>build_circuit()</code> function to create a basic circuit, and selectively add<a id="_idIndexMarker479"/> gates to it depending on what circuit we want to explore:<pre>def build_circuit(choice):
    # Create the circuit 
    qc = QuantumCircuit(5,5)
    
    if choice=="1":
        # Simple X
        qc.x(0)
    elif choice=="2":
        # H + Barrier
        #'''
        qc.x(0)
        qc.barrier(0)
        qc.h(0)
    elif choice=="3":
        # Controlled Y (CY)
        qc.cy(0,1)
    elif choice=="4":    
        # Non-conforming CX
        qc.cx(0,4)
    else:
        # Multi qubit circuit
        qc.h(0)
        qc.h(3)
        qc.cx(0,4)
        qc.cswap(3,1,2)
    # Show measurement targets
    #qc.barrier([0,1,2,3,4])
    #qc.measure([0,1,2,3,4],[0,1,2,3,4])
    return(qc)</pre></li>
				<li>Finally, we <a id="_idIndexMarker480"/>set up the <code>main()</code> function to run the circuit.<p>The main function prompts for a circuit to test, calls the <code>build_circuit()</code> function, transpiles the returned circuit using the <code>transpile()</code> class, and then displays the results:</p><pre>def main(): 
    choice="1"
    while choice !="0": 
        choice=input("Pick a circuit: 1. Simple, 
            2. H + Barrier, 3. Controlled-Y, 
            4. Non-conforming CX, 5. Multi\n")
        qc=build_circuit(choice) 
        trans_qc = transpile(qc, backend)
        print("Circuit:")
        display(qc.draw())
        print("Transpiled circuit:")
        display(trans_qc.draw())
        print("Circuit depth:")
        print("---------------")
        print("Circuit:", qc.depth())
        print("Transpiled circuit:", trans_qc.depth())
        print("\nCircuit size:")
        print("---------------")
        print("Circuit:", qc.size())
        print("Transpiled circuit:", trans_qc.size())
if __name__ == '__main__':
    main()</pre></li>
			</ol>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor195"/>How to do it…</h2>
			<p>Let's build and <a id="_idIndexMarker481"/>transpile a simple X circuit:</p>
			<ol>
				<li value="1">In your Python environment, run <code>ch6_r3_transpiler.py</code>.</li>
				<li>When prompted, enter <code>1</code> to pick the <code>Simple</code> <code>X</code> circuit:<div><img alt="Figure 6.23 – First, select the Simple X circuit&#13;&#10;" src="img/Figure_6.23_B14436.jpg"/></div><p class="figure-caption">Figure 6.23 – First, select the Simple X circuit</p></li>
				<li>The code should <a id="_idIndexMarker482"/>result in an output similar to this:<div><img alt="Figure 6.24 – The output of the simple, single X gate circuit" src="img/Figure_6.24_B14436.jpg"/></div><p class="figure-caption">Figure 6.24 – The output of the simple, single X gate circuit</p><p>The resulting circuit looks pretty similar. The only real change is that the X gate is now a U3 gate, one of the basis gates. </p></li>
				<li>We can get a numerical result as well, by pulling out the circuit depths and sizes for the circuit and the transpiled circuit.<p>This code should result in the following circuit depths and sizes:</p></li>
			</ol>
			<div><div><img alt="Figure 6.25 – Circuit depth and size" src="img/Figure_6.25_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – Circuit depth and size</p>
			<p>Here, depth means the number of end-to-end steps that the quantum computer has to execute. Each step might include one or more gates, depending on the layout of the circuit. The size is just the total number of gates that are executed.</p>
			<p>For this very simple circuit<a id="_idIndexMarker483"/> transpiling, there isn't much of a change. The U3 gate performs the required rotation around the <em class="italic">x</em> axis, and the circuit depth and size are the same. Technically, you could use the U3 gate instead of the X gate in your code, but it would be much less transparent.</p>
			<p class="callout-heading">Transpiling for a simulator?</p>
			<p class="callout">So, what happens if you try transpiling your circuits for a simulator backend? As it turns out, the simulator includes many more basis gates than the hardware backends, so the transpiling will be different. To test this, simply uncomment the following line in the script to set the backend to a simulator and run the program again:</p>
			<p class="callout"><code>backend = provider.get_backend('ibmq_qasm_simulator')</code></p>
			<p class="callout">The <code>ibmq_qasm_simulator</code> supports the following basis gates:</p>
			<p class="callout"><code>['u1', 'u2', 'u3', 'cx', 'cz', 'id', 'x', 'y', 'z', 'h', 's', 'sdg', 't', 'tdg', 'ccx', 'swap', 'unitary', 'initialize', 'kraus']</code></p>
			<p class="callout">That said, you can provide additional parameters when running the transpiler, such as <code>basis_gates</code> and <code>coupling_map</code> to define the basis gates that you want to use and specify how the qubits are connected for use when transpiling for multi-qubit gates. We will not go into any details about that in this chapter, but take a look at the Qiskit® help for more info:</p>
			<p class="callout"><code>&gt;&gt;&gt; from qiskit.compiler import transpile</code></p>
			<p class="callout"><code>&gt;&gt;&gt; help(transpile)</code></p>
			<p>Now take a<a id="_idIndexMarker484"/> look at the <em class="italic">There's more</em> section for a short showcase of how things can get much more complicated, quickly.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor196"/>There's more...</h2>
			<p>This quick recipe gave a quick taste of what the transpiler does for a very simple quantum program, and illustrated how the transpiler translates your generic circuits into circuits that can be directly executed on the quantum chip.</p>
			<p>The following quick examples illustrate the complexities that might befall the poor transpiler if you ask it to build circuits that do not at all match the physical layout of the backend. You can test these circuits in the sample code to see if you get similar results.</p>
			<p>Test the following inputs when running the sample code:</p>
			<h3>Adding H and H + Barrier – Multiple gates and the barrier circuit element</h3>
			<p>The transpiling of<a id="_idIndexMarker485"/> one gate doesn't leave the transpiler with a lot to do, but <a id="_idIndexMarker486"/>as soon as you add more gates, things quickly get more complex. Remember that quantum gates generically are rotations around the three axes <em class="italic">x</em>, <em class="italic">y</em>, and <em class="italic">z</em>. If two gates are added in a row, the transpiler seeks to simplify the circuit (and thus make it shorter; less deep) by combining multiple gates into single basis gate.</p>
			<p>In the sample code, we extended the quantum circuit by adding a Hadamard gate after the X gate:</p>
			<pre># Add H
qc.x(0)
qc.h(0)</pre>
			<p>When you run the circuit now, you should see something like this:</p>
			<p class="figure-caption">  </p>
			<div><div><img alt="Figure 6.26 – Simplified transpiled circuit&#13;&#10;" src="img/Figure_6.26_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26 – Simplified transpiled circuit</p>
			<p>As you can see, the<a id="_idIndexMarker487"/> transpiler combined the two gates into one, simplifying<a id="_idIndexMarker488"/> and shortening the circuit by looking ahead at what the gate combination would result in, and coding that as a U gate. However, it is not always that you want this simplification. For example, as we saw in the <em class="italic">A quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, two identical quantum gates in a row might effectively cancel each other out. In some instances, a quantum circuit will end up being constructed out of repeating gates, and if those repeating gates are removed, the circuit will not work as expected. </p>
			<p>The solution is the <code>barrier()</code> circuit component, which stops the transpiler from simplifying by <a id="_idIndexMarker489"/>combining gates. By using the <em class="italic">H + Barrier</em> option, we add a <a id="_idIndexMarker490"/>barrier between the X and H gates like this:</p>
			<pre># H + Barrier
qc.x(0)
qc.barrier(0)
qc.h(0)</pre>
			<p>When you use the <em class="italic">H + Barrier</em> option, you should see something similar to this:</p>
			<p class="figure-caption">  </p>
			<div><div><img alt="Figure 6.27 – Transpiler does not transpile past the barriers&#13;&#10;" src="img/Figure_6.27_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27 – Transpiler does not transpile past the barriers</p>
			<p>The gates are<a id="_idIndexMarker491"/> now transpiled one by one, and the circuit depth is<a id="_idIndexMarker492"/> retained. So, no problem there, right? Well, these were pretty simple gates. What happens when we complicate our circuit a bit? Take a look at the next section.</p>
			<h3>Controlled Y </h3>
			<p>The <strong class="bold">controlled X gate</strong> (<strong class="bold">CX</strong>) is a basis gate <a id="_idIndexMarker493"/>for the IBM Quantum® backends, but the <strong class="bold">controlled Y</strong> (<strong class="bold">CY</strong>) is not. To <a id="_idIndexMarker494"/>create a CY gate that can run on the backend, the transpiler adds some additional basis gates.</p>
			<p>By using the <em class="italic">Controlled-Y</em> option, we add a <code>cy()</code> gate like this:</p>
			<pre># Controlled Y (CY)
qc.cy(0,1)</pre>
			<p>To create a CY gate <a id="_idIndexMarker495"/>that can run on the backend, the transpiler adds some additional basis gates:</p>
			<div><div><img alt="Figure 6.28 – Transpiling a CY gate&#13;&#10;" src="img/Figure_6.28_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28 – Transpiling a CY gate</p>
			<p>Here we have the transpiler do a quick trick, adding Z rotations before and after the X in the CX gate. If the control qubit is 0, we will just get a rotation back and forth around the <em class="italic">z</em> axis. If the control qubit is 1, we get a negative quarter rotation around Z, a half-turn rotation around X, and then a quarter rotation back around Z, effectively landing us where we would have been with a half-turn Y rotation. Granted, a Y rotation would have been easily done with <code>Y(qubit)</code> <code>=</code> <code>U3(</code><img alt="" src="img/Formula_06_154.png"/><code>,</code> <img alt="" src="img/Formula_06_154.png"/><code>,</code> <img alt="" src="img/Formula_06_154.png"/><code>,</code> <code>qubit)</code>, but as the control functionality of the CX cannot be attached to the Y gate, we have to do this rework instead.</p>
			<p>Let's look at some other examples. These will illustrate how the transpiler works to convert your seemingly<a id="_idIndexMarker496"/> simple quantum circuits to circuits made out of basis gates that can be run on the actual IBM Quantum® hardware.</p>
			<h3>Non-conforming CX</h3>
			<p>In this example, we <a id="_idIndexMarker497"/>set up a CX gate between two qubits that are not physically connected. As you have seen, CX is a base gate, so this should not require any transpiling, right? Well, in this case, we force the transpiler to attempt to build your circuit across two qubits that are not directly connected. In this case, the transpiler must map your CX gate across several intermediate qubits, which will add complexity to your circuit. In our sample code, we build this circuit:</p>
			<pre># Non-conforming CX
qc.cx(0,4)</pre>
			<p>Running the sample code with the non-conforming CX input should result in something similar to the following:</p>
			<div><div><img alt="Figure 6.29 – Transpiling a CX gate across non-connected qubits&#13;&#10;" src="img/Figure_6.29_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29 – Transpiling a CX gate across non-connected qubits</p>
			<p>Notice how this<a id="_idIndexMarker498"/> simple, one-CX circuit all of a sudden ballooned to a circuit with seven CX gates. This is not the most efficient coding example. The reason for this is clear if you look at the coupling map for the quantum computer that we are transpiling for, IBM Quantum® Ourense. Qubit 4 cannot directly communicate with qubit 0, but has to go through 3 and 1 first:</p>
			<p class="figure-caption"> </p>
			<div><div><img alt="Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends&#13;&#10;" src="img/Figure_6.30_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.30 – The physical layout of one of the IBM Quantum® 5-qubit backends</p>
			<p>For simple circuits, there is no big difference between the original and transpiled circuits; try having the CX gate go from qubit 0 to qubit 1 and see what you get. But for more elaborate ones, the circuits quickly diverge.</p>
			<p>But hang on! </p>
			<p>For those <a id="_idIndexMarker499"/>nitpickers of you that, like me, have looked over the circuit and walked through what happens if qubit 0 is set to 1 to trigger the CX, you will have noticed that the result of the original circuit ought to be <code>barrier</code> and <code>measure</code> lines in the code and run it again:</p>
			<pre># Show measurement targets
qc.barrier([0,1,2,3,4])
qc.measure([0,1,2,3,4],[0,1,2,3,4])</pre>
			<p>This ought to result in the following output:</p>
			<div><div><img alt="Figure 6.31 – The transpiler also moves the measurement instructions around&#13;&#10;" src="img/Figure_6.31_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.31 – The transpiler also moves the measurement instructions around</p>
			<p>As you can see from the <a id="_idIndexMarker500"/>new mapping, qubits 1 and 3 are now measured to classical bits 0 and 4, just as we expected. The final measurement output will be correct.</p>
			<h3>Multi-gate – Combined Bell and CSWAP circuit</h3>
			<p>This last <a id="_idIndexMarker501"/>example illustrates the complexity that <a id="_idIndexMarker502"/>occurs when you try to achieve something reasonably simple but run out of pathways to achieve it. We are creating a Bell state over qubits 0 and 4 and adding a controlled-SWAP gate from qubit 3 to qubits 1 and 2 to have those qubits just swap values:</p>
			<pre># Multi qubit circuit
qc.h(0)
qc.h(3)
qc.cx(0,4)
qc.cswap(3,1,2)</pre>
			<p>The multi-gate <a id="_idIndexMarker503"/>input should give the following<a id="_idIndexMarker504"/> result:</p>
			<div><div><img alt="Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit&#13;&#10;" src="img/Figure_6.32_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32 – A complex transpiling of a reasonably simple Bell + CSWAP circuit</p>
			<p>Well, trying this relatively simple circuit quickly took a turn for the worse. It ballooned from a depth of 2 to 32. The circuit size also went up from the original 4 gates to an astounding 43. Look at all those CX gates!</p>
			<div><div><img alt="Figure 6.33 – Depth and size of the multi-gate circuit&#13;&#10;" src="img/Figure_6.33_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33 – Depth and size of the multi-gate circuit</p>
			<p>Again, if you take a look at <em class="italic">Figure 6.33</em>, you can see why this happens. The simple act on our part of <a id="_idIndexMarker505"/>connecting qubit 0 and 4 is physically<a id="_idIndexMarker506"/> impossible as the quantum chip is laid out. Instead, this connection requires a chain of intermediate qubit connections across qubits 1, 2, and 3. These additional connections caused the number of individual gates to explode. </p>
			<p>Now try the following circuit instead and see how that changes the counts. You should expect both depth and size to shrink significantly as you are now coding for qubits that can directly communicate with each other. Apparently, coding for the backend that you want to run your program on is still important in this <strong class="bold">Noisy Intermediate-Scale Quantum  (NISQ)</strong> era:</p>
			<div><div><img alt="Figure 6.34 – A better conforming Bell + CSWAP circuit&#13;&#10;" src="img/Figure_6.34_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.34 – A better conforming Bell + CSWAP circuit</p>
			<p>As we have seen in this chapter, good quality programming is as important in quantum computing as it is in classical computing, if not more. The transpiler, left to its own devices, will do<a id="_idIndexMarker507"/> its best to translate your circuits to the <a id="_idIndexMarker508"/>backend where you plan to run them.</p>
			<p>If it gets crowded, and you utilize all the qubits extensively, the rewriting of your circuit might extend the execution time beyond the T1 and T2 times, making your circuit produce junk results on today's <strong class="bold">NISQ computer</strong> even<a id="_idIndexMarker509"/> though it otherwise is very nicely constructed. </p>
			<p>Quantum programming is definitely an art!</p>
		</div>
	</body></html>