- en: '*Chapter 4*: Starting at the Ground Level with Terra'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After our brief exploration of the IBM Quantum Experience® composer, and installation
    of IBM's Qiskit®, we are now ready to start writing quantum programs with Qiskit®.
    We will let go of the user interface, expanding our quantum computing journey
    into Python – one of the world's most popular and widespread scientific programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers the basic requirements for building a quantum circuit with
    Qiskit®. We will walk through the making of a few minimalistic quantum programs
    that run on a local Qiskit Aer simulator and that display the results of the program
    in numeric as well as diagrammatic form. We will then take the leap and run the
    programs on actual IBM Quantum® hardware.
  prefs: []
  type: TYPE_NORMAL
- en: The theme of this chapter is *quantum coin tossing*, based on the rudimentary
    quantum program that we built in IBM Quantum Experience®. These are arguably the
    simplest meaningful quantum programs that you can write, as they start you off
    with a few basic foundational quantum gates, but also demonstrate the difference
    between probabilistic quantum computing and deterministic classical computing.
  prefs: []
  type: TYPE_NORMAL
- en: We will also expand on the minimal program by adding more gates, run the program
    many times to gather statistics about the outcomes, and more. The topics that
    we will be learning about in this chapter will be applied from the next chapter
    onwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Qiskit® quantum program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum coin toss revisited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting some statistics – tossing many coins in a row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an upside-down coin toss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tossing two coins simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum-cheating in a coin toss? – Introducing the Bell state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More ways to quantum-cheat – tweaking the odds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding more coins – straight and cheating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tossing some real coins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: You can run the recipes in this chapter in your local Qiskit® environment that
    you set up as part of [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*, or you can run them in the notebook environment
    of the IBM Quantum Experience®.
  prefs: []
  type: TYPE_NORMAL
- en: If you run them in your local environment, I'd recommend using the built-in
    Spyder iPython editor from your Anaconda installation. That is the editor used
    to build and run the samples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code examples in this book, you will sometimes see the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your environment, iPython might not display graphical output directly
    in the output. If this is the case, you can use the `display()` method to force
    the output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example prints the quantum circuit `qc` to the iPython console.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Qiskit® quantum program
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, there are just a few required building blocks to create
    a quantum program using Qiskit®. First, you have to set up the required infrastructure
    and create the quantum circuit (what we call the **quantum score** in IBM Quantum
    Experience®). Then, you have to configure a backend to run your quantum program
    on, and finally execute and retrieve the results of your calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The following section is a summary of the Python building blocks that are required
    to make up a quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the required classes, modules, and functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qiskit® includes a large number of Python classes, but for our initial foray,
    we just need the basic ones. These are used to configure each of the components
    that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QuantumCircuit`: This is used to create the circuit—the program—that you will
    execute. You will add gates and other components to the circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QuantumRegister`: This represents the qubits that you can use to build your
    quantum program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassicalRegister`: This represents the classical bits that are used to store
    the output of your quantum program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Aer`: This is the Qiskit® simulation layer, which we will discuss in greater
    detail in [*Chapter 7*](B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197), *Simulating
    Quantum Computers with Aer*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IBMQ`: This module is required to execute your quantum programs on actual
    IBMQ hardware. It includes the tools you need to interact with IBMQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute`: This component lets you run your program by providing the circuit,
    a backend, and a number of shots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with quantum registers and classical registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to build your quantum program, you first need to decide how many
    qubits you want to work with, and how many classical bits you want to include
    to store your output. You can either set these up explicitly or use the `QuantumCircuit`
    class to automatically create the registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The registers make up two sets of information-carrying bits of your quantum
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: One set of quantum registers to hold your qubits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One set of classical registers to hold your regular bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will use measurement gates to read your qubits and then write the resulting
    classical bit to the classical registers.
  prefs: []
  type: TYPE_NORMAL
- en: For most of the recipes in this book, the number of quantum and classical registers
    will be the same, but this is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding your quantum circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The quantum circuit instance that you create will hold the qubits and classical
    bits. You will manipulate each instance by adding gates.
  prefs: []
  type: TYPE_NORMAL
- en: A quantum program can be assembled by combining more than one quantum circuit.
    You can, for example, create a circuit that holds the quantum gates and one circuit
    that holds the measurement gates. You can then add these circuits together to
    create a main quantum circuit that makes up your quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a backend to run on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to execute your quantum program, you must define a backend. A backend
    can be a local simulator, an IBM Quantum® simulator in the cloud, or actual IBM
    Quantum® hardware accessed through the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we will use the `qasm_simulator` backend that is included with Qiskit
    Aer, but we will also run our quantum programs on some of the freely available
    IBM Quantum® backends.
  prefs: []
  type: TYPE_NORMAL
- en: Running your circuit as a job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You run the quantum program as a job by providing the circuit, a backend, and
    a number of shots. If you run your quantum programs on IBM Quantum® hardware,
    you can also include a job monitor to keep track of your place in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving the results of your job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your job has run, the results are returned. In these initial recipes, where
    we use the `qasm_simulator` backend or the IBM Quantum® hardware, the returned
    results will be Python dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a 1-qubit circuit, the result might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the returned result of one shot was a qubit in the state ![](img/Formula_04_001.png)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The results could also look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the returned result was 1,000 shots, where 495 shots resulted in the qubit
    being ![](img/Formula_04_002.png) , and 505 shots that resulted in ![](img/Formula_04_001.png)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned results can be more complex. The following example is a possible
    result of a 3-qubit quantum program that was run 1,000 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the result ![](img/Formula_04_004.png) came up 113 times, ![](img/Formula_04_005.png)
    came up 139 times, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But, enough talk, let's write some quantum programs.
  prefs: []
  type: TYPE_NORMAL
- en: Quantum coin toss revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a closer look at the very first quantum program
    we created in IBM Quantum Experience® – the **quantum coin toss**. Again, this
    is arguably the simplest quantum program that still provides real quantum computing
    value. It demonstrates the probabilistic nature of quantum computing. For a refresher,
    see [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)*, IBM Quantum
    Experience® – Quantum Drag and Drop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In IBM Quantum Experience®, the coin toss program looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Simple coin toss circuit in the IBM Quantum Experience® composer
  prefs: []
  type: TYPE_NORMAL
- en: With the quantum coin toss, we will again use the *Hadamard gate* to create
    a quantum superposition, and a measurement gate to force the superposition to
    collapse into one of the two qubit states ![](img/Formula_04_002.png) or ![](img/Formula_04_001.png),
    representing *heads* or *tails*. This time, however, we will create the circuit
    in Python with Qiskit®, which means that we need to also create the framework
    for the gates and measurement by defining and creating quantum circuits and classical
    circuits using Python commands.
  prefs: []
  type: TYPE_NORMAL
- en: This is a quantum circuit that simulates the probabilistic nature of a single
    qubit in superposition. The 1-qubit circuit initializes the qubit in the ground
    state – ![](img/Formula_04_002.png) – and then uses a Hadamard gate to put the
    qubit in superposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'During our calculations, the statevector of the qubit looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Formula for the statevector of the qubit](img/Figure_4.2_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Formula for the statevector of the qubit
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write it in the vector form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Statevector of the qubit in the vector form](img/Figure_4.3_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Statevector of the qubit in the vector form
  prefs: []
  type: TYPE_NORMAL
- en: 'Another vector form is the Qiskit® statevector form that you will see in these
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Measuring the qubit causes it to collapse into one of the states ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png) with a ~50% probability, that is, a coin toss.
    The result is displayed as a numeric readout, as a bar diagram, and as a Bloch
    sphere.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r1_coin_toss.py).'
  prefs: []
  type: TYPE_NORMAL
- en: For a quick reminder of how to run the sample programs, see the *Downloading
    the code samples* recipe of [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: You are ready to write your first quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps will—to a large extent—be repeated throughout the book,
    based on the basic required classes and steps for basic Qiskit® management. So,
    expect the *How to do it…* section's bullets to be somewhat briefer going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will, however, be differences depending on what program you are planning
    to run, and what Qiskit® components you will be using. Let''s start the program
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the required Qiskit® classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we import the Python classes that are required to create registers and
    circuits, set a backend, and so on. Please refer to the *Listing the required
    Qiskit® classes, modules, and functions* section of the *Building a Qiskit® quantum
    program* recipe:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition, we also import the `display` method from `IPython.core.display`.
    This is used to correctly display the graphics output in our Anaconda Spyder IPython
    environment, and might not be required in your environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the required registers and the quantum circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create two registers, one for the quantum bit and one for the classic bit.
    We also create a quantum circuit that is made up of the quantum register and the
    classic register. The quantum register is initialized in the ground state, ![](img/Formula_04_002.png)
    , and the classical register is set to 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add gates to the quantum circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our quantum program to actually do something, we now add a Hadamard gate
    that will put the qubit in a superposition, and also a measurement gate that we
    will use to read the value of the quantum bit at the end of our program. The Hadamard
    gate is one of the foundational gates. We will look much more closely at that
    gate, and others, in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By visualizing the circuit with `qc.draw`(`''mpl''`), we see that just like
    in the IBM Quantum Experience® composer, we have a quantum circuit with 1 qubit
    and 1 classical bit, with a Hadamard gate on the qubit, and a measurement gate
    that will write the state of the qubit `q0_0` (![](img/Formula_04_002.png) or
    ![](img/Formula_04_001.png) ) to the classical bit `c0_0` as a 0 or 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.4 – A simple quantum coin toss circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.4 – A simple quantum coin toss circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a strictly text-based Python environment, you can also print your circuit
    with the `print(qc)` command or use `qc.draw`(`''text''`), both of which produce
    ASCII text output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The circuit displayed as ASCII text](img/Figure_4.5_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.5 – The circuit displayed as ASCII text
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the backend on which to run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this initial recipe, we will use the built-in `qasm_simulator` backend.
    We create a backend variable and call on the Aer component to get us the required
    backend information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a quantum job for the circuit and the selected backend that runs just
    one shot to simulate a coin toss. We then run the job and display the returned
    result; either ![](img/Formula_04_002.png) for heads or ![](img/Formula_04_001.png)
    for tails. The results are returned as a Python dictionary:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print and visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we get a printout of the results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we get a printout of the result as a histogram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The result of a single quantum "coin toss" as a histogram](img/Figure_4.6_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The result of a single quantum "coin toss" as a histogram
  prefs: []
  type: TYPE_NORMAL
- en: Success! Your very first quantum coin toss program returned a tails, or ![](img/Formula_04_001.png)
    result.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We tossed a quantum coin that started out with *heads* up ( ![](img/Formula_04_002.png)
    ), *spun* in quantum space as a superposition of ![](img/Formula_04_002.png) and
    ![](img/Formula_04_001.png), and finally landed in a *tails* position when we
    measured it.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s reiterate:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a qubit and initialized it in the ground state, ![](img/Formula_04_002.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then applied a Hadamard gate to the qubit, which moved the statevector from
    the pole to the equator of the Bloch sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mathematically, when you apply the Hadamard gate to your qubit, you run it through
    two rotations, first a ![](img/Formula_04_021.png) rotation around the *y* axis,
    and then a ![](img/Formula_04_022.png) rotation around the *x* axis. The qubit
    is now in a superposition of ![](img/Formula_04_002.png) and ![](img/Formula_04_001.png),
    halfway between the poles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more detailed information about the Hadamard gate, see the *Creating superpositions
    with the H gate* recipe in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we measured the qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By measuring, we destroyed the superposition, literally forcing nature to make
    up its mind, and the qubit will be either ![](img/Formula_04_002.png) or ![](img/Formula_04_001.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, go ahead and run your program a couple of times, noting if you get heads
    ( ![](img/Formula_04_002.png) ) or tails ( ![](img/Formula_04_001.png) ). If we
    have done this right, you should be simulating a coin toss pretty closely.
  prefs: []
  type: TYPE_NORMAL
- en: Getting some statistics – tossing many coins in a row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, so far, we have done a single coin toss at a time, much like you would
    do in real life.
  prefs: []
  type: TYPE_NORMAL
- en: But the power of quantum computing comes from running your quantum programs
    many times with the same initial conditions, letting the qubit superpositions
    play out their quantum mechanical advantages, and summarizing a large number of
    runs statistically.
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe, we will do 1,000 coin tosses in the blink of an eye and take
    a look at the results to see how good the coin is. Will this coin be a fair way
    to start, say, a game of baseball? Let's see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r2_coin_tosses.py).'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore and expand on the `shots` job parameter. This
    parameter lets you control how many times you run the quantum job cycle – prepare,
    run, measure. So far, we have prepared our qubits in the ![](img/Formula_04_002.png)
    state, set the backend to a simulator, and then run one shot, which represents
    one full cycle.
  prefs: []
  type: TYPE_NORMAL
- en: In the IBM Quantum Experience® composer examples, we ran our scores 1,024 times,
    which is the default. We discovered that the output turned statistical. In this
    recipe, we will play with a different number of shots to see how the outcomes
    statistically change.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, you want to increase the number of shots to improve statistical
    accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like in the previous recipe, the following steps are all you need:'
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse
  prefs: []
  type: TYPE_NORMAL
- en: And for the lazy coder, in this case, as you might have realized, the only real
    change to the circuit appears in *step 6*, where we set the number of shots. Feel
    free to reuse the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required Qiskit® classes and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the required registers and the quantum circuit. Set up our quantum circuit
    with one qubit and one classical bit. Create the quantum circuit based on the
    registers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add gates to the quantum circuit. Add the Hadamard and measurement gates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.7 – The same simple quantum coin toss circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.7_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.7 – The same simple quantum coin toss circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that this time, we run it with *1,000 shots*. This means that we run our
    quantum circuit 1,000 times, collect the results, and provide the average output
    as our results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print and visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time the output looks different:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here is the output in the form of a histogram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0
    and 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.8_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – The result of 1,000 shots, a roughly even distribution of 0 and
    1
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This time we used the underlying Qiskit® analytics to store and process the
    result of each individual shot and return it as a concatenated Python dictionary.
    The end result is a statistical view of all the actual outcomes of your quantum
    program. For the coin toss, you would expect to get heads and tails with roughly
    equal probability if you run it enough times.
  prefs: []
  type: TYPE_NORMAL
- en: Try adjusting the number of shots to 10,000 or 20,000, and see how your qubit
    behaves statistically.
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex quantum program, the result will usually indicate a preference
    for a specific outcome, a specific combination of qubit statistics where certain
    solutions are amplified and show up much more often than others. This is one of
    the key tricks with writing good quantum algorithms, understanding how to get
    the circuits to point to the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: We will go into more detail on this later, starting with the *Exploring quantum
    phase kickback* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, you are usually interested in getting the statistical result
    of your quantum program. In this case, we are looking at the probabilistic nature
    of a quantum coin toss – a random number generator. But sometimes, it might be
    interesting to see exactly what transpired, shot by shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve this by setting the `memory=True` parameter when you run your
    quantum program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This setting makes the quantum job save the individual results of each shot,
    and you can later retrieve these as a Python list by using the `result.get_memory()`
    command. For 10 shots on a 1-qubit circuit, the memory result might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And for 10 shots on a 2-qubit circuit (which we will do in a later recipe),
    the memory result might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can then dig out any data you want from this list and process it further
    with other Python tools as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an upside-down coin toss
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will tweak our very first quantum program a little bit but
    still keep it relatively simple. An actual coin can be tossed starting with either
    heads or tails facing upward. Let's do another quantum coin toss but with a different
    starting point, the coin facing tails up. In Dirac notation, we start with our
    qubit in ![](img/Formula_04_001.png) instead of in ![](img/Formula_04_002.png).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r3_coin_toss_tails.py).'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the previous recipe, this one is almost identical to the first coin
    toss recipe. Feel free to reuse what you have already created. The only real difference
    is that we add a new quantum gate, the **X** (or **NOT**) gate.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps are to a large extent identical to the steps from the *Quantum
    coin toss revisited* recipe. There are, however, differences depending on the
    program you are creating, and what Qiskit® components you are using. I will describe
    these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your code like the previous example and then add an X gate to flip the
    qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required Qiskit® classes and methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we are not importing the `QuantumRegister` and `ClassicalRegister`
    methods here like we did before. In this recipe, we will take a look at a different
    way of creating your quantum circuit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the quantum circuit with 1 qubit and 1 classical bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are implicitly letting the `QuantumCircuit` method create the quantum
    and classical registers in the background; we do not have to explicitly create
    them. We will refer to these registers by numbers and lists going forward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the Hadamard gate, the X gate, and the measurement gates to the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, here is the first example of using just numbers to refer to the qubits.
    We add the X gate to the first qubit, here referred to as 0 as Python starts numbering
    at 0, not 1:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The upside-down quantum coin toss circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.9 – The upside-down quantum coin toss circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the job, this time, we go back to 1 shot to do just a single coin toss:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice here how we have streamlined the code a bit and put all the execution
    in one row as we are only interested in the final counts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Setting your qubit to  by using the initialize method](img/Figure_4.10_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The results of a single upside-down quantum coin toss
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are introducing a new gate in this recipe, the Pauli-X gate. The X gate works
    just like a NOT gate in classical computing – it flips the value of a qubit.
  prefs: []
  type: TYPE_NORMAL
- en: If the qubit is ![](img/Formula_04_002.png), then it is flipped to ![](img/Formula_04_001.png),
    and if it is in ![](img/Formula_04_001.png), then it is flipped to ![](img/Formula_04_002.png).
  prefs: []
  type: TYPE_NORMAL
- en: For simple situations like this, it is intuitively easy to understand exactly
    what the result will be, but for more complex qubit configurations, where the
    Bloch vector points at an arbitrary point on the Bloch sphere, it gets a little
    trickier. Essentially what happens is that the qubit is rotated around the *x*
    axis through an angle of ![](img/Formula_04_036.png) radians.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The X gate is handy for this, but there is another way to set your coin toss
    tails up. You can use the Qiskit Aer `initialize` method to set the initial state
    of a qubit to ![](img/Formula_04_001.png) before running your circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python vector that corresponds to an excited ![](img/Formula_04_001.png)
    state and initialize the quantum circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the following code in your circuit, and replace it with the preceding
    initialize code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the program as normal. The results should be similar, but your circuit
    printout will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Setting your qubit to  by using the initialize method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.11_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Setting your qubit to ![](img/Formula_04_039.png) by using the
    initialize method
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, you can initialize any number of qubits to any state you choose.
    The initialization vector needs to fulfill two main criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It must include an entry for each of the 2n possible states. In the preceding
    example, with 1 qubit, all we needed was a vector with length 2\. For 2 qubits,
    the vector must have length 4, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The sum of the squares of the absolute value of the vector components must
    be equal to 1\. Here''s the initial vector from the preceding example that initialized
    the qubit to ![](img/Formula_04_001.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This translates into the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Initial vector](img/Figure_4.12_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Initial vector
  prefs: []
  type: TYPE_NORMAL
- en: 'This, in turn, gives the sum of probabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Sum of probabilities'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.13_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Sum of probabilities
  prefs: []
  type: TYPE_NORMAL
- en: Tossing two coins simultaneously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only played with one coin at a time, but there is nothing stopping
    us from adding more coins. In this recipe, we will add a coin to the simulation,
    and toss two coins simultaneously. We will do this by adding a second qubit, expanding
    the number of qubits – two of everything.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r4_two_coin_toss.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up your code like the previous example, but with a 2-qubit quantum circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Hadamard gates and the measurement gates to the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note how we are now using lists to reference multiple qubits and multiple bits.
    For example, we apply the Hadamard gate to qubits 0 and 1 by using [0,1] as input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.14 – A 2-qubit quantum coin toss circuit ](img/Figure_4.14_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.14 – A 2-qubit quantum coin toss circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the job with one shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we are using streamlined code as we are only interested in the counts
    here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.15 – The  result of a double quantum coin toss'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.15_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – The ![](img/Formula_04_041.png) result of a double quantum coin
    toss
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You set the number of qubits when you create the quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: When you ran the program, both qubits were supplied with Hadamard gates, creating
    two parallel qubits both in superposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Qiskit®, qubit numbering starts with 0 for the first qubit and then counts
    upward. A 3-qubit circuit will contain the following qubits, referred to as the
    first, second, and third qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using `QuantumRegister` notation, like in the *Quantum coin toss
    revisited* recipe: `q[0]`, `q[1]`, and `q[2]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are using the list notation: `[0,1,2]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do a little experimentation here by adding more qubits to your circuit. You
    will realize that you can use this simple method to create random numbers of any
    kind. The output will be a binary number of the same length as the number of qubits
    in your circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, creating a circuit with 20 qubits and running it with one shot
    might result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates into the following decimal number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'So, you can use quantum programs to create any type of random number. For example,
    you can also use this setup to create dice of different sizes following the 2n
    rule for a number of possible states (where n is the number of qubits). So, the
    calculation goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: One qubit = two possible states = coin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two qubits = four possible states = four-sided dice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three qubits = eight possible states = eight-sided dice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum-cheating in a coin toss? Introducing the Bell state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now you have the ability to toss one or more quantum coins and get a probabilistic
    outcome. That is all well and good, and we could picture ourselves doing some
    gambling with this new tool of ours, betting money against the outcome of a coin
    toss. But with a 50/50 outcome, the possibility of earning any real money is limited,
    unless, of course, we tweak the odds (that is, we cheat).
  prefs: []
  type: TYPE_NORMAL
- en: So how do you cheat in coin tossing? Well, knowing the outcome beforehand would
    be a clever way. And it turns out this is possible using a quantum phenomenon
    called **entanglement**.
  prefs: []
  type: TYPE_NORMAL
- en: By entangling two qubits, we connect them in a way so that they can no longer
    be described separately. In the most basic sense, if you have two entangled qubits
    and measure one of them as ![](img/Formula_04_002.png), the result of measuring
    the other one will be ![](img/Formula_04_002.png) as.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we use this to cheat in coin tossing? Well, we create two qubits,
    entangle them, and then we separate them (turns out this is the tricky part to
    do physically, but we will ignore that for now). You bring one qubit into the
    gambling den, and your friend keeps the other qubit outside the room.
  prefs: []
  type: TYPE_NORMAL
- en: When it is time to do a coin toss, you run your quantum circuit, entangle the
    qubits, and then your friend measures the qubit that they keep outside the room.
    They then sneakily, through some means (such as Bluetooth earphones, semaphoring,
    or telepathy), tell you what their measurement was, ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png). You will then instantly know what your qubit is,
    before you measure it, and can bet money on that outcome. After measuring, you
    will find that you were indeed right, and cash in your winnings.
  prefs: []
  type: TYPE_NORMAL
- en: So, how is this done quantum programmatically? We will introduce a new gate,
    **controlled-NOT** (**CX**).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r5_two_coin_toss_bell.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up your code like the previous example, with 2 qubits and classical bits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the Hadamard gate, a controlled NOT gate, and the measurement gates to the
    circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each circuit manipulation we do, such as adding a gate, we need to indicate
    which qubit to perform the manipulation on. For example, to add a Hadamard gate
    on the first qubit, you would use the code `qc.h(0)`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle
    the qubits](img/Figure_4.16_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.16 – 2-qubit quantum circuit with a controlled-NOT gate to entangle
    the qubits
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the job with one shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the histogram looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.17 – The result of a 2-qubit entangled coin toss](img/Figure_4.17_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.17 – The result of a 2-qubit entangled coin toss
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the circuit a couple of times and you will realize that the only result
    on this double quantum coin toss is ![](img/Formula_04_046.png) or ![](img/Formula_04_047.png).
    Now run the circuit again, but with 1,000 shots, and get the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following histogram as a result of your code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Result of 1,000 shots. Only  and  appear!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.18_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Result of 1,000 shots. Only ![](img/Formula_04_048.png) and ![](img/Formula_04_049.png)
    appear!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with the new gate, CX. This gate takes as input the quantum state
    of the first qubit (as indicated by the dot on the first qubit score) and then
    executes a NOT gate (x) on the second qubit if the quantum state is ![](img/Formula_04_007.png).
    If the quantum state is ![](img/Formula_04_002.png), it does nothing to the second
    qubit.
  prefs: []
  type: TYPE_NORMAL
- en: So here's a really exciting part of this story. At a point where we expect the
    `cx` gate to act, we do not know the state of the first qubit yet. The Hadamard
    gate has put it in a nice superposition, hovering exactly between ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png). Not until we measure the first qubit will we
    know what state the qubit is in. Not even nature will know the state because the
    qubit isn't in a specific state; it is in a superposition of two states.
  prefs: []
  type: TYPE_NORMAL
- en: So how would the CX gate know that it needed to flip the second qubit from ![](img/Formula_04_002.png)
    to ![](img/Formula_04_001.png) when we run the program? Well, that is the fascinating
    part of quantum computing, *it* *didn't*. Only when we measure the first qubit
    will the gate execution take place, and the entangled the second qubit will have
    flipped, or not. Einstein called this very real example of quantum mechanics *Spooky
    action at a distance* and wanted nothing to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: So, the end result when running our little recipe is to get one of the two possible
    outcomes for these two qubits, ![](img/Formula_04_054.png) or ![](img/Formula_04_055.png)
    with roughly equal probability. If the first qubit reads ![](img/Formula_04_002.png),
    then so will the second qubit, giving you the ![](img/Formula_04_057.png) result.
    The same is true for the opposite reading of ![](img/Formula_04_001.png); both
    qubits will read the same, giving us ![](img/Formula_04_059.png). Once you have
    read 1 qubit, you immediately know what the second will be. This is how cheating
    is done in quantum coin tossing!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But the Bell state is not locked into just the two results ![](img/Formula_04_060.png)
    and ![](img/Formula_04_061.png). By using other gates, you can set this entanglement
    up to be ![](img/Formula_04_062.png) and ![](img/Formula_04_063.png) as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Which gate would you use, on which qubit would it act, and where in your circuit
    would you add it? In this case, you might want to start the qubits in different
    states to see what happens. Take a look at the *Implementing an upside-down coin
    toss* recipe for inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results we got when running this Bell-state circuit on `qasm_simulator`
    (which simulates a perfect universal fault-tolerant quantum computer) gave us
    clear-cut results where both qubits were the same when measured all the time.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, where the existing physical quantum computers are still quite
    far from universal fault-tolerant quantum computers, the result will be somewhat
    different. For a quick look, see the *Tossing some real coins* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: More ways to quantum-cheat – tweaking the odds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used a quantum phenomenon called entanglement to
    cheat with our coin tossing. Admittedly, this might be complicated to set up,
    and people do tend to get suspicious of coin tossers with an earpiece who are
    obviously listening for information before catching and revealing the coin (measuring
    the qubit).
  prefs: []
  type: TYPE_NORMAL
- en: But there are more ways to skin a cat. Remember our discussion of qubits and
    quantum gates. By manipulating the qubit using gates, we could adjust the state
    of the qubit before we measure it. The closer the vector is to either ![](img/Formula_04_002.png)
    or ![](img/Formula_04_001.png), the higher the probability of that specific outcome
    when you measure.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use a rotation gate, the **Ry** gate, to increase the
    probability of getting a tails outcome when we toss our coin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r6_coin_toss_rot.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up your code like the previous example and then add a **Ry** gate to rotate
    the qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up our quantum circuit with one qubit and one classical bit and create
    the quantum circuit based on the registers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Hadamard gate, the Ry gate, and the measurement gates to the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should result in the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Our cheating coin toss circuit with a Ry gate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.19_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.19 – Our cheating coin toss circuit with a Ry gate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the job with a thousand shots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram for the preceding code looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.20_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.20 – A slightly skewed outcome for our cheating coin toss circuit
  prefs: []
  type: TYPE_NORMAL
- en: Alright, so the odds now seem to be much in your favor for tossing a ![](img/Formula_04_001.png)
    – almost 2 to 1.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs: []
  type: TYPE_NORMAL
- en: So, what is going on here? By adding the Ry gate, we managed to tweak the odds
    mightily in our favor. Let's take a closer look at what that gate does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Bloch vectors for the three different states that
    we are discussing here. In the sample code, there is this suspicious function
    that we have not touched upon yet. We will see more of it in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*. By calling the `get_psi()` function
    and using the quantum circuit that you are building, you can see the behavior
    of the qubit at each stage of building the circuit. The function uses another
    simulator, `statevector_simulator`, that calculates the behavior of the qubit
    at a given location in your circuit, and then we use the `plot_bloch_multivector()`
    method to display it as a Bloch sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When we call this function with a quantum circuit as an input, it will return
    the qubit statevector (psi or ![](img/Formula_04_067.png) ) at the end of the
    circuit. If more than one qubit is included in the circuit, the function will
    include the complete statevector for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the circuit with the `get_psi()` function enabled, change the `show_bloch`
    variable from `False` to `True`, and run your circuit again. The output should
    now look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we show the qubit in the ground state:![Figure 4.21 – In the initial
    ground state, the quantum vector is pointing straight
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: up to  as we expect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.21_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.21 – In the initial ground state, the quantum vector is pointing straight
    up to ![](img/Formula_04_068.png) as we expect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we show the qubit after the Hadamard gate, now in a superposition of ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png):![Figure 4.22 – After applying the Hadamard gate,
    the vector is now pointing along the x axis to the Bloch sphere equator](img/Figure_4.22_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.22 – After applying the Hadamard gate, the vector is now pointing along
    the x axis to the Bloch sphere equator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen this before. If we were to measure it now, we would get ![](img/Formula_04_002.png)
    and ![](img/Formula_04_001.png) with roughly 50% probability:![Figure 4.23 – Finally,
    after applying the Ry gate, the vector is now pointing below
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the Bloch sphere equator](img/Figure_4.23_B14436.jpg)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.23 – Finally, after applying the Ry gate, the vector is now pointing
    below the Bloch sphere equator
  prefs: []
  type: TYPE_NORMAL
- en: Now, we apply the Ry gate, rotating the vector ![](img/Formula_04_073.png) radians
    (0.3927 in our preceding circuit diagram) around the *y* axis toward ![](img/Formula_04_001.png).
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens here is that we have modified the angle ![](img/Formula_04_075.png)
    by using the Ry gate.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the formula from [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After applying the Hadamard gate, the angles were ![](img/Formula_04_077.png)
    and ![](img/Formula_04_078.png) (we haven't rotated around the *y* axis yet).
  prefs: []
  type: TYPE_NORMAL
- en: 'The probability of measuring ![](img/Formula_04_001.png) was then:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we change ![](img/Formula_04_081.png) to ![](img/Formula_04_082.png)
    by adding ![](img/Formula_04_073.png) , we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_04_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This corresponds very well with what we measured and shows us that we have indeed
    tweaked the probability of our quantum coin to land tails up.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three basic rotational gates—Rx, Ry, and Rz—that you can use to easily
    point the vector at any point on the Bloch sphere. These are described in more
    detail in [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156), *Understanding
    the Qiskit® Gate Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Try your hand at these variations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Have a go at creating a couple of quantum circuits using these:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a 1-qubit superposition without using the Hadamard gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the circuit to make sure that the result is the same as with a Hadamard
    gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 1-qubit superposition using the Hadamard gate, then use an R-gate to
    point the vector along the *y* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which gate would that be, and what is the input? Can you get the same result
    by skipping the Hadamard gate and using only an R gate? Which one? Now, measure
    and see if that makes any difference to the expected outcome for a circuit in
    superposition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look at the formula for calculating the probability of measuring ![](img/Formula_04_001.png)
    and see if you can use the Ry gate to set up a circuit that gives ![](img/Formula_04_001.png)
    as an outcome:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 99% of the time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 66% of the time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 33% of the time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Congratulations! Not only can you now cheat in quantum coin tossing, but you
    can also calculate your odds.
  prefs: []
  type: TYPE_NORMAL
- en: More on the get_psi() function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We started out with this very small, 1-qubit quantum circuit as an example of
    how to use our home-made `get_psi()` function to step your way through your circuit
    to understand how your qubits behave at each stage. Remember that even though
    people sometimes talk about qubits being 0 and 1 at the same time, what they really
    are referring to is the superposition math we have looked at. The important thing
    is that during our calculations, we place our qubits in very well-known states
    by manipulating their statevectors.
  prefs: []
  type: TYPE_NORMAL
- en: For small circuits, it is fairly easy to envision what is going on at each step,
    but for larger circuits, you quickly run out of brainpower to mentally visualize
    how the little qubits behave.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `get_psi()` function and the statevector simulator for just
    this. Call it from any point in your circuit design to see what your qubits are
    up to. If your quantum programs do not behave the way you expect, use the statevector
    simulator and Bloch sphere visualization to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: As we move along through the book, we will tweak and modify the `get_psi()`
    function to suit our needs, and use it to display additional details about our
    circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Adding more coins – straight and cheating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, our recipes have been mainly of the 1- or 2-qubit sort. With our
    simulator, there is nothing stopping us from adding more qubits to our circuits
    at will, with the caveat that each additional qubit will require more and more
    processing power from the system on which your simulator runs. For example, the
    IBM Quantum Experience® `qasm_simulator` runs on an IBM POWER9™ server and maxes
    out at around 32 qubits.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create two 3-qubit quantum programs, one multi-coin
    toss, and one new entangled state called **GHZ** (for **Greenberger–Horne–Zeilinger**
    state).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of doing this by creating two separate files, we will take a look at
    a new command, `reset()`. As the name implies, using the `reset()` command with
    a qubit sets it back to its original state of ![](img/Formula_04_002.png), ready
    to start a new quantum computing round. In this example, we use `reset()` to run
    two quantum programs in a row, writing to two sets of three classical registers,
    measuring twice per run.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r7_three_coin_toss_ghz.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up your code like the previous examples, but with three qubits and classical
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up our quantum circuit with three qubits and six classical bits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Hadamard gates and the measurement gates to the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output for the preceding code looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical
    bits 0, 1, and 2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.24_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.24 – A 3-qubit in superposition circuit, measuring to classical bits
    0, 1, and 2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to our local simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the job with a thousand shots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram for the preceding code looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Three qubits in superposition give random results'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.25_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.25 – Three qubits in superposition give random results
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice here that we only see measurement results for the three first classical
    bits (0, 1, and 2). The three last classical bits are all 0\.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now modify the circuit by resetting the qubits, adding a Hadamard gate to qubit
    0, then adding two CX (Controlled NOT) gates, one from qubit 0 to qubit 1, and
    one from qubit 0 to qubit 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use a new circuit command to reset the qubits of our circuit back to
    ![](img/Formula_04_002.png) and start over using `reset()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember that when you modify just one qubit, you must specify which qubit
    to modify, like this `qc.h`(`0`), to add a Hadamard gate to the first qubit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Resetting the qubits of a quantum circuit back to   and starting
    over, writing to classical bits 3, 4, and 5 for the final measurement'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.26_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.26 – Resetting the qubits of a quantum circuit back to ![](img/Formula_04_002.png)
    and starting over, writing to classical bits 3, 4, and 5 for the final measurement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the job with 1,000 shots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram presentation for the previous code looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.27 – The combined results of three coin toss qubits and of three
    entangled qubits, the GHZ state, in the first three and second three classical
    bits, respectively'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.27_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – The combined results of three coin toss qubits and of three entangled
    qubits, the GHZ state, in the first three and second three classical bits, respectively
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is nothing inherently new to the two circuits that we created, just more
    qubits, and two rounds of measurements. In the first one, we added all gates in
    parallel, and in the second one, we diligently specified which ones to add where.
    The end result was two 3-qubit circuits, one that represented even more coins
    tossed, and one that expanded on the Bell state we explored earlier.
  prefs: []
  type: TYPE_NORMAL
- en: That last one is interesting as it shows entanglement between several qubits;
    none of the qubits can now be treated separately. And this type of entanglement
    is key to more advanced quantum algorithms where a large number of qubits are
    set up, which are put in superposition and then entangled. They are finally acted
    on by other gates to produce specific outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tested a new way of writing the outcomes to classical bits. We wrote
    the coin toss results to the first three classical bits and the GHZ state results
    to the three last ones.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do a little experimentation to see how you can build larger circuits with more
    qubits, and how to add gates:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a 5-qubit circuit, with Hadamard gates on all, but measurement gates
    on the first, third, and fifth qubits only. How many classical registers do you
    really need?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 5-qubit circuit where you entangle the first, second, fourth, and fifth
    qubits with the third qubit. On which qubit do you need to add the Hadamard gate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The GHZ circuit we built as a part of this recipe gives the entangled results
    ![](img/Formula_04_089.png)and ![](img/Formula_04_090.png) only. Build a circuit
    that gives you the result ![](img/Formula_04_091.png) or ![](img/Formula_04_092.png)
    instead. What gate other than H and CX do you use, and where do you put it, or
    them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It might be easier to understand the workings of these circuits if you use one
    set of measurement commands only, and don't use the `reset()` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tossing some real coins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what do you say? Are you done simulating quantum coin tosses now, and want
    to do the real thing, running your Qiskit® quantum program on an actual IBM quantum
    computer? Let's finally get some use out of that IBM Quantum Experience® API key
    that you created.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will run the cheating coin toss or Bell state on an actual
    IBM Quantum® machine by using Qiskit®. We know what the expected result is on
    a perfectly simulated quantum computer and will now take a look at what the results
    of a real so-called NISQ machine look like.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will be getting some use out of that API key, introducing the IBMQ
    components, how to find the backends, how to select the best backend, and how
    to run the circuit against that backend.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter04/ch4_r8_coin_toss_IBMQ.py).'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to run your quantum program on real IBM hardware, you need to use
    the API key that you are assigned with in your IBM Quantum Experience® account.
    If you are running Qiskit® from the IBM Quantum Experience® notebook environment,
    then your API key is already available to you and no further action is needed.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you are running Qiskit® on your own local machine, you must store
    the API key locally. You might have already carried out these required steps as
    part of the *Installing your API key and accessing your provider* recipe in [*Chapter
    1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021), *Preparing Your Environment*.
    If not, go ahead and complete the task now. We'll wait for you here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set up your code as in the previous examples, with two qubits and classical
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the stored API key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up our quantum circuit with two qubits and two classical bits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Hadamard gate and the CX gate to prepare for a Bell state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code shows the following circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.28 – 2-qubit Bell-state circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_4.28_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.28 – 2-qubit Bell-state circuit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the backend to the least busy IBM Quantum® machine available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will revisit this way of picking an IBM Quantum® computer backend to run
    your circuit on in the *Finding the least busy backend* recipe of [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum Hardware® with Qiskit® Tools*. For now, just use the
    code as is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the job with 1,000 shots. Wait for the job to complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The histogram presentation for the preceding code looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.29 – The result of running the Bell-state circuit on an actual IBM
    Quantum® backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.29_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – The result of running the Bell-state circuit on an actual IBM
    Quantum® backend
  prefs: []
  type: TYPE_NORMAL
- en: Hold your horses! We were expecting results for only ![](img/Formula_04_093.png)
    and for ![](img/Formula_04_094.png) ... What is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wow, look at those noisy qubits!
  prefs: []
  type: TYPE_NORMAL
- en: What you are seeing in the noisy results of your program is just that – noise.
    Even though the IBM Quantum® computers are running at temperatures colder than
    outer space (15 millikelvin), they still suffer from random noise both when executing
    gates on the qubits and when measuring them.
  prefs: []
  type: TYPE_NORMAL
- en: The local `qasm_simulator` that we have run our quantum programs on up until
    this point behaves like a perfect **universal quantum computer**. The real hardware,
    on the other hand, is what is called a **Noisy Intermediate-Scale Quantum (NISQ)**
    computer, which behaves less than perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the existing IBM Quantum® backends in more detail in [*Chapter
    5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128), *Touring the IBM Quantum®
    Hardware with Qiskit® Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When running your job on an actual IBM Quantum® machine, things will generally
    differ from the controlled experience you had with your local simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Get in line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As soon as you start running one or two quantum programs on the IBM Quantum®
    machines, you will most likely realize that you are not the only one. As it happens,
    there are a limited number of quantum computers available to the general public
    to use for free. As of this writing, a steadily growing number of physical backends
    and one simulator can be used. Use the `provider.backends()` command to list the
    ones that are currently available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code might give a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you are in a timeshare here, with everyone else simultaneously
    running on the same machine as you. In the next chapter, we will take a closer
    look at these machines and explore how to figure out which one is best to use
    at any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware details in the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After your job is complete and you have looked at the results, you can take
    a quick peek at the complete returned results as well by using the `job.result()`
    command. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this result set, you can see information about the quantum computer backend
    that was used, the results of the run, as well as the status and date and time
    for the run.
  prefs: []
  type: TYPE_NORMAL
- en: What if the wait turns out to be long?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes there is just a really long queue ahead of you, and you have to wait
    your turn. In a sense, the IBM Quantum® machines work as a time-share setup from
    the early days of computing; only one program can run at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: But no need to despair. Your job has been submitted, and you can take a step
    back and let the machines do their work, picking up the thread when it suits you.
  prefs: []
  type: TYPE_NORMAL
- en: This works the same as in the IBM Quantum Experience® Circuit Composer. Once
    submitted, your job will wait its turn, and then show up on the results page when
    returned. To do the same with your local Qiskit®, you first need your job ID.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the job ID to get your most recent job, or even retrieve earlier
    jobs that you have executed. The job ID is unique for each executed job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `job.job_id()` command to get the job ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a job ID, you can get back the `job` object by using the
    `retrieve_job()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And now you can get the job results just like you are used to, from the `job`
    object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code might give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the job ID to find the status of your job, and to see where
    in the queue it currently is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: There are more features built in with the jobs that you can pull back from IBM
    Quantum Experience®. For a closer look at the backends and what you can learn
    about them, continue with [*Chapter 5*](B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128),
    *Touring the IBM Quantum® Hardware with Qiskit® Tools*.
  prefs: []
  type: TYPE_NORMAL
