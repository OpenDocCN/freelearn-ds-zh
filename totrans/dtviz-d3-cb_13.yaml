- en: Chapter 13. Test Drive your Visualization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Getting Jasmine and setting up the test environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test driving your visualization – chart creation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test driving your visualization – SVG rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test driving your visualization – pixel-perfect bar rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we program as a professional programmer it is always important to test
    the program we write in order to make sure it functions as designed and produces
    the expected outcome. D3 data visualization mainly consists of JavaScript programs
    hence just like any other program we write, data visualization needs to be tested
    to make sure it represents the underlying data accurately. Obviously, we can perform
    our validation through visual examination and manual testing, which is always
    a critical part of the process of building data visualization since visual observation
    gives us a chance to verify not only the correctness, but also the aesthetics,
    usability, and many other useful aspects. However, manual visual inspection can
    be quite subjective, therefore, in this chapter we will focus our effort on automated
    unit testing. Visualization well covered by unit tests can free the creator from
    the manual labor of verifying correctness by hand additionally, allowing him/her
    to focus more on the aesthetics, usability, and other important aspects where
    it is hard to automate with machine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is a method in which a smallest unit of the program is tested and
    verified by another program called the test case. The logic behind unit testing
    is that at unit level the program is typically simpler and more testable. If we
    can verify if every unit in the program is correct then putting these correct
    units together will give us a higher confidence that the integrated program is
    also correct. Furthermore, since unit tests are typically cheap and fast to execute,
    a group of unit test cases can be quickly and frequently executed to provide feedback
    whether our program is performing correctly or not.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Software testing is a complex topic and so far we have only scratched the surface;
    however, due to limited scope in this chapter, we will have to stop our introduction
    now and dive into developing unit tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on testing please check out the following links:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit test: [http://en.wikipedia.org/wiki/Unit_testing](http://en.wikipedia.org/wiki/Unit_testing)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test driven development: [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage: [http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Getting Jasmine and setting up the test environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing our unit test cases we need to set up an environment
    where our test cases can be executed to verify our implementation. In this recipe,
    we will show how this environment and necessary libraries can be set up for a
    visualization project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jasmine ([http://pivotal.github.io/jasmine/](http://pivotal.github.io/jasmine/))
    is a **behavior-driven development** (**BDD**) framework for testing JavaScript
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine ([http://pivotal.github.io/jasmine/](http://pivotal.github.io/jasmine/))
    是一个用于测试JavaScript代码的**行为驱动开发**（**BDD**）框架。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: BDD is a software development technique that combines **Test Driven Development**
    (**TDD**) with domain driven design.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是一种软件开发技术，它将**测试驱动开发**（**TDD**）与领域驱动设计相结合。
- en: 'We chose Jasmine as our testing framework because of its popularity in JavaScript
    community as well as its nice BDD syntax. You can download the Jasmine library
    from:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择Jasmine作为我们的测试框架，因为它在JavaScript社区中的流行以及它良好的BDD语法。您可以从以下位置下载Jasmine库：
- en: '[https://github.com/pivotal/jasmine/downloads](https://github.com/pivotal/jasmine/downloads)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/pivotal/jasmine/downloads](https://github.com/pivotal/jasmine/downloads)'
- en: 'Once downloaded you need to unzip it into the `lib` folder. Besides the `lib`
    folder we also need to create the `src` and `spec` folders for storing source
    files as well as test cases (in BDD terminology test cases are called specification).
    See the following screenshot for the folder structure:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您需要将其解压缩到`lib`文件夹中。除了`lib`文件夹外，我们还需要创建`src`和`spec`文件夹来存储源文件以及测试用例（在BDD术语中，测试用例被称为规范）。以下截图显示了文件夹结构：
- en: '![Getting ready](img/2162OS_13_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/2162OS_13_01.jpg)'
- en: Testing Directory Structure
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目录结构
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now, we have Jasmine in our library, next thing to do is to set up an HTML
    page that will include Jasmine library as well as our source code plus test cases
    so they can be executed to verify our program. This file is called `SpecRunner.html`
    in our setup which includes the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在我们的库中有了Jasmine，接下来要做的事情是设置一个HTML页面，该页面将包括Jasmine库以及我们的源代码和测试用例，以便它们可以被执行以验证我们的程序。在我们的设置中，这个文件被命名为`SpecRunner.html`，它包括以下代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This code follows standard Jasmine spec runner structure and generates execution
    report directly into our HTML page. Now, you have a fully functional test environment
    set up for your visualization development. If you open the `SpecRunner.html` file
    with your browser you will see a blank page at this point; however, if you check
    out our code sample you will see the following report:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遵循标准的Jasmine规范运行器结构，并将执行报告直接生成到我们的HTML页面中。现在，您已经为您的可视化开发设置了一个完整的测试环境。如果您用浏览器打开`SpecRunner.html`文件，您现在会看到一个空白页面；然而，如果您查看我们的代码示例，您将看到以下报告：
- en: '![How it works...](img/2162OS_13_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/2162OS_13_02.jpg)'
- en: Jasmine Report
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine报告
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Jasmine Reference Document: [http://pivotal.github.io/jasmine/](http://pivotal.github.io/jasmine/)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine参考文档：[http://pivotal.github.io/jasmine/](http://pivotal.github.io/jasmine/)
- en: Test driving your visualization – chart creation
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化 - 图表创建
- en: 'With test environment ready, we can move on and develop a simple bar chart
    very similar to what we have done in the *Creating a bar chart* recipe in [Chapter
    8](ch08.html "Chapter 8. Chart Them Up"), *Chart Them Up*, though this time in
    a test-driven fashion. You can see how the bar chart looks if you open the `tdd-bar-chart.html`
    page:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境准备就绪后，我们可以继续开发一个简单的条形图，这与我们在第8章的“创建条形图”食谱中做的是非常相似的，尽管这次是以测试驱动的形式。如果你打开`tdd-bar-chart.html`页面，你可以看到条形图的外观：
- en: '![Test driving your visualization – chart creation](img/2162OS_13_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![测试驱动你的可视化 - 图表创建](img/2162OS_13_03.jpg)'
- en: Test Driven Bar Chart
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动条形图
- en: By now we all know very well how to implement a bar chart using D3; however,
    building a bar chart is not the focus of this recipe. Instead, we want to show
    how we can build test cases every step of the way and verify automatically that
    our bar chart implementation is doing what it is supposed to do. The source code
    of this recipe was built using test driven development method; however, we will
    not show you every step in the TDD process due to limited scope in this book.
    Instead, we have grouped multiple steps into three larger sections with different
    focuses in this chapter and this recipe is the first step we take.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有人都非常清楚如何使用D3实现条形图；然而，构建条形图并不是本食谱的重点。相反，我们想展示如何每一步都构建测试用例，并自动验证我们的条形图实现是否正在执行其应有的功能。本食谱的源代码是使用测试驱动开发方法构建的；然而，由于本书的篇幅限制，我们不会展示TDD过程中的每一步。相反，我们将多个步骤组合成三个较大的部分，每个部分在本章和本食谱中都有不同的重点，而这个食谱是我们迈出的第一步。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First step we need to take is to make sure our bar chart implementation exists
    and can receive the data. The starting point of our development could be arbitrary
    and we decide to drive from this simplest function to set up the skeleton for
    our object. Here is what the test case looks like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的第一步是确保我们的条形图实现存在并且可以接收数据。我们的开发起点可以是任意的，我们决定从这个最简单的函数开始，为我们的对象设置框架。以下是测试用例的样子：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this first test case we used a few Jasmine constructs:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个测试用例中，我们使用了几个Jasmine构造：
- en: '`describe`: This function defines a suite of test cases; within describe a
    sub-suite can be nested and test cases can be defined'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：这个函数定义了一系列测试用例；在`describe`内部可以嵌套子测试套件，并定义测试用例。'
- en: '`it`: This function defines a test case'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it`：这个函数定义了一个测试用例'
- en: '`beforeEach`: This function defines a pre-execution hook which will execute
    the given function before the execution of each test case'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach`：这个函数定义了一个执行前钩子，它将在每个测试用例执行前执行给定的函数。'
- en: '`afterEach`: This function defines a post-execution hook which will execute
    the given function after the execution of each test case'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterEach`：这个函数定义了一个执行后钩子，它将在每个测试用例执行后执行给定的函数。'
- en: '`expect`: This function defines an expectation in your test case which can
    then be chained with matchers (for example, `toBe` and `toBeEmpty`) to perform
    assertion in your test case'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`：这个函数在测试用例中定义了一个期望，然后可以通过匹配器（例如，`toBe`和`toBeEmpty`）进行链式调用，以在测试用例中执行断言。'
- en: 'In our example we use the `beforeEach` hook to set up a `div` container for
    each test case and then remove `div` after execution in `afterEach` hook to improve
    the isolation between different test cases. The test case itself is almost trivial;
    it checks if the bar chart can take data and also return data attribute correctly.
    At this point if we run our SpecRunner, it will display a red message complaining
    there is no `BarChart` object, so let''s create our object and function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用`beforeEach`钩子为每个测试用例设置一个`div`容器，然后在`afterEach`钩子中删除`div`以改善不同测试用例之间的隔离。测试用例本身几乎是微不足道的；它检查条形图是否可以接收数据并正确返回数据属性。到目前为止，如果我们运行我们的SpecRunner，它将显示一条红色消息，抱怨没有`BarChart`对象，所以让我们创建我们的对象和函数：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if you run `SpecRunner.html` again it will give you a happy green message
    showing our only test case is passing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你再次运行`SpecRunner.html`，它将显示一个快乐的绿色消息，表明我们的唯一测试用例已经通过。
- en: Test driving your visualization – SVG rendering
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化——SVG渲染
- en: Now we have the basic skeleton of our bar chart object created, and we feel
    that we are ready to try to render something, so in this second iteration we will
    try to generate the `svg:svg` element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了条形图对象的初步框架，并且觉得我们已经准备好尝试渲染一些内容了，所以在这个第二次迭代中，我们将尝试生成`svg:svg`元素。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Rendering the `svg:svg` element should not only simply add the `svg:svg` element
    to the HTML body, but also translate the width and height setting on our chart
    object to proper SVG attributes. Here is how we express our expectation in our
    test cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染`svg:svg`元素不仅应该简单地将`svg:svg`元素添加到HTML主体中，还应该将我们的图表对象的宽度和高度设置转换为正确的SVG属性。以下是我们如何在测试用例中表达我们的期望：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At this point, all of these tests will fail since we don''t even have the render
    function; however, it clearly articulates that we expect the render function to
    generate the `svg:svg` element and setting the `width` and `height` attributes
    correctly. The second test case also makes sure that if the user does not provide
    the `height` and `width` attributes we will supply a set of default values. Here
    is how we will implement the render method to satisfy these expectations:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些测试都将失败，因为我们甚至没有渲染函数；然而，它清楚地说明了我们期望渲染函数生成`svg:svg`元素并正确设置`width`和`height`属性。第二个测试用例还确保，如果用户没有提供`height`和`width`属性，我们将提供一组默认值。以下是我们将如何实现渲染方法以满足这些期望：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point our `SpecRunner.html` is once again all green and happy. However,
    it's still not doing much since all it does is generate an empty `svg element`
    on the page and not even use the data at all.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`SpecRunner.html`再次全部显示为绿色和快乐。然而，它实际上并没有做很多事情，因为它只是在页面上生成一个空的`svg元素`，甚至没有使用任何数据。
- en: Test driving your visualization – pixel-perfect bar rendering
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动你的可视化——像素级完美的条形渲染
- en: In this iteration we will finally generate the bars using the data we have.
    Through our test cases we will make sure all bars are not only rendered but rendered
    with pixel-perfect precision.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们最终将使用我们拥有的数据生成条形图。通过我们的测试用例，我们将确保所有条形图不仅被渲染，而且渲染得像素级精确。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s see how we test it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何测试它的：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding test suite we describe our expectations of having the chart
    body `svg:g` element correctly transform and correct number of bars with appropriate
    attributes (`width`, `x`, `y`, `height`) set. The implementation is actually going
    to be shorter than our test case which is quite common in well tested implementation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试套件中，我们描述了我们期望图表主体 `svg:g` 元素能够正确变换，并且设置了正确数量的条形图，并带有适当的属性（`width`、`x`、`y`、`height`）。实际上，实现过程将比我们的测试用例要短，这在经过良好测试的实现中是很常见的：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I think you are getting the picture and now you can repeat this cycle over and
    over to drive your implementation. D3 visualization is built on HTML and SVG and
    both are simple mark-up languages that can be verified easily. Well thought-out
    test suite can make sure your visualization is pixel-perfect even sub-pixel perfect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你已经明白了这个道理，现在你可以一遍又一遍地重复这个循环来推动你的实现。D3 可视化建立在 HTML 和 SVG 之上，这两种都是简单的标记语言，可以轻松验证。精心设计的测试套件可以确保你的可视化不仅像素级精确，甚至可以达到亚像素级精确。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'Test driven development: [http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发：[http://en.wikipedia.org/wiki/Test-driven_development](http://en.wikipedia.org/wiki/Test-driven_development)
