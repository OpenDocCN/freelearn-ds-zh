["```py\nfrom . import builder\nfrom . import dialogues\nfrom . import toolkit\nfrom . import icons \n```", "```py\nfrom . import app\n```", "```py\nfrom .buttons import *\nfrom .layers import *\nfrom .map import *\nfrom .popups import *\nfrom .ribbon import *\nfrom .statusbar import *\nfrom .toolbars import *\n\nfrom . import theme\nfrom . import dispatch\n```", "```py\nimport os\nimport PIL.Image, PIL.ImageTk\n\nICONSFOLDER = os.path.split(__file__)[0]\n\ndef get(iconname, width=None, height=None):\n    iconpath = os.path.join(ICONSFOLDER, iconname)\n\n    if os.path.lexists(iconpath):\n        img = PIL.Image.open(iconpath)\n        if width or height:\n            width = width or img.size[0]\n            height = height or img.size[1]\n            img = img.resize((width,height), PIL.Image.ANTIALIAS)\n        tk_img = PIL.ImageTk.PhotoImage(img)\n        return tk_img\n\n    else:\n        raise Exception(\"No icon by that name\")\n```", "```py\ncolor1 = \"Grey69\"\ncolor2 = \"Grey79\"\ncolor3 = \"Grey89\"\ncolor4 = \"Grey99\"\ncolor5 = \"white\"\n\nstrongcolor1 = \"gold\"\nstrongcolor2 = \"dark orange\"\n\nalterncolor1 = \"DodgerBlue\"\nalterncolor2 = \"Blue3\"\n```", "```py\ntitlefont1 = {\"type\": (\"Segoe UI\", 12, \"bold\"),\n              \"color\": \"black\"}\ntitlefont1_contrast = {\"type\": (\"Segoe UI\", 12, \"bold\"),\n              \"color\": \"white\"}\n\nfont1 = {\"type\": (\"Segoe UI\", 10),\n         \"color\": \"black\"}\nfont2 = {\"type\": (\"Segoe UI\", 10),\n         \"color\": \"Grey42\"}\n```", "```py\n# Import builtins\nimport sys, os\n\n# Import GUI libraries\nimport Tkinter as tk\nfrom tkFileDialog import askopenfilenames, asksaveasfilename\nimport PIL, PIL.Image, PIL.ImageTk\n\n# Import internals\nfrom .. import icons\n```", "```py\n# Import theme\nfrom . import theme\nstyle_button_normal = {\"fg\": theme.font1[\"color\"],\n                  \"font\": theme.font1[\"type\"],\n                  \"bg\": theme.color4,\n                   \"relief\": \"flat\",\n                   \"activebackground\": theme.strongcolor2\n                   }\nstyle_button_mouseover = {\"bg\": theme.strongcolor1\n                    }\n```", "```py\nclass Button(tk.Button):\n    def __init__(self, master, **kwargs):\n        # get theme style\n        style = style_button_normal.copy()\n        style.update(kwargs)\n\n        # initialize\n        tk.Button.__init__(self, master, **style)\n\n        # bind event behavior\n        def mouse_in(event):\n            event.widget.config(style_button_mouseover)\n        def mouse_out(event):\n            event.widget.config(style_button_normal)\n\n        self.bind(\"<Enter>\", mouse_in)\n        self.bind(\"<Leave>\", mouse_out)\n```", "```py\nclass OkButton(Button):\n    def __init__(self, master, **kwargs):\n        # initialize\n        if kwargs.get(\"text\") == None:\n            kwargs[\"text\"] = \"OK\"\n        okfunc = kwargs.get(\"command\")\n        Button.__init__(self, master, **kwargs)\n\n        # bind enter keypress to command function\n        def runfunc(event):\n            okfunc()\n        self.winfo_toplevel().bind(\"<Return>\", runfunc)\n```", "```py\nclass IconButton(Button):\n    def __init__(self, master, **kwargs):\n        # initialize\n        Button.__init__(self, master, **kwargs)\n\n    def set_icon(self, iconname, **kwargs):\n        # get icon as tkinter photoimage, with an optional resize\n        tk_img = icons.get(iconname,\n                           width=kwargs.get(\"width\"),\n                           height=kwargs.get(\"height\"))\n        self.config(image=tk_img, **kwargs)\n        # resize button to have room for text if compound type\n        if not kwargs.get(\"anchor\"): kwargs[\"anchor\"] = \"center\"\n        if kwargs.get(\"compound\"):\n            def expand():\n                self[\"width\"] += tk_img.width()\n                self[\"height\"] += tk_img.height() / 2\n            self.after(100, expand)\n        # store as attribute, so it doesn't get garbage collected\n        self.tk_img = tk_img\n```", "```py\n# Import GUI\nimport Tkinter as tk\n\n# Import internals\nfrom .buttons import *\nfrom .popups import *\n\n# Import style\nfrom . import theme\nstyle_toolbar_normal = {\"bg\": theme.color4}\nstyle_namelabel_normal = {\"bg\": theme.color4,\n                          \"font\": theme.font2[\"type\"],\n                          \"fg\": theme.font2[\"color\"],\n                          \"pady\": 0}\n```", "```py\nclass Toolbar(tk.Frame):\n    \"\"\"\n    Base class for all toolbars.\n    \"\"\"\n    def __init__(self, master, toolbarname, **kwargs):\n        # get theme style\n        style = style_toolbar_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # Divide into button area and toolbar name\n        self.buttonframe = tk.Frame(self, **style)\n        self.buttonframe.pack(side=\"top\", fill=\"y\", expand=True)\n        self.name_label = tk.Label(self, **style_namelabel_normal)\n        self.name_label[\"text\"] = toolbarname\n        self.name_label.pack(side=\"bottom\")\n\n    def add_button(self, icon=None, **kwargs):\n        button = IconButton(self.buttonframe)\n        options = {\"text\":\"\", \"width\":48, \"height\":32, \"compound\":\"top\"}\n        options.update(kwargs)\n        if icon:\n            button.set_icon(icon, **options)\n        else:\n            button.config(**options)\n        button.pack(side=\"left\", padx=2, pady=0, anchor=\"center\")\n        return button\n```", "```py\n# Import GUI\nimport Tkinter as tk\n\n# Import internals\nfrom .toolbars import *\n\n# Import style\nfrom . import theme\nstyle_ribbon_normal = {\"bg\": theme.color3,\n                       \"height\": 120,\n                       \"pady\": 0}\n\nstyle_tabsarea_normal = {\"bg\": theme.color3,\n                         \"height\": 20,\n                         \"padx\": 1,\n                         \"pady\": 0}\n\nstyle_tabselector_normal = {\"bg\": theme.color3,\n                            \"activebackground\": theme.color4,\n                            \"fg\": theme.font1[\"color\"],\n                            \"font\": theme.font1[\"type\"],\n                            \"relief\": \"flat\",\n                            \"padx\":10, \"pady\":5}\nstyle_tabselector_mouseover = {\"bg\": \"Grey93\" }\n\nstyle_toolbarsarea_normal = {\"bg\": theme.color4}\n```", "```py\nclass Ribbon(tk.Frame):\n    \"\"\"\n    Can switch between a series of logically grouped toolbar areas (tabs).\n    \"\"\"\n    def __init__(self, master, **kwargs):\n        # get theme style\n        style = style_ribbon_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # Make top area for tab selectors\n        self.tabs_area = tk.Frame(self, **style_tabsarea_normal)\n        self.tabs_area.pack(fill=\"x\", side=\"top\")\n\n        # Make bottom area for each tab's toolbars\n        self.toolbars_area = tk.Frame(self, **style_toolbarsarea_normal)\n        self.toolbars_area.pack(fill=\"both\", expand=True, side=\"top\")\n        self.pack_propagate(False)\n\n        # Create tab list\n        self.tabs = dict()\n\n    def add_tab(self, tabname):\n        tab = Tab(self.toolbars_area, tabname=tabname)\n        self.tabs[tab.name] = tab\n        self.current = tab\n        # add tab to toolbars area\n        tab.place(relwidth=1, relheight=1)\n        # add tabname to tab selector area\n        tab.selector = tk.Label(self.tabs_area, text=tab.name, **style_tabselector_normal)\n        tab.selector.pack(side=\"left\", padx=5)\n        # enable dynamic tab selector styling\n        def mouse_in(event):\n            if event.widget[\"state\"] == \"normal\":\n                event.widget.config(style_tabselector_mouseover)\n        def mouse_out(event):\n            if event.widget[\"state\"] == \"normal\":\n                event.widget.config(style_tabselector_normal)\n        tab.selector.bind(\"<Enter>\", mouse_in)\n        tab.selector.bind(\"<Leave>\", mouse_out)\n        # make tab selector selectable\n        tab.selector.bind(\"<Button-1>\", self.switch)\n        return tab\n\n    def switch(self, event=None, tabname=None):\n        if event: tabname = event.widget[\"text\"]\n        # deactivate old tab\n        self.current.selector[\"state\"] = \"normal\"\n        # activate new tab\n        self.current = self.tabs[tabname]\n        self.current.selector.config(style_tabselector_normal)\n        self.current.selector[\"state\"] = \"active\"\n        self.current.lift()\n```", "```py\nclass Tab(tk.Frame):\n    \"\"\"\n    Base class for all tabs\n    \"\"\"\n    def __init__(self, master, tabname, **kwargs):\n        # get theme style\n        style = style_toolbarsarea_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # remember name\n        self.name = tabname\n\n    def add_toolbar(self, toolbarname):\n        toolbar = Toolbar(self, toolbarname=toolbarname)\n        toolbar.pack(side=\"left\", padx=10, pady=0, fill=\"y\")\n        return toolbar\n```", "```py\n# Import GUI\nimport Tkinter as tk\n\n# Import style\nfrom . import theme\nstyle_statusbar_normal = {\"height\": 25,\n                          \"bg\": theme.color3}\nstyle_status_normal = {\"fg\": theme.font2[\"color\"],\n                       \"font\": theme.font2[\"type\"],\n                       \"bg\": theme.color3}\nstyle_taskstatus_normal = style_status_normal.copy()\nstyle_taskstatus_working = {\"fg\": theme.font1[\"color\"],\n                            \"font\": theme.font1[\"type\"],\n                            \"bg\": theme.strongcolor2}\n```", "```py\nclass StatusBar(tk.Frame):\n    def __init__(self, master, **kwargs):\n        \"\"\"\n        A container bar that contains one or more status widgets\n        \"\"\"\n        # get theme style\n        style = style_statusbar_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # Insert status items\n        self.task = TaskStatus(self)\n        self.task.place(relx=0.0, rely=0.5, anchor=\"w\") \n        self.projection = ProjectionStatus(self)\n        self.projection.place(relx=0.20, rely=0.5, anchor=\"w\") \n        self.zoom = ZoomStatus(self)\n        self.zoom.place(relx=0.40, rely=0.5, anchor=\"w\") \n        self.mouse = MouseStatus(self)\n        self.mouse.place(relx=0.70, rely=0.5, anchor=\"w\")\n```", "```py\nclass Status(tk.Label):\n    def __init__(self, master, **kwargs):\n        \"\"\"\n        The base class used for all status widgets\n        \"\"\"\n        # get theme style\n        style = style_status_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Label and add to it\n        tk.Label.__init__(self, master, **style)\n        self.prefix = \"\"\n\n    def set_text(self, text):\n        self[\"text\"] = self.prefix + text\n\n    def clear_text(self):\n        self[\"text\"] = self.prefix\n\nclass TaskStatus(Status):\n    def __init__(self, master, **kwargs):\n        # Make this class a subclass of tk.Label and add to it\n        default = {\"width\":30, \"anchor\":\"w\"}\n        default.update(kwargs)\n        Status.__init__(self, master, **default)\n\n        # Set startup status\n        self.set_text(\"Ready\")\n\n    def start(self, taskname):\n        self.config(**style_taskstatus_working)\n        self.set_text(taskname)\n\n    def stop(self):\n        self.set_text(\"Finished!\")\n        self.config(**style_taskstatus_normal)\n        def reset_text():\n            self.set_text(\"Ready\")\n        self.after(1000, reset_text)\n\nclass ProjectionStatus(Status):\n    def __init__(self, master, **kwargs):\n        # Make this class a subclass of tk.Label and add to it\n        self.prefix = \"Map Projection: \"\n        default = {\"text\":self.prefix, \"width\":30, \"anchor\":\"w\"}\n        default.update(kwargs)\n        Status.__init__(self, master, **default)\n\nclass ZoomStatus(Status):\n    def __init__(self, master, **kwargs):\n        # Make this class a subclass of tk.Label and add to it\n        self.prefix = \"Horizontal Scale: \"\n        default = {\"text\":self.prefix, \"width\":30, \"anchor\":\"w\"}\n        default.update(kwargs)\n        Status.__init__(self, master, **default)\n\nclass MouseStatus(Status):\n    def __init__(self, master, **kwargs):\n        # Make this class a subclass of tk.Label and add to it\n        self.prefix = \"Mouse coordinates: \"\n        default = {\"text\":self.prefix, \"width\":50, \"anchor\":\"w\"}\n        default.update(kwargs)\n        Status.__init__(self, master, **default)\n```", "```py\n# Import GUI functionality\nimport Tkinter as tk\nfrom tkFileDialog import askopenfilenames, asksaveasfilename\n\n# Import internals\nfrom .buttons import *\nfrom .popups import *\n\n# Import style\nfrom . import theme\nstyle_layerspane_normal = {\"bg\": theme.color4,\n                           \"width\": 200}\nstyle_layersheader = {\"bg\": theme.color2,\n                      \"font\": theme.titlefont1[\"type\"],\n                      \"fg\": theme.titlefont1[\"color\"],\n                      \"anchor\": \"w\", \"padx\": 5}\n\nstyle_layeritem_normal = {\"bg\": theme.color4,\n                          \"width\": 200,\n                          \"relief\": \"ridge\"}\nstyle_layercheck = {\"bg\": theme.color4}\nstyle_layername_normal = {\"bg\": theme.color4,\n                   \"fg\": theme.font1[\"color\"],\n                   \"font\": theme.font1[\"type\"],\n                   \"relief\": \"flat\",\n                   \"anchor\": \"w\"}\n\n# Import GIS functionality\nimport pythongis as pg\nfrom . import dispatch\n```", "```py\nclass LayersPane(tk.Frame):\n    def __init__(self, master, layer_rightclick=None, **kwargs):\n        # get theme style\n        style = style_layerspane_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Frame and add to it\n        tk.Frame.__init__(self, master, **style)\n\n        # Make the top header\n        self.header = tk.Label(self, text=\"Layers:\", **style_layersheader)\n        self.header.pack(side=\"top\", fill=\"x\")\n\n        # Then, the layer list view\n        self.layersview = tk.Frame(self, **style)\n        self.layersview.pack(side=\"top\", fill=\"x\")\n        self.pack_propagate(False) # important, this prevents layeritem names from deciding the size of layerspane\n```", "```py\n# Import builtins\nimport time\n\n# Import GUI libraries\nimport Tkinter as tk\n\n# Import internals\nfrom .popups import popup_message\nfrom .. import icons\n\n# Import GIS functionality\nimport pythongis as pg\nfrom . import dispatch\n\n# Import style\nfrom . import theme\nstyle_map_normal = {\"bg\": theme.color1} \n```", "```py\nclass MapView(tk.Canvas):\n    def __init__(self, master, **kwargs):\n        # get theme style\n        style = style_map_normal.copy()\n        style.update(kwargs)\n\n        # Make this class a subclass of tk.Canvas and add to it\n        tk.Canvas.__init__(self, master, **style)\n\n        # Other\n        self.proj = kwargs.get(\"projection\", \"WGS84\")\n        self.statusbar = None\n        self.mousepressed = False\n        self.mouse_mode = \"pan\"\n        self.zoomcenter = None\n        self.zoomfactor = 1\n        self.zoomdir = None\n        self.last_zoomed = None \n\n    def assign_statusbar(self, statusbar):\n        statusbar.mapview = self\n        self.statusbar = statusbar\n```", "```py\n# Import GUI helpers\nimport Tkinter as tk\nimport tkMessageBox\n\n# Import internals\nfrom .buttons import IconButton, OkButton, CancelButton\nfrom . import dispatch\nfrom ... import vector\n\n# Define some styles\nfrom . import theme\nstyle_options_helptext = {\"font\": theme.font1[\"type\"],\n                          \"fg\": theme.font1[\"color\"]}\nstyle_options_titles = {\"font\": theme.titlefont1[\"type\"],\n                        \"fg\": theme.titlefont1[\"color\"]}\nstyle_options_labels = {\"font\": theme.font1[\"type\"],\n                      \"fg\": theme.font1[\"color\"]}\n```", "```py\ndef popup_message(parentwidget, errmsg):\n    tkMessageBox.showwarning(\"Warning\", errmsg) \n\nclass Window(tk.Toplevel):\n    def __init__(self, master=None, **kwargs):\n        # Make this class a subclass of tk.Menu and add to it\n        tk.Toplevel.__init__(self, master, **kwargs)\n        # Set its size to percent of screen size, and place in middle\n        width = self.winfo_screenwidth() * 0.6\n        height = self.winfo_screenheight() * 0.6\n        xleft = self.winfo_screenwidth()/2.0 - width / 2.0\n        ytop = self.winfo_screenheight()/2.0 - height / 2.0\n        self.geometry(\"%ix%i+%i+%i\"%(width, height, xleft, ytop))\n        # Force and lock focus to the window\n        self.grab_set()\n        self.focus_force()\n```", "```py\nclass RunToolFrame(tk.Frame): \n    def __init__(self, master=None, **kwargs):\n        # Make this class a subclass of tk.Toplevel and add to it\n        tk.Frame.__init__(self, master, **kwargs)\n\n        # Create empty option and input data\n        self.hidden_options = dict()\n        self.inputs = list()\n        self.statusbar = None\n        self.method = None\n        self.process_results = None\n\n        # Make helpscreen area to the right\n        self.helpscreen = tk.Frame(self)\n        self.helpscreen.pack(side=\"right\", fill=\"y\")\n        self.helptitle = tk.Label(self.helpscreen, text=\"Help Screen\", **style_options_titles)\n        self.helptitle.pack(fill=\"x\")\n        self.helptext = tk.Text(self.helpscreen, width=30,\n                                wrap=tk.WORD, cursor=\"arrow\",\n                                **style_options_helptext)\n        self.helptext.pack(fill=\"both\", expand=True)\n\n        # Make main screen where input goes to the left\n        self.mainscreen = tk.Frame(self)\n        self.mainscreen.pack(side=\"left\", fill=\"both\", expand=True)\n        self.maintitle = tk.Label(self.mainscreen, text=\"User Input\", **style_options_titles)\n        self.maintitle.pack()\n        self.mainoptions = tk.Frame(self.mainscreen)\n        self.mainoptions.pack(fill=\"both\", expand=True)\n        self.mainbottom = tk.Frame(self.mainscreen)\n        self.mainbottom.pack()\n\n        # Make run button at bottom\n        self.runbut = OkButton(self.mainbottom, command=self.run)\n        self.runbut.pack(side=\"right\")\n```", "```py\n    def add_option_input(self, label, valuetype, argname=None, multi=False, length=None, default=None, minval=None, maxval=None, choices=None):\n        optionrow = tk.Frame(self.mainoptions)\n        optionrow.pack(fill=\"x\", anchor=\"n\", pady=5, padx=5)\n        if multi:\n            # make a list-type widget that user can add to\n            inputlabel = tk.Label(optionrow, text=label, **style_options_labels)\n            inputlabel.pack(side=\"left\", anchor=\"nw\", padx=3)\n            inputwidget = tk.Listbox(optionrow, activestyle=\"none\",\n                                     highlightthickness=0, selectmode=\"extended\",\n                                     **style_options_labels)\n            inputwidget.pack(side=\"right\", anchor=\"ne\", padx=3)\n\n            if choices:\n                # add a listbox of choices to choose from\n                def addtolist():\n                    for selectindex in fromlist.curselection():\n                        selectvalue = fromlist.get(selectindex)\n                        inputwidget.insert(tk.END, selectvalue)\n                    for selectindex in reversed(fromlist.curselection()):\n                        fromlist.delete(selectindex)\n                def dropfromlist():\n                    for selectindex in inputwidget.curselection():\n                        selectvalue = inputwidget.get(selectindex)\n                        fromlist.insert(tk.END, selectvalue)\n                    for selectindex in reversed(inputwidget.curselection()):\n                        inputwidget.delete(selectindex)\n                # define buttons to send back and forth bw choices and input\n                buttonarea = tk.Frame(optionrow)\n                buttonarea.pack(side=\"right\", anchor=\"n\")\n                addbutton = IconButton(buttonarea, command=addtolist,\n                                       text=\"-->\", **style_options_labels)\n                addbutton.pack(anchor=\"ne\", padx=3, pady=3)\n                dropbutton = IconButton(buttonarea, command=dropfromlist,\n                                       text=\"<--\", **style_options_labels)\n                dropbutton.pack(anchor=\"ne\", padx=3, pady=3)\n                # create and populate the choices listbox\n                fromlist = tk.Listbox(optionrow, activestyle=\"none\",\n                                     highlightthickness=0, selectmode=\"extended\",\n                                     **style_options_labels)\n                for ch in choices:\n                    fromlist.insert(tk.END, ch)\n                fromlist.pack(side=\"right\", anchor=\"ne\", padx=3)\n            else:\n                # add a freeform entry field and button to add to the listbox\n                def addtolist():\n                    entryvalue = addentry.get()\n                    inputwidget.insert(tk.END, entryvalue)\n                    addentry.delete(0, tk.END)\n                def dropfromlist():\n                    for selectindex in reversed(inputwidget.curselection()):\n                        inputwidget.delete(selectindex)\n                buttonarea = tk.Frame(optionrow)\n                buttonarea.pack(side=\"right\", anchor=\"n\")\n                addbutton = IconButton(buttonarea, command=addtolist,\n                                       text=\"-->\", **style_options_labels)\n                addbutton.pack(anchor=\"ne\", padx=3, pady=3)\n                dropbutton = IconButton(buttonarea, command=dropfromlist,\n                                       text=\"<--\", **style_options_labels)\n                dropbutton.pack(anchor=\"ne\", padx=3, pady=3)\n                # place the freeform text entry widget\n                addentry = tk.Entry(optionrow, **style_options_labels)\n                addentry.pack(side=\"right\", anchor=\"ne\", padx=3)\n\n        else:\n            inputlabel = tk.Label(optionrow, text=label, **style_options_labels)\n            inputlabel.pack(side=\"left\", anchor=\"nw\")\n            if choices:\n                # dropdown menu of choices\n                choice = tk.StringVar()\n                if default: choice.set(default)\n                inputwidget = tk.OptionMenu(optionrow, choice, *choices)\n                inputwidget.choice = choice\n                inputwidget.pack(side=\"right\", anchor=\"ne\", padx=3)\n            else:\n                # simple number or string entry widget\n                inputwidget = tk.Entry(optionrow, **style_options_labels)\n                inputwidget.pack(side=\"right\", anchor=\"ne\")\n                if default != None:\n                    inputwidget.insert(tk.END, str(default))\n\n        # remember for later\n        inputwidget.meta = dict(argname=argname, label=label, choices=choices,\n                                valuetype=valuetype, multi=multi, length=length,\n                                default=default, minval=minval, maxval=maxval)            \n        self.inputs.append(inputwidget)\n\n    def add_hidden_option(self, argname, value):\n        self.hidden_options[argname] = value\n```", "```py\n    def assign_statusbar(self, statusbar):\n        self.statusbar = statusbar\n\n    def set_target_method(self, taskname, method):\n        self.taskname = taskname\n        self.method = method\n        # use the method docstring as the help text\n        doc = method.__doc__\n        if doc:\n            # clean away tabs, multispaces, and other junk\n            cleandoc = method.__doc__.strip().replace(\"\\t\",\"\").replace(\"  \",\" \")\n            # only keep where there are two newlines after each other\n            # because single newlines are likely just in-code formatting\n            cleandoc = \"\\n\\n\".join(paragraph.replace(\"\\n\",\"\").strip() for paragraph in cleandoc.split(\"\\n\\n\") )\n            helptext = cleandoc\n        else:\n            helptext = \"Sorry, no documentation available...\"\n        self.helptext.insert(tk.END, helptext)\n        self.helptext[\"state\"] = tk.DISABLED\n\n    def set_finished_method(self, method):\n        self.process_results = method\n\n    def get_options(self):\n        args = list()\n        kwargs = dict()\n        for key,val in self.hidden_options.items():\n            if key == None: args.extend(val) #list arg\n            else: kwargs[key] = val\n        for inputwidget in self.inputs:\n            argname = inputwidget.meta[\"argname\"]\n            multi = inputwidget.meta[\"multi\"]\n            choices = inputwidget.meta[\"choices\"]\n            valuetype = inputwidget.meta[\"valuetype\"]\n\n            # ensure within min/max range\n            def validate(value):\n                minval = inputwidget.meta[\"minval\"]\n                if minval and not value >= minval:\n                    return Exception(\"The input value for %s was smaller than the minimum value %s\" %(inputwidget.meta[\"label\"], minval))\n                maxval = inputwidget.meta[\"maxval\"]\n                if maxval and not value <= maxval:\n                    return Exception(\"The input value for %s was larger than the maximum value %s\" %(inputwidget.meta[\"label\"], minval))\n                return value\n\n            # get value based on the argument type\n            if argname == None:\n                # if argname is None, then it is not a kwarg, but unnamed arg list\n                get = inputwidget.get(0, last=tk.END)\n                if get != \"\":\n                    args.extend( [validate(valuetype(val)) for val in get] )\n            elif multi:\n                get = inputwidget.get(0, last=tk.END)\n                if get != \"\":\n                    kwargs[argname] = [ validate(valuetype(val)) for val in get ]\n            elif choices:\n                get = inputwidget.choice.get()\n                if get != \"\":\n                    kwargs[argname] = validate(valuetype(get))\n            else:\n                get = inputwidget.get()\n                if get != \"\":\n                    kwargs[argname] = validate(valuetype(get))\n        return args,kwargs\n\n    def run(self):\n        # first ensure the tool has been prepped correctly\n        if not self.statusbar:\n            raise Exception(\"Internal error: The tool has not been assigned a statusbar\")\n        if not self.method:\n            raise Exception(\"Internal error: The tool has not been assigned a method to be run\")\n        if not self.process_results:\n            raise Exception(\"Internal error: The tool has not been assigned how to process the results\")\n\n        # get options\n        try:\n            args,kwargs = self.get_options()\n        except Exception as err:\n            popup_message(self, \"Invalid options: \\n\" + str(err) )\n            return\n\n        # start statusbar\n        self.statusbar.task.start(self.taskname)\n\n        # run task\n        pending = dispatch.request_results(self.method, args=args, kwargs=kwargs)\n\n        # schedule to process results upon completion\n        def finish(results):\n            # first run user specified processing\n            try:\n                self.process_results(results)\n            except Exception as err:\n                popup_message(self, \"Error processing results:\" + \"\\n\\n\" + str(err) )\n            # then stop the task\n            self.statusbar.task.stop()\n        # note: this window cannot be the one to schedule the listening\n        # ...because this window might be destroyed, so use its master\n        dispatch.after_completion(self.master, pending, finish)\n```", "```py\nimport threading\nimport Queue\nimport traceback\n\ndef request_results(func, args=(), kwargs={}):\n    # prepare request\n    results = Queue.Queue()\n    func_args = (args, kwargs)\n    instruct = func, func_args, results\n\n    # ask the thread\n    worker = threading.Thread(target=_compute_results_, args=instruct)\n    worker.daemon = True\n    worker.start()\n\n    # return the empty results, it is up to the GUI to wait for it\n    return results\n\ndef after_completion(window, queue, func):\n\n    def check():\n        try:\n            result = queue.get(block=False)\n        except:\n            window.after(1000, check)\n        else:\n            func(result)\n\n    window.after(100, check)\n\ndef _compute_results_(func, func_args, results):\n    \"\"\"\n    This is where the actual work is done,\n    and is run entirely in the new worker thread.\n    \"\"\"\n    args, kwargs = func_args\n    try: _results = func(*args, **kwargs)\n    except Exception as errmsg:\n        _results = Exception(traceback.format_exc() )\n    results.put( _results )\n```", "```py\n# Import builtins\nimport sys, os\nimport time\n\n# Import GUI library\nimport Tkinter as tk\n\n# Import internals\nfrom .toolkit import *\nfrom .dialogues import *\n\n# Import GIS functionality\nimport pythongis as pg\n\nclass GUI(tk.Frame):\n    def __init__(self, master, **kwargs):\n        tk.Frame.__init__(self, master, **kwargs)\n\n        # Place top ribbon area\n        self.ribbon = Ribbon(self)\n        self.ribbon.pack(side=\"top\", fill=\"x\")\n        # Add tabs\n        hometab = self.ribbon.add_tab(\"Home\")\n        # Set starting tab\n        self.ribbon.switch(tabname=\"Home\")\n\n        # Place main middle area\n        middle_area = tk.Frame(self)\n        middle_area.pack(side=\"top\", expand=True, fill=\"both\")\n\n        # Layers pane on left\n        self.layerspane = LayersPane(middle_area)\n        self.layerspane.pack(side=\"left\", fill=\"y\")\n\n        # Mapwidget on right\n        self.mapview = MapView(middle_area)\n        self.mapview.pack(side=\"left\", fill=\"both\", expand=True)\n\n        # Place bottom info and mouse coords bar at bottom\n        self.statusbar = StatusBar(self, height=20, width=100)\n        self.statusbar.pack(side=\"bottom\", fill=\"x\")\n\n        # Assign statusbar to widgets that perform actions\n        self.mapview.assign_statusbar(self.statusbar)\n        self.layerspane.assign_statusbar(self.statusbar)\n```", "```py\ndef run():\n    \"\"\"Build the GUI.\"\"\"\n    # create main window\n    window = tk.Tk()\n    window.wm_title(\"Python GIS\")\n    try: # windows and mac\n        window.wm_state('zoomed')\n    except: # linux\n        window.wm_attributes(\"-zoomed\", \"1\")\n    # pack in the GUI frame\n    gui = GUI(window)\n    gui.place(relwidth=1, relheight=1)\n\n    # open the window\n    window.mainloop()\n```", "```py\nfrom .builder import run\n```", "```py\nimport pythongis as pg\npg.app.run()\n```"]