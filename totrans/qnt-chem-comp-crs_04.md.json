["```py\npip install numpy\n```", "```py\npip install qiskit\n```", "```py\npip install 'qiskit[visualization]'\n```", "```py\npip install qiskit-nature\n```", "```py\npip install pyscf\n```", "```py\nimport numpy as np\n```", "```py\nimport matplotlib.pyplot as plt\n```", "```py\nfrom qiskit.visualization import array_to_latex, plot_bloch_vector, plot_bloch_multivector, plot_state_qsphere, plot_state_city\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile\nfrom qiskit import execute, Aer\nimport qiskit.quantum_info as qi\nfrom qiskit.extensions import Initialize\nfrom qiskit.providers.aer import extensions  # import aer snapshot instructions\n```", "```py\nfrom qiskit import Aer\nfrom qiskit_nature.drivers import UnitsType, Molecule\nfrom qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver\nfrom qiskit_nature.problems.second_quantization import ElectronicStructureProblem\nfrom qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper, BravyiKitaevMapper\nfrom qiskit_nature.converters.second_quantization import QubitConverter\nfrom qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer, FreezeCoreTransformer\nfrom qiskit_nature.operators.second_quantization import FermionicOp\n```", "```py\nfrom qiskit_nature.properties import Property, GroupedProperty\n```", "```py\n# https://qiskit.org/documentation/nature/tutorials/08_property_framework.html\nfrom qiskit_nature.properties.second_quantization.electronic import (\n    ElectronicEnergy,\n    ElectronicDipoleMoment,\n    ParticleNumber,\n    AngularMomentum,\n    Magnetization,\n)\n```", "```py\nfrom qiskit_nature.properties.second_quantization.electronic.integrals import (\n    ElectronicIntegrals,\n    OneBodyElectronicIntegrals,\n    TwoBodyElectronicIntegrals,\n    IntegralProperty,\n)\nfrom qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis\n```", "```py\nimport cmath\nimport math\n```", "```py\nx = np.linspace(-5,5,num=1000)\nr = abs(x)\nalpha = 1.0\nR = 2*alpha**(1.5)*np.exp(-alpha*r)\nplt.figure(figsize=(4,3))\nplt.plot(x,R,label=\"STO 1s H\")\nplt.legend()\n```", "```py\nx = np.linspace(-7,7,num=1000)\nr1 = abs(x+2.5)\nr2 = abs(x-2.5)\nalpha = 1.0\nR = 2*alpha**(1.5)*np.exp(-alpha*r1)-2*alpha**(1.5)*np.exp(-alpha*r2)\nplt.figure(figsize=(4,3))\nplt.plot(x,R,label=\"Antisymmetric STO H2\")\nplt.legend()\n```", "```py\nx = np.linspace(-7,7,num=1000)\nr = abs(x)\nc = [0.444635,0.535328,0.154329]\nalpha = [0.109818,0.405771,2.227660]\npsi = 0\nfor k in range(3):\n  psi += c[k]*(2*alpha[k]/np.pi)**0.75 * np.exp(-alpha[k]*r**2)\nplt.figure(figsize=(5,3))\nplt.plot(x,psi,label=\"STO-3G 1s H\")\nplt.legend()\n```", "```py\nx = np.linspace(-7,7,num=1000)\nr1 = abs(x+2.5)\nr2 = abs(x-2.5)\nc = [0.444635,0.535328,0.154329]\nalpha = [0.109818,0.405771,2.227660]\npsi = 0\nfor k in range(3):\n  psi += c[k]*(2*alpha[k]/np.pi)**0.75 * np.exp(-alpha[k]*r1**2) \\\n  - c[k]*(2*alpha[k]/np.pi)**0.75 * np.exp(-alpha[k]*r2**2)\nplt.figure(figsize=(5,3))\nplt.plot(x,psi,label=\"Antisymmetric STO-3G H2\")\nplt.legend()\n```", "```py\nhydrogen_molecule = Molecule(geometry=[['H', [0., 0., 0.]],\n                              ['H', [0., 0., 0.735]]],\n                     charge=0, multiplicity=1)\n```", "```py\ndriver = ElectronicStructureMoleculeDriver(hydrogen_molecule, basis='sto3g', driver_type=ElectronicStructureDriverType.PYSCF)\n```", "```py\nqH2 = driver.run()\n```", "```py\nH2_fermionic_hamiltonian = ElectronicStructureProblem(driver)\n```", "```py\nH2_second_q_op = H2_fermionic_hamiltonian.second_q_ops()\n```", "```py\ndef get_particle_number(problem, show=True):\n  particle_number = problem.grouped_property_transformed.get_property(\"ParticleNumber\")\n  num_particles = (particle_number.num_alpha, particle_number.num_beta)\n  num_spin_orbitals = particle_number.num_spin_orbitals\n  if show:\n    print(\"Number of alpha electrons: {}\".format(particle_number.num_alpha))\n    print(\"Number of beta electrons: {}\".format(particle_number.num_beta))\n    print(\"Number of spin orbitals: {}\".format(num_spin_orbitals))\n  return particle_number\n```", "```py\nprint(\"Hydrogen molecule, basis: sto3g, Hartree-Fock calculation\")\nH2_particle_number = get_particle_number(H2_fermionic_hamiltonian)\n```", "```py\ndef get_electronic_energy(problem, show=True):\n  electronic_energy = problem.grouped_property_transformed.get_property(\"ElectronicEnergy\")\n  if show:\n    print(electronic_energy)\n  return electronic_energy\n```", "```py\nH2_electronic_energy = get_electronic_energy(H2_fermionic_hamiltonian)\n```", "```py\n# Set truncation to None\nH2_second_q_op[0].set_truncation(0)\n# Print the Fermionic operator\nprint(\"Hydrogen molecule\")\nprint(H2_second_q_op[0])\n```", "```py\nprint(H2_second_q_op[0].to_matrix())\n```", "```py\nLiH_molecule = Molecule(geometry=[['Li', [0., 0., 0.]],\n                              ['H', [0., 0., 1.5474]]],\n                     charge=0, multiplicity=1)\n```", "```py\ndriver = ElectronicStructureMoleculeDriver(LiH_molecule, basis='sto3g', driver_type=ElectronicStructureDriverType.PYSCF)\n```", "```py\nLiH_fermionic_hamiltonian = ElectronicStructureProblem(driver, transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])])\n```", "```py\nLiH_second_q_op = LiH_fermionic_hamiltonian.second_q_ops()\n```", "```py\nprint(\"Lithium hydride molecule, basis: sto3g, Hartree-Fock calculation\")\nprint(\"Parameters freeze_core=True, remove_orbitals=[4, 3]\")\nLiH_particle_number = get_particle_number(LiH_fermionic_hamiltonian)\n```", "```py\nLiH_electronic_energy = get_electronic_energy(LiH_fermionic_hamiltonian)\n```", "```py\n# Set truncation to 1000\nLiH_second_q_op[0].set_truncation(1000)\n# Print the Fermionic operator\nprint(\"Lithium hydride molecule\")\nprint(LiH_second_q_op[0])\n```", "```py\nprint(LiH_second_q_op[0].to_matrix())\n```", "```py\ndef label_to_qubit(label, converter):\n    qubit_converter = QubitConverter(converter)\n    f_op = FermionicOp(label)\n    qubit_op = qubit_converter.convert(f_op)\n    return qubit_op\n```", "```py\nfor k in (\"+_0\", \"+_1\", \"+_2\", \"+_3\", \"+_4\"):\n  qubit_op = label_to_qubit(k, JordanWignerMapper())\n  print(\"{}:\\n {}\\n\".format(k, qubit_op))\n```", "```py\nfor k in (\"+_0\", \"+_1\", \"+_2\", \"+_3\", \"+_4\"):\n  qubit_op = label_to_qubit(k, ParityMapper())\n  print(\"{}:\\n {}\\n\".format(k, qubit_op))\n```", "```py\ndef BK(m):\n  I = [[1, 0], [0, 1]]\n  d = {}\n  d[0] = [1]\n  for k in range(0, m):\n    B = np.kron(I,d[k])\n    for l in range(2**k, 2**(k+1)):\n      B[0,l] = 1\n    d[k+1] = B\n  return d\n```", "```py\nd = BK(3)\nfor k, v in d.items():\n  s = \"B_{\"+str(2**k)+\"} = \"\n  display(array_to_latex(v, prefix=s, precision = 0))\n  print(\" \")\n```", "```py\nfor k in (\"+_0\", \"+_1\", \"+_2\", \"+_3\", \"+_4\"):\n  qubit_op = label_to_qubit(k, BravyiKitaevMapper())\n  print(\"{}:\\n {}\\n\".format(k, qubit_op))\n```", "```py\ndef fermion_to_qubit(f_op, second_q_op, mapper, truncate=20, two_qubit_reduction=False, z2symmetry_reduction=None, show=True): \n  if show:\n    print(\"Qubit Hamiltonian operator\")\n  dmap = {\"Jordan-Wigner\": JordanWignerMapper(), \"Parity\": ParityMapper(), \"Bravyi-Kitaev\": BravyiKitaevMapper()}\n  qubit_op = None\n  qubit_converter = None\n  for k, v in dmap.items():\n    if k == mapper:\n      if show:\n        print(\"{} transformation \". format(mapper))\n      qubit_converter = QubitConverter(v, two_qubit_reduction=two_qubit_reduction, z2symmetry_reduction=z2symmetry_reduction)\n      if two_qubit_reduction:\n        qubit_op = qubit_converter.convert(second_q_op[0], num_particles=f_op.num_particles)\n      else:\n        qubit_op = qubit_converter.convert(second_q_op[0])\n      n_items = len(qubit_op)\n      if show:\n        print(\"Number of items in the Pauli list:\", n_items)\n        if n_items <= truncate:\n          print(qubit_op)\n        else:\n          print(qubit_op[0:truncate])\n  return qubit_op, qubit_converter\n```", "```py\nprint(\"Hydrogen molecule\")\nH2_qubit_op, qubit_converter = fermion_to_qubit(H2_fermionic_hamiltonian, H2_second_q_op, \"Jordan-Wigner\", two_qubit_reduction=True)\n```", "```py\nprint(\"Hydrogen molecule\")\nH2_qubit_op, qubit_converter = fermion_to_qubit(H2_fermionic_hamiltonian, H2_second_q_op, \"Parity\", two_qubit_reduction=True)\n```", "```py\nprint(\"Hydrogen molecule\")\nH2_qubit_op, qubit_converter = fermion_to_qubit(H2_fermionic_hamiltonian, H2_second_q_op, \"Bravyi-Kitaev\", two_qubit_reduction=True)\n```", "```py\nprint(\"Lithium hydride molecule\")\nprint(\"Using the ParityMapper with two_qubit_reduction=True to eliminate two qubits\")\nprint(\"Setting z2symmetry_reduction=\\\"auto\\\"\")\nLiH_qubit_op, qubit_converter = fermion_to_qubit(LiH_fermionic_hamiltonian, LiH_second_q_op, \"Parity\", two_qubit_reduction=True, z2symmetry_reduction=\"auto\")\n```"]