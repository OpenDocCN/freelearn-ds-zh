- en: Chapter 5. Answering Questions with Density Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to work with large and dense datasets in which there is a lot
    of overplotting and features experience significant overlap. Such datasets may
    be very slow at rendering because they contain thousands, or even millions, of
    features, and very difficult to interpret because overlaps make it difficult to
    detect any clusters or distribution patterns. In this chapter, you will learn
    the techniques that allow you to visualize such datasets in a more readable and
    faster way by displaying feature density instead of the features themselves. By
    the end of this chapter, you will be able to perform density analysis of your
    data and extract information from density maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Density analysis and heat maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating heat maps with the Heatmap plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping density with a hexagonal grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Density analysis and heatmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Density maps allow visual estimation of object or event concentration over the
    study area. Such maps are very useful for assessment of the distribution patterns
    of the features over the study area. When we simply add locations of the features
    or events (for example, as points) to the map, we cannot see the changes in their
    concentration in different areas. Density analysis gives us such functionality
    by using uniform area characteristics, such as feature count per acre or square
    kilometer.
  prefs: []
  type: TYPE_NORMAL
- en: A density map gives us the ability to estimate the concentration of some features
    within an area. This helps us find areas where an urgent reaction is required
    or which match your criteria. Heatmaps also help control conditions and their
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Density maps are also extremely useful when mapped regions (for example, districts)
    have different sizes. For example, if we want to know how many people live in
    each district, we just need an ordinal map with the population data. According
    to this map, a large district may have a higher population than a smaller district.
    But if we want to identify the districts with a higher concentration of population,
    then we need a density map to see the number of people per square kilometer. And
    a density map will show us that, in fact, small regions with a high population
    density may have more people per square kilometer than larger districts.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we can show on a map the density distributions of the features themselves
    (for example, schools), as well as distributions of some numerical characteristics
    of these features (for example, the number of pupils in schools). The results
    will be completely different in these cases. A density map of schools can help
    an education department find areas where more schools are needed, while a density
    map created from information about the number of pupils in each school may help
    a transportation company to plan bus routes and to decide where to place bus stops.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case is the creation of density maps to display the density
    of point features. Such maps are often called **heat maps**. What is a heat map?
    It is a raster layer. Each cell of it contains a representation of the density
    of features in its vicinity (for example, the number of people per square kilometer),
    which depends on the number of features within some area.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a heat map, in the simplest case, GIS looks at the features around
    a cell center, using a given search radius. Then the number of features that fall
    within the given radius is calculated and divided by the area of the region. This
    value will be a cell value. Then next cell will be analyzed, and so on. As a result,
    we will get a combination of values, which creates a smooth surface. To understand
    this better, refer to the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Density analysis and heatmaps](img/image00420.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram shows the general principle of creating heat maps. The green dots
    depict the features used for density map generation, the blue square is a current
    raster cell, and the red dotted circle marks the search radius, for example, 1
    km. In this case, the area covered will be about 3.14 sq. km. As we can see in
    the diagram to the left, four features are within the search radius. So, the raster
    cell will get a value of *4/3.14 = 1.27*. On the right side, we notice that the
    next cell will get a value of 1.59 because now there are five features inside
    the search radius.
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest approach. In real-world applications, more complex algorithms
    are used, where each point has some impact on the values of the neighboring cells,
    depending on its distance from those cells.
  prefs: []
  type: TYPE_NORMAL
- en: Creating heat maps with the Heatmap plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of the QGIS core plugin called Heatmap, we can easily create heat
    maps from vector point data and use it for further analysis. First, we need to
    activate this plugin, if it has not yet been activated. After activation, it creates
    a submenu under the **Raster** menu and places its button on the **Raster** toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a density map for the `noise` layer, which contains information
    about complaints regarding high noise levels. This layer contains 44,397 features,
    and it is difficult to know which places are noisy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about such places may be useful for a police department or other
    agencies to plan some activities for noise reduction, or for those who are looking
    for apartments and don''t want neighbors who like playing loud music:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the plugin by clicking on the **Heatmap** button on the **Raster** panel,
    or by navigating to **Raster** | **Heatmap** | **Heatmap...**.![Creating heat
    maps with the Heatmap plugin](img/image00421.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `noise` layer from the **Input point layer** combobox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **…** button on the right side of the **Output raster** field, specify
    the location in which the resulting heat map needs to be saved. Note that there
    is no need to specify the file extension; it will be picked up automatically,
    based on the output file format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Output format** combobox to select the desired format for the heat
    map. The most common choice here is **GeoTIFF**, but for very large maps, it is
    better to use something different, for example, **Erdas Imagine**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to specify is **Radius**. This value defines the distance
    from each cell up to which QGIS will look for neighbor features and take their
    presence into account. Generally, a bigger search radius gives a more generalized
    result, as the number of features found will be divided by a bigger area. A smaller
    radius gives more precise results, but if this value is too small, we may not
    find any distribution patterns. The search radius can be defined in meters or
    map units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To determine the search radius from a known area, we can use a very simple
    formula derived from formula for the area of a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00422.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, if we need to calculate density per square kilometer, then the
    search radius will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00423.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For more fine-grained control over the result, we can check the **Advanced**
    box and define some additional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rows** and **Columns**: These allow us to define dimensions of the output
    raster. Larger dimensions will result in a bigger output file size, while smaller
    dimensions will result in a rough and pixelated output. Input fields are linked
    to each other, so changing the value in the **Rows** field (for example, halving
    it) will also cause the corresponding change to the value in the **Columns** field,
    and vice versa. Furthermore, these values have a direct influence on the raster
    cell size (see the next point). It is worth mentioning that the extent of the
    raster preserved when changing raster dimensions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cell size X** and **Cell size Y**: The raster cell size determines how coarse
    or detailed the display of the distribution patterns will be. A smaller cell size
    will give smoother results, but the processing time and memory required for the
    analysis will increase. Large cells will be processed faster, but the resulting
    raster will be pixelated. If the cells are really big, some patterns will become
    invisible, so you may need to run the analysis several times, trying different
    cell sizes to get results that satisfy your requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cell size depends on and is linked to the raster dimensions. Increasing
    it will decrease the number of rows and columns, and vice versa.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Kernel shape**: This controls how the point influence changes with changes
    in distance from this point. The QGIS Heatmap plugin currently supports the following
    kernels:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: quartic (also known as biweight)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: triangular
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uniform
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: triweight
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Epanechnikov
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the distribution of the point influence for different
    kernels:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00424.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details about kernel shapes, refer to the Wikipedia article at [http://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use](http://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use),
    and books about statistics, for example, *Density Estimation for Statistics* and
    *Data Analysis* by B. W. Silverman.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the kernel shape, we will get a smoother heat map, or more clearly
    exposed hotspots. For example, the triweight kernel will give clearer, sharper
    hotspots than the Epanechnikov kernel, because the Epanechnikov kernel has lower
    influence near the hotspot center. Also, in different scientific fields, different
    kernels are preferred; for example, in crime analysis, the quartic kernel is typically
    used.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use a variable search radius for each point by selecting
    the **Use radius from field** checkbox and selecting the attribute field with
    radius value from the combobox. If you need to weight points (in other words,
    increase or decrease their influence) by some numeric attribute, activate the
    **Use weight from field** checkbox and select the corresponding field. In our
    example, we will not use this functionality, but you can try it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: As we said before, cell size has a direct influence on the quality of the resulting
    heat map, so it is important to select it carefully. In most cases, the cell size
    is chosen in such a way that we get 10 to 100 cells per unit area (which in turn
    is defined by the search radius). To calculate the cell size, we need to align
    area units with distance units; for example, if we calculate the density using
    square kilometers and define the search radius in meters, then it is necessary
    to convert the square kilometers to square meters. The next step is to divide
    the area by the desired number of cells. Finally, as the cell size is defined
    by its width or height (because raster cells usually have a square shape), we
    need to extract the square root of this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will create a heat map with a search radius of 1000 m, so
    the lookup area will be approximately 3.14 square kilometers. When expressed in
    meters, this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00425.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we want a smooth heat map, we will use a relatively large number of cells
    per unit area; let''s say 100 cells per 3.14 square kilometers. So, we divide
    the area in square meters by the desired cell count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00426.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we calculate the square root of this value to get the cell size that
    allows us to have 100 cells per 3.14 square kilometers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00427.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course this is not a strict rule but just a recommendation. You can safely
    use another cell size, depending on your data and the desired results. Just remember
    that smaller values lead to smoother heat maps, but at the same time increase
    the analysis time and output raster size.
  prefs: []
  type: TYPE_NORMAL
- en: When all the inputs and parameters are set, press the **OK** button to start
    the process of the heat map generation. The progress of the heat map formation
    will be displayed in a small progress dialog. If this process is taking too long
    time to complete, you can interrupt it by pressing the **Abort** button. Note
    that after aborting heat map generation, you still get the output, but it will
    be incomplete and not useful for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the process completes, the generated heat map will be added to QGIS as
    a grayscale raster, where lighter regions correspond to higher density values
    and darker regions correspond to lower density values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00428.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To improve readability and make it look like real heat map, we need to change
    its style. To do this, follow the next steps. For more detailed information about
    styling raster layers, refer to the *Developing styles for raster layers* section
    of [Chapter 2](part0021.xhtml#aid-K0RQ1 "Chapter 2. Visualizing and Styling the
    Data"), *Visualizing and Styling the Data*:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `heatmap` layer in the QGIS layer tree. In the context menu,
    select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Style** tab and select **Singleband pseudocolor** as **Render type**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Load min/max values** group, activate the **Min/max** options. Set
    **Extent** to **Full** and **Accuracy** to **Actual (slower)**. Press the **Load**
    button to get raster statistics. This will be used for further classification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a suitable color ramp in the **Generate new color map** group, for example,
    `YlOrBr` (which changes colors from yellow to orange and then brown), or `Reds`
    (which uses different shades of red). If necessary, change the number of classes
    and click on the **Classify** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to apply the changes and close the properties dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can easily locate the hottest points (displayed in colors closer to
    red if the `Reds` color map is used), and even recognize some distribution patterns
    that were not visible when we looked at the original point layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating heat maps with the Heatmap plugin](img/image00429.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can easily locate the hottest points (displayed in colors closer to red
    if the `Reds` color map is used), and even recognize some distribution patterns
    that were not visible when we looked at the original point layer. Also, our heatmap
    layer showed up much faster than the vector which is used to create this heat
    map.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the "hottest" regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you don't need the heat map itself, but just want to find the hotspots—areas
    with the highest density—and use them in further analysis. It is pretty easy to
    find such regions in QGIS and extract them in the vector form.
  prefs: []
  type: TYPE_NORMAL
- en: First, we should define threshold value, which will be used to recognize the
    hotspots. As a starting value, we can use the maximum pixel value in our heat
    map and then adjust it as per our needs.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to find the maximum pixel value is to use the **Identify Features**
    tool. Select a layer in the QGIS layer tree, activate the **Identify Features**
    tool, click on the most visually "hottest" regions, and look at the reported value.
    With our heat map, this will be `540.32`.
  prefs: []
  type: TYPE_NORMAL
- en: If we will use this value as is, we cannot find all the important clusters,
    so this value should be reduced first. The smaller the selected value (in comparison
    with the maximum value), the larger the number of clusters found. The area of
    separate clusters will also grow. For our example, we choose a value of `200`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open **Raster Calculator** from the **Raster** menu, specify a path where
    the output file should be saved in the **Output layer** field, and enter the `"heatmap@1">=200`
    formula in the **Raster calculator expression** field, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the "hottest" regions](img/image00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This formula is used to create a so-called mask. If the pixel value of the input
    layer is greater or equal to our threshold value of `200`, then the output pixel
    value will be `1`. Otherwise, it will be `0`. So, our output raster will be a
    binary raster, with only two pixel values—`0` and `1`—which is very easy to convert
    to a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave all other values unchanged so that the resulting raster will have exactly
    the same dimensions and cell size as the input one. Press the **OK** button to
    start the calculation. When it is done, a new black-and-white raster layer will
    be added to the QGIS canvas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the "hottest" regions](img/image00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To convert the mask raster into vector format, we need to create polygons from
    all connected pixels with the same value. This is where the **Polygonize** tool
    comes to help. In the **Processing** toolbox, you can find the **Polygonize**
    algorithm by typing its name in the filter field at the top of the toolbox. Double-click
    on the algorithm name to open its dialog, and you will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the "hottest" regions](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select the mask layer that was previously created as **Input layer**, specify
    the path where the result will be saved using the **Output layer** field, and
    click on the **Run** button to start the algorithm. When it is done, a new vector
    layer will be added to QGIS. This layer has an attribute called `DN` (if you did
    not change it) that indicates the pixel value of each polygon in the layer. So,
    all we need to do is remove all the features that have the attribute value equal
    to zero. The remaining features will be the hotspots.
  prefs: []
  type: TYPE_NORMAL
- en: To delete unnecessary features from the hotspots layer, select it in the QGIS
    layer tree, right-click to open the context menu, and select **Open Attribute
    Table**. Click on the **Select features using an expression** button. In the **Select
    by expression** dialog, enter `"DN" = 0` (if necessary, replace `DN` with your
    field name), click on the **Select** button, and close the dialog. Start editing
    by clicking on the **Toggle editing mode** button, or press *Ctrl* + *E*. To remove
    the selected features, press the *Delete* key or click on **Delete selected features**.
    Finally, turn editing mode off by pressing *Ctrl* + *E* or clicking on **Toggle
    editing mode** again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting the "hottest" regions](img/image00433.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, the hotspots layer contains only hotspot polygons, which can be used for
    further analysis. For example, we can combine this cluster with information about
    the nearest buildings and noise types to find dependencies and develop some suggestions
    for reducing the noise levels there.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for distribution patterns with contour lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from detecting hotspots, heat maps can also be used to detect intensity
    changes or visualize the direction of value changes. The most common way to do
    both of these tasks is contour lines generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, QGIS has all the necessary tools for this. We will use processing
    again, but contour lines generation is also available in the **GDALTools** plugin
    (which can be found in the **Raster** menu). In the **Processing** toolbox, you
    can find the **Contour** algorithm by typing its name in the filter field at the
    top of the toolbox. Double-click on the algorithm name to open its dialog, which
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for distribution patterns with contour lines](img/image00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select the `heatmap` raster layer as **Input layer**. In the **Output file**
    field, specify the path where the results will be saved. Also, it is necessary
    to define **Interval between contour lines**. There are no strict principles about
    determining this interval. The general rule is to select such an interval that
    detects patterns in the areas with smooth density changes. We will select an interval
    of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: When all of the necessary information has been defined, click on **Run** to
    start the contour line generation. After some time, a new polygonal vector layer
    will be added to QGIS, and we can start analyzing it. First, if necessary, move
    the contours layer to the top of the heat map in the QGIS layer tree. Also, it
    is better to adjust contours' symbology to make them more recognizable against
    the background of the heat map.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for distribution patterns with contour lines](img/image00435.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: More dense contours correspond to more intense density changes. Also, we can
    identify the direction of changes in noise. For example, in the preceding screenshot,
    we can see that in some places, the noise distribution around the center is not
    equal; the intensity reduces more quickly in the southeast than in the northwest.
    So, we may assume that there are some obstacles to noise there.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping density with a hexagonal grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also another approach of mapping density, called binning. Generally
    speaking, binning is a technique of grouping *N* values/features into *M* groups,
    where *M < N*. The result of such an operation can be interpreted as a two-dimensional
    histogram.
  prefs: []
  type: TYPE_NORMAL
- en: Binning is an alternative to heat maps, not a replacement. The choice of the
    method depends on the requirements and further usage of the results. It is, however,
    worth mentioning that binning produces a vector output, while a heat map produces
    a raster output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, binning can be described in two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a hexagonal grid on top of the point layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count the number of points in each grid cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you will learn how to use this technique in QGIS in the example
    of hexbinning, in other words, mapping density with a hexagonal grid.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, for binning, we can use not only hexagons but also other shapes that
    allow regular tessellation of a 2D surface—triangles and rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we choose hexagons? Well, because a hexagon is closest to a circle among
    all shapes that tessellate. As a result, they represent curves more naturally.
    Another advantage of hexagons is a more compact structure, so the distance between
    cell centers in a hexagonal grid is lower than in a rectangular grid. So data
    aggregation around the cell center is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating Analysis with
    Processing Models"), *Automating Analysis with Processing Models*, we will create
    a model that produces two density maps: hexagonal and rectangular, so that you
    can compare them side by side and better understand their differences and use
    cases.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will create a density map using this approach.
    For this exercise, we will use data from Brooklyn's street tree census. This is
    the `trees` layer in our map.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hexagonal grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a hexagonal grid, we will use the QGIS Processing framework and its
    algorithm called **Create grid**:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Processing** toolbox, find the **Create grid** algorithm by typing
    its name in the filter field at the top of the toolbox. Double-click on the algorithm
    name to open its dialog, which looks like this:![Creating a hexagonal grid](img/image00436.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Grid type** combobox, select **Hexagon (polygon)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To specify grid extent press the **…** button on the right side of the **Grid
    extent** field and choose **Use layer/canvas extent** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Select extent** dialog will pop up. Use it to select the `trees` layer
    from the combobox, and click on **OK**. The coordinates of the `layer` extent
    will be added to the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `1000` as the horizontal and vertical spacing. These values have the same
    meaning as the search radius in the case of heat maps. Grid spacing determines
    how many cells will be in a grid and how smooth the resulting map will be. A smaller
    spacing produces smoother results, but very small values prevent us from identifying
    any distribution patterns. Note that the spacing should be specified in the same
    units as used by layer; for example, if a layer CRS uses feet as units, then the
    spacing should be in feet too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the **Output** field, specify the path where the resulting grid
    will be saved and click on **Run** to create the grid. When the algorithm execution
    completes, a new polygonal layer will be added to QGIS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Counting points in grid cells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To calculate the number of features inside each grid cell, we can use fTools
    or Processing core plugins. The latter is more flexible and allows us to automate
    tasks, as described in [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating
    Analysis with Processing Models"), *Automating Analysis with Processing Models*.
    We will use the **Count points in polygon** algorithm from the Processing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a **Count unique points** algorithm in Processing that lets us
    count only points with unique attributes in the selected field. This may be useful
    when a more precise analysis is needed, for example, for mapping diversity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Processing toolbox, find the **Count points in polygon** algorithm by
    typing its name in filter field at the top of the toolbox. Double-click on the
    algorithm name to open its dialog, and you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting points in grid cells](img/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select the grid layer created in the previous section as **Polygons** and the
    `trees` layer as **Points**. Enter **Count field name** or leave it unchanged.
    Don't forget the 10-character limitation for the shapefile field names! Finally,
    in the **Result** field, specify the location where the resulting layer will be
    stored, and click on the **Run** button to start the analysis. Keep in mind that
    this may take some time, as the `tree` layer contains many features and the grid
    size is relatively small.
  prefs: []
  type: TYPE_NORMAL
- en: When an algorithm execution completes, a new grid layer, containing the field
    with the number of points in each cell, will be added to QGIS. We can safely remove
    the original grid layer from QGIS and from the filesystem, as it is no longer
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For better visual representation of our data, we apply a graduated renderer
    to style cells according to the number of features in them. If necessary, go back
    to the *Developing styles for vector layers* section of [Chapter 2](part0021.xhtml#aid-K0RQ1
    "Chapter 2. Visualizing and Styling the Data"), *Visualizing and Styling the Data*.
    The result may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Counting points in grid cells](img/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Removing redundant data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look carefully at our grid layer and its attribute table, we will see
    that some grid cells are empty; there are no points in them. Such cells displayed
    with a very light green color in the preceding screenshot. It is clear that the
    empty cells are much more than the nonempty cells. Of course, we can simply hide
    such empty cells by assigning to them the same color as the map background, or
    by removing them from the renderer (assigning an empty style). But, is it better
    to remove them completely and reduce the file size?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two possible ways to remove empty cells: manually or by using one
    of the existing tools from the Processing toolbox. Each method has own advantages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will learn how to remove redundant data manually. This method can
    be used when you need to process only one layer and don''t want to create any
    temporary intermediate files. Also, it allows you to easily examine the features
    that will be removed. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `LAYER` layer from the QGIS layer tree. Then, click on the **Select
    features using an expression** button in the **Attributes** toolbar to open the
    **Select by expression** dialog.![Removing redundant data](img/image00439.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the functions tree, under the **Fields and Values** group, find the `NUMPOINTS`
    field and double-click on it to add its name to the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click on **=** to add the equal to operator to the expression, and type
    `0` after it. The final expression will look like **"NUMPOINTS" = 0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Select** to select all the features that match your condition. The
    selected features will be highlighted in yellow so that you can check whether
    they are what you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, close the **Select by expression** dialog and open the layer attribute
    table by clicking on the **Open Attribute Table** button in the **Attributes**
    toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle editing mode by clicking on the corresponding button in the attribute
    table dialog, or by simply pressing *Ctrl* + *E*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To remove the selected features, just press the *Delete* key or click on the
    **Delete selected features** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, turn editing mode off by pressing *Ctrl* + *E* again. Now our layer
    contains only nonempty cells and is much smaller in size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting redundant data with Processing requires fewer steps than removing redundant
    data manually, but instead of updating the existing layer, it creates another
    file. The Processing framework is useful when you need to process many layers
    at once or want to automate some operations. To remove empty cells, we can use
    the **Extract by attribute** algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our case, the comparison condition is very simple, so we use the **Extract
    by attribute** algorithm. When a more complex comparison condition that includes
    several attributes or some calculations is needed, it is better to use the **Select
    by expression** algorithm in combination with **Save selected features**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing redundant data](img/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the necessary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the **Extract by attribute** algorithm by typing its name in the filter
    field, and double-click on its name to open its dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Input layer** combobox, select `LAYER`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Selection attribute** combobox, select the `NUMPOINTS` field, which
    stores the point count in each cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Operator** combobox select the not equal operator !`=`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `0` in the **Value** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the name of the output file in the **Output** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can press the **Run** button to start processing. When it is done, the
    new layer, with empty cells removed, will be added to QGIS, and we can remove
    the original layer. The new layer is much smaller, but still contains all of the
    information. Also, we can now set up styles more precisely and identify some distribution
    patterns that were not visible earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing redundant data](img/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we overlay a layer that has a street network with this density map, we can
    easily identify that the greenest street is the Ocean Parkway.
  prefs: []
  type: TYPE_NORMAL
- en: The result looks great, but performing all of these steps manually is not very
    comfortable. Also, there are a number of intermediate layers that can, and should,
    be removed. Fortunately, QGIS allows us to automate such operations with the Processing
    Graphical Modeler. Refer to [Chapter 8](part0062.xhtml#aid-1R42S1 "Chapter 8. Automating
    Analysis with Processing Models"), *Automating Analysis with Processing Models*,
    to learn how to create models and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the analysis of dense-point datasets. You learned
    how to create raster heat maps with the help of the QGIS Heatmap plugin. Then,
    we covered analysis of heat maps and data extraction from them.
  prefs: []
  type: TYPE_NORMAL
- en: You also familiarized yourself with an alternative and popular technique for
    displaying dense datasets, called binning, and you learned how to perform hexbinning
    (a kind of binning technique) in QGIS using the Processing framework.
  prefs: []
  type: TYPE_NORMAL
