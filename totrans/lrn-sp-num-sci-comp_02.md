# 第二章。使用 NumPy 数组作为 SciPy 的第一步

在顶层，SciPy 基本上是 NumPy，因为这两个对象创建和基本操作都是由后者的函数执行的。这保证了计算速度更快，因为内存处理是在内部以最佳方式进行的。例如，如果必须在大型多维数组的元素上执行操作，一个新手用户可能会被诱惑使用尽可能多的 for 循环来遍历列和行。当循环以与它们在内存中存储的相同顺序访问每个连续元素时，循环运行得更快。在编码时，我们不应该被这类考虑所困扰。NumPy/SciPy 操作确保了这一点。作为一个额外的优势，NumPy/SciPy 中操作的名字直观且易于理解。以这种方式编写的代码非常容易理解和维护，在需要时更快地纠正或更改。

让我们用一个入门示例来说明这一点。

SciPy 包中的`scipy.misc`模块包含一个经典图像`lena`，该图像在图像处理社区中被用于测试和比较目的。这是一个 512 x 512 像素的标准测试图像，自 1973 年以来一直被使用，最初是从 1972 年 11 月《花花公子》杂志的封底裁剪而来。这是一张由摄影师 Dwight Hooker 拍摄的瑞典模特 Lena Söderberg 的照片。这张图像可能是所有各种图像处理算法（如压缩和降噪）和相关科学出版物中最广泛使用的测试图像。

这张图像存储为一个二维数组。请注意，该数组第*n*列和*m*行的数字测量图像像素位置(*n+1*, *m+1*)的灰度值。在以下内容中，我们通过以下命令访问这张图片并将其存储在`img`变量中：

```py
>>> import scipy.misc
>>> img=scipy.misc.lena()
>>> import matplotlib.pyplot as plt 
>>> plt.gray() 
>>> plt.imshow(img) 

```

可以通过以下命令显示图像：

```py
>>> plt.show() 

```

![使用 NumPy 数组作为 SciPy 的第一步](img/7702OS_02_01.jpg)

我们可以查看一些这些值；比如说图像的 7 x 3 上角（7 列，3 行）。我们不必使用 for 循环，我们可以*切片*图像的相应部分。`img[0:3,0:7]`命令给出了以下内容：

```py
array([[162, 162, 162, 161, 162, 157, 163],
 [162, 162, 162, 161, 162, 157, 163],
 [162, 162, 162, 161, 162, 157, 163]])

```

我们可以使用相同的策略来填充数组或更改它们的值。例如，让我们将上一个数组的所有条目更改为在第二行第 2 到第 6 列之间持有零：

```py
>>> img[1,1:6]=0
>>> print (img[0:3,0:7])

```

输出如下所示：

```py
[[162 162 162 161 162 157 163]
 [162   0   0   0   0   0 163]
 [162 162 162 161 162 157 163]]

```

# 对象基础

我们已经介绍了 NumPy 的主要对象——同构的多维数组，也称为`ndarray`。数组的所有元素都被转换为相同的数据类型（同构）。我们通过`dtype`属性获得数据类型，通过`shape`属性获得其维度，通过`size`属性获得数组中的元素总数，通过引用它们的位位置来引用元素：

```py
>>> img.dtype, img.shape, img.size

```

输出如下所示：

```py
(dtype('int64'), (512, 512), 262144)

```

现在让我们计算灰度值：

```py
>>> img[32,67]

```

输出如下所示：

```py
87

```

让我们解释一下输出。`img`的元素是 64 位整数值（'int64'）。这可能会根据系统、Python 安装和计算机规格而变化。数组的形状（注意它以 Python 元组的形式出现）是 512 x 512，元素数量为 262144。图像在第 33 列和第 68 行的灰度值是`87`（请注意，在 NumPy 中，就像在 Python 或 C 中一样，所有索引都是从 0 开始的）。

现在我们将介绍 NumPy/SciPy 对象的基本属性和方法——数据类型和索引。

# 使用数据类型

强制数据类型的方法有多种。例如，如果我们想将已创建数组的所有条目都设置为 32 位浮点值，我们可以按照以下方式转换：

```py
>>> import scipy.misc
>>> img=scipy.misc.lena().astype('float32')

```

我们还可以通过命令使用可选参数`dtype`：

```py
>>> import numpy
>>> scores = numpy.array([101,103,84], dtype='float32')
>>> scores

```

输出如下所示：

```py
array([ 101.,  103.,   84.], dtype=float32)

```

这可以通过第三种巧妙的方法进一步简化（尽管这种做法提供的代码不易理解）：

```py
>>> scores = numpy.float32([101,103,84])
>>> scores

```

输出如下所示：

```py
array([ 101.,  103.,   84.], dtype=float32)

```

NumPy 数组的类型选择非常灵活；我们可以选择基本的 Python 类型（包括`bool`、`dict`、`list`、`set`、`tuple`、`str`和`unicode`），尽管在数值计算中我们专注于`int`、`float`、`long`和`complex`。

NumPy 有一组针对`ndarray`实例优化的数据类型，并且与之前给出的原生类型具有相同的精度。我们通过尾部下划线（`_`）来区分它们。例如，字符串的`ndarray`可以初始化如下：

```py
>>> a=numpy.array(['Cleese', 'Idle', 'Gilliam'], dtype='str_')
>>> a.dtype

```

输出如下所示（这取决于您的 Python 版本）：

```py
dtype('<U7')

```

注意两点；与它的纯 Python 对应物不同，使用`'str_'`数据类型需要将名称引号括起来；我们可以使用较长的未引号版本，即`numpy.str_`。

当系统提示数据类型时，它会返回其 C 派生的等效类型：`'<U7'`（`<U`表示字符串，`7`表示其元素的最大大小）。

最常见的处理数值类型的方法是使用位宽命名法：`boolXX`、`intXX`、`uintXX`、`floatXX`或`complexXX`，其中`XX`表示位大小（例如，`uint32`表示 32 位无符号整数）。

我们也可以设计自己的数据类型，这正是 NumPy 数据类型灵活性的全部潜力所在。例如，可以创建一个数据类型来表示学生的姓名和成绩，如下所示：

```py
>>> dt = numpy.dtype([ ('name', numpy.str_, 16), ('grades',numpy.float64, (2,)) ])
>>> dt 

```

输出如下所示（这取决于您的 Python 版本）：

```py
dtype([('name', '<U16'), ('grades', '<f8', (2,))])

```

这意味着`dt`数据类型有两个部分：第一部分是`name`，它必须是一个 16 个字符的`numpy.str_`字符串。第二部分是`grades`，它是一个维度为 2 的子数组，其中的分数是 64 位浮点值。具有此数据类型元素的数组将如下所示：

```py
>>> MA141=numpy.array([ ('Cleese', (7.0,8.0)), ('Gilliam',(9.0,10.0)) ], dtype=dt)
>>> MA141

```

输出如下所示（这取决于您的 Python 版本）：

```py
array([('Cleese', [7.0, 8.0]), ('Gilliam', [9.0, 10.0])],dtype=[('name', '<U16'), ('grades', '<f8', (2,))])

```

# 索引和切片数组

访问 NumPy 数组中的数据有两种基本方法；让我们称这个数组为`A`。两种方法都使用相同的语法，`A[obj]`，其中`obj`是一个 Python 对象，它执行选择。我们已经熟悉了访问单个元素的第一种方法。第二种方法是本节的主题，即**切片**。这个概念正是使 NumPy 和 SciPy 如此易于管理的根本原因。

基本切片方法是一个形式为`slice(start,stop,step)`的 Python 对象，或者在一个更紧凑的表示法中，`start:stop:step`。最初，三个变量`start`，`stop`和`step`是非负整数值，其中`start`小于或等于`stop`。

这表示索引序列*k = start + (i * step)*，其中*k*从`start`运行到最大的整数*k_max = start + step*int((stop-start)/step)*，或者*i*从`0`运行到最大的整数等于*int((stop - start) / step)*。当在`ndarray`的任何维度上调用切片方法时，它选择该维度中由相应索引序列索引的所有元素。下面的简单示例说明了这一点：

```py
>>> A=numpy.array([[1,2,3,4,5,6,7,8],[2,4,6,8,10,12,14,16]])
>>> print (A[0:2, 0:8:2])

```

输出如下所示：

```py
[[ 1  3  5  7]
 [ 2  6 10 14]]

```

如果`start`大于`stop`，则使用负值的`step`来反向遍历序列：

```py
>>> print (A[0:2, 8:0:-2])

```

输出如下所示：

```py
[[ 8,  6,  4,  2]
 [16, 12,  8,  4]]

```

`start`和`stop`的负值被解释为`n-start`和`n-stop`（分别），其中`n`是相应维度的尺寸。`A[0:2,-1:0:-2]`命令给出与前面示例完全相同的输出。

切片对象可以通过省略`start`（如果`step`为正，则表示零，如果`step`为负，则表示该维度的尺寸）来缩短，省略`stop`（在`step`为正的情况下，表示相应维度的尺寸，在`step`为负的情况下，表示零）。省略`step`意味着`step`等于 1。`::`对象可以简单地缩短为`:`，以便于语法。然后`A[:,::-2]`命令再次提供与前面两个相同的输出。

从数组中访问数据的第一个非基本方法基于收集多个索引并请求具有这些索引的数组元素的思路。例如，从我们之前的数组`A`中，我们希望构建一个新的数组，包含位置(0, 0)，(0, 3)，(1, 2)和(1, 5)的元素。我们通过收集索引的*x*和*y*值，分别在列表`[0,0,1,1]`和`[0,3,2,5]`中，并将这些列表作为索引对象传递给`A`，如下所示：

```py
>>> print (A[ [0,0,1,1], [0,3,2,5] ])

```

输出如下所示：

```py
[ 1  4  6 12]

```

注意结果丢失了原始数组的维度，并提供了一个一维数组。如果我们希望捕获`A`的子数组，其索引位于两个索引集的笛卡尔积中，尊重行和列的选择，并创建一个具有笛卡尔积维度的新数组，我们使用`ix_`命令。例如，如果我们想从之前的数组中获取维度为 2 x 2 的子数组，其索引位于索引（0, 1）和（0,3）的笛卡尔积中（这些位置是（0, 0）、（0, 3）、（1, 0）和（1, 3），我们可以这样做：

```py
>>> print (A[ numpy.ix_( [0,1], [0,3] )])

```

输出如下所示：

```py
[[1 4]
 [2 8]]

```

# 数组对象

在这一点上，我们已准备好对所有有趣的`ndarray`属性进行彻底研究，以用于科学计算目的。我们已经涵盖了几个，例如`dtype`、`shape`和`size`。其他有用的属性包括`ndim`（用于计算数组中的维度数量）、`real`和`imag`（如果数据由复数组成，则用于获取数据的实部和虚部）或`flat`（它从数据创建一个一维可索引迭代器）。

例如，如果我们想将数组中的所有值相加，我们可以使用`flat`属性按顺序遍历所有元素，并将所有值累积到一个变量中。执行此任务的可能的代码片段如下（将此代码与稍后解释的`ndarray.sum()`方法进行比较）：

```py
>>> value=0; import scipy.misc; img=scipy.misc.lena()
>>> for item in img.flat: value+=item
>>> value

```

输出如下所示：

```py
32518120

```

我们还将探索应用于数组的一些方法。这些是用于修改对象的工具；无论是它们的数据类型、形状还是通过转换的结构。这些方法可以分为三大类——**数组转换**、**形状选择/操作**和**对象计算**。

## 数组转换

`astype()`方法返回数组的副本，转换为特定类型；`copy`方法返回数组的副本。最后，`tofile()`、`tolist()`或`tostring()`方法将数组的二进制数据写入文件，返回相同数组的分层 Python 列表版本，或返回数组数据的字符串表示。

例如，要将`img`数组的内容写入文本文件，确保数组中的每个条目都按整数打印，并且每两个整数之间用空格分隔，我们可以发出以下命令：

```py
>>> img.tofile("lena.txt",sep=" ",format="%i")

```

注意格式化字符串遵循 C 语言约定。

## 形状选择/操作

这些方法不仅在我们需要重新排列（`swapaxes`和`transpose`）或排序（`argsort`和`sort`）数组时使用，而且在我们需要重塑（`reshape`）、调整大小（`flatten`、`ravel`、`resize`和`squeeze`）或选择（`choose`、`compress`、`diagonal`、`nonzero`、`searchsorted`和`take`）数组时也使用。请注意，当与切片操作结合使用时，这些方法非常强大；事实上，许多方法可以替代切片以提供更好的可读性。

我们需要谈谈`flat`、`ravel`和`flatten`这些属性，它们提供非常相似的结果，但在内存管理方面却大不相同。第一个属性`flat`创建一个数组迭代器。一旦使用，它就会从内存中消失。属性`ravel`返回一个一维展平的输入数组；只有在需要时才会创建副本。最后，`flatten`创建一个一维输入数组，并且总是为它分配内存。我们只在需要更改展平数组的值时使用它。我们将在以下代码片段中强调排序方法的力量。当对一个整数数组进行排序时，它们的索引顺序会是什么？我们可以使用`argsort()`方法获得这些信息。我们甚至可以指定要使用的排序算法（而不是自己编写代码）——`quicksort`、`mergesort`或`heapsort`。我们甚至可以使用`sort()`方法就地排序。让我们看一下以下一系列命令：

```py
>>> import numpy
>>> A = numpy.array([11,13,15,17,19,18,16,14,12,10])
>>> A.argsort(kind='mergesort')

```

输出如下所示：

```py
array([9, 0, 8, 1, 7, 2, 6, 3, 5, 4])

```

现在，我们应用`sort()`方法：

```py
>>> A.sort()
>>> print(A)

```

输出如下所示：

```py
[10 11 12 13 14 15 16 17 18 19]

```

## 对象计算

数组计算方法用于执行计算或从我们的数据中提取信息。Python 提供了一系列统计方法来计算，例如，数据的最大值和最小值（`max`和`min`），以及它们的对应索引方法（`argmax`和`argmin`）来计算总和、累计总和、乘积或累计乘积（`sum`、`cumsum`、`prod`和`cumprod`），以及计算我们的数据的平均值（`mean`）、点扩散（`ptp`）、方差（`var`）和标准差（`std`）。其他方法允许我们计算复数值数组的复共轭（`conj`）、数组的迹（`trace`，即对角线元素的总和），甚至可以通过强制设置低于和高于某些阈值的最低和最高值来剪切矩阵（`clip`）。

注意，这些方法中的大多数都可以作用于整个数组及其每个维度：

```py
>>> A=numpy.array([[1,1,1],[2,2,2],[3,3,3]])
>>> A.mean()

```

输出如下所示：

```py
2

```

现在，让我们使用`axis=0`应用`mean()`方法：

```py
>>> A.mean(axis=0)

```

输出如下所示：

```py
array([ 2.,  2.,  2.])

```

类似地，我们使用相同的命令并设置`axis=1`：

```py
>>> A.mean(axis=1)

```

输出如下：

```py
array([ 1.,  2.,  3.])

```

让我们也通过基于 Lena 图像的简单练习来说明`clip`命令。计算 Lena（`img`）的最大值和最小值，并将它们与点扩散（它应该等于这两个值之间的差）进行对比。现在，通过剪切 Lena 创建一个新的数组`A`，保持最小值不变，但将点扩散减少到仅 100 个值。让我们说明`min()`、`max()`和`ptp()`命令对 Lena（`img`）的影响：

```py
>>> img.min(), img.max(), img.ptp()

```

输出如下所示：

```py
(25, 245, 220)

```

此外，我们将在以下代码行中说明`clip()`命令对`img`的影响：

```py
>>> A=img.clip(img.min(),img.min()+100)
>>> A.min(), A.max(), A.ptp()

```

输出如下所示：

```py
(25, 125, 100)

```

# 数组例程

在本节中，我们将处理数组的大部分操作。我们将它们分为四个主要类别：

+   创建新数组的例程

+   操作单个数组的例程

+   结合两个或更多数组的例程

+   从数组中提取信息的例程

读者肯定会意识到，这类操作可以通过方法来实现，这再次显示了 Python 和 NumPy 的灵活性。

## 创建数组的例程

我们之前已经看到了创建数组并将其存储到变量`A`中的命令。让我们再次看看它：

```py
>>> A=numpy.array([[1,2],[2,1]])

```

然而，完整的语法如下所示：

```py
array(object,dtype=None,copy=True,order=None, subok=False,ndim=0)
```

让我们来看看选项：`object`只是我们用来初始化数组的原始数据。在先前的例子中，该对象是一个 2 x 2 的方阵；我们可以使用`dtype`选项来指定数据类型。结果存储在变量`A`中。如果`copy`为`True`，返回的对象将是数组的副本，如果`False`，则返回的对象将仅是副本，如果`dtype`与对象的类型不同。数组按照 C 风格的行和列顺序存储。如果用户希望按照 FORTRAN 的内存风格存储数组，应使用`order='Fortran'`选项。`subok`选项非常微妙；如果为`True`，数组可以作为对象的子类传递，如果为`False`，则只能传递`ndarray`数组。最后，`ndmin`选项表示数组返回的最小维度。如果没有提供，这将从`object`中计算得出。

可以使用`zeros`、`ones`、`empty`、`identity`和`eye`等命令获得一组特殊数组。这些命令的名称非常有信息性：

+   `zeros`创建一个填充有零的数组。

+   `ones`创建一个填充有 1 的数组。

+   `empty`返回所需形状的数组，但不初始化其条目。

+   `identity`创建一个由单个正整数*n*指定的维度的方阵。除了对角线外，所有条目都填充为零，对角线填充为 1。

`eye`命令与`identity`非常相似。它也构建对角数组，但与`identity`不同，`eye`允许指定偏离传统居中对齐的对角线，因为它还可以在矩形数组上操作。在以下代码行中，我们使用 zeros、ones 和 identity 命令：

```py
>>> Z=numpy.zeros((5,5), dtype=int)
>>> U=numpy.ones((2,2), dtype=int)
>>> I=numpy.identity(3, dtype=int)

```

在前两种情况下，我们指明了数组的形状（作为正整数的 Python 元组）和可选的数据类型指定。

`eye` 的语法如下：

```py
numpy.eye(N,M=None,k=0,dtype=float)
```

整数 `N` 和 `M` 表示数组的形状，整数 `k` 表示要填充的对角线索引。

索引 `k=0`（默认值）指向传统的对角线；正索引指向上对角线，负索引指向下对角线。为了说明这一点，以下示例展示了如何创建一个 4 x 4 的稀疏矩阵，其非零元素位于第一上对角线和次对角线上：

```py
>>> D=numpy.eye(4,k=1) + numpy.eye(4,k=-1)
>>> print (D)

```

输出如下所示：

```py
[[ 0\.  1\.  0\.  0.]
 [ 1\.  0\.  1\.  0.]
 [ 0\.  1\.  0\.  1.]
 [ 0\.  0\.  1\.  0.]]

```

将前四个命令与基本切片结合使用，可以非常简单地创建更复杂的数组。我们提出以下挑战。

仅使用之前定义的 `U` 和 `I` 以及 `eye` 数组。读者将如何创建一个 5 x 5 的数组 `A`，其值为浮点数，在四个条目（0, 0）、（0, 1）、（1, 0）和（1, 1）处为 *fives*；在剩余的对角线条目处为 *sixes*；在两个其他角落处为 *threes*？此问题的解决方案可以通过以下命令集来解决：

```py
>>> A=3.0*(numpy.eye(5,k=4) + numpy.eye(5,k=-4))
>>> A[0:2,0:2]=5*U; A[2:5,2:5]=6*I
>>> print (A)

```

输出如下所示：

```py
[[ 5\.  5\.  0\.  0\.  3.]
 [ 5\.  5\.  0\.  0\.  0.]
 [ 0\.  0\.  6\.  0\.  0.]
 [ 0\.  0\.  0\.  6\.  0.]
 [ 3\.  0\.  0\.  0\.  6.]]

```

使用 NumPy 创建数组的灵活性通过 `fromfunction` 命令表现得更加清晰。例如，如果我们需要一个 4 x 4 的数组，其中每个条目都反映了其索引的乘积，我们可以在 `fromfunction` 命令中使用 `lambda` 函数 `(lambda i,j: i*j)`，如下所示：

```py
>>> B=numpy.fromfunction( (lambda i,j: i*j), (4,4), dtype=int)
>>> print (B)

```

输出如下所示：

```py
[[0 0 0 0]
 [0 1 2 3]
 [0 2 4 6]
 [0 3 6 9]]

```

处理数组的一个非常重要的工具是掩码的概念。**掩码**基于选择或掩码那些满足给定条件的索引条目的想法。例如，在前面示例中显示的数组 `B` 中，我们可以使用 `B==0` 命令掩码所有零值条目，如下所示：

```py
>>> print (B==0)

```

输出如下所示：

```py
[[ True  True  True  True]
 [ True False False False]
 [ True False False False]
 [ True False False False]]

```

现在，读者将如何更新 `B`，以便将所有零替换为它们对应索引的平方和？

将一个掩码与形状相同的第二个数组相乘，会得到一个新的数组，其中每个条目要么是零（如果掩码中相应的条目是 `False`），要么是第二个数组的条目（如果掩码中相应的条目是 `True`）：

```py
>>> B += numpy.fromfunction((lambda i,j:i*i+j*j), (4,4))*(B==0)
>>> print (B)

```

输出如下所示：

```py
[[0 1 4 9]
 [1 1 2 3]
 [4 2 4 6]
 [9 3 6 9]]

```

注意，我们创建了一个新数组，其中填充了布尔值，其大小与原始数组相同，并在每个步骤中。在这些玩具示例中，这并不是什么大问题，但在处理大型数据集时，分配过多的内存可能会严重减慢我们的计算速度并耗尽系统的内存。在创建数组的命令中，有两个命令特别重要，即 `putmask` 和 `where`，它们有助于内部资源管理，从而加快处理过程。

例如，当我们寻找 `B` 中所有奇数值条目时，生成的掩码大小为 16，尽管有趣的条目只有八个：

```py
>>> print (B%2!=0)

```

输出如下所示：

```py
[[False  True False  True]
 [ True  True False  True]
 [False False False False]
 [ True  True False  True]]

```

`numpy.where()`命令帮助我们更有效地收集这些条目。让我们看看以下命令：

```py
>>> numpy.where(B%2!=0)

```

输出如下所示：

```py
(array([0, 0, 1, 1, 1, 3, 3, 3], dtype=int32),array([1, 3, 0, 1, 3, 0, 1, 3], dtype=int32))

```

如果我们希望将这些条目（所有奇数）改为，比如说，它们是*squares plus one*，我们可以使用`numpy.putmask()`命令，同时更好地管理内存。以下是对`numpy.putmask()`命令的示例代码：

```py
>>> numpy.putmask( B, B%2!=0, B**2+1)
>>> print (B)

```

输出如下所示：

```py
[[ 0  2  4 82]
 [ 2  2  2 10]
 [ 4  2  4  6]
 [82 10  6 82]]

```

注意`putmask`过程如何更新`B`的值，而不需要显式地进行新的赋值。

有三个额外的命令可以创建网格形式的数组。`arange`和`linspace`命令在两个数字之间创建均匀分布的值。在`arange`中，我们指定元素之间的间隔；在`linspace`中，我们指定网格中所需的元素数量。`logspace`命令在以 10 为底的两个数字的对数之间创建对数刻度的均匀分布值。用户可以将这些输出视为单变量函数的支持。

以下是对`numpy.arrange()`命令的示例代码：

```py
>>> L1=numpy.arange(-1,1,0.3)
>>> print (L1)

```

上述代码的输出如下所示：

```py
[-1\.  -0.7 -0.4 -0.1  0.2  0.5  0.8]

```

以下是对`numpy.linspace()`命令的示例代码：

```py
>>> L2=numpy.linspace(-1,1,4)
>>> print (L2)

```

输出如下所示：

```py
[-1\.         -0.33333333  0.33333333  1\.        ]

```

以下是对`numpy.logspace()`命令的示例：

```py
>>> L3= numpy.logspace(-1,1,4)
>>> print (L3)

```

上述代码的输出如下所示：

```py
[  0.1          0.46415888   2.15443469  10\.        ]

```

最后，`meshgrid`、`mgrid`和`ogrid`创建了两个二维数组，维度为*n x m*，包含两个给定的一维数组（维度为*n*和*m*）的元素。它是通过重复每个数组的值来实现的。用户可以将这些输出视为二元函数的支持。

这些程序中的第一个，`meshgrid`，只接受数组作为输入。其他两个程序，`mgrid`和`ogrid`，只接受索引对象（例如，切片）。这两个最后之间的区别是内存分配的问题；`mgrid`分配包含所有数据的完整数组，而`ogrid`只创建足够的集合，以便可以通过适当的笛卡尔积获得相应的`mgrid`命令。

让我们看看以下`meshgrid`命令：

```py
>>> print (numpy.meshgrid(L2,L3))

```

输出如下所示：

```py
(array([[-1\.        , -0.33333333,  0.33333333,  1\.        ],
 [-1\.        , -0.33333333,  0.33333333,  1\.        ],
 [-1\.        , -0.33333333,  0.33333333,  1\.        ],
 [-1\.        , -0.33333333,  0.33333333,  1\.        ]]), array([[ 
0.1       ,   0.1       ,   0.1       ,   0.1       ],
 [  0.46415888,   0.46415888,   0.46415888,   0.46415888],
 [  2.15443469,   2.15443469,   2.15443469,   2.15443469],
 [ 10\.        ,  10\.        ,  10\.        ,  10\.        ]]))

```

让我们看看以下`mgrid`命令：

```py
>>> print (numpy.mgrid[0:5,0:5])

```

输出如下所示：

```py
[[[0 0 0 0 0]
 [1 1 1 1 1]
 [2 2 2 2 2]
 [3 3 3 3 3]
 [4 4 4 4 4]]

 [[0 1 2 3 4]
 [0 1 2 3 4]
 [0 1 2 3 4]
 [0 1 2 3 4]
 [0 1 2 3 4]]]

```

让我们看看以下`ogrid`命令：

```py
>>> print (numpy.ogrid[0:5,0:5])

```

输出如下所示：

```py
[array([[0],
 [1],
 [2],
 [3],
 [4]]), array([[0, 1, 2, 3, 4]])]

```

我们希望通过展示图像处理和微分方程中最有用的程序之一——`tile`命令，来完成关于数组创建的小节。它的语法非常简单，如下所示：

```py
tile(A, reps)
```

这个程序提供了一个非常有效的方法，通过重复模式`reps`（一个元组、一个列表或另一个数组）来对数组`A`进行平铺，从而创建更大的数组。以下棋盘练习展示了它的潜力。

从两个小的二进制数组开始——`B=numpy.ones((3,3))` 和 `checker2by2=numpy.zeros((6,6))`，并使用 `tile` 和尽可能少的操作创建一个棋盘。

让我们使用这些命令执行一些操作：

```py
>>> checker2by2[0:3,0:3]=checker2by2[3:6,3:6]=B
>>> numpy.tile(checker2by2,(4,4))

```

输出太长，无法在此显示。请参阅第一章中“如何打开 IPython 笔记本”部分，*SciPy 简介*，以运行与本章对应的 IPython 笔记本。

## 组合两个或更多数组的常规操作

有时，我们需要将两个或更多数组的数据组合起来以解决特定问题。核心 NumPy 库包含执行这些计算的高效常规操作，我们敦促读者熟悉它们。它们使用最先进的算法构建，并确保内存使用最小化，复杂度最优化。最相关的是将数组作为矩阵操作的常规操作。这包括矩阵乘法（`outer`、`inner`、`dot`、`vdot`、`tensordot`、`cross` 和 `kron`）、数组相关性（`correlate` 和 `convolve`）、数组堆叠（`concatenate`、`vstack`、`hstack`、`column_stack`、`row_stack` 和 `dstack`）以及数组比较（`allclose`）。

如果你精通线性代数，你一定会喜欢 NumPy 中包含的矩阵乘法。我们将推迟它们的用法和分析，直到我们在第三章中介绍 SciPy 模块的线性代数部分，*SciPy 线性代数*。

数组相关性的一个很好的用途是基本的模式匹配。例如，以下示例（`text` 数组）中的图像是从维基百科关于堂吉诃德的页面中提取的段落图像，而第二个数组 `letterE` 包含字母 *e* 的图像，实际上是从 `text` 数组中获得的子数组，代表要匹配的模式。

首先，我们加载文本图像并在其上进行一些预处理，以便将图像转换为正确的格式（尽可能接近灰度近似），以便在此简单模式匹配方法上获得更好的性能。我们通过在 Python 控制台中执行以下代码行来完成此操作：

```py
>>> import scipy.ndimage
>>> import numpy as np
>>> import matplotlib.pyplot as plt
>>> text = scipy.ndimage.imread('Chap_02_text_image.png')
>>> text = np.mean(text.astype(float)/255,-1)*2-1

```

第二，识别字母 *e* 的模式：

```py
>>> letterE = text[37:53,275:291]

```

接下来，两个数组相关性的最大值的一部分提供了数组 `text` 中包含的所有 *e* 字母的位置：

```py
>>> corr = scipy.ndimage.correlate(text,letterE)
>>> eLocations = (corr >= 0.95 * corr.max())

```

找到的模式在图像中 `x` 的位置如下：

```py
>>> CorrLocIndex = np.where(eLocations==True)
>>> x=CorrLocIndex[1]
>>> x 

```

输出如下所示：

```py
array([ 283,  514,  583,  681,  722,  881,  929, 1023,   64,  188,  452, 
 504,  892,  921, 1059, 1087, 1102, 1133,  118,  547,  690, 1066, 
 1110,  330,  363,  519,  671,  913,  951, 1119,  120,  292,  441, 
 516,  557,  602,  649,  688,  717,  747,  783,  813,  988, 1016, 
 250,  309,  505,  691,  769,  876,  904, 1057,  224,  289,  470, 
 596,  626,  780, 1027,  112,  151,  203,  468,  596,  751,  817, 
 867,  203,  273,  369,  560,  599,  888, 1111,  159,  221,  260, 
 352,  427,  861,  901, 1034, 1146,  325,  506,  558]) 

```

找到的模式在图像中 `y` 的位置如下：

```py
>>> y=CorrLocIndex[0] 
>>> y 

```

输出如下所示：

```py
array([ 45,  45,  45,  45,  45,  45,  45,  45,  74,  74,  74,  74,  74, 
 74,  74,  74,  74,  74, 103, 103, 103, 103, 103, 132, 132, 132, 
 132, 132, 132, 132, 161, 161, 161, 161, 161, 161, 161, 161, 161, 
 161, 161, 161, 161, 161, 190, 190, 190, 190, 190, 190, 190, 190, 
 219, 219, 219, 219, 219, 219, 219, 248, 248, 248, 248, 248, 248, 
 248, 248, 277, 277, 277, 277, 277, 277, 277, 306, 306, 306, 306, 
 306, 306, 306, 306, 306, 335, 335, 335]) 

```

有 86 个元素，实际上是在文本图像中字母 *e* 出现的总数，可以通过计数来验证。是否正确匹配可以通过图形验证，将每个模式 `(x,y)` 对的图案叠加到文本图像上，如下所示：

```py
>>> thefig=plt.figure()
>>> plt.subplot(211)
<matplotlib.axes._subplots.AxesSubplot object at 0x7fb9b2390110>
>>> plt.imshow(text, cmap=plt.cm.gray, interpolation='nearest')
<matplotlib.image.AxesImage object at 0x7fb9b1f29410>
>>> plt.axis('off')

```

`plt.axis()`的输出如下所示：

```py
(-0.5, 1199.5, 359.5, -0.5) 

```

现在，让我们在代码中进一步深入：

```py
>>> plt.subplot(212) 
<matplotlib.axes._subplots.AxesSubplot object at 0x7fb9b1f29890> 
>>> plt.imshow(text, cmap=plt.cm.gray, interpolation='nearest') 
<matplotlib.image.AxesImage object at 0x7fb9b1637e10> 
>>> plt.autoscale(False) 
>>> plt.plot(x,y,'wo',markersize=10) 
[<matplotlib.lines.Line2D object at 0x7fb9b1647290>] 
>>> plt.axis('off') 

```

`plt.axis()`的输出如下所示：

```py
(-0.5, 1199.5, 359.5, -0.5) 

```

最后，在下面的`show()`命令中，我们显示一个图像，该图像将图案中的每个`(x,y)`对叠加到文本图像上：

```py
>>> plt.show() 

```

这导致以下截图（第一幅图像是文本，下一幅图像是所有出现字母*e*的文本都被划掉的文本）：

![两个或多个数组合并的程序](img/7702OS_02_02.jpg)

关于堆叠操作的一些话；我们有一个基本的连接程序，`concatenate`，它沿着预定的轴将一系列数组连接在一起。当然，序列中的所有数组都必须具有相同的维度，否则显然不起作用。其余的堆叠操作是`concatenate`的特殊情况的语法糖——`vstack`用于垂直连接数组，`hstack`用于水平连接数组，`dstack`用于在第三个维度上连接数组，等等。

另一组令人印象深刻的程序是集合操作。它们允许用户将一维数组视为集合，并执行交集（`intersect1d`）、并集（`union1d`）、集合差（`setdiff1d`）和集合异或（`setxor1d`）的布尔运算。这些集合操作的输出返回排序后的数组。请注意，也可以测试一个数组中的所有元素是否属于第二个数组（`in1d`）。

## 数组操作的相关程序

有一个分割程序序列，旨在将数组分割成更小的数组，在任何给定维度上——`array_split`、`split`（两者都是沿指示轴的基本分割）、`hsplit`（水平分割）、`vsplit`（垂直分割）和`dsplit`（在第三个轴上）。让我们用一个简单的例子来说明这些：

```py
>>> import numpy 
>>> B = numpy.ones((3,3)) 
>>> checker2by2 = numpy.zeros((6,6)) 
>>> checker2by2[0:3,0:3] = checker2by2[3:6,3:6] = B 
>>> print(checker2by2)

```

输出如下所示：

```py
[[ 1\.  1\.  1\.  0\.  0\.  0.]
 [ 1\.  1\.  1\.  0\.  0\.  0.]
 [ 1\.  1\.  1\.  0\.  0\.  0.]
 [ 0\.  0\.  0\.  1\.  1\.  1.]
 [ 0\.  0\.  0\.  1\.  1\.  1.]
 [ 0\.  0\.  0\.  1\.  1\.  1.]]

```

现在，让我们执行垂直分割：

```py
>>> numpy.vsplit(checker2by2,3)

```

输出如下所示：

```py
[array([[ 1.,  1.,  1.,  0.,  0.,  0.],
 [ 1.,  1.,  1.,  0.,  0.,  0.]]),
 array([[ 1.,  1.,  1.,  0.,  0.,  0.],
 [ 0.,  0.,  0.,  1.,  1.,  1.]]),
 array([[ 0.,  0.,  0.,  1.,  1.,  1.],
 [ 0.,  0.,  0.,  1.,  1.,  1.]])]

```

在数组上应用 Python 函数*通常*意味着将函数应用于数组的每个元素。注意 NumPy 函数`sin`是如何在数组上工作的，例如：

```py
>>> a=numpy.array([-numpy.pi, numpy.pi])
>>> print (numpy.vstack((a, numpy.sin(a))))

```

输出如下所示：

```py
[[ -3.14159265e+00   3.14159265e+00]
 [ -1.22464680e-16   1.22464680e-16]]

```

注意，`sin`函数是在数组的每个元素上计算的。

这只有在函数已经被正确向量化（例如`numpy.sin`）的情况下才会工作。注意非向量化 Python 函数的行为。让我们定义一个函数，用于计算对于每个`x`值，`x`和 100 之间的最大值，而不使用 NumPy 库中的任何程序：

```py
# function max100
>>> def max100(x):
 return(x)

```

如果我们尝试将此函数应用于前面的数组，系统将引发错误，如下所示：

```py
>>> max100(a)

```

输出是一个错误，显示如下：

```py
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()

```

我们需要明确告诉系统，当我们想要将我们的函数应用于数组以及标量时。我们通过`vectorize`程序来完成，如下所示：

```py
>>> numpy.vectorize(max100)(a)

```

输出如下所示：

```py
array([100, 100])

```

为了我们的便利，NumPy 库提供了一大堆已经向量化了的数学函数。一些例子包括`round_`、`fix`（将数组元素四舍五入到所需的十进制位数），以及`angle`（提供数组元素的角，前提是它们是复数）和任何基本三角函数（`sin`、`cos`、`tan`、`sec`）、指数函数（`exp`、`exp2`、`sinh`、`cosh`）和对数函数（`log`、`log10`、`log2`）。

我们还有将数组视为多维函数输出的数学函数，并提供相关计算。一些有用的例子包括`diff`（通过执行离散差分来模拟任何指定维度的微分），`gradient`（计算相应函数的梯度），或者`cov`（用于数组的协方差）。

使用`msort`和`sort_complex`例程可以根据第一轴的值对整个数组进行排序。

## 从数组中提取信息的例程

大多数提取信息的例程都具有统计性质，包括`average`（与`mean`方法作用相同），`median`（计算数组在其任何维度上的统计中位数，或整个数组），以及直方图的计算（`histogram`、`histogram2d`和`histogramdd`，取决于数组的维度）。在这个类别中，另一组重要的例程处理一维数组的 bin 概念。这可以通过例子更容易地解释。以数组`A=numpy.array([5,1,1,2,1,1,2,2,10,3,3,4,5])`为例，`unique`命令找到数组中的唯一值，并以排序的方式呈现：

```py
>>> numpy.unique(A)

```

输出如下所示：

```py
array([ 1, 2, 3, 4, 5, 10])

```

对于所有条目都是非负整数的数组，如`A`，我们可以将数组`A`可视化为从 0 到 10（数组中的最大值）的数字标签的十一个 bin 序列（bin）。每个标签为*n*的 bin 包含数组中*n*的数量：

```py
>>> numpy.bincount(A)

```

输出如下所示：

```py
array([0, 4, 3, 2, 1, 2, 0, 0, 0, 0, 1])

```

对于某些元素不是数字（`nan`）的数组，NumPy 提供了一套模拟提取信息但忽略冲突元素的例程——`nanmax`、`nanmin`、`nanargmax`、`nanargmin`、`nansum`等等：

```py
>>> A=numpy.fromfunction((lambda i,j: (i+1)*(-1)**(i*j)), (4,4))
>>> print (A)

```

输出如下所示：

```py
[[ 1\.  1\.  1\.  1.]
 [ 2\. -2\.  2\. -2.]
 [ 3\.  3\.  3\.  3.]
 [ 4\. -4\.  4\. -4.]]

```

让我们看看`log2`对数组`A`的影响：

```py
>>> B=numpy.log2(A)
__main__:1: RuntimeWarning: invalid value encountered in log2
>>> print (B)

```

输出如下所示：

```py
[[ 0\.         0\.         0\.         0\.       ]
 [ 1\.               nan  1\.               nan]
 [ 1.5849625  1.5849625  1.5849625  1.5849625]
 [ 2\.               nan  2\.               nan]]

```

让我们看一下以下代码行中的`sum`和`nansum`命令：

```py
>>> numpy.sum(B), numpy.nansum(B)

```

输出如下所示：

```py
(nan, 12.339850002884624)

```

# 摘要

在本章中，我们深入探讨了 SciPy 使用的对象数组的创建和基本操作，作为对 NumPy 库的概述。特别是，我们看到了切片和掩码的原则，这些原则简化了算法的编码，以至于将原本难以阅读的循环和原始命令序列转换成直观且自解释的对象调用和方法集。你还了解到，NumPy 中的非基本模块在 SciPy 自身中也作为模块进行了复制。本章的结构大致与官方 NumPy 参考（读者可以在 SciPy 页面[`docs.scipy.org/doc/numpy/reference/`](http://docs.scipy.org/doc/numpy/reference/)上访问）相同。还有其他一些严谨地覆盖 NumPy 的优质资源，我们建议您查阅这些材料以获得对该主题更详细的了解。

在接下来的五章中，我们将探讨使 SciPy 成为数值计算强大工具的命令。这些章节的结构基本上反映了 SciPy 中不同模块的结构，这些模块按照允许在彼此之上构建应用程序的顺序排列。
