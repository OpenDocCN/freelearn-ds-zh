<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Interaction with Other Languages</h1></div></div></div><p>We often need to incorporate into our workflow some code written in different languages; mostly C/C++ or Fortran, and also from R, MATLAB, or Octave. Python excels at allowing code from all these other sources to run from within; care must be taken to convert different numerical types to something that Python understands, but this is pretty much the only issue we encounter.</p><p>If you are working with SciPy, it is because your Python ecosystem has available compilers for C and Fortran programs. Otherwise, SciPy could have not been installed on your system. Also, given its popularity, it is highly probably that your computer environment has MATLAB/Octave available. Accordingly, this has driven the selection of topics listed later in this chapter. We left to the interested reader to find out how interface with R and many other software is available out there for numerical computing. Two<a id="id358" class="indexterm"/> alternatives to do that with R are the packages <strong>PypeR</strong> (<a class="ulink" href="http://bioinfo.ihb.ac.cn/softwares/PypeR/">http://bioinfo.ihb.ac.cn/softwares/PypeR/</a>) and <strong>rpy2</strong> (<a class="ulink" href="http://rpy.sourceforge.net/">http://rpy.sourceforge.net/</a>). Additional alternatives can be found at <a class="ulink" href="http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language">http://stackoverflow.com/questions/11716923/python-interface-for-r-programming-language</a>. </p><p>In this chapter, we will cover the following things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief discussion on how Python can be used to run codes from Fortran, C/C++, and MATLAB/Octave</li><li class="listitem" style="list-style-type: disc">We will first see the basic functionality of the utility <code class="literal">f2py</code> to handle the inclusion of Fortran codes in Python via SciPy</li><li class="listitem" style="list-style-type: disc">A basic usage to include C/C++ code within Python code using the tools provided by the the <code class="literal">scipy.weav</code><code class="literal">e</code> module</li></ul></div><p>The routines will be illustrated via simple examples that can be enriched by you modifying the IPython Notebook corresponding to this chapter.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Interaction with Fortran</h1></div></div></div><p>SciPy provides<a id="id359" class="indexterm"/> a simple way of including Fortran code—<code class="literal">f2py</code>. This is a utility shipped with the NumPy libraries, which is operative when <code class="literal">distutils</code> from SciPy are available. This is always the case when we install SciPy.</p><p>The <code class="literal">f2py</code> utility is supposed to run outside Python, and it is used to create from any Fortran file a Python module that can be easily called in our sessions. Under any <code class="literal">*nix</code> system, we call it from the terminal. Under Windows, we recommend you run it in the native terminal, or even better, through a <code class="literal">cygwin</code> session.</p><p>Before being compiled with <code class="literal">f2py</code>, any Fortran code needs to undergo three basic changes, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Removal of all allocations</li><li class="listitem" style="list-style-type: disc">Transformation of the whole program into a subroutine</li><li class="listitem" style="list-style-type: disc">If anything special needs to be passed to <code class="literal">f2py</code>, we must add it with the comment string <code class="literal">"!f2py"</code> or <code class="literal">"cf2py"</code></li></ul></div><p>Let's illustrate the process with a simple example. The following naive subroutine, which we store in the <code class="literal">primefactors.f90</code> file, performs a factorization in prime numbers for any given integer:</p><div><pre class="programlisting">SUBROUTINE PRIMEFACTORS(num, factors, f)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: num  !input number
  INTEGER,INTENT(OUT), DIMENSION((num/2))::factors 
  INTEGER, INTENT(INOUT) :: f
  INTEGER :: i, n
  i = 2  
  f = 1  
  n = num
  DO
    IF (MOD(n,i) == 0) THEN 
      factors(f) = i
      f = f+1
      n = n/i
    ELSE
      i = i+1
    END IF
    IF (n == 1) THEN    
      f = f-1    
      EXIT
    END IF
  END DO</pre></div><p>Since no allocation was made in the code, and we receive a subroutine directly, we may skip to the third step, but for the moment we will not tamper with <code class="literal">f2py</code> commands, and are <a id="id360" class="indexterm"/>content with trying to create a python module from it. The fastest way to wrap this <code class="literal">primefactors</code> subroutine is by issuing the following command (at the shell or terminal prompt indicated by <code class="literal">%</code>):</p><div><pre class="programlisting"><strong>% f2py –c primefactors.f90 –m primefactors</strong>
</pre></div><p>If everything is correct, an extension module with the name <code class="literal">primefactors.so</code> is created. We can then access the <code class="literal">primefactors</code> routine in Python from the <code class="literal">primefactors</code> module:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import primefactors</strong>
<strong>&gt;&gt;&gt; primefactors.primefactors(6,1)</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>array([2, 3, 0], dtype=int32)</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Interaction with C/C++</h1></div></div></div><p>Technically, <code class="literal">f2py</code> can also wrap a C code for us, but there are more efficient ways to perform<a id="id361" class="indexterm"/> this task. For instance, if we need to interface a very large library of C functions, the preferred method for doing this is <strong>Simplified Wrapper and Interface Generator</strong> (<strong>SWIG</strong>) (<a class="ulink" href="http://www.swig.org/">http://www.swig.org/</a>). To wrap C++ code, depending on the features required <a id="id362" class="indexterm"/>and the method of interacting with Python, we have several <a id="id363" class="indexterm"/>methods such as SWIG or <code class="literal">f2py</code> again, but also <strong>PyCXX</strong>, <strong>Boost.Python</strong>, <strong>Cython</strong>, or the SciPy module: <code class="literal">weave</code>. When C compilers are not available (and thus linking extensive libraries is not possible in the usual way), we use <code class="literal">ctypes</code>. Whenever we will use NumPy/SciPy code, and want fast solutions to our wrapping/binding, the two most common ways to interact with C/C++ are usually through the Python/C API and <code class="literal">weave</code> packages.</p><p>All the methods briefly enumerated here would require an entire monograph to describe, at length, the methodology of binding the nuisances of the wrapping, depending on systems and requirements, and the caveats of their implementations. The method we would like to cover in more detail in this chapter is the <code class="literal">weave</code> package, more concretely by means of the <code class="literal">inline</code> routine. This command receives a string (raw or otherwise) containing a sequence of commands, and runs it in Python by calling your C/C++ compiler. The syntax is as follows:</p><div><pre class="programlisting">inline(code, arg_names, local_dict=None, global_dict=None,
           force = 0,
           compiler='',
           verbose = 0,
support_code = None,
           customize=None,
type_factories = None,
auto_downcast=1,
           **kw)</pre></div><p>Let's go<a id="id364" class="indexterm"/> over the different parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">code</code> parameter is the string that holds the code to be run. Note that this code<a id="id365" class="indexterm"/> must not specify any kind of <code class="literal">return</code> statement. Instead, it should assign some result that can be returned to Python.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">arg_names</code> parameter is a list of strings containing the Python variable names<a id="id366" class="indexterm"/> that are to be sent to the C/C++ code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">local_dict</code> parameter is optional, and must be a Python dictionary containing<a id="id367" class="indexterm"/> the values used as local scope for the C/C++ code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">global_dict</code> parameter is also optional, and must be another Python dictionary <a id="id368" class="indexterm"/>containing the values that should be used as the global scope for the C/C++ code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">force</code> parameter is <a id="id369" class="indexterm"/>used only for debugging purposes. It is also optional, and can take only two values—0 (by default) or 1. If its value is set to 1, the C/C++ code is compiled every time <code class="literal">inline</code> is called.</li><li class="listitem" style="list-style-type: disc">We may specify the compiler that takes over the C/C++ code with the <code class="literal">compiler</code> option. It must be a string containing the name of the C/C++ compiler.</li></ul></div><p>Let's take an example of the <code class="literal">inline</code> routine in which we use the following method to employ <code class="literal">cout</code> for text displaying purposes:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy.weave</strong>
<strong>&gt;&gt;&gt; name = 'Francisco'</strong>
<strong>&gt;&gt;&gt; pin = 1234</strong>
<strong>&gt;&gt;&gt; code = 'std::cout &lt;&lt; name &lt;&lt; "---PIN: " '</strong>
<strong>&gt;&gt;&gt; code+= '&lt;&lt;std::hex &lt;&lt; pin &lt;&lt;std::endl;'</strong>
<strong>&gt;&gt;&gt; arg_names = ['name','pin']</strong>
<strong>&gt;&gt;&gt; scipy.weave.inline(code, arg_names)</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>Francisco---PIN: 4d2</strong>
</pre></div><p>That was a very simple example, in which no external header declarations were needed. If we wish to do so, those go into the <code class="literal">support_code</code> option. For instance, if we wish to include math functions from R in our C/C++ code and pass it with <code class="literal">inline</code>, we need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Configure the C functions as a shared library. In the folder, holding the R release in a terminal session, issue the following command:<div><pre class="programlisting"><strong>% ./configure --enable-R-static-lib --enable-static --with-readline=no</strong>
</pre></div></li><li class="listitem">Change to <a id="id370" class="indexterm"/>the <code class="literal">standalone</code> folder at <code class="literal">src/nmath</code> and finish the installation of the libraries. At the end, we should have a file named <code class="literal">libRmath.so</code>, which needs to be pointed to from the <code class="literal">libpath</code> string back into our Python session:<div><pre class="programlisting"><strong>% cd src/nmath/standalone</strong>
<strong>% make</strong>
</pre></div></li><li class="listitem">Back in our Python session, we prepare the <code class="literal">inline</code> call with the proper options. For instance, if we wish to call the R routine <code class="literal">pbinom</code>, we proceed as follows:<div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy.weave </strong>
<strong>&gt;&gt;&gt; support_code= 'extern "C" double pbinom(double x,\ </strong>
<strong>                 double n, double p, int lower_tail, int log_p);' </strong>
<strong>&gt;&gt;&gt; libpath='/opt/Rlib' #IS THE LOCATION OF LIBRARY libRmath.so</strong>
<strong>&gt;&gt;&gt; library_dirs=[libpath] </strong>
<strong>&gt;&gt;&gt; libraries=['Rmath'] </strong>
<strong>&gt;&gt;&gt; runtime_library_dirs=[libpath] </strong>
<strong>&gt;&gt;&gt; code='return_val=pbinom(100,20000,100./20000.,0,1);' </strong>
<strong>&gt;&gt;&gt; res=scipy.weave.inline(code, support_code=support_code, \ </strong>
<strong>        library_dirs=library_dirs, libraries=libraries, \ </strong>
<strong>        runtime_library_dirs=runtime_library_dirs) </strong>
<strong>&gt;&gt;&gt; print(res) </strong>
</pre></div><p>The output is shown as:</p><div><pre class="programlisting"><strong>-0.747734910363 </strong>
</pre></div><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Note how the function declaration is passed in <code class="literal">support_code</code>, not in code. Also, note that this option needs to start with <code class="literal">extern "C"</code> whenever we are not using C++.</p></div></div></li><li class="listitem">If extra headers need to be passed, we do so with the <code class="literal">header</code> option, rather than <code class="literal">support_code</code> or <code class="literal">code</code>:<div><pre class="programlisting"><strong>&gt;&gt;&gt; headers = ['&lt;math.h&gt;']</strong>
</pre></div></li></ol></div><p>We have a word of advice. Care must be taken while converting the different variable types from their original C/C++ format to something that Python understands. This requires modifying the original C/C++ code in certain cases. But by default, we do not have to worry about the following C/C++ types, as SciPy automatically turns them into the<a id="id371" class="indexterm"/> indicated<a id="id372" class="indexterm"/> Python formats, as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="bottom">
<p><strong>Python</strong></p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">float</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">complex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">string</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">list</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">tuple</code>
</p>
</td></tr><tr><td style="text-align: left" valign="bottom">
<p><strong>C/C++</strong></p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">int</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">double</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">std::complex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">py::string</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">py::list</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">py:dict</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">py::tuple</code>
</p>
</td></tr></tbody></table></div><p>File<a id="id373" class="indexterm"/> types <code class="literal">FILE*</code> are sent to Python files. Python callables and instances are both obtained from <code class="literal">py::object</code>. NumPy ndarrays are constructed from <code class="literal">PyArrayObject*</code>. For any other Python type to be used, the corresponding C/C++ types must be carefully turned into combinations of the previous.</p><p>And that should be all. To go beyond trivial uses of the inline function, we usually create extension modules and catalog the functions within for future use.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Interaction with MATLAB/Octave</h1></div></div></div><p>Since both<a id="id374" class="indexterm"/> numerical computing environments are provide with a fourth-generation programming language, we discourage the straightforward inclusion of code from any of these two. There is no gain in terms of speed, resource usage, or coding power. In the extreme and rare cases, in which a specific routine is not available in SciPy, the preferred way to bring it to our session is by generating C code from the MATLAB/Octave code, and then wrap it with any of the methods suggested in the <em>Interaction with C/C++</em> section of this chapter.</p><p>There is a different story when we receive data created from within MATLAB or Octave. SciPy has a dedicated module to deal with this situation—<code class="literal">scipy.io</code>.</p><p>Let's show you by example. We start with Octave, where we generate a <strong>Delaunay triangulation</strong> of a<a id="id375" class="indexterm"/> random set of 10 points in the plane. </p><p>We save the coordinates of these points, as well as the pointers to the triangles in the triangulation, to a MATLAB-style file (version 7) called data:</p><div><pre class="programlisting"><strong>octave:1&gt; x=rand(1,10);</strong>
<strong>octave:2&gt; y=rand(size(x));</strong>
<strong>octave:3&gt; T=delaunay(x,y);</strong>
<strong>octave:4&gt; save -v7 data x y T</strong>
</pre></div><p>We are done here. We then go to our Python session, where we recover the file data:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from scipy.io import loadmat</strong>
<strong>&gt;&gt;&gt; datadict = loadmat("data")</strong>
</pre></div><p>The <code class="literal">datadict</code> variable holds a Python dictionary with the names of the variables as <code class="literal">keys</code> and the loaded matrices as their corresponding values:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; datadict.keys()</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>['__header__', '__globals__', 'T', 'y', 'x', '__version__']</strong>
</pre></div><p>Let's issue the <code class="literal">datadict</code> command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; datadict['x']</strong>
</pre></div><p>The<a id="id376" class="indexterm"/> output is shown as follows:</p><div><pre class="programlisting"><strong>array([[0.81222999,0.51836246,0.60425982,0.23660352,0.01305779,</strong>
<strong>        0.0875166,0.77873049,0.70505801,0.51406693,0.65760987]])</strong>
</pre></div><p>Let's take a look at following <code class="literal">datadict</code> command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; datadict['__header__']</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>'MATLAB 5.0 MAT-file, written by Octave 3.2.4, 2012-11-27</strong>
<strong> 15:45:20 UTC'</strong>
</pre></div><p>It is possible to save data from our sessions to a format that MATLAB and Octave will understand. We do so with the <code class="literal">savemat</code> command, from the same module. The syntax is as follows:</p><div><pre class="programlisting">savemat(file_name, mdict, appendmat=True, format='5', 
long_field_names=False, do_compression=False,
oned_as=None)</pre></div><p>The <code class="literal">file_name</code> parameter contains the name of the MATLAB-type file where the data will be written. The Python dictionary <code class="literal">mdict</code> contains the names (as keys) of the variables, and their corresponding array values.</p><p>If we wish to append <code class="literal">.mat</code> at the end of the file, we may do so in the <code class="literal">file_name</code> variable, or by setting <code class="literal">appendmat</code> to <code class="literal">True</code>. In case we need to provide long names for the files (which not all versions of MATLAB accept), we need to indicate so by setting the <code class="literal">long_field_names</code> option to <code class="literal">True</code>.</p><p>We may indicate the version of MATLAB with the <code class="literal">format</code> option. We set it to the string <code class="literal">'5'</code> for versions 5 and later, or to the string <code class="literal">'4'</code> for version 4.</p><p>It is possible to compress the matrices we send, and we indicate so by setting the <code class="literal">do_compression</code> option to <code class="literal">True</code>.</p><p>The last option is very interesting. It allows us to indicate to MATLAB/Octave whether our arrays <a id="id377" class="indexterm"/>are to be read column by column, or row by row. Setting the <code class="literal">oned_as</code> parameter to the string <code class="literal">'column'</code> will send our data into a collection of column vectors. If we set it to the string <code class="literal">'row'</code>, it will send the data as collections of row vectors. If set to <code class="literal">None</code>, the format in which the data was written is respected.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Summary</h1></div></div></div><p>This chapter introduced one of the main strengths of SciPy—the ability to interact with other languages such as C/C++, Fortran, R, and MATLAB/Octave. To go in depth into interfacing Python with other languages, you might want to read more specialized literature like <em>Learning Cython Programming</em>, <em>Philip Herron</em>, <em>Packt Publishing</em> or the in-depth coverage of F2PY at <a class="ulink" href="http://docs.scipy.org/doc/numpy/f2py/">http://docs.scipy.org/doc/numpy/f2py/</a> and <a class="ulink" href="http://www.f2py.com/home/references">http://www.f2py.com/home/references</a>. Additional help can be found at <a class="ulink" href="https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages">https://wiki.python.org/moin/IntegratingPythonWithOtherLanguages</a>.</p><p>If you have reached this chapter and have been reading from the first one, you should be aware that many topics were left out in this introductory chapter on SciPy. This book has given you enough background to further strengthen your skills and ability to work with SciPy. To proceed studying, refer to the SciPy Reference Guide (<a class="ulink" href="http://docs.scipy.org/doc/scipy/reference/">http://docs.scipy.org/doc/scipy/reference/</a>) and other documentation guides available at (<a class="ulink" href="http://docs.scipy.org/doc/">http://docs.scipy.org/doc/</a>).</p><p>In addition, we recommend you regularly read and also subscribe to the SciPy mailing list (<a class="ulink" href="http://mail.scipy.org/mailman/listinfo/scipy-user">http://mail.scipy.org/mailman/listinfo/scipy-user</a>) where you can interact with users of SciPy all over the world, not only by asking/answering questions about SciPy, but also to find out current trends on SciPy and even jobs related to it. </p><p>You can peruse the historical archive of the collection of postings to the list, <a class="ulink" href="http://mail.scipy.org/pipermail/scipy-user/">http://mail.scipy.org/pipermail/scipy-user/</a>. Also, you should know that there is a SciPy conference held every year (<a class="ulink" href="http://conference.scipy.org/">http://conference.scipy.org/</a>) which, to quote them, allows participants from academic, commercial, and governmental organizations to showcase their latest Scientific Python projects, learn from skilled users and developers, and collaborate on code development.</p></div></body></html>