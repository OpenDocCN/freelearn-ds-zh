["```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    #\n    # for every polygon in a polygon layer there can only be\n    # one point object located in each polygon\n    # the number of points per polygon can be defined by the user\n    from utils import shp2_geojson_obj\n    from utils import create_shply_multigeom\n    import json\n\n    in_shp_poly = \"../geodata/topo_polys.shp\"\n    in_shp_point = \"../geodata/topo_points.shp\"\n\n    ply_geojs_obj = shp2_geojson_obj(in_shp_poly)\n    pt_geojs_obj = shp2_geojson_obj(in_shp_point)\n\n    shply_polys = create_shply_multigeom(ply_geojs_obj, \"MultiPolygon\")\n    shply_points = create_shply_multigeom(pt_geojs_obj, \"MultiPoint\")\n\n    def valid_point_in_poly(polys, points):\n        \"\"\"\n        Determine if every polygon contains max one point and that each\n        point is not located on the EDGE or Vertex of the polygon\n        :param point: Point data set\n        :param poly: Polygon data set\n        :return: True or False if False a dictionary containing polygon ids\n        that contain no or multiple points\n        \"\"\"\n        pts_in_polys = []\n        pts_touch_plys = []\n\n        pts_plys_geom = []\n        pts_touch_geom = []\n\n        # check each polygon for number of points inside\n        for i, poly in enumerate(polys):\n\n            pts_in_this_ply = []\n            pts_touch_this_ply = []\n\n            for pt in points:\n                if poly.touches(pt):\n                    pts_touch_this_ply.append(\n                        {'multipoint_errors_touches': pt.__geo_interface__, 'poly_id': i,\n                         'point_coord': pt.__geo_interface__})\n\n                if poly.contains(pt):\n                    pts_in_this_ply.append({'multipoint_contains': pt.__geo_interface__})\n\n            pts_in_polys.append(len(pts_in_this_ply)) \n            pts_touch_plys.append(len(pts_touch_this_ply))\n\n            # create list of point geometry errors\n            pts_plys_geom.append(pts_in_this_ply)\n            pts_touch_geom.append(pts_touch_this_ply)\n\n        # identify if we have more than one point per polygon or\n        # identify if no points are inside a polygon\n        no_good = dict()\n        all_good = True\n\n        # loop over list containing the number of pts per polygon\n        # each item in list is an integer representing the number\n        # of points located inside a particular polygon [4,1,0]\n        # represents 4 points in polygon 1, 1 point in poly 2, and\n        # 0 points in polygon 3\n        for num, res in enumerate(pts_in_polys):\n\n            if res == 1:\n                # this polygon is good and only has one point inside\n                # no points on the edge or on the vertex of polygon\n                continue\n                # no_good['poly num ' + str(num)] = \"excellen only 1 point in poly\"\n            elif res > 1:\n                # we have more than one point either inside, on edge\n                # or vertex of a polygon\n                no_good['poly num ' + str(num)] = str(res) + \" points in this poly\"\n                all_good = False\n            else:\n                # last case no points in this polygon\n                no_good['poly num ' + str(num)] = \"No points in this poly\"\n                all_good = False\n\n        if all_good:\n            return all_good\n        else:\n            bad_list = []\n            for pt in pts_plys_geom:\n                fgeom = {}\n                for res in pt:\n                    if 'multipoint_contains' in res:\n                        hui = res['multipoint_contains']\n                        print hui\n                        fgeom['geom'] = hui\n                bad_list.append(fgeom)\n            return bad_list\n            # return no_good,pts_in_polys2 # [4,0,1]\n\n    valid_res = valid_point_in_poly(shply_polys, shply_points)\n\n    final_list = []\n    for res in valid_res:\n        if 'geom' in res:\n            geom = res['geom']\n            final_list.append(geom)\n\n    final_gj = {\"type\": \"GeometryCollection\", \"geometries\": final_list}\n    print json.dumps(final_gj)\n    ```", "```py\n    # -*- coding: utf-8 -*-\n    import unittest\n    from shapely.geometry import Point\n    from shapely.geometry import Polygon\n\n    class TestPointPerPolygon(unittest.TestCase):\n        def test_inside(self):\n\n            ext = [(0, 0), (0, 2), (2, 2), (2, 0), (0, 0)]\n            int = [(1, 1), (1, 1.5), (1.5, 1.5), (1.5, 1)]\n            poly_with_hole = Polygon(ext,[int])\n\n            polygon = Polygon([(0, 0), (0, 10), (10, 10),(0, 10)])\n\n            point_on_edge = Point(5, 10)\n            point_on_vertex = Point(10, 10)\n            point_inside = Point(5, 5)\n            point_outside = Point(20,20)\n            point_in_hole = Point(1.25, 1.25)\n\n            self.assertTrue(polygon.touches(point_on_vertex))\n            self.assertTrue(polygon.touches(point_on_edge))\n            self.assertTrue(polygon.contains(point_inside))\n            self.assertFalse(polygon.contains(point_outside))\n            self.assertFalse(point_in_hole.within(poly_with_hole))\n\n    if __name__ == '__main__':\n        unittest.main()\n    ```", "```py\n    self.assertTrue(point_in_hole.within(poly_with_hole)\n    ```", "```py\n    Failure\n    Traceback (most recent call last):\n     File \"/home/mdiener/ch09/code/ch09-01_single_pt_test_in_poly.py\", line 26, in test_inside\n     self.assertTrue(point_in_hole.within(poly_with_hole))\n    AssertionError: False is not true\n\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    from utils import shp2_geojson_obj\n    from utils import create_shply_multigeom\n    from utils import out_geoj\n    from shapely.geometry import Point, MultiPoint\n\n    in_shp_line = \"../geodata/topo_line.shp\"\n    in_shp_point = \"../geodata/topo_points.shp\"\n\n    # create our geojson like object from a Shapefile\n    shp1_data = shp2_geojson_obj(in_shp_line)\n    shp2_data = shp2_geojson_obj(in_shp_point)\n\n    # convert the geojson like object to shapely geometry\n    shp1_lines = create_shply_multigeom(shp1_data, \"MultiLineString\")\n    shp2_points = create_shply_multigeom(shp2_data, \"MultiPoint\")\n\n    def create_start_end_pts(lines):\n        '''\n        Generate a list of all start annd end nodes\n        :param lines: a Shapely geometry LineString\n        :return: Shapely multipoint object which includes\n                 all the start and end nodes\n        '''\n        list_end_nodes = []\n        list_start_nodes = []\n\n        for line in lines:\n            coords = list(line.coords)\n\n            line_start_point = Point(coords[0])\n            line_end_point = Point(coords[-1])\n\n            list_start_nodes.append(line_start_point)\n            list_end_nodes.append(line_end_point)\n\n        all_nodes = list_end_nodes + list_start_nodes\n\n        return MultiPoint(all_nodes)\n\n    def check_points_cover_start_end(points, lines):\n        '''\n\n        :param points: Shapely point geometries\n        :param lines:Shapely linestrings\n        :return:\n        '''\n\n        all_start_end_nodes = create_start_end_pts(lines)\n\n        bad_points = []\n        good_points = []\n        if len(points) > 1:\n            for pt in points:\n                if pt.touches(all_start_end_nodes):\n                    print \"touches\"\n                if pt.disjoint(all_start_end_nodes):\n                    print \"disjoint\" # 2 nodes\n                    bad_points.append(pt)\n                if pt.equals(all_start_end_nodes):\n                    print \"equals\"\n                if pt.within(all_start_end_nodes):\n                    print \"within\" # all our nodes on start or end\n                if pt.intersects(all_start_end_nodes):\n                    print \"intersects\"\n                    good_points.append(pt)\n        else:\n            if points.intersects(all_start_end_nodes):\n                print \"intersects\"\n                good_points.append(points)\n            if points.disjoint(all_start_end_nodes):\n                print \"disjoint\"\n                good_points.append(points)\n\n        if len(bad_points) > 1:\n            print \"oh no 1 or more points are NOT on a start or end node\"\n            out_geoj(bad_points, '../geodata/points_bad.geojson')\n            out_geoj(good_points, '../geodata/points_good.geojson')\n\n        elif len(bad_points) == 1:\n            print \"oh no your input single point is NOT on start or end node\"\n\n        else:\n            print \"super all points are located on a start or end node\" \\\n                  \"NOTE point duplicates are NOT checked\"\n\n    check_points_cover_start_end(shp2_points, shp1_lines)\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n\n    from utils import shp2_geojson_obj\n    from utils import create_shply_multigeom\n    from utils import out_geoj\n\n    in_shp_line = \"../geodata/topo_line.shp\"\n    in_shp_overlap = \"../geodata/topo_line_overlap.shp\"\n\n    shp1_data = shp2_geojson_obj(in_shp_line)\n    shp2_data = shp2_geojson_obj(in_shp_overlap)\n\n    shp1_lines = create_shply_multigeom(shp1_data, \"MultiLineString\")\n    shp2_lines_overlap = create_shply_multigeom(shp2_data, \"MultiLineString\")\n\n    overlap_found = False\n\n    for line in shp1_lines:\n        if line.equals(shp2_lines_overlap):\n            print \"equals\"\n            overlap_found = True\n        if line.within(shp2_lines_overlap):\n            print \"within\"\n            overlap_found = True\n\n    # output the overlapping Linestrings\n    if overlap_found:\n        print \"now exporting overlaps to GeoJSON\"\n        out_int = shp1_lines.intersection(shp2_lines_overlap)\n        out_geoj(out_int, '../geodata/overlapping_lines.geojson')\n\n        # create final Linestring only list of overlapping lines\n        # uses a pyhton list comprehension expression\n        # only export the linestrings Shapely also creates  2 Points\n        # where the linestrings cross and touch\n        final = [feature for feature in out_int if feature.geom_type == \"LineString\"]\n\n        # code if you do not want to use a list comprehension expresion\n        # final = []\n        # for f in out_int:\n        #     if f.geom_type == \"LineString\":\n        #         final.append(f)\n\n        # export final list of geometries to GeoJSON\n        out_geoj(final, '../geodata/final_overlaps.geojson')\n    else:\n        print \"hey no overlapping linestrings\"\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    from utils import shp2_geojson_obj\n    from utils import create_shply_multigeom\n    from utils import out_geoj\n    from shapely.geometry import Point\n\n    in_shp_dangles = \"../geodata/topo_dangles.shp\"\n    shp1_data = shp2_geojson_obj(in_shp_dangles)\n    shp1_lines = create_shply_multigeom(shp1_data, \"MultiLineString\")\n\n    def find_dangles(lines):\n        \"\"\"\n        Locate all dangles\n        :param lines: list of Shapely LineStrings or MultiLineStrings\n        :return: list of dangles\n        \"\"\"\n        list_dangles = []\n        for i, line in enumerate(lines):\n            # each line gets a number\n            # go through each line added first to second\n            # then second to third and so on\n            shply_lines = lines[:i] + lines[i+1:]\n            # 0 is start point and -1 is end point\n            # run through\n            for start_end in [0, -1]:\n                # convert line to point\n                node = Point(line.coords[start_end])\n                # Return True if any element of the iterable is true.\n                # https://docs.python.org/2/library/functions.html#any\n                # python boolean evaluation comparison\n                if any(node.touches(next_line) for next_line in shply_lines):\n                    continue\n                else:\n                    list_dangles.append(node)\n        return list_dangles\n\n    # convert our Shapely MultiLineString to list\n    list_lines = [line for line in shp1_lines]\n\n    # find those dangles\n    result_dangles = find_dangles(list_lines)\n\n    # return our results\n    if len(result_dangles) >= 1:\n        print \"yes we found some dangles exporting to GeoJSON\"\n        out_geoj(result_dangles, '../geodata/dangles.geojson')\n    else:\n        print \"no dangles found\"\n    ```", "```py\n    #!/usr/bin/env python\n    # -*- coding: utf-8 -*-\n    from utils import shp2_geojson_obj\n    from utils import create_shply_multigeom\n    from utils import out_geoj\n\n    in_shp_lines = \"../geodata/topo_line.shp\"\n    shp1_data = shp2_geojson_obj(in_shp_lines)\n    shp1_lines = create_shply_multigeom(shp1_data, \"MultiLineString\")\n\n    in_shp_poly = \"../geodata/topo_polys.shp\"\n    ply_geojs_obj = shp2_geojson_obj(in_shp_poly)\n    shply_polys = create_shply_multigeom(ply_geojs_obj, \"MultiPolygon\")\n\n    # nearest point using linear referencing\n    # with interpolation and project\n    # pt_interpolate = line.interpolate(line.project(point))\n\n    # create point centroids from all polygons\n    # measure distance from centroid to nearest line segment\n\n    def within_tolerance(polygons, lines, tolerance):\n        \"\"\"\n        Discover if all polygon centroids are within a distance of a linestring\n        data set, if not print out centroids that fall outside tolerance\n        :param polygons: list of polygons\n        :param lines: list of linestrings\n        :param tolerance: value of distance in meters\n        :return: list of all points within tolerance\n        \"\"\"\n\n        # create our centroids for each polygon\n        list_centroids = [x.centroid for x in polygons]\n\n        # list to store all of our centroids within tolerance\n        good_points = []\n\n        for centroid in list_centroids:\n            for line in lines:\n                # calculate point location on line nearest to centroid\n                pt_interpolate = line.interpolate(line.project(centroid))\n                # determine distance between 2 cartesian points\n                # that are less than the tolerance value in meters\n                if centroid.distance(pt_interpolate) > tolerance:\n                    print \"to far  \" + str(centroid.distance(pt_interpolate))\n                else:\n                    print \"hey your in  \" + str(centroid.distance(pt_interpolate))\n                    good_points.append(centroid)\n\n        if len(good_points) > 1:\n            return good_points\n        else:\n            print \"sorry no centroids found within your tolerance of \" + str(tolerance)\n\n    # run our function to get a list of centroids within tolerance\n    result_points = within_tolerance(shply_polys, shp1_lines, 20000)\n\n    if result_points:\n        out_geoj(result_points, '../geodata/centroids_within_tolerance.geojson')\n    else:\n        print \"sorry cannot export GeoJSON of Nothing\"\n    ```"]