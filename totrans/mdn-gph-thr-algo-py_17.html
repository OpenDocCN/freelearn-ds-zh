<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-157"><a id="_idTextAnchor157" class="pcalibre calibre6 pcalibre1"/>12</h1>
<h1 id="_idParaDest-158" class="calibre5"><a id="_idTextAnchor158" class="pcalibre calibre6 pcalibre1"/>Graph Databases</h1>
<p class="calibre3">In the previous chapters, we’ve considered networks as data structures that we can analyze to extract insight into data science problems. In this chapter, we’ll consider networks as data storage options, linking many pieces of information in a multi-relational way. Many storage options exist but we’ll focus on an open source option that integrates well with<a id="_idIndexMarker533" class="pcalibre calibre6 pcalibre1"/> Python—<strong class="bold">Neo4j</strong>.</p>
<p class="calibre3">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Introduction to graph databases</li>
<li class="calibre11">Querying and modifying data in Neo4j</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll understand the advantages of graph databases to store network science datasets, be able to visualize graph databases and know how to query them for the quick retrieval of relevant information. You’ll feel comfortable modifying tables by insertion and deletion. You’ll understand how the tools in our previous chapters can help you query efficiently to find relevant data. Let’s get started by exploring the rationale behind graph databases.</p>
<h1 id="_idParaDest-159" class="calibre5"><a id="_idTextAnchor159" class="pcalibre calibre6 pcalibre1"/>Introduction to graph databases</h1>
<p class="calibre3"><strong class="bold">Graph databases</strong> (databases <a id="_idIndexMarker534" class="pcalibre calibre6 pcalibre1"/>that store data in network form) offer many advantages over traditional relational databases. First, graph databases can capture and traverse hierarchical relationships. While relational databases can capture taxonomies, they do so in different columns that are not explicitly linked.</p>
<p class="calibre3">In addition, graph databases capture complex relationships between items or groups of items explicitly by connecting them with edges. This allows for multiway relationships to exist within the database; querying for nearest neighbors, for instance, is much easier when neighbors<a id="_idIndexMarker535" class="pcalibre calibre6 pcalibre1"/> are connected<a id="_idIndexMarker536" class="pcalibre calibre6 pcalibre1"/> by an edge and do not require estimation steps to find <strong class="bold">Euclidean</strong> or <strong class="bold">Manhattan distances</strong> between all items in the database.</p>
<p class="calibre3">Furthermore, graph databases can capture the directionality of relationships between items in the database very easily. In a relational database, the directionality of a single relationship may involve several columns’ worth of information to capture that single relationship. Thus, for items with complicated relationships that may be unidirectional, a graph database provides a compact representation of data structure.</p>
<p class="calibre3">Finally, within graph databases, it is possible to mine the dataset for implicit relationships that have not been programmed into the database by using network algorithms to probe for similar patterns in different parts of a network or to infer edges that don’t exist based on triadic closure. For many datasets—such as continuously-growing <em class="italic">-omics</em> datasets, evolving ontologies, or other non-static datasets where knowledge is incomplete—mining the data provides new research avenues.</p>
<p class="calibre3">Now that we know a bit about the advantages of graph databases, let’s dive into specific differences<a id="_idIndexMarker537" class="pcalibre calibre6 pcalibre1"/> between graph databases and relational databases.</p>
<h2 id="_idParaDest-160" class="calibre7"><a id="_idTextAnchor160" class="pcalibre calibre6 pcalibre1"/>What is a graph database?</h2>
<p class="calibre3">Graph databases are databases based on network science. Rather than storing data as columns in a spreadsheet (shown in the following figure), as is done in relational databases, graph databases store data as <em class="italic">networks</em>, with items that would occupy a row represented as a vertex connected to other vertices per relations that exist. Column data is used to either add metadata to the vertex or connect it to other vertices. Graph database queries rely on network science algorithms to traverse the graph, pattern-finding algorithms, and combinations of these two approaches. Thus, queries for graph databases can become quite sophisticated without necessarily leading to a long run-time as subqueries in SQL will require. Efficiency is a big advantage of graph databases. Let’s look at an example of supermarket customer feedback related to customer service or products, shown in <em class="italic">Figure 12</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 12.1 – An example of relational database design, where rows contain items with information organized into columns﻿ (Used with permission from Microsoft Excel)" src="img/B21087_12_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.1 – An example of relational database design, where rows contain items with information organized into columns (Used with permission from Microsoft Excel)</p>
<p class="calibre3"><em class="italic">Figure 12</em><em class="italic">.1</em> shows a relational database with many rows of data that exist as columns. However, this data may be better represented as a graph database, where items relate through the columns or use columns as metadata in a queryable way. Perhaps there are dates attached to<a id="_idIndexMarker538" class="pcalibre calibre6 pcalibre1"/> the comments that could link items by time and use the department related to the complaint as metadata.</p>
<p class="calibre3">While it is difficult to visualize a relational database, visualizing a graph database is much more straightforward. Some graph databases come with built-in visualization tools to zoom into areas of interest or query results. Some allow developers to build on pre-existing visualizations to tailor this feature to their needs. When hovering over edges and vertices, most graph database visualization tools will show metadata associated with a vertex or edge, providing context for the relationships of interest pulled by the query. Cytoscape is one of the most commonly used programs for network visualization at scale; originally, it was constructed to visualize proteomics datasets, where protein interactions are documented across organisms. Here’s Cytoscape with demo images of the example graphs: <a href="https://js.cytoscape.org/" class="pcalibre calibre6 pcalibre1">https://js.cytoscape.org/</a>.</p>
<p class="calibre3">One of the advantages of Cytoscape is its ability to handle saved igraph networks such that analysis of very large networks can be done in Python and then visualized with Cytoscape, where the network size will not complicate visualization as it will with the igraph plotting functions. In addition, Cytoscape offers a desktop version that should work with Java-based devices and a web interface version for those who do not have access to the desktop version. If you are interested, you are encouraged to download Cytoscape and test out its visualization either with the datasets we use in this book or with your own datasets of interest.</p>
<p class="calibre3">Now that we understand the structure and advantages of graph databases, let’s dive into some datasets <a id="_idIndexMarker539" class="pcalibre calibre6 pcalibre1"/>where a graph database may function better than a relational database with respect to organizing the information and retrieving information of interest.</p>
<h2 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor161" class="pcalibre calibre6 pcalibre1"/>What can you represent in a graph database?</h2>
<p class="calibre3">There are many data science domains that can benefit from graph databases. We’ll explore a few of these use cases in depth before diving into coding in one open source graph database. Let’s start with an example from epidemiology.</p>
<h3 class="calibre9">Contact tracing</h3>
<p class="calibre3">When a new epidemic<a id="_idIndexMarker540" class="pcalibre calibre6 pcalibre1"/> starts in an area, epidemiologists often employ a tool <a id="_idIndexMarker541" class="pcalibre calibre6 pcalibre1"/>called <strong class="bold">contact tracing</strong>, where data on each case is collected to connect cases to each other in the hopes of finding the outbreak source, or patient zero. Patient zero often provides insight into the source of the epidemic—whether an animal vector, a laboratory breach, or an environmental disaster. Epidemiologists, then, can pinpoint effective containment policies and monitor potential sources to prevent future outbreaks.</p>
<p class="calibre3">In longer outbreaks where a virus has enough time to mutate, contact tracing allows epidemiologists to study the viral evolution of an outbreak. During the COVID-19 pandemic, we saw many mutations of COVID-19 with different rates of mortality and different symptomologies, some of which did not respond well to current vaccines or treatments to which prior strains had responded. Early identification of new mutations and their geographic sources provides crucial information for quick response across countries and continents.</p>
<p class="calibre3">Let’s consider an example of contact tracing in a new HIV outbreak. Let’s say we are in a mid-sized city with many neighborhoods and subpopulations. Cases have popped up at several testing centers and hospitals over the past two months, and epidemiologists are concerned that the dominant strain in the area has mutated into a much deadlier strain of HIV, threatening the city. Two of the main ways that HIV spreads within a population are sexual contact and sharing syringes when using drugs intravenously; this hypothetical epidemic seems to be largely contained to young populations with high rates of drug use and risky sexual behaviors.</p>
<p class="calibre3">When a case is identified, healthcare providers collect information about others potentially exposed to HIV through sexual contact or syringe sharing such that the person or the provider can inform those exposed that they are at risk of HIV. Positive cases are identified and traced to build a network of exposure. Typically, metadata, such as strain genomics, demographic factors, geographic histories, and exposure routes, is collected and attached to this network to quickly identify the main sources of spreading and populations most at risk given identified case characteristics.</p>
<p class="calibre3">Determining causality is not always straightforward. Oftentimes, cases are missed when individuals do not present with illness or do not get tested regularly. This means cases identified later in<a id="_idIndexMarker542" class="pcalibre calibre6 pcalibre1"/> an epidemic might be sources of infection. <em class="italic">Figure 12</em><em class="italic">.2</em> shows a small piece of a contact tracing network, where cases identified later in the epidemic through contact tracing were infected earlier than the presenting individual (<em class="italic">Case #161</em>):</p>
<div><div><img alt="Figure 12.2 – A small subsection of a contact tracing network" src="img/B21087_12_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.2 – A small subsection of a contact tracing network</p>
<p class="calibre3">In <em class="italic">Figure 12</em><em class="italic">.2</em>, we see <em class="italic">Case #161</em> was identified (likely through a testing center or by seeking medical care). This individual’s contacts revealed infection from <em class="italic">Case #165</em>, who was infected by <em class="italic">Case #173</em>. Contact tracing also revealed another individual infected from <em class="italic">Case #165</em> (<em class="italic">Case #169</em>). Without contact tracing, at least three other cases would have been missed, leading to treatment delays and potentially more exposures and cases. Generally, causality is established through strain analysis and information about the timing of exposures through sexual partners or syringe sharing. These factors are included in the case metadata.</p>
<p class="calibre3">Storing case metadata and causality information in a relational database would be very difficult, as the directionality of infection is critical for studying epidemic evolution over the population and for contacting potential exposures who have not yet been tested (as case contacts can overlap and often do in this type of epidemic). Graph databases allow for efficient storage and retrieval of this information for maximal efficiency of both contact tracing and<a id="_idIndexMarker543" class="pcalibre calibre6 pcalibre1"/> public policy formation to protect those at risk of HIV exposure in this population. Early identification saves people from suffering and, potentially, death.</p>
<h3 class="calibre9">Island ecology study</h3>
<p class="calibre3">Now that we know how <a id="_idIndexMarker544" class="pcalibre calibre6 pcalibre1"/>graph databases improve analytics and outcomes for social science data, let’s consider how graph databases can improve research in conservation. Suppose scientists have identified a new island in a remote area long isolated from mainland populations. <em class="italic">Figure 12</em><em class="italic">.3</em> shows the hypothetical island:</p>
<div><div><img alt="Figure 12.3 – An﻿ illustration of an island long isolated from the mainland" src="img/B21087_12_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.3 – An illustration of an island long isolated from the mainland</p>
<p class="calibre3">On the island shown in <em class="italic">Figure 12</em><em class="italic">.3</em>, we wish to document the flora and fauna that live on that island, as well as the island’s food chains. We’ll collect information on population sizes, predator-prey relationships, and potential threats to those populations and relationships (such as climate change). We may wish to link species into food webs to explore the <a id="_idIndexMarker545" class="pcalibre calibre6 pcalibre1"/>sustainability of food sources given changes in temperature, weather, and sea levels on the island. We may also wish to divide the island into separate ecosystems, which may be isolated in valleys with high cliffs or connected to other ecosystems on the island through migration patterns or habitat overlap. Food webs and overlapping habitat/migration patterns create relationships between population data in our dataset, which naturally lives as a network. We can add metadata to the vertices in our network (species or habitats) or the edges connecting them (such as seasonal information about migration patterns that might connect species from two different habitats periodically).</p>
<p class="calibre3">In this conservation example, we’ll likely have more than one dataset collected. We might have several different food webs from different geographies. We may also have habitat overlap datasets connecting geographies on the island that connect to our food webs, such as metadata on population size estimates, ecosystem health indicators, and seasonal patterns.</p>
<p class="calibre3">Connecting many datasets, some of which include hierarchical relationships, is quite tricky in relational databases; however, it is easy when using graph databases. Different types of edges can connect different vertices in collected networks to link each network and the metadata contained in each network collected. This makes querying and exploring potential relationships that are not explicitly defined (perhaps not collected due to time constraints or difficulty of terrain navigation) much easier for conservationists.</p>
<p class="calibre3">From this data and exploration of its graph database, it is possible to infer and define protected areas on the island in which many food webs connect or are isolated regions with large biodiversity. This protects species from human activities or climate change threats and allows researchers to focus limited funding on monitoring areas critical to the overall ecosystem. In addition, as further expeditions and conservation efforts collect new data, the graph database setup allows researchers to test hypothesized links between ecosystems or food webs that were not directly observed in the first pass expedition.</p>
<p class="calibre3">Now that we<a id="_idIndexMarker546" class="pcalibre calibre6 pcalibre1"/> understand a bit about datasets that will benefit from graph database storage solutions, let’s turn our attention to Neo4j, an open source graph database option.</p>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor162" class="pcalibre calibre6 pcalibre1"/>Querying and modifying data in Neo4j</h1>
<p class="calibre3">Before we start<a id="_idIndexMarker547" class="pcalibre calibre6 pcalibre1"/> using Neo4j, we’ll need to download and install the software on our machines. You can follow this link to reach the Neo4j Desktop download page: <a href="https://neo4j.com/download/" class="pcalibre calibre6 pcalibre1">https://neo4j.com/download/</a>.</p>
<p class="calibre3">You should see a page that looks like this, where you can download Neo4j by clicking on the <strong class="bold">Download</strong> button:</p>
<div><div><img alt="Figure 12.4 – Neo4j download site" src="img/B21087_12_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Neo4j download site</p>
<p class="calibre3">After hitting<a id="_idIndexMarker548" class="pcalibre calibre6 pcalibre1"/> the <strong class="bold">Download</strong> button in <em class="italic">Figure 12</em><em class="italic">.4</em>, you’ll be prompted to follow the installer instructions to complete the installation. When the installer finishes, you’ll see an icon or will have launched Neo4j directly on your machine from the installation process. This should take you to a page that looks like this:</p>
<div><div><img alt="Figure 12.5 – The start page of Neo4j" src="img/B21087_12_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.5 – The start page of Neo4j</p>
<p class="calibre3"><em class="italic">Figure 12</em><em class="italic">.5</em> shows the free Desktop version of Neo4j on a Windows machine.</p>
<p class="callout-heading">Note</p>
<p class="calibre3">There is already an example project ready to explore or query.</p>
<p class="calibre3">We’ll work on<a id="_idIndexMarker549" class="pcalibre calibre6 pcalibre1"/> some basic queries with this data, but if you wish to explore this database prior to querying, click on <strong class="bold">Movie DBMS</strong> and hit the <strong class="bold">Start</strong> button to run the database on your machine; when you finish exploring, make sure to hit the <strong class="bold">Stop</strong> button to cache the database again.</p>
<p class="calibre3">The query language used by Neo4j is<a id="_idIndexMarker550" class="pcalibre calibre6 pcalibre1"/> called <code>Match</code> command functions much like SQL’s <code>SELECT</code> command, and operations such as <code>limit</code> and <code>as</code> also exist in Cypher. However, operations that retrieve directional relationships (edges) between objects in the database (vertices) also exist to query specific types of relationships that might exist. We’ll see more of this in action as we explore the Movie DBMS (database management system) database <a id="_idIndexMarker551" class="pcalibre calibre6 pcalibre1"/>on Neo4j’s Desktop application.</p>
<p class="calibre3">Now, let’s explore Neo4j.</p>
<h2 id="_idParaDest-163" class="calibre7"><a id="_idTextAnchor163" class="pcalibre calibre6 pcalibre1"/>Basic query example</h2>
<p class="calibre3">When you open your<a id="_idIndexMarker552" class="pcalibre calibre6 pcalibre1"/> Neo4j Desktop application, you’ll see an <code>Example Project</code> folder. When you hover over the <strong class="bold">Movie DBMS</strong> label on the right-hand side of the screen, you’ll see a <strong class="bold">Start</strong> button that launches the connection to this database (shown in <em class="italic">Figure 12</em><em class="italic">.6</em>). Click on <strong class="bold">Start</strong>:</p>
<div><div><img alt="Figure 12.6 – The Start button to launch the Movie DBMS database" src="img/B21087_12_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.6 – The Start button to launch the Movie DBMS database</p>
<p class="calibre3">As shown in <em class="italic">Figure 12</em><em class="italic">.6</em>, once you have launched the Movie DBMS database by clicking <code>about-movies.neo4j-browser-guide</code> file option and run through a few examples of queries to become familiar with Cypher’s syntax and results.</p>
<p class="calibre3">You’ll see a page like <em class="italic">Figure 12</em><em class="italic">.7</em> when you click on the <code>about-movies.neo4j-browser-guide</code> file option. The first page shows a basic query pulling data on an actor. Here, we’ll change the actor to <code>Brad Pitt</code> and query the graph for instances of <code>Brad Pitt</code>. When you have the code changed to what is shown in <em class="italic">Figure 12</em><em class="italic">.7</em>, hit the arrow to run the code. Note that you’ll see the default tutorial below the code you write. We aren’t showing this in our Neo4j query images but it will appear on your screen:</p>
<div><div><img alt="Figure 12.7 – A basic Cypher query that searches for Brad Pitt" src="img/B21087_12_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.7 – A basic Cypher query that searches for Brad Pitt</p>
<p class="calibre3">This database does not contain any information about Brad Pitt. Running the suggested query on <code>Tom Hanks</code> does produce information in JSON form, as this data does not contain graph elements. You should see something like <em class="italic">Figure 12</em><em class="italic">.8</em> when you query the<a id="_idIndexMarker553" class="pcalibre calibre6 pcalibre1"/> database for <code>Tom Hanks</code>:</p>
<div><div><img alt="Figure 12.8 – The result of our query for Tom Hanks in Movie DBMS" src="img/B21087_12_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.8 – The result of our query for Tom Hanks in Movie DBMS</p>
<p class="calibre3">Let’s go to the next page of the guide and add an actor to the database. We’ll add Brad Pitt, as our query came back empty initially. <em class="italic">Figure 12</em><em class="italic">.9</em> shows how to add an actor to the database along with their birth year.</p>
<div><div><img alt="Figure 12.9 – Instructions to create an entry for Brad Pitt" src="img/B21087_12_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Instructions to create an entry for Brad Pitt</p>
<p class="calibre3">When we run the code from <em class="italic">Figure 12</em><em class="italic">.9</em>, Neo4j shows us a vertex with Brad Pitt’s information, as seen in <em class="italic">Figure 12</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 12.10 – The result of creating Brad Pitt’s entry" src="img/B21087_12_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.10 – The result of creating Brad Pitt’s entry</p>
<p class="calibre3">We can add a<a id="_idIndexMarker554" class="pcalibre calibre6 pcalibre1"/> movie associated with <code>Brad Pitt</code>, in this case, <code>Seven Years in Tibet</code>, as shown in <em class="italic">Figure 12</em><em class="italic">.11</em>’s code in the top line:</p>
<div><div><img alt="Figure 12.11 – Cypher code to add a movie associated with Brad Pitt" src="img/B21087_12_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Cypher code to add a movie associated with Brad Pitt</p>
<p class="calibre3">When we run this Cypher<a id="_idIndexMarker555" class="pcalibre calibre6 pcalibre1"/> code, we see another graph database vertex appear, as shown in <em class="italic">Figure 12</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 12.12 – The result of running the Cypher query from Figure 12.11" src="img/B21087_12_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.12 – The result of running the Cypher query from Figure 12.11</p>
<p class="calibre3">Just as we can add to our graph database, we can also delete individual records from the database. Let’s delete the records we just created for <code>Brad Pitt</code>. <em class="italic">Figure 12</em><em class="italic">.13</em> shows the deletion of the record for <code>Brad Pitt</code>. I urge you to try deleting <code>Seven Years in Tibet</code> before moving on to the next task in this chapter:</p>
<div><div><img alt="Figure 12.13 – Cypher code to delete the record we created for Brad Pitt" src="img/B21087_12_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Cypher code to delete the record we created for Brad Pitt</p>
<p class="calibre3">We can also create or update a record in the database using the <code>MERGE</code> statement with a <code>CREATE</code> and a <code>MATCH</code> statement to either create a new record or update an existing record (depending on what exists in the database). We’ll add Brad Pitt’s information back into the database using the code shown in <em class="italic">Figure 12</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 12.14 – An updated example in Cypher code" src="img/B21087_12_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.14 – An updated example in Cypher code</p>
<p class="calibre3">When we run the code in <em class="italic">Figure 12</em><em class="italic">.14</em>, we see <em class="italic">Figure 12</em><em class="italic">.9</em> appear again, where Brad Pitt’s<a id="_idIndexMarker556" class="pcalibre calibre6 pcalibre1"/> information has been added to the database. Now that we know some basic Cypher commands, we can move on to more complicated graph database operations in the next section.</p>
<h2 id="_idParaDest-164" class="calibre7"><a id="_idTextAnchor164" class="pcalibre calibre6 pcalibre1"/>More complicated query examples</h2>
<p class="calibre3">Now that we know <a id="_idIndexMarker557" class="pcalibre calibre6 pcalibre1"/>how to execute basic queries, we can move on to more complicated operations in Neo4j, such as adding relationships between items. Let’s connect actors and movies with a Cypher query connecting Brad Pitt to <em class="italic">Seven Years in Tibet</em> through his character, Heinrich Harrer.</p>
<p class="callout-heading">Note</p>
<p class="calibre3">You’ll need to add both the movie and actor back into our database using the code in the <em class="italic">Basic query example</em> section before running this query. This query is shown in <em class="italic">Figure 12</em><em class="italic">.15</em>.</p>
<div><div><img alt="Figure 12.15 – A Cypher query to connect Brad Pitt to his character, Heinrich Harrer, in Seven Years in Tibet " src="img/B21087_12_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.15 – A Cypher query to connect Brad Pitt to his character, Heinrich Harrer, in Seven Years in Tibet</p>
<p class="calibre3">Running this query returns information about the actor, the movie, and the relationship we just created<a id="_idIndexMarker558" class="pcalibre calibre6 pcalibre1"/> between the two datasets, as shown in <em class="italic">Figure 12</em><em class="italic">.16</em>:</p>
<div><div><img alt="Figure 12.16 – The result of Figure 12.15’s Cypher query to connect Brad Pitt to Seven Years in Tibet" src="img/B21087_12_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.16 – The result of Figure 12.15’s Cypher query to connect Brad Pitt to Seven Years in Tibet</p>
<p class="calibre3">The next page of the Neo4j Cypher guide shows an alternative way to create this relationship. You are encouraged to modify that code to add another actor and movie as an exercise. Let’s turn our attention to Cypher’s <code>WHERE</code> clauses, which function much as they do in SQL.</p>
<p class="calibre3">We’ll search for persons whose names start with the first name <code>Brad</code>, which should pull up Brad Pitt’s entry, as well as any other actors whose first name is Brad. <em class="italic">Figure 12</em><em class="italic">.17</em> shows this query:</p>
<div><div><img alt="Figure 12.17 – An example of a WHERE query in Cypher" src="img/B21087_12_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.17 – An example of a WHERE query in Cypher</p>
<p class="calibre3">When we run the Cypher code in <em class="italic">Figure 12</em><em class="italic">.17</em>, we should see two instances of <code>Brad Pitt</code> showing<a id="_idIndexMarker559" class="pcalibre calibre6 pcalibre1"/> up in our database, as shown in <em class="italic">Figure 12</em><em class="italic">.18</em>:</p>
<div><div><img alt="Figure 12.18 – Results from Figure 12.17’s WHERE Cypher query" src="img/B21087_12_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.18 – Results from Figure 12.17’s WHERE Cypher query</p>
<p class="calibre3">We can also match based on relationships, such as finding movies associated with an actor. Let’s try a Cypher query on relationships to find all of the movies associated with Brad Pitt (here, just <code>Seven Years in Tibet</code>, as we added this relationship). <em class="italic">Figure 12</em><em class="italic">.19</em> shows the query we’ll use to query a relationship:</p>
<div><div><img alt="Figure 12.19 – A Cypher query on graph relationships between people and movies" src="img/B21087_12_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.19 – A Cypher query on graph relationships between people and movies</p>
<p class="calibre3">When we run the Cypher query shown in <em class="italic">Figure 12</em><em class="italic">.19</em>, we see the connections between our<a id="_idIndexMarker560" class="pcalibre calibre6 pcalibre1"/> instances of <code>Brad Pitt</code> and <code>Seven Years in Tibet</code> shown in graph form (<em class="italic">Figure 12</em><em class="italic">.20</em>):</p>
<div><div><img alt="Figure 12.20 – The results of Figure 12.19’s graph relationship query" src="img/B21087_12_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.20 – The results of Figure 12.19’s graph relationship query</p>
<p class="calibre3"><em class="italic">Figure 12</em><em class="italic">.20</em> shows the essential strengths of a graph database. We can see relationships that connect different items across tables (here, the <code>Person</code> table and the <code>Movie</code> table), as well as the nature of that relationship. It’s easy to see an actor connected to a movie, and should more movies exist, we’d have an easy visualization of our query results from this graph-based query in Neo4j.</p>
<p class="calibre3">While this movie database contains basic tables and relationships, we can imagine our examples in the <em class="italic">What can you represent in a graph database?</em> section containing much more complicated relationships between many more tables. Visualizing query results in graph form across tables and items in tables provides easy-to-understand summaries of the data and relationships of interest in a query. Herein lies the power of graph databases. Queries tend to be quick, even for queries with many subqueries or when searching very large tables and their relations, and visualizations of results allow users to explore relationships in depth across tables (or provide succinct visuals for a report).</p>
<p class="calibre3">If you wish to explore Neo4j further, Neo4j’s AuraDB allows users to connect to the database through Python by establishing an account and connecting to Neo4j with an API in Python using the <code>neo4j</code> package and <code>GraphDatabase.driver()</code> function to create the connection.</p>
<p class="callout-heading">Note</p>
<p class="calibre3">For any large databases or databases you wish to permanently save, you’ll need a paid account.</p>
<p class="calibre3">Once the database is created, you can query the Neo4j database through Python’s <code>neo4j driver.execute_query()</code> statement and import the data as a network in igraph to analyze the results. This provides a powerful combination of graph storage and graph analysis<a id="_idIndexMarker561" class="pcalibre calibre6 pcalibre1"/> for your analytics projects. If you are interested, you are encouraged to explore Neo4j further and create your own connected projects between igraph and Neo4j’s AuraDB accounts.</p>
<h1 id="_idParaDest-165" class="calibre5"><a id="_idTextAnchor165" class="pcalibre calibre6 pcalibre1"/>Summary</h1>
<p class="calibre3">In this chapter, we examined cases where graph databases are advantageous, familiarized ourselves with an open source graph database called Neo4j, and learned a bit about the query language of Neo4j, called Cypher. We created, deleted, and modified records in a Neo4j movie database. We explored the advantages of querying graph databases and the unique query result visualizations possible with graph databases. If you are interested, I encourage you to consult Cypher and Neo4j resources to dive deeper into what is possible with graph databases.</p>
<p class="calibre3">In the next chapter, we’ll be putting together all of the skills we’ve learned in the book so far to tackle a real-world problem of predicting Ebola outbreak severity over time and geography across regions of the Democratic Republic of Congo.</p>
<h1 id="_idParaDest-166" class="calibre5"><a id="_idTextAnchor166" class="pcalibre calibre6 pcalibre1"/>References</h1>
<p class="calibre3">Adler, M. W., and Johnson, A. M. (1988). <em class="italic">Contact tracing for HIV infection</em>. <em class="italic">British Medical Journal (Clinical research ed.)</em>, <em class="italic">296</em>(6634), 1420.</p>
<p class="calibre3">Angles, R., Arenas, M., Barceló, P., Hogan, A., Reutter, J., and Vrgoč, D. (2017). <em class="italic">Foundations of modern query languages for graph databases</em>. <em class="italic">ACM Computing Surveys (CSUR)</em>, <em class="italic">50</em>(5), 1–40.</p>
<p class="calibre3">Beas-Luna, R., Novak, M., Carr, M. H., Tinker, M. T., Black, A., Caselle, J. E., ... and Iles, A. (2014). <em class="italic">An online database for informing ecological network models</em>: <a href="http://kelpforest" class="pcalibre calibre6 pcalibre1">http://kelpforest</a>. ucsc. edu. <em class="italic">PloS one</em>, <em class="italic">9</em>(10), e109356.</p>
<p class="calibre3">Hyman, J. M., Li, J., and Stanley, E. A. (2003). <em class="italic">Modeling the impact of random screening and contact tracing in reducing the spread of HIV</em>. <em class="italic">Mathematical biosciences</em>, <em class="italic">181</em>(1), 17–54.</p>
<p class="calibre3">Mueller, W., Rudowicz-Nawrocka, J., Otrzasek, J., Idziaszek, P., and Weres, J. (2016). <em class="italic">Spatial data and graph databases for identifying relations among members of cattle herd</em>. <em class="italic">International Multidisciplinary Scientific GeoConference: SGEM</em>, <em class="italic">1</em>, 835–841.</p>
<p class="calibre3">Pasquale, D. K., Doherty, I. A., Leone, P. A., Dennis, A. M., Samoff, E., Jones, C. S., ... and Miller, W. C. (2021). <em class="italic">Lost and found: applying network analysis to public health contact tracing for HIV</em>. <em class="italic">Applied network science</em>, <em class="italic">6</em>, 1–16.</p>
<p class="calibre3">Pokorný, J. (2015). <em class="italic">Graph databases: their power and limitations</em>. In <em class="italic">Computer Information Systems and Industrial Management: 14th IFIP TC 8 International Conference, CISIM 2015, Warsaw, Poland, September 24-26, 2015, Proceedings 14</em> (pp. 58-69). Springer International Publishing.</p>
<p class="calibre3">Robinson, I., Webber, J., and Eifrem, E. (2015). <em class="italic">Graph databases: new opportunities for connected data</em>. O’Reilly Media, Inc..</p>
<p class="calibre3">Shannon, P., Markiel, A., Ozier, O., Baliga, N. S., Wang, J. T., Ramage, D., ... and Ideker, T. (2003). <em class="italic">Cytoscape: a software environment for integrated models of biomolecular interaction networks</em>. <em class="italic">Genome research</em>, <em class="italic">13</em> (11), 2498–2504.</p>
<p class="calibre3">Webber, J. (2012, October). <em class="italic">A programmatic introduction to neo4j</em>. In <em class="italic">Proceedings of the 3rd annual conference on Systems, programming, and applications: software for humanity</em> (pp. 217–218).</p>
</div>
</body></html>