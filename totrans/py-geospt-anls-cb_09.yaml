- en: Chapter 9. Topology Checking and Data Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule – only one point inside a polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A point must be on the starting and ending nodes of a line only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LineStrings must not overlap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LineString must not have dangles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A polygon centroid must be within a specific distance of a line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topology rules allow you to enforce and test spatial relationships between different
    geometry sets. This chapter will build an open source set of topology rules that
    you can run from the command line or integrate in your python programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spatial relationships described by the DE-9IM (Nine Intersect Model) are
    Equals, Disjoint, Intersects, Touches, Crosses, Within, Contains, and Overlaps.
    However, exactly how these are related is something that''s unclear for most beginners.
    We are referring to the interior, boundary, and exterior of our geometry types:
    Point, LineString, and Polygon, which are used directly to perform the topology
    checks. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interior**: This refers to the entire shape except for its boundary. All
    geometry types have interiors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundary**: This refers to the endpoints of all linear parts of line features
    or the linear outline of a polygon. Only lines and polygons have boundaries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exterior**: This refers to the outside area a shape. All geometry types have
    exteriors.![Introduction](img/50790OS_09_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table summarizes the topology geometries in a more formal wording:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Geometric subtypes | Interior (I) | Boundary (B) | Exterior (E) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Point, MultiPoint | point or points | Empty set | Points not in the interior
    or boundary |'
  prefs: []
  type: TYPE_TB
- en: '| LineString, Line | Points that are left when the boundary points are removed
    | Two end Points | Points not in the interior or boundary |'
  prefs: []
  type: TYPE_TB
- en: '| LinearRing | All Points along the LinearRing | Empty set | Points not in
    the interior or boundary |'
  prefs: []
  type: TYPE_TB
- en: '| MultiLineString | Points that are left when the boundary points are removed
    | Those Points that are in the boundaries of an odd number of its element Curves
    | Points not in the interior or boundary |'
  prefs: []
  type: TYPE_TB
- en: '| Polygon | Points within the Rings | Set of Rings | Points not in the interior
    or boundary |'
  prefs: []
  type: TYPE_TB
- en: '| MultiPolygon | Points within the Rings | Set of Rings of its Polygons | Points
    not in the interior or boundary |'
  prefs: []
  type: TYPE_TB
- en: The definitions of the interior, boundary, and exterior of the main geometry
    types are described by the **Open Geospatial Consortium** (**OGC**).
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipes, we will explore some custom topology rules that you
    could apply to any project, laying the groundwork for you to create your own set
    of rules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule – only one point inside a polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A long time ago in GIS history, not having more than one point present in a
    polygon was super important because one point per polygon was the standard way
    to demonstrate a topologically clean polygon with its associated attribute and
    ID. Today, it is still important for many other reasons, such as assigning attributes
    to polygons based on points inside a polygon. We must perform a spatial join between
    the polygon and point to assign these valuable attributes. If two points are located
    in one polygon, which attributes do you use? This recipe is about creating a rule
    to check your data beforehand to ensure that only one point is located in each
    polygon. If this test fails, you will get a list or errors; if it passes, the
    test returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a rule – only one point inside a polygon](img/50790OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data again plays the central role here, so check that your `/ch09/geodata/`
    folder is ready with two input Shapefiles containing `topo_polys.shp` and `topo_points.shp`.
    The Shapely library performs the geometry topology testing. If you have followed
    along so far, you have it installed already; if not, install it now by referring
    to [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"),
    *Setting Up Your Geospatial Python Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now check to see if each polygon contains a point as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This ends the practical test using two input Shapefiles. Now for your testing
    pleasure, here is a simple unit test to break things down for a simple point in
    polygon tests. The following test code is located in the `ch09/code/ch09-01_single_pt_test_in_poly.py`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This simple test should run nicely. If you feel like breaking it to see what
    happens, change the last call to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have lots of things to test to determine whether there's only one point inside
    the polygon. We'll start with what is defined as inside and not inside. Looking
    back at the introduction to this chapter, a polygon interior, exterior, and boundary
    can be logically defined. The position of our input points is then explicitly
    defined as a point that lies within a polygon, excluding points that are located
    on the polygon boundary, edge, or vertex. Plus, our added criterion is that only
    one point per polygon is allowed, thus giving errors if `0` or more points fall
    inside any given polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Our spatial predicates include touches to find out whether the point is on the
    vertex or edge. If touches returns `True`, our point is located on the edge or
    vertex, which means that it is not inside. This is followed by the `contains`
    method that checks whether the point is inside our polygon. Here, we check to
    see that there's no more than one point inside our polygon.
  prefs: []
  type: TYPE_NORMAL
- en: The code works through importing and converting a Shapefile for processing performed
    by the `Shapely` module. As we process our polygons, we create a couple of lists
    to track what kind of relationship is found between them so that we can sum them
    up at the end, allowing us to count if zero or more than one point is inside a
    single polygon.
  prefs: []
  type: TYPE_NORMAL
- en: Our last bit of code then runs through a series of simple function calls, testing
    out the several scenarios relative to whether a point is inside the polygon or
    not. The final call runs through the Shapefiles with multiple polygons and points
    in a more realistic test. This then returns either `True` if no errors are found
    or it returns a GeoJSON printout, showing you where the errors are located.
  prefs: []
  type: TYPE_NORMAL
- en: A point must be on the starting and ending nodes of a line only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A routing network of connected edges may contain some routing logic associated
    with the intersections of roads that are represented as points. These points must,
    of course, be exactly located at the start or end of a line in order to identify
    these junctions. Once the junctions are found, various rules can be applied in
    the attributes to control your routing, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical example would be turn restrictions that could be modeled as points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A point must be on the starting and ending nodes of a line only](img/50790OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our handy `utils.py` module located in the `trunk` folder helps us out with
    the mundane tasks of importing a Shapefile and converting it to a Shapely geometry
    object for us to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create our point check code like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can attack this problem in a number of different ways. This method may not
    be very efficient but demonstrates how to go about solving a spatial problem.
  prefs: []
  type: TYPE_NORMAL
- en: Our logic begins with creating a function to find all the true start and end
    node locations of our input LineString. Shapely helps us out with some simple
    lists by slicing to get us the first and last coordinate pair for each of our
    lines. These two sets are then combined into a single list holder for all our
    nodes to check against.
  prefs: []
  type: TYPE_NORMAL
- en: The second function actually does the check to see whether our point is located
    on either the start or end node in our master list. We begin by creating the master
    list of start and end nodes for comparison by calling our first function. Now,
    if our input has more than one point, we loop through each point and check several
    spatial relationships. The only two that are of any real interest are disjoint
    and intersects. These deliver our answer by showing us which points are good and
    which are not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The within predicate could also be used instead of the intersect, but was not
    chosen simply because it is not always understood properly by beginners, while
    intersects seem to be easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining checks simply export the list of bad and good points to a GeoJSON
    file that you can open in QGIS to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: LineStrings must not overlap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overlapping lines are hard to find usually because you cannot see them on a
    map. They might be deliberate, for example, bus route network lines that might
    overlap. This exercise sets out to discover these overlapping lines for better
    or for worse.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows a set of two input LineStrings and you can see clearly
    where they overlap, but this is a cartographic visual inspection. We need this
    to work on many, many lines that you cannot always see as clearly.
  prefs: []
  type: TYPE_NORMAL
- en: '![LineStrings must not overlap](img/50790OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s dive into the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overlapping LineStrings are sometimes desirable and sometimes not. In this code,
    you can make some simple adjustments and have them report either situation in
    the form of GeoJSON. The default case is to output a GeoJSON file showing the
    overlapping LineStrings.
  prefs: []
  type: TYPE_NORMAL
- en: We begin the journey with the boilerplate code to convert our Shapefiles to
    Shapely geometries so that we can use our spatial relation predicates to filter
    out our overlaps. We only need two predicate equals and within to find what we
    are looking for. If we use intersects, these might return a false positive since
    both `crosses()` and `touches()` are also checked.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could also use the intersects predicate that is equivalent to the OR-ing
    of `contains()`, `crosses()`, `equals()`, `touches()`, and `within()` as stated
    in the Shapely online documentation at [http://toblerity.org/shapely/manual.html#object.intersects](http://toblerity.org/shapely/manual.html#object.intersects).
  prefs: []
  type: TYPE_NORMAL
- en: A LineString must not have dangles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dangles are like cul-de-sac (roads). You can find them only in LineStrings where
    a line ends and does not connect to another line segment. "To dangle in the air"
    refers to a LineString that is not connected to any other LineString. These are
    very important to identify if you are looking to ensure that a road network is
    connected or to identify where streets come together as they should.
  prefs: []
  type: TYPE_NORMAL
- en: A more technical description of a dangle could be described as an edge that
    has one or both ends that are not incidental to another edge endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![A LineString must not have dangles](img/50790OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now check for dangles on your set of LineStrings as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding dangles is easy at first glance, but this is really a little more involved
    than one might think. So, for clarity's sake, let's explain some logic in dangle
    identification as pseudo code.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are not a part of Dangle logic:'
  prefs: []
  type: TYPE_NORMAL
- en: If the start nodes of two different lines are equal, it is not a dangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the end nodes of two different lines are equal, it is not a dangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the start node of one line is equal to the end node of the other line, it
    is not a dangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the end node of one line is equal to the start node of the other line, it
    is not a dangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we need to loop over each LineString and compare the start and end points
    from one LineString to the next, checking if they touch each other using `touches()`
    from Shapely. If they do touch, we move on to the next comparison without breaking
    the use of `continue`. It moves to the else section and here we will catch those
    nice dangles and append them to the dangles list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then only left with one last fun decision: to print out confirmation
    that we have no dangles or export the dangles to a GeoJSON fine for some visual
    inspection.'
  prefs: []
  type: TYPE_NORMAL
- en: A polygon centroid must be within a specific distance of a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check that each polygon centroid is within a distance tolerance to a LineString.
    An example use case for such a rule could be for a routing network that defines
    the snap tolerance in meters from a room centroid to the nearest routing networkline.
    This line must be located within a certain distance; otherwise, no route can be
    generated, for example. The following screenshot shows the use of some dummy polygons
    and LineStrings, indicating the centroids that fall within our set tolerance of
    20000 m in red. These are polygons that are spread far apart from Venice to Vienna:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're up for some algorithm reading material, this is a nice read by Paul
    Bourke at [http://paulbourke.net/geometry/pointlineplane/](http://paulbourke.net/geometry/pointlineplane/).
  prefs: []
  type: TYPE_NORMAL
- en: '![A polygon centroid must be within a specific distance of a line](img/50790OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code will now automatically find centroids outside your distance tolerance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our boilerplate starter code brings in a polygon and a LineString Shapefile
    so that we can calculate our centroids and shortest distances. The main logic
    here is that we need to first create a list of centroids for each polygon, and
    then find the nearest point location on a line to this centroid. Of course, the
    last step is to get the distance between these two points in meters and check
    if it is less than our specified tolerance value.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the comments explain the details, but the actual shortest distance to
    the line is accomplished using the linear referencing feature of Shapely. We have
    encountered this process in [Chapter 5](ch05.html "Chapter 5. Vector Analysis"),
    *Vector Analysis*, using our snap point to a line. The `interpolate` and `project`
    functions do the heavy lifting to find the nearest point on the line.
  prefs: []
  type: TYPE_NORMAL
- en: This, as usual, is followed up by exporting our results to GeoJSON if any points
    are found with the specified tolerance value.
  prefs: []
  type: TYPE_NORMAL
