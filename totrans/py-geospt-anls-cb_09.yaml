- en: Chapter 9. Topology Checking and Data Validation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 拓扑检查和数据验证
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a rule – only one point inside a polygon
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建规则 - 多边形内只有一个点
- en: A point must be on the starting and ending nodes of a line only
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个点必须位于线的起始和结束节点上
- en: LineStrings must not overlap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线字符串不得重叠
- en: A LineString must not have dangles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线字符串不得有悬垂线
- en: A polygon centroid must be within a specific distance of a line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多边形质心必须位于线的一定距离内
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Topology rules allow you to enforce and test spatial relationships between different
    geometry sets. This chapter will build an open source set of topology rules that
    you can run from the command line or integrate in your python programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑规则允许你强制执行和测试不同几何集之间的空间关系。本章将构建一个开源的拓扑规则集，你可以从命令行运行或将其集成到你的Python程序中。
- en: 'The spatial relationships described by the DE-9IM (Nine Intersect Model) are
    Equals, Disjoint, Intersects, Touches, Crosses, Within, Contains, and Overlaps.
    However, exactly how these are related is something that''s unclear for most beginners.
    We are referring to the interior, boundary, and exterior of our geometry types:
    Point, LineString, and Polygon, which are used directly to perform the topology
    checks. These are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DE-9IM（九相交模型）描述的空间关系包括等于、不相交、相交、接触、交叉、包含、包含于和重叠。然而，这些关系的确切联系对于大多数初学者来说并不明确。我们指的是我们的几何类型（点、线字符串和多边形）的内部、边界和外部，这些类型直接用于执行拓扑检查。具体如下：
- en: '**Interior**: This refers to the entire shape except for its boundary. All
    geometry types have interiors.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：这指的是整个形状除了其边界之外的部分。所有几何类型都有内部。'
- en: '**Boundary**: This refers to the endpoints of all linear parts of line features
    or the linear outline of a polygon. Only lines and polygons have boundaries.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界**：这指的是线特征所有线性部分的端点或多边形的线性轮廓。只有线和多边形有边界。'
- en: '**Exterior**: This refers to the outside area a shape. All geometry types have
    exteriors.![Introduction](img/50790OS_09_01.jpg)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：这指的是形状的外部区域。所有几何类型都有外部。[介绍](img/50790OS_09_01.jpg)'
- en: 'The following table summarizes the topology geometries in a more formal wording:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下表以更正式的措辞总结了拓扑几何：
- en: '| Geometric subtypes | Interior (I) | Boundary (B) | Exterior (E) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 几何子类型 | 内部（I） | 边界（B） | 外部（E） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Point, MultiPoint | point or points | Empty set | Points not in the interior
    or boundary |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 点、多点 | 点或多个点 | 空集 | 不在内部或边界内的点 |'
- en: '| LineString, Line | Points that are left when the boundary points are removed
    | Two end Points | Points not in the interior or boundary |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 线字符串、线 | 移除边界点后留下的点 | 两个端点 | 不在内部或边界内的点 |'
- en: '| LinearRing | All Points along the LinearRing | Empty set | Points not in
    the interior or boundary |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 线性环 | 线性环上的所有点 | 空集 | 不在内部或边界内的点 |'
- en: '| MultiLineString | Points that are left when the boundary points are removed
    | Those Points that are in the boundaries of an odd number of its element Curves
    | Points not in the interior or boundary |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 多线字符串 | 移除边界点后留下的点 | 其元素曲线边界中的奇数个点 | 不在内部或边界内的点 |'
- en: '| Polygon | Points within the Rings | Set of Rings | Points not in the interior
    or boundary |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 多边形 | 环内的点 | 环集 | 不在内部或边界内的点 |'
- en: '| MultiPolygon | Points within the Rings | Set of Rings of its Polygons | Points
    not in the interior or boundary |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 多多边形 | 环内的点 | 其多边形的环集 | 不在内部或边界内的点 |'
- en: The definitions of the interior, boundary, and exterior of the main geometry
    types are described by the **Open Geospatial Consortium** (**OGC**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 主几何类型（如多边形、边界和外部）的定义由**开放地理空间联盟**（**OGC**）描述。
- en: In the following recipes, we will explore some custom topology rules that you
    could apply to any project, laying the groundwork for you to create your own set
    of rules.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们将探讨一些可以应用于任何项目的自定义拓扑规则，为你创建自己的规则集打下基础。
- en: Creating a rule – only one point inside a polygon
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建规则 - 多边形内只有一个点
- en: A long time ago in GIS history, not having more than one point present in a
    polygon was super important because one point per polygon was the standard way
    to demonstrate a topologically clean polygon with its associated attribute and
    ID. Today, it is still important for many other reasons, such as assigning attributes
    to polygons based on points inside a polygon. We must perform a spatial join between
    the polygon and point to assign these valuable attributes. If two points are located
    in one polygon, which attributes do you use? This recipe is about creating a rule
    to check your data beforehand to ensure that only one point is located in each
    polygon. If this test fails, you will get a list or errors; if it passes, the
    test returns `True`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在GIS历史很久以前，多边形内不出现多于一个点非常重要，因为一个多边形一个点是展示具有相关属性和ID的拓扑干净多边形的标准方式。今天，它对于许多其他原因仍然很重要，例如根据多边形内的点分配属性。我们必须在多边形和点之间执行空间连接来分配这些宝贵的属性。如果两个点位于一个多边形内，你将使用哪些属性？这个配方是关于创建一个规则来检查你的数据，以确保每个多边形内只有一个点。如果这个测试失败，你将得到一个错误列表；如果它通过，测试将返回`True`。
- en: '![Creating a rule – only one point inside a polygon](img/50790OS_09_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![创建规则 - 多边形内只有一个点](img/50790OS_09_02.jpg)'
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Data again plays the central role here, so check that your `/ch09/geodata/`
    folder is ready with two input Shapefiles containing `topo_polys.shp` and `topo_points.shp`.
    The Shapely library performs the geometry topology testing. If you have followed
    along so far, you have it installed already; if not, install it now by referring
    to [Chapter 1](ch01.html "Chapter 1. Setting Up Your Geospatial Python Environment"),
    *Setting Up Your Geospatial Python Environment*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在这里再次扮演着核心角色，所以请检查你的`/ch09/geodata/`文件夹是否已准备好，包含两个包含`topo_polys.shp`和`topo_points.shp`的输入Shapefiles。Shapely库执行几何拓扑测试。如果你到目前为止一直跟着做，那么你已经安装了它；如果没有，现在通过参考[第1章](ch01.html
    "第1章。设置你的地理空间Python环境")，*设置你的地理空间Python环境*来安装它。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You will now check to see if each polygon contains a point as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在将检查每个多边形是否包含一个点，方法如下：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This ends the practical test using two input Shapefiles. Now for your testing
    pleasure, here is a simple unit test to break things down for a simple point in
    polygon tests. The following test code is located in the `ch09/code/ch09-01_single_pt_test_in_poly.py`
    file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这结束了使用两个输入Shapefiles的实践测试。现在为了你的测试乐趣，这里有一个简单的单元测试，用于分解简单的点在多边形中的测试。以下测试代码位于`ch09/code/ch09-01_single_pt_test_in_poly.py`文件中：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple test should run nicely. If you feel like breaking it to see what
    happens, change the last call to the following:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个简单的测试应该能正常运行。如果你想要破坏它来查看会发生什么，请将最后的调用更改为以下内容：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This results in the following output:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have lots of things to test to determine whether there's only one point inside
    the polygon. We'll start with what is defined as inside and not inside. Looking
    back at the introduction to this chapter, a polygon interior, exterior, and boundary
    can be logically defined. The position of our input points is then explicitly
    defined as a point that lies within a polygon, excluding points that are located
    on the polygon boundary, edge, or vertex. Plus, our added criterion is that only
    one point per polygon is allowed, thus giving errors if `0` or more points fall
    inside any given polygon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多事情要测试，以确定多边形内是否只有一个点。我们将从定义的内部和外部开始。回顾本章的介绍，多边形的内部、外部和边界可以逻辑地定义。然后，我们明确地定义输入点的位置，即位于多边形内部且不在多边形边界、边或顶点上的点。此外，我们添加的准则是一个多边形只允许一个点，因此如果有`0`个或更多点位于任何给定的多边形内，将会产生错误。
- en: Our spatial predicates include touches to find out whether the point is on the
    vertex or edge. If touches returns `True`, our point is located on the edge or
    vertex, which means that it is not inside. This is followed by the `contains`
    method that checks whether the point is inside our polygon. Here, we check to
    see that there's no more than one point inside our polygon.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的空间谓词包括接触以确定点是否在顶点或边上。如果接触返回`True`，则我们的点位于边或顶点上，这意味着它不在内部。这之后是`contains`方法，它检查点是否在我们的多边形内。在这里，我们检查多边形内是否没有超过一个点。
- en: The code works through importing and converting a Shapefile for processing performed
    by the `Shapely` module. As we process our polygons, we create a couple of lists
    to track what kind of relationship is found between them so that we can sum them
    up at the end, allowing us to count if zero or more than one point is inside a
    single polygon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过导入和转换 Shapefile 来处理 `Shapely` 模块执行的处理。当我们处理多边形时，我们创建几个列表来跟踪它们之间发现的关系类型，以便我们可以在最后将它们加起来，这样我们就可以计算是否有一个或多个点在单个多边形内部。
- en: Our last bit of code then runs through a series of simple function calls, testing
    out the several scenarios relative to whether a point is inside the polygon or
    not. The final call runs through the Shapefiles with multiple polygons and points
    in a more realistic test. This then returns either `True` if no errors are found
    or it returns a GeoJSON printout, showing you where the errors are located.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的代码段运行一系列简单的函数调用，测试点是否在多边形内部或外部的几个场景。最后的调用通过具有多个多边形和点的 Shapefiles 进行更现实的测试。这会返回
    `True` 如果没有发现错误，或者返回一个 GeoJSON 打印输出，显示错误的位置。
- en: A point must be on the starting and ending nodes of a line only
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个点必须只位于线的起始和结束节点上
- en: A routing network of connected edges may contain some routing logic associated
    with the intersections of roads that are represented as points. These points must,
    of course, be exactly located at the start or end of a line in order to identify
    these junctions. Once the junctions are found, various rules can be applied in
    the attributes to control your routing, for example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由连接边组成的路由网络可能包含一些与表示为点的道路交点相关的路由逻辑。当然，这些点必须精确地位于线的起始或结束位置，以便识别这些交叉口。一旦找到交叉口，可以在属性中应用各种规则来控制你的路由，例如。
- en: 'A typical example would be turn restrictions that could be modeled as points:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子是将转弯限制建模为点：
- en: '![A point must be on the starting and ending nodes of a line only](img/50790OS_09_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![一个点必须只位于线的起始和结束节点上](img/50790OS_09_03.jpg)'
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Our handy `utils.py` module located in the `trunk` folder helps us out with
    the mundane tasks of importing a Shapefile and converting it to a Shapely geometry
    object for us to work with.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们方便的 `utils.py` 模块位于 `trunk` 文件夹中，它帮助我们处理一些日常任务，例如导入 Shapefile 并将其转换为 Shapely
    几何对象，以便我们进行处理。
- en: 'Now let''s create our point check code like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建点检查代码如下：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You can attack this problem in a number of different ways. This method may not
    be very efficient but demonstrates how to go about solving a spatial problem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种不同的方法来解决这个问题。这种方法可能不是非常高效，但它演示了如何解决空间问题。
- en: Our logic begins with creating a function to find all the true start and end
    node locations of our input LineString. Shapely helps us out with some simple
    lists by slicing to get us the first and last coordinate pair for each of our
    lines. These two sets are then combined into a single list holder for all our
    nodes to check against.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的逻辑从创建一个函数开始，用于找到输入 LineString 的所有真实起始和结束节点位置。Shapely 通过切片帮助我们获取每条线的第一个和最后一个坐标对，从而提供一些简单的列表。然后，这两个集合被合并成一个单独的列表持有者，以便检查所有节点。
- en: The second function actually does the check to see whether our point is located
    on either the start or end node in our master list. We begin by creating the master
    list of start and end nodes for comparison by calling our first function. Now,
    if our input has more than one point, we loop through each point and check several
    spatial relationships. The only two that are of any real interest are disjoint
    and intersects. These deliver our answer by showing us which points are good and
    which are not.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数实际上执行检查，以确定我们的点是否位于主列表中的起始或结束节点。我们首先通过调用第一个函数来创建起始和结束节点的主列表，以便进行比较。现在，如果我们的输入有多个点，我们将遍历每个点并检查几个空间关系。其中只有两个真正有趣，那就是不相交和相交。这些通过显示哪些点是好的，哪些不是，来给出我们的答案。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The within predicate could also be used instead of the intersect, but was not
    chosen simply because it is not always understood properly by beginners, while
    intersects seem to be easier to understand.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 within 语句代替 intersect，但之所以没有选择它，仅仅是因为它并不总是被初学者正确理解，而 intersects 似乎更容易理解。
- en: The remaining checks simply export the list of bad and good points to a GeoJSON
    file that you can open in QGIS to visualize.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的检查只是将不良和良好点的列表导出到一个 GeoJSON 文件中，您可以在 QGIS 中打开它来可视化。
- en: LineStrings must not overlap
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LineStrings 不能重叠
- en: Overlapping lines are hard to find usually because you cannot see them on a
    map. They might be deliberate, for example, bus route network lines that might
    overlap. This exercise sets out to discover these overlapping lines for better
    or for worse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠的线通常很难找到，因为你无法在地图上看到它们。它们可能是故意的，例如，可能重叠的公交线路。这项练习旨在发现这些重叠的线，无论好坏。
- en: The following diagram shows a set of two input LineStrings and you can see clearly
    where they overlap, but this is a cartographic visual inspection. We need this
    to work on many, many lines that you cannot always see as clearly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了两组输入线字符串，你可以清楚地看到它们重叠的地方，但这是一种地图学的视觉检查。我们需要在许多你无法如此清晰地看到的线路上工作。
- en: '![LineStrings must not overlap](img/50790OS_09_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![线字符串不能重叠](img/50790OS_09_04.jpg)'
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s dive into the code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们深入代码：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Overlapping LineStrings are sometimes desirable and sometimes not. In this code,
    you can make some simple adjustments and have them report either situation in
    the form of GeoJSON. The default case is to output a GeoJSON file showing the
    overlapping LineStrings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠的线字符串有时是可取的，有时则不然。在这段代码中，你可以做一些简单的调整，并以GeoJSON的形式报告这两种情况。默认情况下，输出显示重叠线字符串的GeoJSON文件。
- en: We begin the journey with the boilerplate code to convert our Shapefiles to
    Shapely geometries so that we can use our spatial relation predicates to filter
    out our overlaps. We only need two predicate equals and within to find what we
    are looking for. If we use intersects, these might return a false positive since
    both `crosses()` and `touches()` are also checked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从将我们的Shapefiles转换为Shapely几何形状的样板代码开始，这样我们就可以使用我们的空间关系谓词来过滤掉重叠的部分。我们只需要两个谓词等于和包含来找到我们想要的东西。如果我们使用相交，这些可能会返回假阳性，因为`crosses()`和`touches()`也被检查了。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We could also use the intersects predicate that is equivalent to the OR-ing
    of `contains()`, `crosses()`, `equals()`, `touches()`, and `within()` as stated
    in the Shapely online documentation at [http://toblerity.org/shapely/manual.html#object.intersects](http://toblerity.org/shapely/manual.html#object.intersects).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用与`contains()`、`crosses()`、`equals()`、`touches()`和`within()`的OR运算等效的`intersects`谓词，如Shapely在线文档[http://toblerity.org/shapely/manual.html#object.intersects](http://toblerity.org/shapely/manual.html#object.intersects)中所述。
- en: A LineString must not have dangles
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线字符串不能有悬垂
- en: Dangles are like cul-de-sac (roads). You can find them only in LineStrings where
    a line ends and does not connect to another line segment. "To dangle in the air"
    refers to a LineString that is not connected to any other LineString. These are
    very important to identify if you are looking to ensure that a road network is
    connected or to identify where streets come together as they should.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 悬垂就像死胡同（道路）。你只能在一条线结束且不连接到另一段线的情况下找到它们。"悬在空中"指的是不连接到任何其他线字符串的线字符串。如果你想要确保道路网络是连通的，或者要确定街道应该如何汇合的地方，这些非常重要。
- en: A more technical description of a dangle could be described as an edge that
    has one or both ends that are not incidental to another edge endpoint.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 悬垂的更技术性的描述可以是这样一个边缘，其一个或两个端点不是另一个边缘端点的附属。
- en: '![A LineString must not have dangles](img/50790OS_09_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![线字符串不能有悬垂](img/50790OS_09_05.jpg)'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You will now check for dangles on your set of LineStrings as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在将按照以下方式检查你的线字符串集中的悬垂：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Finding dangles is easy at first glance, but this is really a little more involved
    than one might think. So, for clarity's sake, let's explain some logic in dangle
    identification as pseudo code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始看，找到悬垂很容易，但实际上这比人们想象的要复杂一些。因此，为了清楚起见，让我们用伪代码解释一些悬垂识别的逻辑。
- en: 'These are not a part of Dangle logic:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是悬垂逻辑的一部分：
- en: If the start nodes of two different lines are equal, it is not a dangle
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两条不同线的起始节点相等，则这不是悬垂
- en: If the end nodes of two different lines are equal, it is not a dangle
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两条不同线的端节点相等，则这不是悬垂
- en: If the start node of one line is equal to the end node of the other line, it
    is not a dangle
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一条线的起始节点等于另一条线的结束节点，则这不是悬垂
- en: If the end node of one line is equal to the start node of the other line, it
    is not a dangle
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一条线的端节点等于另一条线的起始节点，则这不是悬垂
- en: So, we need to loop over each LineString and compare the start and end points
    from one LineString to the next, checking if they touch each other using `touches()`
    from Shapely. If they do touch, we move on to the next comparison without breaking
    the use of `continue`. It moves to the else section and here we will catch those
    nice dangles and append them to the dangles list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要遍历每个 LineString，并比较一个 LineString 的起始点和结束点与下一个 LineString 的起始点和结束点，使用
    Shapely 的 `touches()` 方法检查它们是否接触。如果它们接触，我们继续下一个比较而不使用 `break`。它移动到 `else` 部分，在这里我们将捕获那些漂亮的悬垂线并将其追加到悬垂线列表中。
- en: 'We are then only left with one last fun decision: to print out confirmation
    that we have no dangles or export the dangles to a GeoJSON fine for some visual
    inspection.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只剩下最后一个有趣的决策：打印出我们没有任何悬垂线的确认，或者将悬垂线导出到 GeoJSON 以供视觉检查。
- en: A polygon centroid must be within a specific distance of a line
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个多边形的质心必须位于一条线的一定距离范围内
- en: 'Check that each polygon centroid is within a distance tolerance to a LineString.
    An example use case for such a rule could be for a routing network that defines
    the snap tolerance in meters from a room centroid to the nearest routing networkline.
    This line must be located within a certain distance; otherwise, no route can be
    generated, for example. The following screenshot shows the use of some dummy polygons
    and LineStrings, indicating the centroids that fall within our set tolerance of
    20000 m in red. These are polygons that are spread far apart from Venice to Vienna:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个多边形的质心是否在到 LineString 的距离容差范围内。这种规则的一个示例用例可能是为路由网络定义从房间质心到最近路由网络线的捕捉容差（以米为单位）。这条线必须位于一定距离内；否则，无法生成路线，例如。以下截图显示了使用一些虚拟多边形和
    LineString 的应用，用红色表示位于我们设定的 20000 米容差范围内的质心。这些多边形从威尼斯到维也纳分布得很远：
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're up for some algorithm reading material, this is a nice read by Paul
    Bourke at [http://paulbourke.net/geometry/pointlineplane/](http://paulbourke.net/geometry/pointlineplane/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一些算法阅读材料，Paul Bourke 在 [http://paulbourke.net/geometry/pointlineplane/](http://paulbourke.net/geometry/pointlineplane/)
    提供了一篇不错的阅读材料。
- en: '![A polygon centroid must be within a specific distance of a line](img/50790OS_09_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![一个多边形的质心必须位于一条线的一定距离范围内](img/50790OS_09_06.jpg)'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何去做...
- en: 'This code will now automatically find centroids outside your distance tolerance:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码现在将自动找到距离容差范围外的质心：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our boilerplate starter code brings in a polygon and a LineString Shapefile
    so that we can calculate our centroids and shortest distances. The main logic
    here is that we need to first create a list of centroids for each polygon, and
    then find the nearest point location on a line to this centroid. Of course, the
    last step is to get the distance between these two points in meters and check
    if it is less than our specified tolerance value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样板起始代码引入了一个多边形和一个 LineString Shapefile，这样我们就可以计算我们的质心和最短距离。这里的逻辑主要是我们需要首先为每个多边形创建一个质心列表，然后找到离这个质心最近的线上的点位置。当然，最后一步是计算这两个点之间的距离（以米为单位），并检查它是否小于我们指定的容差值。
- en: Most of the comments explain the details, but the actual shortest distance to
    the line is accomplished using the linear referencing feature of Shapely. We have
    encountered this process in [Chapter 5](ch05.html "Chapter 5. Vector Analysis"),
    *Vector Analysis*, using our snap point to a line. The `interpolate` and `project`
    functions do the heavy lifting to find the nearest point on the line.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数注释解释了细节，但实际计算到线的最短距离是使用 Shapely 的线性引用功能完成的。我们在 [第5章](ch05.html "第5章. 向量分析")
    的 *向量分析* 中遇到了这个过程，使用我们的捕捉点到线。`interpolate` 和 `project` 函数负责找到线上的最近点。
- en: This, as usual, is followed up by exporting our results to GeoJSON if any points
    are found with the specified tolerance value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会接着导出我们的结果到 GeoJSON，如果找到了具有指定容差值的任何点。
