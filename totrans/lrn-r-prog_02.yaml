- en: Chapter 2. Basic Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 基本对象
- en: 'The first step of learning R programming is getting familiar with basic R objects
    and their behavior. In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习R编程的第一步是熟悉基本R对象及其行为。在本章中，您将学习以下主题：
- en: Creating and subsetting atomic vectors (for example, numeric vectors, character
    vectors, and logical vectors), matrices, arrays, lists, and data frames.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和子集原子向量（例如，数值向量、字符向量和逻辑向量）、矩阵、数组、列表和数据框。
- en: Defining and working with functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用函数
- en: '*"Everything that exists is an object. Everything that happens is a function."
    -- John Chambers*'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “存在的一切都是对象。发生的一切都是函数。” —— 约翰·查普曼*
- en: For example, in statistical analysis, we often feed a set of data to a linear
    regression model and obtain a group of linear coefficients.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在统计分析中，我们经常将一组数据输入到线性回归模型中，并得到一组线性系数。
- en: Provided that there are different types of objects in R, when we do this, what
    basically happens in R is that we provide a data frame object that holds the set
    of data, carry it to the linear model function and get a list object consisting
    of the properties of the regression results, and finally extract a numeric vector,
    which is another type of object, from the list to represent the linear coefficients.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设R中有不同类型的对象，当我们这样做时，在R中基本上发生的事情是，我们提供一个包含数据集的数据框对象，将其传递给线性模型函数，并得到一个包含回归结果属性的列表对象，最后从列表中提取一个数值向量，这是另一种类型的对象，用来表示线性系数。
- en: Every task involves various different types of objects. Each object has a different
    goal and behavior. It's important to understand how a basic object works in order
    to solve real-world problems, especially with more elegant code and fewer steps.
    More importantly, a more concrete understanding of object behavior allows you
    to spend more time on working out the solution to your problem than on getting
    stuck by countless minor problems while producing the right code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每项任务都涉及各种不同类型的对象。每个对象都有不同的目标和行为。为了解决现实世界的问题，特别是用更优雅的代码和更少的步骤，理解基本对象的工作方式非常重要。更重要的是，对对象行为的更具体理解，让您有更多时间来解决您的问题，而不是在编写正确代码时被无数的小问题所困扰。
- en: In the following sections, we will see a variety of basic objects in R that
    represent different types of data and make it easy to analyze and visualize datasets.
    You will have a basic understanding of how these objects work and how they interact
    with each other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将看到R中代表不同类型数据的基本对象，这些对象使得分析和可视化数据集变得容易。您将基本了解这些对象是如何工作的以及它们之间是如何相互作用的。
- en: Vector
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: A vector is a group of primitive values of the same type. It can be a group
    of numbers, true/false values, texts, and values of some other type. It is one
    of the building blocks of all R objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一组相同类型的原始值。它可以是一组数字、真/假值、文本或其他类型的值。它是所有R对象的基本构建块之一。
- en: There are several types of vectors in R. They are distinct from each other in
    the type of elements they store. In the following sections, we will see the most
    commonly used types of vectors including numeric vectors, logical vectors, and
    character vectors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: R中有几种不同类型的向量。它们在存储的元素类型上彼此不同。在以下章节中，我们将看到最常用的向量类型，包括数值向量、逻辑向量和字符向量。
- en: Numeric vector
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值向量
- en: 'A numeric vector is a vector of numeric values. A scalar number is the simplest
    numeric vector. An example is shown as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数值向量是数值值的向量。一个标量数是最简单的数值向量。以下是一个示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A numeric vector is the most frequently used data type and is the foundation
    of nearly all kinds of data analysis. In other popular programming languages,
    there are some scalar types such as integer, double, and string, and these scalar
    types are the building blocks of the container types such as vectors. In R, however,
    there is no formal definition of scalar types. A scalar number is only a special
    case of numeric vector, and it's special only because its length is 1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数值向量是最常用的数据类型，是几乎所有数据分析的基础。在其他流行的编程语言中，有一些标量类型，如整数、双精度和字符串，这些标量类型是容器类型（如向量）的构建块。然而，在R中，没有正式的标量类型定义。标量数只是数值向量的一个特殊情况，它之所以特殊，仅仅是因为它的长度为1。
- en: 'When we create a value, it is natural to think of how to store it for future
    use. To store the value, we can use `<-` to assign the value to a symbol. In other
    words, we create a variable named `x` of the value `1.5`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个值时，自然会想到如何将其存储起来以供将来使用。为了存储值，我们可以使用 `<-` 将值赋给一个符号。换句话说，我们创建了一个名为 `x`
    的值为 `1.5` 的变量：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, the value is assigned to symbol `x`, and we can use `x` to represent
    the value from now on:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，值被赋给符号 `x`，从现在起我们可以使用 `x` 来表示这个值：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are multiple ways to create a numeric vector. We can call `numeric()`
    to create a zero vector of a given length:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数值向量的方法有多种。我们可以调用 `numeric()` 来创建给定长度的零向量：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also use `c()` to combine several vectors to make one vector. The simplest
    case is, for example, to combine several single-element vectors to be a multi-element
    vector:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `c()` 来组合几个向量，使其成为一个向量。最简单的情况是，例如，将几个单元素向量组合成一个多元素向量：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also combine a mixture of single-element vectors and multi-element vectors
    and obtain a vector with the same elements as we previously created:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以组合单元素向量和多元素向量，并得到一个与我们之前创建的具有相同元素的向量：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To create a series of consecutive integers, the `:` operator will easily do
    the trick.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一系列连续的整数，`:` 运算符可以轻松完成这个任务。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Precisely speaking, the preceding code produces an integer vector instead of
    a numeric vector. In many cases, their difference is not that important. We will
    cover this topic later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，前面的代码生成的是一个整数向量，而不是数值向量。在许多情况下，它们的区别并不重要。我们将在后面讨论这个话题。
- en: 'A more general way to produce a numeric sequence is `seq()`. For example, the
    following code produces a numeric vector of a sequence from 1 to 10 by increment
    2:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成数值序列的更通用方法是 `seq()`。例如，以下代码通过增量 2 生成从 1 到 10 的数值向量：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Functions like `seq()` have many arguments. We can call such a function by supplying
    all the arguments, but it is not necessary in most cases. Most functions provide
    reasonable default values for some arguments, which makes it easier for us to
    call them. In this case, we only need to specify the argument that we would like
    to modify from its default value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `seq()` 的函数有很多参数。我们可以通过提供所有参数来调用这样的函数，但在大多数情况下并不需要。大多数函数为某些参数提供了合理的默认值，这使得我们更容易调用它们。在这种情况下，我们只需要指定我们想要从其默认值修改的参数。
- en: 'For example, we can create another numeric vector that starts from `3` with
    the length `10` by specifying the `length.out` argument:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过指定 `length.out` 参数来创建一个从 `3` 开始长度为 `10` 的另一个数值向量：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A function call like the above uses a named argument `length.out` so that other
    arguments are kept default and only this argument is modified.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上面的函数调用使用命名参数 `length.out`，这样其他参数保持默认值，只修改这个参数。
- en: 'There are many ways in which we can define numeric vectors, but we should always
    be careful when we use `:`, an example is shown as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义数值向量的方式有很多，但我们在使用 `:` 时应该始终小心，以下是一个示例：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the result shows, `1 + 1:5` does not mean a sequence from `2` to `5`, but
    from `2` to `6`. It is because `:` has higher priority than `+`, which results
    in evaluating `1:5` first and adding `1` to each entry, yielding the sequence
    you see in the result. We will cover the priority of operators later.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如结果所示，`1 + 1:5` 并不表示从 `2` 到 `5` 的序列，而是从 `2` 到 `6`。这是因为 `:` 的优先级高于 `+`，导致首先计算
    `1:5`，然后将 `1` 加到每个元素上，得到结果中看到的序列。我们将在后面讨论运算符的优先级。
- en: Logical vector
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑向量
- en: In contrast to numeric vectors, a logical vector stores a group of `TRUE` or `FALSE`
    values. They are basically yes or no to denote the answers to a group of logical
    questions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与数值向量不同，逻辑向量存储了一组 `TRUE` 或 `FALSE` 值。它们基本上是针对一组逻辑问题的“是”或“否”的回答。
- en: 'The simplest logical vectors are `TRUE` and `FALSE` themselves:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的逻辑向量就是 `TRUE` 和 `FALSE` 本身：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A more usual way to obtain a logical vector is to ask logical questions about
    R objects. For example, we can ask R whether 1 is greater than 2:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 获取逻辑向量的更常见方式是询问 R 对象的逻辑问题。例如，我们可以询问 R 是否 1 大于 2：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The answer is yes, represented by `TRUE.` Sometimes, it is verbose to write `TRUE`
    and `FALSE`; so, we can use `T` as an abbreviation for `TRUE` and `F` for `FALSE`.
    If we want to perform multiple comparisons at the same time, we can directly use
    numeric vectors in the question:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，用 `TRUE` 表示。有时，写 `TRUE` 和 `FALSE` 有点啰嗦；因此，我们可以用 `T` 作为 `TRUE` 的缩写，用 `F`
    作为 `FALSE` 的缩写。如果我们想同时进行多个比较，我们可以直接在问题中使用数值向量：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: R interprets this expression as the element-wise comparison between `c(1, 2)`
    and `2`. In other words, it is equivalent to `c(1 > 2, 2 > 2)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: R 将此表达式解释为 `c(1, 2)` 和 `2` 的逐元素比较。换句话说，它等同于 `c(1 > 2, 2 > 2)`。
- en: 'We can compare two multi-element numeric vectors as long as the length of the
    longer vector is a multiple of that of the shorter one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 只要较长向量的长度是较短向量长度的倍数，我们就可以比较两个多元素数值向量：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code is equivalent to `c(1 > 2, 2 > 1)`. To demonstrate how two
    vectors of different lengths are compared, see the following example::'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码等同于 `c(1 > 2, 2 > 1)`。为了演示不同长度的向量是如何比较的，请看以下示例：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This may confuse you a bit. The computing mechanism recycles the shorter vector
    and works like `c(2 > 1, 3 > 2, 2 > -1, 3 > 3)`. More specifically, the shorter
    vector will by recycled to finish all the comparisons for each element in the
    longer vector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你有些困惑。计算机制会回收较短的向量，并像 `c(2 > 1, 3 > 2, 2 > -1, 3 > 3)` 一样工作。更具体地说，较短的向量将被回收以完成较长向量中每个元素的比较。
- en: 'In R, several logical binary operators are defined, such as `==` to denote equality, `>` for
    greater-than, `>=` for greater-or-equals-to, `<` for less-than, and `<=` for less-than-or-equals-to.
    Moreover, R provides some other additional logical operators like `%in%` to tell
    whether each element in the left-hand side vector is contained by the right-hand
    side vector:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，定义了几个逻辑二元运算符，例如 `==` 表示相等，`>` 表示大于，`>=` 表示大于等于，`<` 表示小于，以及 `<=` 表示小于等于。此外，R
    还提供了一些其他附加的逻辑运算符，如 `%in%`，用于判断左侧向量中的每个元素是否包含在右侧向量中：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may notice that all the equality operators perform recycling but `%in%`
    does not. Instead, it always works by iterating over the vector on the left and
    works like `c(1 %in% c(1, 2, 3), 4 %in% c(1, 2, 3))` in the preceding example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，所有相等运算符都执行回收，但 `%in%` 不执行。相反，它总是通过迭代左边的向量来工作，就像前面的例子中的 `c(1 %in% c(1,
    2, 3), 4 %in% c(1, 2, 3))`。
- en: Character vector
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符向量
- en: 'A character vector is a group of strings. Here, a character does not mean literally
    a single letter or symbol in a language, but it means a string like `this is a
    string`. Both double quotation marks and single quotation mark, can be used to
    create a character vector, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 字符向量是一组字符串。在这里，字符并不意味着在语言中字面上是一个单独的字母或符号，而是指像 `this is a string` 这样的字符串。双引号和单引号都可以用来创建字符向量，如下所示：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also use the combine function `c()` to construct a multi-element character
    vector:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组合函数 `c()` 来构建一个多元素字符向量：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use `==` to tell whether two vectors have equal values in corresponding
    positions; this applies to character vectors too:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `==` 来判断两个向量在对应位置上的值是否相等；这也适用于字符向量：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The character vectors are equal because `"` and `''` both work to create a
    string and do not affect its value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字符向量相等，因为 `"` 和 `"` 都用于创建字符串，并且不影响其值：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous expression yields both `FALSE` because neither `Hello` nor `World` 
    equals `Hello, World`. The only difference between the two quotation marks is
    the behavior when you create a string containing quotation marks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的表达式返回 `FALSE`，因为 `Hello` 和 `World` 都不等于 `Hello, World`。两个引号之间的唯一区别在于创建包含引号的字符串时的行为。
- en: If you use `"` to create a string (a single-element character vector) containing `"`
    itself, you need to type `"` to escape `"` inside the string to prevent the interpreter
    from regarding `"` in the string as the close quotation mark of the string.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `"` 创建一个包含 `"` 本身的字符串（一个单元素字符向量），你需要输入 `"` 来转义字符串中的 `"`，以防止解释器将字符串中的 `"`
    视为字符串的结束引号。
- en: 'The following examples demonstrate the escaping of quotation marks. The code
    uses `cat()` to print the given text:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了引号的转义。代码使用 `cat()` 打印给定的文本：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you feel that this is not easy to read, you may well use `''` to create
    the string, which can be easier:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这不容易阅读，你可以很好地使用 `'` 来创建字符串，这可能更容易：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In other words, `"` allows `'` in the string without escaping, and `'` allows `"`
    in the string without escaping.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`"` 允许在字符串中包含 `"` 而无需转义，而 `"` 允许在字符串中包含 `"` 而无需转义。
- en: Now we know the basic things about creating numeric vectors, logical vectors, and
    character vectors. In fact, we also have complex vectors and raw vectors in R.
    Complex vectors are vectors of complex values, such as `c(1 + 2i, 2 + 3i)`. Raw
    vectors basically store raw binary data that is represented in the hexadecimal
    form. These two types of vectors are much less frequently used, but they share
    many behaviors with the three types of vectors we have covered.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了创建数值向量、逻辑向量和字符向量的基本知识。实际上，在R中我们还有复数向量和原始向量。复数向量是复数值的向量，例如`c(1 + 2i,
    2 + 3i)`。原始向量基本上存储原始二进制数据，以十六进制形式表示。这两种类型的向量使用得较少，但它们与我们已经覆盖的三种类型的向量共享许多行为。
- en: In the next section, you will learn several ways to access part of a vector.
    By subsetting vectors, you should begin to understand how different types of vectors
    can be related to each other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习几种访问向量一部分的方法。通过子集向量，你应该开始理解不同类型的向量如何相互关联。
- en: Subsetting vectors
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子集向量
- en: If we want to access some specific entries or a subset of a vector, subsetting
    a vector means accessing some specific entries or a subset of the vector. In this
    section, we'll demonstrate various ways to subset a vector.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要访问一些特定的条目或向量的一个子集，对向量进行子集操作意味着访问向量的一些特定条目或其子集。在本节中，我们将演示各种对向量进行子集操作的方法。
- en: 'First, we create a simple numeric vector and assign it to `v1`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个简单的数值向量并将其赋值给`v1`：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each of the following lines gets a specific subset of `v1`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都获取`v1`的一个特定子集。
- en: 'For example, we can get the second element:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以获取第二个元素：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can get the second to fourth elements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取第二个到第四个元素：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can get all elements except the third one:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取除了第三个元素之外的所有元素：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The patterns are clear—we can put any numeric vector inside the square brackets
    after the vector to extract a corresponding subset:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是清晰的——我们可以在向量后面的方括号中放入任何数值向量以提取相应的子集：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All the preceding examples perform subsetting by position, that is, we get
    a subset of a vector by specifying the positions of elements. Using negative numbers
    will exclude those elements. One thing to notice is that you can''t use positive
    numbers and negative numbers together:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述示例都是通过位置进行子集操作，也就是说，我们通过指定元素的位置来获取向量的一个子集。使用负数将排除这些元素。需要注意的一点是，你不能同时使用正数和负数：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What if we subset the vector using positions beyond the range of the vector?
    The following example tries to get a subset of `v1` from the third element to
    the nonexisting sixth element:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用超出向量范围的索引来子集向量，会怎样呢？以下示例尝试从第三个元素到不存在的第六个元素获取`v1`的子集：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, the nonexisting positions end up in missing values represented
    by NA. In real-world data, missing values are common. The good part is that all
    arithmetic calculations with NA also result in NA for consistency. On the other
    hand, however, it takes extra effort to deal with data because it may not be safe
    to assume that the data contains no missing values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，不存在的位置最终以缺失值表示，用NA表示。在现实世界的数据中，缺失值很常见。好处是，所有与NA进行的算术计算也会得到NA，以保证一致性。然而，另一方面，处理数据需要额外的努力，因为不能安全地假设数据中不包含缺失值。
- en: 'Another way to subset a vector is using logical vectors. We can supply an equal-length
    logical vector to determine whether each entry should be extracted:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种子集向量的方法是使用逻辑向量。我们可以提供一个等长的逻辑向量来决定每个条目是否应该被提取：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'More than subsetting, we can overwrite a specific subset of a vector like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了子集之外，我们还可以像这样覆盖向量的一个特定子集：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this case, `v1` becomes the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`v1`变为以下形式：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also overwrite multiple elements at different positions at the same
    time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以同时覆盖不同位置上的多个元素：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, v1 becomes the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`v1`变为以下形式：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Like subsetting, logical selectors are also accepted for overwriting:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与子集类似，逻辑选择器也可以用于覆盖：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you may expect, `v1` becomes the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，`v1`变为以下形式：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A useful implication of this operation is selecting entries by logical criterion.
    For example, the following code picks out all elements that are not greater than
    `2` in `v1`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的用途之一是按照逻辑标准选择条目。例如，以下代码挑选出所有在`v1`中不大于`2`的元素：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A more complex selection criterion also works. The following example picks
    out all elements of `v1` that satisfy *x² - x + 1 > 0* :'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的选择标准也适用。以下示例挑选出所有满足`x² - x + 1 > 0`的`v1`元素：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To replace all entries that satisfy `x <= 2` with `0`, we can call the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要将所有满足 `x <= 2` 的条目替换为 `0`，我们可以调用以下代码：
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may expect, `v1` becomes the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，`v1` 变成了以下内容：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we overwrite the vector at a nonexisting entry, the vector will automatically
    expand with the unassigned value being NA as missing values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个不存在的条目上覆盖向量，向量将自动扩展，未分配的值作为缺失值 `NA`：
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Named vectors
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名向量
- en: 'A named vector is not a specific type of vector parallel to a numeric or logical
    vector. It is a vector with names corresponding to the elements. We can give names
    to a vector when we create it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 命名向量不是与数值向量或逻辑向量平行的特定类型的向量。它是一个具有与元素对应的名称的向量。我们可以在创建向量时为其命名：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we can access the elements with a single-valued character vector:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用单值字符向量访问元素：
- en: '[PRE42]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can also get multiple elements with a character vector:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符向量获取多个元素：
- en: '[PRE43]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the character vector has duplicate elements, the selection will result in
    selecting duplicate elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符向量有重复的元素，选择将导致选择重复的元素：
- en: '[PRE44]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In addition to this, all other operations to a vector also perfectly work for
    named vectors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对向量进行的所有其他操作也完全适用于命名向量。
- en: 'We can get the names of a vector with `names()`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `names()` 函数获取向量的名称：
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The names of a vector are not fixed. We can change the names of a vector by
    assigning another character vector to its names.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的名称不是固定的。我们可以通过将另一个字符向量赋给其名称来更改向量的名称。
- en: '[PRE46]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the names are no longer needed, we can simply remove the vector''s names
    using NULL, a special object that represents undefined value:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要名称，我们可以简单地使用 NULL（一个表示未定义值的特殊对象）来移除向量的名称：
- en: '[PRE47]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may wonder what happens when the name does not exist at all. Let''s experiment
    with the original `x` value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道当名称根本不存在时会发生什么。让我们用原始的 `x` 值进行实验：
- en: '[PRE48]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'By intuition, accessing a nonexisting element should produce an error. However,
    the result is not an error but a vector of a single missing value with a missing
    name:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据直觉，访问一个不存在的元素应该会产生错误。然而，结果不是一个错误，而是一个包含单个缺失值的向量，并且具有缺失的名称：
- en: '[PRE49]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you provide a character vector in which some names exist but others do not,
    the resulting vector will preserve the length of the selection vector:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个包含一些名称但其他名称不存在的字符向量，结果向量将保留选择向量的长度：
- en: '[PRE50]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Extracting an element
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取元素
- en: While `[]` creates a subset of a vector, `[[]]` extracts an element from a vector.
    A vector is like ten boxes of candy, `[]` gets you three boxes of candy, but `[[]]`
    opens a box and gets you a candy from it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `[]` 创建向量的子集，但 `[[]]` 从向量中提取一个元素。向量就像十盒糖果，`[]` 可以让你得到三盒糖果，但 `[[]]` 打开一盒并从中得到一颗糖果。
- en: 'For simple vectors, using `[]` and `[[]]` to get one element will produce the
    same result. However, in some cases, they have different behaviors. For example,
    subsetting a named vector using one entry and extracting an element from it will
    produce different results:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单向量，使用 `[]` 和 `[[]]` 获取一个元素会产生相同的结果。然而，在某些情况下，它们有不同的行为。例如，使用单个条目对命名向量进行子集操作和从中提取元素将产生不同的结果：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The metaphor of candy boxes makes it easier to understand. The `x["a"]` argument
    gives you the box of candy labeled `"a"`, while `x[["a"]]` gives you the candy
    in the box labeled `"a"`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 糖果盒的比喻使理解更容易。`x["a"]` 参数给你标有 `"a"` 的糖果盒，而 `x[["a"]]` 给你标有 `"a"` 的盒子中的糖果。
- en: 'Since `[[]]` only extracts one element, it does not work with vectors of more
    than one element:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `[[]]` 只提取一个元素，因此它不适用于包含多个元素的向量：
- en: '[PRE52]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Also, it does not work with negative integers meaning excluding elements at
    certain positions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它不适用于负整数，这意味着排除特定位置的元素：
- en: '[PRE53]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We already know that subsetting a vector with a nonexisting position or name
    will produce missing values. However, `[[]]` simply does not work when we extract
    an element with a position beyond the range, nor does it work with a nonexisting
    name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，使用不存在的位置或名称对向量进行子集操作会产生缺失值。然而，当我们使用超出范围的索引提取元素时，`[[]]` 简单地不起作用，与不存在的名称一起使用时也不起作用：
- en: '[PRE54]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For many beginners, it may be confusing to see both `[[]]` and `[]` used in
    the code and it is easy to misuse them. Just remember the metaphor of the candy
    boxes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多初学者来说，看到代码中同时使用 `[[]]` 和 `[]` 可能会感到困惑，并且很容易误用它们。只需记住糖果盒的比喻。
- en: Telling the class of vectors
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别向量的类别
- en: 'Sometimes we need to tell which kind of vector we are dealing with before taking
    an action. The `class()` function tells us the class of any R object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在采取行动之前我们需要知道我们正在处理哪种类型的向量。`class()` 函数告诉我们任何 R 对象的类别：
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we need to ensure that an object is indeed a vector of a specific class,
    we can use `is.numeric`, `is.logical`, `is.character`, and some other functions
    with similar names:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要确保一个对象确实是一个特定类别的向量，我们可以使用 `is.numeric`、`is.logical`、`is.character` 和一些具有类似名称的其他函数：
- en: '[PRE56]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Converting vectors
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量转换
- en: Different classes of vectors can be coerced to a specific class of vector. For
    example, some data are string representation of numbers, such as `1` and `20`.
    If we leave these strings as they are, we won't be able to perform numeric calculations
    with them. Fortunately, these two strings can be converted to numeric vectors.
    This will make R regard them as numbers rather than strings so that we can do
    the math with them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类别的向量可以被强制转换为特定类别的向量。例如，一些数据是数字的字符串表示，如 `1` 和 `20`。如果我们保留这些字符串不变，我们就无法用它们进行数值计算。幸运的是，这两个字符串可以被转换为数值向量。这将使
    R 将它们视为数字而不是字符串，这样我们就可以用它们进行数学运算。
- en: 'To demonstrate a typical conversion, we first create a character vector:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个典型的转换，我们首先创建一个字符向量：
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As I mentioned, strings cannot be used to do maths directly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，字符串不能直接用于数学运算：
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can use `as.numeric()` to convert the character vector to a numeric vector:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `as.numeric()` 将字符向量转换为数值向量：
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can do maths with numbers:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用数字进行数学运算：
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Similar to `is.*` functions (for example, `is.numeric`, `is.logical`, and `is.character`)
    that check the class of a given object, we can use the `as.*` function family
    to convert a vector from its original class to another:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与检查给定对象类别的 `is.*` 函数（例如，`is.numeric`、`is.logical` 和 `is.character`）类似，我们可以使用
    `as.*` 函数族将向量从其原始类别转换为另一个类别：
- en: '[PRE61]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It seems that each type of vector can be somehow converted to all other types.
    However, the conversion follows a set of rules.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来每种类型的向量都可以以某种方式转换为所有其他类型。然而，转换遵循一套规则。
- en: The first line in the preceding block of code attempts to convert the character
    vector to a numeric vector, just as we did in the previous example. Obviously,
    the last element `a` cannot be converted to a number. The conversion is done except
    for the last element, so a missing value is produced instead.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块中的第一行尝试将字符向量转换为数值向量，就像我们在上一个例子中所做的那样。显然，最后一个元素 `a` 无法转换为数字。转换除了最后一个元素之外都已完成，因此产生了缺失值。
- en: As for converting a numeric vector to a logical vector, the rule is that only
    `0` corresponds to `FALSE` and all non-zero numbers will produce `TRUE`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将数值向量转换为逻辑向量，规则是只有 `0` 对应于 `FALSE`，所有非零数字都将产生 `TRUE`。
- en: 'Each kind of vector can be converted to a character vector since everything
    has a character representation. However, if a numeric vector or a logical vector
    is coerced to a character vector, it cannot be directly involved in the arithmetic
    operations with other numeric or logical vectors unless it is converted back.
    That is why the following code does not work, as I have just mentioned:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的向量都可以转换为字符向量，因为一切都有字符表示。然而，如果数值向量或逻辑向量被强制转换为字符向量，除非转换回，否则它不能直接参与与其他数值或逻辑向量的算术运算。这就是为什么以下代码不起作用，正如我刚才提到的：
- en: '[PRE62]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: From the preceding examples, I have stressed that although R does not impose
    strong typing rules, it does not mean that R is smart enough to do exactly what
    you want it to do automatically. In most cases, it is better to ensure that the
    type of vectors are correct in computations; otherwise, an unexpected error will
    occur. In other words, only when you get the right type of data objects can you
    do the right math.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我强调虽然 R 不强制类型规则，但这并不意味着 R 足够智能，可以自动执行你想要的精确操作。在大多数情况下，最好确保在计算中向量的类型是正确的；否则，可能会发生意外的错误。换句话说，只有当你得到正确的数据对象类型时，你才能进行正确的数学运算。
- en: Arithmetic operators for numeric vectors
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值向量的算术运算符
- en: 'The arithmetic operations of numeric vectors are very simple. They basically
    follow two rules: Computing in an element-wise manner and recycling the shorter
    vector. The following examples demonstrate the behavior of the operators working
    with numeric vectors:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数值向量的算术运算非常简单。它们基本上遵循两个规则：逐元素计算和回收较短的向量。以下示例演示了运算符与数值向量一起工作的行为：
- en: '[PRE63]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Although vectors can have names, the operations do not function with corresponding
    names. Only the names of vectors on the left-hand side will remain and the names
    of those on the right-hand side will be ignored:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管向量可以有名称，但操作并不与相应的名称一起使用。只有左侧向量的名称将保留，而右侧向量的名称将被忽略：
- en: '[PRE64]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We saw some basic behaviors of numeric vectors, logical vectors, and character
    vectors. They are the most commonly used data structures and are the building
    blocks of a wide variety of other useful objects. One of them is matrix, which
    is intensively used in the formulation of statistical and econometric theories,
    and it is very useful in representing two-dimensional data and solving linear
    systems. In the next chapter, we will see how we can create a matrix in R and
    how it is deeply rooted in vectors.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了数值向量、逻辑向量和字符向量的基本行为。它们是最常用的数据结构，是各种其他有用对象的构建块之一。其中之一是矩阵，它在统计和计量经济学理论的制定中得到了广泛的应用，并且在表示二维数据和解决线性系统中非常有用。在下一章中，我们将看到如何在
    R 中创建矩阵以及它与向量的深厚联系。
- en: Matrix
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: A matrix is a vector represented and accessible in two dimensions. Therefore,
    what applies to vectors is most likely to apply to a matrix. For example, each
    type of vector (for example, numeric vector or logical vectors) has its matrix
    version, that is, there are numeric matrices, logical matrices, and so on.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个在二维中表示和可访问的向量。因此，适用于向量的东西很可能也适用于矩阵。例如，每种类型的向量（例如，数值向量或逻辑向量）都有其矩阵版本，即存在数值矩阵、逻辑矩阵等等。
- en: Creating a matrix
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建矩阵
- en: 'We can call `matrix()` to create a matrix from a vector by setting up one of
    its two dimensions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置其两个维度之一来使用 `matrix()` 从向量创建矩阵：
- en: '[PRE65]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'By specifying `ncol = 3`, we mean that the provided vector should be regarded
    as a matrix with 3 columns (and 3 rows automatically). You may feel the original
    vector is not as straightforward as its representation. To make the code more
    user-friendly, we can write the vector in multiple lines:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`ncol = 3`，我们的意思是提供的向量应被视为一个有3列（和自动的3行）的矩阵。你可能觉得原始向量并不像它的表示那样直接。为了使代码更易于用户使用，我们可以将向量写成多行：
- en: '[PRE66]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Often, we may need to create a diagonal matrix. Here, `diag()` is the most
    handy way to do this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可能需要创建一个对角矩阵。在这里，`diag()` 是完成此操作最方便的方法：
- en: '[PRE67]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Naming rows and columns
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名行和列
- en: 'By default, creating a matrix does not automatically give names to its rows
    and columns. Sometimes, it is useful and straightforward to do so when different
    rows and columns have different meanings. We can give row names and/or column
    names when creating the matrix:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，创建矩阵不会自动为其行和列命名。有时，当不同的行和列有不同的含义时，这样做是有用且直接的。在创建矩阵时，我们可以给出行名称和/或列名称：
- en: '[PRE68]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Alternatively, we can use row names and/or column names after the matrix is
    created:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在矩阵创建后使用行名称和/或列名称：
- en: '[PRE69]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we encounter two new things: a list and a type of function, such as `rownames(x)
    <-`. We will discuss them later in this chapter.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们遇到了两个新事物：一个列表和一种函数类型，例如 `rownames(x) <-`。我们将在本章后面讨论它们。
- en: Subsetting a matrix
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵子集
- en: Just as we deal with vectors, we need not only create matrices but also extract
    data from a matrix. This is called **matrix subsetting**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们处理向量一样，我们不仅需要创建矩阵，还需要从矩阵中提取数据。这被称为**矩阵子集**。
- en: Note that a matrix is a vector that is represented and accessible in two dimensions;
    we not only view a matrix in two dimensions, but also access it with a two-dimensional
    accessor `[,]`, which is quite similar to the one-dimensional accessor, `[]` ,
    for subsetting vectors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，矩阵是一个在二维中表示和可访问的向量；我们不仅以二维的方式查看矩阵，还使用二维访问器 `[,]` 来访问它，这与用于子集向量的单维访问器 `[]`
    非常相似。
- en: To use it, we can supply two vectors for each dimension to determine a subset
    of a matrix. The first argument in the square bracket is the row selector, and
    the second is the column selector. As we tried in subsetting vectors, we can use
    numeric vectors, logical vectors, and character vectors in the two dimensions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们可以为每个维度提供两个向量以确定矩阵的子集。方括号中的第一个参数是行选择器，第二个是列选择器。正如我们在子集向量中所尝试的那样，我们可以在两个维度中使用数值向量、逻辑向量和字符向量。
- en: 'The following code demonstrates the various ways to subset the following matrix:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了以下矩阵的多种子集方法：
- en: '[PRE70]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can extract only one element in the first row and the second column:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只提取第一行和第二列中的一个元素：
- en: '[PRE71]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can subset it with a range of positions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一系列位置来对其进行子集操作：
- en: '[PRE72]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If one dimension is left blank, all the values in that dimension will be selected:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个维度留空，则将选择该维度中的所有值：
- en: '[PRE73]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Negative numbers exclude positions in a subsetting matrix, which is exactly
    the same as working with vectors:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 负数在子集矩阵中排除位置，这与处理向量完全相同：
- en: '[PRE74]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that the matrix has row names and column names, and we can use character
    vectors to subset it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，矩阵有行名和列名，我们可以使用字符向量来对其进行子集操作：
- en: '[PRE75]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Note again that a matrix is a vector represented and accessible in two dimensions;
    however, it is still a vector in its nature. This allows us to use a one-dimensional
    accessor for vectors to subset a matrix:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，矩阵是一个在二维中表示和可访问的向量；然而，本质上它仍然是一个向量。这允许我们使用一维访问器来对矩阵进行子集操作：
- en: '[PRE76]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Since a vector only contains entries of the same type, so does a matrix. Therefore,
    their operations are quite similar. If you type an inequality, it will return
    another logical matrix of equal size:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量只包含相同类型的条目，矩阵也是如此。因此，它们的操作非常相似。如果你输入一个不等式，它将返回另一个大小相同的逻辑矩阵：
- en: '[PRE77]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can use an equal-sized logical matrix for subsetting as if it is a vector:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用大小相等的逻辑矩阵进行子集操作，就像它是向量一样：
- en: '[PRE78]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Using matrix operators
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用矩阵运算符
- en: 'All arithmetic operators for vectors also work with matrices as if they were
    vectors. These operators perform calculations element-wise, except for matrix-only
    operators, such as matrix product,  `%*%`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的所有算术运算符也可以与矩阵一起使用，就像它们是向量一样。这些运算符逐元素执行计算，除了矩阵特有的运算符，如矩阵乘法 `%*%`：
- en: '[PRE79]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can also transpose a matrix using `t()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `t()` 来转置矩阵：
- en: '[PRE80]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Vectors and matrices are sufficient for many use cases. However, some particular
    problems need a data structure with even higher dimensions. In this next section,
    we will briefly introduce arrays and you will see how these data structures share
    similar behaviors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和矩阵对于许多用例来说已经足够了。然而，一些特定的问题需要更高维度的数据结构。在下一节中，我们将简要介绍数组，并展示这些数据结构如何具有相似的行为。
- en: Array
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a natural extension to a matrix in its number of dimensions. More
    specifically, an array is a vector that is represented and accessible in a given
    number of dimensions (mostly more than two dimensions).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是矩阵在维度数量上的自然扩展。更具体地说，数组是一个在给定维度中表示和可访问的向量（通常是超过两个维度）。
- en: If you are already familiar with vectors and matrices, you won't be surprised
    to see how arrays behave.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉向量和矩阵，你不会对数组的行为感到惊讶。
- en: Creating an array
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个数组
- en: To create an array, we call `array()` by supplying a vector of data, how this
    data is arranged in different dimensions, and sometimes the names of the rows
    and columns of these dimensions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数组，我们通过提供数据向量、数据在不同维度中的排列方式以及有时这些维度的行和列的名称来调用 `array()`：
- en: 'Suppose we have some data (10 integers from 0 to 9) and we need to arrange
    them in three dimensions: 1 for the first dimension, 5 for the second, and 2 for
    the third:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些数据（从0到9的10个整数）并且我们需要在三维中排列它们：第一维为1，第二维为5，第三维为2：
- en: '[PRE81]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can clearly see how we can access these entries by looking at the notations
    around them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察它们周围的符号，我们可以清楚地看到如何访问这些条目。
- en: 'Moreover, we can add names for these dimensions when we create the array:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在创建数组时为这些维度添加名称：
- en: '[PRE82]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Alternatively, for an array that is already created, we can call `dimnames(x)
    <-` to setup the names for each dimension by supplying a list of several character
    vectors:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于已经创建的数组，我们可以调用 `dimnames(x) <-` 来通过提供几个字符向量的列表来为每个维度设置名称：
- en: '[PRE83]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Subsetting an array
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的子集
- en: 'The principle of subsetting an array is exactly the same as subsetting a matrix.
    Here, we can supply a vector for each dimension to extract a subset of an array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的子集原则与矩阵的子集原则完全相同。在这里，我们可以为每个维度提供一个向量来提取数组的子集：
- en: '[PRE84]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As you may notice, atomic vectors, matrices, and arrays share almost the same
    set of behaviors. A fundamental common feature they share is that they are all
    **homogeneous data types**, that is, the type of elements they store must be the
    same. However, there are also **heterogeneous data types** in R, that is, they
    can store different types of elements, which makes them much more flexible but
    they are less memory efficient and slower to operate.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，原子向量、矩阵和数组几乎共享相同的行为集合。它们共享的一个基本共同特征是它们都是**同质数据类型**，即它们存储的元素类型必须相同。然而，R中也有**异质数据类型**，即它们可以存储不同类型的元素，这使得它们更加灵活，但它们在内存效率和操作速度上较低。
- en: Lists
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: A list is a generic vector that is allowed to include different types of objects,
    even other lists.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一种通用的向量，允许包含不同类型的对象，甚至其他列表。
- en: It is useful for its flexibility. For example, the result of a linear model
    fit in R is basically a list object that contains rich results of a linear regression
    such as linear coefficients (numeric vectors), residuals (numeric vectors), QR
    decomposition (a list containing a matrix and other objects), and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它的灵活性使其非常有用。例如，R中线性模型拟合的结果基本上是一个包含线性回归丰富结果的列表对象，如线性系数（数值向量）、残差（数值向量）、QR分解（包含矩阵和其他对象的列表）等等。
- en: It is very handy to extract the information without calling different functions
    each time because these results are all packed into a list.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要每次调用不同的函数就能提取信息非常方便，因为这些结果都打包在一个列表中。
- en: Creating a list
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建列表
- en: 'We can use `list()` to create a list, as the function name suggests. Different
    types of objects can be put into one list. For example, the following code creates
    a list that contains a single-element numeric vector, a two-entry logical vector,
    and a character vector of three values:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据函数名，我们可以使用 `list()` 创建列表。不同类型的对象可以放入一个列表中。例如，以下代码创建了一个包含单个元素数值向量、两个条目的逻辑向量和三个值的字符向量列表：
- en: '[PRE85]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can assign names to each list entry using named arguments:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命名参数为每个列表条目分配名称：
- en: '[PRE86]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Extracting an element from a list
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从列表中提取元素
- en: 'There are various ways to access the elements of a list. The most common way
    is to use a dollar-sign `$` to extract the value of a list element by name:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 访问列表的元素有多种方式。最常见的方式是使用美元符号 `$` 通过名称提取列表元素的值：
- en: '[PRE87]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that if we ask for a non-existing element `m`, `NULL` will be returned.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们请求一个不存在的元素 `m`，将返回 `NULL`。
- en: 'Alternatively, we can supply a number in double square brackets to extract
    the value of the n^(th) list member. For example, we can extract the value of
    the second member of list `l1`, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用双方括号中的数字来提取第 n 个列表成员的值。例如，我们可以提取列表 `l1` 的第二个成员的值，如下所示：
- en: '[PRE88]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With the same notation, we can also supply a name to extract the value of the
    list member with that name, just like using a dollar sign:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的符号，我们也可以提供一个名称来提取具有该名称的列表成员的值，就像使用美元符号一样：
- en: '[PRE89]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'It can be more flexible to use double square brackets for value extraction
    from a list because, sometimes, we might not know which member we need to extract
    before a computation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双方括号从列表中提取值可以更加灵活，因为有时在计算之前我们可能不知道需要提取哪个成员：
- en: '[PRE90]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, we supply a runtime-evaluated, single-element character vector to the
    brackets. But why should we use double brackets here? Where are the single brackets?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将一个运行时评估的单元素字符向量提供给方括号。但为什么在这里要使用双括号？单括号在哪里？
- en: Subsetting a list
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表的子集化
- en: In many cases, we need to extract multiple elements from a list. These multiple
    members also construct a list as a subset of the original list.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要从列表中提取多个元素。这些多个成员也作为原始列表的子集构建一个列表。
- en: To subset a list, we can use single-square-bracket notation, just like what
    we use for vectors and matrices. We can extract some elements of a list and put
    them into a new list.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要对列表进行子集化，我们可以使用单方括号符号，就像我们用于向量和矩阵一样。我们可以从列表中提取一些元素并将它们放入一个新的列表中。
- en: 'The notation is very much consistent with how it works for vectors. We can
    extract elements from a list by name using a character vector, or by position
    using a numeric vector, or by criterion using a logical vector:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 符号与向量操作的方式非常一致。我们可以通过字符向量使用名称提取列表元素，或通过数值向量使用位置提取，或通过逻辑向量使用标准提取：
- en: '[PRE91]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: To summarize, we can say that  `[[` means extracting one element from a vector
    or list, and `[` means subsetting a vector or list. Subsetting a vector will result
    in a vector. Likewise, subsetting a list will result in a list.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样表述：`[[` 表示从向量或列表中提取一个元素，而 `[` 表示对向量或列表进行子集操作。对向量进行子集操作将得到一个新的向量。同样，对列表进行子集操作将得到一个新的列表。
- en: Named lists
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名列表
- en: 'Irrespective of whether the list members have already got names when the list
    is created, we can always name or rename the members of a list, by simply naming
    a vector:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 无论列表成员在创建列表时是否已经具有名称，我们都可以通过简单地命名一个向量来命名或重命名列表成员：
- en: '[PRE92]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To remove their names, we replace the names of `l1` with `NULL`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除它们的名称，我们将 `l1` 的名称替换为 `NULL`：
- en: '[PRE93]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once the names of list members are removed, we can no longer access the list
    members by name but by position and logical criterion.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移除了列表成员的名称，我们就不能再通过名称访问列表成员，而只能通过位置和逻辑条件访问。
- en: Setting values
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置值
- en: 'Setting the values in a list is as straightforward as working with vectors:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设置列表中的值与处理向量一样简单：
- en: '[PRE94]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we assign a value to a nonexisting member, we will add a new member to the
    list with the given name or position:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给一个不存在的成员赋值，我们将添加一个新成员到列表中，其名称或位置由给定值决定：
- en: '[PRE95]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Also, we can set multiple values at the same time:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以同时设置多个值：
- en: '[PRE96]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If we need to remove some of the members in a list, just assign the `NULL`
    value to them:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要从列表中删除一些成员，只需将它们的值赋为 `NULL`：
- en: '[PRE97]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We can remove more than one member from a list altogether:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从列表中一次性删除多个成员：
- en: '[PRE98]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Other functions
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他函数
- en: 'Many functions in R are related to lists. For example, if we are not sure whether
    an object is a list or not, we can call `is.list()` to find out:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: R 中的许多函数都与列表相关。例如，如果我们不确定一个对象是否是列表，我们可以调用 `is.list()` 来查询：
- en: '[PRE99]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, `l2` is a list, and `butl2$a` is a numeric vector rather than a list.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`l2` 是一个列表，而 `butl2$a` 是一个数值向量，而不是列表。
- en: 'We can also convert a vector to a list using `as.list()`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `as.list()` 将向量转换为列表：
- en: '[PRE100]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'It is also easy to coerce a list to a vector by calling `unlist` that basically
    converts all list members and puts them to a vector of a compatible type:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `unlist` 将列表强制转换为向量也很容易，它基本上将所有列表成员转换为兼容类型的向量：
- en: '[PRE101]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If we unlist a list of numbers and texts in mixture, all members will be converted
    to the closest type that each one can be converted to:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将混合数字和文本的列表进行反序列化，所有成员都将转换为它们各自可以转换到的最接近的类型：
- en: '[PRE102]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here, `l4$a` and `l4$b` are numbers and can be converted to a character; however,
     `butl4$c` is a character vector and cannot be converted to numeric values. Therefore,
    their closest type that is compatible with all elements is a character vector.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`l4$a` 和 `l4$b` 是数字，可以转换为字符；然而，`butl4$c` 是字符向量，不能转换为数值。因此，它们与所有元素兼容的最接近的类型是字符向量。
- en: Data frames
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据框
- en: 'A data frame represents a set of data with a number of rows and columns. It
    looks like a matrix but its columns are not necessarily of the same type. This
    is consistent with the most commonly seen formats of datasets: each row, or data
    record, is described by multiple columns of various types.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框表示具有行数和列数的数据集。它看起来像矩阵，但其列不一定具有相同的类型。这与数据集最常见的格式一致：每一行，或数据记录，由多个不同类型的列描述。
- en: The following table is an example that can be fully characterized by a data
    frame.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下表是一个可以完全由数据框表征的示例。
- en: '| **Name** | **Gender** | **Age** | **Major** |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **姓名** | **性别** | **年龄** | **专业** |'
- en: '| Ken | Male | 24 | Finance |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| Ken | 男性 | 24 | 金融 |'
- en: '| Ashley | Female | 25 | Statistics |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| Ashley | 女性 | 25 | 统计学 |'
- en: '| Jennifer | Female | 23 | Computer Science |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| Jennifer | 女性 | 23 | 计算机科学 |'
- en: Creating a data frame
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据框
- en: 'To create a data frame, we can call `data.frame()` and supply the data of each
    column by a vector of the corresponding type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据框，我们可以调用 `data.frame()` 并通过相应类型的向量提供每列的数据：
- en: '[PRE103]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that creating a data frame is exactly the same as creating a list. This
    is because, in essence, a data frame is a list in which each element is a vector
    and represents a table column and has the same number of elements.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，创建数据框与创建列表的过程完全相同。这是因为，本质上，数据框是一个列表，其中每个元素都是一个向量，代表一个表格列，并且具有相同数量的元素。
- en: 'Other than creating a data frame from raw data, we can also create it from
    a list by calling either `data.frame` directly or `as.data.frame`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从原始数据创建数据框外，我们还可以通过直接调用 `data.frame` 或 `as.data.frame` 来从列表创建数据框：
- en: '[PRE104]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can also create a data frame from a matrix with the same method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同的方法从一个矩阵创建数据框：
- en: '[PRE105]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note that the conversion also automatically assigns column names to the new
    data frame. In fact, as you may verify, if the matrix already has column names
    or row names, they will be preserved in the conversion.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，转换还会自动将列名分配给新的数据框。实际上，正如你可能验证的那样，如果矩阵已经具有列名或行名，它们将在转换中保留。
- en: Naming rows and columns
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名行和列
- en: 'Since a data frame is a list but also looks like a matrix, the ways we access
    these two types of objects both apply to a data frame:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据框是一个列表，但看起来也像矩阵，因此访问这两种类型对象的两种方法都适用于数据框：
- en: '[PRE106]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can rename the columns and rows just like we do with a matrix:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理矩阵一样重命名列和行：
- en: '[PRE107]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Subsetting a data frame
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框的子集操作
- en: Since a data frame is a matrix-like list of column vectors, we can use both
    sets of notations to access the elements and subsets in a data frame.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据框是列向量类似矩阵的列表，我们可以使用这两组符号来访问数据框中的元素和子集。
- en: Subsetting a data frame as a list
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据框作为列表进行子集操作
- en: If we would like to regard a data frame as a list of vectors, we can use list
    notations to extract a value or perform subsetting.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将数据框视为向量的列表，我们可以使用列表符号来提取值或进行子集操作。
- en: 'For example, we can use `$` to extract the values of one column by name, or
    use `[[` to do so by position:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用 `$` 通过名称提取一列的值，或者使用 `[[` 通过位置进行操作：
- en: '[PRE108]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'List subsetting perfectly applies to a data frame and also yields a new data
    frame. The subsetting operator (`[`) allows us to use a numeric vector to extract
    columns by position, a character vector to extract columns by name, or a logical
    vector to extract columns by `TRUE` and `FALSE` selection:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表子集完美适用于数据框，并产生一个新的数据框。子集操作符 (`[`) 允许我们使用数值向量通过位置提取列，使用字符向量通过名称提取列，或使用逻辑向量通过
    `TRUE` 和 `FALSE` 选择提取列：
- en: '[PRE109]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Subsetting a data frame as a matrix
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据框作为矩阵进行子集操作
- en: However, the list notation does not support row selection. In contrast, the
    matrix notation provides more flexibility. If we view a data frame as a matrix,
    the two-dimensional accessor enables us to easily access an entry of a subset,
    which supports both column selection and row selection.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表符号不支持行选择。相比之下，矩阵符号提供了更多的灵活性。如果我们将数据框视为矩阵，二维访问器使我们能够轻松访问子集的条目，这支持列选择和行选择。
- en: In other words, we can use the `[row, column]` notation to subset a data frame
    by specifying the row selector and column selector, which can be numeric vectors,
    character vectors, and/or logical vectors.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们可以使用 `[row, column]` 符号通过指定行选择器和列选择器来子集数据框，这些选择器可以是数值向量、字符向量或逻辑向量。
- en: 'For example, we can specify the column selector:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以指定列选择器：
- en: '[PRE110]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Alternatively, we can specify the row selector:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指定行选择器：
- en: '[PRE111]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We can even specify both selectors at the same time:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以同时指定两个选择器：
- en: '[PRE112]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Note that the matrix notation automatically simplifies the output. That is,
    if only one column is selected, the result won''t be a data frame but the values
    of that column. To always keep the result as a data frame, even if it only has
    a single column, we can use both notations together:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，矩阵符号会自动简化输出。也就是说，如果只选择一列，结果将不会是数据框，而是该列的值。为了始终将结果保持为数据框，即使它只有一列，我们也可以同时使用这两种符号：
- en: '[PRE113]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, the first group of brackets subsets the data frame as a matrix with the
    first four rows and all columns selected. The second group of brackets subsets
    the resultant data frame as a list with only the `id` column selected, which results
    in a data frame.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一组括号将数据框作为矩阵子集，选择前四行和所有列。第二组括号将结果数据框作为列表子集，只选择 `id` 列，从而得到一个数据框。
- en: 'Another way is to specify `drop = FALSE` to avoid simplifying the results:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是指定 `drop = FALSE` 以避免简化结果：
- en: '[PRE114]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If you expect the output of a data frame subsetting to always be a data frame,
    you should always set `drop = FALSE`; otherwise, some edge cases (like a user
    input selecting only one column) may end up in unexpected behaviors if you assume
    that you will get a data frame but actually get a vector.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望数据框子集的输出始终是数据框，你应该始终设置 `drop = FALSE`；否则，如果假设你会得到数据框但实际上得到向量，一些边缘情况（如用户输入只选择一列）可能会导致意外的行为。
- en: Filtering data
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据过滤
- en: 'The following code filters the rows of `df1` by `criterionscore >= 0.5` and
    selects the `id` and `level` columns:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过 `criterionscore >= 0.5` 过滤 `df1` 的行，并选择 `id` 和 `level` 列：
- en: '[PRE115]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The following code filters the rows of `df1` by a criterion that the row name
    must be among `a`, `d`, or `e`, and selects the `id` and `score` columns:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过一个标准过滤`df1`的行，该标准是行名必须是`a`、`d`或`e`之一，并选择`id`和`score`列：
- en: '[PRE116]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Both of these examples basically use matrix notation to select rows by a logical
    vector and select columns by a character vector.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子基本上都使用矩阵表示法通过逻辑向量选择行，通过字符向量选择列。
- en: Setting values
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置值
- en: Setting the values of a subset of a data frame allows both methods working with
    a list and a matrix.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数据框子集的值允许同时使用列表和矩阵的方法。
- en: Setting values as a list
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将值作为列表设置
- en: 'We can assign new values to a list member using `$` and `<-` together:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`$`和`<-`一起给列表成员赋新值：
- en: '[PRE117]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Alternatively, `[` works too, and it also allows multiple changes in one expression
    in contrast to `[[`, which only allows modifying one column at a time:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`[`也可以使用，并且它还允许在一个表达式中进行多个更改，而`[[`只能一次修改一列：
- en: '[PRE118]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Setting values as a matrix
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将值作为矩阵设置
- en: 'Using list notations to set values of a data frame has the same problem as
    subsetting–we can only access the columns. If we need to set values with more
    flexibility, we can use matrix notations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表表示法设置数据框的值与子集操作存在相同的问题——我们只能访问列。如果我们需要更灵活地设置值，我们可以使用矩阵表示法：
- en: '[PRE119]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Factors
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 因子
- en: One thing to notice is that the default behavior of a data frame tries to use
    memory more efficiently. Sometimes, this behavior might silently lead to unexpected
    problems.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一点是，数据框的默认行为试图更有效地使用内存。有时，这种行为可能会默默地导致意外的问题。
- en: For example, when we create a data frame by supplying a character vector as
    a column, it will by default convert the character vector to a factor that only
    stores the same value once so that repetitions will not cost much memory. In fact,
    a factor is essentially an integer vector with a pre-specified set of possible
    values called levels to represent values of limited possibilities.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们通过提供一个字符向量作为列来创建数据框时，它将默认将该字符向量转换为因子，该因子只存储一次相同的值，这样重复就不会占用太多内存。实际上，因子本质上是一个整数向量，它有一个预先指定的可能值集合，称为级别，用于表示有限可能性的值。
- en: 'We can verify this by calling `str()` on the data frame `persons` we created
    in the beginning:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在最初创建的`persons`数据框上调用`str()`来验证这一点：
- en: '[PRE120]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As we can clearly find out that `Name`, `Gender`, and `Major` are not character
    vectors but factor objects. It is reasonable that `Gender` is represented by a
    factor because it may only be either `Female` or `Male`, so using two integers
    to represent these two values is more efficient than using a character vector
    to store all the values regardless of the repetition.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地发现`Name`、`Gender`和`Major`不是字符向量，而是因子对象。`Gender`用因子表示是合理的，因为它可能只能是`Female`或`Male`，所以使用两个整数来表示这两个值比使用字符向量存储所有值（无论是否重复）更有效率。
- en: 'However, it may induce problems for other columns not limited to taking several
    possible values. For example, if we want to set a name in `persons`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会对其他列（不仅限于具有几个可能值的列）引起问题。例如，如果我们想在`persons`中设置一个名字：
- en: '[PRE121]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A warning message appears. This happens because in the initial `Name` dictionary,
    there is no word called `John`, therefore we cannot set the name of the first
    person to be such a non-existing value. The same thing happens when we set any `Gender`
    to be `Unknown`. The reason is exactly the same: when the column is initially
    created from a character vector when we define a data frame, the column will by
    default be a factor whose value must be taken from the dictionary created from
    the unique values in that character vector.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一个警告信息。这是因为在我们最初定义数据框时，`Name`字典中没有名为`John`的单词，因此我们无法将第一个人的名字设置为这样一个不存在的值。当我们设置任何`Gender`为`Unknown`时，也会发生同样的事情。原因完全相同：当我们从字符向量创建列时，该列默认将是一个因子，其值必须来自从该字符向量中唯一值创建的字典。
- en: 'This behavior is sometimes very annoying and does not really help much, especially
    as memory is cheap today. The simplest way to avoid this behavior is to set `stringsAsFactors
    = FALSE` when we create a data frame using `data.frame()`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有时非常令人烦恼，实际上并没有多大帮助，尤其是在今天内存便宜的情况下。避免这种行为的简单方法是在使用`data.frame()`创建数据框时设置`stringsAsFactors
    = FALSE`：
- en: '[PRE122]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If we really want a factor object to play its role, we can explicitly call `factor()`
    at specific columns, just like we did previously  for the `Gender` column.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想让因子对象发挥作用，我们可以在特定的列中显式调用`factor()`，就像我们之前在`Gender`列上所做的那样。
- en: Useful functions for data frames
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于数据框的有用函数
- en: There are many useful functions for a data frame. Here we only introduce a few
    but the most commonly used ones.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据框，有许多有用的函数。在这里，我们只介绍一些但最常用的函数。
- en: 'The `summary()` function works with a data frame by generating a table that
    shows the summary statistics of each column:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`函数通过生成一个显示每列汇总统计信息的表格与数据框一起工作：'
- en: '[PRE123]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: For a factor `Gender`, the summary counts the number of rows taking each value,
    or level. For a numeric vector, the summary shows the important quantiles of the
    numbers. For other types of columns, it shows the length, class, and mode of them.
    Another common demand is binding multiple data frames together by either row or
    column. For this purpose, we can use `rbind()` and `cbind()` which, as their names
    suggest, perform row binding and column binding respectively.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于因子`Gender`，汇总计算每个值或级别的行数。对于数值向量，汇总显示数字的重要分位数。对于其他类型的列，它显示它们的长度、类别和模式。另一个常见的需求是通过行或列将多个数据框绑定在一起。为此，我们可以使用`rbind()`和`cbind()`，正如它们的名称所暗示的，分别执行行绑定和列绑定。
- en: 'If we want to append some rows to a data frame, in this case, add a new record
    of a person, we can use `rbind()`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向数据框中添加一些行，在这种情况下，添加一个人的新记录，我们可以使用`rbind()`：
- en: '[PRE124]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If we want to append some columns to a data frame, in this case, add two new
    columns to indicate whether each person is registered and the number of projects
    in hand, we can use `cbind()`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想向数据框中添加一些列，在这种情况下，添加两个新列以指示每个人是否注册以及手头项目的数量，我们可以使用`cbind()`：
- en: '[PRE125]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note that `rbind()` and `cbind()` do not modify the original data but create
    a new data frame with given rows or columns appended.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`rbind()`和`cbind()`不会修改原始数据，而是创建一个新的数据框，其中附加了指定的行或列。
- en: 'Another useful function is `expand.grid()`. This generates a data frame that
    includes all combinations of the values in the columns:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的函数是`expand.grid()`。它生成一个包含列中所有值组合的数据框：
- en: '[PRE126]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are many other useful functions working with data frames. We will discuss
    these functions in data manipulation chapters.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他与数据框一起工作的有用函数。我们将在数据处理章节中讨论这些函数。
- en: Loading and writing data on disk
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在磁盘上加载和写入数据
- en: In practice, data is usually stored in files. R provides a number of functions
    to read a table from a file or write a data frame to a file. If a file stores
    a table, it is often well organized and follows some convention that specifies
    how rows and columns are arranged. In most cases, we don't have to read a file
    byte to byte but call functions such as `read.table()` or `read.csv()`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，数据通常存储在文件中。R提供了一些函数来从文件中读取表格或将数据框写入文件。如果一个文件存储了一个表格，它通常是组织良好的，并遵循一些约定，该约定指定了行和列的排列方式。在大多数情况下，我们不需要逐字节读取文件，而是调用`read.table()`或`read.csv()`等函数。
- en: 'The most popular software-neutral data format is **CSV** (**Comma-Separated
    Values**). The format is basically organized in a way that values in different
    columns are separated by a comma and the first row is by default regarded as the
    header. For example, persons may be represented in the following CSV format:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的软件无关数据格式是**CSV**（逗号分隔值）。该格式基本上是按这种方式组织的，即不同列中的值由逗号分隔，默认情况下，第一行被视为标题行。例如，人员可能以以下CSV格式表示：
- en: '[PRE127]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'To read the data into the R environment, we only need to call `read.csv(file)`
    where the file is the path of the file. To ensure that the data file can be found,
    please place the `data` folder directly in your working directory, call `getwd()`
    to find out. We''ll talk about this in detail in the next chapter:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据读入R环境，我们只需调用`read.csv(file)`，其中file是文件的路径。为确保数据文件可以被找到，请将`data`文件夹直接放置在您的当前工作目录中，调用`getwd()`以查找。我们将在下一章详细讨论这一点：
- en: '[PRE128]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'If we need to save a data frame to a CSV file, we may call `write.csv(file)`
    with some additional arguments:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将数据框保存到CSV文件中，我们可以调用`write.csv(file)`并添加一些额外的参数：
- en: '[PRE129]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The argument `row.names = FALSE` avoids storing the row names which are not
    necessary, and the `argumentquote = FALSE` avoids quoting text in the output,
    both of which in most cases are not necessary.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`row.names = FALSE`避免了存储不必要的行名，而`argumentquote = FALSE`避免了在输出中引用文本，这两者在大多数情况下都是不必要的。
- en: There are a number of built-in functions and several packages related to reading
    and writing data in different formats. We will cover this topic in later chapters.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内置函数和几个与不同格式数据读取和写入相关的包。我们将在后面的章节中介绍这个主题。
- en: Functions
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: A function is an object you can call. Basically, it is a machine with internal
    logic that takes a group of inputs (parameters or arguments) and returns a value
    as output.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一个可以调用的对象。基本上，它是一个具有内部逻辑的机器，它接受一组输入（参数或参数）并返回一个值作为输出。
- en: In the previous sections, we encountered some built-in functions of R. For example,
    `is.numeric()` takes an argument that can be any R object and returns a logical
    value that indicates whether the object is a numeric vector. Similarly, `is.function()`
    can tell whether a given R object is a function object.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们遇到了一些R的内置函数。例如，`is.numeric()`接受任何R对象作为参数，并返回一个逻辑值，指示该对象是否为数值向量。同样，`is.function()`可以判断给定的R对象是否为函数对象。
- en: In fact, in R environment, everything we use is an object, everything we do
    is a function, and, maybe to your surprise, all functions are still objects. Even
    `<-` and `+` are both functions that take two arguments. Although they are called
    binary operators, they are essentially functions.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在R环境中，我们使用的每一件事都是对象，我们做的每一件事都是函数，也许会令你惊讶，所有函数仍然是对象。甚至`<-`和`+`都是接受两个参数的函数。尽管它们被称为二元运算符，但本质上它们是函数。
- en: When we do casual, interactive data analysis, at times, we won't have to write
    any function on our own since the built-in functions and those provided by thousands
    of packages are usually enough.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行随意的交互式数据分析时，有时我们不需要自己编写任何函数，因为内置函数以及成千上万的包提供的函数通常已经足够。
- en: However, if you need to repeat your logic or a process in data manipulation
    or analysis, those functions may not fully serve your purpose because they are
    not designed to meet the specific needs of a task or the format of a particular
    dataset. Then, you need to create your own functions targeting a specific set
    of demands.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要在数据处理或分析中重复逻辑或过程，这些函数可能无法完全满足您的需求，因为它们不是为满足特定任务或特定数据集的格式而设计的。那么，您需要创建自己的函数，针对特定的需求集。
- en: Creating a function
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数
- en: 'It is easy to create a function in R. Suppose we define a function called `add`
    that simply adds two numbers `x` and `y`, respectively:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中创建函数很容易。假设我们定义一个名为`add`的函数，该函数简单地分别将两个数字`x`和`y`相加：
- en: '[PRE130]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The syntax function `(x, y)` specifies the arguments of the function. In other
    words, the function takes two arguments named `x` and `y`. The `{ x + y }` is
    the function body that contains a series of expressions expressed in terms of `x`, `y`
    and other symbols available. The value of the last expression determines the value
    returned by the function unless `return()` is called inside the function. Finally,
    the function is assigned to add so that we can call this function using add later
    on.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 函数语法`（x, y）`指定了函数的参数。换句话说，该函数接受两个名为`x`和`y`的参数。`{ x + y }`是函数体，它包含一系列以`x`、`y`和其他符号表示的表达式。函数返回的值是最后一个表达式的值，除非函数内部调用`return()`。最后，函数被赋值给`add`，这样我们就可以稍后使用`add`调用此函数。
- en: 'Creating such a simple function, or any more complicated functions, does not
    impose any difference on evaluating a vector. The function in R just acts like
    another object. To see what object `add` refers to, just type `add` at the console:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个简单的函数，或者任何更复杂的函数，都不会对评估向量产生任何影响。R中的函数就像另一个对象。要查看`add`引用的对象，只需在控制台输入`add`：
- en: '[PRE131]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Calling a function
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'Once the function is defined, we can call the function just as we do in math.
    The calling requires the same syntax: name (arg1, arg2, ...). Take a look at the
    following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义后，我们可以像在数学中一样调用函数。调用需要相同的语法：名称（arg1, arg2, ...）。看看下面的例子：
- en: '[PRE132]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The call is quite transparent. When we evaluate such a call, R will find out
    if there is a function named `add` in the environment. Then, it will figure out
    that `add` refers to the function we just created and creates a local environment
    in which `x` takes `2` and `y` takes `3`. The expression in the function body
    is then evaluated given the values of the arguments. Finally, the function returns
    the value of that expression, `5`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 调用非常透明。当我们评估这样的调用时，R会找出环境中是否有名为`add`的函数。然后，它会确定`add`指的是我们刚刚创建的函数，并创建一个局部环境，其中`x`取值为`2`，`y`取值为`3`。然后根据参数的值评估函数体内的表达式。最后，函数返回该表达式的值，即`5`。
- en: Dynamic typing
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型
- en: 'Functions in R can be very flexible since it is not strongly typed. In other
    words, the type of inputs are not fixed prior to the calling. Even if the function
    is originally designed to work for scalar numbers, it is automatically generalized
    to also work with all vectors as long as `+` works with them. For example, we
    can run the following code without any change in the function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: R中的函数可以非常灵活，因为它不是强类型。换句话说，在调用之前，输入的类型不是固定的。即使函数最初是为标量数字设计的，只要`+`可以与它们一起工作，它也会自动推广到也可以与所有向量一起工作。例如，我们可以运行以下代码而不改变函数：
- en: '[PRE133]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The preceding example does not really demonstrate the flexibility of dynamic
    typing because scalar is also a vector in R. A more qualified example is:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子并没有真正展示动态类型的灵活性，因为标量在R中也是一个向量。一个更有资格的例子是：
- en: '[PRE134]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The function put the two arguments into the expression without any type checking.
    `as.Date()` creates a `Date` object, which has a date representation. Without
    changing any code of `add`, it works with `Date` perfectly. The function fails
    only when `+` is not well-defined for the two arguments:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将两个参数放入表达式而不进行任何类型检查。`as.Date()`创建一个`Date`对象，它具有日期表示。在不改变`add`的任何代码的情况下，它与`Date`完美地工作。函数只有在`+`对于两个参数没有明确定义时才会失败：
- en: '[PRE135]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Generalizing a function
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛化一个函数
- en: Functions are a well-defined abstraction of a particular set of logic or process
    intended for solving some particular problem. Developers often want a function
    to be general enough to adapt to a wide range of use cases so that we can easily
    use it to solve similar problems without writing too many specialized functions
    for each problem.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对特定逻辑或过程的明确抽象，旨在解决某些特定问题。开发者通常希望函数足够通用，以适应广泛的用例，这样我们就可以轻松地使用它来解决类似的问题，而无需为每个问题编写太多的专用函数。
- en: To make a function more widely applicable is called **generalization**. It is
    very handy to generalize a function in a weakly-typed programming language like
    R, but it can be error-prone if it is incorrectly implemented.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使函数更广泛适用的过程称为**泛化**。在像R这样的弱类型编程语言中泛化函数非常方便，但如果实现不正确，则可能会出错。
- en: To make `add()` more general so that it can handle various primitive algebraic
    operations, we can define another function called `calc`. This new function accepts
    three arguments where `x` and `y` are the two vectors, and `type` accepts a character
    vector which is the kind of algebraic operation the user wants to perform.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`add()`更通用，以便它可以处理各种原始代数运算，我们可以定义另一个函数，称为`calc`。这个新函数接受三个参数，其中`x`和`y`是两个向量，而`type`接受一个字符向量，表示用户想要执行哪种代数运算。
- en: 'The following code implements such a function using **flow control**, which
    we will cover soon, but it should be easy to understand at first look. In this
    code, the choice of expression to be evaluated depends on the value of `type`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用**流程控制**实现这样一个函数，我们将在不久的将来介绍，但一开始看起来应该很容易理解。在这段代码中，要评估的表达式的选择取决于`type`的值：
- en: '[PRE136]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Once the function is defined, we can call it by supplying appropriate arguments:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数被定义，我们就可以通过提供适当的参数来调用它：
- en: '[PRE137]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The function automatically works with numeric vectors:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 函数自动与数值向量一起工作：
- en: '[PRE138]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The function is also generalized to work with non-numeric vectors for which
    `+` is well-defined:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也被推广到可以与非数值向量一起工作，其中`+`是明确定义的：
- en: '[PRE139]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Consider supplying some invalid arguments:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑提供一些无效的参数：
- en: '[PRE140]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In this case, no conditions are satisfied, so the expression in the last else
    block will be evaluated. The `stop()` call yields an error message and terminates
    the whole evaluation immediately.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有任何条件得到满足，因此最后else块中的表达式将被评估。`stop()`调用将产生一个错误信息并立即终止整个评估。
- en: 'The functions seem to work fine and consider all possible situations with invalid
    arguments. However, it is not true:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 函数似乎工作得很好，并考虑了所有可能的无效参数的情况。然而，这并不正确：
- en: '[PRE141]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Here, we didn''t consider the case where type is given as a multi-element vector.
    The problem is: when such a vector is compared with another vector, it will also
    result in a multi-element logical vector, it will also result in a mult-element
    logical vector which makes an ambiguous condition for `if`. Consider what it means
    by `if(c(TRUE, FALSE))`?'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有考虑类型被给定为多元素向量的情况。问题是：当这样的向量与另一个向量比较时，它也会产生一个多元素逻辑向量，这将为`if`条件造成模糊。考虑`if(c(TRUE,
    FALSE))`的含义？
- en: 'To avoid such ambiguity explicitly, we need to refine the function so that
    the error will be more informative and transparent. To proceed, we just need to
    check whether the vector has the length `1`:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确避免这种歧义，我们需要改进函数，以便错误信息更加详细和透明。为了进行下去，我们只需要检查向量是否有长度`1`：
- en: '[PRE142]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Then, we retry the trouble-making call and see how the exception is handled
    by pre-checking of arguments:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重新尝试那个麻烦的调用，看看异常是如何通过参数的预检查来处理的：
- en: '[PRE143]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Default value for function arguments
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数的默认值
- en: Some functions are very flexible because they accept a wide range of input and
    meet a variety of demands. In many cases, more flexibility means an increasing
    number of arguments.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数非常灵活，因为它们接受广泛的输入并满足各种需求。在很多情况下，更多的灵活性意味着参数数量的增加。
- en: If we have to specify tens of arguments each time using a very flexible function,
    it would certainly be a mess to look at the code. In this case, reasonable default
    values for arguments will largely simplify the code to call a function.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须在每次使用非常灵活的函数时指定数十个参数，那么查看代码肯定会很混乱。在这种情况下，为参数设置合理的默认值将极大地简化调用函数的代码。
- en: 'To set the default value of an argument, use `arg = value`. This will make
    the argument optional. The following example creates a function with an optional
    argument:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置参数的默认值，使用`arg = value`。这将使参数成为可选的。以下示例创建了一个具有可选参数的函数：
- en: '[PRE144]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The new function `increase()` allows us to call it with only `x`. In this case, `y`
    automatically takes `1` unless it is explictly specified.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数`increase()`允许我们仅使用`x`来调用它。在这种情况下，如果未明确指定，`y`将自动取值为`1`。
- en: '[PRE145]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Many R functions have multiple arguments and some of them are given default
    values. Sometimes, it is tricky to determine the default values of arguments because
    it heavily relies on the intention of most users.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 许多R函数都有多个参数，其中一些参数有默认值。有时，确定参数的默认值可能很棘手，因为这很大程度上依赖于大多数用户的意图。
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned the basic behaviors of numeric vectors, logical
    vectors, and character vectors. These vectors are homogeneous data types that can
    only store elements of the same type. By contrast, lists and data frames are more
    flexible since they store elements of different types. You learned how to subset
    these data structures and extract an element from them. Finally, you learned about
    creating and calling functions.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了数值向量、逻辑向量和字符向量的基本行为。这些向量是同质数据类型，只能存储相同类型的元素。相比之下，列表和数据框更加灵活，因为它们可以存储不同类型的元素。你学习了如何对这些数据结构进行子集化并从中提取元素。最后，你学习了如何创建和调用函数。
- en: Now you know the rules of the game, you need to get familiar with the playground.
    In the next chapter, we will cover some basic yet important things about managing
    the workspace. I will show you some common practices of managing the working directory,
    the environment, and the library of packages.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了游戏的规则，你需要熟悉游戏场地。在下一章中，我们将介绍一些关于管理工作空间的基本但重要的事项。我会向你展示一些管理工作目录、环境和包库的常见做法。
