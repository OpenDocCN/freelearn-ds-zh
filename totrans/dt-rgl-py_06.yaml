- en: '*Chapter 6*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*'
- en: Learning the Hidden Secrets of Data Wrangling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习数据清洗的隐藏秘密
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Clean and handle real-life messy data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洗和处理现实生活中的杂乱数据
- en: Prepare data for data analysis by formatting data in the format required by
    downstream systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过格式化数据以符合下游系统所需格式来准备数据分析
- en: Identify and remove outliers from data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据中识别并移除异常值
- en: In this chapter, you will learn about data issues that happen in real-life.
    You will also learn how to solve these issues.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解现实生活中发生的数据问题。你还将学习如何解决这些问题。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will learn about the secret sauce behind creating a successful
    data wrangling pipeline. In the previous chapters, we were introduced to the basic
    data structures and building blocks of Data Wrangling, such as pandas and NumPy.
    In this chapter, we will look at the data handling section of data wrangling.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解创建成功数据清洗管道背后的秘诀。在前几章中，我们介绍了数据清洗的基本数据结构和构建块，例如 pandas 和 NumPy。在本章中，我们将查看数据清洗的数据处理部分。
- en: Imagine that you have a database of patients who have heart diseases, and like
    any survey, the data is either missing, incorrect, or has outliers. Outliers are
    values that are abnormal and tend to be far away from the central tendency, and
    thus including it into your fancy machine learning model may introduce a terrible
    bias that we need to avoid. Often, these problems can cause a huge difference
    in terms of money, man-hours, and other organizational resources. It is undeniable
    that someone with the skills to solve these problems will prove to be an asset
    to an organization.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含患有心脏病患者的数据库，就像任何调查一样，数据可能缺失、不正确或存在异常值。异常值是异常值，通常远离中心趋势，因此将其包含到你的复杂机器学习模型中可能会引入我们希望避免的严重偏差。通常，这些问题在金钱、人力和其他组织资源方面会造成巨大的差异。不可否认，具备解决这些问题的技能的人将对组织证明是一笔财富。
- en: '**Additional Software Required for This Section**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**本节所需额外软件**'
- en: The code for this exercise depends on two additional libraries. We need to install
    `SciPy` and `python-Levenshtein`, and we are going to install them in the running
    Docker container. Be wary of this, as we are not in the container.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码依赖于两个额外的库。我们需要安装 `SciPy` 和 `python-Levenshtein`，并且我们将在运行的 Docker 容器中安装它们。请注意这一点，因为我们不在容器中。
- en: 'To install the libraries, type the following command in the running Jupyter
    notebook:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装库，请在运行的 Jupyter 笔记本中输入以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Advanced List Comprehension and the zip Function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级列表推导式和 zip 函数
- en: In this topic, we will deep dive into the heart of list comprehension. We have
    already seen a basic form of it, including something as simple as `a = [i for
    i in range(0, 30)]` to something a bit more complex that involves one conditional
    statement. However, as we already mentioned, list comprehension is a very powerful
    tool and, in this topic, we will explore the power of this amazing tool further.
    We will investigate another close relative of list comprehension called `generators`,
    and also work with `zip` and its related functions and methods. By the end of
    this topic, you will be confident in handling complicated logical problems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将深入探讨列表推导式的核心。我们已经看到了它的基本形式，包括像 `a = [i for i in range(0, 30)]` 这样简单的东西，到涉及一个条件语句的稍微复杂一些的形式。然而，正如我们之前提到的，列表推导式是一个非常强大的工具，在本主题中，我们将进一步探索这个神奇工具的力量。我们将研究列表推导式的另一个近亲，称为
    `generators`，并使用 `zip` 及其相关函数和方法。在本主题结束时，你将能够自信地处理复杂的逻辑问题。
- en: Introduction to Generator Expressions
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器表达式的介绍
- en: Previously, while discussing advanced data structures, we witnessed functions
    such as `repeat`. We said that they represent a special type of function known
    as iterators. We also showed you how the lazy evaluation of an iterator can lead
    to an enormous amount of space saving and time efficiency.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前讨论高级数据结构时，我们见证了 `repeat` 等函数。我们说它们代表一种特殊类型的函数，称为迭代器。我们还展示了迭代器的懒加载如何导致巨大的空间节省和时间效率。
- en: Iterators are one brick in the functional programming construct that Python
    has to offer. Functional programming is indeed a very efficient and safe way to
    approach a problem. It offers various advantages over other methods, such as modularity,
    ease of debugging and testing, composability, formal provability (a theoretical
    computer science concept), and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是 Python 提供的函数式编程结构中的一个组成部分。函数式编程确实是一种非常高效且安全的方法来解决问题。它提供了比其他方法更多的优势，如模块化、易于调试和测试、可组合性、形式可证明性（一个理论计算机科学概念）等等。
- en: 'Exercise 73: Generator Expressions'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 73：生成器表达式
- en: 'In this exercise, we will be introduced to generator expressions, which are
    considered another brick of functional programming (as a matter of fact, they
    are inspired by the pure functional language known as [Haskell](https://www.haskell.org/)).
    Since we have seen some amount of list comprehension already, generator expressions
    will look familiar to us. However, they also offer some advantages over list comprehension:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍生成器表达式，它们被认为是函数式编程的另一个基石（实际上，它们受到了纯函数式语言 [Haskell](https://www.haskell.org/)
    的启发）。由于我们已经看到了一些列表推导的例子，生成器表达式对我们来说将很熟悉。然而，它们也提供了一些比列表推导更多的优势：
- en: 'Write the following code using list comprehension to generate a list of all
    the odd numbers between 0 and 100,000:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表推导编写以下代码以生成介于 0 和 100,000 之间的所有奇数列表：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use `getsizeof` from `sys` by using the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过 `sys` 模块中的 `getsizeof` 函数：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will see that it takes a good amount of memory to do this. It is also not
    very time efficient. How can we change that? Using something like `repeat` is
    not applicable here because we need to have the logic of the list comprehension.
    Fortunately, we can turn any list comprehension into a generator expression.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将看到，这样做需要相当多的内存。它也不是非常高效。我们如何改变这一点？使用类似 `repeat` 的方法在这里不适用，因为我们需要列表推导的逻辑。幸运的是，我们可以将任何列表推导转换为生成器表达式。
- en: 'Write the equivalent generator expression for the aforementioned list comprehension:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为上述列表推导编写等效的生成器表达式：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the only change we made is to surround the list comprehension statement
    with round brackets instead of square ones. That makes it shrink to only around
    100 bytes! This makes it become a lazy evaluation, and thus is more efficient.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们做的唯一改变是将列表推导语句用圆括号而不是方括号包围。这使得它缩小到大约 100 字节！这使得它成为一个惰性评估，因此更高效。
- en: 'Print the first 10 odd numbers, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印前 10 个奇数，如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exercise 74: One-Liner Generator Expression'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 74：一行生成器表达式
- en: 'In this exercise, we will use our knowledge of generator expressions to generate
    an expression that will read one word at a time from a list of words and will
    remove newline characters at the end of them and make them lowercase. This can
    certainly be done using a `for` loop explicitly:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用我们对生成器表达式的知识来生成一个表达式，该表达式将逐个从单词列表中读取一个单词，并移除它们末尾的换行符并将它们转换为小写。这当然可以使用显式的
    `for` 循环来完成：
- en: 'Create a words string, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单词字符串，如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Write the following generator expression to achieve the task, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下生成器表达式以完成任务，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a list comprehension to get words one by one from the generator expression
    and finally print the list, as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个列表推导，从生成器表达式中逐个获取单词，并最终打印出列表，如下所示：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.1: List comprehension of words](img/C11065_06_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：单词列表推导](img/C11065_06_01.jpg)'
- en: 'Figure 6.1: List comprehension of words'
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.1：单词列表推导
- en: 'Exercise 75: Extracting a List with Single Words'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 75：提取单字列表
- en: 'If we look at the output of the previous exercise, we will notice that due
    to the messy nature of the source data (which is normal in the real world), we
    ended up with a list where, in some cases, we have more than one word together,
    separated by a space. To improve this, and to get a list of single words, we will
    have to modify the generator expressions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看上一个练习的输出，我们会注意到，由于源数据的杂乱性质（这在现实世界中是正常的），我们最终得到了一个列表，在某些情况下，我们有一个以上的单词连在一起，由空格分隔。为了改进这一点，并获取单字列表，我们不得不修改生成器表达式：
- en: 'Write the generator expression and then write the equivalent nested for loops
    so that we can compare the results:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写生成器表达式，然后编写等效的嵌套循环，以便我们可以比较结果：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_02.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C11065_06_02.jpg)'
- en: 'Figure 6.2: List of words from the string'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.2：从字符串中提取的单词列表
- en: 'Write an equivalent to this by following a nested `for` loop, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照嵌套`for`循环的方式编写一个等效的代码，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_06_03.jpg)'
- en: 'Figure 6.3: List of words from the string using a nested loop'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.3：使用嵌套循环从字符串中提取的单词列表
- en: We must admit that the generator expression was not only space and time saving
    but also a more elegant way to write the same logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认生成器表达式不仅节省了空间和时间，而且是一种更优雅的方式来编写相同的逻辑。
- en: To remember how the nested loop in generator expressions works, keep in mind
    that the loops are evaluated from left to right and the final loop variable (in
    our example, which is denoted by the single letter "w") is given back (thus we
    could call `strip` and `lower` on it).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住生成器表达式中的嵌套循环是如何工作的，请记住循环是从左到右评估的，并且最终的循环变量（在我们的例子中，用单个字母“w”表示）被返回（因此我们可以对它调用`strip`和`lower`）。
- en: 'The following diagram will help you remember the trick about nested `for` loops
    in list comprehension or generator expression:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助您记住列表推导式或生成器表达式中嵌套`for`循环的技巧：
- en: '![Figure 6.4: Nested loops illustration](img/C11065_06_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：嵌套循环说明](img/C11065_06_04.jpg)'
- en: 'Figure 6.4: Nested loops illustration'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.4：嵌套循环说明
- en: We have learned about nested `for` loops in generator expressions previously,
    but now we are going to learn about independent `for` loops in a generator expression.
    We will have two output variables from two `for` loops and they must be treated
    as a tuple so that they don't have ambiguous grammar in Python.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经学习了生成器表达式中的嵌套`for`循环，但现在我们将学习生成器表达式中的独立`for`循环。我们将从两个`for`循环中获得两个输出变量，并且它们必须被当作一个元组来处理，这样它们在Python中就不会有语法上的歧义。
- en: 'Create the following two lists:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下两个列表：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You are asked to generate all possible combinations of marbles and counts after
    being given the preceding two lists. How will you do that? Surely using a nested
    `for` loop and with list''s `append` method you can accomplish the task. How about
    a generator expression? A more elegant and easy solution is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您被要求在给出前两个列表后生成所有可能的弹珠和计数的组合。您将如何做到这一点？当然，使用嵌套`for`循环和列表的`append`方法可以完成这个任务。那么生成器表达式呢？一个更优雅、更简单的解决方案如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This generator expression creates a tuple in each iteration of the simultaneous
    `for` loops. This code is equivalent to the following explicit code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式在同时`for`循环的每次迭代中创建一个元组。这段代码等同于以下显式代码：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.5: Appending the marbles and counts](img/C11065_06_05.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：添加弹珠和计数](img/C11065_06_05.jpg)'
- en: 'Figure 6.5: Appending the marbles and counts'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.5：添加弹珠和计数
- en: This generator expression creates a tuple in each iteration of the simultaneous
    for loops. Once again, the generator expression is easy, elegant, and efficient.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式在同时`for`循环的每次迭代中创建一个元组。再次强调，生成器表达式简单、优雅且高效。
- en: 'Exercise 76: The zip Function'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 76：`zip` 函数
- en: 'In this exercise, we will examine the `zip` function and compare it with the
    generator expression we wrote in the previous exercise. The problem with the previous
    generator expression is the fact that, it produced all possible combinations.
    For instance, if we need to relate countries with its capitals, doing so using
    generator expression will be difficult. Fortunately, Python gives us a built-in
    function called `zip` for just this purpose:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查`zip`函数，并将其与我们之前练习中编写的生成器表达式进行比较。之前生成器表达式的缺点是它产生了所有可能的组合。例如，如果我们需要将国家与其首都关联起来，使用生成器表达式来做这个会比较困难。幸运的是，Python为我们提供了一个内置函数`zip`，专门用于这个目的：
- en: 'Create the following two lists:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下两个列表：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Generate a list of tuples where the first element is the name of the country
    and the second element is the name of the capital by using the following commands:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成一个包含国家名称作为第一个元素和首都名称作为第二个元素的元组列表：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is not very well represented. We can use `dict` where keys are the names
    of the countries, whereas the values are the names of the capitals by using the
    following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表示得不是很好。我们可以使用`dict`，其中键是国家的名称，而值是首都的名称，可以使用以下命令：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.6: Dictionary with countries and capitals](img/C11065_06_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：包含国家和首都的字典](img/C11065_06_06.jpg)'
- en: 'Figure 6.6: Dictionary with countries and capitals'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.6：包含国家和首都的字典
- en: 'Exercise 77: Handling Messy Data'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 77：处理混乱的数据
- en: As always, in real life, data is messy. So, the nice equal length lists of countries
    and capitals that we just saw are not available.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在现实生活中，数据是杂乱的。因此，我们刚才看到的那些国家与首都的长度相等的漂亮列表并不存在。
- en: 'The `zip` function cannot be used with unequal length lists, because `zip`
    will stop working as soon as one of the lists comes to an end. To save us in such
    a situation, we have `ziplongest` in the `itertools` module:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数不能与长度不等的长列表一起使用，因为一旦其中一个列表到达末尾，`zip`就会停止工作。为了在这种情况下帮助我们，`itertools`模块中提供了`ziplongest`：'
- en: 'Create two lists of unequal length, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个长度不等的长列表，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the final `dict` and put `None` as the value to the countries who do
    not have a capital in the capital''s list:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最终的`dict`并将`None`作为没有首都的国家在首都列表中的值：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.7: Output using ziplongest](img/C11065_06_07.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7：使用ziplongest的输出](img/C11065_06_07.jpg)'
- en: 'Figure 6.7: Output using ziplongest'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：使用ziplongest的输出
- en: We should pause here for a second and think about how many lines of explicit
    code and difficult-to-understand `if-else` conditional logic we just saved by
    calling a single function and just giving it the two source data lists. It is
    indeed amazing!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在这里暂停一下，思考一下通过调用一个函数并仅给出两个源数据列表，我们节省了多少行显式代码和难以理解的`if-else`条件逻辑。这确实令人惊叹！
- en: With these exercises, we are ending the first topic of this chapter. Advanced
    list comprehension, generator expressions, and functions such as `zip` and `ziplongest`
    are some very important tricks that we need to master if we want to write clean,
    efficient, and maintainable code. Code that does not have these three qualities
    are considered sub-par in the industry, and we certainly don't want to write such
    code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些练习，我们结束了本章的第一个主题。高级列表解析、生成器表达式以及`zip`和`ziplongest`等函数是一些我们必须掌握的重要技巧，如果我们想要编写干净、高效且易于维护的代码。不具备这三个品质的代码在业界被认为是次品，我们当然不希望编写这样的代码。
- en: However, we did not cover one important object here, that is, **generators**.
    Generators are a special type of function that shares the behavioral traits with
    generator expressions. However, being a function, they have a broader scope and
    they are much more flexible. We strongly encourage you to learn about them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有涵盖这里的一个重要对象，那就是**生成器**。生成器是一种特殊类型的函数，它具有与生成器表达式相同的特性。然而，作为一个函数，它具有更广泛的范围，并且更加灵活。我们强烈建议您了解它们。
- en: Data Formatting
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据格式化
- en: 'In this topic, we will format a given dataset. The main motivations behind
    formatting data properly are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本主题中，我们将格式化给定的数据集。正确格式化数据的动机主要包括以下几点：
- en: It helps all the downstream systems to have a single and pre-agreed form of
    data for each data point, thus avoiding surprises and, in effect, breaking it.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于所有下游系统对每个数据点有一个单一且预先约定的数据格式，从而避免意外，实际上也避免了破坏。
- en: To produce a human-readable report from lower-level data that is, most of the
    time, created for machine consumption.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主要用于机器消费的底层数据生成可读性强的报告。
- en: To find errors in data.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了查找数据中的错误。
- en: There are a few ways to do data formatting in Python. We will begin with the
    modulus operator.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有几种方法可以进行数据格式化。我们将从模运算符开始。
- en: The % operator
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '%运算符'
- en: Python gives us the % operator to apply basic formatting on data. To demonstrate
    this, we will load the data first by reading the CSV file, and then we will apply
    some basic formatting on it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了%运算符来对数据进行基本格式化。为了演示这一点，我们首先通过读取CSV文件加载数据，然后我们将对它应用一些基本的格式化。
- en: 'Load the data from the CSV file by using the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从CSV文件加载数据：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we have a list called `raw_data` that contains all the rows of the CSV
    file. Feel free to print it to check out what it looks like.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`raw_data`的列表，它包含了CSV文件的所有行。您可以随意打印它来查看其外观。
- en: 'The output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.8: Raw data](img/C11065_06_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：原始数据](img/C11065_06_08.jpg)'
- en: 'Figure 6.8: Raw data'
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：原始数据
- en: We will be producing a report on this data. This report will contain one section
    for each data point and will report the name, age, weight, height, history of
    family disease, and finally the present heart condition of the person. These points
    must be clear and easily understandable English sentences.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一份关于这些数据的报告。这份报告将包含每个数据点的一个部分，并报告个人的姓名、年龄、体重、身高、家族病史以及最终的心脏状况。这些点必须是清晰且易于理解的英文句子。
- en: 'We do this in the following way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是这样做的：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.9: Raw data in a presentable format](img/C11065_06_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：以可展示格式呈现的原始数据](img/C11065_06_09.jpg)'
- en: 'Figure 6.9: Raw data in a presentable format'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：以可展示格式呈现的原始数据
- en: 'The % operator is used in two different ways:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '% 操作符有两种不同的用法：'
- en: When used inside a quote, it signifies what kind of data to expect here. `%s`
    stands for string, whereas `%d` stands for integer. If we indicate a wrong data
    type, it will throw an error. Thus, we can effectively use this kind of formatting
    as an error filter in the incoming data.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在引号内使用时，它表示这里期望的数据类型。`%s` 代表字符串，而 `%d` 代表整数。如果我们指定了错误的数据类型，它将引发错误。因此，我们可以有效地使用这种格式化作为输入数据的错误过滤器。
- en: When we use the % operator outside the quote, it basically tells Python to start
    the replacement of all the data inside with the values provided for them outside.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在引号外使用 % 操作符时，它基本上告诉Python开始用外部提供的值替换所有内部数据。
- en: Using the format Function
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用格式化函数
- en: In this section, we will be looking at the exact same formatting problem, but
    this time we will use a more advanced approach. We will use Python's `format`
    function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨完全相同的格式化问题，但这次我们将使用更高级的方法。我们将使用Python的 `format` 函数。
- en: 'To use the `format` function, we do the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `format` 函数，我们执行以下操作：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_06_09.jpg)'
- en: 'Figure 6.10: Data formatted using the format function of the string'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：使用字符串的格式化函数进行格式化的数据
- en: Notice that we have replaced the `%s` with {} and instead of the % outside the
    quote, we have called the `format` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将 `%s` 替换为 {}，并且不再使用引号外的 %，而是调用了 `format` 函数。
- en: 'We will see how the powerful `format` function can make the previous code a
    lot more readable and understandable. Instead of simple and blank {}, we mention
    the key names inside and then use the special Python `**` operation on a `dict`
    to unpack it and give that to the format function. It is smart enough to figure
    out how to replace the key names inside the quote with the values from the actual
    `dict` by using the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到强大的 `format` 函数如何使之前的代码更加易读和易懂。我们不再使用简单的空白 `{}`，而是在其中提及键名，然后使用特殊的Python
    `**` 操作对 `dict` 进行解包，并将其提供给格式化函数。它足够智能，可以通过以下命令确定如何使用实际的 `dict` 中的值替换引号内的键名：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.11: Readable file using the ** operation](img/C11065_06_11.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：使用**操作的可读文件](img/C11065_06_11.jpg)'
- en: 'Figure 6.11: Readable file using the ** operation'
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：使用**操作的可读文件
- en: This approach is indeed much more concise and maintainable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实更加简洁且易于维护。
- en: 'Exercise 78: Data Representation Using {}'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习78：使用{}进行数据表示
- en: 'The `{}` notation inside the quote is powerful and we can change our data representation
    significantly by using it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 引号内的 `{}` 符号功能强大，我们可以通过它显著改变数据的表现形式：
- en: 'Change a decimal number to its binary form by using the following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令将十进制数字转换为二进制形式：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_12.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C11065_06_12.jpg)'
- en: 'Figure 6.12: A number in its binary representation'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：其二进制表示形式的数字
- en: 'Printing a string that''s center oriented:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印居中对齐的字符串：
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_13.jpg)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C11065_06_13.jpg)'
- en: 'Figure 6.13: A string that''s been center formatted'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：使用居中对齐格式化的字符串
- en: 'Printing a string that''s center oriented, but this time with padding on both
    sides:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印居中对齐的字符串，但这次在两侧都有填充：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.14: A string that’s been center formatted with padding](img/C11065_06_14.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14：使用填充居中对齐的字符串](img/C11065_06_14.jpg)'
- en: 'Figure 6.14: A string that''s been center formatted with padding'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：使用填充居中对齐的字符串
- en: As we've already mentioned, the format statement is a powerful one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，格式说明是一个强大的功能。
- en: It is important to format date as date has various formats depending on what
    the source of the data is, and it may need several transformations inside the
    data wrangling pipeline.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化日期很重要，因为日期的格式取决于数据来源，并且在数据清洗管道中可能需要多次转换。
- en: 'We can use the familiar date formatting notations with format as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用熟悉的日期格式化符号，格式如下：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.15: Data after being formatted](img/C11065_06_15.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：格式化后的数据](img/C11065_06_15.jpg)'
- en: 'Figure 6.15: Data after being formatted'
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：格式化后的数据
- en: Compare it with the actual output of `datetime.utcnow` and you will see the
    power of this expression easily.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与`datetime.utcnow`的实际输出进行比较，你将很容易看到这个表达式的力量。
- en: Identify and Clean Outliers
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别和清除异常值
- en: 'When confronted with real-world data, we often see a specific thing in a set
    of records: there are some data points that do not fit with the rest of the records.
    They have some values that are too big, or too small, or completely missing. These
    kinds of records are called `outliers`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 面对现实世界数据时，我们经常在记录集中看到特定的事情：有一些数据点与其余记录不匹配。它们有一些值太大，或太小，或完全缺失。这类记录被称为`异常值`。
- en: Statistically, there is a proper definition and idea about what an outlier means.
    And often, you need deep domain expertise to understand when to call a particular
    record an outlier. However, in this present exercise, we will look into some basic
    techniques that are commonplace to flag and filter outliers in real-world data
    for day-to-day work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学上，有一个关于异常值含义的适当定义和概念。通常，你需要深厚的领域专业知识来理解何时将某个特定记录称为异常值。然而，在这个当前练习中，我们将探讨一些在现实世界数据中标记和过滤异常值的基本技术，这些技术在日常工作中很常见。
- en: 'Exercise 79: Outliers in Numerical Data'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习79：数值数据中的异常值
- en: 'In this exercise, we will first construct a notion of an outlier based on numerical
    data. Imagine a cosine curve. If you remember the math for this from high school,
    then a cosine curve is a very smooth curve within the limit of `[1, -1]`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将首先基于数值数据构建异常值的概念。想象一个余弦曲线。如果你还记得高中数学中的这个概念，那么余弦曲线是在 `[1, -1]` 范围内一个非常平滑的曲线：
- en: 'To construct a cosine curve, execute the following command:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建余弦曲线，请执行以下命令：
- en: '[PRE28]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Plot the data by using the following code:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码绘制数据：
- en: '[PRE29]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_16.jpg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/C11065_06_16.jpg)'
- en: 'Figure 6.16: Cosine wave'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：余弦波
- en: As we can see, it is a very smooth curve, and there is no outlier. We are going
    to introduce some now.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，它是一个非常平滑的曲线，没有异常值。我们现在要引入一些。
- en: 'Introduce some outliers by using the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令引入一些异常值：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Plot the curve:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制曲线：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Figure 6.17: Wave with outliers](img/C11065_06_17.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：带有异常值的波](img/C11065_06_17.jpg)'
- en: 'Figure 6.17: Wave with outliers'
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：带有异常值的波
- en: We can see that we have successfully introduced two values in the curve, which
    broke the smoothness and hence can be considered as outliers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们已经成功地在曲线上引入了两个值，打破了平滑性，因此可以被认为是异常值。
- en: 'A good way to detect if our dataset has an outlier is to create a box plot.
    A boxplot is a way of plotting numerical data based on their central tendency
    and some `buckets` (in reality, we call them `quartiles`). In a box plot, the
    outliers are usually drawn as separate points. The `matplotlib` library helps
    draw boxplots out of a series of numerical data, which isn''t hard at all. This
    is how we do it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 检测我们的数据集是否有异常值的一个好方法是创建一个箱线图。箱线图是一种基于数据的中心趋势和一些`桶`（实际上，我们称之为`四分位数`）来绘制数值数据的方式。在箱线图中，异常值通常被绘制为单独的点。`matplotlib`库帮助从一系列数值数据中绘制箱线图，这并不困难。这就是我们这样做的方式：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you execute the preceding code, you will be able to see that there is
    a nice boxplot where the two outliers that we had created are clearly shown, just
    like in the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行上述代码，你将能够看到有一个很好的箱线图，其中我们创建的两个异常值清晰地显示出来，就像以下图表所示：
- en: '![Figure 6.18: Boxplot with outliers](img/C11065_06_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18：带有异常值的箱线图](img/C11065_06_18.jpg)'
- en: 'Figure 6.18: Boxplot with outliers'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：带有异常值的箱线图
- en: Z-score
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Z-score
- en: A z-score is a measure on a set of data that gives you a value for each data
    point regarding how much that data point is spread out with respect to the standard
    deviation and mean of the dataset. We can use z-score to numerically detect outliers
    in a set of data. Normally, any data point with a z-score greater than +3 or less
    then -3 is considered an outlier. We can use this concept with a bit of help from
    the excellent SciPy and `pandas` libraries to filter out the outliers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Z-score是在数据集上的一种度量，它为每个数据点提供一个值，说明该数据点相对于数据集的标准差和平均值分布的程度。我们可以使用z-score在数据集中数值检测异常值。通常，任何z-score大于+3或小于-3的数据点都被认为是异常值。我们可以借助优秀的SciPy和`pandas`库的概念来过滤异常值。
- en: 'Use SciPy and calculate the z-score by using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SciPy，使用以下命令计算z-score：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 6.19: The z-score values](img/C11065_06_19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19：z-score值](img/C11065_06_19.jpg)'
- en: 'Figure 6.19: The z-score values'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：z-score值
- en: 'Exercise 80: The Z-Score Value to Remove Outliers'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习80：用于去除异常值的Z分数
- en: 'In this exercise, we will discuss how to get rid of outliers in a set of data.
    In the last exercise, we calculated the z-score of each data point. In this exercise,
    we will use that to remove outliers from our data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将讨论如何从一组数据中去除异常值。在上一个练习中，我们计算了每个数据点的z分数。在这个练习中，我们将利用这个结果来从我们的数据中移除异常值：
- en: 'Import `pandas` and create a DataFrame:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`pandas`并创建一个DataFrame：
- en: '[PRE34]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Assign outliers with a z-score less than 3:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将z分数小于3的异常值分配给：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `print` function to print the new and old shape:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`print`函数打印新的和旧的形状：
- en: '[PRE36]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From the two prints (48, 1 and 50, 1), it is clear that the derived DataFrame
    has two rows less. These are our outliers. If we plot the `cos_arr_without_outliers`
    DataFrame, then we will see the following output:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从两个打印结果（48, 1和50, 1）中，我们可以清楚地看到派生的DataFrame少了两行。这些就是我们的异常值。如果我们绘制`cos_arr_without_outliers`
    DataFrame，那么我们将看到以下输出：
- en: '![](img/C11065_06_20.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_06_20.jpg)'
- en: 'Figure 6.20: Cosine wave without outliers'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：无异常值的余弦波
- en: As expected, we got back the smooth curve and got rid of the outliers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们得到了平滑的曲线并去除了异常值。
- en: Detecting and getting rid of outliers is an involving and critical process in
    any data wrangling pipeline. They need deep domain knowledge, expertise in descriptive
    statistics, mastery over the programming language (and all the useful libraries),
    and a lot of caution. We recommend being very careful when doing this operation
    on a dataset.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何数据清洗流程中，检测和去除异常值是一个复杂且关键的过程。这需要深厚的领域知识、描述性统计学的专业知识、对编程语言（以及所有有用的库）的掌握，以及大量的谨慎。我们建议在数据集上执行此操作时要非常小心。
- en: 'Exercise 81: Fuzzy Matching of Strings'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习81：字符串的模糊匹配
- en: In this exercise, we will look into a slightly different problem which, at the
    first glance, may look like an outlier. However, upon careful examination, we
    will see that it is indeed not, and we will learn about a useful concept that
    is sometimes referred to as fuzzy matching of strings.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨一个稍微不同的问题，乍一看可能看起来像是一个异常值。然而，经过仔细检查，我们会发现它确实不是，我们将了解一个有时被称为字符串模糊匹配的有用概念。
- en: Levenshtein distance is an advanced concept. We can think of it as the minimum
    number of single-character edits that are needed to convert one string into another.
    When two strings are identical, the distance between them is 0 – the more the
    difference, the higher the number. We can consider a threshold of distance under
    which we will consider two strings as the same. Thus, we can not only rectify
    human error but also spread a safety net so that we don't pass all the candidates.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein距离是一个高级概念。我们可以将其视为将一个字符串转换为另一个字符串所需的最小单字符编辑次数。当两个字符串相同的时候，它们之间的距离是0
    - 差异越大，数字越高。我们可以考虑一个距离阈值，低于这个阈值我们将认为两个字符串是相同的。因此，我们不仅可以纠正人为错误，还可以设置一个安全网，以确保我们不会通过所有候选者。
- en: 'Levenshtein distance calculation is an involving process, and we are not going
    to implement it from scratch here. Thankfully, like a lot of other things, there
    is a library available for us to do this. It is called [python-Levenshtein](https://github.com/ztane/python-Levenshtein/):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein距离计算是一个复杂的过程，我们不会在这里从头开始实现它。幸运的是，像很多其他事情一样，有一个库可供我们使用来完成这个任务。它被称为[python-Levenshtein](https://github.com/ztane/python-Levenshtein/)：
- en: Create the load data of a ship on three different dates:![](img/C11065_06_21.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建三艘船在不同日期的负载数据！[](img/C11065_06_21.jpg)
- en: 'Figure 6.21: Initialized ship_data variable'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.21：初始化ship_data变量
- en: If you look carefully, you will notice that the name of the ship is spelled
    differently in all three different cases. Let's assume that the actual name of
    the ship is "Sea Princess". From a normal perspective, it does look like there
    had been a human error and the data points do describe a single ship. Removing
    two of them on a strict basis of outliers may not be the best thing to do.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到船名在三种不同情况下拼写不同。让我们假设船的实际名称是"Sea Princess"。从正常的角度来看，这确实看起来像有人犯了错误，数据点确实描述了同一艘船。在严格基于异常值的基础上移除其中两个可能不是最好的做法。
- en: 'Then, we simply need to import the distance function from it and pass two strings
    to it to calculate the distance between them:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需从其中导入距离函数，并传递两个字符串给它来计算它们之间的距离：
- en: '[PRE37]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/C11065_06_22.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_06_22.jpg)'
- en: 'Figure 6.22: Distance between the strings'
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.22：字符串之间的距离
- en: We will notice that the distance between the strings are different. It is 0
    when they are identical, and it is a positive integer when they are not. We can
    use this concept in our data wrangling jobs and say that strings with distance
    less than or equal to a certain number is the same string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到字符串之间的距离是不同的。当它们相同的时候，距离是 0，当它们不同的时候，距离是一个正整数。我们可以在我们的数据处理工作中使用这个概念，并说距离小于或等于某个数字的字符串是相同的字符串。
- en: Here, again, we need to be cautious about when and how to use this kind of fuzzy
    string matching. Sometimes, they are needed, and other times they will result
    in a very bad bug.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次需要谨慎考虑何时以及如何使用这种模糊字符串匹配。有时，它们是必需的，而其他时候它们可能会导致非常糟糕的错误。
- en: 'Activity 8: Handling Outliers and Missing Data'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8：处理异常值和缺失数据
- en: In this activity, we will identify and get rid of outliers. Here, we have a
    CSV file. The goal here is to clean the data by using the knowledge that we have
    learned about so far and come up with a nicely formatted DataFrame. Identify the
    type of outliers and their effect on the data and clean the messy data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将识别并去除异常值。这里，我们有一个 CSV 文件。我们的目标是利用我们迄今为止学到的知识来清理数据，并创建一个格式良好的 DataFrame。识别异常值的类型及其对数据的影响，并清理混乱的数据。
- en: 'The steps that will help you solve this activity are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助你解决此活动的步骤如下：
- en: Read the `visit_data.csv` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取 `visit_data.csv` 文件。
- en: Check for duplicates.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查重复项。
- en: Check if any essential column contains NaN.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有任何重要列包含 NaN。
- en: Get rid of the outliers.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除异常值。
- en: Report the size difference.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告大小差异。
- en: Create a box plot to check for outliers.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个箱线图来检查异常值。
- en: Get rid of any outliers.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去除任何异常值。
- en: Note
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 312.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 312 页找到。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about interesting ways to deal with list data by
    using a `generator` expression. They are easy and elegant and once mastered, they
    give us a powerful trick that we can use repeatedly to simplify several common
    data wrangling tasks. We also examined different ways to format data. Formatting
    of data is not only useful for preparing beautiful reports – it is often very
    important to guarantee data integrity for the downstream system.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用生成器表达式处理列表数据的一些有趣方法。它们既简单又优雅，一旦掌握，就能给我们一个强大的技巧，我们可以反复使用它来简化几个常见的数据处理任务。我们还考察了不同的数据格式化方法。数据的格式化不仅对准备漂亮的报告有用，而且对于保证下游系统的数据完整性通常非常重要。
- en: We ended the chapter by checking out some methods to identify and remove outliers.
    This is important for us because we want our data to be properly prepared and
    ready for all our fancy downstream analysis jobs. We also observed how important
    it is to take time and use domain expertise to set up rules for identifying outliers,
    as doing this incorrectly can do more harm than good.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查一些识别和删除异常值的方法来结束本章。这对我们来说很重要，因为我们希望我们的数据得到适当的准备，并准备好进行所有复杂的数据分析工作。我们还观察到，花时间并利用领域专业知识来制定识别异常值的规则是多么重要，因为这样做可能会造成比好处更大的伤害。
- en: In the next chapter, we will cover the how to read web pages, XML files, and
    APIs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何读取网页、XML 文件和 API。
