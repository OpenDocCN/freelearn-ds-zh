<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 10. Visualizing Your Analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Visualizing Your Analysis</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generating a leaflet web map with Folium</li><li class="listitem" style="list-style-type: disc">Setting up TileStache to serve tiles</li><li class="listitem" style="list-style-type: disc">Visualizing DEM data with Three.js</li><li class="listitem" style="list-style-type: disc">Draping an orthophoto over a DEM</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec69"/>Introduction</h1></div></div></div><p>The great part about geospatial analysis is visualization. This chapter is all about showing some ways to visualize your analysis results. Up to this point, we have used QGIS, leaflet, and Openlayers 3 to see our results. Here, we will concentrate on web mapping with some of the newest libraries to publish our data.</p><p>Most of this code will mix Python with JavaScript, HTML, and CSS.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>An <a id="id441" class="indexterm"/>awesome list of visualization techniques and libraries can be found at <a class="ulink" href="http://selection.datavisualization.ch/">http://selection.datavisualization.ch/</a>.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Generating a leaflet web map with Folium"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Generating a leaflet web map with Folium</h1></div></div></div><p>Creating<a id="id442" class="indexterm"/> a web map with your own data is becoming<a id="id443" class="indexterm"/> easier with every new web mapping library. Folium (<a class="ulink" href="http://folium.readthedocs.org/">http://folium.readthedocs.org/</a>) is a small new Python project that can create<a id="id444" class="indexterm"/> a simple web map directly from your Python code, leveraging the leaflet JavaScript mapping library. This is still more than one line, but with under 20 lines of Python code, you can have Folium generate a nice web map for you.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec165"/>Getting ready</h2></div></div></div><p>Folium requires the Jinja2 template engine alongside Pandas for data binding. The nice part about this is that both are simple to install using <code class="literal">pip</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install jinja2</strong></span>
<span class="strong"><strong>pip install pandas</strong></span>
</pre></div><p>Instructions <a id="id445" class="indexterm"/>on using Pandas are also found<a id="id446" class="indexterm"/> in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec166"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now make sure that you are in your <code class="literal">/ch10/code/</code> folder to see the live example of Folium as follows:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import folium
import pandas as pd

# define the polygons
states_geojson = r'us-states.json'

# statistic data to connect to our polygons
state_unemployment = r'../www/html/US_Unemployment_Oct2012.csv'

# read the csv statistic data
state_data = pd.read_csv(state_unemployment)

# Let Folium determine the scale
map = folium.Map(location=[48, -102], zoom_start=3, tiles="Stamen Toner")

# create the leaflet map settings
map.geo_json(geo_path=states_geojson, data=state_data,
             columns=['State', 'Unemployment'],
             threshold_scale=[5, 6, 7, 8, 9, 10],
             key_on='feature.id',
             fill_color='YlGn', fill_opacity=0.7, line_opacity=0.2,
             legend_name='Unemployment Rate (%)')

# output the final map file
map.create_map(path='../www/html/ch10-01_folium_map.html')</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec167"/>How it works...</h2></div></div></div><p>Folium<a id="id447" class="indexterm"/> uses the Jinja2 Python template engine<a id="id448" class="indexterm"/> to render the final results and Pandas to bind the CSV statistic data. The code begins with importing and then defining the data sources. The GeoJSON file of the U.S. State polygons will be displayed as a <span class="strong"><strong>chloropleth map</strong></span>. A <a id="id449" class="indexterm"/>choropleth map is one that displays data values that are classified into a defined set of data ranges, usually based on some statistical method. Within the GeoJSON data is a key-filed named <code class="literal">id</code> with a value the U.S. State abbreviation code. This <code class="literal">id</code> binds the spatial data to the statistic CSV column that also includes a corresponding <code class="literal">id</code> field, hence allowing us to connect our two datasets.</p><p>Folium then needs to create a <code class="literal">map</code> object, setting the <code class="literal">map</code> center coordinates alongside a zoom level and a base tile map for our background. In our case, the <code class="literal">Stamen Toner</code> tile set is defined.</p><p>Next up, we define the vector GeoJSON that is going to appear on top of our background map. We need to pass in the path of our source GeoJSON and the Pandas data frame object that references our CSV file columns, <code class="literal">State</code> and <code class="literal">Unemployment</code>. Next, we set the linking key value that connects our CSV with the GeoJSON data. The <code class="literal">key_on</code> parameter reads the <code class="literal">id</code> GeoJSON properties key in the feature array.</p><p>Lastly, we set the color brewer to a color we want along with the style. The legend is a D3 legend that's automatically created for us and is scaled via quantiles.</p><div class="mediaobject"><img src="images/50790OS_10_01.jpg" alt="How it works..."/></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Setting up TileStache to serve tiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Setting up TileStache to serve tiles</h1></div></div></div><p>Once<a id="id450" class="indexterm"/> you have data and want to get it onto the Web, a server of some sort is required. TileStache, originally developed by Michal Migurski, is a Python tile map server that can pump out vector tiles. Vector tiles are the future of web mapping and make web map applications super fast. In the end, you will have a <code class="literal">TileStache</code> instance running and serving up a simple web map.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec168"/>Getting ready</h2></div></div></div><p>A few requirements are needed to get TileStache running on your machine, including Werkzeug, PIL, SimpleJson, and Modestmaps, so we must first install these. Let's start with running our <code class="literal">pip install</code> commands like this:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Getting <code class="literal">TileStache</code> to run on a full-blown server, such as Nginx or Apache, with <code class="literal">mod-python</code> is beyond the scope of this book but is highly recommended for production deployment (for more information on this refer to <a class="ulink" href="http://modpython.org/">http://modpython.org/</a>).</p></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install Werkzeug</strong></span>
<span class="strong"><strong>pip install modestmaps</strong></span>
<span class="strong"><strong>pip install simplejson</strong></span>
</pre></div><p>The Python<a id="id451" class="indexterm"/> library called <code class="literal">Werkzeug</code> (<a class="ulink" href="http://werkzeug.pocoo.org/">http://werkzeug.pocoo.org/</a>) is the WSGI server for our test application. Mapnik is not <a id="id452" class="indexterm"/>required, but go ahead and install it to view the demo application.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec169"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now let's<a id="id453" class="indexterm"/> download the most recent code from GitHub as a ZIP from <a class="ulink" href="https://github.com/TileStache/TileStache/archive/master.zip">https://github.com/TileStache/TileStache/archive/master.zip</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>Use the command-line <code class="literal">git</code> if you have it installed as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git clone https://github.com/TileStache/TileStache.git</strong></span>
</pre></div></div></div></li><li class="listitem">Unpack this into your <code class="literal">/ch10/TileStache-master</code> folder.</li><li class="listitem">Test and check whether your installation went smoothly by going into your <code class="literal">/ch10/TileStache-master/</code> directory and entering the following command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; python tilestache-server.py -c ../tilestache.cfg</strong></span>
</pre></div></li><li class="listitem">After running the preceding command, you should see this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>* Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)</strong></span>
</pre></div></li><li class="listitem">Now open up your web browser and type in <code class="literal">http://localhost:8080/</code>; you should see some simple text stating <code class="literal">TileStache belows hello</code>.</li><li class="listitem">Next, try to enter <code class="literal">http://localhost:8080/osm/0/0/0.png</code>; you will get the following output:<div class="mediaobject"><img src="images/50790OS_10_02.jpg" alt="How to do it..."/></div><p>This is the map of the world that you should be able to see.</p></li><li class="listitem">To <a id="id454" class="indexterm"/>get a live scrollable map around Vancouver, British Colombia, visit <code class="literal">http://localhost:8080/osm/preview.html#10/49.1725/-123.0719</code>.</li></ol></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Visualizing DEM data with Three.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Visualizing DEM data with Three.js</h1></div></div></div><p>You<a id="id455" class="indexterm"/> have a great 3D <span class="strong"><strong>Digital Elevation Model</strong></span> (<span class="strong"><strong>DEM</strong></span>) that<a id="id456" class="indexterm"/> you may want to view on a web <a id="id457" class="indexterm"/>page, so your choices are limited only to your imagination and programming skills. In this little example based on the great work of Bjorn Sandvik, we will explore the methods needed to manipulate a DEM to load a Three.js HTML-based web page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip26"/>Tip</h3><p>A great plugin that I would highly recommend for QGIS is the <span class="strong"><strong>qgis2threejs</strong></span> plugin, <a id="id458" class="indexterm"/>written by Minoru Akagi. The Python plugin code is available on GitHub at <a class="ulink" href="https://github.com/minorua/Qgis2threejs">https://github.com/minorua/Qgis2threejs</a> where you can find a nice <code class="literal">gdal2threejs.py</code> converter.</p></div></div><p>The resulting 3D DEM mesh can be viewed in your browser:</p><div class="mediaobject"><img src="images/50790OS_10_03.jpg" alt="Visualizing DEM data with Three.js"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec170"/>Getting ready</h2></div></div></div><a id="id459" class="indexterm"/><p>We need Jinja2 as our template engine (installed in the first section of this chapter) to create our HTML. The<a id="id460" class="indexterm"/> remaining requirements include JavaScript and our 3D DEM data. Our DEM data is from <a class="link" href="ch07.html" title="Chapter 7. Raster Analysis">Chapter 7</a>, <span class="emphasis"><em>Raster Analysis</em></span>, and is located in the <code class="literal">/ch07/geodata/dem_3857.dem</code> folder, so if you have not already downloaded all the data and code, do so now.</p><p>The <code class="literal">gdal_translate</code> GDAL executable is used to convert our DEM into an ENVI <code class="literal">.bin</code> 16-bit raster. This raster will contain the elevation values that the <code class="literal">threejs</code> library can read to create the 3D mesh.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip27"/>Tip</h3><p>Using an IDE is not always necessary, but in this case, the PyCharm Pro IDE is helpful since we are using HTML, JavaScript, and Python to create our results. There is also a free PyCharm community edition that I would also recommend but it lacks the HTML, JavaScript, and Jinja2 template support.</p></div></div><p>Three.js is available if you have downloaded the <code class="literal">/ch10/www/js</code> folder on your machine. If not, do so now and download the entire <code class="literal">/ch10/www/</code> folder. Inside it, you will find the folders needed for the output of HTML and the web templates used by Jinja2.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec171"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll <a id="id461" class="indexterm"/>start by running a subprocess <a id="id462" class="indexterm"/>call to generate the needed raster with elevation data for Three.js. Then, we'll step into the HTML template code containing a single <code class="literal">Jinja2</code> variable as follows:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import subprocess

from jinja2 import Environment, FileSystemLoader


# Create our DEM

# use gdal_translate command to create an image to store elevation values
# -scale from 0 meters to 2625 meters
#     stretch all values to full 16bit  0 to 65535
# -ot is output type = UInt16 unsigned 16bit
# -outsize is 200 x 200 px
# -of is output format ENVI raster image .bin file type
# then our input .tif with elevation
# followed by output file name .bin
subprocess.call("gdal_translate -scale 0 2625 0 65535 "
                "-ot UInt16 -outsize 200 200 -of ENVI "
                "../../ch07/geodata/dem_3857.tif "
                "../geodata/whistler2.bin")


# create our Jinja2 HTML
# create a standard Jinja2 Environment and load all files
# located in the folder templates
env = Environment(loader=FileSystemLoader(["../www/templates"]))

# define which template we want to render
template = env.get_template("base-3d-map.html")

# path and name of input 16bit raster image with our elevation values
dem_3d = "../../geodata/whistler2.bin"

# name and location of the output HTML file we will generate
out_html = "../www/html/ch10-03_dem3d_map.html"

# dem_file is the variable name we use in our Jinja2 HTML template file
result = template.render(title="Threejs DEM Viewer", dem_file=dem_3d)

# write out our template to the HTML file on disk
with open(out_html,mode="w") as f:
    f.write(result)</pre></div></li><li class="listitem">Our<a id="id463" class="indexterm"/> Jinja2 HTML template code <a id="id464" class="indexterm"/>only contains one simple variable called <code class="literal">{{ dem_3d }}</code> so that you can see what's happening clearly:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;DEM threejs Browser&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
    &lt;style&gt; body { margin: 0; overflow: hidden; }&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="dem-map"&gt;&lt;/div&gt;
    &lt;script src="../js/three.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/TrackballControls.js"&gt;&lt;/script&gt;
    &lt;script src="../js/TerrainLoader.js"&gt;&lt;/script&gt;
    &lt;script&gt;

        var width  = window.innerWidth,
            height = window.innerHeight;

        var scene = new THREE.Scene();

        var axes = new THREE.AxisHelper(200);
        scene.add(axes);

        var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, -50, 50);

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);

        var terrainLoader = new THREE.TerrainLoader();
        terrainLoader.load('{{ dem_3d }}', function(data) {

            var geometry = new THREE.PlaneGeometry(60, 60, 199, 199);

            for (var i = 0, l = geometry.vertices.length; i &lt; l; i++) {
                geometry.vertices[i].z = data[i] / 65535 * 10;
            }

            var material = new THREE.MeshPhongMaterial({
                color: 0xdddddd,
                wireframe: true
            });

            var plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

        });

        var controls = new THREE.TrackballControls(camera);

        document.getElementById('dem-map').appendChild(renderer.domElement);

        render();

        function render() {
            controls.update();
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec172"/>How it works...</h2></div></div></div><p>Our <code class="literal">gdal_translate</code> does the hard work for us by converting the DEM data into a raster <a id="id465" class="indexterm"/>format that Three.js can understand. The<a id="id466" class="indexterm"/> Jinja2 template HTML code shows us the required moving parts, starting with three JavaScript files. <code class="literal">TerrainLoader.js</code> reads this binary <code class="literal">.bin</code> format raster into the Three.js terrain.</p><p>Inside our HTML file, the JavaScript code shows how we can go about creating the Three.js scene where the most important part is creating <code class="literal">THREE.PlaneGeometry</code>. We assign each <code class="literal">geometry.vertices</code> the elevation height in this JavaScript <code class="literal">for</code> loop, assigning each vertex the flat plane of the elevation value.</p><p>We follow this with <code class="literal">MeshPhongMaterial</code> so that we can see the mesh on our screen as a wireframe. To view the resulting HTML file generated, you need to run a local web server and for this, Python comes with <code class="literal">SimpleHTTPServer</code> out of the box. This can be run from the command line as the following Python command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; python -m SimpleHTTPServer 8080</strong></span>
</pre></div><p>Then, go visit your browser and enter <code class="literal">http://localhost:8080/</code>; select the <code class="literal">html</code> folder, and then click on the <code class="literal">ch10-03_dem3d_map.html</code> file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>Using the PyCharm IDE, you can simply open the HTML file inside PyCharm, move your mouse to the upper right-hand corner of the open file, and select a browser, such as Chrome, to open a new HTML page. PyCharm will automatically start a web server for you and display the 3D terrain in your selected browser.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Draping an orthophoto over a DEM"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Draping an orthophoto over a DEM</h1></div></div></div><p>This <a id="id467" class="indexterm"/>time around, we are going to take our previous<a id="id468" class="indexterm"/> recipe to the next level by draping satellite imagery over our DEM to create a truly impressive 3D interactive web map.</p><div class="mediaobject"><img src="images/50790OS_10_04.jpg" alt="Draping an orthophoto over a DEM"/></div><p>You<a id="id469" class="indexterm"/> can take<a id="id470" class="indexterm"/> a look at <a id="id471" class="indexterm"/>other orthophotos from <code class="literal">geogratis.ca</code> at <a class="ulink" href="http://geogratis.gc.ca/api/en/nrcan-rncan/ess-sst/77618678-421b-4a28-a0a5-b074e5f072ff.html">http://geogratis.gc.ca/api/en/nrcan-rncan/ess-sst/77618678-421b-4a28-a0a5-b074e5f072ff.html</a>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec173"/>Getting ready</h2></div></div></div><p>To drape an orthophoto directly over our DEM, we need to make sure that the input DEM and the orthophoto have the same extent and pixel size. For this exercise, you need to complete the previous section and have data available in the <code class="literal">/ch10/geodata/092j02_1_1.tif</code> folder. This is the orthophoto that we are going to drape over the DEM.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec174"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's <a id="id472" class="indexterm"/>dive into some code that's full of <a id="id473" class="indexterm"/>comments for your enlightenment:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import subprocess
from PIL import Image
from jinja2 import Environment, FileSystemLoader


# convert from Canada UTM http://epsg.io/3157/map   to 3857
# transform the orthophto from epsg:3157 to epsg:3857
# cut the orthophoto to same extent of DEM
subprocess.call("gdalwarp -s_srs EPSG:3157 -t_srs EPSG:3857 -overwrite "
                "-te -13664479.091 6446253.250 -13636616.770 6489702.670"
                "/geodata/canimage_092j02_tif/092j02_1_1.tif ../geodata/whistler_ortho.tif")

# convert the new orthophoto into a 200 x 200 pixel image
subprocess.call("gdal_translate -outsize 200 200 "
                "../geodata/whistler_ortho.tif "
                "../geodata/whistler_ortho_f.tif")

# prepare to create new jpg output from .tif
processed_ortho = '../geodata/whistler_ortho_f.tif'
drape_texture = '../../geodata/whistler_ortho_f.jpg'

# export the .tif to a jpg to make is smaller for web using pil
Image.open(processed_ortho).save(drape_texture)

# set Jinja2 env and load folder where templates are located
env = Environment(loader=FileSystemLoader(["../www/templates"]))

# assign template to our HTML file with our variable inside
template = env.get_template( "base-3d-map-drape.html")

# define the original DEM file
dem_3d = "../../geodata/whistler2.bin"

# location of new HTML file to be output
out_html = "../www/html/ch10-04_dem3d_map_drape.html"

# create the new output HTML object and set variable names
result = template.render(title="Threejs DEM Drape Viewer", dem_file=dem_3d,
                         texture_map=drape_texture)

# write the new HTML file to disk
with open(out_html,mode="w") as file:
    file.write(result)</pre></div></li><li class="listitem">Our <a id="id474" class="indexterm"/>Jinja2 HTML template file looks <a id="id475" class="indexterm"/>like this:<div class="informalexample"><pre class="programlisting">&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;title&gt;DEM threejs Browser&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"&gt;
    &lt;style&gt; body { margin: 0; overflow: hidden; }&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="dem-map"&gt;&lt;/div&gt;
    &lt;script src="../js/three.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/TrackballControls.js"&gt;&lt;/script&gt;
    &lt;script src="../js/TerrainLoader.js"&gt;&lt;/script&gt;
    &lt;script&gt;

        var width  = window.innerWidth,
            height = window.innerHeight;

        var scene = new THREE.Scene();
        scene.add(new THREE.AmbientLight(0xeeeeee));
       
        var axes = new THREE.AxisHelper(200);
        scene.add(axes);

        var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
        camera.position.set(0, -50, 50);

        var renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);

        var terrainLoader = new THREE.TerrainLoader();
        terrainLoader.load('{{ dem_file }}', function(data) {

            var geometry = new THREE.PlaneGeometry(60, 60, 199, 199);

            for (var i = 0, l = geometry.vertices.length; i &lt; l; i++) {
                geometry.vertices[i].z = data[i] / 65535 * 10;
            }

            var material = new THREE.MeshPhongMaterial({
              map: THREE.ImageUtils.loadTexture('{{ texture_map }}')
            });

            var plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

        });

        var controls = new THREE.TrackballControls(camera);
        document.getElementById('dem-map').appendChild(renderer.domElement);
        render();
        function render() {
            controls.update();
            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec175"/>How it works...</h2></div></div></div><p>The main methodology for draping an orthophoto is the same as seen in the previous section, with a slight difference in the way we use the Three.js material rendering.</p><p>Data <a id="id476" class="indexterm"/>preparation plays the biggest and most important <a id="id477" class="indexterm"/>role once again to make things jive together. Inside our Python code, <code class="literal">Ch10-04_drapeOrtho.py</code> uses the subprocess call to execute the <code class="literal">gdalwarp</code> and <code class="literal">gdal_translate</code> command-line tools. Gdalwarp is first used by taking the original orthophoto in EPSG:3157 and converting it to the EPSG:3857 Web Mercator format. At the same time, it also cuts the original raster to the same extent as our DEM input. This extent is achieved by reading the <code class="literal">gdalinfo whistler.bin</code> raster command-line call.</p><p>After this, we need to cut the raster down to size and make a 200 x 200 pixel image to match our DEM size. This is followed by using PIL to transform the output <code class="literal">.tif</code> file into a much smaller <code class="literal">.jpg</code> file that's better suited for web presentations and speed.</p><p>With the major leg work out of the way, we can use Jinja2 to create our output HTML template and pass in two <code class="literal">dem_file</code>, variables pointing to the original DEM. The second variable called <code class="literal">texture_map</code> points to the newly created whistler <code class="literal">.jpg</code> that's used to drape over the DEM.</p><p>The final results are written to the <code class="literal">/ch10/www/html/ch10-04_dem3d_map_drape.html</code> folder for you to then open and view in the browser. To view this HTML file, you will need to start a local web server from the <code class="literal">/ch10/www/</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; python -m simpleHTTPServer 8080</strong></span>
</pre></div><p>Then, visit the browser at <code class="literal">http://localhost.8080/</code> and you should see a draped image on the DEM.</p></div></div></div>
</body></html>