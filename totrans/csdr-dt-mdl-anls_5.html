<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;First-cut Design and Implementation"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. First-cut Design and Implementation</h1></div></div></div><p>Riding on the ingredients of a Cassandra data model that were explained in the previous chapters, now it is time to put them into a working application. We will begin defining what we really want to store and inquire in the data model, setting up the environment, writing the program code, and finally testing the application.</p><p>The application to be built is a<a id="id365" class="indexterm"/> Stock Screener Application, which stores the historical stock quotes in a Cassandra database for technical analysis. The application collects the stock quote data from a free source on the Internet and then applies some technical analysis indicators to find out the buy and sell reference signals. A brief and quick introduction of technical analysis is given in order to enable you to easily understand what the application does. Although it is oversimplified in architecture and not complete in features, it does provide a good foundation for further improvement on more advanced features to be made by you.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>
<span class="strong"><strong>Disclaimer</strong></span>
</p><p>It should be assumed that the methods, techniques, or indicators discussed in this book will be profitable and will not result in losses. There is no assurance that the strategies and methods presented will be successful, or that you will become a profitable trader. The past performance and results of any trading system or trading methodology are not necessarily indicative of future results. You should not trade with money that you cannot afford to lose. The examples discussed and presented in this book are for educational purposes only. These are not solicitations of any order to buy or sell. I assume no responsibility for your trading results. No representation is being made that any account will, or is likely to, achieve profits or losses similar to those discussed in this book. There is a very high degree of risk in trading. You are encouraged to consult a certified financial advisor before making any investment or trading decisions.</p></div></div><div class="section" title="Stock Screener Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Stock Screener Application</h1></div></div></div><p>In this section, we will learn<a id="id366" class="indexterm"/> some background information of the sample application. Then, we will discuss the data source, the initial data model, and the high-level processing logic of the application.</p><div class="section" title="An introduction to financial analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>An introduction to financial analysis</h2></div></div></div><p>A stock screener is a<a id="id367" class="indexterm"/> utility program that uses a certain set of criteria to screen a large number of stocks that match your preferences. It is akin to a search engine on stocks but not on websites. The screening criteria might be<a id="id368" class="indexterm"/> based on fundamental and/or technical analysis methods.</p><p>Firstly, let us look at what fundamental analysis is.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>
<span class="strong"><strong>Fundamental analysis</strong></span>
</p><p>Fundamental analysis<a id="id369" class="indexterm"/> involves analyzing a company's historical and present financial statements and health, its management and competitive advantages, and its competitors and markets, in order to assess and calculate the value of a company stock and predict its probable price evolution. The goal is to make financial forecasts and find out the undervalued stock (stock that is cheap, in other words) for buy-and-hold.</p></div></div><p>In contrast, technical analysis is a totally different approach.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>
<span class="strong"><strong>Technical analysis</strong></span>
</p><p>Technical analysis is<a id="id370" class="indexterm"/> a stock analysis methodology used to forecast the direction of prices through the study of past market data, primarily price and volume. The fundamental principle of technical analysis is that the market price reflects all the relevant information, so the analysis looks at the history of the trading patterns rather than external drivers such as economic, fundamental, and news events.</p></div></div><p>In this book, technical analysis is solely used for the Stock Screener Application. As technical analysis focuses on price actions, the Stock Screener Application requires stock price data as its input and then it applies technical analysis techniques to determine whether the stock fulfills the buy or sell conditions. Whenever such a condition is fulfilled, we can say that a trading signal is triggered.</p><p>The conceptual design of the Stock Screener Application is shown in the following figure:</p><div class="mediaobject"><img src="graphics/8884OS_05_01.jpg" alt="An introduction to financial analysis"/></div><p>We will go through the<a id="id371" class="indexterm"/> preceding figure from the left to the right. <span class="strong"><strong>Data Feed Provider</strong></span> is the source of stock quote data that is collected from a free Data Feed<a id="id372" class="indexterm"/> Provider on the Internet, such as Yahoo! Finance. It should be noted that Yahoo! Finance provides free-of-charge <span class="strong"><strong>end-of-day</strong></span> (<span class="strong"><strong>EOD</strong></span>) <a id="id373" class="indexterm"/>stock quote data, thus providing the daily stock quote. If you want the <a id="id374" class="indexterm"/>
<span class="strong"><strong>Stock Screener</strong></span> to produce intraday signals, you need to look for other Data Feed Providers who typically have a wide range of paid service offers available. <span class="strong"><strong>Historical Data</strong></span><a id="id375" class="indexterm"/> is a repository to store the historical stock quote data. <span class="strong"><strong>Stock Screener</strong></span> is the application to be developed in this chapter. Lastly, <span class="strong"><strong>Alert List</strong></span> is<a id="id376" class="indexterm"/> a list of trading signals found by the <span class="strong"><strong>Stock Screener</strong></span>.</p><p>Before we proceed to the high-level design of the <span class="strong"><strong>Stock Screener</strong></span>, I would like to highlight the reasons of establishing the <span class="strong"><strong>Historical Data</strong></span> repository. There are three major reasons. First, it can save tremendous network bandwidth from repeatedly downloading historical stock quote data from the Data Feed Provider (actually, Yahoo! Finance provides as many as 10 years of historical price data.) Second, it serves as a canonical data model so that the <span class="strong"><strong>Stock Screener</strong></span> does not need to cater for the different data formats of different Data Feed Providers. Finally, the <span class="strong"><strong>Stock Screener</strong></span> can still perform technical analysis on the historical data even though it is disconnected from the Internet.</p></div><div class="section" title="Stock quote data"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Stock quote data</h2></div></div></div><p>Technical analysis only focuses<a id="id377" class="indexterm"/> on price action. So what is price action? Price action is simply the movement of a stock's price. It is encompassed in<a id="id378" class="indexterm"/> technical and chart pattern analysis in an attempt to discover the order in the seemingly random movement of price.</p><p>On a single day, the price action of a stock can be summarized by four important prices:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Open price</strong></span>: This is the <a id="id379" class="indexterm"/>starting price for that day</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>High price</strong></span>: This is the highest <a id="id380" class="indexterm"/>price for that day</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Low price</strong></span>: This is the lowest price<a id="id381" class="indexterm"/> for that day</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Close price</strong></span>: This is the<a id="id382" class="indexterm"/> closing price for that day</li></ul></div><p>These four prices are usually abbreviated as OHLC. In addition to OHLC, another measure of how much of a given stock has been traded in a given period of time is known as Volume. For a<a id="id383" class="indexterm"/> complete trading day, the volume is called daily volume.</p><p>Only five attributes such as <span class="strong"><strong>open price</strong></span>, <span class="strong"><strong>high price</strong></span>, <span class="strong"><strong>low price</strong></span>, <span class="strong"><strong>close price</strong></span>, and <span class="strong"><strong>volume</strong></span> (<span class="strong"><strong>OHLCV</strong></span>), provide all the <a id="id384" class="indexterm"/>necessary and sufficient data for technical analysis of stock. Now we know the input for technical analysis, but how do we get them?</p><p>Many websites provide<a id="id385" class="indexterm"/> free-of-charge stock quote data that are very easy to obtain, and are especially suitable for amateur or retail traders. The following<a id="id386" class="indexterm"/> websites are just a few of them listed for your<a id="id387" class="indexterm"/> reference:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Yahoo!<a id="id388" class="indexterm"/> Finance: <a class="ulink" href="http://finance.yahoo.com">http://finance.yahoo.com</a></li><li class="listitem" style="list-style-type: disc">Google<a id="id389" class="indexterm"/> Finance: <a class="ulink" href="https://www.google.com/finance">https://www.google.com/finance</a></li><li class="listitem" style="list-style-type: disc">EODData: <a class="ulink" href="http://eoddata.com">http://eoddata.com</a></li></ul></div><p>However, there is a caveat that stock quote data might have errors, for example, incorrect high and low prices. In this book, I selected Yahoo! Finance as the prime Data Feed Provider. The following screenshot is a sample of the historical prices of a stock called <span class="emphasis"><em>GS</em></span>:</p><div class="mediaobject"><img src="graphics/8884OS_05_02.jpg" alt="Stock quote data"/></div><p>As you scroll to the<a id="id390" class="indexterm"/> bottom of the web page, you<a id="id391" class="indexterm"/> will see a link <span class="emphasis"><em>Download to Spreadsheet</em></span>. When you click on this link, the historical stock quote <a id="id392" class="indexterm"/>data can be downloaded as a <a id="id393" class="indexterm"/>
<span class="strong"><strong>Comma Separated Values</strong></span> (<span class="strong"><strong>CSV</strong></span>) file. An excerpt of the CSV file is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_05_03.jpg" alt="Stock quote data"/></div><p>Of course, we can<a id="id394" class="indexterm"/> manually download the historical stock quote data from the website. Nonetheless, it becomes impractical when we want to<a id="id395" class="indexterm"/> download the data of many different stocks on a daily basis. Thus, we will develop a program to <a id="id396" class="indexterm"/>automatically collect the data feed.</p></div><div class="section" title="Initial data model"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Initial data model</h2></div></div></div><p>We now know that a single daily price action consists of a stock symbol, trading date, open price, high price, low price, close price, and volume. Obviously, a sequence of price action measured typically<a id="id397" class="indexterm"/> at successive trading days is of a time-series nature and Cassandra is very suitable for storing time-series type data.</p><p>As mentioned previously, it is beneficial<a id="id398" class="indexterm"/> to store the collected stock quote data<a id="id399" class="indexterm"/> locally in a repository. Therefore, we will implement the repository as a table in a Cassandra database.</p><p>We can use CQL to define a table called <code class="literal">quote</code> to store the historical prices:</p><div class="informalexample"><pre class="programlisting">// table to store historical stock quote data
CREATE TABLE quote (
  symbol varchar, // stock symbol
  price_time timestamp, // timestamp of quote
  open_price float, // open price
  high_price float, // high price
  low_price float, // low price
  close_price float, // close price
  volume double, // volume
  PRIMARY KEY (symbol, price_time) // primary key
);</pre></div><p>The column data types<a id="id400" class="indexterm"/> and names are self-explanatory.</p><p>One useful technique <a id="id401" class="indexterm"/>of designing a Cassandra data model is to imagine the<a id="id402" class="indexterm"/> visual representation of the internal storage of a row. The following figure is such an example:</p><div class="mediaobject"><img src="graphics/8884OS_05_04.jpg" alt="Initial data model"/></div><p>Based on the design of the primary key, the row key is <code class="literal">symbol</code> and the clustering column is <code class="literal">price_time</code>. It is expected that a row will become a wide row, as more historical stock quote data gets added to it. Without the internal storage picture, this might not be easy to spot in the initial data model design stage. For the time being, we just take note of the potential wide row problem and leave it as is (one possible solution is the date bucket pattern).</p></div><div class="section" title="Processing flow"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Processing flow</h2></div></div></div><p>The following figure shows<a id="id403" class="indexterm"/> the processing flow<a id="id404" class="indexterm"/> of the <span class="strong"><strong>Stock Screener</strong></span>, which elaborates the conceptual design with a more detailed sequence of steps. Each of the building blocks is explained starting first from the top, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_05_05.jpg" alt="Processing flow"/></div><p>
<span class="strong"><strong>Data Feed Provider</strong></span> <a id="id405" class="indexterm"/>consists of <span class="strong"><strong>Data Feed</strong></span>, <span class="strong"><strong>Data Feed Adapter</strong></span>, and <a id="id406" class="indexterm"/>
<span class="strong"><strong>Data Mapper and Archiver</strong></span>. Yahoo! Finance is <a id="id407" class="indexterm"/>chosen as the data feed. <span class="strong"><strong>Data Feed Adapter</strong></span><a id="id408" class="indexterm"/> is used to deal with the different connectivity <a id="id409" class="indexterm"/>and interfacing methods if we<a id="id410" class="indexterm"/> switch to other Data Feed<a id="id411" class="indexterm"/> Providers. <span class="strong"><strong>Data Mapper and Archiver</strong></span> caters for the different stock quote data formats and standardizes them to the corresponding columns of the <code class="literal">quote</code> table.</p><p>The <code class="literal">quote</code> table is the <span class="strong"><strong>Historical Data</strong></span> repository and has been explained previously.</p><p>We now turn our focus to the core <span class="strong"><strong>Stock Screener</strong></span>. The heart of the <span class="strong"><strong>Stock Screener</strong></span> is the <a id="id412" class="indexterm"/>
<span class="strong"><strong>Stock Screener Engine</strong></span> that uses the <a id="id413" class="indexterm"/>
<span class="strong"><strong>Screening Rule</strong></span> on the <span class="strong"><strong>Historical Data</strong></span>, which is filtered by<a id="id414" class="indexterm"/> the <span class="strong"><strong>Data Scoper</strong></span>. The <span class="strong"><strong>Screen Rule</strong></span> is<a id="id415" class="indexterm"/> used by one or more <span class="strong"><strong>Technical Analysis Signals</strong></span><a id="id416" class="indexterm"/> so that the <span class="strong"><strong>Stock Screener Engine</strong></span> produces an alert if the conditions of the <span class="strong"><strong>Technical Analysis Signals</strong></span> are met.</p><p>The alert generated by the <span class="strong"><strong>Stock Screener Engine</strong></span> is presented in the form of an<a id="id417" class="indexterm"/> <span class="strong"><strong>Alert List</strong></span>, which can be kept as records or distributed through other means.</p><p>Basically, the <span class="strong"><strong>Data Feed Provider</strong></span> and the <span class="strong"><strong>Stock Screener</strong></span> need not run in the same process. They work in an asynchronous mode. This means that the <span class="strong"><strong>Data Feed Provider</strong></span> can collect, map, and archive the historical stock quote data into the <span class="strong"><strong>Historical Data</strong></span> repository, whereas the <span class="strong"><strong>Stock Screener</strong></span> can analyze and produce alerts independently.</p><p>We have come up with<a id="id418" class="indexterm"/> a high-level design of the application, the next thing to do is conceivably see how it can be implemented.</p></div></div></div>
<div class="section" title="System design"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>System design</h1></div></div></div><p>In this section, we will select the<a id="id419" class="indexterm"/> appropriate software for various system components.</p><div class="section" title="The operating system"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>The operating system</h2></div></div></div><p>When considering<a id="id420" class="indexterm"/> the implementation, the first fundamental choice is the operating<a id="id421" class="indexterm"/> system. The single most important constraint is that it must be supported by Cassandra. For this book, I have selected Ubuntu 14.04 LTS 64-bit Version, which can be obtained at the<a id="id422" class="indexterm"/> official Ubuntu website, <a class="ulink" href="http://www.ubuntu.com/">http://www.ubuntu.com/</a>. You should be able to painlessly set up your Linux box by following the verbose installation instructions.</p><p>However, it is entirely up to you to use any other operating systems, supported by Cassandra, such as Microsoft Windows and Mac OS X. Please follow the respective operating system installation instructions to set up your machine. I have already considered the portability of the Stock Screener. As you will see in the subsequent sections, the Stock Screener Application is designed and developed in order to be compatible with a great number of operating systems.</p></div><div class="section" title="Java Runtime Environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Java Runtime Environment</h2></div></div></div><p>As Cassandra is Java-based, a<a id="id423" class="indexterm"/> <span class="strong"><strong>Java Runtime Environment</strong></span> (<span class="strong"><strong>JRE</strong></span>) is required as a prerequisite. I have <a id="id424" class="indexterm"/>used Oracle Java SE Runtime Environment 7 64-bit Version 1.7.0_65. It is provided<a id="id425" class="indexterm"/> at the following URL:<a class="ulink" href="http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html">http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html</a>.</p><p>Of course, I have downloaded the Linux x64 binary and followed the instructions at <a class="ulink" href="http://www.datastax.com/documentation/cassandra/2.0/cassandra/install/installJreDeb.html">http://www.datastax.com/documentation/cassandra/2.0/cassandra/install/installJreDeb.html</a> to properly set up the JRE.</p><p>At the time of writing, Java SE has been updated to Version 8. However, I have not tested JRE 8 and DataStax recommends JRE 7 for Cassandra 2.0 too. Therefore, I will stick to JRE 7 in this book.</p></div><div class="section" title="Java Native Access"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Java Native Access</h2></div></div></div><p>If you want to deploy Cassandra<a id="id426" class="indexterm"/> in production use on Linux platforms, <span class="strong"><strong>Java Native Access</strong></span> (<span class="strong"><strong>JNA</strong></span>) is required to improve Cassandra's memory usage. When installed and <a id="id427" class="indexterm"/>configured, Linux does not swap the <a id="id428" class="indexterm"/>
<span class="strong"><strong>Java virtual machine</strong></span> (<span class="strong"><strong>JVM</strong></span>), and thus avoids any performance related issues. This is recommended as a best practice even when Cassandra, which is to be installed, is for non-production use.</p><p>To install JNA on Ubuntu, simply use <a id="id429" class="indexterm"/>Aptitude Package Manager with the following command in a terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install libjna-java</strong></span>
</pre></div></div><div class="section" title="Cassandra version"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Cassandra version</h2></div></div></div><p>I used <a id="id430" class="indexterm"/>Cassandra Version 2.0.9, which is distributed by<a id="id431" class="indexterm"/> DataStax Community, on <a id="id432" class="indexterm"/>Debian or Ubuntu. The installation steps are well documented at <a class="ulink" href="http://www.datastax.com/documentation/getting_started/doc/getting_started/gettingStartedDeb_t.html">http://www.datastax.com/documentation/getting_started/doc/getting_started/gettingStartedDeb_t.html</a>.</p><p>The installation process typically takes several minutes depending on your Internet bandwidth and the performance of your machine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>
<span class="strong"><strong>DataStax</strong></span>
</p><p>DataStax is a<a id="id433" class="indexterm"/> computer software company based in Santa Clara, California which offers commercial enterprise grade for Apache Cassandra in its DataStax Enterprise product. It also provides tremendous support for the Apache Cassandra community.</p></div></div></div><div class="section" title="Programming language"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Programming language</h2></div></div></div><p>It is now time to turn our attention to the programming language for the implementation of the Stock Screener Application. For this book, I have chosen Python. Python is a high-level programming language <a id="id434" class="indexterm"/>designed for speed of development. It is open source, free, and cross-platform. It possesses a wealthy set of libraries for almost every popular algorithm you can imagine.</p><p>You need not be<a id="id435" class="indexterm"/> afraid of learning Python if you are not familiar with it. Python is designed such that it is very easy to learn when compared to other programming languages such as C++. Coding a Python program is pretty much like writing pseudocode that improves the speed of development.</p><p>In addition, there are many renowned Python libraries used for data analysis, for example, NumPy, SciPy, pandas, scikit-learn, and matplotlib. You can make use of them to quickly build a full-blown application with all the bells and whistles. For the Stock Screener Application, you will use NumPy and pandas extensively.</p><p>When it comes to high performance, Python can also utilize Cython, which is an optimizing static complier for Python programs to run as fast as native C or C++ programs.</p><p>The latest major version of Python is Python 3. However, there are still many programs running that are written in Python 2. This is caused by the breaking backward compatibility of Python 3 that makes the migration of so many libraries written in Python 2 to Python 3, a very long way to go. Hence, the coexistence of Python 2 and Python 3 is expected for quite a long time in future. For this book, Python 2.7.x is used.</p><p>The following<a id="id436" class="indexterm"/> steps are used to install Python 2.7 in Ubuntu using a terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get –y update</strong></span>
<span class="strong"><strong>$ sudo apt-get –y upgrade</strong></span>
<span class="strong"><strong>$ sudo apt-get install python-pip python-dev \</strong></span>
<span class="strong"><strong>$ python2.7-dev build-essential</strong></span>
</pre></div><p>Once the installation is complete, type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python --version</strong></span>
</pre></div><p>You should see the version string returned by Python, which tells you that the installation has been successful.</p><p>One problem that many Python beginners face is the cumbersome installation of the various library packages. To rectify this problem, I suggest that the reader downloads the Anaconda distribution. Anaconda is completely free and includes almost 200 of the most popular Python packages for Science, Mathematics, engineering, and data analysis. Although it is<a id="id437" class="indexterm"/> rather bulky in size, it frees you from the Python package hustle. Anaconda can be<a id="id438" class="indexterm"/> downloaded at <a class="ulink" href="http://continuum.io/downloads">http://continuum.io/downloads</a>, where you can select the appropriate versions <a id="id439" class="indexterm"/>of Python and the operating system. It is straightforward to install Anaconda by following the installation instructions, so I will not detail the steps here.</p></div><div class="section" title="Cassandra driver"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Cassandra driver</h2></div></div></div><p>The last item of the system<a id="id440" class="indexterm"/> environment is the driver software for Python to connect to a Cassandra database. In fact, there are several choices out there, for example, pycassa, Cassandra driver, and Thrift. I have chosen <a id="id441" class="indexterm"/>Python Driver 2.0 for Apache Cassandra distributed by DataStax. It exclusively supports CQL 3 and Cassandra's new binary protocol, which was introduced in Version 1.2. More detailed information<a id="id442" class="indexterm"/> can be found at <a class="ulink" href="http://www.datastax.com/documentation/developer/python-driver/2.0/common/drivers/introduction/introArchOverview_c.html">http://www.datastax.com/documentation/developer/python-driver/2.0/common/drivers/introduction/introArchOverview_c.html</a>.</p><p>The driver can be easily installed with pip in a Ubuntu terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install cassandra-driver</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>
<span class="strong"><strong>pip</strong></span>
</p><p>pip is a command-line package<a id="id443" class="indexterm"/> management system used to install and manage Python library packages. Its project page can be found <a id="id444" class="indexterm"/>at Github, <a class="ulink" href="https://github.com/pypa/pip">https://github.com/pypa/pip</a>.</p></div></div></div><div class="section" title="The integrated development environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>The integrated development environment</h2></div></div></div><p>Spyder is an open source, cross-platform <span class="strong"><strong>integrated development environment</strong></span> (<span class="strong"><strong>IDE</strong></span>), usually <a id="id445" class="indexterm"/>used for scientific <a id="id446" class="indexterm"/>programming in Python. It is automatically installed by Anaconda and integrates NumPy, SciPy, matplotlib, IPython, and other open source software. It is also<a id="id447" class="indexterm"/> my favorite Python development environment.</p><p>There are many other good and popular Python IDEs, such as IPython and Eclipse. The code in this book is friendly to these IDEs.</p></div><div class="section" title="The system overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>The system overview</h2></div></div></div><p>Alright, we have<a id="id448" class="indexterm"/> gone through the major system components of the Stock Screener Application and decided their implementation. The following figure depicts the system overview for the implementation of the application:</p><div class="mediaobject"><img src="graphics/8884OS_05_06.jpg" alt="The system overview"/></div><p>It is worth noting that the system will be developed on a single Ubuntu machine first and then on a single node Cassandra cluster (In <a class="link" href="ch07.html" title="Chapter 7. Deployment and Monitoring">Chapter 7</a>, <span class="emphasis"><em>Deployment and Monitoring</em></span>, we will expand the cluster<a id="id449" class="indexterm"/> to a two-node cluster). It serves as a limit to the superb clustering capabilities of Cassandra. However, from the software development perspective, the most important thing is to completely realize the required functionalities rather than splitting the significant efforts on the system or infrastructure components, which are of second priority.</p></div></div>
<div class="section" title="Code design and development"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Code design and development</h1></div></div></div><p>We are now entering the<a id="id450" class="indexterm"/> development stage. I will walk<a id="id451" class="indexterm"/> you through the coding of the application building blocks step-by-step. Logically, two core modules<a id="id452" class="indexterm"/> will be built, namely, Data Feed Provider and Stock Screener. First, we will build the Data Feed Provider.</p><div class="section" title="Data Feed Provider"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Data Feed Provider</h2></div></div></div><p>The Data Feed Provider<a id="id453" class="indexterm"/> achieves the following three tasks:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Collecting the historical stock quote data from Yahoo! Finance.</li><li class="listitem">Transforming the received data into a standardized format.</li><li class="listitem">Saving the standardized data into the Cassandra database.</li></ol></div><p>Python has a well-known<a id="id454" class="indexterm"/> data analysis library called pandas. It is an <a id="id455" class="indexterm"/>open source library providing high-performance, easy-to-use data structures, and data analysis tools, especially, for time-series<a id="id456" class="indexterm"/> type of data. You can go to <a class="ulink" href="http://pandas.pydata.org/">http://pandas.pydata.org/</a> for more details.</p><div class="section" title="Collecting stock quote"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Collecting stock quote</h3></div></div></div><p>pandas offers a <code class="literal">DataReader</code> function in its <code class="literal">pandas.io.data</code> package. <code class="literal">DataReader</code> extracts financial data from various Internet <a id="id457" class="indexterm"/>sources into a<a id="id458" class="indexterm"/> data structure known as <code class="literal">DataFrame</code>. Yahoo! Finance is one of the supported Internet sources, making the collection of the historical stock quote data a piece of cake. Refer to the following Python code, <code class="literal">cha</code>
<code class="literal">pter05_001.py</code>:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_001.py

## web is the shorthand alias of pandas.io.data
import pandas.io.data as web
import datetime

## we want to retrieve the historical daily stock quote of
## Goldman Sachs from Yahoo! Finance for the period
## between 1-Jan-2012 and 28-Jun-2014
symbol = 'GS'
start_date = datetime.datetime(2012, 1, 1)
end_date = datetime.datetime(2014, 6, 28)

## data is a DataFrame holding the daily stock quote
data = web.DataReader(symbol, 'yahoo', start_date, end_date)

## use a for-loop to print out the data
for index, row in data.iterrows():
    print index.date(), '\t', row['Open'], '\t', row['High'], \
          '\t', row['Low'], '\t', row['Close'], '\t', row['Volume']</pre></div><p>A brief explanation is required. pandas offers a very handy data structure called <code class="literal">DataFrame</code>, which is a two-dimensional labeled data structure with columns of potentially different<a id="id459" class="indexterm"/> types. You can think of it as a spreadsheet or SQL table. It is generally the most commonly <a id="id460" class="indexterm"/>used pandas object.</p><p>The following is a screenshot demonstrating the use of Spyder to write and test <code class="literal">chapter05_001.py</code> code:</p><div class="mediaobject"><img src="graphics/8884OS_05_07.jpg" alt="Collecting stock quote"/></div><p>The left-hand side of the Spyder IDE is the place where you write Python code. The middle panel on the right-hand side is the <span class="strong"><strong>IPython console</strong></span> that runs the code.</p></div><div class="section" title="Transforming data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Transforming data</h3></div></div></div><p>Along with the data in the <code class="literal">DataFrame</code>, you can optionally pass index (row labels) and columns (column labels). The row and column labels can be accessed respectively, by accessing the index and columns attributes. For example, you can revisit the screenshot of <code class="literal">table.csv</code> and see that the <a id="id461" class="indexterm"/>column names returned by Yahoo! Finance are <span class="strong"><strong>Date</strong></span>, <span class="strong"><strong>Open</strong></span>, <span class="strong"><strong>High</strong></span>, <span class="strong"><strong>Low</strong></span>, <span class="strong"><strong>Close</strong></span>, <span class="strong"><strong>Volume</strong></span>, and <span class="strong"><strong>Adj Close</strong></span>, respectively. <code class="literal">DataReader</code> uses <span class="strong"><strong>Date</strong></span> as the index of the returned <code class="literal">DataFrame</code>. The remaining column names become the column labels of the <code class="literal">DataFrame</code>.</p><p>The last for-loop in <code class="literal">chapter05_001.py</code> is also worth some remarks. <code class="literal">DataFrame</code> has a function, <code class="literal">iterrows()</code>, for iterating<a id="id462" class="indexterm"/> over its rows as (index, columns) pairs. Therefore, the for-loop uses <code class="literal">iterrows()</code> to iterate the daily stock quotes and we simply print out the index (that is converted to a string by the <code class="literal">date()</code> function), and the <span class="strong"><strong>Open</strong></span>, <span class="strong"><strong>High</strong></span>, <span class="strong"><strong>Low</strong></span>, <span class="strong"><strong>Close</strong></span>, <span class="strong"><strong>Volume</strong></span> columns by passing the respective column labels to the row. <span class="strong"><strong>Adj Close</strong></span> is a close price with adjustments of stock split, merge, and dividend. We do not use this, as we want to focus on pure prices.</p><p>Please be aware that stock quote data from the different sources might have different formats and, needless to say, different column names. Therefore, we need to take care of such a subtle difference, when mapping them to our standardized data model. <code class="literal">DataFrame</code> provides a very handy way to retrieve the data by column names and a few useful functions to manipulate the index and columns. We can make use of them to standardize the data format, as shown in <code class="literal">chapter05_002.py</code>:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_002.py

## web is the shorthand alias of pandas.io.data
import pandas.io.data as web
import datetime

## we want to retrieve the historical daily stock quote of
## Goldman Sachs from Yahoo! Finance for the period
## between 1-Jan-2012 and 28-Jun-2014
symbol = 'GS'
start_date = datetime.datetime(2012, 1, 1)
end_date = datetime.datetime(2014, 6, 28)

## data is a DataFrame holding the daily stock quote
data = web.DataReader(symbol, 'yahoo', start_date, end_date)

## standardize the column names
## rename index column to price_date to match the Cassandra table
data.index.names=['price_date']

## drop extra column 'Adj Close'
data = data.drop(['Adj Close'], axis=1)

## rename the columns to match the respective columns in Cassandra
data = data.rename(columns={'Open':'open_price', \
                            'High':'high_price', \
                            'Low':'low_price', \
                            'Close':'close_price', \
                            'Volume':'volume'})

## use a for-loop to print out the transformed data
for index, row in data.iterrows():
    print index.date(), '\t', row['open_price'], '\t', \
                              row['high_price'], '\t', \
                              row['low_price'], '\t', \
                              row['close_price'], '\t', \
                              row['volume']</pre></div></div><div class="section" title="Storing data in Cassandra"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec12"/>Storing data in Cassandra</h3></div></div></div><p>Before storing the retrieved data<a id="id463" class="indexterm"/> in Cassandra, we need to create the keyspace and table in the Cassandra database. We will create a keyspace <a id="id464" class="indexterm"/>called <code class="literal">packtcdma</code> and a table called <code class="literal">quote</code> in <code class="literal">chapter05_003.py</code> to hold the Historical Data, as shown in the <a id="id465" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_003.py

## import Cassandra driver library
from cassandra.cluster import Cluster

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect()

## create keyspace packtcdma if not exists
## currently it runs on a single-node cluster
session.execute("CREATE KEYSPACE IF NOT EXISTS packtcdma " + \
                "WITH replication" + \
                "={'class':'SimpleStrategy', " + \
                "'replication_factor':1}")

## use packtcdma keyspace
session.set_keyspace('packtcdma')

## execute CQL statement to create quote table if not exists
session.execute('CREATE TABLE IF NOT EXISTS quote (' + \
                'symbol varchar,' + \
                'price_time timestamp,' + \
                'open_price float,' + \
                'high_price float,' + \
                'low_price float,' + \
                'close_price float,' + \
                'volume double,' + \
                'PRIMARY KEY (symbol, price_time))')

## close Cassandra connection
cluster.shutdown()</pre></div><p>The comments of the code are sufficient to explain what it is doing. Now, we have the Historical Data<a id="id466" class="indexterm"/> repository ready and what follows is to store the received data into it. This is exactly the purpose<a id="id467" class="indexterm"/> of <code class="literal">chapter05_004.py</code> in which a Python function is created to insert the<a id="id468" class="indexterm"/> data, as shown in the following code:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_004.py

## import Cassandra driver library
from cassandra.cluster import Cluster
from decimal import Decimal

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## d: standardized DataFrame containing historical data
def insert_quote(ss, sym, d):
    ## CQL to insert data, ? is the placeholder for parameters
    insert_cql = 'INSERT INTO quote (' + \
                 'symbol, price_time, open_price, high_price,' + \
                 'low_price, close_price, volume' + \
                 ') VALUES (' + \
                 '?, ?, ?, ?, ?, ?, ?' + \
                 ')'
    ## prepare the insert CQL as it will run repeatedly
    insert_stmt = ss.prepare(insert_cql)

    ## set decimal places to 4 digits
    getcontext().prec = 4

    ## loop thru the DataFrame and insert records
    for index, row in d.iterrows():
        ss.execute(insert_stmt, \
                   [sym, index, \
                   Decimal(row['open_price']), \
                   Decimal(row['high_price']), \
                   Decimal(row['low_price']), \
                   Decimal(row['close_price']), \
                   Decimal(row['volume']) \
                   ])</pre></div><p>Although <code class="literal">chapter05_004.py</code> contains less than ten lines of code, it is rather complicated and needs some explanation.</p><p>We can create a function<a id="id469" class="indexterm"/> in Python using the keyword <code class="literal">def</code>. This must be followed by the function name and the parenthesized list of formal<a id="id470" class="indexterm"/> parameters. The <a id="id471" class="indexterm"/>code that form the body of the function starts in the next line, indented by a tab. Thus, in <code class="literal">chapter05_004.py</code>, the function name is <code class="literal">insert_quote()</code> with three parameters, namely, <code class="literal">ss</code>, <code class="literal">sym</code>, and <code class="literal">d</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>
<span class="strong"><strong>Indentation in Python</strong></span>
</p><p>In Python, leading whitespace (spaces and tabs) at the beginning of a logical line is used to compute the indentation level of the line, which in turn is used to determine the grouping of statements. Be very careful of this. Most of the Python IDE has features to check against the indentations. The article on the myths about indentation of Python is worth reading, which is available at <a class="ulink" href="http://www.secnetix.de/olli/Python/block_indentation.hawk">http://www.secnetix.de/olli/Python/block_indentation.hawk</a>.</p></div></div><p>The second interesting thing is the <code class="literal">prepare()</code> function. It is used to prepare CQL statements that are parsed by Cassandra and then saved for later use. When the driver uses a prepared<a id="id472" class="indexterm"/> statement, it only needs to send the values of parameters to bind. This lowers network traffic and CPU utilization as a result of<a id="id473" class="indexterm"/> the avoidance of re-parsing the statement each time.</p><p>The placeholders for <a id="id474" class="indexterm"/>prepared statements are <code class="literal">?</code> characters so that the parameters are passed in sequence. This method is called positional parameter passing.</p><p>The last segment of code is a for-loop that iterates through the <code class="literal">DataFrame</code> and inserts each row into the quote table. We also use the <code class="literal">Decimal()</code> function to cast the string into numeric value.</p></div><div class="section" title="Putting them all together"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec13"/>Putting them all together</h3></div></div></div><p>All pieces of Python<a id="id475" class="indexterm"/> code can be combined to make the Data Feed Provider. To make the code cleaner, the code fragment for the collection of stock quote is encapsulated in a function called <code class="literal">collect_data()</code> and that for data transformation in <code class="literal">transform_yahoo()</code> function. The complete program, <code class="literal">chapter05_</code>
<code class="literal">005.py</code>, is listed as follows:.</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_005.py

## import Cassandra driver library
from cassandra.cluster import Cluster
from decimal import Decimal

## web is the shorthand alias of pandas.io.data
import pandas.io.data as web
import datetime

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## d: standardized DataFrame containing historical data
def insert_quote(ss, sym, d):
    ## CQL to insert data, ? is the placeholder for parameters
    insert_cql = "INSERT INTO quote (" + \
                 "symbol, price_time, open_price, high_price," + \
                 "low_price, close_price, volume" + \
                 ") VALUES (" + \
                 "?, ?, ?, ?, ?, ?, ?" + \
                 ")"
    ## prepare the insert CQL as it will run repeatedly
    insert_stmt = ss.prepare(insert_cql)

    ## set decimal places to 4 digits
    getcontext().prec = 4

    ## loop thru the DataFrame and insert records
    for index, row in d.iterrows():
        ss.execute(insert_stmt, \
                   [sym, index, \
                   Decimal(row['open_price']), \
                   Decimal(row['high_price']), \
                   Decimal(row['low_price']), \
                   Decimal(row['close_price']), \
                   Decimal(row['volume']) \
                   ])

## retrieve the historical daily stock quote from Yahoo! Finance
## Parameters
## sym: stock symbol
## sd: start date
## ed: end date
def collect_data(sym, sd, ed):
    ## data is a DataFrame holding the daily stock quote
    data = web.DataReader(sym, 'yahoo', sd, ed)
    return data

## transform received data into standardized format
## Parameter
## d: DataFrame containing Yahoo! Finance stock quote
def transform_yahoo(d):
    ## drop extra column 'Adj Close'
    d1 = d.drop(['Adj Close'], axis=1)

    ## standardize the column names
    ## rename index column to price_date
    d1.index.names=['price_date']

    ## rename the columns to match the respective columns
    d1 = d1.rename(columns={'Open':'open_price', \
                            'High':'high_price', \
                            'Low':'low_price', \
                            'Close':'close_price', \
                            'Volume':'volume'})
    return d1

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect('packtcdma')

symbol = 'GS'
start_date = datetime.datetime(2012, 1, 1)
end_date = datetime.datetime(2014, 6, 28)

## collect data
data = collect_data(symbol, start_date, end_date)

## transform Yahoo! Finance data
data = transform_yahoo(data)

## insert historical data
insert_quote(session, symbol, data)

## close Cassandra connection
cluster.shutdown()</pre></div></div></div><div class="section" title="Stock Screener"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Stock Screener</h2></div></div></div><p>The Stock Screener<a id="id476" class="indexterm"/> retrieves historical data<a id="id477" class="indexterm"/> from the Cassandra database <a id="id478" class="indexterm"/>and applies technical analysis techniques to produce alerts. It has four components:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Retrieve historical data over a specified period</li><li class="listitem">Program a technical analysis indicator for time-series data</li><li class="listitem">Apply the screening rule to the historical data</li><li class="listitem">Produce alert signals</li></ol></div><div class="section" title="Data Scoper"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Data Scoper</h3></div></div></div><p>To utilize technical<a id="id479" class="indexterm"/> analysis techniques, a sufficient optimal number of stock quote data is required for calculation. We do not need to use all the stored data, and therefore a subset of data <a id="id480" class="indexterm"/>should be retrieved for processing. The following code, <code class="literal">chapte05_006.py</code>, retrieves the historical data from the table quote within a specified period:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_006.py

import pandas as pd
import numpy as np

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## sd: start date
## ed: end date
## return a DataFrame of stock quote
def retrieve_data(ss, sym, sd, ed):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT * FROM quote WHERE symbol=? " + \"AND price_time &gt;= ? AND price_time &lt;= ?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [sym, sd, ed])

    ## initialize an index array
    idx = np.asarray([])

    ## initialize an array for columns
    cols = np.asarray([])

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        idx = np.append(idx, [r.price_time])
        cols = np.append(cols, [r.open_price, r.high_price, \r.low_price, r.close_price, r.volume])

    ## reshape the 1-D array into a 2-D array for each day
    cols = cols.reshape(idx.shape[0], 5)

    ## convert the arrays into a pandas DataFrame
    df = pd.DataFrame(cols, index=idx, \
                      columns=['close_price', 'high_price', \
                      'low_price', 'close_price', 'volume'])
    return df</pre></div><p>The first portion of the function should be easy to understand. It executes a <code class="literal">select_cql</code> query for a particular stock symbol over a specified date period. The clustering column, <code class="literal">price_time</code>, makes range <a id="id481" class="indexterm"/>query possible here. The query result set is returned and used to fill two NumPy arrays, <code class="literal">idx</code> for index, and <code class="literal">cols</code> for columns. The <code class="literal">cols</code> array is then reshaped as a two-dimensional<a id="id482" class="indexterm"/> array with rows of prices and volume for each day. Finally, both <code class="literal">idx</code> and <code class="literal">cols</code> arrays are used to create a <code class="literal">DataFrame</code> to return <code class="literal">df</code>.</p></div><div class="section" title="Time-series data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Time-series data</h3></div></div></div><p>As a simple illustration, we use a 10-day <a id="id483" class="indexterm"/>
<span class="strong"><strong>Simple Moving Average</strong></span> (<span class="strong"><strong>SMA</strong></span>) as the technical analysis signal for stock screening. pandas provides a rich set of functions to work with time-series data. The SMA<a id="id484" class="indexterm"/> can be easily computed by the <code class="literal">rolling_mean()</code> function, as shown in <code class="literal">chapter05_007.py</code>:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_007.py

import pandas as pd

## function to compute a Simple Moving Average on a DataFrame
## d: DataFrame
## prd: period of SMA
## return a DataFrame with an additional column of SMA
def sma(d, prd):
    d['sma'] = pd.rolling_mean(d.close_price, prd)
    return d</pre></div></div><div class="section" title="The screening rule"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec16"/>The screening rule</h3></div></div></div><p>When SMA is<a id="id485" class="indexterm"/> calculated, we <a id="id486" class="indexterm"/>can apply a screening rule in order to look for trading signals. A very simple rule is adopted: a buy-and-hold signal is generated whenever a trading day whose close price is higher than 10-day SMA. In Python, it is just a one<a id="id487" class="indexterm"/> liner by virtue of pandas power. Amazing! Here is an example:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_008.py

## function to apply screening rule to generate buy signals
## screening rule, Close &gt; 10-Day SMA
## d: DataFrame
## return a DataFrame containing buy signals
def signal_close_higher_than_sma10(d):
    return d[d.close_price &gt; d.sma]</pre></div></div><div class="section" title="The Stock Screener engine"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec17"/>The Stock Screener engine</h3></div></div></div><p>Until now, we coded the<a id="id488" class="indexterm"/> components of the Stock Screener. We now<a id="id489" class="indexterm"/> combine them together to generate the Alert List, as shown in the following code:</p><div class="informalexample"><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter05_009.py

## import Cassandra driver library
from cassandra.cluster import Cluster

import pandas as pd
import numpy as np
import datetime

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## sd: start date
## ed: end date
## return a DataFrame of stock quote
def retrieve_data(ss, sym, sd, ed):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT * FROM quote WHERE symbol=? " + \"AND price_time &gt;= ? AND price_time &lt;= ?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [sym, sd, ed])

    ## initialize an index array
    idx = np.asarray([])

    ## initialize an array for columns
    cols = np.asarray([])

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        idx = np.append(idx, [r.price_time])
        cols = np.append(cols, [r.open_price, r.high_price, \
                         r.low_price, r.close_price, r.volume])

    ## reshape the 1-D array into a 2-D array for each day
    cols = cols.reshape(idx.shape[0], 5)

    ## convert the arrays into a pandas DataFrame
    df = pd.DataFrame(cols, index=idx, \
                      columns=['open_price', 'high_price', \
                      'low_price', 'close_price', 'volume'])
    return df

## function to compute a Simple Moving Average on a DataFrame
## d: DataFrame
## prd: period of SMA
## return a DataFrame with an additional column of SMA
def sma(d, prd):
    d['sma'] = pd.rolling_mean(d.close_price, prd)
    return d

## function to apply screening rule to generate buy signals
## screening rule, Close &gt; 10-Day SMA
## d: DataFrame
## return a DataFrame containing buy signals
def signal_close_higher_than_sma10(d):
    return d[d.close_price &gt; d.sma]

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect('packtcdma')
## scan buy-and-hold signals for GS over 1 month since 28-Jun-2012
symbol = 'GS'
start_date = datetime.datetime(2012, 6, 28)
end_date = datetime.datetime(2012, 7, 28)

## retrieve data
data = retrieve_data(session, symbol, start_date, end_date)

## close Cassandra connection
cluster.shutdown()

## compute 10-Day SMA
data = sma(data, 10)

## generate the buy-and-hold signals
alerts = signal_close_higher_than_sma10(data)

## print out the alert list
for index, r in alerts.iterrows():
    print index.date(), '\t', r['close_price']</pre></div></div></div></div>
<div class="section" title="Test run"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Test run</h1></div></div></div><p>An End-to-End Test consists of two parts. First, we test and verify <code class="literal">chapter05_005.py</code>, which is the complete Data Feed Provider module. Then run <code class="literal">chapter05_005.py</code> in Spyder. Historical stock quote data should be stored in the Cassandra database. Then run and verify the Stock Screener module, <code class="literal">chapter05_009.py</code>, also in Spyder.</p><p>A sample screen of the test run<a id="id490" class="indexterm"/> is shown in the following screenshot. The Alert List should have seven buy-and-hold trading signals:</p><div class="mediaobject"><img src="graphics/8884OS_05_08.jpg" alt="Test run"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>This chapter was rather jam-packed. We designed a simple stock screening application that collects stock quote data from Yahoo! Finance, which uses Cassandra as its repository. The system environment of the application was also introduced with brief setup instructions. Then we developed the application in Python with a step-by-step explanation. Despite of using one Cassandra table, the basic row manipulation logic has been demonstrated.</p><p>In the next chapter, we will continue enhancing the Stock Screener Application to collect stock quote data of a bunch of stocks and optimize the application with several refinements.</p></div></body></html>