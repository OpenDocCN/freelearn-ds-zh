- en: 'Chapter 1: Getting Started with spaCy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will have a comprehensive introduction to **natural language
    processing** (**NLP**) application development with Python and **spaCy**. First,
    we will see how NLP development goes hand in hand with **Python**, along with
    an overview of what **spaCy** offers as a Python library.
  prefs: []
  type: TYPE_NORMAL
- en: After the warm-up, you will quickly get started with spaCy by downloading the
    library and loading the models. You will then explore spaCy's popular visualizer
    **displaCy** by visualizing several features of spaCy.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know what you can achieve with spaCy and
    how to plan your journey with spaCy code. You will be also settled with your development
    environment, having already installed all the necessary packages for NLP tasks
    in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of spaCy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing spaCy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing spaCy's statistical models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualization with displaCy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The chapter code can be found at the book''s GitHub repository: [https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of spaCy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before getting started with the spaCy code, we will first have an overview of
    NLP applications in real life, NLP with Python, and NLP with spaCy. In this section,
    we'll find out the reasons to use Python and spaCy for developing NLP applications.
    We will first see how Python goes hand-in-hand with text processing, then we'll
    understand spaCy's place in the Python NLP libraries. Let's start our tour with
    the close-knit relationship between Python and NLP.
  prefs: []
  type: TYPE_NORMAL
- en: Rise of NLP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the past few years, most of the branches of AI created a lot of buzz, including
    NLP, computer vision, and predictive analytics, among others. But just what is
    NLP? How can a machine or code solve human language?
  prefs: []
  type: TYPE_NORMAL
- en: 'NLP is a subfield of AI that analyzes text, speech, and other forms of human-generated
    language data. Human language is complicated – even a short paragraph contains
    references to the previous words, pointers to real-world objects, cultural references,
    and the writer''s or speaker''s personal experiences. *Figure 1.1* shows such
    an example sentence, which includes a reference to a relative date (*recently*),
    phrases that can be resolved only by another person who knows the speaker (regarding
    the city that the speaker''s parents live in) and who has general knowledge about
    the world (a city is a place where human beings live together):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – An example of human language, containing many cognitive and
    cultural aspects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – An example of human language, containing many cognitive and cultural
    aspects
  prefs: []
  type: TYPE_NORMAL
- en: How do we process such a complicated structure then? We have our weapons too;
    we model natural language with statistical models, and we process linguistic features
    to turn the text into a well-structured representation. This book provides all
    the necessary background and tools for you to extract the meaning out of text.
    By the end of this book, you will possess statistical and linguistic knowledge
    to process text by using a great tool – the spaCy library.
  prefs: []
  type: TYPE_NORMAL
- en: Though NLP gained popularity recently, processing human language has been present
    in our lives via many real-world applications, including search engines, translation
    services, and recommendation engines.
  prefs: []
  type: TYPE_NORMAL
- en: Search engines such as Google Search, Yahoo Search, and Microsoft Bing are an
    integral part of our daily lives. We look for homework help, cooking recipes,
    information about celebrities, the latest episodes of our favorite TV series;
    all sorts of information that we use in our daily lives. There is even a verb
    in English (also in many other languages), *to google*, meaning *to look up some
    information on the Google search engine*.
  prefs: []
  type: TYPE_NORMAL
- en: Search engines use advanced NLP techniques including mapping queries into a
    semantic space, where similar queries are represented by similar vectors. A quick
    trick is called **autocomplete**, where query suggestions appear on the search
    bar when we type the first few letters. Autocomplete looks tricky but indeed the
    algorithm is a combination of a search tree walk and character-level distance
    calculation. A past query is represented by a sequence of its characters, where
    each character corresponds to a node in the search tree. The **arcs** between
    the characters are assigned weights according to the popularity of this past query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, when a new query comes, we compare the current query string to past queries
    by walking on the tree. A fundamental **Computer Science** (**CS**) data structure,
    the tree, is used to represent a list of queries, who would have thought that?
    *Figure 1.2* shows a walk on the character tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – An autocomplete example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – An autocomplete example
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simplified explanation; the real algorithms blend several techniques
    usually. If you want to learn more about this subject, you can read the great
    articles about the data structures: [http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata](http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata)
    and [http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees](http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with search engines, search engines also know how to transform unstructured
    data to structured and linked data. When we type `Diana Spencer` into the search
    bar, this is what comes up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Search results for the query "Diana Spencer"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Search results for the query "Diana Spencer"
  prefs: []
  type: TYPE_NORMAL
- en: How did the search engine link `Diana Spencer` to her well-known name *Princess
    Diana*? This is called **entity linking**. We link entities that mention the same
    real-world entity. Entity-linking algorithms concern representing semantic relations
    and knowledge in general. This area of NLP is called the **Semantic Web**. You
    can learn more about this at [https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/](https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/).
    I worked as a knowledge engineer at a search engine company at the beginning of
    my career and really enjoyed it. This is a fascinating subject in NLP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is really no limit to what you can develop: search engine algorithms,
    chatbots, speech recognition applications, and user sentiment recognition applications.
    NLP problems are challenging yet fascinating. This book''s mission is to provide
    you a toolbox with all the necessary tools. The first step of NLP development
    is choosing the programming language we will use wisely. In the next section,
    we will explain why Python is the weapon of choice. Let''s move on to the next
    section to see the string bond of NLP and Python.'
  prefs: []
  type: TYPE_NORMAL
- en: NLP with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we remarked before, NLP is a subfield of AI that analyzes text, speech,
    and other forms of human-generated language data. As an industry professional,
    my first choice for manipulating text data is Python. In general, there are many
    benefits to using Python:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to read and looks very similar to pseudocode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to produce and test code with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a high level of abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python is a great choice for developing NLP systems because of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: Python is easy to learn. You can focus on NLP rather than the
    programming language details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: It allows for easier development of quick NLP application prototypes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Popularity**: Python is one of the most popular languages. It has huge community
    support, and installing new libraries with pip is effortless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AI ecosystem presence**: A significant number of open source NLP libraries
    are available in Python. Many **machine learning** (**ML**) libraries such as
    PyTorch, TensorFlow, and Apache Spark also provide Python APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sentenc.split()`, which can be quite painful in other languages, such as C++,
    where you have to deal with stream objects for this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we put all the preceding points together, the following image appears
    – Python intersects with string processing, the AI ecosystem, and ML libraries
    to provide us the best NLP development experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – NLP with Python overview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – NLP with Python overview
  prefs: []
  type: TYPE_NORMAL
- en: We will use Python 3.5+ throughout this book. Users who do not already have
    Python installed can follow the instructions at [https://realpython.com/installing-python/](https://realpython.com/installing-python/).
    We recommend downloading and using the latest version of Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.x, the default encoding is **Unicode**, which means that we can
    use Unicode text without worrying much about the encoding. We won't go into details
    of encodings here, but you can think of Unicode as an extended set of ASCII, including
    more characters such as German-alphabet umlauts and the accented characters of
    the French alphabet. This way we can process German, French, and many more languages
    other than English.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing some useful string operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, the text is represented by `str` class. Strings are immutable sequences
    of characters. Creating a string object is easy – we enclose the text in quotation
    marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `word` variable contains the string `Hello World`. As we mentioned,
    strings are sequences of characters, so we can ask for the first item of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Always remember to use parentheses with `print`, since we are coding in Python
    3.x. We can similarly access other indices, as long as the index doesn''t go out
    of bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'How about string length? We can use the `len` method, just like with `list`
    and other sequence types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also iterate over the characters of a string with sequence methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: Please mind the indentation throughout the book. Indentation in Python is the
    way we determine the control blocks and function definitions in general, and we
    will apply this convention in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's go over the more string methods such as counting characters, finding
    a substring, and changing letter case.
  prefs: []
  type: TYPE_NORMAL
- en: '`count` counts the number of occurrences of a character in the string, so the
    output is `3` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, you need to find the index of a character for a number of substring
    operations such as cutting and slicing the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can search for substrings in a string with the `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`find` returns `–1` if the substring is not in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Searching for the last occurrence of a substring is also easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change letter case by the `upper` and `lower` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `upper` method changes all characters to uppercase. Similarly, the `lower`
    method changes all characters to lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `capitalize` method capitalizes the first character of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `title` method makes the string title case. Title case literally means
    *to make a title*, so each word of the string is capitalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Forming new strings from other strings can be done in several ways. We can
    concatenate two strings by adding them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also multiply a string with an integer. The output will be the string
    concatenated to itself by the number of times specified by the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`join` is a frequently used method; it takes a list of strings and joins them
    into one string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a variety of substring methods. Replacing a substring means changing
    all of its occurrences with another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a substring by index is called **slicing**. You can slice a string
    by specifying the start index and end index. If we want only the second word,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the first word is similar. Leaving the first index blank means the
    index starts from zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Leaving the second index blank has a special meaning as well – it means the
    rest of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now know some of the Pythonic NLP operations. Now we can dive into more of
    spaCy.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a high-level overview of the spaCy library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: spaCy is an open source Python library for modern NLP. The creators of spaCy
    describe their work as **industrial-strength NLP**, and as a contributor I can
    assure you it is true. spaCy is shipped with pretrained language models and word
    vectors for 60+ languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'spaCy is focused on production and shipping code, unlike its more academic
    predecessors. The most famous and frequently used Python predecessor is **NLTK**.
    NLTK''s main focus was providing students and researchers an idea of language
    processing. It never put any claims on efficiency, model accuracy, or being an
    industrial-strength library. spaCy focused on providing production-ready code
    from the first day. You can expect models to perform on real-world data, the code
    to be efficient, and the ability to process a huge amount of text data in a reasonable
    time. The following table is an efficiency comparison from the spaCy documentation
    (https://spacy.io/usage/facts-figures#speed-comparison):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – A speed comparison of spaCy and other popular NLP frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – A speed comparison of spaCy and other popular NLP frameworks
  prefs: []
  type: TYPE_NORMAL
- en: The spaCy code is also maintained in a professional way, with issues sorted
    by labels and new releases covering as many fixes as possible. You can always
    raise an issue on the spaCy GitHub repo at https://github.com/explosion/spaCy,
    report a bug, or ask for help from the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another predecessor is **CoreNLP** (also known as **StanfordNLP**). CoreNLP
    is implemented in Java. Though CoreNLP competes in terms of efficiency, Python
    won by easy prototyping and spaCy is much more professional as a software package.
    The code is well maintained, issues are tracked on GitHub, and every issue is
    marked with some labels (such as bug, feature, new project). Also, the installation
    of the library code and the models is easy. Together with providing backward compatibility,
    this makes spaCy a professional software project. Here is a detailed comparison
    from the spaCy documentation at https://spacy.io/usage/facts-figures#comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – A feature comparison of spaCy, NLTK, and CoreNLP'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – A feature comparison of spaCy, NLTK, and CoreNLP
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, we will be using spaCy''s latest releases, *v2.3* and
    *v3.0* (the versions used at the time of writing this book) for all our computational
    linguistics and ML purposes. The following are the features in the latest release:'
  prefs: []
  type: TYPE_NORMAL
- en: Original data preserving tokenization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical sentence segmentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named entity recognition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part-of-Speech** (**POS**) tagging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretrained word vectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy integration with popular deep learning libraries. spaCy's ML library `Thinc`
    provides thin wrappers around PyTorch, TensorFlow, and MXNet. spaCy also provides
    wrappers for `HuggingFace` Transformers by `spacy-transformers` library. We'll
    see more of the `Transformers` in [*Chapter 9*](B16570_09_Final_JM_ePub.xhtml#_idTextAnchor158)*,
    spaCy and Transformers*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Industrial-level speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A built-in visualizer, displaCy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for 60+ languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 46 state-of-the-art statistical models for 16 languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Space-efficient string data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient serialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy model packaging and usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large community support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We had a quick glance around spaCy as an NLP library and as a software package.
    We will see what spaCy offers in detail throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for the reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This book is a practical guide. In order to get the most out of the book, I
    recommend readers replicate the code in their own Python shell. Without following
    and performing the code, it is not possible to get a proper understanding of NLP
    concepts and spaCy methods, which is why we have arranged the upcoming chapters
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation of the language/ML concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application code with spaCy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation of the outcome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges of the methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pro tips and tricks to overcome the challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing spaCy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started by installing and setting up spaCy. spaCy is compatible with
    64-bit Python 2.7 and 3.5+, and can run on Unix/Linux, macOS/OS X, and Windows.
    `pip` (https://pypi.org/) and `conda` (https://conda.io/en/latest/). `pip` and
    `conda` are two of the most popular distribution packages.
  prefs: []
  type: TYPE_NORMAL
- en: '`pip` is the most painless choice as it installs all the dependencies, so let''s
    start with it.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing spaCy with pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can install spaCy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one Python version installed in your system (such as
    Python 2.8, Python 3.5, Python 3.8, and so on), then select the `pip` associated
    with Python you want to use. For instance, if you want to use spaCy with Python
    3.5, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have spaCy installed on your system, you may want to upgrade
    to the latest version of spaCy. We''re using *spaCy 2.3* in this book; you can
    check which version you have with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a version info output looks like. This has been generated with
    the help of my Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – An example spaCy version output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – An example spaCy version output
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to upgrade your spaCy version. You can upgrade your spaCy
    version to the latest available version with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Installing spaCy with conda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`conda` support is provided by the conda community. The command for installing
    spaCy with `conda` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Installing spaCy on macOS/OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'macOS and OS X already ship with Python. You only need to install a recent
    version of the Xcode IDE. After installing Xcode, please run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This installs the command-line development tools. Then you will be able to follow
    the preceding `pip` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Installing spaCy on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a Windows system, you need to install a version of Visual C++ Build
    Tools or Visual Studio Express that matches your Python distribution. Here are
    the official distributions and their matching versions, taken from the spaCy installation
    guide (https://spacy.io/usage#source-windows):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Visual Studio and Python distribution compatibility table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Visual Studio and Python distribution compatibility table
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t encounter any problems so far, then that means spaCy is installed
    and running on your system. You should be able to import spaCy into your Python
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now you successfully installed spaCy – congrats and welcome to the spaCy universe!
    If you have installation problems please continue to the next section, otherwise
    you can move on to language model installation.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting while installing spaCy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There might be cases where you get issues popping up during the installation
    process. The good news is, we're using a very popular library so most probably
    other developers have already encountered the same issues. Most of the issues
    are listed on *Stack Overflow* ([https://stackoverflow.com/questions/tagged/spacy](https://stackoverflow.com/questions/tagged/spacy))
    and the *spaCy GitHub* Issues section ([https://github.com/explosion/spaCy/issues](https://github.com/explosion/spaCy/issues))
    already. However, in this section, we'll go over the most common issues and their
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most common issues are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Python distribution is incompatible**: In this case please upgrade your
    Python version accordingly and then do a fresh installation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The upgrade broke spaCy**: Most probably there are some leftover packages
    in your installation directories. The best solution is to first remove the spaCy
    package completely by doing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then do a fresh installation by following the installation instructions mentioned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**You''re unable to install spaCy on a Mac**: On a Mac, please make sure that
    you don''t skip the following to make sure you correctly installed the Mac command-line
    tools and enabled pip:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In general, if you have the correct Python dependencies, the installation process
    will go smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: We're all set up and ready for our first usage of spaCy, so let's go ahead and
    start using spaCy's language models.
  prefs: []
  type: TYPE_NORMAL
- en: Installing spaCy's statistical models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The spaCy installation doesn't come with the statistical language models needed
    for the spaCy pipeline tasks. spaCy language models contain knowledge about a
    specific language collected from a set of resources. Language models let us perform
    a variety of NLP tasks, including **POS tagging** and **named-entity recognition**
    (**NER**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Different languages have different models and are language specific. There
    are also different models available for the same language. We''ll see the differences
    between those models in detail in the *Pro tip* at the end of this section, but
    basically the training data is different. The underlying statistical algorithm
    is the same. Some of the currently supported languages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – spaCy models overview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – spaCy models overview
  prefs: []
  type: TYPE_NORMAL
- en: The number of supported languages grows rapidly. You can follow the list of
    supported languages on the **spaCy Models and Languages** page ([https://spacy.io/usage/models#languages](https://spacy.io/usage/models#languages)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Several pretrained models are available for different languages. For English,
    the following models are available for download: `en_core_web_sm`, `en_core_web_md`,
    and `en_core_web_lg`. These models use the following naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`en` for English, `de` for German, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core` means a general-purpose model for the vocabulary, syntax, entities,
    and vectors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web`(Wikipedia), `news` (news, media) `Twitter`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lg` for large, `md` for medium, and `sm` for small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what a typical language model looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – The small-sized spaCy English web model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – The small-sized spaCy English web model
  prefs: []
  type: TYPE_NORMAL
- en: Large models can require a lot of disk space, for example `en_core_web_lg` takes
    up 746 MB, while `en_core_web_md` needs 48MB and `en_core_web_sm` takes only 11MB.
    Medium-sized models work well for many development purposes, so we'll use the
    English `md`model throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to match model genre to your text type. We recommend picking
    the genre as close as possible to your text. For example, the vocabulary in the
    social media genre will be very different from that in the Wikipedia genre. You
    can pick the web genre if you have social media posts, newspaper articles, financial
    news – that is, more language from daily life. The Wikipedia genre is suitable
    for rather formal articles, long documents, and technical documents. In case you
    are not sure which genre is the most suitable, you can download several models
    and test some example sentences from your own corpus and see how each model performs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're well-informed about how to choose a model, let's download our
    first model.
  prefs: []
  type: TYPE_NORMAL
- en: Installing language models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since v1.7.0, spaCy offers a great benefit: installing the models as Python
    packages. You can install spaCy models just like any other Python module and make
    them a part of your Python application. They''re properly versioned, so they can
    go into your `requirements.txt` file as a dependency. You can install the models
    from a download URL or a local director manually, or via `pip`. You can put the
    model data anywhere on your local filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download a model via spaCy''s `download` command. `download` looks
    for the most compatible model for your spaCy version, and then downloads and installs
    it. This way you don''t need to bother about any potential mismatch between the
    model and your spaCy version. This is the easiest way to install a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command selects and downloads the most compatible version of
    this specific model for your local spaCy version. Another option is to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands install the most compatible *default* model for each language
    and create a shortcut link. To download the exact model version, the following
    is what needs to be done (though you often don''t need it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `download` command deploys `pip` behind the scenes. When you make a download,
    `pip` installs the package and places it in your `site-packages` directory just
    as any other installed Python package.
  prefs: []
  type: TYPE_NORMAL
- en: After the download, we can load the packages via spaCy's `load ()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we did so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can provide the full model name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also download models via `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need the link to the model we want to download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We navigate to the model releases (https://github.com/explosion/spacy-models/releases),
    find the model, and copy the archive file link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we do a `pip install` with the model link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example command for downloading with a custom URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install a local file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This installs the model into your `site-packages` directory. Then we run `spacy.load()`
    to load the model via its package name, create a shortcut link to give it a custom
    name (usually a shorter name), or import it as a module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing the language model as a module is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Pro tip
  prefs: []
  type: TYPE_NORMAL
- en: In professional software development, we usually download models as part of
    an automated pipeline. In this case, it's not feasible to use spaCy's `download`
    command; rather, we use `pip` with the model URL. You can add the model into your
    `requirements.txt` file as a package as well.
  prefs: []
  type: TYPE_NORMAL
- en: How you like to load your models is your choice and also depends on the project
    requirements you're working on.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we're ready to explore the spaCy world. Let's now learn about
    spaCy's powerful visualization tool, **displaCy**.
  prefs: []
  type: TYPE_NORMAL
- en: Visualization with displaCy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Visualization** is an important tool that should be in every data scientist''s
    toolbox. Visualization is the easiest way to explain some concepts to your colleagues,
    your boss, and any technical or non-technical audience. Visualization of language
    data is specifically useful and allows you to identify patterns in your data at
    a glance.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many Python libraries and plugins such as *Matplotlib*, *seaborn*,
    *TensorBoard*, and so on. Being an industrial library, spaCy comes with its own
    visualizer – `Doc` object. We'll start by exploring the easiest way – using displaCy's
    interactive demo.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with displaCy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go ahead and navigate to [https://explosion.ai/demos/displacy](https://explosion.ai/demos/displacy)
    to use the interactive demo. Enter your text in the **Text to parse** box and
    then click the search icon on the right to generate the visualization. The result
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – displaCy''s online demo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – displaCy's online demo
  prefs: []
  type: TYPE_NORMAL
- en: The visualizer performs two syntactic parses, POS tagging, and a **dependency
    parse**, on the submitted text to visualize the sentence's syntactic structure.
    Don't worry about how POS tagging and dependency parsing work, as we'll explore
    them in the upcoming chapters. For now, just think of the result as a sentence
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice two tick boxes, **Merge Punctuation** and **Merge Phrases**. Merging
    punctuation merges the punctuation tokens into the previous token and serves a
    more compact visualization (it works like a charm on long documents).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option, `They were beautiful and healthy kids with strong appetites.`
    It contains two noun phrases, `beautiful and healthy kids` and `strong appetite`.
    If we merge them, the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – An example parse with noun phrases merged'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – An example parse with noun phrases merged
  prefs: []
  type: TYPE_NORMAL
- en: 'Without merging, every adjective and noun are shown individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – A parse of the same sentence, unmerged'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – A parse of the same sentence, unmerged
  prefs: []
  type: TYPE_NORMAL
- en: The second parse is a bit too cumbersome and difficult to read. If you work
    on a text with long sentences such as law articles or Wikipedia entries, we definitely
    recommend merging.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose a statistical model from the **Model** box on the right for the
    currently supported languages. This option allows you to play around with the
    language models without having to download and install them on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Entity visualizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: displaCy's entity visualizer highlights the named entities in your text. The
    online demo lives at [https://explosion.ai/demos/displacy-ent/](https://explosion.ai/demos/displacy-ent/).
    We didn't go through named entities yet, but you can think of them as proper nouns
    for important entities such as people's names, company names, dates, city and
    country names, and so on. Extracting entities will be covered in [*Chapter 3*](B16570_03_Final_JM_ePub.xhtml#_idTextAnchor055),
    *Linguistic Features*, and [*Chapter 4*](B16570_04_Final_JM_ePub.xhtml#_idTextAnchor069),
    *Rule-Based Matching*, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The online demo works similar to the syntactic parser demo. Enter your text
    into the textbox and hit the search button. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – An example entity visualization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – An example entity visualization
  prefs: []
  type: TYPE_NORMAL
- en: The right side contains tick boxes for entity types. You can tick the boxes
    that match your text type such as, for instance, **MONEY** and **QUANTITY** for
    a financial text. Again, just like in the syntactic parser demo, you can choose
    from the available models.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing within Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the introduction of the latest version of spaCy, the displaCy visualizers
    are integrated into the core library. This means that you can start using displaCy
    immediately after installing spaCy on your machine! Let's go through some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code segment is the easiest way to spin up displaCy on your local
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding snippet, the following is what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: We import `spaCy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following that, we import `displaCy` from the core library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We load the English model that we downloaded in the *Installing spaCy's statistical
    models* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it is loaded, we create a `Doc` object to pass to `displaCy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then started the `displaCy` web server via calling `serve()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also passed `dep` to the `style` parameter to see the dependency parsing
    result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After firing up this code, you should see a response from displaCy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15 – Firing up displaCy locally'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.15 – Firing up displaCy locally
  prefs: []
  type: TYPE_NORMAL
- en: 'The response is added along with a link, `http://0.0.0.0:5000`, this is the
    local address where displaCy renders your graphics. Please click the link and
    navigate to the web page. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16 – View the result visualization in your browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.16 – View the result visualization in your browser
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that displaCy generated a dependency parse result visualization
    and rendered it on your localhost. After you''re finished with displaying the
    visual and you want to shut down the server, you can press *Ctrl* +*C* to shut
    down the displaCy server and go back to the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Shutting down the displaCy server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.17 – Shutting down the displaCy server
  prefs: []
  type: TYPE_NORMAL
- en: After shutting down, you won't be able to visualize more examples, but you'll
    continue seeing the results you already generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to use another port or you get an error because the port `5000`
    is already in use, you can use the `port` parameter of displaCy with another port
    number. Replacing the last line of the preceding code block with the following
    line will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provide the port number `5001` explicitly. In this case, displaCy will
    render the graphics on `http://0.0.0.0:5001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating an entity recognizer is done similarly. We pass `ent` to the `style`
    parameter instead of `dep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – The entity visualization is displayed on your browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.18 – The entity visualization is displayed on your browser
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to other platforms we can use for displaying the results.
  prefs: []
  type: TYPE_NORMAL
- en: Using displaCy in Jupyter notebooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jupyter notebook is an important part of daily data science work. Fortunately,
    displaCy can spot whether you're currently coding in a Jupyter notebook environment
    and returns markup that can be directly displayed in a cell.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have Jupyter notebook installed on your system but wish to use
    it, you can follow the instructions at [https://test-jupyter.readthedocs.io/en/latest/install.html](https://test-jupyter.readthedocs.io/en/latest/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we''ll call `render()` instead of `serve()`. The rest of the code
    is the same. You can type/paste the following code into your Jupyter notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – displaCy rendering results in a Jupyter notebook'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16570_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.19 – displaCy rendering results in a Jupyter notebook
  prefs: []
  type: TYPE_NORMAL
- en: Exporting displaCy graphics as an image file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, we need to export the graphics that we generated with displaCy as image
    files to place them into presentations, articles, or papers. We can call displaCy
    in this case as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We import `spaCy` and `displaCy`. We load the English language model, then create
    a `Doc` object as usual. Then we call `displacy.render()` and capture the output
    to the `svg` variable. The rest is writing the `svg` variable to a file called
    `butterfly.svg`.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of the visualization chapter here. We created good-looking
    visuals and learned the details of creating visuals with displaCy. If you wish
    to find out how to use different background images, background colors, and fonts,
    you can visit the displaCy documentation at [http://spacy.io/usage/visualizers](http://spacy.io/usage/visualizers).
  prefs: []
  type: TYPE_NORMAL
- en: Often, we need to create visuals with different colors and styling, and the
    displaCy documentation contains detailed information about styling. The documentation
    also includes how to embed displaCy into your web applications. spaCy is well
    documented as a project and the documentation contains everything we need!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter gave you an introduction to NLP with Python and spaCy. You now
    have a brief idea about why to use Python for language processing and the reasons
    to prefer spaCy for creating your NLP applications. We also got started on our
    spaCy journey by installing spaCy and downloading language models. This chapter
    also introduced us to the visualization tool – displaCy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exciting spaCy journey with spaCy
    core operations such as tokenization and lemmatization. It'll be our first encounter
    with spaCy features in detail. Let's go ahead and explore more together!
  prefs: []
  type: TYPE_NORMAL
