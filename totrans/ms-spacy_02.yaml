- en: 'Chapter 1: Getting Started with spaCy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：spaCy 入门
- en: In this chapter, we will have a comprehensive introduction to **natural language
    processing** (**NLP**) application development with Python and **spaCy**. First,
    we will see how NLP development goes hand in hand with **Python**, along with
    an overview of what **spaCy** offers as a Python library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将全面介绍使用 Python 和 spaCy 开发的自然语言处理（NLP）应用程序开发。首先，我们将看到 NLP 开发如何与 Python
    密不可分，以及 spaCy 作为 Python 库提供的内容概述。
- en: After the warm-up, you will quickly get started with spaCy by downloading the
    library and loading the models. You will then explore spaCy's popular visualizer
    **displaCy** by visualizing several features of spaCy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 经过热身之后，您将快速开始使用 spaCy，通过下载库和加载模型。然后，您将通过可视化 spaCy 的几个功能来探索 spaCy 的流行可视化器 **displaCy**。
- en: By the end of this chapter, you will know what you can achieve with spaCy and
    how to plan your journey with spaCy code. You will be also settled with your development
    environment, having already installed all the necessary packages for NLP tasks
    in the upcoming sections.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解使用 spaCy 可以实现什么，以及如何使用 spaCy 代码规划您的旅程。您也将对您的开发环境感到满意，因为您已经在接下来的章节中安装了所有必要的
    NLP 任务包。
- en: 'We''re going to cover the following main topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Overview of spaCy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spaCy 概述
- en: Installing spaCy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 spaCy
- en: Installing spaCy's statistical models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 spaCy 的统计模型
- en: Visualization with displaCy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 displaCy 进行可视化
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter code can be found at the book''s GitHub repository: [https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01](https://github.com/PacktPublishing/Mastering-spaCy/tree/main/Chapter01)
- en: Overview of spaCy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: spaCy 概述
- en: Before getting started with the spaCy code, we will first have an overview of
    NLP applications in real life, NLP with Python, and NLP with spaCy. In this section,
    we'll find out the reasons to use Python and spaCy for developing NLP applications.
    We will first see how Python goes hand-in-hand with text processing, then we'll
    understand spaCy's place in the Python NLP libraries. Let's start our tour with
    the close-knit relationship between Python and NLP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习 spaCy 代码之前，我们将首先概述 NLP 在现实生活中的应用、使用 Python 的 NLP 以及使用 spaCy 的 NLP。在本节中，我们将了解为什么使用
    Python 和 spaCy 开发 NLP 应用程序的原因。我们将首先看到 Python 如何与文本处理紧密结合，然后我们将了解 spaCy 在 Python
    NLP 库中的位置。让我们从 Python 和 NLP 之间的紧密关系开始我们的探索之旅。
- en: Rise of NLP
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NLP 的兴起
- en: Over the past few years, most of the branches of AI created a lot of buzz, including
    NLP, computer vision, and predictive analytics, among others. But just what is
    NLP? How can a machine or code solve human language?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，人工智能的许多分支都引起了很大的关注，包括 NLP、计算机视觉和预测分析等。但 NLP 究竟是什么？机器或代码如何解决人类语言？
- en: 'NLP is a subfield of AI that analyzes text, speech, and other forms of human-generated
    language data. Human language is complicated – even a short paragraph contains
    references to the previous words, pointers to real-world objects, cultural references,
    and the writer''s or speaker''s personal experiences. *Figure 1.1* shows such
    an example sentence, which includes a reference to a relative date (*recently*),
    phrases that can be resolved only by another person who knows the speaker (regarding
    the city that the speaker''s parents live in) and who has general knowledge about
    the world (a city is a place where human beings live together):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NLP 是人工智能的一个子领域，它分析文本、语音和其他形式的人类生成语言数据。人类语言很复杂——即使是简短的段落也包含对先前单词的引用、指向现实世界对象的指针、文化引用以及作者或说话者的个人经历。*图
    1.1* 展示了这样一个示例句子，它包括对相对日期（*最近*）的引用，只有了解说话者的人才能解决的短语（关于说话者父母居住的城市），以及拥有关于世界的普遍知识的人（城市是人类共同生活的地方）：
- en: '![Figure 1.1 – An example of human language, containing many cognitive and
    cultural aspects'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 包含许多认知和文化方面的人类语言示例'
- en: '](img/B16570_01_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_01.jpg)'
- en: Figure 1.1 – An example of human language, containing many cognitive and cultural
    aspects
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 包含许多认知和文化方面的人类语言示例
- en: How do we process such a complicated structure then? We have our weapons too;
    we model natural language with statistical models, and we process linguistic features
    to turn the text into a well-structured representation. This book provides all
    the necessary background and tools for you to extract the meaning out of text.
    By the end of this book, you will possess statistical and linguistic knowledge
    to process text by using a great tool – the spaCy library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理这样一个复杂结构呢？我们也有我们的武器；我们用统计模型来模拟自然语言，并处理语言特征，将文本转换为良好的结构化表示。这本书为你提供了所有必要的背景和工具，让你能够从文本中提取意义。到这本书的结尾，你将拥有使用一个伟大的工具——spaCy
    库来处理文本的统计和语言知识。
- en: Though NLP gained popularity recently, processing human language has been present
    in our lives via many real-world applications, including search engines, translation
    services, and recommendation engines.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自然语言处理最近才流行起来，但通过许多现实世界的应用，包括搜索引擎、翻译服务和推荐引擎，处理人类语言已经存在于我们的生活中。
- en: Search engines such as Google Search, Yahoo Search, and Microsoft Bing are an
    integral part of our daily lives. We look for homework help, cooking recipes,
    information about celebrities, the latest episodes of our favorite TV series;
    all sorts of information that we use in our daily lives. There is even a verb
    in English (also in many other languages), *to google*, meaning *to look up some
    information on the Google search engine*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎如 Google 搜索、Yahoo 搜索和 Microsoft Bing 是我们日常生活的重要组成部分。我们寻找家庭作业帮助、烹饪食谱、名人信息、我们最喜欢的电视剧的最新一集；我们日常生活中使用的各种信息。甚至在英语中（也在许多其他语言中）有一个动词
    *to google*，意思是 *在 Google 搜索引擎上查找一些信息*。
- en: Search engines use advanced NLP techniques including mapping queries into a
    semantic space, where similar queries are represented by similar vectors. A quick
    trick is called **autocomplete**, where query suggestions appear on the search
    bar when we type the first few letters. Autocomplete looks tricky but indeed the
    algorithm is a combination of a search tree walk and character-level distance
    calculation. A past query is represented by a sequence of its characters, where
    each character corresponds to a node in the search tree. The **arcs** between
    the characters are assigned weights according to the popularity of this past query.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎使用高级 NLP 技术，包括将查询映射到语义空间，其中相似的查询由相似的向量表示。一个快速技巧叫做 **自动完成**，当我们输入查询的前几个字母时，查询建议就会出现在搜索栏上。自动完成看起来很复杂，但的确算法是搜索树遍历和字符级距离计算的组合。一个过去的查询由其字符序列表示，其中每个字符对应于搜索树中的一个节点。字符之间的
    **弧** 根据过去查询的流行度分配权重。
- en: 'Then, when a new query comes, we compare the current query string to past queries
    by walking on the tree. A fundamental **Computer Science** (**CS**) data structure,
    the tree, is used to represent a list of queries, who would have thought that?
    *Figure 1.2* shows a walk on the character tree:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当一个新的查询到来时，我们会通过遍历树来比较当前查询字符串和过去的查询。一个基本的**计算机科学**（**CS**）数据结构，树，被用来表示查询列表，谁能想到呢？*图
    1.2* 展示了在字符树上的遍历：
- en: '![Figure 1.2 – An autocomplete example'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – 自动完成示例'
- en: '](img/B16570_01_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_02.jpg)'
- en: Figure 1.2 – An autocomplete example
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 自动完成示例
- en: 'This is a simplified explanation; the real algorithms blend several techniques
    usually. If you want to learn more about this subject, you can read the great
    articles about the data structures: [http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata](http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata)
    and [http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees](http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化的解释；真正的算法通常融合了多种技术。如果你想了解更多关于这个主题的信息，你可以阅读关于数据结构的优秀文章：[http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata](http://blog.notdot.net/2010/07/Damn-Cool-Algorithms-Levenshtein-Automata)
    和 [http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees](http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees)。
- en: 'Continuing with search engines, search engines also know how to transform unstructured
    data to structured and linked data. When we type `Diana Spencer` into the search
    bar, this is what comes up:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论搜索引擎，搜索引擎也知道如何将非结构化数据转换为结构化和关联数据。当我们输入 `Diana Spencer` 到搜索栏中，就会出现以下内容：
- en: '![Figure 1.3 – Search results for the query "Diana Spencer"'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 搜索查询 "Diana Spencer" 的结果'
- en: '](img/B16570_01_03.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_03.jpg)'
- en: Figure 1.3 – Search results for the query "Diana Spencer"
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 搜索查询 "Diana Spencer" 的结果
- en: How did the search engine link `Diana Spencer` to her well-known name *Princess
    Diana*? This is called **entity linking**. We link entities that mention the same
    real-world entity. Entity-linking algorithms concern representing semantic relations
    and knowledge in general. This area of NLP is called the **Semantic Web**. You
    can learn more about this at [https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/](https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/).
    I worked as a knowledge engineer at a search engine company at the beginning of
    my career and really enjoyed it. This is a fascinating subject in NLP.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎是如何将“黛安娜·斯宾塞”这个名字与她的著名名字*戴安娜公主*联系起来的？这被称为**实体链接**。我们链接提及相同真实世界实体的实体。实体链接算法关注表示语义关系和知识。这个NLP领域被称为**语义网**。你可以在[https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/](https://www.cambridgesemantics.com/blog/semantic-university/intro-semantic-web/)了解更多信息。我在职业生涯初期在一家搜索引擎公司担任知识工程师，并真正享受这份工作。这是NLP中的一个非常吸引人的主题。
- en: 'There is really no limit to what you can develop: search engine algorithms,
    chatbots, speech recognition applications, and user sentiment recognition applications.
    NLP problems are challenging yet fascinating. This book''s mission is to provide
    you a toolbox with all the necessary tools. The first step of NLP development
    is choosing the programming language we will use wisely. In the next section,
    we will explain why Python is the weapon of choice. Let''s move on to the next
    section to see the string bond of NLP and Python.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开发的内容实际上没有限制：搜索引擎算法、聊天机器人、语音识别应用和用户情感识别应用。NLP问题具有挑战性但非常吸引人。本书的使命是为你提供一个包含所有必要工具的工具箱。NLP开发的第一步是明智地选择我们将使用的编程语言。在下一节中，我们将解释为什么Python是首选武器。让我们继续到下一节，看看NLP和Python之间的字符串联系。
- en: NLP with Python
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python进行NLP
- en: 'As we remarked before, NLP is a subfield of AI that analyzes text, speech,
    and other forms of human-generated language data. As an industry professional,
    my first choice for manipulating text data is Python. In general, there are many
    benefits to using Python:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，自然语言处理（NLP）是人工智能的一个子领域，它分析文本、语音和其他形式的人类生成语言数据。作为一名行业专业人士，我处理文本数据的第一选择是Python。一般来说，使用Python有很多好处：
- en: It is easy to read and looks very similar to pseudocode.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于阅读，看起来非常类似于伪代码。
- en: It is easy to produce and test code with.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于编写和测试代码。
- en: It has a high level of abstraction.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有高度的抽象级别。
- en: 'Python is a great choice for developing NLP systems because of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以下原因，Python是开发NLP系统的绝佳选择：
- en: '**Simplicity**: Python is easy to learn. You can focus on NLP rather than the
    programming language details.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：Python易于学习。你可以专注于NLP而不是编程语言的细节。'
- en: '**Efficiency**: It allows for easier development of quick NLP application prototypes.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：它允许更容易地开发快速NLP应用原型。'
- en: '**Popularity**: Python is one of the most popular languages. It has huge community
    support, and installing new libraries with pip is effortless.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流行度**：Python是最受欢迎的语言之一。它拥有庞大的社区支持，使用pip安装新库非常容易。'
- en: '**AI ecosystem presence**: A significant number of open source NLP libraries
    are available in Python. Many **machine learning** (**ML**) libraries such as
    PyTorch, TensorFlow, and Apache Spark also provide Python APIs.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AI生态系统存在**：Python中有大量的开源NLP库。许多机器学习（ML）库，如PyTorch、TensorFlow和Apache Spark，也提供了Python
    API。'
- en: '`sentenc.split()`, which can be quite painful in other languages, such as C++,
    where you have to deal with stream objects for this task.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sentenc.split()`，在其他语言中可能相当痛苦，例如C++，你必须处理流对象来完成这个任务。'
- en: 'When we put all the preceding points together, the following image appears
    – Python intersects with string processing, the AI ecosystem, and ML libraries
    to provide us the best NLP development experience:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将所有前面的点结合起来时，以下图像就会出现——Python与字符串处理、AI生态系统和ML库相交，为我们提供最佳的NLP开发体验：
- en: '![Figure 1.4 – NLP with Python overview'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 使用Python的NLP概述'
- en: '](img/B16570_01_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_04.jpg)'
- en: Figure 1.4 – NLP with Python overview
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 使用Python的NLP概述
- en: We will use Python 3.5+ throughout this book. Users who do not already have
    Python installed can follow the instructions at [https://realpython.com/installing-python/](https://realpython.com/installing-python/).
    We recommend downloading and using the latest version of Python 3.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这本书中使用Python 3.5+。尚未安装Python的用户可以按照[https://realpython.com/installing-python/](https://realpython.com/installing-python/)上的说明进行操作。我们建议下载并使用Python
    3的最新版本。
- en: In Python 3.x, the default encoding is **Unicode**, which means that we can
    use Unicode text without worrying much about the encoding. We won't go into details
    of encodings here, but you can think of Unicode as an extended set of ASCII, including
    more characters such as German-alphabet umlauts and the accented characters of
    the French alphabet. This way we can process German, French, and many more languages
    other than English.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.x中，默认编码是**Unicode**，这意味着我们可以使用Unicode文本而无需过多担心编码。我们不会在这里详细介绍编码的细节，但你可以将Unicode视为ASCII的扩展集，包括更多字符，如德语字母的重音符号和法语字母的带音符号。这样我们就可以处理德语、法语以及许多其他非英语语言。
- en: Reviewing some useful string operations
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习一些有用的字符串操作
- en: 'In Python, the text is represented by `str` class. Strings are immutable sequences
    of characters. Creating a string object is easy – we enclose the text in quotation
    marks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，文本由`str`类表示。字符串是不可变的字符序列。创建字符串对象很简单——我们用引号包围文本：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now the `word` variable contains the string `Hello World`. As we mentioned,
    strings are sequences of characters, so we can ask for the first item of the sequence:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`word`变量包含字符串`Hello World`。正如我们提到的，字符串是字符序列，因此我们可以请求序列的第一个元素：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Always remember to use parentheses with `print`, since we are coding in Python
    3.x. We can similarly access other indices, as long as the index doesn''t go out
    of bounds:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得在`print`中使用括号，因为我们正在使用Python 3.x进行编码。我们可以以类似的方式访问其他索引，只要索引没有超出范围：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'How about string length? We can use the `len` method, just like with `list`
    and other sequence types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串长度如何？我们可以使用`len`方法，就像使用`list`和其他序列类型一样：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also iterate over the characters of a string with sequence methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用序列方法遍历字符串的字符：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pro tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please mind the indentation throughout the book. Indentation in Python is the
    way we determine the control blocks and function definitions in general, and we
    will apply this convention in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意本书中的缩进。在Python中，缩进是我们确定控制块和函数定义的一般方式，我们将在本书中应用此约定。
- en: Now let's go over the more string methods such as counting characters, finding
    a substring, and changing letter case.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一些更复杂的字符串方法，比如计数字符、查找子字符串和更改字母大小写。
- en: '`count` counts the number of occurrences of a character in the string, so the
    output is `3` here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`方法计算字符串中字符的出现次数，所以这里的输出是`3`：'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Often, you need to find the index of a character for a number of substring
    operations such as cutting and slicing the string:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要找到字符的索引以进行一系列的子字符串操作，如切割和切片字符串：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, we can search for substrings in a string with the `find` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`find`方法在字符串中搜索子字符串：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`find` returns `–1` if the substring is not in the string:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子字符串不在字符串中，`find`返回`-1`：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Searching for the last occurrence of a substring is also easy:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查找子字符串的最后出现也很简单：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can change letter case by the `upper` and `lower` methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`upper`和`lower`方法更改字母的大小写：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `upper` method changes all characters to uppercase. Similarly, the `lower`
    method changes all characters to lowercase:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper`方法将所有字符转换为大写。同样，`lower`方法将所有字符转换为小写：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `capitalize` method capitalizes the first character of the string:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`方法将字符串的第一个字符大写：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `title` method makes the string title case. Title case literally means
    *to make a title*, so each word of the string is capitalized:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`方法将字符串转换为标题大小写。标题大小写字面意思是*制作标题*，因此字符串中的每个单词都被大写：'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Forming new strings from other strings can be done in several ways. We can
    concatenate two strings by adding them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他字符串形成新字符串可以通过几种方式完成。我们可以通过相加来连接两个字符串：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also multiply a string with an integer. The output will be the string
    concatenated to itself by the number of times specified by the integer:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将字符串与一个整数相乘。输出将是字符串根据整数指定的次数进行拼接：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`join` is a frequently used method; it takes a list of strings and joins them
    into one string:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`是一个常用的方法；它接受一个字符串列表并将它们连接成一个字符串：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is a variety of substring methods. Replacing a substring means changing
    all of its occurrences with another string:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多子字符串方法。替换子字符串意味着将所有出现都替换为另一个字符串：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Getting a substring by index is called **slicing**. You can slice a string
    by specifying the start index and end index. If we want only the second word,
    we can do the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引获取子字符串被称为**切片**。您可以通过指定起始索引和结束索引来切片字符串。如果我们只想获取第二个单词，我们可以这样做：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Getting the first word is similar. Leaving the first index blank means the
    index starts from zero:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第一个单词类似。留空第一个索引意味着索引从零开始：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Leaving the second index blank has a special meaning as well – it means the
    rest of the string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 留空第二个索引也有特殊含义——它表示字符串的其余部分：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now know some of the Pythonic NLP operations. Now we can dive into more of
    spaCy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了一些 Pythonic NLP 操作。现在我们可以更深入地了解 spaCy。
- en: Getting a high-level overview of the spaCy library
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 spaCy 库的高级概述
- en: spaCy is an open source Python library for modern NLP. The creators of spaCy
    describe their work as **industrial-strength NLP**, and as a contributor I can
    assure you it is true. spaCy is shipped with pretrained language models and word
    vectors for 60+ languages.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy 是一个开源的 Python NLP 库，其创造者将其描述为 **工业级 NLP**，作为贡献者，我可以保证这是真的。spaCy 随带预训练的语言模型和
    60 多种语言的词向量。
- en: 'spaCy is focused on production and shipping code, unlike its more academic
    predecessors. The most famous and frequently used Python predecessor is **NLTK**.
    NLTK''s main focus was providing students and researchers an idea of language
    processing. It never put any claims on efficiency, model accuracy, or being an
    industrial-strength library. spaCy focused on providing production-ready code
    from the first day. You can expect models to perform on real-world data, the code
    to be efficient, and the ability to process a huge amount of text data in a reasonable
    time. The following table is an efficiency comparison from the spaCy documentation
    (https://spacy.io/usage/facts-figures#speed-comparison):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy 专注于生产和发布代码，与其更学术的前辈不同。最著名且最常用的 Python 前辈是 **NLTK**。NLTK 的主要重点是向学生和研究人员提供一个语言处理的概念。它从未对效率、模型精度或成为工业级库提出任何要求。spaCy
    从第一天起就专注于提供生产就绪的代码。您可以期望模型在真实世界数据上表现良好，代码效率高，能够在合理的时间内处理大量文本数据。以下是从 spaCy 文档（https://spacy.io/usage/facts-figures#speed-comparison）中的效率比较：
- en: '![Figure 1.5 – A speed comparison of spaCy and other popular NLP frameworks'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – spaCy 与其他流行 NLP 框架的速度比较'
- en: '](img/B16570_01_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_05.jpg)'
- en: Figure 1.5 – A speed comparison of spaCy and other popular NLP frameworks
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – spaCy 与其他流行 NLP 框架的速度比较
- en: The spaCy code is also maintained in a professional way, with issues sorted
    by labels and new releases covering as many fixes as possible. You can always
    raise an issue on the spaCy GitHub repo at https://github.com/explosion/spaCy,
    report a bug, or ask for help from the community.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy 的代码也是以专业的方式进行维护的，问题按标签分类，新版本尽可能覆盖所有修复。您始终可以在 spaCy GitHub 仓库 https://github.com/explosion/spaCy
    上提出问题，报告错误，或向社区寻求帮助。
- en: 'Another predecessor is **CoreNLP** (also known as **StanfordNLP**). CoreNLP
    is implemented in Java. Though CoreNLP competes in terms of efficiency, Python
    won by easy prototyping and spaCy is much more professional as a software package.
    The code is well maintained, issues are tracked on GitHub, and every issue is
    marked with some labels (such as bug, feature, new project). Also, the installation
    of the library code and the models is easy. Together with providing backward compatibility,
    this makes spaCy a professional software project. Here is a detailed comparison
    from the spaCy documentation at https://spacy.io/usage/facts-figures#comparison:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个前辈是 **CoreNLP**（也称为 **StanfordNLP**）。CoreNLP 是用 Java 实现的。尽管 CoreNLP 在效率方面有所竞争，但
    Python 通过简单的原型设计和 spaCy 作为软件包的更专业性而获胜。代码得到了良好的维护，问题在 GitHub 上跟踪，每个问题都标记了一些标签（如错误、功能、新项目）。此外，库代码和模型的安装也很简单。与提供向后兼容性一起，这使得
    spaCy 成为一个专业的软件项目。以下是 spaCy 文档中的详细比较 https://spacy.io/usage/facts-figures#comparison：
- en: '![Figure 1.6 – A feature comparison of spaCy, NLTK, and CoreNLP'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – spaCy、NLTK 和 CoreNLP 的功能比较'
- en: '](img/B16570_01_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_06.jpg)'
- en: Figure 1.6 – A feature comparison of spaCy, NLTK, and CoreNLP
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – spaCy、NLTK 和 CoreNLP 的功能比较
- en: 'Throughout this book, we will be using spaCy''s latest releases, *v2.3* and
    *v3.0* (the versions used at the time of writing this book) for all our computational
    linguistics and ML purposes. The following are the features in the latest release:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 spaCy 的最新版本 *v2.3* 和 *v3.0*（本书编写时使用的版本）来处理所有计算语言学和机器学习目的。以下是最新版本中的功能：
- en: Original data preserving tokenization.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留原始数据的分词。
- en: Statistical sentence segmentation.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计句分割。
- en: Named entity recognition.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名实体识别。
- en: '**Part-of-Speech** (**POS**) tagging.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**词性标注**（**POS**）。'
- en: Dependency parsing.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依存句法分析。
- en: Pretrained word vectors.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预训练词向量。
- en: Easy integration with popular deep learning libraries. spaCy's ML library `Thinc`
    provides thin wrappers around PyTorch, TensorFlow, and MXNet. spaCy also provides
    wrappers for `HuggingFace` Transformers by `spacy-transformers` library. We'll
    see more of the `Transformers` in [*Chapter 9*](B16570_09_Final_JM_ePub.xhtml#_idTextAnchor158)*,
    spaCy and Transformers*.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流行的深度学习库轻松集成。spaCy 的 ML 库 `Thinc` 提供了 PyTorch、TensorFlow 和 MXNet 的薄包装器。spaCy
    还通过 `spacy-transformers` 库提供了 `HuggingFace` Transformers 的包装器。我们将在 [*第 9 章*](B16570_09_Final_JM_ePub.xhtml#_idTextAnchor158)*，spaCy
    和 Transformers* 中看到更多关于 `Transformers` 的内容。
- en: Industrial-level speed.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工业级速度。
- en: A built-in visualizer, displaCy.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的可视化工具，displaCy。
- en: Support for 60+ languages.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 60 多种语言。
- en: 46 state-of-the-art statistical models for 16 languages.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16 种语言的 46 个最先进的统计模型。
- en: Space-efficient string data structures.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间高效的字符串数据结构。
- en: Efficient serialization.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的序列化。
- en: Easy model packaging and usage.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的模型打包和使用。
- en: Large community support.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型社区支持。
- en: We had a quick glance around spaCy as an NLP library and as a software package.
    We will see what spaCy offers in detail throughout the book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速浏览了 spaCy 作为 NLP 库和软件包。我们将在本书中详细探讨 spaCy 提供的内容。
- en: Tips for the reader
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读者小贴士
- en: 'This book is a practical guide. In order to get the most out of the book, I
    recommend readers replicate the code in their own Python shell. Without following
    and performing the code, it is not possible to get a proper understanding of NLP
    concepts and spaCy methods, which is why we have arranged the upcoming chapters
    in the following way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是一本实用指南。为了最大限度地利用这本书，我建议读者在自己的 Python shell 中复现代码。如果不遵循并执行代码，就无法正确理解 NLP
    概念和 spaCy 方法，这就是为什么我们将接下来的章节安排如下：
- en: Explanation of the language/ML concept
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言/ML 概念解释
- en: Application code with spaCy
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 spaCy 的应用程序代码
- en: Evaluation of the outcome
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果评估
- en: Challenges of the methodology
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法论的挑战
- en: Pro tips and tricks to overcome the challenges
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克服挑战的专业技巧和窍门
- en: Installing spaCy
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 spaCy
- en: Let's get started by installing and setting up spaCy. spaCy is compatible with
    64-bit Python 2.7 and 3.5+, and can run on Unix/Linux, macOS/OS X, and Windows.
    `pip` (https://pypi.org/) and `conda` (https://conda.io/en/latest/). `pip` and
    `conda` are two of the most popular distribution packages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装和设置 spaCy 开始。spaCy 与 64 位 Python 2.7 和 3.5+ 兼容，可以在 Unix/Linux、macOS/OS
    X 和 Windows 上运行。`pip` (https://pypi.org/) 和 `conda` (https://conda.io/en/latest/)。`pip`
    和 `conda` 是最受欢迎的发行包之一。
- en: '`pip` is the most painless choice as it installs all the dependencies, so let''s
    start with it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip` 是最省心的选择，因为它会安装所有依赖项，所以让我们从这里开始。'
- en: Installing spaCy with pip
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip 安装 spaCy
- en: 'You can install spaCy with the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令安装 spaCy：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have more than one Python version installed in your system (such as
    Python 2.8, Python 3.5, Python 3.8, and so on), then select the `pip` associated
    with Python you want to use. For instance, if you want to use spaCy with Python
    3.5, you can do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的系统上安装了多个 Python 版本（例如 Python 2.8、Python 3.5、Python 3.8 等），那么请选择你想要使用的
    Python 版本的 `pip`。例如，如果你想使用 Python 3.5 的 spaCy，你可以这样做：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you already have spaCy installed on your system, you may want to upgrade
    to the latest version of spaCy. We''re using *spaCy 2.3* in this book; you can
    check which version you have with the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的系统上安装了 spaCy，你可能想升级到 spaCy 的最新版本。本书中使用的是 *spaCy 2.3*；你可以使用以下命令检查你拥有哪个版本：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is how a version info output looks like. This has been generated with
    the help of my Ubuntu machine:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是版本信息输出的样子。这是在我的 Ubuntu 机器的帮助下生成的：
- en: '![Figure 1.7 – An example spaCy version output'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – spaCy 版本输出示例'
- en: '](img/B16570_01_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – spaCy 版本输出示例'
- en: Figure 1.7 – An example spaCy version output
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – spaCy 版本输出示例
- en: 'Suppose you want to upgrade your spaCy version. You can upgrade your spaCy
    version to the latest available version with the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想升级你的 spaCy 版本。你可以使用以下命令将 spaCy 版本升级到最新可用版本：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Installing spaCy with conda
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 conda 安装 spaCy
- en: '`conda` support is provided by the conda community. The command for installing
    spaCy with `conda` is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`conda` 支持由 conda 社区提供。使用 `conda` 安装 spaCy 的命令如下：'
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Installing spaCy on macOS/OS X
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 macOS/OS X 上安装 spaCy
- en: 'macOS and OS X already ship with Python. You only need to install a recent
    version of the Xcode IDE. After installing Xcode, please run the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 和 OS X 已经预装了 Python。你只需要安装一个较新的 Xcode IDE 版本。安装 Xcode 后，请运行以下命令：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This installs the command-line development tools. Then you will be able to follow
    the preceding `pip` commands.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装命令行开发工具。然后您将能够遵循前面的 `pip` 命令。
- en: Installing spaCy on Windows
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 spaCy
- en: 'If you have a Windows system, you need to install a version of Visual C++ Build
    Tools or Visual Studio Express that matches your Python distribution. Here are
    the official distributions and their matching versions, taken from the spaCy installation
    guide (https://spacy.io/usage#source-windows):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows 系统，您需要安装与您的 Python 发行版相匹配的 Visual C++ Build Tools 或 Visual Studio
    Express 版本。以下是从 spaCy 安装指南（https://spacy.io/usage#source-windows）中摘录的官方发行版及其匹配版本：
- en: '![Figure 1.8 – Visual Studio and Python distribution compatibility table'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – Visual Studio 和 Python 发行版兼容性表'
- en: '](img/B16570_01_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_08.jpg)'
- en: Figure 1.8 – Visual Studio and Python distribution compatibility table
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – Visual Studio 和 Python 发行版兼容性表
- en: 'If you didn''t encounter any problems so far, then that means spaCy is installed
    and running on your system. You should be able to import spaCy into your Python
    shell:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您到目前为止没有遇到任何问题，那么这意味着 spaCy 已安装并正在您的系统上运行。您应该能够将 spaCy 导入到您的 Python 命令行中：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now you successfully installed spaCy – congrats and welcome to the spaCy universe!
    If you have installation problems please continue to the next section, otherwise
    you can move on to language model installation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已成功安装 spaCy – 祝贺您并欢迎加入 spaCy 的大千世界！如果您遇到安装问题，请继续阅读下一节，否则您可以继续进行语言模型安装。
- en: Troubleshooting while installing spaCy
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 spaCy 时的问题排除
- en: There might be cases where you get issues popping up during the installation
    process. The good news is, we're using a very popular library so most probably
    other developers have already encountered the same issues. Most of the issues
    are listed on *Stack Overflow* ([https://stackoverflow.com/questions/tagged/spacy](https://stackoverflow.com/questions/tagged/spacy))
    and the *spaCy GitHub* Issues section ([https://github.com/explosion/spaCy/issues](https://github.com/explosion/spaCy/issues))
    already. However, in this section, we'll go over the most common issues and their
    solutions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中可能会出现一些问题。好消息是，我们使用的是一个非常流行的库，所以很可能其他开发者已经遇到了相同的问题。大多数问题已在 *Stack Overflow*
    ([https://stackoverflow.com/questions/tagged/spacy](https://stackoverflow.com/questions/tagged/spacy))
    和 *spaCy GitHub 问题部分* ([https://github.com/explosion/spaCy/issues](https://github.com/explosion/spaCy/issues))
    中列出。然而，在本节中，我们将讨论最常见的问题及其解决方案。
- en: 'Some of the most common issues are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的一些问题如下：
- en: '**The Python distribution is incompatible**: In this case please upgrade your
    Python version accordingly and then do a fresh installation.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python 发行版不兼容**：在这种情况下，请相应地升级您的 Python 版本，然后进行全新安装。'
- en: '**The upgrade broke spaCy**: Most probably there are some leftover packages
    in your installation directories. The best solution is to first remove the spaCy
    package completely by doing the following:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级破坏了 spaCy**：很可能是您的安装目录中遗留了一些包。最好的解决方案是首先通过以下步骤完全删除 spaCy 包：'
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then do a fresh installation by following the installation instructions mentioned.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后按照提到的安装说明进行全新安装。
- en: '**You''re unable to install spaCy on a Mac**: On a Mac, please make sure that
    you don''t skip the following to make sure you correctly installed the Mac command-line
    tools and enabled pip:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您无法在 Mac 上安装 spaCy**：在 Mac 上，请确保您没有跳过以下步骤，以确保您正确安装了 Mac 命令行工具并启用了 pip：'
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In general, if you have the correct Python dependencies, the installation process
    will go smoothly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果您有正确的 Python 依赖项，安装过程将顺利进行。
- en: We're all set up and ready for our first usage of spaCy, so let's go ahead and
    start using spaCy's language models.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置好并准备好使用 spaCy，让我们继续使用 spaCy 的语言模型。
- en: Installing spaCy's statistical models
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 spaCy 的统计模型
- en: The spaCy installation doesn't come with the statistical language models needed
    for the spaCy pipeline tasks. spaCy language models contain knowledge about a
    specific language collected from a set of resources. Language models let us perform
    a variety of NLP tasks, including **POS tagging** and **named-entity recognition**
    (**NER**).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: spaCy 的安装不包括 spaCy 管道任务所需的统计语言模型。spaCy 语言模型包含从一组资源收集的特定语言知识。语言模型使我们能够执行各种 NLP
    任务，包括**词性标注**和**命名实体识别**（NER）。
- en: 'Different languages have different models and are language specific. There
    are also different models available for the same language. We''ll see the differences
    between those models in detail in the *Pro tip* at the end of this section, but
    basically the training data is different. The underlying statistical algorithm
    is the same. Some of the currently supported languages are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言有不同的模型，并且是针对特定语言的。同一语言也有不同的模型可供选择。我们将在本节末尾的*小贴士*中详细说明这些模型之间的差异，但基本上训练数据是不同的。底层统计算法是相同的。目前支持的一些语言如下：
- en: '![Figure 1.9 – spaCy models overview'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 – spaCy模型概览'
- en: '](img/B16570_01_09.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_09.jpg)'
- en: Figure 1.9 – spaCy models overview
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – spaCy模型概览
- en: The number of supported languages grows rapidly. You can follow the list of
    supported languages on the **spaCy Models and Languages** page ([https://spacy.io/usage/models#languages](https://spacy.io/usage/models#languages)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的语言数量正在迅速增长。你可以在**spaCy模型和语言**页面([https://spacy.io/usage/models#languages](https://spacy.io/usage/models#languages))上查看支持的语言列表。
- en: 'Several pretrained models are available for different languages. For English,
    the following models are available for download: `en_core_web_sm`, `en_core_web_md`,
    and `en_core_web_lg`. These models use the following naming convention:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的语言提供了几个预训练模型。对于英语，以下模型可供下载：`en_core_web_sm`、`en_core_web_md`和`en_core_web_lg`。这些模型使用以下命名约定：
- en: '`en` for English, `de` for German, and so on.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`en`代表英语，`de`代表德语，等等。'
- en: '`core` means a general-purpose model for the vocabulary, syntax, entities,
    and vectors.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core`表示通用模型，用于词汇、语法、实体和向量。'
- en: '`web`(Wikipedia), `news` (news, media) `Twitter`, and so on.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`(维基百科), `news` (新闻，媒体) `Twitter`，等等。'
- en: '`lg` for large, `md` for medium, and `sm` for small.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lg`代表大型，`md`代表中等，`sm`代表小型。'
- en: 'Here is what a typical language model looks like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的语言模型的样子：
- en: '![Figure 1.10 – The small-sized spaCy English web model'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10 – 小型spaCy英语网络模型'
- en: '](img/B16570_01_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_10.jpg)'
- en: Figure 1.10 – The small-sized spaCy English web model
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 小型spaCy英语网络模型
- en: Large models can require a lot of disk space, for example `en_core_web_lg` takes
    up 746 MB, while `en_core_web_md` needs 48MB and `en_core_web_sm` takes only 11MB.
    Medium-sized models work well for many development purposes, so we'll use the
    English `md`model throughout the book.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大型模型可能需要大量的磁盘空间，例如`en_core_web_lg`占用746 MB，而`en_core_web_md`需要48MB，`en_core_web_sm`仅占用11MB。中等大小的模型适用于许多开发目的，因此本书中我们将使用英语`md`模型。
- en: Pro tip
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good practice to match model genre to your text type. We recommend picking
    the genre as close as possible to your text. For example, the vocabulary in the
    social media genre will be very different from that in the Wikipedia genre. You
    can pick the web genre if you have social media posts, newspaper articles, financial
    news – that is, more language from daily life. The Wikipedia genre is suitable
    for rather formal articles, long documents, and technical documents. In case you
    are not sure which genre is the most suitable, you can download several models
    and test some example sentences from your own corpus and see how each model performs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个好习惯，将模型类型与你的文本类型相匹配。我们建议尽可能选择与你的文本最接近的类型。例如，社交媒体类型的词汇将与维基百科类型的词汇非常不同。如果你有社交媒体帖子、报纸文章、财经新闻等，即更多来自日常生活的语言，你可以选择网络类型。维基百科类型适用于相当正式的文章、长文档和技术文档。如果你不确定哪种类型最适合，你可以下载几个模型，并测试一些来自你自己的语料库的示例句子，看看每个模型的表现如何。
- en: Now that we're well-informed about how to choose a model, let's download our
    first model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何选择模型，让我们下载我们的第一个模型。
- en: Installing language models
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装语言模型
- en: 'Since v1.7.0, spaCy offers a great benefit: installing the models as Python
    packages. You can install spaCy models just like any other Python module and make
    them a part of your Python application. They''re properly versioned, so they can
    go into your `requirements.txt` file as a dependency. You can install the models
    from a download URL or a local director manually, or via `pip`. You can put the
    model data anywhere on your local filesystem.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自从v1.7.0版本以来，spaCy提供了一项重大优势：将模型作为Python包安装。你可以像安装任何其他Python模块一样安装spaCy模型，并将它们作为你Python应用程序的一部分。它们有适当的版本控制，因此可以作为依赖项添加到你的`requirements.txt`文件中。你可以手动从下载URL或本地目录安装模型，或者通过`pip`安装。你可以在本地文件系统的任何位置放置模型数据。
- en: 'You can download a model via spaCy''s `download` command. `download` looks
    for the most compatible model for your spaCy version, and then downloads and installs
    it. This way you don''t need to bother about any potential mismatch between the
    model and your spaCy version. This is the easiest way to install a model:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 spaCy 的 `download` 命令下载模型。`download` 会寻找与您的 spaCy 版本最兼容的模型，然后下载并安装它。这样您就不必担心模型与您的
    spaCy 版本之间可能存在的任何不匹配。这是安装模型的最简单方法：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding command selects and downloads the most compatible version of
    this specific model for your local spaCy version. Another option is to do the
    following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令选择并下载与您本地 spaCy 版本最兼容的特定模型版本。另一种选择是执行以下操作：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These commands install the most compatible *default* model for each language
    and create a shortcut link. To download the exact model version, the following
    is what needs to be done (though you often don''t need it):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令为每种语言安装最兼容的 *默认* 模型并创建快捷链接。要下载确切的模型版本，需要执行以下操作（尽管您通常不需要这样做）：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `download` command deploys `pip` behind the scenes. When you make a download,
    `pip` installs the package and places it in your `site-packages` directory just
    as any other installed Python package.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`download` 命令在幕后部署 `pip`。当您进行下载时，`pip` 会安装该包并将其放置在您的 `site-packages` 目录中，就像其他任何已安装的
    Python 包一样。'
- en: After the download, we can load the packages via spaCy's `load ()` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，我们可以通过 spaCy 的 `load()` 方法加载这些包。
- en: 'This is what we did so far:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们迄今为止所做的一切：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, we can provide the full model name:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以提供完整的模型名称：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also download models via `pip`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过 `pip` 下载模型：
- en: First, we need the link to the model we want to download.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要下载我们想要下载的模型的链接。
- en: We navigate to the model releases (https://github.com/explosion/spacy-models/releases),
    find the model, and copy the archive file link.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导航到模型发布页面（https://github.com/explosion/spacy-models/releases），找到所需的模型，并复制存档文件的链接。
- en: Then, we do a `pip install` with the model link.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用模型链接进行 `pip install`。
- en: 'Here is an example command for downloading with a custom URL:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用自定义 URL 下载的示例命令：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can install a local file as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式安装本地文件：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This installs the model into your `site-packages` directory. Then we run `spacy.load()`
    to load the model via its package name, create a shortcut link to give it a custom
    name (usually a shorter name), or import it as a module.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将模型安装到您的 `site-packages` 目录中。然后我们运行 `spacy.load()` 通过其包名加载模型，创建一个快捷链接以给它一个自定义名称（通常是更短的名字），或者将其作为模块导入。
- en: 'Importing the language model as a module is also possible:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将语言模型作为模块导入也是可能的：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pro tip
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In professional software development, we usually download models as part of
    an automated pipeline. In this case, it's not feasible to use spaCy's `download`
    command; rather, we use `pip` with the model URL. You can add the model into your
    `requirements.txt` file as a package as well.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业的软件开发中，我们通常将模型下载作为自动化流程的一部分。在这种情况下，使用 spaCy 的 `download` 命令是不可行的；相反，我们使用带有模型
    URL 的 `pip`。您也可以将模型添加到 `requirements.txt` 文件中作为包。
- en: How you like to load your models is your choice and also depends on the project
    requirements you're working on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何加载模型由您自己的喜好决定，也取决于您正在工作的项目需求。
- en: At this point, we're ready to explore the spaCy world. Let's now learn about
    spaCy's powerful visualization tool, **displaCy**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好探索 spaCy 世界。现在，让我们了解 spaCy 强大的可视化工具 **displaCy**。
- en: Visualization with displaCy
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 displaCy 进行可视化
- en: '**Visualization** is an important tool that should be in every data scientist''s
    toolbox. Visualization is the easiest way to explain some concepts to your colleagues,
    your boss, and any technical or non-technical audience. Visualization of language
    data is specifically useful and allows you to identify patterns in your data at
    a glance.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**可视化** 是每个数据科学家工具箱中的重要工具。可视化是向您的同事、老板以及任何技术或非技术受众解释某些概念的最简单方法。语言数据可视化特别有用，并允许您一眼就识别出数据中的模式。'
- en: There are many Python libraries and plugins such as *Matplotlib*, *seaborn*,
    *TensorBoard*, and so on. Being an industrial library, spaCy comes with its own
    visualizer – `Doc` object. We'll start by exploring the easiest way – using displaCy's
    interactive demo.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 Python 库和插件，例如 *Matplotlib*、*seaborn*、*TensorBoard* 等。作为一个工业级库，spaCy 自带其可视化工具
    – `Doc` 对象。我们将从最简单的方法开始探索 – 使用 displaCy 的交互式演示。
- en: Getting started with displaCy
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 displaCy
- en: 'Go ahead and navigate to [https://explosion.ai/demos/displacy](https://explosion.ai/demos/displacy)
    to use the interactive demo. Enter your text in the **Text to parse** box and
    then click the search icon on the right to generate the visualization. The result
    might look like the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://explosion.ai/demos/displacy](https://explosion.ai/demos/displacy)使用交互式演示。在**要解析的文本**框中输入你的文本，然后点击右侧的搜索图标以生成可视化。结果可能看起来如下：
- en: '![Figure 1.11 – displaCy''s online demo'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 – displaCy的在线演示'
- en: '](img/B16570_01_11.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_11.jpg)'
- en: Figure 1.11 – displaCy's online demo
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – displaCy的在线演示
- en: The visualizer performs two syntactic parses, POS tagging, and a **dependency
    parse**, on the submitted text to visualize the sentence's syntactic structure.
    Don't worry about how POS tagging and dependency parsing work, as we'll explore
    them in the upcoming chapters. For now, just think of the result as a sentence
    structure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化工具对提交的文本执行两个句法解析、词性标注和**依存句法解析**，以可视化句子的句法结构。不用担心词性标注和依存句法解析是如何工作的，因为我们在接下来的章节中会探讨它们。现在，只需将结果视为句子结构。
- en: You'll notice two tick boxes, **Merge Punctuation** and **Merge Phrases**. Merging
    punctuation merges the punctuation tokens into the previous token and serves a
    more compact visualization (it works like a charm on long documents).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到两个复选框，“合并标点”和“合并短语”。合并标点将标点符号标记合并到前一个标记中，从而提供更紧凑的视觉呈现（在长文档上效果极佳）。
- en: 'The second option, `They were beautiful and healthy kids with strong appetites.`
    It contains two noun phrases, `beautiful and healthy kids` and `strong appetite`.
    If we merge them, the result is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择，“他们都是美丽健康的孩子们，有着强烈的食欲。”它包含两个名词短语，“美丽健康的孩子们”和“强烈的食欲”。如果我们合并它们，结果如下：
- en: '![Figure 1.12 – An example parse with noun phrases merged'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 – 合并名词短语后的一个示例解析'
- en: '](img/B16570_01_12.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_12.jpg)'
- en: Figure 1.12 – An example parse with noun phrases merged
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 合并名词短语后的一个示例解析
- en: 'Without merging, every adjective and noun are shown individually:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 未合并时，每个形容词和名词都单独显示：
- en: '![Figure 1.13 – A parse of the same sentence, unmerged'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – 同句子的一个未合并的解析'
- en: '](img/B16570_01_13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_13.jpg)'
- en: Figure 1.13 – A parse of the same sentence, unmerged
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 同句子的一个未合并的解析
- en: The second parse is a bit too cumbersome and difficult to read. If you work
    on a text with long sentences such as law articles or Wikipedia entries, we definitely
    recommend merging.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次解析有点过于繁琐且难以阅读。如果你处理的是长句子的文本，如法律文章或维基百科条目，我们强烈建议合并。
- en: You can choose a statistical model from the **Model** box on the right for the
    currently supported languages. This option allows you to play around with the
    language models without having to download and install them on your local machine.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从右侧的**模型**框中选择一个统计模型用于当前支持的语言。此选项允许你在不下载和安装到本地机器的情况下尝试不同的语言模型。
- en: Entity visualizer
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体可视化
- en: displaCy's entity visualizer highlights the named entities in your text. The
    online demo lives at [https://explosion.ai/demos/displacy-ent/](https://explosion.ai/demos/displacy-ent/).
    We didn't go through named entities yet, but you can think of them as proper nouns
    for important entities such as people's names, company names, dates, city and
    country names, and so on. Extracting entities will be covered in [*Chapter 3*](B16570_03_Final_JM_ePub.xhtml#_idTextAnchor055),
    *Linguistic Features*, and [*Chapter 4*](B16570_04_Final_JM_ePub.xhtml#_idTextAnchor069),
    *Rule-Based Matching*, in detail.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: displaCy的实体可视化工具突出显示文本中的命名实体。在线演示可在[https://explosion.ai/demos/displacy-ent/](https://explosion.ai/demos/displacy-ent/)找到。我们尚未介绍命名实体，但你可以将它们视为重要实体的专有名词，例如人名、公司名、日期、城市和国家名称等。提取实体将在[*第3章*](B16570_03_Final_JM_ePub.xhtml#_idTextAnchor055)“语言特征”和[*第4章*](B16570_04_Final_JM_ePub.xhtml#_idTextAnchor069)“基于规则的匹配”中详细讲解。
- en: 'The online demo works similar to the syntactic parser demo. Enter your text
    into the textbox and hit the search button. Here is an example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在线演示与句法解析演示类似。将文本输入到文本框中，然后点击搜索按钮。以下是一个示例：
- en: '![Figure 1.14 – An example entity visualization'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14 – 一个实体可视化的示例'
- en: '](img/B16570_01_14.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_14.jpg)'
- en: Figure 1.14 – An example entity visualization
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 一个实体可视化的示例
- en: The right side contains tick boxes for entity types. You can tick the boxes
    that match your text type such as, for instance, **MONEY** and **QUANTITY** for
    a financial text. Again, just like in the syntactic parser demo, you can choose
    from the available models.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧包含实体类型的复选框。您可以选择与您的文本类型匹配的复选框，例如，例如，对于金融文本，选择 **MONEY** 和 **QUANTITY**。同样，就像在句法解析演示中一样，您可以从可用的模型中选择。
- en: Visualizing within Python
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中可视化
- en: With the introduction of the latest version of spaCy, the displaCy visualizers
    are integrated into the core library. This means that you can start using displaCy
    immediately after installing spaCy on your machine! Let's go through some examples.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 随着spaCy最新版本的推出，displaCy 可视化器已集成到核心库中。这意味着您可以在机器上安装 spaCy 后立即开始使用 displaCy！让我们通过一些示例来了解。
- en: 'The following code segment is the easiest way to spin up displaCy on your local
    machine:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段是在本地机器上启动 displaCy 的最简单方法：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see from the preceding snippet, the following is what we did:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，以下是我们所做的工作：
- en: We import `spaCy`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入 `spaCy`。
- en: Following that, we import `displaCy` from the core library.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，我们从核心库中导入 `displaCy`。
- en: We load the English model that we downloaded in the *Installing spaCy's statistical
    models* section.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们加载了在 *安装 spaCy 的统计模型* 部分下载的英语模型。
- en: Once it is loaded, we create a `Doc` object to pass to `displaCy`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦加载完成，我们创建一个 `Doc` 对象传递给 `displaCy`。
- en: We then started the `displaCy` web server via calling `serve()`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `serve()` 来启动 `displaCy` 网络服务器。
- en: We also passed `dep` to the `style` parameter to see the dependency parsing
    result.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将 `dep` 传递给 `style` 参数，以查看依赖关系解析结果。
- en: 'After firing up this code, you should see a response from displaCy as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 启动此代码后，您应该看到 displaCy 的以下响应：
- en: '![Figure 1.15 – Firing up displaCy locally'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.15 – 在本地启动 displaCy'
- en: '](img/B16570_01_15.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_15.jpg)'
- en: Figure 1.15 – Firing up displaCy locally
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 在本地启动 displaCy
- en: 'The response is added along with a link, `http://0.0.0.0:5000`, this is the
    local address where displaCy renders your graphics. Please click the link and
    navigate to the web page. You should see the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中添加了一个链接，`http://0.0.0.0:5000`，这是 displaCy 渲染您图形的本地地址。请点击链接并导航到网页。您应该看到以下内容：
- en: '![Figure 1.16 – View the result visualization in your browser'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.16 – 在您的浏览器中查看结果可视化'
- en: '](img/B16570_01_16.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_16.jpg)'
- en: Figure 1.16 – View the result visualization in your browser
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 在您的浏览器中查看结果可视化
- en: 'This means that displaCy generated a dependency parse result visualization
    and rendered it on your localhost. After you''re finished with displaying the
    visual and you want to shut down the server, you can press *Ctrl* +*C* to shut
    down the displaCy server and go back to the Python shell:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 displaCy 生成了一个依赖关系解析结果的可视化，并在您的本地主机上渲染了它。在您完成显示可视化并想要关闭服务器后，您可以按 *Ctrl*
    +*C* 来关闭 displaCy 服务器并返回 Python 壳：
- en: '![Figure 1.17 – Shutting down the displaCy server'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17 – 关闭 displaCy 服务器'
- en: '](img/B16570_01_17.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_17.jpg)'
- en: Figure 1.17 – Shutting down the displaCy server
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 关闭 displaCy 服务器
- en: After shutting down, you won't be able to visualize more examples, but you'll
    continue seeing the results you already generated.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭后，您将无法可视化更多示例，但您将继续看到您已经生成的结果。
- en: 'If you wish to use another port or you get an error because the port `5000`
    is already in use, you can use the `port` parameter of displaCy with another port
    number. Replacing the last line of the preceding code block with the following
    line will suffice:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望使用另一个端口或由于端口 `5000` 已被占用而出现错误，您可以使用 displaCy 的 `port` 参数使用另一个端口号。将前一个代码块的最后一条行替换为以下行就足够了：
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we provide the port number `5001` explicitly. In this case, displaCy will
    render the graphics on `http://0.0.0.0:5001`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确提供了端口号 `5001`。在这种情况下，displaCy 将在 `http://0.0.0.0:5001` 上渲染图形。
- en: 'Generating an entity recognizer is done similarly. We pass `ent` to the `style`
    parameter instead of `dep`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 生成实体识别器的方式类似。我们将 `ent` 传递给 `style` 参数而不是 `dep`：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result should look like the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像以下这样：
- en: '![Figure 1.18 – The entity visualization is displayed on your browser'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.18 – 实体可视化显示在您的浏览器上'
- en: '](img/B16570_01_18.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16570_01_18.jpg)'
- en: Figure 1.18 – The entity visualization is displayed on your browser
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 实体可视化显示在您的浏览器上
- en: Let's move on to other platforms we can use for displaying the results.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨其他我们可以用于显示结果的平台。
- en: Using displaCy in Jupyter notebooks
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Jupyter 笔记本中使用 displaCy
- en: Jupyter notebook is an important part of daily data science work. Fortunately,
    displaCy can spot whether you're currently coding in a Jupyter notebook environment
    and returns markup that can be directly displayed in a cell.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter notebook 是日常数据科学工作的重要组成部分。幸运的是，displaCy 可以检测您是否正在 Jupyter notebook 环境中编码，并返回可以直接在单元格中显示的标记。
- en: If you don't have Jupyter notebook installed on your system but wish to use
    it, you can follow the instructions at [https://test-jupyter.readthedocs.io/en/latest/install.html](https://test-jupyter.readthedocs.io/en/latest/install.html).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您系统上没有安装 Jupyter notebook 但希望使用它，可以按照[https://test-jupyter.readthedocs.io/en/latest/install.html](https://test-jupyter.readthedocs.io/en/latest/install.html)中的说明进行操作。
- en: 'This time we''ll call `render()` instead of `serve()`. The rest of the code
    is the same. You can type/paste the following code into your Jupyter notebook:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将调用 `render()` 而不是 `serve()`。其余的代码保持不变。您可以将以下代码输入或粘贴到您的 Jupyter 笔记本中：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result should look like the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像下面这样：
- en: '![Figure 1.19 – displaCy rendering results in a Jupyter notebook'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19 – displaCy 在 Jupyter 笔记本中的渲染结果](img/B16570_01_19.jpg)'
- en: '](img/B16570_01_19.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16570_01_19.jpg](img/B16570_01_19.jpg)'
- en: Figure 1.19 – displaCy rendering results in a Jupyter notebook
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – displaCy 在 Jupyter 笔记本中的渲染结果
- en: Exporting displaCy graphics as an image file
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 displaCy 图形导出为图像文件
- en: 'Often, we need to export the graphics that we generated with displaCy as image
    files to place them into presentations, articles, or papers. We can call displaCy
    in this case as well:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要将使用 displaCy 生成的图形导出为图像文件，以便将其放入演示文稿、文章或论文中。在这种情况下，我们也可以调用 displaCy：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We import `spaCy` and `displaCy`. We load the English language model, then create
    a `Doc` object as usual. Then we call `displacy.render()` and capture the output
    to the `svg` variable. The rest is writing the `svg` variable to a file called
    `butterfly.svg`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `spaCy` 和 `displaCy`。然后加载英语语言模型，然后像往常一样创建一个 `Doc` 对象。然后我们调用 `displacy.render()`
    并将输出捕获到 `svg` 变量中。其余的就是将 `svg` 变量写入名为 `butterfly.svg` 的文件中。
- en: We have reached the end of the visualization chapter here. We created good-looking
    visuals and learned the details of creating visuals with displaCy. If you wish
    to find out how to use different background images, background colors, and fonts,
    you can visit the displaCy documentation at [http://spacy.io/usage/visualizers](http://spacy.io/usage/visualizers).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了可视化章节的结尾。我们创建了美观的视觉效果，并学习了使用 displaCy 创建视觉效果的所有细节。如果您想了解如何使用不同的背景图像、背景颜色和字体，您可以访问
    displaCy 文档[http://spacy.io/usage/visualizers](http://spacy.io/usage/visualizers)。
- en: Often, we need to create visuals with different colors and styling, and the
    displaCy documentation contains detailed information about styling. The documentation
    also includes how to embed displaCy into your web applications. spaCy is well
    documented as a project and the documentation contains everything we need!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要创建具有不同颜色和样式的视觉效果，而 displaCy 文档中包含了关于样式的详细信息。文档还包括如何将 displaCy 集成到您的 Web
    应用程序中。spaCy 作为项目有很好的文档记录，文档中包含了我们所需的所有内容！
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter gave you an introduction to NLP with Python and spaCy. You now
    have a brief idea about why to use Python for language processing and the reasons
    to prefer spaCy for creating your NLP applications. We also got started on our
    spaCy journey by installing spaCy and downloading language models. This chapter
    also introduced us to the visualization tool – displaCy.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您介绍了使用 Python 和 spaCy 的 NLP。您现在对为什么使用 Python 进行语言处理以及为什么选择 spaCy 创建您的 NLP
    应用程序的原因有了简要的了解。我们还通过安装 spaCy 和下载语言模型开始了我们的 spaCy 之旅。本章还介绍了可视化工具 – displaCy。
- en: In the next chapter, we will continue our exciting spaCy journey with spaCy
    core operations such as tokenization and lemmatization. It'll be our first encounter
    with spaCy features in detail. Let's go ahead and explore more together!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的激动人心的 spaCy 之旅，探讨 spaCy 核心操作，如分词和词形还原。这将是我们第一次详细接触 spaCy 的功能。让我们继续探索，一起了解更多吧！
