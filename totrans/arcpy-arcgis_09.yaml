- en: Chapter 9. More ArcPy.Mapping Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability to control map document cartography, while also running geospatial
    analyses, increases the power and usefulness of ArcPy. The properties and methods
    of `arcpy.mapping` can be utilized to manipulate layer objects, map scales and
    data frame extents, or even to set definition queries. By combining automated
    geospatial analysis with dynamic map production, scripted mapping systems are
    made possible. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Arcpy.mapping Layer objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layer object definition queries and extents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arcpy.mapping Data Frame objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamically scaled maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using arcpy.mapping to control Layer objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Arcpy.mapping` Layer objects are used to control the properties of layers
    within map document data frames. Turning layer visibility on and off, adding new
    layers, and adjusting layer order can all be accomplished using Layer object properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating Layer objects involves passing parameters to the `arcpy.mapping.ListLayers()`
    method. As discussed in [Chapter 8](ch08.html "Chapter 8. Introduction to ArcPy.Mapping"),
    *Introduction to ArcPy.Mapping*, when referencing an `arcpy.mapping.MapDocument`
    object, the layers within the map document can be accessed using zero-based indexing.
    This code will print the list of Layer objects contained within the data frame
    called Layers in an MXD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The layers within the data frame called **Layers**, have been assigned to the
    variable `layersList` using the `ListLayers()` method. Each layer in `layersList`
    can be accessed using zero-based indexing. Once the layers have been accessed
    within the list and either assigned to a variable or placed inside a `for` loop,
    the properties and methods of the Layer objects can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second parameter of the `ListLayers` method is empty here, but does not
    have to be. It is a wild card parameter that will limit the returned Layer objects
    to those that match the pattern of the wild card. For instance, ***Stops** would
    return all layers with the name **Stops** at the end. Multiple asterisks can be
    used to find layers with the word at the beginning, middle, or end of the layer
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Layer object methods and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layer object properties and methods can either be read only, meaning they can
    be checked but not adjusted, or they are read and write, meaning they can be adjusted
    within the script. Let's explore a number of these properties and methods, and
    see how they can be used to control the look and feel of the maps produced from
    the map document, as well as the data from the script analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Definition queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important property of Layer objects is the ability to dynamically set definition
    queries. A definition query is a SQL statement `where` clause that limits the
    data available for display, query, or other data operations (buffers, intersections,
    etc.) to only the rows that match the `where` clause. Definition queries could
    be set in an MXD by opening a layer''s properties menu and using the Definition
    Query tab, but here we are concerned with how to add them programmatically. Following
    is an example of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This valuable property can be utilized to reformat the code from [Chapter 8](ch08.html
    "Chapter 8. Introduction to ArcPy.Mapping"), *Introduction to ArcPy.Mapping*.
    Remember the complicated second portion of the `Chapter8_6.py` script, where each
    bus stop along the `71 Inbound` line is selected and its geometry is written to
    another feature class? Instead, we can use Layer objects and definition queries
    to perform the same type of geometry operation. Let''s examine how the first part
    of that operation (selecting the bus stop geometry and creating a buffer around
    it) looks when a definition query is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the definition query is used to limit the potential results
    from the `SearchCursor` to the bus stop specified by the query. However, this
    is overly cumbersome and the definition query doesn't add much, as first another
    `SearchCursor` is needed to extract the `ObjectID` information from the `busStops`
    layer. This complicates the code when only one `SearchCursor` is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Definition queries should be used to select the blocks that intersect with the
    buffer, as this will eliminate the need to use the complicated Search Cursor and
    Insert Cursor setup that was employed in [Chapter 8](ch08.html "Chapter 8. Introduction
    to ArcPy.Mapping"), *Introduction to ArcPy.Mapping*. Let's reformulate the code
    so that definition queries are properly used on the census block Layer object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add some code that will generate the SQL statement that
    will be used as the definition query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this section, the code assigns the census blocks layer in the MXD to the
    variable `censusBlocks`. The bus stops `SearchCursor` is then created, and the
    400 foot buffer is generated for each row to select the census blocks surrounding
    the bus stop. Once the correct blocks have been selected, a second `SearchCursor`
    is used on the `censusBlocks` Layer object to find the `ObjectID` (using the `OID@`
    token) of the selected blocks. The `ObjectIDs` are then appended to the list called
    `blockList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list is then iterated in a `for` loop to generate a string SQL statement.
    Using the initial string assigned to the variable `newQuery`, the `for` loop will
    add the `ObjectIDs` of each select block to the string to create a valid SQL statement.
    The `for` loop uses the function enumerate to count the number of loops that the
    `for` loop performs; this allows for an `if/then` statement to be used. The `if/then`
    statement determines what comes after the `ObjectID` in the string, as each `ObjectID`
    must be separated by a comma, except for the final `ObjectID`, which must be followed
    by the closing parenthesis. The `for` loop produces a SQL statement similar to
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `print` statement at the end is used to demonstrate the results of this
    section of the code, and also to give that warm fuzzy feeling that comes from
    seeing the results of the code working. Once we are sure that the code is generating
    valid SQL statements (closed parenthesis and comma separated `ObjectIDs`), the
    next step is to assign the definition query to the `censusBlocks` Layer object
    and use the result to generate a map of the area.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the data frame window extent and scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.html "Chapter 8. Introduction to ArcPy.Mapping"), *Introduction
    to ArcPy.Mapping* we started to explore the properties and methods of the data
    frame. Using the `arcpy.Extent` object, we were able to set the extent of the
    data frame to an extent that was hard-coded into the script. However, this does
    not always capture the entire extent of large census blocks. Using a combination
    of definition queries and the data frame extent and scale properties, we can avoid
    these unwanted results.
  prefs: []
  type: TYPE_NORMAL
- en: There are two data frame object methods used to shift the data frame window
    to the area of interest, in this case the selected census blocks. The first, which
    we are not using here, is `dataFrame.zoomToSelectedFeatures`. The second, is to
    assign the data frame's extent property to the extent of the census block layer
    after the definition query has been assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer the second method, as it will work even when there is no selected
    census blocks. Also, as the maps that are produced by this script should not show
    the selection of the blocks, we will have to add code to explicitly clear the
    selection once the correct census blocks have been identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The definition query has made it easy to move the data frame window to the area
    of interest, as the extent rectangle (or envelope) of the layer is now only around
    the specified blocks and the `dataFrame` extent property can be set to the extent
    rectangle. However, this is not always cartographically desirable as it seems
    better to move the data frame window back from the extent rectangle. To do that,
    we'll access the data frame the object's scale property.
  prefs: []
  type: TYPE_NORMAL
- en: The scale property can be set to be a multiplier of the current scale to avoid
    hard-coding any specific distances when adjusting the data frame extent. When
    using the scale property, it is important to remember to use the `arcpy.RefreshActiveView()`
    method, as it will refresh the data frame window to the new scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the data frame extent was set in the few lines before this, the current scale
    represents the envelope of the selected census blocks. To adjust it, assess the
    property and apply a multiplier. In this case, the multiplier is 1.1, but it could
    be any value. This makes the resulting map look better by giving the analysis
    results some background context.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Layer object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step before exporting out the maps is to add the 400 foot buffers created
    above as a layer to the data frame object. To accomplish this, we need to create
    a symbolized layer ahead of time and copy its symbology to ensure it looks as
    desired. This will be added to the **MXD** as a placeholder layer, and assigned
    to the `bufferLayer` variable in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Open up an **MXD** and add the **bus stop feature class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the **Buffer Tool** in the **Proximity** toolset in the **Analysis** toolset
    of the **ArcToolbox**, adding the **bus stop feature class** as the input and
    setting the buffer size to **400 feet**. After the tool has run, open the properties
    of the buffer layer and symbolize the layer as desired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the layer has been symbolized, right-click on the layer and select **Save**
    **As Layer File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the layer in a folder and close the **MXD**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the **MapDocument1.mxd** map document and add the layer using the **Add
    Data** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to change the name to **400 Foot Buffer** and to add it to the legend
    above the **Population** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the script, assign the buffer layer to the variable `bufferLayer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lower in the script, in the bus stop `SearchCursor`, add these lines below
    where the buffer is generated around the bus stop geometry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two lines copy the buffer generated to disk as a shapefile and then replace
    the data source of the `bufferLayer` Layer object with the newly created buffer.
    Note that the name of the shapefile does not include the `.shp` extension; the
    `SHAPEFILE_WORKSPACE` parameter makes this unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make sure that each new buffer shapefile can be written over an existing
    shapefile, add the following line below the `import arcpy` line to make sure that
    files can be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exporting the maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final step of this script is to export the maps of the area surrounding
    each bus stop. To do this, we will borrow some code from the script `Chapter8_6_AdjustMap.py`
    and add the whole script to a file called `Chapter9.py`. This code will identify
    and adjust the title and subtitle elements, making it possible to customize each
    resulting PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the use of layer definition queries, data frame
    extents and scales, and layer source replacement to ease the production of maps.
    By using definition queries, the layers can be modified to new extents, making
    it easier to zoom into the layer extent and to set the scale of the data frame.
    The definition queries also limit which members of a layer are displayed within
    the data frame. Layer source replacement was used as a cartographic control, allowing
    us to pre-generate the style of a layer and adjust the data that it represented
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will combine the lessons from the last three chapters,
    allowing us to create a script tool that will run analysis and produce spreadsheets
    and maps from the analysis results.
  prefs: []
  type: TYPE_NORMAL
