<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction to SciPy</h1></div></div></div><p>There is no doubt that the labor of scientists in the twenty-first century is more comprehensive and interdisciplinary than in previous generations. Members of scientific communities connect in larger teams and work together on mission-oriented goals and across their fields. This paradigm on research is also reflected in the computational resources employed by researchers. No longer are researchers restricted to one type of commercial software, operating system, or vendor, but inspired by open source contributions made available and tested by research institutions and open source communities; research work often spans over various platforms and technologies.</p><p>This book presents the highly-recognized open source programming environment till date — a system based on two libraries of the computer language Python: <strong>NumPy</strong> and <strong>SciPy</strong>. In the<a id="id0" class="indexterm"/> following sections, we will guide you through examples from science and engineering on the usage of this system.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>What is SciPy?</h1></div></div></div><p>The<a id="id1" class="indexterm"/> ideal programming environment for computational mathematics enjoys the<a id="id2" class="indexterm"/> following characteristics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must be based on a computer language that allows the user to work quickly and integrate systems effectively. Ideally, the computer language should be portable to all platforms: Windows, Mac OS X, Linux, Unix, Android, and so on. This is key to fostering cooperation among scientists with different resources and accessibilities. It must contain a powerful set of libraries that allow the acquisition, storing, and handling of large datasets in a simple and effective manner. This is central—allowing simulation and the employment of numerical computations at a large scale.</li><li class="listitem" style="list-style-type: disc">Smooth integration with other computer languages, as well as third-party software.</li><li class="listitem" style="list-style-type: disc">Besides running the compiled code, the programming environment should allow the possibility of interactive sessions as well as scripting capabilities for quick experimentation.</li><li class="listitem" style="list-style-type: disc">Different coding paradigms should be supported—imperative, object-oriented, and/or functional coding styles.</li><li class="listitem" style="list-style-type: disc">It<a id="id3" class="indexterm"/> should be an open source software, that allows user access to<a id="id4" class="indexterm"/> the raw data code, and allows the user to modify basic algorithms if so desired. With commercial software, the inclusion of the improved algorithms is applied at the discretion of the seller, and it usually comes at a cost of the end user. In the open source universe, the community usually performs these improvements and releases new versions as they are published—at no cost.</li><li class="listitem" style="list-style-type: disc">The set of applications should not be restricted to mere numerical computations; it should be powerful enough to allow symbolic computations as well.</li></ul></div><p>Among the best-known environments for numerical computations used by the scientific community<a id="id5" class="indexterm"/> is <strong>MATLAB</strong>, which is commercial, expensive, and which <a id="id6" class="indexterm"/>does not allow any tampering with the code. <strong>Maple</strong> and <strong>Mathematica</strong> are <a id="id7" class="indexterm"/>more geared towards symbolic computation, although they can match many of the numerical computations from MATLAB. These are, however, also commercial, expensive, and closed to modifications. A decent alternative to MATLAB and based on a similar mathematical engine is the <strong>GNU Octave system</strong>. Most of the MATLAB code is easily portable to Octave, which is open <a id="id8" class="indexterm"/>source. Unfortunately, the accompanying programming environment is not very user friendly, it is also very much restricted to numerical computations. One environment that combines the best of all worlds is Python with the open source libraries NumPy and SciPy for numerical operations. The first property that attracts users to Python is, without a doubt, its code readability. The syntax is extremely clear and expressive. It has the advantage of supporting code written in different paradigms: object oriented, functional, or old school imperative. It allows packing of Python codes and to run them as standalone executable programs through the <code class="literal">py2exe</code>, <code class="literal">pyinstaller</code>, and <code class="literal">cx_Freeze</code> libraries, but it can also be used interactively or as a <a id="id9" class="indexterm"/>scripting language. This is a great advantage when developing tools for symbolic computation. Python has therefore been a firm competitor to Maple and Mathematica: the open source mathematics software <strong>Sage</strong> (<strong>System for Algebra and Geometry Experimentation</strong>).</p><p>NumPy is an open source extension to Python that adds support for multidimensional arrays of large sizes. This support allows the desired acquisition, storage, and complex manipulation of data mentioned previously. NumPy alone is a great tool to solve many numerical computations.</p><p>On top of NumPy, we have yet another open source library, SciPy. This library contains algorithms and mathematical tools to manipulate NumPy objects with very definite scientific and engineering objectives.</p><p>The<a id="id10" class="indexterm"/> combination of Python, NumPy, and SciPy (which henceforth are coined as "SciPy" for brevity) has been the environment of choice of many applied mathematicians for years; we work on a daily basis with both pure mathematicians and with hardcore engineers. One of the challenges of this trade is to bring about the scientific production of professionals with different visions, techniques, tools, and software to a single workstation. SciPy is the perfect solution to coordinate computations in a smooth, reliable, and coherent manner.</p><p>Constantly, we are required to produce scripts with, for example, combinations of experiments written and performed in SciPy itself, C/C++, Fortran, and/or MATLAB. Often, we receive large amounts of data from some signal acquisition devices. From all this heterogeneous material, we employ Python to retrieve and manipulate the data, and once finished with the analysis, to produce high-quality documentation with professional-looking diagrams and visualization aids. SciPy allows performing all these tasks with ease.</p><p>This is <a id="id11" class="indexterm"/>partly because many dedicated software tools easily extend the <a id="id12" class="indexterm"/>core features of SciPy. For example, although graphing and plotting are usually taken care of with the Python<a id="id13" class="indexterm"/> libraries of <strong>matplotlib</strong>, there are also other packages available, such <a id="id14" class="indexterm"/>as <strong>Biggles</strong> (<a class="ulink" href="http://biggles.sourceforge.net/">http://biggles.sourceforge.net/</a>), <strong>Chaco</strong> (<a class="ulink" href="https://pypi.python.org/pypi/chaco">https://pypi.python.org/pypi/chaco</a>), <strong>HippoDraw</strong> (<a class="ulink" href="https://github.com/plasmodic/hippodraw">https://github.com/plasmodic/hippodraw</a>), <strong>MayaVi</strong> for <strong>3D</strong> rendering (<a class="ulink" href="http://mayavi.sourceforge.net/">http://mayavi.sourceforge.net/</a>), the <a id="id15" class="indexterm"/>
<strong>Python Imaging Library</strong> or <strong>PIL</strong> (<a class="ulink" href="http://pythonware.com/products/pil/">http://pythonware.com/products/pil/</a>), and <a id="id16" class="indexterm"/>the online analytics and data visualization<a id="id17" class="indexterm"/> tool <strong>Plotly</strong> (<a class="ulink" href="https://plot.ly/">https://plot.ly/</a>).</p><p>Interfacing with non-Python packages is also possible. For example, the interaction of SciPy with <a id="id18" class="indexterm"/>the R statistical package can be done with <strong>RPy</strong> (<a class="ulink" href="http://rpy.sourceforge.net/rpy2.html">http://rpy.sourceforge.net/rpy2.html</a>). This allows for much more robust data analysis.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Installing SciPy</h1></div></div></div><p>At the <a id="id19" class="indexterm"/>time of this book, the stable production releases of Python were 2.7.9 and 3.4.2. Still, Python 2.7 is more convenient if the user needs to communicate with third-party applications. No new releases are planned for Python 2; Python 3 is considered the present and the future of Python. For the purposes of SciPy applications, we do recommend you hold on to the 2.7 version, as there are still some packages using SciPy that have not been ported to Python 3 yet. Nevertheless, the companion software of this book was tested to work on both Python 2.7 and Python 3.4. </p><p>The Python software package can be downloaded from the official site (<a class="ulink" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>) and can be installed on all major systems such as<a id="id20" class="indexterm"/> Windows, Mac OS X, Linux, and Unix. It has also been ported to other platforms, including Palm OS, iOS, PlayStation, PSP, Psion, and so on. </p><p>The following screenshot shows two popular options for coding in Python on an iPad—<strong>PythonMath</strong> and <strong>Sage Math</strong>. While the first application allows only the use of simple math libraries, the second permits the user to load and use both NumPy and SciPy remotely.</p><div><img src="img/7702OS_01_01.jpg" alt="Installing SciPy"/></div><p>
<strong>PythonMath</strong> and <strong>Sage</strong> <strong>Math</strong> bring Python coding to iOS devices. <strong>Sage Math</strong> allows importing NumPy and SciPy.</p><p>We shall not go into detail about the installation of Python on your system, since we already assume familiarity with this language. In case of doubt, we advise browsing the excellent book <em>Expert Python Programming</em>, <em>Tarek Ziadé</em>, <em>Packt Publishing</em>, where detailed explanations are given for installing many of the different implementations on different systems. It is usually a good idea to follow the directions given on the official Python website. We will also assume familiarity with carrying out interactive sessions in Python, as well as writing standalone scripts.</p><p>The latest libraries for both NumPy and SciPy can be downloaded from the official SciPy site (<a class="ulink" href="http://scipy.org/">http://scipy.org/</a>). They both require a Python Version 2.4 or newer, so we should be in good shape <a id="id21" class="indexterm"/>at this point. We may choose to download the package from SourceForge (<a class="ulink" href="http://sourceforge.net/projects/scipy/">http://sourceforge.net/projects/scipy/</a>), <strong>Gohlke</strong> (<a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>) or <strong>Git</strong> repositories (for instance, the <strong>superpack</strong> <a id="id22" class="indexterm"/>from <a class="ulink" href="http://stronginference.com/ScipySuperpack/">http://stronginference.com/ScipySuperpack/</a>). </p><p>It is also<a id="id23" class="indexterm"/> possible in some systems to use prepackaged executable bundles that<a id="id24" class="indexterm"/> simplify the process, such as the <strong>Anaconda</strong> (<a class="ulink" href="https://store.continuum.io/cshop/anaconda/">https://store.continuum.io/cshop/anaconda/</a>) or the <strong>Enthought</strong> (<a class="ulink" href="https://www.enthought.com/products/epd/">https://www.enthought.com/products/epd/</a>) Python distributions. Here, we will show you <a id="id25" class="indexterm"/>how to download and install Scipy on various platforms in the most common cases.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Installing SciPy on Mac OS X</h2></div></div></div><p>While <a id="id26" class="indexterm"/>installing SciPy on Mac OS X, you must consider <a id="id27" class="indexterm"/>some criteria before you install it on your system. This helps in smooth installation of SciPy. The following are the things to be taken care of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For instance, in Mac OS X, if <code class="literal">MacPorts</code> is installed, the process could not be easier. Open a terminal as superuser, and at the prompt (<code class="literal">%</code>), issue the following command:<div><pre class="programlisting"><strong>% port search scipy</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc">This presents a list of all ports that either install SciPy or use SciPy as a requirement. For Python 2.7 we need to install <code class="literal">py27-scipy</code> issuing the following command:<div><pre class="programlisting"><strong>% port install py27-scipy</strong>
</pre></div></li></ul></div><p>A few minutes later, the libraries are properly installed and ready to use. Note how <code class="literal">macports</code> also installs all needed requirements for us (including the NumPy libraries) without any extra effort on our part. </p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Installing SciPy on Unix/Linux</h2></div></div></div><p>Under<a id="id28" class="indexterm"/> any other Unix/Linux system, if either no ports are <a id="id29" class="indexterm"/>available or if the user prefers to install from the packages downloaded from either SourceForge or Git, it is enough to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Unzip the NumPy and SciPy packages following the recommendation of the official pages. This creates two folders, one for each library.<p>Within a terminal session, change directories to the folder where the NumPy libraries are stored, which contains the <code class="literal">setup.py</code> file. Find out which Fortran compiler you are using (one of <code class="literal">gnu</code>, <code class="literal">gnu95</code>, or <code class="literal">fcompiler</code>), and at prompt, issue the following command:</p><div><pre class="programlisting"><strong>% python setup.py build –fcompiler=&lt;compiler&gt;</strong>
</pre></div></li><li class="listitem">Once<a id="id30" class="indexterm"/> built, and on the same folder, issue the <a id="id31" class="indexterm"/>installation command. This should be all:<div><pre class="programlisting"><strong>% python setup.py install</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Installing SciPy on Windows</h2></div></div></div><p>You<a id="id32" class="indexterm"/> can install Scipy on Windows in many ways. The <a id="id33" class="indexterm"/>following are some recommended ways that you might want to have a look on: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Under Microsoft Windows, we recommend you install from the binary installers provided by the Anaconda or Enthought Python Distributions. Please, however, be aware of the memory requirements. Alternatively, you can download and install the SciPy stack or the libraries, individually. </li><li class="listitem" style="list-style-type: disc">The procedure for the installation of the SciPy libraries is exactly the same, that is, downloading and building before installing under Unix/Linux or downloading and running under Microsoft Windows. Note that different implementations of Python might have different requirements before installing NumPy and SciPy.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Testing the SciPy installation</h2></div></div></div><p>As you <a id="id34" class="indexterm"/>might know, computer systems are not infallible. Accordingly, before starting computing via SciPy, one needs to be sure it is working correctly. To that end, SciPy developers have included a test suit any user of SciPy can execute to be sure the SciPy being used is working fine. That way, much debugging time can be saved whenever an error occurs while using any function provided by SciPy. </p><p>To run the test suite, at the Python prompt, one can run the following commands:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy</strong>
<strong>&gt;&gt;&gt; scipy.test()</strong>
</pre></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>The reader should be aware that the execution of this test will take some time to finish. It should end with something like this:</p><div><img src="img/7702OS_01_02.jpg" alt="Testing the SciPy installation"/></div><p>This <a id="id35" class="indexterm"/>means that at the basic level, your SciPy installation is fine. Eventually, the test could end in the form:</p><div><img src="img/7702OS_01_03.jpg" alt="Testing the SciPy installation"/></div><p>In this case, one needs to revise carefully the errors and the failed tests. A place to get help is the SciPy mailing list (<a class="ulink" href="http://mail.scipy.org/pipermail/scipy-user/">http://mail.scipy.org/pipermail/scipy-user/</a>) to which one could subscribe. We have included a Python script that the reader could use to run these<a id="id36" class="indexterm"/> tests that can be found at the companion software<a id="id37" class="indexterm"/> for this chapter that comes with the book. </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>SciPy organization</h1></div></div></div><p>SciPy is<a id="id38" class="indexterm"/> organized as a family of modules. We like to think of each module as a different field of mathematics. And as such, each has its own particular techniques and tools. You can find a list of some of the different modules included in SciPy at <a class="ulink" href="http://docs.scipy.org/doc/scipy-0.14.0/reference/py-modindex.html">http://docs.scipy.org/doc/scipy-0.14.0/reference/py-modindex.html</a>.</p><p>Let's use some of its functions to solve a simple problem.</p><p>The following table shows the IQ test scores of 31 individuals:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>114</p>
</td><td style="text-align: left" valign="top">
<p>100</p>
</td><td style="text-align: left" valign="top">
<p>104</p>
</td><td style="text-align: left" valign="top">
<p>89</p>
</td><td style="text-align: left" valign="top">
<p>102</p>
</td><td style="text-align: left" valign="top">
<p>91</p>
</td><td style="text-align: left" valign="top">
<p>114</p>
</td><td style="text-align: left" valign="top">
<p>114</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>103</p>
</td><td style="text-align: left" valign="top">
<p>105</p>
</td><td style="text-align: left" valign="top">
<p>108</p>
</td><td style="text-align: left" valign="top">
<p>130</p>
</td><td style="text-align: left" valign="top">
<p>120</p>
</td><td style="text-align: left" valign="top">
<p>132</p>
</td><td style="text-align: left" valign="top">
<p>111</p>
</td><td style="text-align: left" valign="top">
<p>128</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>118</p>
</td><td style="text-align: left" valign="top">
<p>119</p>
</td><td style="text-align: left" valign="top">
<p>86</p>
</td><td style="text-align: left" valign="top">
<p>72</p>
</td><td style="text-align: left" valign="top">
<p>111</p>
</td><td style="text-align: left" valign="top">
<p>103</p>
</td><td style="text-align: left" valign="top">
<p>74</p>
</td><td style="text-align: left" valign="top">
<p>112</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>107</p>
</td><td style="text-align: left" valign="top">
<p>103</p>
</td><td style="text-align: left" valign="top">
<p>98</p>
</td><td style="text-align: left" valign="top">
<p>96</p>
</td><td style="text-align: left" valign="top">
<p>112</p>
</td><td style="text-align: left" valign="top">
<p>112</p>
</td><td style="text-align: left" valign="top">
<p>93</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>A stem plot of the distribution of these 31 scores (refers to the IPython Notebook for this chapter) shows that there are no major departures from normality, and thus we assume the distribution of the scores to be close to normal. Now, estimate the mean IQ score for this population, using a 99 percent confidence interval.</p><p>We start by loading the data into memory, as follows:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import numpy</strong>
<strong>&gt;&gt;&gt; scores = numpy.array([114, 100, 104, 89, 102, 91, 114, 114, 103, 105, 108, 130, 120, 132, 111, 128, 118, 119, 86, 72, 111, 103, 74, 112, 107, 103, 98, 96, 112, 112, 93])</strong>
</pre></div><p>At this point, if we type <code class="literal">dir(scores)</code>, hit the <em>return</em> key followed by a dot (<code class="literal">.</code>), and press the <em>tab</em> key ;the system lists all possible methods inherited by the data from the NumPy library, as it is customary in Python. Technically, we could go ahead and compute the required <code class="literal">mean</code>, <code class="literal">xmean</code>, and corresponding confidence interval according to the formula, <em>xmean ± zcrit * sigma / sqrt(n)</em>, where <code class="literal">sigma</code> and <code class="literal">n</code> are respectively the standard deviation and size of the data, and <em>zcrit</em> is the critical value corresponding to the confidence (<a class="ulink" href="http://en.wikipedia.org/wiki/Confidence_interval">http://en.wikipedia.org/wiki/Confidence_interval</a>). In this case, we could look up a table on any statistics book to obtain a crude approximation to its value, <em>zcrit = 2.576</em>. The remaining values may be computed in our session and properly combined, as follows:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy</strong>
<strong>&gt;&gt;&gt; xmean = scipy.mean(scores)</strong>
<strong>&gt;&gt;&gt; sigma = scipy.std(scores)</strong>
<strong>&gt;&gt;&gt; n = scipy.size(scores)</strong>
<strong>&gt;&gt;&gt; xmean, xmean - 2.576*sigma /scipy.sqrt(n), \</strong>
<strong>    xmean + 2.576*sigma / scipy.sqrt(n)</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>(105.83870967741936, 99.343223715529746, 112.33419563930897)</strong>
</pre></div><p>We<a id="id39" class="indexterm"/> have thus computed the estimated mean IQ score (with value <code class="literal">105.83870967741936</code>) and the interval of confidence (from about <code class="literal">99.34</code> to approximately <code class="literal">112.33</code> ). We have done so using purely SciPy-based operations while following a known formula. But instead of making all these computations by hand and looking for critical values on tables, we could just ask SciPy. </p><p>Note how the <code class="literal">scipy.stats</code> module needs to be loaded before we use any of its functions:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from scipy import stats</strong>
<strong>&gt;&gt;&gt; result=scipy.stats.bayes_mvs(scores)</strong>
</pre></div><p>The variable <code class="literal">result</code> contains the solution to our problem with some additional information. Note that result is a tuple with three elements as the <code class="literal">help</code> documentation suggests:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; help(scipy.stats.bayes_mvs)</strong>
</pre></div><p>The output of this command will depend on the installed version of SciPy. It might look like this (run the companion IPython Notebook for this chapter to see how the actual output from your system is, or run the command in a Python console):</p><div><img src="img/7702OS_01_04.jpg" alt="SciPy organization"/></div><p>Our solution is the first element of the tuple <code class="literal">result</code>; to see its contents, type: </p><div><pre class="programlisting"><strong>&gt;&gt;&gt; result[0]</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong>(105.83870967741936, (101.48825534263035, 110.18916401220837))</strong>
</pre></div><p>Note<a id="id40" class="indexterm"/> how this output gives us the same average as before, but a slightly different confidence interval, due to more accurate computations through SciPy (the output might be different depending on the SciPy version available on your computer). </p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>How to find documentation</h1></div></div></div><p>There is a<a id="id41" class="indexterm"/> wealth of information online, either from the official pages of SciPy (although its reference guides are somehow incomplete, as a work in progress), or from many other contributors that present tutorials on forums, YouTube, or personal sites. Several developers also publish examples of their work with great detail online.</p><p>As we previously saw, it is also possible to obtain help from our interactive Python sessions. The libraries NumPy and SciPy make use of <strong>docstrings </strong>heavily, which makes it simple to request for help for usage and recommendations with the usual Python help system. For example, if in doubt of the usage of the <code class="literal">bayes_mvs</code> routine, the user can issue the following command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy.stats</strong>
<strong>&gt;&gt;&gt; help(scipy.stats.bayes_mvs)</strong>
</pre></div><p>After executing this command, the system provides the necessary information. Equivalently, both NumPy and SciPy come bundled with their own help system, <code class="literal">info</code>. For instance, look at the following command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import numpy</strong>
<strong>&gt;&gt;&gt; numpy.info('random')</strong>
</pre></div><p>This will offer a summary of all information parsed from the contents of all docstrings from the NumPy library associated with the given keyword (note it must be quoted). The user may navigate the output scrolling up and down, without the possibility of further interaction.</p><p>This is convenient provided we already do know the function we want to use if we are unsure of its usage. But, what should we do if we don't know about the existence of this procedure, and suspect that it may exist? The usual Python way is to invoke the <code class="literal">dir()</code> command on a module, which lists all possible attributes. </p><p>Interactive Python sessions make it easier to search for such information with the possibility of navigating and performing further searches inside the output of help sessions. For instance, type in the following command at prompt:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy.stats</strong>
<strong>&gt;&gt;&gt; help(scipy.stats)</strong>
</pre></div><p>The <a id="id42" class="indexterm"/>output of this command will depend on the installed version of SciPy. It might look like this (run the companion IPython Notebook for this chapter to see the actual output from your system, or run the command in a Python console):</p><div><img src="img/7702OS_01_05.jpg" alt="How to find documentation"/></div><p>Note the colon (<strong>:</strong>) at the end of the screen—this is an old-school prompt. The system is in stand-by mode, expecting the user to issue a command (in the form of a single key). This also indicates that there are a few more pages of help following the given text. If we intend to read the rest of the help file, we may press spacebar to scroll to the next page. </p><p>In this way, we can visit the following manual pages on this topic. It is also possible to navigate the manual pages scrolling one line of text at a time using the up and down arrow keys. When we are ready to quit the help session, we simply press (the keyboard letter) <em>Q</em>.</p><p>It is also<a id="id43" class="indexterm"/> possible to search the help contents for a given string. In that case, at the prompt, we press the (<em>/</em>) slash key. The prompt changes from a colon into a slash, and we proceed to input the keyword we would like to search for.</p><p>For example, is<a id="id44" class="indexterm"/> there a SciPy function that computes the <strong>Pearson kurtosis</strong> of a given dataset? At the slash prompt, we type in <code class="literal">kurtosis</code> and press <em>enter</em>. The help system takes us to the first occurrence of that string. To access successive occurrences of the string kurtosis, we press the <em>N</em> key (for next) until we find what we require. At that stage, we proceed to quit this help session (by pressing <em>Q</em>) and request more information on the function itself:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; help(scipy.stats.kurtosis)</strong>
</pre></div><p>The output of this command will depend on the installed version of SciPy. It might look like this (run the companion IPython Notebook for this chapter to see how the actual output from your system is, or run the command in a Python console):</p><div><img src="img/7702OS_01_06.jpg" alt="How to find documentation"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Scientific visualization</h1></div></div></div><p>At this<a id="id45" class="indexterm"/> point, we would like to introduce you to another resource that we will be using to generate graphs, namely the matplotlib libraries. It may be downloaded from its official web page, <a class="ulink" href="http://matplotlib.org/">http://matplotlib.org/</a>, and installed following the standard Python commands. There is a good online documentation in the official web page, and we encourage the reader to dig deeper than the few commands that we will use in this book. For instance, the excellent monograph <em>Matplotlib for Python Developers</em>, <em>Sandro Tosi</em>, <em>Packt Publishing</em>, provides all that we would need and more. Other plotting libraries are available (commercial or otherwise that aim to very different and specific applications. The degree of sophistication and ease of use of matplotlib makes it one of the best options to generate graphics in scientific computing.</p><p>Once installed, it may be imported using <code class="literal">import matplotlib</code>. Among all its modules, we will focus on <code class="literal">pyplot</code> that provides a comfortable interface with the plotting libraries. For example, if we desire to plot a cycle of the sine function, we could execute the following code snippet:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import numpy</strong>
<strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong>
<strong>&gt;&gt;&gt; x=numpy.linspace(0,2*numpy.pi,32)</strong>
<strong>&gt;&gt;&gt; fig = plt.figure()</strong>
<strong>&gt;&gt;&gt; plt.plot(x, numpy.sin(x))</strong>
<strong>&gt;&gt;&gt; plt.show()</strong>
<strong>&gt;&gt;&gt; fig.savefig('sine.png')</strong>
</pre></div><p>We obtain the following plot:</p><div><img src="img/7702OS_01_07.jpg" alt="Scientific visualization"/></div><p>Let us explain each command from the previous session. The first two commands are used to import <code class="literal">numpy</code> and <code class="literal">matplotlib.pyplot</code> as usual. We define an array <em>x</em> of 32 uniformly spaced floating point values from 0 to 2<em>π</em>, and define <em>y</em> to be the array containing the sine of the values from <em>x</em>. The command figure creates space in the memory <a id="id46" class="indexterm"/>to store the subsequent plots and puts in place an object of the <code class="literal">matplotlib.figure.Figure</code> form. The <code class="literal">plt.plot(x, numpy.sin(x))</code> command creates an object of the <code class="literal">matplotlib.lines.Line2D</code> form containing data with the plot of <em>x</em> against <code class="literal">numpy.sin(x)</code> together with a set of axes attached to it and labeled according to the ranges of the variables. This object is stored in the previous <code class="literal">Figure</code> object and is displayed on the screen via the <code class="literal">plt.show()</code>command. The last command in the session, <code class="literal">fig.savefig()</code>, saves the Figure object to whatever valid image format we desire (in this case, a <strong>Portable</strong> <strong>Network</strong> <strong>Graphics</strong> (<strong>PNG</strong>) image). From<a id="id47" class="indexterm"/> now on, in any code that deals with matplotlib commands, we will leave the option of showing/saving open.</p><p>There are, of course, commands that control the style of axes, aspect ratio between axes, labeling, colors, legends, the possibility of managing several figures at the same time (subplots), and many more features to display all sorts of data. We will be discovering these as we progress with examples throughout the book.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>How to open IPython Notebooks</h1></div></div></div><p>This <a id="id48" class="indexterm"/>book comes with a set of IPython Notebooks that will help you interactively test and modify or adapt to your needs to the code snippets shown in each chapter of the book. We should warn, however, that these IPython Notebooks will make sense only if read along side the book.</p><p>In this regard, this book assumes familiarity with Python and some of its development environment as the IPython Notebook. Consequently, we will only refer to the documentation <a id="id49" class="indexterm"/>on the official website for IPython Notebook (<a class="ulink" href="http://ipython.org/notebook.html">http://ipython.org/notebook.html</a>). You can find additional help at (<a class="ulink" href="http://ipython.org/ipython-doc/stable/notebook/index.html">http://ipython.org/ipython-doc/stable/notebook/index.html</a>). Note that IPython <a id="id50" class="indexterm"/>Notebook is also available through <strong>Wakari</strong> (<a class="ulink" href="https://wakari.io/">https://wakari.io/</a>), as a standalone or part of the Anaconda package, or by Enthought. If you're new to IPython Notebook, get started by looking at the example collection and reading the documentation. </p><p>To use the files for this book, open a terminal and go to the directory where the file you want to open is stored (it should have the form <code class="literal">filename.ipynb</code>). At the command line, in that terminal, type: </p><div><pre class="programlisting"><strong>ipython notebook filename.ipynb</strong>
</pre></div><p>After hitting the <em>enter</em> key, the file should be displayed in the default web browser. In case that does not happen, please note that the IPython Notebook is officially supported on the browsers Chrome, Safari, and Firefox. For additional details refers to the <em>Browser Compatibility</em> section on the documentation currently at <a class="ulink" href="http://ipython.org/ipython-doc/stable/install/install.html">http://ipython.org/ipython-doc/stable/install/install.html</a>.</p><p>Once<a id="id51" class="indexterm"/> the <code class="literal">.ipynb</code> file has been opened, press and hold the <em>shift</em> key and hit <em>enter</em> to start executing the notebook cell by cell. Another way to execute the notebook cell by cell is via the player icon on the menu near the left of the cell labeled as <strong>markdown</strong>. Alternatively, from the <strong>Cell</strong> menu (on the top of the browser) you could choose among several options to execute the contents of the notebook. </p><p>To leave the notebook you could choose <strong>Close</strong> <strong>and</strong> <strong>halt</strong>, from the <strong>File</strong> menu on top of the browser below the label <strong>Notebook</strong>. Options to save the notebook can also be found under the <strong>File</strong> menu. To completely close the notebook browser you need to hit the keys <em>ctrl</em> and <em>C</em> simultaneously on the terminal where the notebook was started and follow the instructions after that. </p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, you have learned the benefits of using the combination of Python, NumPy, SciPy, and matplotlib as a programming environment for any scientific endeavor that requires mathematics; in particular, anything related to numerical computations. You have explored the environment, learned how to download, install, and test the required libraries, used them for some quick computations, and figured out a few good ways to search for help. </p><p>In <a class="link" href="ch02.html" title="Chapter 2. Working with the NumPy Array As a First Step to SciPy">Chapter 2</a>, <em>Working with the NumPy Array As a First Step to SciPy</em>, we will guide you through basic object creation in SciPy, including the best methods to manipulate data, or obtain information from it.</p></div></body></html>