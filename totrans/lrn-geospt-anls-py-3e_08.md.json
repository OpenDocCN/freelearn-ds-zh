["```py\nfrom gdal import gdal_array\n```", "```py\n# name of our source image\nsrc = \"FalseColor.tif\"\n# load the source image into an array\narr = gdal_array.LoadFile(src)\n```", "```py\n# swap bands 1 and 2 for a natural color image.\n# We will use numpy \"advanced slicing\" to reorder the bands.\n# Using the source image\noutput = gdal_array.SaveArray(arr[[1, 0, 2], :], \"swap.tif\",\n format=\"GTiff\", prototype=src)\n# Dereference output to avoid corrupted file on some platforms\noutput = None\n```", "```py\nfrom gdal import gdal_array\nimport turtle as t\n```", "```py\ndef histogram(a, bins=list(range(0, 256))):\n fa = a.flat\n n = gdal_array.numpy.searchsorted(gdal_array.numpy.sort(fa), bins)\n n = gdal_array.numpy.concatenate([n, [len(fa)]])\n hist = n[1:]-n[:-1]\n return hist\n```", "```py\ndef draw_histogram(hist, scale=True):\n```", "```py\nt.color(\"black\")\naxes = ((-355, -200), (355, -200), (-355, -200), (-355, 250))\nt.up()\nfor p in axes:\n  t.goto(p)\n  t.down()\n  t.up()\n```", "```py\nt.goto(0, -250)\nt.write(\"VALUE\", font=(\"Arial, \", 12, \"bold\"))\nt.up()\nt.goto(-400, 280)\nt.write(\"FREQUENCY\", font=(\"Arial, \", 12, \"bold\"))\nx = -355\ny = -200\nt.up()\n```", "```py\nfor i in range(1, 11):\n  x = x+65\n  t.goto(x, y)\n  t.down()\n  t.goto(x, y-10)\n  t.up()\n  t.goto(x, y-25)\n  t.write(\"{}\".format((i*25)), align=\"center\")\n```", "```py\nx = -355\ny = -200\nt.up()\npixels = sum(hist[0])\nif scale:\n  max = 0\n  for h in hist:\n    hmax = h.max()\n    if hmax > max:\n      max = hmax\n  pixels = max\nlabel = int(pixels/10)\nfor i in range(1, 11):\n  y = y+45\n  t.goto(x, y)\n  t.down()\n  t.goto(x-10, y)\n  t.up()\n  t.goto(x-15, y-6)\n  t.write(\"{}\".format((i*label)), align=\"right\")\n```", "```py\nx_ratio = 709.0 / 256\ny_ratio = 450.0 / pixels\ncolors = [\"red\", \"green\", \"blue\"]\nfor j in range(len(hist)):\n  h = hist[j]\n  x = -354\n  y = -199\n  t.up()\n  t.goto(x, y)\n  t.down()\n  t.color(colors[j])\n  for i in range(256):\n    x = i * x_ratio\n    y = h[i] * y_ratio\n    x = x - (709/2)\n    y = y + -199\n    t.goto((x, y))\n```", "```py\nim = \"swap.tif\"\nhistograms = []\narr = gdal_array.LoadFile(im)\nfor b in arr:\n  histograms.append(histogram(b))\ndraw_histogram(histograms)\nt.pen(shown=False)\nt.done()\n```", "```py\ndraw_histogram(histograms)\n```", "```py\ndraw_histogram(histograms, scale=False)\n```", "```py\nimport gdal_array\nimport operator\nfrom functools import reduce\n\ndef histogram(a, bins=list(range(0, 256))):\n fa = a.flat\n n = gdal_array.numpy.searchsorted(gdal_array.numpy.sort(fa), bins)\n n = gdal_array.numpy.concatenate([n, [len(fa)]])\n hist = n[1:]-n[:-1]\n return hist\n\ndef stretch(a):\n \"\"\"\n Performs a histogram stretch on a gdal_array array image.\n \"\"\"\n hist = histogram(a)\n lut = []\n for b in range(0, len(hist), 256):\n # step size\n step = reduce(operator.add, hist[b:b+256]) / 255\n # create equalization look-up table\n n = 0\n for i in range(256):\n lut.append(n / step)\n n = n + hist[i+b]\n gdal_array.numpy.take(lut, a, out=a)\n return asrc = \"swap.tif\"\narr = gdal_array.LoadFile(src)\nstretched = stretch(arr)\noutput = gdal_array.SaveArray(arr, \"stretched.tif\", format=\"GTiff\", prototype=src)\noutput = None\n```", "```py\nim = \"stretched.tif\"\n```", "```py\nimport operator\nfrom osgeo import gdal, gdal_array, osr\nimport shapefile\n```", "```py\ntry:\n import Image\n import ImageDraw\nexcept:\n from PIL import Image, ImageDraw\n```", "```py\n# Raster image to clip\nraster = \"stretched.tif\"\n# Polygon shapefile used to clip\nshp = \"hancock\"\n# Name of clipped raster file(s)\noutput = \"clip\"\n```", "```py\ndef imageToArray(i):\n \"\"\"\n Converts a Python Imaging Library array to a gdal_array image.\n \"\"\"\n a = gdal_array.numpy.fromstring(i.tobytes(), 'b')\n a.shape = i.im.size[1], i.im.size[0]\n return a\n```", "```py\ndef world2Pixel(geoMatrix, x, y):\n \"\"\"\n Uses a gdal geomatrix (gdal.GetGeoTransform()) to calculate\n the pixel location of a geospatial coordinate\n \"\"\"\n ulX = geoMatrix[0]\n ulY = geoMatrix[3]\n xDist = geoMatrix[1]\n yDist = geoMatrix[5]\n rtnX = geoMatrix[2]\n rtnY = geoMatrix[4]\n pixel = int((x - ulX) / xDist)\n line = int((ulY - y) / abs(yDist))\n return (pixel, line)\n```", "```py\n# Load the source data as a gdal_array array\nsrcArray = gdal_array.LoadFile(raster)\n```", "```py\n# Also load as a gdal image to get geotransform (world file) info\nsrcImage = gdal.Open(raster)\ngeoTrans = srcImage.GetGeoTransform()\n```", "```py\n# Use pyshp to open the shapefile\nr = shapefile.Reader(\"{}.shp\".format(shp))\n```", "```py\n# Convert the layer extent to image pixel coordinates\nminX, minY, maxX, maxY = r.bbox\nulX, ulY = world2Pixel(geoTrans, minX, maxY)\nlrX, lrY = world2Pixel(geoTrans, maxX, minY)\n```", "```py\n# Calculate the pixel size of the new image\npxWidth = int(lrX - ulX)\npxHeight = int(lrY - ulY)\nclip = srcArray[:, ulY:lrY, ulX:lrX]\n```", "```py\n# Create a new geomatrix for the image\n# to contain georeferencing data\ngeoTrans = list(geoTrans)\ngeoTrans[0] = minX\ngeoTrans[3] = maxY\n```", "```py\n# Map points to pixels for drawing the county boundary\n# on a blank 8-bit, black and white, mask image.\npixels = []\nfor p in r.shape(0).points:\n pixels.append(world2Pixel(geoTrans, p[0], p[1]))\nrasterPoly = Image.new(\"L\", (pxWidth, pxHeight), 1)\n# Create a blank image in PIL to draw the polygon.\nrasterize = ImageDraw.Draw(rasterPoly)\nrasterize.polygon(pixels, 0)\n```", "```py\n# Convert the PIL image to a NumPy array\nmask = imageToArray(rasterPoly)\n```", "```py\n# Clip the image using the mask\nclip = gdal_array.numpy.choose(mask, (clip, 0)).astype(\n gdal_array.numpy.uint8)\n# Save ndvi as tiff\ngdal_array.SaveArray(clip, \"{}.tif\".format(output),\n format=\"GTiff\", prototype=raster)\n```", "```py\nimport gdal\nfrom gdal import gdal_array, osr\n```", "```py\n# Input file name (thermal image)\nsrc = \"thermal.tif\"\n# Output file name\ntgt = \"classified.jpg\"\n```", "```py\n# Load the image into numpy using gdal\nsrcArr = gdal_array.LoadFile(src)\n```", "```py\n# Split the histogram into 20 bins as our classes\nclasses = gdal_array.numpy.histogram(srcArr, bins=20)[1]\n```", "```py\n# Color look-up table (LUT) - must be len(classes)+1.\n# Specified as R, G, B tuples\nlut = [[255, 0, 0], [191, 48, 48], [166, 0, 0], [255, 64, 64], [255, \n    115, 115], [255, 116, 0], [191, 113, 48], [255, 178, 115], [0, \n    153, 153], [29, 115, 115], [0, 99, 99], [166, 75, 0], [0, 204, \n    0], [51, 204, 204], [255, 150, 64], [92, 204, 204], [38, 153, \n    38], [0, 133, 0], [57, 230, 57], [103, 230, 103], [184, 138, 0]]\n```", "```py\n# Starting value for classification\nstart = 1\n# Set up the RGB color JPEG output image\nrgb = gdal_array.numpy.zeros((3, srcArr.shape[0],\n srcArr.shape[1], ), gdal_array.numpy.float32)\n# Process all classes and assign colors\nfor i in range(len(classes)):\n  mask = gdal_array.numpy.logical_and(start <= srcArr, srcArr <= \n  classes[i])\n for j in range(len(lut[i])):\n   rgb[j] = gdal_array.numpy.choose(mask, (rgb[j], lut[i][j]))\n start = classes[i]+1\n```", "```py\n# Save the image\noutput = gdal_array.SaveArray(rgb.astype(gdal_array.numpy.uint8), tgt, format=\"JPEG\")\noutput = None\n```", "```py\nfrom gdal import gdal_array\n```", "```py\n# Input file name (thermal image)\nsrc = \"islands.tif\"\n# Output file name\ntgt = \"islands_classified.tiff\"\n```", "```py\n# Load the image into numpy using gdal\nsrcArr = gdal_array.LoadFile(src)\n```", "```py\n# Split the histogram into 20 bins as our classes\nclasses = gdal_array.numpy.histogram(srcArr, bins=2)[1]\nlut = [[255, 0, 0], [0, 0, 0], [255, 255, 255]]\n```", "```py\n# Starting value for classification\nstart = 1\n# Set up the output image\nrgb = gdal_array.numpy.zeros((3, srcArr.shape[0], srcArr.shape[1], ),\n gdal_array.numpy.float32)\n# Process all classes and assign colors\nfor i in range(len(classes)):\n  mask = gdal_array.numpy.logical_and(start <= srcArr, srcArr <= \n  classes[i])\n for j in range(len(lut[i])):\n   rgb[j] = gdal_array.numpy.choose(mask, (rgb[j], lut[i][j]))\n   start = classes[i]+1\n```", "```py\n# Save the image\ngdal_array.SaveArray(rgb.astype(gdal_array.numpy.uint8),\n tgt, format=\"GTIFF\", prototype=src) \n```", "```py\nimport gdal\nfrom gdal import ogr, osr\n```", "```py\n# Thresholded input raster name\nsrc = \"islands_classified.tiff\"\n# Output shapefile name\ntgt = \"extract.shp\"\n# OGR layer name\ntgtLayer = \"extract\"\n```", "```py\n# Open the input raster\nsrcDS = gdal.Open(src)\n# Grab the first band\nband = srcDS.GetRasterBand(1)\n```", "```py\n# Force gdal to use the band as a mask\nmask = band\n```", "```py\n# Set up the output shapefile\ndriver = ogr.GetDriverByName(\"ESRI Shapefile\")\nshp = driver.CreateDataSource(tgt)\n```", "```py\n# Copy the spatial reference\nsrs = osr.SpatialReference()\nsrs.ImportFromWkt(srcDS.GetProjectionRef())\nlayer = shp.CreateLayer(tgtLayer, srs=srs)\n```", "```py\n# Set up the dbf file\nfd = ogr.FieldDefn(\"DN\", ogr.OFTInteger)\nlayer.CreateField(fd)\ndst_field = 0\n```", "```py\n# Automatically extract features from an image!\nextract = gdal.Polygonize(band, mask, layer, dst_field, [], None) \n```", "```py\nimport shapefile\nimport pngcanvas\n```", "```py\nr = shapefile.Reader(\"extract.shp\")\nxdist = r.bbox[2] - r.bbox[0]\nydist = r.bbox[3] - r.bbox[1]\niwidth = 800\niheight = 600\nxratio = iwidth/xdist\nyratio = iheight/ydist\n```", "```py\npolygons = []\n```", "```py\nfor shape in r.shapes():\n for i in range(len(shape.parts)):\n pixels = []\n pt = None\n if i < len(shape.parts)-1:\n   pt = shape.points[shape.parts[i]:shape.parts[i+1]]\n else:\n   pt = shape.points[shape.parts[i]:]\n```", "```py\n for x, y in pt:\n   px = int(iwidth - ((r.bbox[2] - x) * xratio))\n   py = int((r.bbox[3] - y) * yratio)\n   pixels.append([px, py])\n polygons.append(pixels)\n```", "```py\nc = pngcanvas.PNGCanvas(iwidth, iheight)\nfor p in polygons:\n c.polyline(p)\n```", "```py\nwith open(\"extract.png\", \"wb\") as f:\n    f.write(c.dump())\n    f.close()\n```", "```py\nimport gdal\nfrom gdal import gdal_array\nimport numpy as np\n```", "```py\n# \"Before\" image\nim1 = \"before.tif\"\n# \"After\" image\nim2 = \"after.tif\"\n```", "```py\n# Load before and after into arrays\nar1 = gdal_array.LoadFile(im1).astype(np.int8)\nar2 = gdal_array.LoadFile(im2)[1].astype(np.int8)\n```", "```py\n# Perform a simple array difference on the images\ndiff = ar2 - ar1\n```", "```py\n# Set up our classification scheme to try\n# and isolate significant changes\nclasses = np.histogram(diff, bins=5)[1]\n```", "```py\n# The color black is repeated to mask insignificant changes\nlut = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 255, 0], [255, 0, 0]]\n```", "```py\n# Starting value for classification\nstart = 1\n# Set up the output image\nrgb = np.zeros((3, diff.shape[0], diff.shape[1], ), np.int8)\n# Process all classes and assign colors\nfor i in range(len(classes)):\n mask = np.logical_and(start <= diff, diff <= classes[i])\n for j in range(len(lut[i])):\n rgb[j] = np.choose(mask, (rgb[j], lut[i][j]))\n start = classes[i]+1\n```", "```py\n# Save the output image\noutput = gdal_array.SaveArray(rgb, \"change.tif\", format=\"GTiff\", prototype=im2)\noutput = None\n```"]