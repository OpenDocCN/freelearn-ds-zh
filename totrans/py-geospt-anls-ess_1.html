<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Geospatial Analysis and Techniques</h1></div></div></div><p>In this introductory chapter, we will start our exploration of geospatial analysis by learning about the types of tasks you will typically be performing, and then look at spatial data and the Python libraries you can use to work with it. We will finish by writing an example program in Python to analyze some geospatial data.</p><p>As you work through this chapter, you will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Become familiar with the types of problems that geospatial analysis will help to solve</li><li class="listitem" style="list-style-type: disc">Understand the various types of geospatial data and some of the important concepts related to location-based data</li><li class="listitem" style="list-style-type: disc">Set up your computer to use the third-party libraries you need to start analyzing geospatial data using Python</li><li class="listitem" style="list-style-type: disc">Obtain some basic geospatial data to get started</li><li class="listitem" style="list-style-type: disc">Learn how to use the GDAL/OGR library to read through a shapefile and extract each feature's attributes and geometry</li><li class="listitem" style="list-style-type: disc">Learn how to use Shapely to manipulate and analyze geospatial data</li><li class="listitem" style="list-style-type: disc">Write a simple but complete program to identify neighboring countries</li></ul></div><p>Let's start by looking at the types of problems and tasks typically solved using geospatial analysis.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>About geospatial analysis</h1></div></div></div><p>Geospatial analysis<a id="id0" class="indexterm"/> is the process of reading, manipulating, and summarizing geospatial data to yield useful and interesting results. A lot of the time, you will be answering questions like the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is the shortest drivable distance between Sausalito and Palm Springs?</li><li class="listitem" style="list-style-type: disc">What is the total length of the border between France and Belgium?</li><li class="listitem" style="list-style-type: disc">What is the area of each National Park in New Zealand that borders the ocean?</li></ul></div><p>The answer to these sorts of questions will typically be a number or a list of numbers. Other types of geospatial analysis will involve calculating new sets of geospatial data based on existing data. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate an <a id="id1" class="indexterm"/>elevation profile for USA Route 66 from Los Angeles, CA, to Albuquerque, NM.</li><li class="listitem" style="list-style-type: disc">Show me the portion of Brazil north of the equator.</li><li class="listitem" style="list-style-type: disc">Highlight the area of Rarotonga likely to be flooded if the ocean rose by 2 meters.</li></ul></div><p>In these cases, you will be generating a new set of geospatial data, which you would typically then display in a chart or on a map.</p><p>To perform this sort of analysis, you will need two things: appropriate geospatial analysis tools and suitable geospatial data.</p><p>We are going to perform some simple geospatial analysis shortly. Before we do, though, let's take a closer look at the concept of geospatial data.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Understanding geospatial data</h1></div></div></div><p>Geospatial data <a id="id2" class="indexterm"/>is data that positions things on the Earth's surface. This is a deliberately vague definition that encompasses both the idea of location and shape. For example, a database of car accidents may include the latitude and longitude coordinates identifying where each accident occurred, and a file of county outlines would include both the position and shape of each county. Similarly, a GPS recording of a journey would include the position of the traveler over time, tracing out the path they took on their travels.</p><p>It is important to realize that geospatial data includes more than just the geospatial information itself. For example, the following outlines are not particularly useful by themselves:</p><div><img src="img/4516OS_1_01.jpg" alt="Understanding geospatial data"/></div><p>Once you add appropriate <a id="id3" class="indexterm"/>
<strong>metadata</strong>, however, these outlines make a lot more sense:</p><div><img src="img/4516OS_1_02.jpg" alt="Understanding geospatial data"/></div><p>Geospatial data, therefore, includes both spatial information (locations and shapes) and non-spatial information (metadata) about each item being described.</p><p>Spatial <a id="id4" class="indexterm"/>information is usually represented as a series of <a id="id5" class="indexterm"/>
<strong>coordinates</strong>, for example:</p><div><pre class="programlisting">location = (-38.136734, 176.252300)
outline = ((-61.686,17.024),(-61.738,16.989),(-61.829,16.996) ...)</pre></div><p>These numbers won't mean much to you directly, but once you plot these series of coordinates onto a map, the data suddenly becomes comprehensible:</p><div><img src="img/4516OS_01_03.jpg" alt="Understanding geospatial data"/></div><p>There are two fundamental types of geospatial data:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Raster data</strong>: This is <a id="id6" class="indexterm"/>geospatial<a id="id7" class="indexterm"/> data that divides the world up into <strong>cells</strong><a id="id8" class="indexterm"/> and associates values with each cell. This is very similar to the way that bitmapped images divide an image up into pixels and associate a color with each pixel; for example:<div><img src="img/4516OS_01_04.jpg" alt="Understanding geospatial data"/></div><p>The value of each cell might represent the color to use when drawing the raster data on a map—this is often done to provide a raster basemap on which other data is drawn—or it might represent other information such as elevation, moisture levels, or soil type.</p></li><li class="listitem" style="list-style-type: disc"><strong>Vector data</strong>: This is<a id="id9" class="indexterm"/> geospatial data that consists of a list of <a id="id10" class="indexterm"/><strong>features</strong>. For example, a shapefile containing countries would <a id="id11" class="indexterm"/>have one feature for each country. For each feature, the geospatial dataset will have a <a id="id12" class="indexterm"/><strong>geometry</strong>, which is the shape associated with that feature, and any number of attributes containing the metadata for that feature.<p>A feature's geometry is just a geometric shape that is positioned on the surface of the earth. This geometric shape is made up of<a id="id13" class="indexterm"/> <strong>points</strong>, <strong>lines</strong><a id="id14" class="indexterm"/> (sometimes referred to as <a id="id15" class="indexterm"/>
<strong>LineStrings</strong>), and <a id="id16" class="indexterm"/>
<strong>polygons</strong>, or some combination of these three fundamental types:</p><div><img src="img/4516OS_01_05.jpg" alt="Understanding geospatial data"/></div></li></ul></div><p>The typical raster data formats you might encounter include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GeoTIFF files, which are <a id="id17" class="indexterm"/>basically just TIFF format image files with georeferencing information added to position the image accurately on the earth's surface.</li><li class="listitem" style="list-style-type: disc">USGS <code class="literal">.dem</code> files, which<a id="id18" class="indexterm"/> hold a <strong>Digital Elevation Model</strong> (<strong>DEM</strong>)<a id="id19" class="indexterm"/> in a simple ASCII data format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">.png</code>, <code class="literal">.bmp</code>, and <code class="literal">.jpeg</code> format image files, with <a id="id20" class="indexterm"/>associated <a id="id21" class="indexterm"/>georeferencing files to <a id="id22" class="indexterm"/>position the images on the surface of the earth.</li></ul></div><p>For vector-format data, you may typically encounter the following formats:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Shapefile</strong>: This is an<a id="id23" class="indexterm"/> extremely common file format used to store and share <a id="id24" class="indexterm"/>geospatial data.</li><li class="listitem" style="list-style-type: disc"><strong>WKT (Well-Known Text)</strong>: This is <a id="id25" class="indexterm"/>a text-based format often used to <a id="id26" class="indexterm"/>convert geometries from one library or data source to another. This is also the format commonly used when retrieving features from a database.</li><li class="listitem" style="list-style-type: disc"><strong>WKB (Well-Known Binary)</strong>: This is the <a id="id27" class="indexterm"/>binary equivalent of the <a id="id28" class="indexterm"/>WKT format, storing geometries as raw binary data rather than text.</li><li class="listitem" style="list-style-type: disc"><strong>GML (Geometry Markup Language)</strong>: This is<a id="id29" class="indexterm"/> an industry-standard <a id="id30" class="indexterm"/>format based on XML, and is often used when communicating with web services.</li><li class="listitem" style="list-style-type: disc"><strong>KML (Keyhole Markup Language)</strong>: This <a id="id31" class="indexterm"/>is another XML-based <a id="id32" class="indexterm"/>format popularized by Google.</li><li class="listitem" style="list-style-type: disc"><strong>GeoJSON</strong>: This is a <a id="id33" class="indexterm"/>version of<a id="id34" class="indexterm"/> JSON designed to store and transmit geometry data.</li></ul></div><p>Because your analysis can only be as good as the data you are analyzing, obtaining and using good-quality geospatial data is critical. Indeed, one of the big challenges in performing geospatial analysis is to get the right data for the job. Fortunately, there are several websites which provide free good-quality geospatial data. But if you're looking for a more obscure set of data, you may have trouble finding it. Of course, you do always have the choice of creating your own data from scratch, though this is an extremely time-consuming process.</p><p>We will return to the topic of geospatial data in <a class="link" href="ch02.html" title="Chapter 2. Geospatial Data">Chapter 2</a>, <em>Geospatial Data</em>, where we will examine what makes good geospatial data and how to obtain it.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up your Python installation</h1></div></div></div><p>To start analyzing geospatial <a id="id35" class="indexterm"/>data using Python, we are going to make use of two freely available third-party libraries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>GDAL</strong>: The<a id="id36" class="indexterm"/> Geospatial Data Abstraction Library makes it easy for you to read and write geospatial data in both vector and raster format.</li><li class="listitem" style="list-style-type: disc"><strong>Shapely</strong>: As the name <a id="id37" class="indexterm"/>suggests, this is a wonderful library that enables you to perform various calculations on geometric shapes. It also allows you to manipulate shapes, for example, by joining shapes together or by splitting them up into their component pieces.</li></ul></div><p>Let's go ahead and get these two libraries installed into your Python setup so we can start using them right away.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Installing GDAL</h2></div></div></div><p>GDAL, or more <a id="id38" class="indexterm"/>accurately the <a id="id39" class="indexterm"/>GDAL/OGR library, is a project by the <strong>Open Source Geospatial Foundation</strong><a id="id40" class="indexterm"/> to provide libraries to read and write geospatial data in a variety of formats. Historically, the name GDAL referred to the library to read and write raster-format data, while OGR referred to the library to access vector-format data. The two libraries have now merged, though the names are still used in the class and function names, so it is important to understand the difference between the two.</p><p>A default installation of GDAL/OGR allows you to read raster geospatial data in 100 different formats, and write raster data in 71 different formats. For vector data, GDAL/OGR allows you read data in 42 different formats, and write in 39 different formats. This makes GDAL/OGR an extremely useful tool to access and work with geospatial data.</p><p>GDAL/OGR<a id="id41" class="indexterm"/> is a C++ library<a id="id42" class="indexterm"/> with various bindings to allow you to access it from other <a id="id43" class="indexterm"/>languages. After installing it on your computer, you typically use the Python bindings to access the library using your Python interpreter. The following diagram illustrates how these various pieces all fit together:</p><div><img src="img/4516OS_01_06.jpg" alt="Installing GDAL"/></div><p>Let's go ahead and install the GDAL/OGR library now. The main website of GDAL (and OGR) can be <a id="id44" class="indexterm"/>found at <a class="ulink" href="http://gdal.org">http://gdal.org</a>.</p><p>How you install it depends on which operating system your computer is using:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For MS Windows machines, you can install GDAL/OGR using the FWTools<a id="id45" class="indexterm"/> installer, which can be downloaded from <a class="ulink" href="http://fwtools.maptools.org">http://fwtools.maptools.org</a>.<p>Alternatively, you can install GDAL/OGR and Shapely using the <a id="id46" class="indexterm"/>OSGeo installer, which can be found at <a class="ulink" href="http://trac.osgeo.org/osgeo4w">http://trac.osgeo.org/osgeo4w</a>.</p></li><li class="listitem" style="list-style-type: disc">For Mac OS X, you can download the complete installer for GDAL<a id="id47" class="indexterm"/> and OGR<a id="id48" class="indexterm"/> from <a class="ulink" href="http://www.kyngchaos.com/software/frameworks">http://www.kyngchaos.com/software/frameworks</a>.</li><li class="listitem" style="list-style-type: disc">For Linux, you can download the source code to GDAL/OGR from the main GDAL site, and follow the instructions on the site to build it from source. You may also need to install the Python bindings for GDAL and OGR.</li></ul></div><p>Once you have installed it, you can check that it's working by firing up your Python interpreter and typing <code class="literal">import osgeo.gdal</code> and then <code class="literal">import osgeo.ogr</code>. If the Python command prompt reappears each time without an error message, then GDAL and OGR were successfully installed and you're all ready to go:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;import osgeo.gdal</strong>
<strong>&gt;&gt;&gt;import osgeo.ogr</strong>
<strong>&gt;&gt;&gt;</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Installing Shapely</h2></div></div></div><p>Shapely is a geometry <a id="id49" class="indexterm"/>manipulation and<a id="id50" class="indexterm"/> analysis <a id="id51" class="indexterm"/>library. It is based on the <strong>Geometry Engine, Open Source</strong> (<strong>GEOS</strong>) library, which implements a wide range of geospatial data manipulations in C++. Shapely provides a Pythonic interface to GEOS, making it easy to use these manipulations directly within your Python programs. The following illustration shows the relationship between your Python code, the Python interpreter, Shapely, and the GEOS library:</p><div><img src="img/4516OS_01_07.jpg" alt="Installing Shapely"/></div><p>The main website for Shapely<a id="id52" class="indexterm"/> can be found at <a class="ulink" href="http://pypi.python.org/pypi/Shapely">http://pypi.python.org/pypi/Shapely</a>.</p><p>The website has everything you need, including complete documentation on how to use the library. Note that to install Shapely, you need to download both the Shapely Python package and the underlying<a id="id53" class="indexterm"/> GEOS library. The website for the GEOS library can be found at <a class="ulink" href="http://trac.osgeo.org/geos">http://trac.osgeo.org/geos</a>.</p><p>How you go about installing Shapely depends on which operating system your computer is using:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For MS Windows, you should use one of the prebuilt installers available on the Shapely website. These installers include their own copy of GEOS, so there is nothing else to install.</li><li class="listitem" style="list-style-type: disc">For Mac OS X, you should use the prebuilt GEOS framework<a id="id54" class="indexterm"/> available at <a class="ulink" href="http://www.kyngchaos.com/software/frameworks">http://www.kyngchaos.com/software/frameworks</a>.<div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>Note that if you install the <strong>GDAL Complete</strong> package<a id="id55" class="indexterm"/> from the preceding website, you will already have GEOS installed on your computer.</p></div></div><p>Once GEOS has been installed, you can install Shapely using <code class="literal">pip</code>, the Python package manager:</p><div><pre class="programlisting">
<strong>pip install shapely</strong>
</pre></div><p>If you don't have <code class="literal">pip</code> installed on<a id="id56" class="indexterm"/> your computer, you can install it by following the instructions at <a class="ulink" href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>.</p></li><li class="listitem" style="list-style-type: disc">For Linux machines, you can either download the source code from the GEOS website and compile it yourself, or install a suitable RPM or APT package which includes GEOS. Once this has been done, you can use <code class="literal">pip</code> <code class="literal">install shapely</code> to install the Shapely library itself.</li></ul></div><p>Once you have installed it, you can check that the Shapely library is working by running the Python command prompt and typing the following command:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import shapely.geos</strong>
<strong>&gt;&gt;&gt;</strong>
</pre></div><p>If you get the Python command prompt again without any errors, as in the preceding example, then Shapely has been installed successfully and you're all set to go.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Obtaining some geospatial data</h1></div></div></div><p>For this chapter, we will use a simple but still <a id="id57" class="indexterm"/>very useful geospatial data file called <a id="id58" class="indexterm"/>
<strong>World Borders Dataset</strong>. This dataset consists of a single shapefile where each feature within the shapefile represents a country. For each country, the associated geometry object represents the country's outline. Additional attributes contain metadata such as the name of the country, its ISO 3166-1 code, the total land area, its population, and its UN regional classification.</p><p>To obtain the <a id="id59" class="indexterm"/>World Border Dataset, go to <a class="ulink" href="http://thematicmapping.org/downloads/world_borders.php">http://thematicmapping.org/downloads/world_borders.php</a>.</p><p>Scroll down to the <strong>Downloads</strong> section and click on the file to download. Make sure you download the full version and not the simplified one—the file you want will be called <code class="literal">TM_WORLD_BORDERS-0.3.zip</code>.</p><p>Note that the shapefile comes in the form of a ZIP archive. This is because a shapefile consists of multiple files, and it is easier to distribute them if they are stored in a ZIP archive. After downloading the file, double-click on the ZIP archive to decompress it. You will end up with a directory named <code class="literal">TM_WORLD_BORDERS-0.3</code>. Inside this directory should be the following files:</p><div><img src="img/4516OS_01_08.jpg" alt="Obtaining some geospatial data"/></div><p>The following table explains these various files and what information they contain:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Filename</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Readme.txt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is your typical README file, containing useful information about the shapefile.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TM_WORLD_BORDERS-0.3.shp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file contains the geometry data for each feature.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TM_WORLD_BORDERS-0.3.shx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an index into the <code class="literal">.shp</code> file, making it possible to quickly access the geometry for a given feature.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TM_WORLD_BORDERS-0.3.dbf</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a database file holding the various attributes for each feature.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">TM_WORLD_BORDERS-0.3.prj</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This file describes the coordinate system and projection used by the data, as a plain text file.</p>
</td></tr></tbody></table></div><p>Place this directory somewhere <a id="id60" class="indexterm"/>convenient. We will be using this dataset extensively throughout this book, so you may want to keep a backup copy somewhere.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Unlocking the shapefile</h1></div></div></div><p>At last, we are ready to start<a id="id61" class="indexterm"/> working with some geospatial data. Open up a command line or terminal window and <code class="literal">cd</code> into the <code class="literal">TM_WORLD_BORDERS-0.3</code> directory you unzipped earlier. Then type <code class="literal">python</code> to fire up your Python interpreter.</p><p>We're going to start by loading the OGR library we installed earlier:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import osgeo.ogr</strong>
</pre></div><p>We next want to open the <code class="literal">shapefile</code> using OGR:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")</strong>
</pre></div><p>After executing this statement, the <code class="literal">shapefile</code> variable will hold an <code class="literal">osgeo.ogr.Datasource</code> object representing the geospatial data source we have opened. OGR data sources can support multiple layers of information, even though a <code class="literal">shapefile</code> has only a single layer. For this reason, we next need to extract the (one and only) layer from the shapefile:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;layer = shapefile.GetLayer(0)</strong>
</pre></div><p>Let's iterate through the various features within the shapefile, processing each feature in turn. We can do this using the following:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; for i in range(layer.GetFeatureCount()):</strong>
<strong>&gt;&gt;&gt;     feature = layer.GetFeature(i)</strong>
</pre></div><p>The <code class="literal">feature</code> object, an instance of <code class="literal">osgeo.ogr.Feature</code>, allows us to access the geometry associated with the feature, along with the feature's attributes. According to the <code class="literal">README.txt</code> file, the country's name is stored in an attribute called <code class="literal">NAME</code>. Let's extract that name now:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;    feature_name = feature.GetField("NAME")</strong>
</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Notice that the attribute is in uppercase. Shapefile attributes are case sensitive, so you have to use the exact capitalization to get the right attribute. Using <code class="literal">feature.getField("name")</code> would generate an error.</p></div></div><p>To get a reference to the <a id="id62" class="indexterm"/>feature's geometry object, we use the <code class="literal">GetGeometryRef()</code> method:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;     geometry = feature.GetGeometryRef()</strong>
</pre></div><p>We can do all sorts of things with geometries, but for now, let's just see what type of geometry we've got. We can do this using the <code class="literal">GetGeometryName()</code> method:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;&gt;    geometry_type = geometry.GetGeometryName()</strong>
</pre></div><p>Finally, let's print out the information we have extracted for this feature:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt;    print i, feature_name, geometry_type</strong>
</pre></div><p>Here is the complete mini-program we've written to unlock the contents of the shapefile:</p><div><pre class="programlisting">import osgeo.ogr
shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)
for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    feature_name = feature.GetField("NAME")
    geometry = feature.GetGeometryRef()
    geometry_type = geometry.GetGeometryName()
    print i, feature_name, geometry_type</pre></div><p>If you press <strong>Return</strong> a second time to close off the <code class="literal">for</code> loop, your program will run, displaying useful information about each country extracted from the shapefile:</p><div><pre class="programlisting">
<strong>0 Antigua and Barbuda MULTIPOLYGON</strong>
<strong>1 Algeria POLYGON</strong>
<strong>2 Azerbaijan MULTIPOLYGON</strong>
<strong>3 Albania POLYGON</strong>
<strong>4 Armenia MULTIPOLYGON</strong>
<strong>5 Angola MULTIPOLYGON</strong>
<strong>6 American Samoa MULTIPOLYGON</strong>
<strong>7 Argentina MULTIPOLYGON</strong>
<strong>8 Australia MULTIPOLYGON</strong>
<strong>9 Bahrain MULTIPOLYGON</strong>
<strong>...</strong>
</pre></div><p>Notice that the geometry associated with some countries is a polygon, while for other countries the geometry is a multipolygon. As the name suggests, a multipolygon is simply a collection of polygons. Because the geometry represents the outline of each country, a polygon is used where the country's outline can be represented by a single shape, while a multipolygon is used when the outline has multiple parts. This most commonly happens when a country is made up of multiple islands. For example:</p><div><img src="img/4516OS_01_09.jpg" alt="Unlocking the shapefile"/></div><p>As you can see, Algeria is<a id="id63" class="indexterm"/> represented by a polygon, while Australia with its outlying islands would be a multipolygon.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Analyzing the data</h1></div></div></div><p>In the previous section, we <a id="id64" class="indexterm"/>obtained an <code class="literal">osgeo.ogr.Geometry</code> object representing each country's outline. While there are a number of things we can do with this geometry object directly, in this case we'll take the outline and copy it into Shapely so that we can take advantage of Shapely's geospatial analysis capabilities. To do this, we have to export the geometry object out of OGR and import it as a Shapely object. For this, we'll use the WKT format. Still in the Python interpreter, let's grab a single feature's geometry and convert it into a Shapely object:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; import shapely.wkt</strong>
<strong>&gt;&gt;&gt; feature = layer.GetFeature(0)</strong>
<strong>&gt;&gt;&gt; geometry = feature.GetGeometryRef()</strong>
<strong>&gt;&gt;&gt; wkt = geometry.ExportToWkt()</strong>
<strong>&gt;&gt;&gt; outline = shapely.wkt.loads(wkt)</strong>
</pre></div><p>Because we loaded feature number <code class="literal">0</code>, we retrieved the outline for Antigua and Barbuda, which would look like the following if we displayed it on a map:</p><div><img src="img/4516OS_01_10.jpg" alt="Analyzing the data"/></div><p>The <code class="literal">outline</code> variable <a id="id65" class="indexterm"/>holds the outline of this country in the form of a Shapely <code class="literal">MultiPolygon</code> object. We can now use this object to analyze the geometry. Here are a few useful things we can do with a Shapely geometry:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can calculate the <a id="id66" class="indexterm"/><strong>centroid</strong>, which is the center-most point in the geometry.</li><li class="listitem" style="list-style-type: disc">We can calculate the <strong>bounding box</strong><a id="id67" class="indexterm"/> for the geometry. This is a rectangle defining the northern, southern, eastern, and western edges of the polygon.</li><li class="listitem" style="list-style-type: disc">We can calculate the <strong>intersection</strong><a id="id68" class="indexterm"/> between two geometries.</li><li class="listitem" style="list-style-type: disc">We can calculate the <strong>difference</strong><a id="id69" class="indexterm"/> between two geometries.<div><div><h3 class="title"><a id="note03"/>Note</h3><p>We could also calculate values such as the length and area of each polygon. However, because the World Borders Dataset uses what are called <em>unprojected coordinates</em>, the resulting length and area values would be measured in degrees rather than meters or miles. This means that the calculated lengths and areas wouldn't be very useful. We will look at the nature of map projections in the following chapter and find a way to get around this problem so we can calculate meaningful length and area values for polygons. But that's too complex for us to tackle right now.</p></div></div></li></ul></div><p>Let's display the latitude and longitude for our feature's centroid:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; print outline.centroid.x, outline.centroid.y</strong>
<strong>-61.791127517 17.2801365868</strong>
</pre></div><p>Because Shapely doesn't know <a id="id70" class="indexterm"/>which coordinate system the polygon is in, it uses the more generic <code class="literal">x</code> and <code class="literal">y</code> attributes for a point, rather than talking about latitude and longitude values. Remember that latitude corresponds to a position in the north-south direction, which is the <code class="literal">y</code> value, while longitude is a position in the east-west direction, which is the <code class="literal">x</code> value.</p><p>We can also display the outline's bounding box:</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; print outline.bounds</strong>
<strong>(-61.891113, 16.989719, -61.666389, 17.724998)</strong>
</pre></div><p>In this case, the returned values are the minimum longitude and latitude and the maximum longitude and latitude (that is, <code class="literal">min_x</code>, <code class="literal">min_y</code>, <code class="literal">max_x</code>, <code class="literal">max_y</code>).</p><p>There's a lot more we can do with Shapely, of course, but this is enough to prove that the Shapely library is working, and that we can read geospatial data from a shapefile and convert it into a Shapely geometry object for analysis.</p><p>This is as far as we want to go with using the Python shell directly—the shell is great for quick experiments like this, but it quickly gets tedious having to retype lines (or use the command history) when you make a typo. For anything more serious, you will want to write a Python program. In the final section of this chapter, we'll do exactly that: create a Python program that builds on what we have learned to solve a useful geospatial analysis problem.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>A program to identify neighboring countries</h1></div></div></div><p>For our first real geospatial analysis<a id="id71" class="indexterm"/> program, we are going to write a Python script that identifies neighboring countries. The basic concept is to extract the polygon or multipolygon for each country and see which other countries each polygon or multipolygon touches. For each country, we will display a list of other countries that border that country.</p><p>Let's start by creating the Python script. Create a new file named <code class="literal">borderingCountries.py</code> and place it in the same directory as the <code class="literal">TM_WORLD_BORDERS-0.3.shp</code> shapefile you downloaded earlier. Then enter the following into this file:</p><div><pre class="programlisting">import osgeo.ogr
import shapely.wkt

def main():
    shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
    layer = shapefile.GetLayer(0)

    countries = {} # Maps country name to Shapely geometry.

    for i in range(layer.GetFeatureCount()):
        feature = layer.GetFeature(i)
        country = feature.GetField("NAME")
        outline = shapely.wkt.loads(feature.GetGeometryRef().ExportToWkt())

        countries[country] = outline

    print "Loaded %d countries" % len(countries)

if __name__ == "__main__":
    main()</pre></div><p>So far, this is pretty <a id="id72" class="indexterm"/>straightforward. We are using the techniques we learned earlier to read the contents of the shapefile into memory and converting each country's geometry into a Shapely object. The results are stored in the <code class="literal">countries</code> dictionary. Finally, notice that we've placed the program logic into a function called <code class="literal">main()</code>—this is good practice as it lets us use a <code class="literal">return</code> statement to handle errors.</p><p>Now run your program just to make sure it works:</p><div><pre class="programlisting">
<strong>$ python borderingCountries.py</strong>
<strong>Loaded 246 countries</strong>
</pre></div><p>Our next task is to identify the bordering countries. Our basic logic will be to iterate through each country and then find the other countries that border this one. Here is the relevant code, which you should add to the end of your <code class="literal">main()</code> function:</p><div><pre class="programlisting">    for country in sorted(countries.keys()):
        outline = countries[country]

        for other_country in sorted(countries.keys()):

            if country == other_country: continue

            other_outline = countries[other_country]

            if outline.touches(other_outline):

                print "%s borders %s" % (country, other_country)</pre></div><p>As you can see, we use the <code class="literal">touches()</code> method to check if the two countries' geometries are touching.</p><p>Running this program will now show you the countries that border each other:</p><div><pre class="programlisting">
<strong>$ python borderingCountries.py</strong>
<strong>Loaded 246 countries</strong>
<strong>Afghanistan borders Tajikistan</strong>
<strong>Afghanistan borders Uzbekistan</strong>
<strong>Albania borders Montenegro</strong>
<strong>Albania borders Serbia</strong>
<strong>Albania borders The former Yugoslav Republic of Macedonia</strong>
<strong>Algeria borders Libyan Arab Jamahiriya</strong>
<strong>Algeria borders Mali</strong>
<strong>Algeria borders Morocco</strong>
<strong>Algeria borders Niger</strong>
<strong>Algeria borders Western Sahara</strong>
<strong>Angola borders Democratic Republic of the Congo</strong>
<strong>Argentina borders Bolivia</strong>
<strong>...</strong>
</pre></div><p>Congratulations! You <a id="id73" class="indexterm"/>have written a simple Python program to analyze country outlines. Of course, there is a lot that could be done to improve and extend this program. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You could add command-line arguments to let the user specify the name of the shapefile and which attribute to use to display the country name.</li><li class="listitem" style="list-style-type: disc">You could add error checking to handle invalid and non-existent shapefiles.</li><li class="listitem" style="list-style-type: disc">You could add error checking to handle invalid geometries.</li><li class="listitem" style="list-style-type: disc">You could use a spatial database to speed up the process. The program currently takes about a minute to complete, but using a spatial database would speed that up dramatically. If you are dealing with a large amount of spatial data, properly indexed databases are absolutely critical or your program might take weeks to run.</li></ul></div><p>We will look at all these things later in the book.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we started our exploration of geospatial analysis by looking at the types of problems you would typically have to solve and the types of data that you will be working with. We discovered and installed two major Python libraries to work with geospatial data: GDAL/OGR to read (and write) data, and Shapely to perform geospatial analysis and manipulation. We then downloaded a simple but useful shapefile containing country data, and learned how to use the OGR library to read the contents of that shapefile.</p><p>Next, we saw how to convert an OGR geometry object into a Shapely geometry, and then used the Shapely library to analyze and manipulate that geometry. Finally, we created a simple Python program that combines everything we have learned, loading country data into memory and then using Shapely to find countries which border each other.</p><p>In the next chapter, we will delve deeper into the topic of geospatial data, learning more about geospatial data types and concepts, as well as exploring some of the major sources of freely available geospatial data. We will also learn why it is important to have good data to work with—and what happens if you don't.</p></div></div>
</body></html>