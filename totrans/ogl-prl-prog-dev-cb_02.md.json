["```py\ncl_mem clCreateBuffer(cl_context context,\n                      cl_mem_flags flags,\n                      size_t size,\n                      void* host_ptr,\n                      cl_int* errcode_ret)\n```", "```py\ntypedef struct UserData {\n int x;\n int y;\n int z;\n int w;\n} UserData;\n```", "```py\ncl_int clSetKernelArg(cl_kernel kernel,\n                      cl_uint arg_index,\n                      size_T arg_size,\n                      const void *arg_value);\n```", "```py\n// in the kernel code\n_kernel void somefunction(__global int* arg1, __global int* arg2) {…} \n// in the host code\nint main(int argc, char**argv) {\n// code omitted\ncl_kernel kernel; \n// kernel is initialized to point to \"somefunction\" in the kernel file\nclSetKernelArg(kernel, 0, sizeof(cl_mem), (void*) &memoryobjectA);\nclSetKernelArg(kernel, 1, sizeof(cl_mem), (void*) &memoryobjectB);\n```", "```py\n/* Defined earlier */\n#define DATA_SIZE 1048576\nUserData* ud_in = (UserData*) malloc(sizeof(UserData) *\n                                     DATA_SIZE); // input to device\n/* initialization of 'ud_in' is omitted. See code for details.*/\n/* Create a OpenCL buffer object */\ncl_mem UDObj = clCreateBuffer(context, \n                              CL_MEM_READ_ONLY |\n                              CL_MEM_COPY_HOST_PTR, \n                              sizeof(UserData) * DATA_SIZE,\n                              ud_in, &error);\nif (error != CL_SUCCESS) {\n  perror(\"Unable to create buffer object\");\n  exit(1)\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o user_buffer user_buffer.c   -framework OpenCL\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o user_buffer user_buffer.c -I . -I /usr/include -L/usr/lib64/OpenCL/vendors/intel -lintelocl -ltbb -ltbbmalloc -lcl_logger -ltask_executor\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG –m64 -o user_buffer user_buffer.c   -I. –I/opt/AMDAPP/include –L/opt/AMDAPP/lib/x86_64 –lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nCheck passed!\n\n```", "```py\n/*\n  Prepare an array of UserData via dynamic memory allocation\n*/\nUserData* ud_in = (UserData*) malloc( sizeof(UserData) * DATA_SIZE); // input to device\nUserData* ud_out = (UserData*) malloc( sizeof(UserData) * DATA_SIZE); // output from device\n  for( int i = 0; i < DATA_SIZE; ++i) {\n    (ud_in + i)->x = i;\n    (ud_in + i)->y = i;\n    (ud_in + i)->z = i;\n    (ud_in + i)->w = 3 * i;\n  }\n```", "```py\nerror = clSetKernelArg(kernels[i], 0, sizeof(cl_mem), &UDObj);\n  if (error != CL_SUCCESS) {\n    perror(\"Unable to create buffer object\");\n      exit(1);\n  }\n```", "```py\n  /* Enqueue the kernel to the command queue */\n  error = clEnqueueTask(cQ, kernels[i], 0, NULL, NULL);\n    if (error != CL_SUCCESS) {\n      perror(\"Unable to enqueue task to command-queue\");\n      exit(1);\n    }\n```", "```py\n/* Enqueue the read-back from device to host */\n            error = clEnqueueReadBuffer(cQ, UDObj,\n                                         CL_TRUE, // blocking read\n                                         0, // write from the start\n                                         sizeof(UserData) * DATA_SIZE, // how much to copy\n                                         ud_out, 0, NULL, NULL);\n    if ( valuesOK(ud_in, ud_out) ) {\n      printf(\"Check passed!\\n\");\n    } else printf(\"Check failed!\\n\");\n```", "```py\n| __attribute__((aligned))\n```", "```py\n| __attribute__((aligned (8)))\n```", "```py\ntypedef struct __attribute__((aligned)) UserData {\n    int x;\n    int y;\n    int z;\n    int w;\n    char c;\n} UserData;\n```", "```py\ntypedef struct __attribute__((aligned(32)) UserData {…}\n```", "```py\ntypedef struct __attribute__((packed)) LargeUserData {…}\n```", "```py\ncl_int clGetMemObjectInfo(cl_mem memobj,\n                          cl_mem_info param_name,\n                          size_t param_value_size,\n                          void* param_value,\n                          size_t* param_value_size_ret)\n```", "```py\ncl_mem UDObj = clCreateBuffer(context, … sizeof(UserData) *                \n                              DATA_SIZE, ud_in, &error);\n/* Extract some info about the buffer object we created */\ndisplayBufferDetails(UDObj);\n```", "```py\nvoid displayBufferDetails(cl_mem memobj) {\n  cl_mem_object_type objT;\n  cl_mem_flags flags;\n  size_t memSize;\n  clGetMemObjectInfo(memobj, CL_MEM_TYPE,\n                     sizeof(cl_mem_object_type), &objT, 0);\n  clGetMemObjectInfo(memobj, CL_MEM_FLAGS, sizeof(cl_mem_flags),\n                     &flags, 0);\n  clGetMemObjectInfo(memobj, CL_MEM_SIZE, sizeof(size_t),\n                     &memSize, 0);\n  char* str = '\\0';\n  switch (objT) {\n    case CL_MEM_OBJECT_BUFFER: str = \"Buffer or Sub\n                                      buffer\";break;\n    case CL_MEM_OBJECT_IMAGE2D: str = \"2D Image Object\";break;\n    case CL_MEM_OBJECT_IMAGE3D: str = \"3D Image Object\";break;\n  }\n  char flagStr[128] = {'\\0'};\n  if(flags & CL_MEM_READ_WRITE) strcat(flagStr, \"Read-Write|\");\n  if(flags & CL_MEM_WRITE_ONLY) strcat(flagStr, \"Write Only|\");\n  if(flags & CL_MEM_READ_ONLY)  strcat(flagStr, \"Read Only|\");\n  if(flags & CL_MEM_COPY_HOST_PTR) strcat(flagStr, \"Copy from\n                                                    Host|\");\n  if(flags & CL_MEM_USE_HOST_PTR)  strcat(flagStr, \"Use from\n                                                    Host|\");\n  if(flags & CL_MEM_ALLOC_HOST_PTR) strcat(flagStr, \"Alloc from\n                                                     Host|\");\n  printf(\"\\tOpenCL Buffer's details =>\\n\\t size: %lu MB,\\n\\t object type is: %s,\\n\\t flags:0x%lx (%s) \\n\", memSize >> 20, str, flags, flagStr);\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o buffer_query buffer_query.c   -framework OpenCL\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o buffer_query buffer_query.c -I . -I /usr/include -L/usr/lib64/OpenCL/vendors/intel -lintelocl -ltbb -ltbbmalloc -lcl_logger -ltask_executor\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG –m64 -o buffer_query buffer_query.c   -I. –I/opt/AMDAPP/include –L/opt/AMDAPP/lib/x86_64 –lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\n  OpenCL Buffer's details =>\n    size: 128 MB,\n    object type is: Buffer or Sub-buffer,\n    flags:0x21 (Read-Write|Copy from Host)\nTask has been enqueued successfully!\nCheck passed!\n```", "```py\ncl_mem clCreateSubBuffer(cl_mem buffer,\n                         cl_mem_flags flags,\n                         cl_buffer_create_type bufferType,\n                         const void* buffer_create_info,\n                         cl_int* errcode_ret)\n```", "```py\ntypedef struct _cl_buffer_region {\n  size_t origin;\n  size_t size;\n} cl_buffer_region;\n```", "```py\n  cl_buffer_region region;\n  region.size   = (sizeof(UserData)*DATA_SIZE) / numOfDevices; \n  region.origin = offset * region.size;\n  cl_mem subUDObj = clCreateSubBuffer(UDObj,\n                                CL_MEM_READ_WRITE, // read-write\n                                CL_BUFFER_CREATE_TYPE_REGION,\n                                &region, &error);\n  if (error != CL_SUCCESS) { \n    perror(\"Unable to create sub-buffer object\");\n    exit(1);\n  }\n```", "```py\nerror = clSetKernelArg(kernels[j], 0, sizeof(cl_mem), &subUDObj);\n// Error handling code omitted\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o sub_buffer sub_buffer.c –I. –I/opt/AMDAPP/include –L/opt/AMDAPP/lib/x86_64 –lOpenCL\n\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o sub_buffer sub_buffer.c –I. –I/usr/include \n–L/usr/lib64/OpenCL/vendors/intel\n-lintelocl\n-ltbb\n-ltbbmalloc\n-lcl_logger\n-ltask_executor\n\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o sub_buffer sub_buffer.c –I. –I/usr/local/cuda/include –lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 2\nNumber of detected OpenCL devices: 1\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nCheck passed!\n\n```", "```py\nNumber of OpenCL platforms found: 1\nNumber of detected OpenCL devices: 2\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nCheck passed!\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nCheck passed!\n\n```", "```py\ncl_buffer_region region;\nregion.size   = (sizeof(UserData)*DATA_SIZE) / numOfDevices;\nregion.origin = offset * region.size;\ncl_mem subUDObj = clCreateSubBuffer(UDObj,\n                                    CL_MEM_READ_WRITE, // read-write\n                                    CL_BUFFER_CREATE_TYPE_REGION,\n                                    &region, &error);\n```", "```py\nerror = clEnqueueReadBuffer(cQ, \n                            subUDObj,\n                            CL_TRUE, // blocking read\n                            region.origin, // write from the last offset\n                            region.size, // how much to copy\n                            ud_out, 0, NULL, NULL);\n                /* Check the returned data */\n                if ( valuesOK(ud_in, ud_out, DATA_SIZE/numOfDevices){\n                  printf(\"Check passed!\\n\");\n               } else printf(\"Check failed!\\n\");\n```", "```py\ncl_buffer_region region;\nregion.size = sizeof(UserData)*DATA_SIZE;\nregion.origin = 0;\ncl_mem subUDObj = clCreateSubBuffer(UDObj,\n                                    CL_MEM_READ_WRITE, // read-write\n                                    CL_BUFFER_CREATE_TYPE_REGION,\n                                    &region, &error);\ndisplayBufferDetails(subUDObj);\n```", "```py\nvoid displayBufferDetails(cl_mem memobj) {\n  cl_mem_object_type objT;\n  cl_mem_flags flags;\n  size_t memSize;\n  size_t memOffset;\n  cl_mem mainBuffCtx;\n  clGetMemObjectInfo(memobj, CL_MEM_TYPE,\n                     sizeof(cl_mem_object_type), &objT, 0);\n  clGetMemObjectInfo(memobj, CL_MEM_FLAGS, sizeof(cl_mem_flags),\n                     &flags, 0);\n  clGetMemObjectInfo(memobj, CL_MEM_SIZE, sizeof(size_t),\n                     &memSize, 0);\n  clGetMemObjectInfo(memobj, CL_MEM_OFFSET, sizeof(size_t),\n                     &memOffset, 0); // 'CL_MEM_OFF_SET' new in OpenCL 1.2\n  clGetMemObjectInfo(memobj, CL_MEM_ASSOCIATED_MEMOBJECT,\n                     sizeof(size_t),\n                     &memOffset, 0);\n  char* str = '\\0';\n  if (mainBuffCtx) { // implies that 'memobj' is a sub-buffer\n    switch (objT) {\n      case CL_MEM_OBJECT_BUFFER: str = \"Sub-buffer\";break;\n      case CL_MEM_OBJECT_IMAGE2D: str = \"2D Image Object\";break;\n      case CL_MEM_OBJECT_IMAGE3D: str = \"3D Image Object\";break;\n    }\n  } else {\nswitch (objT) {\n  case CL_MEM_OBJECT_BUFFER: str = \"Buffer\";break;\n  case CL_MEM_OBJECT_IMAGE2D: str = \"2D Image Object\";break;\n  case CL_MEM_OBJECT_IMAGE3D: str = \"3D Image Object\";break;\n  } \n}\n  char flagStr[128] = {'\\0'};\n  if(flags & CL_MEM_READ_WRITE) strcat(flagStr, \"Read-Write|\");\n  if(flags & CL_MEM_WRITE_ONLY) strcat(flagStr, \"Write Only|\");\n  if(flags & CL_MEM_READ_ONLY)  strcat(flagStr, \"Read Only|\");\n  if(flags & CL_MEM_COPY_HOST_PTR) strcat(flagStr, \"Copy from\n                                                    Host|\");\n  if(flags & CL_MEM_USE_HOST_PTR)  strcat(flagStr, \"Use from\n                                                    Host|\");\n  if(flags & CL_MEM_ALLOC_HOST_PTR) strcat(flagStr, \"Alloc from\n                                                     Host|\");\n  printf(\"\\tOpenCL Buffer's details =>\\n\\t size: %lu MB,\\n\\t object type is: %s,\\n\\t flags:0x%lx (%s) \\n\", memSize >> 20, str, flags, flagStr);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o subbuffer _query subbuffer_query.c –I. –I/opt/AMDAPP/include –L/opt/AMDAPP/lib/x86_64 –lOpenCL\n\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o subbuffer_query subbuffer_query.c –I. –I/usr/include \n–L/usr/lib64/OpenCL/vendors/intel\n-lintelocl\n-ltbb\n-ltbbmalloc\n-lcl_logger\n-ltask_executor\n\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –m64 –o subbuffer_query subbuffer_query.c –I. –I/usr/local/cuda/include –lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 2\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\n    OpenCL Buffer's details =>\n    size: 128 MB,\n   object type is: Buffer,\n    flags:0x21 (Read-Write|Copy from Host|) \n    OpenCL Buffer's details =>\n    size: 128 MB,\n    object type is: Sub-buffer,\n    flags:0x1 (Read-Write|) \nTask has been enqueued successfully!\nCheck passed!\n```", "```py\nevent1 = clCreateUserEvent(context, &ret);\n```", "```py\nvoid CL_CALLBACK postProcess(cl_event event, cl_int status, void *data) {\n  printf(\"%s\\n\", (char*)data);\n}\nclSetEventCallback(event1, CL_COMPLETE, &postProcess, \"Looks like its done.\");\n```", "```py\nret = clEnqueueWriteBuffer(command_queue, objA, CL_TRUE, 0, 4*4*sizeof(float), A, 0, NULL, NULL );\n  printf(\"A has been written\\n\");\n  /* The next command will wait for event1 according to its status*/\n  ret = clEnqueueWriteBuffer(command_queue, objB, CL_TRUE, 0, 4*4*sizeof(float), B, 1, &event1, NULL);\n  printf(\"B has been written\\n\");\nclSetUserEventStatus(event1, CL_COMPLETE);\n//….code omitted\nclReleaseEvent(event1);\n```", "```py\nCl_int clWaitForEvents(cl_uint num_events, const cl_event* event_list);\n```", "```py\ncl_event event1;\n// create memory objects and other stuff\nret = clEnqueueWriteBuffer(queue, object, CL_TRUE, 0, 1048576, hostPtrA, 1, &event1, NULL);\nclWaitForEvents(&event1); // stalls the host thread until 'event1' has a status of CL_COMPLETE.\n```", "```py\nint\nwaitAndReleaseEvent(cl_event* event) {\n  cl_int eventStatus = CL_QUEUED;\n  while(eventStatus != CL_COMPLETE) {\n    clGetEventInfo(*event, \n                   CL_EVENT_COMMAND_EXECUTION_STATUS,\n                   sizeof(cl_int), \n                   &eventStatus, NULL);\n  }\n  clReleaseEvent(*event);\n  return 0;\n}\n```", "```py\ncl_int clEnqueueCopyBuffer(cl_command_queue command_queue,\n                           cl_mem src_buffer,\n                           cl_mem dst_buffer,\n                           size_t src_offset,\n                           size_t dst_offset,\n                           size_t cb,\n                           cl_uint num_events_in_wait_list,\n                           const cl_event* event_wait_list,\n                           cl_event* event)\n```", "```py\ncl_mem UDObj = clCreateBuffer(context,\n                              CL_MEM_READ_WRITE |\n                              CL_MEM_COPY_HOST_PTR,\n                              sizeof(UserData) * DATA_SIZE, \n                              ud_in, &error);\n… // code omitted. See the source.\n/* Create a buffer from the main buffer 'UDObj' */\ncl_mem copyOfUDObj = clCreateBuffer(context, CL_MEM_READ_WRITE,\t                                               \n                                    sizeof(UserData) * DATA_SIZE,\n                                    0, &error)\nif (error != CL_SUCCESS) { \n  perror(\"Unable to create sub-buffer object\");\n  exit(1);\n}\n/* Let OpenCL know that the kernel is suppose to receive an argument */\nerror = clSetKernelArg(kernels[j], \n                       0,\n                       sizeof(cl_mem),\n                       &copyOfUDObj);\nif (error != CL_SUCCESS) { \n  perror(\"Unable to set buffer object in kernel\");\n  exit(1);\n}\n// code omitted. See the source.\n/* Enqueue the copy-write from device to device */\nerror = clEnqueueCopyBuffer(cQ,\n                            UDObj,\n                            copyOfUDObj,              \n                            0,            // copy from which offset\n                            0,            // copy to which offset\n                            sizeof(UserData)*DATA_SIZE,\n                            0, NULL, NULL);\nprintf(\"Data will be copied!\\n\");\n// Code for enqueueing kernels is omitted.\n/* Enqueue the read-back from device to host */\nerror = clEnqueueReadBuffer(cQ, \n                            copyOfUDObj, \n                            CL_TRUE,  // blocking read\n                            0,        // read from the start\n                            sizeof(UserData)*DATA_SIZE,\n                            ud_out, 0, NULL, NULL);\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g  -DAPPLE -arch i386 -o copy_buffer copy_buffer.c   -framework OpenCL\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o copy_buffer copy_buffer.c -I . -I /usr/include -L/usr/lib64/OpenCL/vendors/intel -lintelocl -ltbb -ltbbmalloc -lcl_logger -ltask_executor\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o copy_buffer copy_buffer.c -I. -I/usr/local/cuda/include  -lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nNumber of detected OpenCL devices: 2\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nData will be copied!\nCheck passed!\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nData will be copied!\nCheck passed!\n```", "```py\nerror = clSetKernelArg(kernels[j], 0, sizeof(cl_mem), &copyOfUDObj);\n```", "```py\ncl_int clEnqueueReadBuffer(cl_command_queue command_queue,\n                        cl_mem buffer,\n                           cl_bool blocking_read, \n                           size_t offset,\n                           size_t cb, \n                           void *ptr,\n                           cl_uint num_events_in_wait_list,\n                           const cl_event *event_wait_list,\n                           cl_event *event)\ncl_int clEnqueueWriteBuffer(cl_command_queue command_queue,\n                        cl_mem buffer,\n                           cl_bool blocking_write, \n                           size_t offset,\n                           size_t cb, \n                           const void *ptr,\n                           cl_uint num_events_in_wait_list,\n                           const cl_event *event_wait_list,\n                           cl_event *event)\n```", "```py\nret = clEnqueueWriteBuffer(command_queue, objA, CL_TRUE, 0, 4*4*sizeof(float), A, 0, NULL, NULL );\nret = clEnqueueWriteBuffer(command_queue, objB, CL_TRUE, 0, 4*4*sizeof(float), B, 1, &event1, NULL);\n```", "```py\ncl_int hostBuffer[NUM_BUFFER_ELEMENTS] = {0, 1, 2, 3, 4, 5, 6, 7,\n                                          8,9,10,11,12,13,14,15};\ncl_int outputPtr[16] = {-1, -1, -1, -1,-1, -1, -1, -1,-1, -1, -1, \n                        -1,-1, -1, -1, -1};\nfor(int idx = 0; idx < 4; ++ idx) {\t\n    size_t buffer_origin[3] = {idx*2*sizeof(int), idx, 0}; \n    size_t host_origin[3] = {idx*2*sizeof(int), idx, 0}; \n    size_t region[3] = {2*sizeof(int), 2, 1};\nerror = clEnqueueReadBufferRect (cQ,\n                                 UDObj,\n                                 CL_TRUE,\n                                 buffer_origin,\n                                 host_origin,\n                                 region,\n                                 0, //buffer_row_pitch,\n                                 0, //buffer_slice_pitch,\n                                 0, //host_row_pitch,\n                                 0, //host_slice_pitch,\n                                 outputPtr,\n                                 0, NULL, NULL);\n}//end of for-loop\n```", "```py\ncl_int\nclEnqueueNDRangeKernel(cl_command_queue command_queue,\n                       cl_kernel kernel,\n                       cl_uint work_dim,\n                       const size_t *global_work_offset,\n                       const size_t *global_work_size,\n                       const size_t *local_work_size,\n                       cl_uint num_events_in_wait_list,\n                       const cl_event *event_wait_list,\n                       cl_event *event)\n```", "```py\n cl_uint work_dim = 2; // 2-D data\n size_t global_work_offset[2] = {0,0}; // kernel evals from (0,0)\n size_t global_work_size[2] = {12,12};\n size_t local_work_size[2]  = {4,4};\n clEnqueueNDRangeKernel(command_q, kernel, work_dim,\n global_work_offset,global_work_size, local_work_size, 0,\n NULL,NULL);\n```", "```py\n// --------- file: work_partition.cl --------------\n#define WIDTH 1024\n#define DATA_TYPE float4\n/*\n  The following macros are convenience 'functions'\n  for striding across a 2-D array of coordinates (x,y)\n  by a factor which happens to be the width of the block\n  i.e. WIDTH\n*/\n#define A(x,y) A[(x)* WIDTH + (y)] #define C(x,y) C[(x)* WIDTH + (y)]\n__kernel void copy2Dfloat4(__global DATA_TYPE *A, __global DATA_TYPE *C)\n{\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    // its like a vector load/store of 4 elements\n    C(x,y) = A(x,y);\n}\n// --------- file: work_partition.c ---------\ncl_float* h_in = (float*) malloc( sizeof(cl_float4) * DATA_SIZE); // input to device\ncl_float* h_out = (float*) malloc( sizeof(cl_float4) * DATA_SIZE); // output from device\n  for( int i = 0; i < DATA_SIZE; ++i) {\n    h_in[i] = (float)i;\n  }\n// code omitted\ncl_mem memInObj = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(cl_float4) * (DATA_SIZE), h_in, &error);\ncl_mem memOutObj = clCreateBuffer(context, \n                                  CL_MEM_WRITE_ONLY ,\n                                  sizeof(cl_float4) * (DATA_SIZE),\n                                  NULL, &error);\nif(error != CL_SUCCESS) {\n  perror(\"Can't create an output buffer object\");\n  exit(1);\n}\n/* Let OpenCL know that the kernel is suppose to receive two arguments */\nerror = clSetKernelArg(kernels[j], 0, sizeof(cl_mem), &memInObj);\nif (error != CL_SUCCESS) {\n  perror(\"Unable to set buffer object in kernel\");\n  exit(1);\n}\nerror = clSetKernelArg(kernels[j], 1, sizeof(cl_mem), &memOutObj);\nif (error != CL_SUCCESS) {\n  perror(\"Unable to set buffer object in kernel\");\n  exit(1);\n}\n/* Enqueue the kernel to the command queue */\nsize_t globalThreads[2];\nglobalThreads[0]=1024;\nglobalThreads[1]=1024;\nsize_t localThreads[2];\nlocalThreads[0] = 64;\nlocalThreads[1] = 2;\ncl_event evt;\nerror = clEnqueueNDRangeKernel(cQ, \n                               kernels[j],\n                               2,\n                               0,\n                               globalThreads,\n                               localThreads,\n                               0, \n                               NULL, &evt);\nclWaitForEvents(1, &evt);\nif (error != CL_SUCCESS) {\n  perror(\"Unable to enqueue task to command-queue\");\n  exit(1);\n}\nclReleaseEvent(evt);\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g  -DAPPLE -arch i386 -o work_partition work_partition.c   -framework OpenCL\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o work_partition work_partition.c -I . -I /usr/include -L/usr/lib64/OpenCL/vendors/intel -lintelocl -ltbb -ltbbmalloc -lcl_logger -ltask_executor\n\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -m64 -o work_partition work_partition.c -I. -I/usr/local/cuda/include  -lOpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 2\nNumber of detected OpenCL devices: 1\nRunning GPU \n    => Kernel name: copy2Dfloat4 with arity: 2\n    => About to create command queue and enqueue this kernel...\n    => Task has been enqueued successfully!\nCheck passed!\nNumber of detected OpenCL devices: 1\nRunning on CPU ........\n    => Kernel name: copy2Dfloat4 with arity: 2\n    => About to create command queue and enqueue this kernel...\n    => Task has been enqueued successfully!\nCheck passed!\n```", "```py\nint x = get_local_id(0);//x would range from 0 to 15\nint y = get_local_id(1);//y would range from 0 to 15\nint blockIdX = get_group_id(0);\nint blockIdY = get_group_id(1);\nint blockSizeX = get_local_size(0); // would return 16\nint blockSizeY = get_local_size(1); // would return 16\nuint globalThreadId = (blockIdx * blockSizeX + x) + \n                      (blockIdY * blockSizeY + y);\n```"]