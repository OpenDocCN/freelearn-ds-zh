- en: Chapter 1. Bird's Eye View of Cassandra
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Cassandra的鸟瞰图
- en: Imagine that we have turned back the clock to the 1990s and you an application
    architect. Whenever you were required to select a suitable database technology
    for your applications, what kind of database technology would you choose? I bet
    95 percent (or more) of the time you would select relational databases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们把时钟拨回到20世纪90年代，你是一名应用架构师。每当需要为你的应用选择合适的数据库技术时，你会选择哪种数据库技术？我敢打赌95%（或更多）的时间你会选择关系数据库。
- en: '**Relational databases** have been the most dominating data management solution
    since the 1970s. At that time, the application system was usually silo. The users
    of the application and their usage patterns were known and under control. The
    workload that had to be catered for by the relational database could be determined
    and estimated. Apart from the workload consideration, the data model can also
    be structured in normalized forms as recommended by the relational theory. Moreover,
    relational databases provide many benefits such as support of transactions, data
    consistency, and isolation. Relational databases just fit perfectly for the purposes.
    Therefore, it is not difficult to understand why the relational database has been
    so popular and why it is the de facto standard for persistent data stores in application
    development.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系数据库**自20世纪70年代以来一直是数据管理解决方案中最占主导地位的形式。当时，应用系统通常是孤立的。应用用户及其使用模式是已知且可控的。关系数据库需要满足的工作负载可以确定并估算。除了工作负载的考虑之外，数据模型还可以按照关系理论推荐的方式进行规范化。此外，关系数据库提供了许多好处，如支持事务、数据一致性和隔离性。关系数据库非常适合这些用途。因此，不难理解为什么关系数据库如此受欢迎，为什么它是应用开发中持久数据存储的事实标准。'
- en: Nonetheless, with the proliferation of the Internet and the numerous web applications
    running on it, the control of the users and their usage patterns (hence the scale),
    the workload generated, and the flexibility of the data model were gone. Typical
    examples of these web applications were global e-commerce websites, social media
    sites, video community websites, and so on. They generated a tremendous amount
    of data in a very short period of time. It should also be noted that the data
    generated by these applications were not only structured, but also semi-structured
    and even unstructured. Since relational databases were the de facto standard at
    that time, developers and architects did not have many alternatives but were forced
    to tweak them to support these web applications, even though they knew that relational
    databases were suboptimal and had many limitations. It became apparent that a
    different kind of enabling technology should be found to break through the challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着互联网的普及和大量在其上运行的Web应用，用户及其使用模式（因此规模）、生成的工作负载和数据模型灵活性都消失了。这些Web应用的典型例子包括全球电子商务网站、社交媒体网站、视频社区网站等。它们在极短的时间内产生了大量数据。还应注意的是，这些应用生成数据不仅结构化，而且半结构化和非结构化。由于当时关系数据库是事实标准，开发者和架构师没有太多选择，只能被迫对其进行调整以支持这些Web应用，尽管他们知道关系数据库不是最优的，并且有许多局限性。很明显，需要找到一种不同类型的使能技术来突破这些挑战。
- en: We are in an era of information explosion, as a result of the ever-increasing
    amount of user-generated data and content on the Web and mobile applications.
    The generated data is not only large in volume and fast in velocity but it is
    also diversified in variety. Such rapidly growing data of different varieties
    is often termed as **Big Data**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正处于信息爆炸的时代，这是由于网络和移动应用中用户生成数据和内容的持续增加。生成数据不仅量大且速度快，而且种类繁多。这种快速增长的、种类多样的数据通常被称为**大数据**。
- en: No one has a clear, formal definition of Big Data. People, however, unanimously
    agree that the most fundamental characteristics of Big Data are related to large
    volume, high velocity, and great variety. Big Data imposes real, new challenges
    to the information systems that have adopted traditional ways of handling data.
    These systems are not designed for web-scale and for being enhanced to do so,
    cost effectively. Due to this, you might find yourself asking whether or not we
    have any alternatives.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人对大数据有一个明确、正式的定义。然而，人们普遍认为，大数据的最基本特征与大量、高速和多样性有关。大数据给采用传统数据处理方式的信息系统带来了真实、新的挑战。这些系统并非为网络规模设计，且为了有效地进行扩展，成本效益并不高。因此，你可能会问自己，我们是否有任何替代方案。
- en: Challenges come with opportunities on the flip side. A new breed of data management
    products was born. The most recent answer to the question in the last paragraph
    is NoSQL.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 机遇与挑战并存。新一代的数据管理产品应运而生。上一段问题的最新答案是NoSQL。
- en: What is NoSQL?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是NoSQL？
- en: The need to tackle the Big Data challenges has led to the emergence of new data
    management technologies and techniques. Such technologies and techniques are rather
    different from the ubiquitous relational database technology that has been used
    for over 40 years. They are collectively known as **NoSQL**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应对大数据挑战的需求导致了新的数据管理技术和技术的出现。这些技术和技术与使用超过40年的普遍关系型数据库技术截然不同。它们统称为**NoSQL**。
- en: NoSQL is an umbrella term for the data stores that are not based on the relational
    data model. It encompasses a great variety of many different database technologies
    and products. As shown in the following figure, The **Data Platforms Landscape
    Map**, there are over 150 different database products that belong to the non-relational
    school as mentioned in [http://nosql-database.org/](http://nosql-database.org/).
    Cassandra is one of the most popular ones. Other popular NoSQL database products
    are, just to name a few, MongoDB, Riak, Redis, Neo4j, so on and so forth.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是一个术语，用于描述不基于关系数据模型的数据存储。它包括许多不同的数据库技术和产品。如图所示，**数据平台景观图**，有超过150种不同的数据库产品属于非关系型学校，如[http://nosql-database.org/](http://nosql-database.org/)中提到的。Cassandra是最受欢迎的之一。其他流行的NoSQL数据库产品，仅举几个例子，包括MongoDB、Riak、Redis、Neo4j等等。
- en: '![What is NoSQL?](img/8884OS_01_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![什么是NoSQL？](img/8884OS_01_01.jpg)'
- en: 'The Data Platforms Landscape Map (Source: 451 Research)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据平台景观图（来源：451 Research）
- en: 'So, what kinds of benefits are provided by NoSQL? When compared to the relational
    database, NoSQL overcomes the weaknesses that the relational data model does not
    address well, which are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，NoSQL提供了哪些好处？与关系型数据库相比，NoSQL克服了关系数据模型处理不佳的弱点，如下所示：
- en: Huge volume of structured, semi-structured, and unstructured data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巨大的结构化、半结构化和非结构化数据量
- en: Flexible data model (schema) that is easy to change
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的数据模型（模式）易于更改
- en: Scalability and performance for web-scale applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络规模应用的扩展性和性能
- en: Lower cost
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本更低
- en: Impedance mismatch between the relational data model and object-oriented programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据模型与面向对象编程之间的阻抗不匹配
- en: Built-in replication
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置复制
- en: Support for agile software development
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持敏捷软件开发
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '**Limitations of NoSQL Databases**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**NoSQL数据库的限制**'
- en: Many NoSQL databases do not support transactions. They use replication extensively
    so that the data in the cluster might be momentarily inconsistent (although it
    is eventually consistent). In addition, the range queries are not available in
    NoSQL databases. Furthermore, a flexible schema might lead to problems with efficient
    searches.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多NoSQL数据库不支持事务。它们广泛使用复制，因此集群中的数据可能会暂时不一致（尽管最终是一致的）。此外，NoSQL数据库中不可用范围查询。此外，灵活的模式可能会导致高效搜索的问题。
- en: The huge volume of structured, semi-structured, and unstructured data was mentioned
    earlier. What I want to dive deeper into here is that different NoSQL databases
    provide different solutions for each of them. The primary factor to be considered
    is the NoSQL database type, which will be introduced in the subsequent section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到了大量结构化、半结构化和非结构化数据。我想深入探讨的是，不同的NoSQL数据库为每种数据提供不同的解决方案。需要考虑的主要因素是NoSQL数据库类型，这将在下一节介绍。
- en: All NoSQL databases provide a flexible data model that is easy to change and
    some might be even schemaless. In a relational database, the relational data model
    is called schema. You need to understand the data to be stored in a relational
    database, design the data model according to the relational database theory, and
    define the schema upfront in the relational database before you can actually store
    data inside it. It is a very structured approach for structured data. It is a
    prescriptive data modeling process. It is absolutely fine if the data model is
    stable, because there are not many changes required. But what if the data model
    keeps changing in the future and you do not know what needs to be changed? You
    cannot prescribe comprehensively in advance. It leads to many inevitable remedies;
    say, data patching for example, to change the schema.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有NoSQL数据库都提供了一种灵活的数据模型，易于更改，其中一些甚至可能是无模式的。在关系型数据库中，关系数据模型被称为模式。在关系型数据库中存储数据之前，您需要理解要存储的数据，根据关系型数据库理论设计数据模型，并在关系型数据库中预先定义模式。这是一种非常结构化的方法，适用于结构化数据。这是一个规定性的数据建模过程。如果数据模型稳定，那就绝对没问题，因为不需要进行很多更改。但如果数据模型在未来不断变化，您不知道需要更改什么？您无法事先全面规定。这会导致许多不可避免的补救措施；比如说，例如，数据修补来更改模式。
- en: Conversely, in NoSQL databases, you need not prescribe comprehensively. You
    only need to describe what is to be stored. You are not bound by the relational
    database theory. You are allowed to change the data model whenever necessary.
    The data model is schemaless and is a living object. It evolves as life goes on.
    It is a descriptive data modeling process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在NoSQL数据库中，您不需要全面规定。您只需要描述要存储的内容。您不受关系型数据库理论的约束。您可以在必要时随时更改数据模型。数据模型是无模式的，是一个活生生的对象。它随着时间的推移而演变。这是一个描述性的数据建模过程。
- en: Scalability and performance for web-scale applications refer to the ability
    of the system to be scaled, preferably horizontally, to support web-scale workloads
    without considerably deteriorating system performance. Relational databases can
    only be scaled out to form a cluster consisting of a very small number of nodes.
    It implies the rather low ceiling imposed on these web-scale applications using
    relational databases. In addition, changing the schema in a clustered relational
    database is a big task of high complexity. The processing power required to do
    this is so significant that the system performance cannot be unaffected. Most
    NoSQL databases were created to serve web-scale applications. They natively support
    horizontal scaling without very little degrade on the performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web规模的应用程序，可扩展性和性能指的是系统可扩展的能力，最好是水平扩展，以支持Web规模的工作负载，而不会显著降低系统性能。关系型数据库只能扩展到由非常少数节点组成的集群。这意味着使用关系型数据库构建的这些Web规模应用程序的上限相当低。此外，在集群关系型数据库中更改模式是一项复杂度高的重大任务。完成这项任务所需的处理能力如此之大，以至于系统性能不可避免地受到影响。大多数NoSQL数据库都是为了服务Web规模应用程序而创建的。它们原生支持水平扩展，而性能下降非常小。
- en: Now let us talk about money. Traditionally, most high-end relational databases
    are commercial products that demand their users to pay huge software license fees.
    Besides, to run these high-end relational databases, the underlying hardware servers
    are usually high-end as well. The result is that the hardware and software costs
    of running a powerful relational database are exceptionally large. In contrast,
    NoSQL databases are open source and community-driven in a majority, meaning that
    you need to pay the software license cost, which is an order of magnitude less
    than other databases. NoSQL databases are able to run on commodity machines that
    will lead to a possible churn, or crashes. Therefore, the machines are usually
    configured to be a cluster. High-end hardware servers are not needed and so the
    hardware cost is tremendously reduced. It should be noted that when NoSQL databases
    are put into production, some cost of the support is still required but it is
    definitely much less when compared to that of commercial products.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈金钱。传统上，大多数高端关系数据库是商业产品，要求用户支付巨额软件许可费。此外，要运行这些高端关系数据库，底层硬件服务器通常也是高端的。结果是，运行强大关系数据库的软硬件成本特别高。相比之下，大多数NoSQL数据库是开源的，由社区驱动，这意味着你需要支付的软件许可费用比其他数据库低一个数量级。NoSQL数据库能够在通用机器上运行，这可能导致可能的故障或崩溃。因此，机器通常配置为集群。高端硬件服务器不需要，因此硬件成本大幅降低。需要注意的是，当NoSQL数据库投入生产时，仍需要一些支持成本，但与商业产品相比，这肯定要少得多。
- en: There exists a generation gap between the relational data model and object-oriented
    programming. The relational data model was the product of 1970s, whereas object-oriented
    programming became very popular in 1990s. The root cause, known as impedance mismatch,
    is an inherent difficulty of representing a record or a table in a relational
    data model with the object-oriented model. Although there are resolutions for
    this difficulty, most application developers still feel very frustrated to bring
    the two together.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据模型和面向对象编程之间存在一代沟。关系数据模型是20世纪70年代的产品，而面向对象编程在20世纪90年代变得非常流行。被称为阻抗不匹配的根本原因，是关系数据模型在面向对象模型中表达记录或表的一个固有困难。尽管有解决这个困难的方法，但大多数应用开发者仍然感到非常沮丧，因为将两者结合起来。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Impedance Mismatch**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**阻抗不匹配**'
- en: Impedance mismatch is the difference between the relational model and the in-memory
    data structures that are usually encountered in object-oriented programming languages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 阻抗不匹配是关系模型和通常在面向对象编程语言中遇到的内存数据结构之间的差异。
- en: Built-in replication is a feature that most NoSQL databases provide to support
    high availability in a cluster of many nodes. It is usually automatic and transparent
    to the application developers. Such a feature is also available in relational
    databases, but the database administrators must struggle to configure, manage,
    and operate it by themselves.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内置复制是大多数NoSQL数据库提供的一项功能，用于支持多个节点集群中的高可用性。这通常是自动的，对应用开发者来说是透明的。这种功能在关系数据库中也是可用的，但数据库管理员必须自己努力配置、管理和操作它。
- en: Finally, relational databases do not support agile software development very
    well. Agile software development is iterative by nature. The software architecture
    and data model emerge and evolve as the project proceeds in order to deliver the
    product incrementally. Hence, it is conceivable that the need of changing the
    data model to meet the new requirements is inevitably frequent. Relational databases
    are structured and do not like changes. NoSQL can provide such flexibility for
    agile software development teams by virtue of its schemaless characteristic. Even
    better, NoSQL databases usually allow the changes to be implemented in real time
    without any downtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，关系数据库并不很好地支持敏捷软件开发。敏捷软件开发本质上是迭代的。软件架构和数据模型随着项目的进行而出现和演变，以便逐步交付产品。因此，可以想见，为了满足新的需求而改变数据模型的需求不可避免地很频繁。关系数据库是结构化的，不喜欢变化。NoSQL可以通过其无模式特性为敏捷软件开发团队提供这种灵活性。更好的是，NoSQL数据库通常允许实时实施更改，而无需停机。 '
- en: NoSQL Database types
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据库类型
- en: 'Now you know the benefits of NoSQL databases, but the products that fall under
    the NoSQL databases umbrella are quite varied. How can you select the right one
    for yourself among so many NoSQL databases? The selection criteria of which NoSQL
    database fits your needs is really dependent on the use cases at hand. The most
    important factor to consider here is the NoSQL database type, which can be subdivided
    into four main categories:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了NoSQL数据库的好处，但属于NoSQL数据库范畴的产品相当多样。如何在众多NoSQL数据库中为自己选择合适的数据库？选择哪种NoSQL数据库适合你的需求实际上取决于手头的用例。这里要考虑的最重要因素是NoSQL数据库的类型，它可以细分为四大主要类别：
- en: Key/value pair store
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值对存储
- en: Column-family store
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列族存储
- en: Document-based repository
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于文档的存储库
- en: Graph database
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: The NoSQL database type dictates the data model that you can use. It is beneficial
    to understand each of them deeper.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库类型决定了你可以使用的数据模型。深入了解每一个都是有益的。
- en: Key/value pair store
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键值对存储
- en: Key/value pair is the simplest NoSQL database type. Key/value store is similar
    to the concept of Windows registry, or in Java or C#, a map, a hash, a key/value
    pair. Each data item is represented as an attribute name, also a key, together
    with its value. It is also the basic unit stored in the database. Examples of
    the NoSQL databases of key/value pair type are **Amazon Dynamo**, **Berkeley DB**,
    **Voldemort** and **Riak**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对是最简单的NoSQL数据库类型。键值存储类似于Windows注册表的概念，或者在Java或C#中，是一个映射、一个哈希、一个键值对。每个数据项都表示为一个属性名称，也是一个键，以及它的值。它也是数据库中存储的基本单元。键值对类型的NoSQL数据库的例子有**Amazon
    Dynamo**、**Berkeley DB**、**Voldemort**和**Riak**。
- en: Internally, key/value pairs are stored in a data structure called **hashmap**.
    Hashmap is popular because it provides very good performance on accessing data.
    The key of a key/value pair is unique and can be searched very quickly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，键值对存储在一个称为**哈希表**的数据结构中。哈希表之所以受欢迎，是因为它在访问数据方面提供了非常好的性能。键值对的键是唯一的，可以非常快速地进行搜索。
- en: Key/value pair can be stored and distributed in the disk storage as well as
    in memory. When used in memory, it can be used as a cache, which depends on the
    caching algorithm, can considerably reduce disk I/O and hence boost up the performance
    significantly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对可以存储和分布在磁盘存储以及内存中。当在内存中使用时，它可以作为缓存使用，这取决于缓存算法，可以显著减少磁盘I/O，从而显著提高性能。
- en: On the flip side, key/value pair has some drawbacks, such as lack of support
    of range queries, no way to operate on multiple keys simultaneously, and possible
    issues with load balancing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，键值对也有一些缺点，例如不支持范围查询，无法同时操作多个键，以及可能存在的负载均衡问题。
- en: Column-family store
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列族存储
- en: A column in this context is not equal to a column in a relational table. In
    the NoSQL world, a column is a data structure that contains a key, value, and
    timestamp. Thus, it can be regarded as a combination of key/value pair and a timestamp.
    Examples are **Google BigTable**, **Apache Cassandra**, and **Apache HBase**.
    They provide optimized performance for queries over very large datasets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，列不等于关系表中的列。在NoSQL世界中，列是一个包含键、值和时间的结构。因此，它可以被视为键值对和时间戳的组合。例子有**Google
    BigTable**、**Apache Cassandra**和**Apache HBase**。它们为查询非常大的数据集提供了优化的性能。
- en: Column-family store is basically a multi-dimensional map. It stores columns
    of data together as a row, which is associated with a row key. This contrasts
    with rows of data in a relational database. Column-family store does not need
    to store null columns, as in the case of a relational database and so it consumes
    much less disk space. Moreover, columns are not bound by a rigid schema and you
    are not required to define the schema upfront.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列族存储基本上是一个多维映射。它将数据列作为一个行存储，与一个行键相关联。这与关系数据库中的数据行形成对比。列族存储不需要存储null列，就像关系数据库中的情况一样，因此它消耗的磁盘空间要少得多。此外，列不受严格模式的约束，你也不需要预先定义模式。
- en: The key component of a column is usually called the primary key or the row key.
    Columns are stored in a sorted manner by the row key. All the data belonging to
    a row key is stored together. As such, read and write operations of the data can
    be confined to a local node, avoiding unnecessary inter-node network traffic in
    a cluster. This mechanism makes the data lookup and retrieval extremely efficient.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列的关键组件通常被称为主键或行键。列按行键排序存储。属于行键的所有数据都存储在一起。因此，数据的读写操作可以限制在本地节点上，避免在集群中产生不必要的节点间网络流量。这种机制使得数据的查找和检索非常高效。
- en: Obviously, a column-family store is not the best solution for systems that require
    ACID transactions and it lacks the support for aggregate queries provided by relational
    databases such as `SUM()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，列族存储对于需要 ACID 事务的系统来说不是最佳解决方案，它缺乏关系数据库（如 `SUM()`）提供的聚合查询支持。
- en: Document-based repository
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文档的存储库
- en: Document-based repository is designed for documents or semi-structured data.
    The basic unit of a document-based repository associates each key, a primary identifier,
    with a complex data structure called a document. A document can contain many different
    key-value pairs, or key-array pairs, or even nested documents. Therefore, document-based
    repository does not adhere to a schema. Examples are **MongoDB** and **CouchDB**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文档的存储库是为文档或半结构化数据设计的。基于文档的存储库的基本单元将每个键（一个主标识符）与一个称为文档的复杂数据结构关联起来。文档可以包含许多不同的键/值对、键/数组对，甚至嵌套文档。因此，基于文档的存储库不遵循模式。例如
    **MongoDB** 和 **CouchDB**。
- en: In practice, a document is usually a loosely structured set of key/value pairs
    in the form of **JavaScript Object Notation** (**JSON**). Document-based repository
    manages a document as a whole and avoids breaking up a document into fragments
    of key/value pairs. It also allows document properties to be associated with a
    document.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，文档通常是以 **JavaScript 对象表示法**（**JSON**）形式存在的松散结构化键/值对集合。基于文档的存储库将文档作为一个整体来管理，避免将文档拆分成键/值对的片段。它还允许将文档属性与文档关联起来。
- en: As a document database does not adhere to a fixed schema, the search performance
    is not guaranteed. There are generally two approaches to query a document database.
    The first is to use materialized views (such as CouchDB) that are prepared in
    advance. The second is to use indexes defined on the document values (such as
    MongoDB) that behave in the same way as a relational database index.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为文档数据库不遵循固定模式，搜索性能无法保证。查询文档数据库通常有两种方法。第一种是使用预先准备的材料化视图（例如 CouchDB）。第二种是使用定义在文档值上的索引（例如
    MongoDB），其行为与关系数据库索引相同。
- en: Graph database
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图数据库
- en: Graph databases are designed for storing information about networks, such as
    a social network. A graph is used to represent the highly connected network that
    is composed of nodes and their relationships. The nodes and relationships can
    have individual properties. The prominent graph databases include **Neo4J** and
    **FlockDB**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库是为存储有关网络的信息而设计的，例如社交网络。图用于表示由节点及其关系组成的高度连接的网络。节点和关系可以具有单独的属性。突出的图数据库包括 **Neo4J**
    和 **FlockDB**。
- en: Owing to the unique characteristics of a graph, graph databases commonly provide
    APIs for rapid traversal of graphs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图具有独特的特性，图数据库通常提供用于快速遍历图的 API。
- en: Graph databases are particularly difficult to be scaled out with sharding because
    traversing a graph of the nodes on different machine does not provide a very good
    performance. It is also not a straightforward operation to update all or a subset
    of the nodes at the same time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库在分片扩展方面尤其困难，因为跨不同机器上的节点图遍历并不提供很好的性能。同时更新所有或部分节点也不是一个简单的操作。
- en: So far, you have grasped the fundamentals of the NoSQL family. Since this book
    concentrates on Apache Cassandra and its data model, you need to know what Cassandra
    is and have a basic understanding of what its architecture is, so that you can
    select and leverage the best available options when you are designing your NoSQL
    data model and application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经掌握了 NoSQL 家族的 fundamentals。由于这本书专注于 Apache Cassandra 及其数据模型，你需要了解 Cassandra
    是什么，并对其架构有一个基本的了解，这样你就可以在设计 NoSQL 数据模型和应用时选择和利用最佳选项。
- en: What is Cassandra?
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Cassandra？
- en: '**Cassandra** can be simply described in a single phrase: a massively scalable,
    highly available open source NoSQL database that is based on peer-to-peer architecture.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cassandra** 可以简单地用一句话来描述：一个基于对等架构的、大规模可扩展、高度可用的开源 NoSQL 数据库。'
- en: Cassandra is now 5 years old. It is an active open source project in the Apache
    Software Foundation and therefore it is known as Apache Cassandra as well. Cassandra
    can manage huge volume of structured, semi-structured, and unstructured data in
    a large distributed cluster across multiple data centers. It provides linear scalability,
    high performance, fault tolerance, and supports a very flexible data model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 现在已经 5 岁了。它是 Apache 软件基金会中的一个活跃的开源项目，因此也被称为 Apache Cassandra。Cassandra
    可以在跨多个数据中心的庞大分布式集群中管理大量结构化、半结构化和非结构化数据。它提供线性可扩展性、高性能、容错性和非常灵活的数据模型。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Netflix and Cassandra**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Netflix 和 Cassandra**'
- en: One very famous case study of Cassandra is Netflix's move to replace their Oracle
    SQL database to Cassandra running on cloud. As of March 2013, Netflix's Cassandra
    deployment consists of 50 clusters with over 750 nodes. For more information,
    please visit the case study at [http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf](http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常著名的 Cassandra 研究案例是 Netflix 将其 Oracle SQL 数据库替换为在云上运行的 Cassandra。截至 2013
    年 3 月，Netflix 的 Cassandra 部署由 50 个集群和超过 750 个节点组成。更多信息，请访问案例研究[http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf](http://www.datastax.com/wp-content/uploads/2011/09/CS-Netflix.pdf)。
- en: In fact, many of the benefits that Cassandra provides are inherited from its
    two best-of-breed NoSQL parents, Google BigTable and Amazon Dynamo. Before we
    go into the details of Cassandra's architecture, let us walk through each of them
    first.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Cassandra 提供的许多好处都继承自其两个最优秀的 NoSQL 祖先，Google BigTable 和 Amazon Dynamo。在我们深入探讨
    Cassandra 的架构细节之前，让我们先了解一下它们各自的特点。
- en: Google BigTable
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google BigTable
- en: Google BigTable is Google's core technology, particularly addressing data persistence
    and management on web-scale. It runs the data stores for many Google applications,
    such as Gmail, YouTube, and Google Analytics. It was designed to be a web-scale
    data store without sacrificing real-time responses. It has superb read and write
    performance, linear scalability, and continuous availability.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Google BigTable 是 Google 的核心技术，特别是针对 Web 规模的数据持久性和管理。它运行着许多 Google 应用程序的数据存储，例如
    Gmail、YouTube 和 Google Analytics。它被设计为不牺牲实时响应的 Web 规模数据存储。它具有卓越的读写性能、线性可扩展性和持续可用性。
- en: Google BigTable is a sparse, distributed, persistent, multidimensional sorted
    map. The map is indexed by a row key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Google BigTable 是一个稀疏的、分布式的、持久的、多维排序映射。映射由行键索引。
- en: Despite the many benefits Google BigTable provides, the underlying design concept
    is really simple and elegant. It uses a persistent commitlog for every data write
    request that it receives and then writes the data into a memory store (acting
    as a cache). At regular intervals or when triggered by a particular event, the
    memory store is flushed to persistent disk storage by a background process. This
    persistent disk storage is called **Sorted String Table**, or **SSTable**. The
    SSTable is immutable meaning that once it has been written to a disk, it will
    never be changed again. The word *sorted* means that the data inside the SSTable
    is indexed and sorted and hence the data can be found very quickly. Since the
    write operation is log-based and memory-based, it does not involve any read operation,
    and therefore the write operation can be extremely fast. If a failure happens,
    the commitlog can be used to replay the sequence of the write operations to merge
    the data that persists in the SSTables.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Google BigTable 提供了许多好处，但其底层设计概念实际上非常简单且优雅。它为接收到的每个数据写入请求使用持久的提交日志，然后将数据写入内存存储（充当缓存）。在固定时间间隔或由特定事件触发时，内存存储通过后台进程被刷新到持久磁盘存储。这种持久磁盘存储被称为
    **排序字符串表** 或 **SSTable**。SSTable 是不可变的，这意味着一旦写入磁盘，它将永远不会再次更改。单词 *sorted* 意味着 SSTable
    内部的数据是索引和排序的，因此数据可以非常快速地找到。由于写入操作基于日志和内存，它不涉及任何读操作，因此写入操作可以非常快。如果发生故障，提交日志可以用来重放写入操作的序列，以合并保存在
    SSTables 中的数据。
- en: Read operation is also very efficient by looking up the data in the memory store
    and the indexed SSTables, which are then merged to return the data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在内存存储和索引的 SSTables 中查找数据，读操作也非常高效，这些数据随后被合并以返回。
- en: All the above-mentioned Google BigTable brilliances do come with a price. Because
    Google BigTable is distributed in nature, it is constrained by the famous *CAP
    theorem*, stating the relationship among the three characteristics of a distributed
    system, namely Consistency, Availability, and Partition-tolerance. In a nutshell,
    Google BigTable prefers Consistency and Partition-tolerance to Availability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的Google BigTable的卓越之处确实是有代价的。因为Google BigTable本质上是分布式的，它受到著名的*CAP定理*的限制，该定理阐述了分布式系统三个特性之间的关系，即一致性、可用性和分区容错性。简而言之，Google
    BigTable更倾向于一致性和分区容错性，而不是可用性。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The CAP theorem**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**CAP定理**'
- en: 'CAP is an acronym of the three characteristics of a distributed system: Consistency,
    Availability, and Partition-tolerance. Consistency means that all the nodes in
    a cluster see the same data at any point in time. Availability means that every
    request that is received by a non-failing node in the cluster must result in a
    response. Partition-tolerance means that a node can still function when communication
    with other groups of nodes is lost. Originating from Eric A. Brewer, the theorem
    states that in a distributed system, only two out of the three characteristics
    can be attained at the most.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CAP是分布式系统三个特性的缩写：一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）。一致性意味着集群中的所有节点在任何时间点都能看到相同的数据。可用性意味着集群中每个非失败节点接收到的每个请求都必须得到响应。分区容错性意味着当与其他节点组的通信丢失时，节点仍然可以继续工作。这个定理起源于埃里克·A·布鲁尔（Eric
    A. Brewer），它表明在一个分布式系统中，最多只能实现这三个特性中的两个。
- en: Google BigTable has trouble with Availability while keeping Consistency across
    partitioned nodes when failures happen in the cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当集群发生故障时，Google BigTable在保持分区节点的一致性时会有可用性问题。
- en: Amazon Dynamo
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Amazon Dynamo
- en: Amazon Dynamo is a proprietary key-value store developed by Amazon. It is designed
    for high performance, high availability, and continuous growth of data of huge
    volume. It is the distributed, highly available, fault-tolerant skeleton for Amazon.
    Dynamo is a peer-to-peer design meaning that each node is a peer and no one is
    a master who manages the data.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Dynamo是由Amazon开发的专有键值存储。它旨在提供高性能、高可用性和海量数据的持续增长。它是Amazon的分布式、高可用性和容错骨架。Dynamo是一种对等设计，意味着每个节点都是一个对等节点，没有谁是管理数据的权威节点。
- en: Dynamo uses data replication and auto-sharding across multiple nodes of the
    cluster. Imagine that a Dynamo cluster consists of many nodes. Every write operation
    in a node is replicated to two other nodes. Thus, there are three copies of data
    inside the cluster. If one of the nodes fails for whatever reason, there are still
    two copies of data that can be retrieved. Auto-sharding ensures that the data
    is partitioned across the cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamo在集群的多个节点上使用数据复制和自动分片。想象一下，一个Dynamo集群由许多节点组成。节点上的每个写操作都会复制到另外两个节点。因此，集群内部有三份数据副本。如果其中一个节点因任何原因失败，仍然可以检索到两份数据副本。自动分片确保数据在集群中分区。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Auto-sharding**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动分片**'
- en: NoSQL database products usually support auto-sharding so that they can natively
    and automatically distribute data across the database cluster. Data and workload
    are automatically balanced across the nodes in the cluster. When a node fails
    for whatever reason, the failed node can be quickly and transparently replaced
    without service interruptions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库产品通常支持自动分片，以便它们可以原生地自动将数据分布到数据库集群中。数据和负载会在集群中的节点之间自动平衡。当某个节点因任何原因失败时，可以快速且透明地替换失败的节点，而不会中断服务。
- en: Dynamo focuses primarily on the high availability of a cluster and the most
    important idea is eventual consistency. While considering the CAP Theorem, Dynamo
    prefers Partition-tolerance and Availability to Consistency. Dynamo introduces
    a mechanism called **Eventual Consistency** to support consistency. Temporary
    inconsistency might occur in the cluster at a point in time, but eventually all
    the nodes will receive the latest consistent updates. Given a sufficiently long
    period of time without further changes, all the updates can be expected to propagate
    throughout the cluster and the replicas on all the nodes will be consistent eventually.
    In real life, an update takes only a fraction of a second to become eventually
    consistent. In other words, it is a trade-off between consistency and latency.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamo主要关注集群的高可用性，最重要的思想是最终一致性。在考虑CAP定理时，Dynamo更倾向于分区容错和可用性而非一致性。Dynamo引入了一种称为**最终一致性**的机制来支持一致性。在某个时间点，集群中可能会出现暂时的不一致性，但最终所有节点都将接收到最新的一致更新。在一段足够长的时间没有进一步变化的情况下，所有更新都可以预期在整个集群中传播，并且所有节点的副本最终都将是一致的。在现实生活中，更新只需要极短的时间就能达到最终一致性。换句话说，这是在一致性和延迟之间的一种权衡。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Eventual consistency**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终一致性**'
- en: Eventual consistency is not inconsistency. It is a weaker form of consistency
    than the typical Atomic-Consistency-Isolation-Durability (ACID) type consistency
    is found in the relational databases. It implies that there can be short intervals
    of inconsistency among the replicated nodes during which the data gets updated
    among these nodes. In other words, the replicas are updated asynchronously.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性不是不一致性。它是一种比关系数据库中典型的原子性一致性隔离持久性（ACID）一致性更弱的一致性形式。它意味着在复制节点之间更新数据时，可能会存在短暂的不一致性间隔。换句话说，副本是异步更新的。
- en: Cassandra's high-level architecture
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cassandra的高级架构
- en: Cassandra runs on a peer-to-peer architecture which means that all nodes in
    the cluster have equal responsibilities except that some of them are seed nodes
    for other non-seed nodes to obtain information about the cluster during startup.
    Each node holds a partition of the database. Cassandra provides automatic data
    distribution and replication across all nodes in the cluster. Parameters are provided
    to customize the distribution and replication behaviors. Once configured, these
    operations are processed in the background and are fully transparent to the application
    developers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra运行在点对点架构上，这意味着集群中的所有节点都有平等的责任，除了其中一些节点是种子节点，用于在启动时让其他非种子节点获取有关集群的信息。每个节点持有数据库的一部分。Cassandra提供了在集群中所有节点上的自动数据分布和复制。提供了参数来自定义分布和复制行为。一旦配置完成，这些操作将在后台处理，并且对应用程序开发者是完全透明的。
- en: Cassandra is a column-family store and provides great schemaless flexibility
    to application developers. It is designed to manage huge volume of data in a large
    cluster without a single point of failure. As multiple copies of the same data
    (replicas) are replicated in the cluster, whenever one node fails for whatever
    reason, the other replicas are still available. Replication can be configured
    to meet the different physical cluster settings, including data center and rack
    locations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra是一个列族存储，为应用程序开发者提供了极大的无模式灵活性。它旨在管理大型集群中的大量数据，而不存在单点故障。由于在集群中复制了相同数据的多个副本，因此每当一个节点因任何原因失败时，其他副本仍然可用。复制可以配置以满足不同的物理集群设置，包括数据中心和机架位置。
- en: Any node in the cluster can accept read or write requests from a client. The
    node that is connected to a client with a request serves as the coordinator of
    that particular request. The coordinator determines which nodes are responsible
    for holding the data for the request and acts as a proxy between the client and
    the nodes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的任何节点都可以接受来自客户端的读或写请求。连接到请求客户端的节点充当该特定请求的协调器。协调器确定哪些节点负责持有请求的数据，并充当客户端和节点之间的代理。
- en: Cassandra borrows the commitlog mechanism from Google BigTable to ensure data
    durability. Whenever a write data request is received by a node, it is written
    into the commitlog. The data that is being updated is then written to a memory
    structure, known as memtable. When the memtable is full, the data inside the memtable
    is flushed to a disk storage structure, SSTable. The writes are automatically
    partitioned by the row key and replicated to the other nodes holding the same
    partition.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra借鉴了Google BigTable的commitlog机制以确保数据持久性。每当节点接收到写数据请求时，它会被写入commitlog。正在更新的数据随后会被写入一个称为memtable的内存结构。当memtable满了之后，memtable中的数据会被刷新到一个磁盘存储结构，即SSTable。写操作会自动根据行键进行分区，并复制到持有相同分区的其他节点。
- en: Cassandra provides linear scalability, which means that the performance and
    capacity of the cluster is proportional to the number of nodes in it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra提供线性可扩展性，这意味着集群的性能和容量与其中的节点数量成正比。
- en: Partitioning
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区
- en: The ability to scale horizontally and incrementally is a Cassandra key design
    feature. To achieve this, Cassandra is required to dynamically partition the data
    over the set of nodes in the cluster.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 横向扩展和增量扩展的能力是Cassandra的关键设计特性。为了实现这一点，Cassandra需要动态地将数据分区到集群中的节点集合中。
- en: A cluster is the outermost structure which is composed of nodes in Cassandra.
    It is also a container of keyspace. A keyspace in Cassandra is analogous to a
    schema in a relational database. Each Cassandra cluster has a system keyspace
    to keep system-wide metadata. It contains the replication settings which controls
    how the data is distributed and replicated in a cluster. Typically, one keyspace
    is assigned to one cluster but one cluster might contain more than one keyspace.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 集群是Cassandra中最外层的结构，由节点组成。它也是keyspace的容器。在Cassandra中，keyspace类似于关系数据库中的模式。每个Cassandra集群都有一个系统keyspace来存储系统级元数据。它包含复制设置，用于控制数据在集群中的分布和复制方式。通常，一个keyspace分配给一个集群，但一个集群可能包含多个keyspace。
- en: The smallest cluster in the theory contains a single node and a cluster of three
    or more nodes, which is much more practical. Each node holds a replica for the
    different range of data in partitions, and exchanges information across the cluster
    every second.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上最小的集群包含一个节点和三个或更多节点的集群，这更加实用。每个节点持有不同分区范围内数据的副本，并且每秒钟在集群中交换信息。
- en: 'A client issues read or write requests to any node. The node that receives
    the request becomes a coordinator that acts as a proxy of the client to do the
    things as explained previously. Data is distributed across the cluster and the
    node addressing mechanism is called consistent hashing. Therefore, a cluster can
    be viewed as a ring of hash as each node in the cluster or the ring is assigned
    a single unique token so that each node is responsible for the data in the range
    from its assigned token to that of the previous node. For example, in the following
    figure, a cluster contains four nodes with unique tokens:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端向任何节点发出读取或写入请求。接收请求的节点成为协调器，充当客户端的代理执行之前所述的操作。数据在集群中分布，节点寻址机制称为一致性哈希。因此，集群可以被视为一个哈希环，因为集群中的每个节点或环都被分配一个唯一的令牌，以便每个节点负责从其分配的令牌到前一个节点令牌范围内的数据。例如，在下面的图中，一个集群包含四个具有唯一令牌的节点：
- en: '![Partitioning](img/8884OS_01_02.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![分区](img/8884OS_01_02.jpg)'
- en: Cassandra's consistent hashing
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra的一致性哈希
- en: Before Version 1.2, tokens were calculated and assigned manually and from Version
    1.2 onwards, tokens can be generated automatically. Each row has a row key used
    by a partitioner to calculate its hash value. The hash value determines the node
    which stores the first replica of the row. The partitioner is just a hash function
    that is used for calculating a row key's hash value and it also affects how the
    data is distributed or balanced in the cluster. When a write occurs, the first
    replica of the row is always placed in the node with the key range of the token.
    For example, the hash value of a row key `ORACLE` is `6DE7` that falls in the
    range of 4,000 and 8,000 and so the row goes to the bottom node first. All the
    remaining replicas are distributed based on the replication strategy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.2之前，令牌是手动计算和分配的，从版本1.2开始，令牌可以自动生成。每一行都有一个分区器使用的行键，用于计算其哈希值。哈希值决定了存储行第一个副本的节点。分区器只是一个用于计算行键哈希值的哈希函数，它还影响数据在集群中的分布或平衡方式。当发生写入操作时，行的第一个副本总是放置在具有令牌键范围的节点上。例如，行键`ORACLE`的哈希值为`6DE7`，位于4,000到8,000的范围内，因此行首先被放置在底部节点。所有剩余的副本都是根据复制策略进行分布的。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Consistent hashing**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性哈希**'
- en: Consistent hashing allows each node in the cluster to independently determine
    which nodes are replicas for a given row key. It just involves hashing the row
    key, and then compares that hash value to the token of each node in the cluster.
    If the hash value falls in between a node's token, and the token of the previous
    node in the ring (tokens are assigned to nodes in a clockwise direction), that
    node is the replica for that row.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性哈希允许集群中的每个节点独立确定给定行键的副本节点。它只涉及对行键进行哈希处理，然后比较该哈希值与集群中每个节点的令牌。如果哈希值落在节点令牌之间，以及环中前一个节点的令牌（令牌按顺时针方向分配给节点）之间，那么该节点就是该行键的副本节点。
- en: Replication
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制
- en: Cassandra uses replication to attain high availability and data durability.
    Each data is replicated at a number of nodes that are configured by a parameter
    called replication factor. The coordinator commands the replication of the data
    within its range. It replicates the data to the other nodes in the ring. Cassandra
    provides the client with various configurable options to see how the data is to
    be replicated, which is called replication strategy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra使用复制来实现高可用性和数据持久性。每个数据都在配置有称为复制因子的参数的多个节点上进行复制。协调器在其范围内指挥数据的复制。它将数据复制到环中的其他节点。Cassandra为客户端提供了各种可配置选项，以查看数据如何进行复制，这被称为复制策略。
- en: Replication strategy is the method of determining which nodes the replicas are
    placed in. It provides many options, such as rack-aware, rack-unaware, network-topology-aware,
    so on and so forth.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 复制策略是确定副本放置在哪些节点上的方法。它提供了许多选项，例如机架感知、非机架感知、网络拓扑感知等。
- en: Snitch
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snitch（侦听器）
- en: 'A snitch determines which data centers and racks to go for in order to make
    Cassandra aware of the network topology for routing the requests efficiently.
    It affects how the replicas can be distributed while considering the physical
    setting of the data centers and racks. The node location can be determined by
    the rack and data center with reference to the node''s IP address. An example
    of a cluster across two data centers is shown in the following figure, in order
    to illustrate the relationship among replication factor, replication strategy,
    and snitch in a better way:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Snitch（侦听器）确定访问哪些数据中心和机架，以便使Cassandra能够了解网络拓扑，从而有效地路由请求。它影响在考虑数据中心的物理设置和机架的情况下，副本的分布方式。节点位置可以通过机架和数据中心以及节点的IP地址来确定。以下图示了一个跨两个数据中心的集群示例，以便更好地说明复制因子、复制策略和侦听器之间的关系：
- en: '![Snitch](img/8884OS_01_03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Snitch](img/8884OS_01_03.jpg)'
- en: Multiple data center cluster
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 多数据中心集群
- en: Each data center has two racks and each rack contains two nodes respectively.
    The replication factor per data center is set to three here. With two data centers,
    there are six replicas in total. The node location that addresses the data center
    and rack locations are subject to the convention of IP address assignment of the
    nodes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据中心有两个机架，每个机架分别包含两个节点。这里每个数据中心的复制因子设置为三。有两个数据中心，总共有六个副本。节点位置，即数据中心和机架位置，遵循节点IP地址分配的惯例。
- en: Seed node
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 种子节点
- en: Some nodes in a Cassandra cluster are designated as seed nodes for the others.
    They are configured to be the first nodes to start in the cluster. They also facilitate
    the bootstrapping process for the new nodes joining the cluster. When a new node
    comes online, it will talk to the seed node to obtain information about the other
    nodes in the cluster. The talking mechanism is called **gossip**. If a cluster
    is across multiple data centers, the best practice is to have more than one seed
    node per data center.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Cassandra集群中，一些节点被指定为其他节点的种子节点。它们被配置为集群中首先启动的节点。它们还简化了新节点加入集群的初始化过程。当一个新节点上线时，它将与种子节点通信以获取集群中其他节点的信息。这种通信机制被称为**八卦**。如果一个集群跨越多个数据中心，最佳实践是在每个数据中心拥有不止一个种子节点。
- en: Gossip and Failure detection
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 八卦和故障检测
- en: Nodes need to communicate periodically (every second) to exchange state information
    (for example, dead or alive), about themselves and about other nodes they know
    about. Cassandra uses a gossip communication protocol to disseminate the state
    information, which is also known as epidemic protocol. It is a peer-to-peer communication
    protocol that provides a decentralized, periodic, and an automatic way for the
    nodes in the cluster to exchange the state information about themselves, and about
    other nodes they know about with up to three other nodes. Therefore, all nodes
    can quickly learn about all the other nodes in the cluster. Gossip information
    is also persisted locally by each node to allow fast restart.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 节点需要定期（每秒）通信以交换状态信息（例如，死亡或存活），关于它们自己和它们所知的其他节点。Cassandra使用八卦通信协议来传播状态信息，也称为流行病协议。它是一种对等通信协议，为集群中的节点提供了一个去中心化、定期和自动的方式，以与其他最多三个节点交换它们自己和它们所知的其他节点的状态信息。因此，所有节点都可以快速了解集群中的所有其他节点。八卦信息也被每个节点本地持久化，以允许快速重启。
- en: Cassandra uses a very efficient algorithm, called *Phi Accrual Failure Detection
    Algorithm*, to detect the failure of a node. The idea of the algorithm is that
    the failure detection is not represented by a Boolean value stating whether a
    node is up or down. Instead, the algorithm outputs a value on the continuous suspicion
    level between dead and alive, on how confident it is that the node has failed.
    In a distributed environment, false negatives might happen due to the network
    performance, fluctuating workload, and other conditions. The algorithm takes all
    these factors into account and provides a probabilistic value. If a node has failed,
    the other nodes periodically try to gossip with it to see if it comes back online.
    A node can then determine locally from the gossip state and its history and adjust
    routes accordingly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra使用一个非常高效的算法，称为*Phi累积故障检测算法*，来检测节点的故障。该算法的思路是，故障检测不是通过一个表示节点是否上线的布尔值来表示。相反，算法输出一个值，表示在死亡和存活之间的连续怀疑水平，以及它对节点已失败的信心程度。在分布式环境中，由于网络性能、波动的工作负载和其他条件，可能会发生假阴性。该算法考虑了所有这些因素，并提供了概率值。如果一个节点已失败，其他节点将定期尝试与它进行八卦，以查看它是否重新上线。节点可以据此从八卦状态及其历史记录中本地确定，并相应地调整路由。
- en: Write path
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入路径
- en: 'The following figure depicts the components and their sequence of executions
    that form a write path:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了构成写入路径的组件及其执行顺序：
- en: '![Write path](img/8884OS_01_04.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![写入路径](img/8884OS_01_04.jpg)'
- en: Cassandra write path
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra写入路径
- en: When a write occurs, the data will be immediately appended to the commitlog
    on the disk to ensure write durability. Then Cassandra stores the data in memtable,
    an in-memory store of hot and fresh data. When memtable is full, the memtable
    data will be flushed to a disk file, called SSTable, using sequential I/O and
    so random I/O is avoided. This is the reason why the write performance is so high.
    The commitlog is purged after the flush.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生写入操作时，数据将立即追加到磁盘上的commitlog以确保写入持久性。然后Cassandra将数据存储在memtable中，这是一个热数据和新鲜数据的内存存储。当memtable满时，memtable数据将通过顺序I/O刷新到称为SSTable的磁盘文件中，从而避免了随机I/O。这就是为什么写入性能如此之高的原因。在刷新后，commitlog将被清除。
- en: Due to the intentional adoption of sequential I/O, a row is typically stored
    across many SSTable files. Apart from its data, SSTable also has a primary index
    and a *bloom filter*. A primary index is a list of row keys and the start position
    of rows in the data file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有意采用顺序I/O，一行数据通常存储在多个SSTable文件中。除了其数据外，SSTable还有一个主索引和一个*bloom filter*。主索引是行键列表以及数据文件中行的起始位置。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Bloom filter**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**布隆过滤器**'
- en: Bloom filter is a sample subset of the primary index with very fast nondeterministic
    algorithms to check whether an element is a member of a set. It is used to boost
    the performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器是主索引的一个样本子集，具有非常快速的确定性算法来检查一个元素是否是集合的成员。它用于提升性能。
- en: 'For write operations, Cassandra supports tunable consistency by various write
    consistency levels. The write consistency level is the number of replicas that
    acknowledge a successful write. It is tunable on a spectrum of write consistency
    levels, as shown in the following figure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于写操作，Cassandra通过各种写一致性级别支持可调一致性。写一致性级别是确认成功写入的副本数量。它可以在一系列写一致性级别上进行调整，如图所示：
- en: '![Write path](img/8884OS_01_05.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![写入路径](img/8884OS_01_05.jpg)'
- en: Cassandra write consistency levels
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra写一致性级别
- en: 'The following describes the terms in the figure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了图中的术语：
- en: '**ANY**: This is the lowest consistency (but highest availability)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ANY**: 这是最低的一致性（但可用性最高）'
- en: '**ALL**: This is the highest consistency (but lowest availability)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALL**: 这是最高的一致性（但可用性最低）'
- en: '**ONE**: This gives at least one replica'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ONE**: 这至少提供一个副本'
- en: '**TWO**: This gives at least two replicas'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TWO**: 这至少提供两个副本'
- en: '**THREE**: This gives at least three replicas'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**THREE**: 这至少提供三个副本'
- en: '**QUORUM**: This ensures strong consistency by tolerating some level of failure,
    which is determined by *(replication_factor / 2) + 1* (rounded down to the nearest
    integer)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QUORUM**: 这通过容忍一定程度的故障来确保强一致性，故障程度由 *(replication_factor / 2) + 1*（向下取整到最接近的整数）确定'
- en: '**LOCAL_QUORUM**: This is for multi-data center and rack-aware without inter-data
    center traffic'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOCAL_QUORUM**: 这适用于多数据中心和机架感知，但没有数据中心间流量'
- en: '**EACH_QUORUM**: This is for multi-data center and rack-aware'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EACH_QUORUM**: 这适用于多数据中心和机架感知'
- en: The two extremes are the leftmost **ANY** which means weak consistency and the
    rightmost **ALL** means strong consistency. A consistency level of **THREE** is
    very common in practice. **QUORUM** can be chosen to be an optimum value, as calculated
    by the given formula. Here, the replication factor is the number of replicas of
    data on multiple nodes. Both **LOCAL QUORUM** and **EACH QUORUM** support multiple
    data centers and rack-aware write consistency with a slight difference as shown
    earlier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 两个极端是左边的**ANY**，表示弱一致性，和右边的**ALL**，表示强一致性。实践中非常常见的**THREE**一致性级别。**QUORUM**可以选择为最佳值，如给定公式计算。在这里，复制因子是多个节点上数据的副本数量。**LOCAL
    QUORUM**和**EACH QUORUM**都支持多数据中心和机架感知的写一致性，与前面所示略有不同。
- en: Read path
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取路径
- en: 'On the flip side, the following figure shows the components and their sequence
    of executions that form a read path:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，以下图显示了构成读取路径的组件及其执行顺序：
- en: '![Read path](img/8884OS_01_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![读取路径](img/8884OS_01_06.jpg)'
- en: Cassandra read path
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra读取路径
- en: When a read request comes in to a node, the data to be returned is merged from
    all the related SSTables and any unflushed memtables. Timestamps are used to determine
    which one is up-to-date. The merged value is also stored in a write-through row
    cache to improve the future read performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取请求到达一个节点时，要返回的数据是从所有相关的SSTables和任何未刷新的memtables中合并的。时间戳用于确定哪个是最新的。合并的值也存储在写入通过行缓存中，以提高未来的读取性能。
- en: 'Similar to the write consistency levels, Cassandra also provides tunable read
    consistency levels, as shown in the following figure:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与写一致性级别类似，Cassandra还提供了可调的读取一致性级别，如图所示：
- en: '![Read path](img/8884OS_01_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![读取路径](img/8884OS_01_07.jpg)'
- en: Cassandra read consistency levels
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra读取一致性级别
- en: 'The following describes the terms in the figure:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了图中的术语：
- en: '**ALL**: This is the highest consistency (but lowest availability)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALL**: 这是最高的一致性（但可用性最低）'
- en: '**ONE**: This gives at least one replica'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ONE**: 这至少提供一个副本'
- en: '**TWO**: This gives at least two replicas'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TWO**: 这至少提供两个副本'
- en: '**THREE**: This gives at least three replicas'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**THREE**: 这至少提供三个副本'
- en: '**QUORUM**: This ensures strong consistency by tolerating some level of failure,
    which is determined by *(replication_factor / 2) + 1* (rounded down to the nearest
    integer)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QUORUM**: 这通过容忍一定程度的故障来确保强一致性，故障程度由 *(replication_factor / 2) + 1*（向下取整到最接近的整数）确定'
- en: '**LOCAL_QUORUM**: This is for multi-data center and rack-aware without inter-data
    center traffic'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LOCAL_QUORUM**: 这适用于多数据中心和机架感知，但没有数据中心间流量'
- en: '**EACH_QUORUM**: This is for multi-data center and rack-aware'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EACH_QUORUM**: 这适用于多数据中心和机架感知'
- en: Read consistency level is the number of replicas contacted for a successful,
    consistent read, almost identical to write consistency levels, except that **ANY**
    is not an option here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 读取一致性级别是成功、一致读取时接触的副本数量，几乎与写入一致性级别相同，只是这里没有**任何**选项。
- en: Repair mechanism
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复机制
- en: 'There are three built-in repair mechanisms provided by Cassandra:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra提供了三种内置的修复机制：
- en: Read repair
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取修复
- en: Hinted handoff
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暗示传递
- en: Anti-entropy node repair
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反熵节点修复
- en: During a read, the coordinator that is just the node connects and services the
    client, contacts a number of nodes as specified by the consistency level for data
    and the fastest replicas will return the data for a consistency check by in-memory
    comparison. As it is not a dedicated node, Cassandra lacks a single point of failure.
    It also checks all the remaining replicas in the background. If a replica is found
    to be inconsistent, the coordinator will issue an update to bring back the consistency.
    This mechanism is called **read repair**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取过程中，仅连接并服务客户端的协调器（即节点）会根据数据的一致性级别和最快的副本数量联系多个节点，通过内存比较进行一致性检查。由于它不是一个专用节点，Cassandra缺乏单点故障。它还会在后台检查所有剩余的副本。如果发现副本不一致，协调器将发出更新以恢复一致性。这种机制称为**读取修复**。
- en: '**Hinted handoff** aims at reducing the time to restore a failed node when
    rejoining the cluster. It ensures absolute write availability by sacrificing a
    bit of read consistency. If a replica is down at the time a write occurs, another
    healthy replica stores a hint. Even worse, if all the relevant replicas are down,
    the coordinator stores the hint locally. The hint basically contains the location
    of the failed replica, the affected row key, and the actual data that is being
    written. When a node responsible for the token range is up again, the hint will
    be handed off to resume the write. As such, the update cannot be read before a
    complete handoff, leading to inconsistent reads.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**暗示传递**旨在减少在重新加入集群时恢复失败节点的时间。它通过牺牲一点读取一致性来确保绝对的写入可用性。如果在写入发生时副本已关闭，另一个健康的副本将存储一个提示。更糟糕的是，如果所有相关的副本都关闭了，协调器将本地存储提示。提示基本上包含失败副本的位置、受影响的行键以及正在写入的实际数据。当负责令牌范围的节点再次上线时，提示将被传递以恢复写入。因此，更新在完全传递之前不能被读取，导致不一致的读取。'
- en: Another repair mechanism is called **anti-entropy** which is a replica synchronization
    mechanism to ensure up-to-date data on all nodes and is run by the administrators
    manually.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种修复机制称为**反熵**，它是一个副本同步机制，用于确保所有节点上的数据都是最新的，并且由管理员手动运行。
- en: Features of Cassandra
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cassandra的特性
- en: 'In order to keep this chapter short, the following bullet list covers the great
    features provided by Cassandra:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章简短，以下项目符号列表涵盖了Cassandra提供的一些主要特性：
- en: Written in Java and hence providing native Java support
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Java编写，因此提供原生Java支持
- en: Blend of Google BigTable and Amazon Dynamo
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合了Google BigTable和Amazon Dynamo
- en: Flexible schemaless column-family data model
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的非模式化列族数据模型
- en: Support for structured and unstructured data
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持结构化和非结构化数据
- en: Decentralized, distributed peer-to-peer architecture
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去中心化、分布式对等架构
- en: Multi-data center and rack-aware data replication
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多数据中心和机架感知的数据复制
- en: Location transparent
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置透明
- en: Cloud enabled
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云支持
- en: Fault-tolerant with no single point of failure
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有容错性，没有单点故障
- en: An automatic and transparent failover
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动且透明的故障转移
- en: Elastic, massively, and linearly scalable
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性、大规模和线性可扩展
- en: Online node addition or removal
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线节点添加或删除
- en: High Performance
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能
- en: Built-in data compression
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置数据压缩
- en: Built-in caching layer
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置缓存层
- en: Write-optimized
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入优化
- en: Tunable consistency providing choices from very strong consistency to different
    levels of eventual consistency
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调一致性，提供从非常强的一致性到不同级别的最终一致性选择
- en: Provision of **Cassandra Query Language** (**CQL**), a SQL-like language imitating
    `INSERT`, `UPDATE`, `DELETE`, `SELECT` syntax of SQL
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类似于SQL的**Cassandra查询语言**（**CQL**），一种模仿SQL的`INSERT`、`UPDATE`、`DELETE`、`SELECT`语法的类似语言
- en: Open source and community-driven
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源并由社区驱动
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have gone through a bit of history starting from the 1970s.
    We were in total control of the data models that were rather stable and the applications
    that were pretty simple. The relational databases were a perfect fit in the old
    days. With the emergence of object-oriented programming and the explosion of the
    web applications on the pervasive Internet, the nature of the data has been extended
    from structured to semi-structured and unstructured. Also, the application has
    become more complex. The relational databases could not be perfect again. The
    concept of Big Data was created to describe such challenges and NoSQL databases
    provide an alternative resolution to the relational databases.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从20世纪70年代开始回顾了一点点历史。我们完全控制着那些相当稳定的数据模型和相对简单的应用程序。在那些日子里，关系型数据库是一个完美的选择。随着面向对象编程的出现和互联网上网络应用程序的爆炸式增长，数据的本质已经从结构化扩展到半结构化和非结构化。此外，应用程序也变得更加复杂。关系型数据库再也无法完美无缺。大数据的概念被创造出来描述这样的挑战，而NoSQL数据库为关系型数据库提供了一种替代的解决方案。
- en: NoSQL databases are of a wide variety. They provide some common benefits and
    can be classified by the NoSQL database type. Apache Cassandra is one of the NoSQL
    databases that is a blend of Google BigTable and Amazon Dynamo. The elegance of
    its architecture inherits from the DNA of these two parents.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库种类繁多。它们提供了一些共同的优点，并且可以根据NoSQL数据库类型进行分类。Apache Cassandra是NoSQL数据库之一，它是Google
    BigTable和Amazon Dynamo的结合。其架构的优雅性继承了这两个父母的DNA。
- en: In the next chapter, we will look at the flexible data model supported by Cassandra.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Cassandra支持的灵活数据模型。
