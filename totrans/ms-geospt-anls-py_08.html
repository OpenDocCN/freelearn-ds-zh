<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Automating QGIS Analysis</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>This book has introduced you to using Python from the command line, in a Jupyter Notebook, and in an IDE to perform geospatial tasks. While these three tools will allow you to accomplish your tasks, there are many times when work needs to be done using desktop GIS software.</span></p>
<p><span><span>QGIS, a popular open source GIS application, provides desktop GIS functionality with the ability to work in a Python console and the ability to write toolboxes and plugins using Python. In this chapter, you will learn how to manipulate desktop GIS data using Python and how to automate these tasks using toolboxes and plugins.</span></span></p>
<p><span><span>In this chapter, you will learn how to:</span></span></p>
<ul>
<li><span><span>Load and save layers</span></span></li>
<li><span><span>Create layers from API data sources</span></span></li>
<li><span><span>Add, edit, and delete features</span></span></li>
<li><span><span>Select specific features</span></span></li>
<li><span><span>Call geoprocessing functions</span></span></li>
<li><span><span>Write geoprocessing toolboxes</span></span></li>
<li><span><span>Write plugins</span></span></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working in the Python console</h1>
                </header>
            
            <article>
                
<p><span><span>The QGIS Python console is a Python console. You can perform all of your normal Python tasks with the added benefit of having the QGIS libraries added. From the console, you can manipulate GIS data and display it on the screen, or not.</span></span></p>
<p>The Python console is located under the <span class="packt_screen">Plugins</span> menu on the QGIS toolbar. You can also access it by pressing <em>Ctrl </em>+ <em>Alt </em>+ <em>P</em> on the keyboard. The console will usually open in the bottom of the main window. You can undock it by clicking on the title bar (where it says <span class="packt_screen">Python Console</span>), holding down the mouse button, and dragging the window to another location on the screen or by clicking the window button at the top-right of the console:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bfc549d0-4917-48e3-86e9-9186a7ddc648.png" width="1366" height="729"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot of the Python console</div>
<p><span><span>The console has buttons for clearing the window, importing GIS and QGIS specific libraries, running the current command (you can press <em>Enter</em> instead of clicking this button), showing the editor, modifying options, and viewing the</span></span> <span class="packt_screen">Help</span> <span><span>files. The editor launches a simplified text editor you can use for writing your Python code. It has a few benefits over the command line. You can use the editor to open existing Python files and run or edit them. When you write code in the console, you can save it to a file. In the console, you would need to select all, then copy and paste it into another file, removing all of the output. The editor also allows you to search for text, cut text, add or remove comments, and inspect objects.</span></span></p>
<p><span><span>Now that you understand the basics of the console and the editor, we can start writing some Python code.</span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Loading layers</h1>
                </header>
            
            <article>
                
<p><span><span>One of the first things you will probably need to do is load some existing GIS data. You can open several different file formats. The method for doing this is the same. It is done by creating a <kbd>QgsVectorLayer</kbd> and passing a parameter for the data source, the layer name to be shown in the layers panel widget, and the provider name as shown in the following code:</span></span></p>
<pre><span><span><span>import requests <br/>import json <br/>from qgis.core import * <br/>from qgis.PyQt.QtGui import * <br/>from qgis.PyQt.QtWidgets <br/>import * <br/>from qgis.PyQt.QtCore import * <br/><br/>streets = QgsVectorLayer(r'C:\Users\Paul\Desktop\PythonBook\CHP8\Streets.shp', "Streets","ogr") <br/>scf = QgsVectorLayer(r'C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp', "SeeClickFix","ogr")<br/></span></span></span></pre>
<p><span><span><span>For most vector layers, you will use <kbd>"ogr"</kbd> as the provider. You can then add the layer to the map using the following code: </span></span></span></p>
<pre>QgsMapLayerRegistry.instance().addMapLayers([scf,streets]) </pre>
<p><span><span><span>The previous code adds the layer to the map registry. Alternatively, you can do the previously mentioned code in a single line of code using <kbd>iface</kbd> as shown in the following code:</span></span></span></p>
<pre>streets = iface.addVectorLayer(r'C:\Users\Paul\Desktop\PythonBook\CHP8\Streets.shp', "Streets","ogr") <br/>scf = iface.addVectorLayer(r'C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp', "SeeClickFix","ogr")</pre>
<p><span><span><span>The previous code loads a vector layer and adds it to the registry in a single step. The following screenshot shows the layers added in QGIS and the names added to the layers panel:</span></span></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/252cacbf-972f-405f-8b3d-7ebda34ceed3.png" width="1366" height="730"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A screenshot of the layers loaded in QGIS</div>
<p><span><span><span>The registry holds a list of all of the layers in the map document. You can get a list of loaded layers by using the following code:</span></span></span></p>
<pre>QgsMapLayerRegistry.instance().mapLayers() </pre>
<p><span><span><span>The previous code should show that two layers, <kbd>SeeClickFix</kbd> and <kbd>Streets</kbd>, are loaded:</span></span></span></p>
<pre><strong>{u'SeeClickFix20171129100436571': &lt;qgis._core.QgsVectorLayer object at 0x000000002257F8C8&gt;, u'Streets20171129100433367': &lt;qgis._core.QgsVectorLayer object at 0x000000002257F268&gt;}</strong></pre>
<p><span><span><span>You can remove a layer from the map by using</span></span></span> <kbd>removeMapLayer()</kbd> <span><span><span>and passing the <kbd>id</kbd> of the layer to remove. The <kbd>id</kbd> is the string from the result of calling</span></span></span> <kbd>mapLayers()</kbd><span><span><span>. In this case, the <kbd>id</kbd> of the loaded layer is <kbd>'Steets20171129092415901'</kbd>. The following code will remove the layer:</span></span></span></p>
<pre>QgsMapLayerRegistry.instance().removeMapLayer('Streets20171129100433367')</pre>
<p><span><span><span>The previous code passes the layer <kbd>id</kbd> to</span></span></span> <kbd>removeMapLayer()</kbd><span><span><span>. Since the data was loaded in the <kbd>streets</kbd> variable, you can also pass</span></span></span> <kbd>streets.id()</kbd> <span><span><span>instead of typing the layer <kbd>id</kbd>, as shown in the following code:</span></span></span></p>
<pre>QgsMapLayerRegistry.instance().removeMapLayer(streets.id()) </pre>
<p><span><span><span>Both methods will result in the layer being removed from the map.</span></span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Processing a layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Once the layer is loaded, you will want to examine the layer and the features in the layer. For the layer, you will probably want to know the projection, the coordinate reference system, and how many features it has.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Layer properties</h1>
                </header>
            
            <article>
                
<p class="mce-root">To find the coordinate reference system, you can use <kbd>crs()</kbd> on the layer as shown in the following code:</p>
<pre class="mce-root">crs = scf.crs()</pre>
<p class="mce-root">The previous code assigns the coordinate reference system to the variable <kbd>crs</kbd>. From here, you can inspect it by getting the descriptions shown in the following code:</p>
<pre class="mce-root">crs.description()</pre>
<p class="mce-root">The previous code will return the output as follows:</p>
<pre class="mce-root"><strong>'WGS 84'</strong></pre>
<p class="mce-root">For a <strong>well-known text</strong> (<strong>WKT</strong>) representation of the coordinate reference system, you can use the <kbd>toWkt()</kbd> method:</p>
<pre class="mce-root">crs.toWkt()</pre>
<p class="mce-root">This will return the results as follows:</p>
<pre class="mce-root"><strong>'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]]'</strong></pre>
<p class="mce-root">You can get the bounding box of the layer by using the <kbd>extent()</kbd> method shown as follows: </p>
<pre class="mce-root">extent = scf.extent()</pre>
<p class="mce-root">You can then get a string of the extent using <kbd>toString()</kbd>, get the WKT using <kbd>asWktPolygon()</kbd>, or you can get each coordinate individually using <kbd>xMinimum()</kbd>, <kbd>xMaximum()</kbd>, <kbd>yMinimum()</kbd>, and <kbd>yMaximum()</kbd>. The methods and their output are shown as follows:</p>
<pre class="mce-root">extent.toString()<br/><strong>u'-106.6649165999999980,35.0744279999999975 : -106.6457526013259951,35.0916344666666973'</strong><br/><br/>extent.asWktPolygon()<br/><strong>'POLYGON((-106.66491659999999797 35.0744279999999975, -106.6457526013259951 35.0744279999999975, -106.6457526013259951 35.09163446666669728, -106.66491659999999797 35.09163446666669728, -106.66491659999999797 35.0744279999999975))'</strong><br/><br/>extent.xMinimum()<br/><strong>-106.6649166</strong><br/><br/>extent.xMaximum()<br/><strong>-106.645752601326</strong><br/><br/>extent.yMinimum()<br/><strong>35.074428</strong> <br/><br/>extent.yMaximum()<br/><strong>35.0916344666667</strong></pre>
<div class="mce-root packt_tip">To see the available methods on an object, use <kbd>dir(object)</kbd>.<br/>
To see the methods for the extent object, use <kbd>dir(extent)</kbd>.</div>
<p class="mce-root">You can get the number of features in the layer by using <kbd>pendingFeatureCount()</kbd>. The following code returns the feature count for the <kbd>SeeClickFix</kbd> layer:</p>
<pre class="mce-root">scf.pendingFeatureCount()</pre>
<p class="mce-root">The result is a long datatype and in this case, equals 126.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Feature properties</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can get the first feature using the code as follows:</p>
<pre class="mce-root">item=scf.getFeatures().next()</pre>
<p class="mce-root">The previous code uses <kbd>getFeatures().next()</kbd> to get the first feature and assigns it to the <kbd>item</kbd> variable. If you remove the <kbd>.next()</kbd>, you get a <kbd>QgsFeatureIterator</kbd>, which allows you to iterate through all of the features. For the following examples we will use a single feature.</p>
<p class="mce-root">To get the <kbd>geometry</kbd>, assign it to a variable as shown:</p>
<pre class="mce-root">g = item.geometry()</pre>
<p class="mce-root">To get the <kbd>type</kbd>, you can use the following code:</p>
<pre class="mce-root">g.type() <br/><strong>0</strong></pre>
<p class="mce-root">The previous code returns <kbd>0</kbd> for points. Knowing that the features are points, we can see the coordinates using <kbd>asPoint()</kbd> as shown in the following code:</p>
<pre class="mce-root">item.geometry().asPoint()<br/><strong>(-106.652,35.0912)</strong><br/><br/>item.geometry().asPoint()[0]<br/><strong>-106.65153503418</strong><br/><br/>item.geometry().asPoint()[1]<br/><strong>35.0912475585134</strong></pre>
<p class="mce-root">If we try the same code on the <kbd>streets</kbd> layer, we will get a type of <kbd>1</kbd> and the coordinates of the <kbd>Polyline</kbd> as shown in the following code:</p>
<pre class="mce-root">street = streets.getFeatures().next().geometry().type()<br/><strong>1</strong><br/><br/>street.geometry().asPolyline() <br/><strong>[(-106.729,35.1659), (-106.729,35.1659), (-106.729,35.1658), (-106.729,35.1658), (-106.73,35.1658), (-106.73,35.1658), (-106.73,35.1658), (-106.73,35.1658)]</strong></pre>
<p class="mce-root">To get information about the fields in the features, use <kbd>fields()</kbd> as shown in the following code:</p>
<pre class="mce-root">item.fields().count()<br/><strong>4</strong></pre>
<p class="mce-root">You can get a field name and type by using <kbd>.name()</kbd> and <kbd>.typeName()</kbd> for each of the four fields. Using field <kbd>2</kbd>, the following code will show you how to get the name and type:</p>
<pre class="mce-root">item.fields()[2].name()<br/><strong>u'Type'</strong><br/>item.fields()[2].typeName()<br/><strong>u'String'</strong></pre>
<p class="mce-root">Knowing the name of the field, you can get the value of the field for the first record. Or, you could always use the numerical index as shown in the following code:</p>
<pre class="mce-root">item["Type"]<br/><strong>u'Other'</strong><br/><br/>item[0]<br/><strong>1572.0</strong><br/><br/>item[1]<br/><strong>3368133L</strong><br/><br/>item[2]<br/><strong>u'Other'</strong><br/><br/>item[3]<br/><strong>u'Acknowledged'</strong></pre>
<p class="mce-root">Now that you know how to access the geometry and attributes of a feature, you can iterate through the features using <kbd>getFeatures()</kbd>. The following code will iterate through the features and <kbd>print</kbd> the <kbd>ID</kbd> of all of the records with a <kbd>Status</kbd> of <kbd>'Closed'</kbd>:</p>
<pre class="mce-root">for f in scf.getFeatures():<br/>    if f["Status"]=='Closed':<br/>        print(f["ID"])</pre>
<p class="mce-root">The previous code uses the <kbd>getFeatures()</kbd> to return an iterator. It then checks if the <kbd>Status</kbd> attribute is equal to <kbd>'Closed'</kbd> and then prints the attribute <kbd>ID</kbd> if it is. The output is shown as follows:</p>
<pre class="mce-root"><strong> 3888698</strong><br/><strong> 3906283</strong><br/><strong> 3906252</strong><br/><strong> 3882952</strong><br/><strong> 3904754</strong><br/><strong> 3904463</strong><br/><strong> 3904344</strong><br/><strong> 3904289</strong><br/><strong> 3903243</strong><br/><strong> 3903236</strong><br/><strong> 3902993</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drawing a layer from PostGIS</h1>
                </header>
            
            <article>
                
<p class="mce-root">QGIS will allow you to load a PostgreSQL layer using the <kbd>QgsDataSourceURI</kbd> class and <kbd>QgsVectorLayer</kbd> (URI, name, provider (Postgres)). For this to work, QGIS needs to be compiled with Postgres support. In this section, you will use <kbd>psycopg2</kbd> as you learned in <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, and <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>. The method of adding features to a layer and a layer to the map in this section will be used later in this chapter when you learn how to write toolboxes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drawing points</h1>
                </header>
            
            <article>
                
<p class="mce-root">Before you learn how to load the data from PostGIS, we will first cover how to draw multiple points, convert them to a feature, add them to a layer, then load the layer to the map. The following code will walk you through the process.</p>
<p class="mce-root">Start by creating a <kbd>memory</kbd> layer as shown in the code:</p>
<pre class="mce-root">theLayer=QgsVectorLayer('Point?crs=epsg:4326','SomePoints','memory') </pre>
<p class="mce-root">The previous code creates a vector layer and assigns it to the variable <kbd>theLayer</kbd>. The parameters are the type and coordinate reference system of the layer, the name for the layer panel, and we specified that it is a <kbd>memory</kbd> layer.</p>
<p class="mce-root">Next, you need to create the features:</p>
<pre class="mce-root">from qgis.PyQt.QtCore import *<br/>theFeatures=theLayer.dataProvider()<br/>theFeatures.addAttributes([QgsField("ID", QVariant.Int),QgsField("Name", Qvariant.String)])</pre>
<p class="mce-root">The previous code imports <kbd>qgis.PyQtCore</kbd>. You need the library for the <kbd>QVariant</kbd>. First, you call the data provider for the layer and pass it to the features. Next, you add the attributes and their types to the features. In the following code, you create a <kbd>point</kbd> and add it to the features:</p>
<pre class="mce-root"> p=QgsFeature()<br/> point=QgsPoint(-106.3463,34.9685)<br/> p.setGeometry(QgsGeometry.fromPoint(point))<br/> p.setAttributes([123,"Paul"])<br/> theFeatures.addFeatures([p])<br/> theLayer.updateExtents()<br/> theLayer.updateFields()</pre>
<p class="mce-root">The previous code creates a <kbd>p</kbd> variable and makes it a <kbd>QgsFeature</kbd>. It then creates a point <kbd>p</kbd> and passes longitude and latitude coordinates. The feature is assigned geometry from the <kbd>point</kbd>. Next, you assign the attributes to the feature. Now you have a feature with geometry and attributes. In the next line, you pass the feature to the features array using <kbd>addFeature()</kbd>. Lastly, you update the layer extents and fields.</p>
<p class="mce-root">Repeat the block of code a second time and assign the <kbd>point</kbd> different coordinates, <kbd>(-106.4540,34.9553)</kbd>, and then add the layer to the map as in the earlier section of this chapter, shown in the following code:</p>
<pre class="mce-root">QgsMapLayerRegistry.instance().addMapLayers([theLayer])</pre>
<p class="mce-root">You will now have a map with two points as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/04cf83ce-3b71-47da-ac91-c0e61a26f86b.png" style="width:53.42em;height:28.50em;" width="1366" height="728"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Two points with attributes loaded in QGIS from the Python console</div>
<p class="mce-root">You can see in the <span class="packt_screen">Layers Panel</span> that the layer is named <span class="packt_screen">SomePoints</span>. In the attribute table, you can see two fields, <span class="packt_screen">ID</span> and <span class="packt_screen">Name</span> for two features. Now that you know how to create features from geometry, add attributes, add the features to a layer, and display the layer on the map, we will add PostGIS to the mix and loop through the process mentioned earlier.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Drawing polygons from PostGIS</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this example, you will draw the Albuquerque Police Department Area Commands polygons from a PostGIS database. You will use the following code with an added PostGIS query, a loop to add all of the features, and a WKT function to draw the geometry instead of hard-coding the coordinates.</p>
<p class="mce-root">The first step is to connect to the PostGIS database. The following code is the same as you used in <a href="42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml" target="_blank">Chapter 3</a>, <em>Introduction to Geospatial Databases</em>, and <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml" target="_blank">Chapter 7</a>, <em>Geoprocessing With Geodatabases</em>:</p>
<pre class="mce-root"> import psycopg2<br/> connection =  <br/> psycopg2.connect(database="pythonspatial",user="postgres", <br/> password="postgres")<br/> cursor = connection.cursor()<br/> cursor.execute("SELECT name, ST_AsTexT(geom) from areacommand")<br/> c=cursor.fetchall()</pre>
<p class="mce-root">The previous code connects to PostGIS, grabs all of the Area Commands with their name and geometry, and assigns them to the <kbd>c</kbd> variable. Next, you will create the layer as in the earlier example. You will create a counter <kbd>x</kbd> and make it the <kbd>ID</kbd> field of the features:</p>
<pre class="mce-root">APD=QgsVectorLayer('Polygon?crs=epsg:4326','AreaCommands','memory') <br/>APDfeatures=APD.dataProvider() <br/>APDfeatures.addAttributes([QgsField("ID",QVariant.Int),QgsField("Name", QVariant.String)]) <br/>x=0</pre>
<p class="mce-root">The previous code creates a polygon <kbd>memory</kbd> layer, creates the features, and adds attributes. Next, you will look through the <kbd>cursor</kbd>, creating geometry for each Area Command and adding attributes, then you update the layer's extents and fields:</p>
<pre class="mce-root">for acmd in c:<br/>    g=QgsGeometry()<br/>    g=QgsGeometry.fromWkt(acmd[1])<br/>    p=QgsFeature()<br/>    print(acmd[0])<br/>    p.setGeometry(g)<br/>    x+=1<br/>    p.setAttributes([x,str(acmd[0])])<br/>    APDfeatures.addFeatures([p])<br/>    APD.updateExtents()<br/>    APD.updateFields()</pre>
<p class="mce-root">The previous code is the same as in the points example in the previous section. The one major difference is that you are creating the polygon using <kbd>QgsGeometry.fromWkt(wkt)</kbd>. The <kbd>acmd[1]</kbd> variable is the WKT <kbd>MultiPolygon</kbd> string from PostGIS.</p>
<p class="mce-root">Lastly, add the layer to the map as in the following code:</p>
<pre class="mce-root">QgsMapLayerRegistry.instance().addMapLayers([APD])</pre>
<p class="mce-root">The following code will render the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/19a7113e-b217-41b2-b14b-055d6f0e7683.png" width="1366" height="729"/></div>
<p class="mce-root">And there you have it, the Area Command polygons for the Albuquerque Police Department as a layer in QGIS. Next, you will learn how to add, edit, and delete features from a layer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding, editing, and deleting features</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous examples, you created an empty layer and added fields, then added data and displayed it. There will be times when you will need to do that, more often than not, you will already have a layer and you will need to add data, edit data, or delete data from it. In this section, you will learn how to perform those tasks on existing data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding features to an existing layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">To add data to a layer, you first need to load the layer. Start by loading a subset of some <kbd>SeeClickFix</kbd> data for Albuquerque as shown in the following code:</p>
<pre class="mce-root">scf = iface.addVectorLayer(r'C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp', "SeeClickFix","ogr") </pre>
<p class="mce-root">The previous code loads and displays the layer on the map. It is the same code from the first section of this chapter.</p>
<div class="mce-root packt_infobox">You do not need to display the layer on the map to work with it. You can load the layer using <kbd>scf = QgsVectorLayer("C:\Users\Paul\Desktop\PythonBook\CHP8\SCF.shp", "SeeClickFix","ogr")</kbd>.</div>
<p class="mce-root">Now that you have the layer loaded you can use <kbd>capabilitiesString()</kbd> to see what operations the provider allows on the data. The following code shows the results on the loaded layer:</p>
<pre class="mce-root">scf.dataProvider().capabilitiesString()<br/><br/><strong>u'Add Features, Delete Features, Change Attribute Values, Add Attributes, Delete Attributes, Rename Attributes, Create Spatial Index, Create Attribute Indexes, Fast Access to Features at ID, Change Geometries'</strong></pre>
<p class="mce-root">Since <kbd>Add Features</kbd> is a capability, you can add a new feature as shown in the following code:</p>
<pre class="mce-root">feat = QgsFeature(scf.pendingFields())<br/>feat.setAttribute('fid',911)<br/>feat.setAttribute('ID',311)<br/>feat.setAttribute('Type','Pothole')<br/>feat.setAttribute('Status','Pending')<br/>feat.setGeometry(QgsGeometry.fromPoint(QgsPoint(-106.65897,35.07743)))<br/>scf.dataProvider().addFeatures([feat])</pre>
<p class="mce-root">The previous code creates a feature and gets the fields from the loaded layer. It then sets each of the attributes. Next, it sets the geometry from a point. Lastly, the feature is added to the layer. When you call <kbd>addFeatures()</kbd> there are two return values you can assign to variables—the result and the feature. The result of <kbd>addFeature()</kbd> will be either true or false. The returned feature is a list of features. It may be convenient to hold the feature if you need to perform more operations with it.</p>
<div class="mce-root packt_tip">When automating the process, you can perform a capabilities check before trying to edit the layer.</div>
<p class="mce-root">The results are a new point and record in the attributes table as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5887ecb1-1029-4075-9d3a-4eeba4a17eec.png" width="1366" height="730"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A feature added to the layer</div>
<p class="mce-root">You can simplify the previous code by passing all the attributes in a single line using a list. The following code shows you how:</p>
<pre class="mce-root">feat.setAttributes([912,312,"Other","Closed"])</pre>
<p class="mce-root">The previous code writes the attributes using a list and <kbd>setAttributes()</kbd> instead of the singular <kbd>setAttribute()</kbd>. If you want to remember the field names when reading your code later, the more verbose version is clearer. But if the efficiency of the code is your goal, the latter version is more appropriate.</p>
<p class="mce-root">What if we made a mistake, or have records we do not need? The next section will show you how to delete a feature.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deleting features from an existing layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">Deleting features can be done in a single line of code following the format as shown:</p>
<pre class="mce-root">LayerName.dataProvider().deleteFeatures([list of id])</pre>
<p class="mce-root">In the previous code, you use <kbd>deleteFeatures()</kbd> and the <kbd>id</kbd> of the layer. The <kbd>id</kbd> is the <kbd>feature.id()</kbd>. It is a number held internally and not in a user assigned attribute. To get the <kbd>id</kbd> of a specific feature you can iterate through them as you learned earlier in this chapter. The following code shows you how to delete the feature we created in the previous section: </p>
<pre class="mce-root">for x in scf.getFeatures():<br/>    if x["ID"]==311:<br/>        scf.dataProvider().deleteFeatures([x.id()])</pre>
<p class="mce-root">The previous code iterates through the features in the layer looking for the one with the <kbd>ID</kbd> of <kbd>311</kbd>. When it finds it, it uses <kbd>deleteFeatures()</kbd> and passes the <kbd>id</kbd> using <kbd>x.id()</kbd>. In this case the <kbd>id</kbd> was <kbd>216</kbd>. If you know the <kbd>id</kbd> of the feature, you can delete it without the loop.</p>
<p class="mce-root">You can also pass a list of IDs as shown in the following code:</p>
<pre class="mce-root">for x in scf.getFeatures():<br/>    if x["Status"]=='Closed':<br/>        key.append(x.id())<br/>    scf.dataProvider().deleteFeatures(key)</pre>
<p class="mce-root">The previous code iterates through the features in the layer looking for all of the <kbd>'Closed'</kbd> cases. When it finds one, it puts the <kbd>id</kbd> in the list <kbd>key</kbd>. Lastly, it calls <kbd>deleteFeatures()</kbd> and passes the list.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Editing features from an existing layer</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can now add and delete features, but sometimes you only need to change an attribute value. For example, an open case status to a closed case status. In this section, you will learn how to modify attributes.</p>
<p class="mce-root">Attributes are modified by calling <kbd>changeAttributeValues()</kbd>. The following code changes a single feature:</p>
<pre class="mce-root">scf.dataProvider().changeAttributeValues({114:{0:123,1:345,2:"ADA",3:"NEW"} })</pre>
<p class="mce-root">The previous code calls <kbd>changeAttributeValues()</kbd> and passes a dictionary with the key being the feature <kbd>id</kbd> and the value being a dictionary of attributes—<kbd>{id:{0:value, 1:value, n:value}}</kbd>. The keys for the attributes dictionary are the field indexes. There are four fields in the features so the dictionary of attributes will have keys <kbd>0</kbd> through <kbd>3</kbd>. The following screenshot shows the change in the attribute table:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/67704e0a-c110-4d57-b0e8-3ce4f7fdb4af.png" width="506" height="396"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">A single feature edited</div>
<p class="mce-root">The previous example assumes you already know the <kbd>id</kbd> of the feature you want to modify. It also assumes you want to modify all of the attribute values. The following code will modify several features but only a single attribute value in each—<span class="packt_screen">Status</span>:</p>
<pre class="mce-root">attributes={3:"Closed"}<br/>for x in scf.getFeatures():<br/>     if x["Type"]=='Other':<br/>         scf.dataProvider().changeAttributeValues({x.id():attributes})</pre>
<p class="mce-root">In the previous code, a dictionary is declared with a key of <kbd>3</kbd> (the <kbd>'Status'</kbd> field) and a value of <kbd>"Closed"</kbd>. The code then iterates through the features in the layer looking for a match. When it finds a match, it changes the attribute value, but this time only the value of the <span class="packt_screen">Status</span> field. The results are reflected in the attributes table shown in the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/2da7e828-dc2c-4132-baa8-23a3602ded04.png" width="508" height="474"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">All features of the Other type now have a status of Open</div>
<p class="mce-root">In the previous examples, you have been iterating through features and selecting them based on a condition. In the next section, you will learn how to highlight the selected features and how to use expressions to select instead of a condition.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Selecting features using expressions</h1>
                </header>
            
            <article>
                
<p class="mce-root">Using expressions, you can iterate through features and evaluate the expression returning true(1) or false(0). Before we get into expressions, let's select and highlight a feature. Selecting a feature is accomplished by calling <kbd>setSelectedFeatures()</kbd> and passing a list of IDs. The following code will select a single feature:</p>
<pre class="mce-root">from qgis.PyQt.QtGui import *<br/>from qgis.PyQt.QtWidgets import *<br/>iface.mapCanvas().setSelectionColor( QColor("red") )<br/>scf.setSelectedFeatures([100])</pre>
<p class="mce-root">The previous code, imports <kbd>QtGUI</kbd>, and <kbd>Qt.Widgets</kbd>. These are needed to set the color using <kbd>QColor</kbd>. The next line gets the map canvas and sets the section color to <kbd>red</kbd>. Lastly, the code selects the feature with an <kbd>id</kbd> of <kbd>100</kbd>. It will now display <kbd>red</kbd> on the map.</p>
<p class="mce-root">The previous example assumes you want to select a single feature and that you know the <kbd>id</kbd>. That is rarely the case. More often than not you will want to select by some condition—or using an expression. Using <kbd>QgsExpression()</kbd> you can pass an expression string and evaluate it against features. The following code shows you how:</p>
<pre class="mce-root">closed=[] <br/>exp=QgsExpression("Type='Traffic Signs' and Status='Acknowledged'") <br/>exp.prepare(scf.pendingFields()) <br/>for f in scf.getFeatures(): <br/>    if exp.evaluate(f)==1: <br/>        closed.append(f.id()) <br/>scf.setSelectedFeatures(closed)</pre>
<p class="mce-root">First, the previous code creates a list, <kbd>closed</kbd>, to store the IDs where the expression evaluates to true. Next the expression is declared. The expression checks for two conditions on the <span class="packt_screen">Type</span> and <span class="packt_screen">Status</span>. The expression is prepared and passed the fields in the layer. The next line iterates through the features. If the expression is true (<kbd>1</kbd>), the <kbd>id</kbd> is put in the list. Lastly, the selected features are set to the IDs in the closed list.</p>
<p class="mce-root">The results of the previous code are shown in the screenshot as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/007b4975-1a00-4f08-8484-c9b29a913792.png" width="1366" height="729"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Features selected based on an expression</div>
<p>In the next section, you will learn how to use the toolboxes that come with QGIS to execute algorithms and perform geospatial tasks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using toolboxes in Python</h1>
                </header>
            
            <article>
                
<p class="mce-root">QGIS has a processing library. If you go to the <span class="packt_screen">Processing</span> menu in QGIS and select <span class="packt_screen">Toolbox</span>, you will see a widget displayed with groups of toolboxes. The widget will look as shown:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b2e75ae6-b8ea-4819-86b1-5a04a461f799.png" width="292" height="324"/></div>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">The processing widget</div>
<p class="mce-root">You have access to the toolboxes in Python by importing <kbd>processing</kbd>. You can see the available algorithms by executing the code as follows:</p>
<pre class="mce-root">import processing<br/>processing.alglist()</pre>
<p class="mce-root">The previous code imports <kbd>processing</kbd> and calls the <kbd>alglist()</kbd> method. The results are all of the available algorithms from the installed toolboxes. You should see something similar to the following output:</p>
<pre class="mce-root"><strong>Advanced Python field calculator---------------------&gt;qgis:advancedpythonfieldcalculator</strong><br/><strong> Bar plot---------------------------------------------&gt;qgis:barplot</strong><br/><strong> Basic statistics for numeric fields------------------&gt;qgis:basicstatisticsfornumericfields</strong><br/><strong> Basic statistics for text fields---------------------&gt;qgis:basicstatisticsfortextfields</strong><br/><strong> Boundary---------------------------------------------&gt;qgis:boundary</strong><br/><strong> Bounding boxes---------------------------------------&gt;qgis:boundingboxes</strong><br/><strong> Build virtual vector---------------------------------&gt;qgis:buildvirtualvector</strong><br/><strong> Check validity---------------------------------------&gt;qgis:checkvalidity</strong><br/><strong> Clip-------------------------------------------------&gt;qgis:clip</strong></pre>
<p class="mce-root">To search the algorithms by keyword, you can pass a string to <kbd>alglist()</kbd> as in the following code:</p>
<pre class="mce-root">Processing.alglist("buffer")</pre>
<p class="mce-root">The previous code passes a string to narrow the results. The output will be several algorithms containing the word <kbd>buffer</kbd>. See the output as follows:</p>
<pre class="mce-root"><strong>Fixed distance buffer--------------------------------&gt;qgis:fixeddistancebuffer</strong><br/><strong> Variable distance buffer-----------------------------&gt;saga:shapesbufferattributedistance</strong><br/><strong> Buffer vectors---------------------------------------&gt;gdalogr:buffervectors</strong><br/><strong> v.buffer.column - Creates a buffer around features of given type.---&gt;grass:v.buffer.column</strong></pre>
<p class="mce-root">In this section, we will use the <kbd>Buffer vectors</kbd> algorithm. To see how the algorithm works, you can run the code as follows:</p>
<pre class="mce-root">processing.alghelp("gdalogr:buffervectors")</pre>
<p class="mce-root">The previous code calls <kbd>alghelp()</kbd> and passes the name of the algorithm found in the second column of the <kbd>alglist()</kbd>. The result will tell you the parameters and their type required for executing the algorithm. The output is shown as follows:</p>
<pre class="mce-root"><strong>ALGORITHM: Buffer vectors</strong><br/><strong> INPUT_LAYER &lt;ParameterVector&gt;</strong><br/><strong> GEOMETRY &lt;ParameterString&gt;</strong><br/><strong> DISTANCE &lt;ParameterNumber&gt;</strong><br/><strong> DISSOLVEALL &lt;ParameterBoolean&gt;</strong><br/><strong> FIELD &lt;parameters from INPUT_LAYER&gt;</strong><br/><strong> MULTI &lt;ParameterBoolean&gt;</strong><br/><strong> OPTIONS &lt;ParameterString&gt;</strong><br/><strong> OUTPUT_LAYER &lt;OutputVector&gt;</strong></pre>
<div class="mce-root packt_tip">If you run the algorithm from the GUI and then open <kbd>\.qgis2\processing\processing.log</kbd>, you will see the parameters used to execute the algorithm. Copy them and use them in your Python code.</div>
<p class="mce-root">The previous output shows the parameters needed to run the algorithm. By using <kbd>runalg()</kbd> you can execute the algorithm. The buffer vector is executed in the code as follows:</p>
<pre class="mce-root">processing.runalg("gdalogr:buffervectors",r'C:/Users/Paul/Desktop/Projected.shp',"geometry",100,False,None,False,"",r'C:/Users/Paul/Desktop<br/>/ProjectedBuffer.shp') <br/>layer = iface.addVectorLayer(r'C:\Users\Paul\Desktop\<br/>ProjectedBuffer.shp', "Buffer", "ogr")</pre>
<p class="mce-root">The previous code calls <kbd>runalg()</kbd> and passes the name of the algorithm we want to run, then the parameters required by the algorithm. In this case:</p>
<pre class="mce-root"><strong>INPUT_LAYER = Projected.shp</strong><br/><strong> GEOMETRY = geometry</strong><br/><strong> DISTANCE = 100</strong><br/><strong> DISSOLVEALL = False</strong><br/><strong> FIELD = None</strong><br/><strong> MULTI = False</strong><br/><strong> OPTIONS = “”</strong><br/><strong> OUTPUT_LAYER = ProjectedBuffer.shp</strong></pre>
<p class="mce-root">The output layer is then added to the map. The result is shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a63f65f2-9d2b-4b7f-b6eb-217bf808e480.png" style="width:30.50em;height:22.50em;" width="483" height="355"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Results of the buffer algorithm</div>
<p class="mce-root">Now that you know how to use the Python console and call an algorithm let's write our own algorithm. The next section will show you how to make a toolbox that you can call using <kbd>runalg()</kbd> or by using the GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing custom toolboxes</h1>
                </header>
            
            <article>
                
<p class="mce-root">Writing toolboxes will allow you to automate several tasks and make that code available to users as a GUI, or to other developers as an algorithm that can be executed using processing. In this section, you will learn how to create a toolbox and call it from processing.</p>
<p class="mce-root">In this chapter, you have learned how to load data from a file and from a PostGIS database. In this example, you will learn how to bring data in to QGIS from the <kbd>SeeClickFix</kbd><strong> Application Program Interface</strong> (<strong>API</strong>).</p>
<div class="mce-root packt_infobox"><kbd>SeeClickFix</kbd> is a 311 reporting system that is used by many cities in the United States. It contains geospatial data and has a very well documented, and user-friendly API.</div>
<p class="mce-root">To create a new script, open the processing toolbox in QGIS. This will open an editor window. You will write your code in this window and save it using the save icon. The file name will become a toolbox under <span class="packt_screen">Tools</span>|<span class="packt_screen">User scripts</span>|<span class="packt_screen">File name</span>. Save the file and name it <kbd>SeeClickFix</kbd>.</p>
<p class="mce-root">Now that you have an empty toolbox, we can start adding code. Before the code, you need to create the parameters you will want to pass to this algorithm. Each parameter will also become a GUI widget with the parameter name as the label. The <kbd>SeeClickFix</kbd> API allows you to specify a city or neighborhood and also filter strings. The following code will add these as parameters to our algorithm:</p>
<pre class="mce-root">##City_or_Neighborhood= string City<br/>##Filter=string Nothing<br/>##Output=output vector</pre>
<p class="mce-root">The previous code uses double comment symbols (<kbd>##</kbd>), then the parameter name followed by the parameter type and a default value. Default values are required for numbers and strings. The first parameter in the code is the city or neighborhood, it is a <kbd>string</kbd> and defaults to Albuquerque. Next, is the filter keyword, which is also a <kbd>string</kbd> and defaults to <kbd>Nothing</kbd>. Lastly, the code has an output, which is a type of <kbd>output vector</kbd>. The output will be what is added to the map or saved to disk. </p>
<p>At this point, you can run the toolbox in the GUI and you will see the window shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d9185e7f-4e22-443e-99e8-369d9ec1a1fc.png" width="852" height="423"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The GUI for the toolbox. Notice each parameter is a label</div>
<p class="mce-root">Next, you can import the libraries you need to perform the task. The following code will import what you need for the <kbd>SeeClickFix</kbd> toolbox:</p>
<pre class="mce-root">import requests<br/>import json<br/>from qgis.core import *<br/>from qgis.PyQt.QtGui import *<br/>from qgis.PyQt.QtWidgets import *<br/>from qgis.PyQt.QtCore import *</pre>
<p class="mce-root">The previous code imports the <kbd>qgis</kbd> libraries and also <kbd>requests</kbd> and <kbd>json</kbd>. The <kbd>requests</kbd> library will be used to make the API call and <kbd>json</kbd> will parse the response from the request to <kbd>json</kbd>.</p>
<p class="mce-root">Now it is time to write some code. First, you will need to grab the parameters and set the variables needed to make the API call, and it would not hurt to give the user some information on what is happening. The following code will show you how:</p>
<pre class="mce-root">scfcity=City_or_Neighborhood <br/>searchterm=Filter <br/>progress.setInfo("Wait while I get data from the API") <br/>progress.setText("Calling API") <br/>if searchterm=="None": <br/>    pagesURL="http://seeclickfix.com/api/v2/issues?per_page=100&amp;amp;amp;place_url="+scf city+"&amp;amp;amp;page=" <br/>    url="http://seeclickfix.com/api/v2/issues?per_page=100&amp;amp;amp;place_url="+scfcity <br/>else: <br/>    pagesURL="http://seeclickfix.com/api/v2/issuesper_page=100&amp;amp;amp;place_url="+scfc ity+"&amp;amp;amp;search="+searchterm+"&amp;amp;amp;page="<br/>    url="http://seeclickfix.com/api/v2/issues?per_page=100&amp;amp;amp;search="+searchterm+"&amp;amp;amp;place_url="+scfcity </pre>
<p class="mce-root">The previous code passes the parameters to variables. Then, I used a global variable, <kbd>progress</kbd>, which is provided to you by QGIS and calls the <kbd>setInfo()</kbd> and <kbd>setText()</kbd> methods to tell the user what is happening. <kbd>progress</kbd> is available as part of QGIS. The <kbd>setInfo()</kbd> method displays text in the text area of the GUI. The <kbd>setText()</kbd> method changes the text of the label on the <kbd>progress</kbd> bar and adds it to the text area in the GUI as well.</p>
<p class="mce-root">Next, the code checks if the filter parameter is still <kbd>None</kbd>, and if it is, it assigns the <strong>Uniform Resource Locator</strong> (<strong>URL</strong>) to the API as a string with no filter parameter and uses the city or neighborhood parameter. If there is a filter, a different URL is assigned to make the API call.</p>
<p class="mce-root">Now you are ready for some GIS specific setup. The following code will start you off:</p>
<pre class="mce-root">crs=QgsCoordinateReferenceSystem("epsg:4326")<br/>scf=QgsVectorLayer('Point?crs=epsg:4326','SeeClickFix','memory')<br/><br/>fields = QgsFields()<br/>fields.append(QgsField("ID", QVariant.Int))<br/>fields.append(QgsField("Type", QVariant.String))<br/>fields.append(QgsField("Status", QVariant.String))<br/><br/>writer = processing.VectorWriter(Output, None, fields.toList(),<br/>QGis.WKBPoint, crs)</pre>
<p class="mce-root">The previous code sets a coordinate reference system in WGS 84. Then, it creates a <kbd>memory</kbd> layer, and assigns fields. Lastly, it creates a <kbd>writer</kbd> vector and passes the output parameter, encoding (<kbd>None</kbd>), the fields, the geometry type, and a coordinate reference system. Now you can make the API call as shown in the code:</p>
<pre class="mce-root">r = requests.get(url).text<br/>rJSON=json.loads(r)<br/>pages=rJSON['metadata']['pagination']['pages']<br/>records=rJSON['metadata']['pagination']['entries']<br/>progress.setInfo("Grabbing "+str(records) +" Records")<br/>count=1<br/><br/>for x in range(1,pages+1):<br/>    progress.setText("Reading page "+str(x))<br/>    pageData=requests.get(pagesURL+str(x)).text<br/>    pageDataJSON=json.loads(pageData)</pre>
<p class="mce-root">The previous code uses <kbd>requests</kbd> to make an API call. It assigns a variable for the number of <kbd>pages</kbd> and the number of <kbd>records</kbd> returned. Using the <kbd>setInfo()</kbd> method, the code tells the user how many <kbd>records</kbd> are being processed. It then loops through each page and loads the items from the <kbd>page</kbd>. It tells the user what <kbd>page</kbd> it is currently reading.</p>
<p class="mce-root">Now, the code will parse each <kbd>record</kbd> on the <kbd>page</kbd> as a feature and send it to the vector <kbd>writer</kbd>. You do not need to add the output to the map. Processing will handle this for you if you run it from the GUI. When you run it from Python, you get the file path to the layer and can load it yourself. The following code will show you how:</p>
<pre class="mce-root">for issue in pageDataJSON['issues']:<br/>try:<br/>    p=QgsFeature()<br/>    point=QgsPoint(issue['lng'],issue['lat'])<br/>    p.setGeometry(QgsGeometry.fromPoint(point))<br/>    p.setAttributes([issue["id"],issue["request_type"]<br/>    ["title"],issue["status"]])<br/>    writer.addFeature(p)<br/>    progress.setPercentage((count/float(records))*100)<br/>    count+=1<br/>except:<br/>    pass<br/>del writer</pre>
<p class="mce-root">The previous code creates a feature and passes the geometry from the API to a <kbd>point</kbd>. It then passes the attributes and sends the completed feature to the vector <kbd>writer</kbd>. The <kbd>progress</kbd> bar on the GUI is updated using <kbd>progress.setPercentage()</kbd>. The method takes a <kbd>float</kbd>. In this example, the percentage is the number of <kbd>records</kbd> processed divided by the total number of <kbd>records</kbd>. Lastly, you delete the <kbd>writer</kbd>.</p>
<p class="mce-root">Your toolbox is complete, save it. Now a user can run it from the GUI or you can call it from Python. The following code will show you how to call it from Python and add the results to the map:</p>
<pre class="mce-root">processing.alghelp("script:seeclickfix")<br/><br/><strong> ALGORITHM: SeeClickFix</strong><br/><strong> City_or_Neighborhood &lt;ParameterString&gt;</strong><br/><strong> Filter &lt;ParameterString&gt;</strong><br/><strong> Output &lt;OutputVector&gt;</strong><br/><br/>out=processing.runalg("script:seeclickfix","Albuquerque","Juan Tabo",None)</pre>
<p class="mce-root">The previous code calls the <kbd>alghelp()</kbd> method to show our new algorithm and the parameters. Next, it runs the algorithm using <kbd>runalg()</kbd> and assigns the results to the <kbd>out</kbd> variable. Printing the <kbd>out</kbd> variable shows a dictionary with a key of <kbd>Output</kbd> and a path to a temporary vector as follows:</p>
<pre class="mce-root">out<br/><br/><strong>{'Output': u'C:\\Users\\Paul\\AppData\\Local\\Temp\\processingca7241c6176e42458ea32e8c7264de1e\\014bc4d4516240028ce9270b49c5fcaf\\Output.shp'}</strong></pre>
<p class="mce-root">You can assign the vector to a layer and add it to the map, or you can iterate through the features and do something else with it, as follows:</p>
<pre class="mce-root">out = iface.addVectorLayer(str(a["Output"]), "SeeClickFix","ogr")<br/>for feature in out.getFeatures():<br/>    Do something...</pre>
<p class="mce-root">The results of adding the layer to the map will look like the following screenshot. All of the <kbd>SeeClickFix</kbd> incidents reported along the street, Juan Tabo:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bac1fc04-bbcd-4809-8478-cde9ca8b00e8.png" width="774" height="357"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Results of the toolbox</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, you have learned how to use Python in QGIS. You started by learning the basics of loading a layer and displaying it on the map, and then progressed to adding, editing, and deleting features. You learned how to select features, highlight the selection, and how to use expressions. Then, we took advantage of pre-built geoprocessing tools and you learned how to call toolbox algorithms using processing. Lastly, you learned how to write your own toolbox.</p>
<p class="mce-root">In the next chapter, you will learn how to use Python with Esri tools. You will learn how to use Jupyter Notebooks in a browser to interact with cloud-based datasets and how to use the Esri API for Python to perform basic geospatial analysis and to create ArcGIS Online web maps.</p>


            </article>

            
        </section>
    </div>



  </body></html>