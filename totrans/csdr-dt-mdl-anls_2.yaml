- en: Chapter 2. Cassandra Data Modeling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Cassandra数据建模
- en: In this chapter, we will open the door to the world of Cassandra data modeling.
    We will briefly go through its building blocks, the main differences to the relational
    data model, and examples of constructing queries on a Cassandra data model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将打开通往Cassandra数据建模世界的大门。我们将简要介绍其构建模块，与关系数据模型的主要区别，以及如何在Cassandra数据模型上构建查询的示例。
- en: Cassandra describes its data model components by using the terms that are inherited
    from the Google BigTable parent, for example, column family, column, row, and
    so on. Some of these terms also exist in a relational data model. They, however,
    have completely different meanings. It often confuses developers and administrators
    who have a background in the relational world. At first sight, the Cassandra data
    model is counterintuitive and very difficult to grasp and understand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra通过使用从其Google BigTable父级继承的术语来描述其数据模型组件，例如列族、列、行等。其中一些术语也存在于关系型数据模型中。然而，它们的含义却完全不同。这常常会让有关系型背景的开发人员和管理员感到困惑。乍一看，Cassandra数据模型似乎反直觉，非常难以把握和理解。
- en: In the relational world, you model the data by creating entities and associating
    them with relationships according to the guidelines governed by the relational
    theories. It means that you can solely concentrate on the logical view or structure
    of the data without any considerations of how the application accesses and manipulates
    the data. The objective is to have a stable data model complying with the relational
    guidelines. The design of the application can be done separately. For instance,
    you can answer different queries by constructing different SQL statements, which
    is not of your concern during data modeling. In short, relational data modeling
    is process oriented, based on a clear separation of concerns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型世界中，你通过创建实体并根据关系理论指导下的指南将它们关联起来来建模数据。这意味着你可以只关注数据的逻辑视图或结构，而不必考虑应用程序如何访问和操作数据。目标是拥有一个符合关系型指导原则的稳定数据模型。应用程序的设计可以单独完成。例如，你可以通过构建不同的SQL语句来回答不同的查询，这在数据建模过程中并不需要你关心。简而言之，关系型数据建模是面向过程的，基于明确的关注点分离。
- en: On the contrary, in Cassandra, you reverse the above steps and always start
    from what you want to answer in the queries of the application. The queries exert
    a considerable amount of influence on the underlying data model. You also need
    to take the physical storage and the cluster topology into account. Therefore,
    the query and the data model are twins, as they were born together. Cassandra
    data modeling is result oriented based on a clear understanding of how a query
    works internally in Cassandra.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在Cassandra中，你将上述步骤颠倒过来，始终从你想要在应用程序的查询中回答的问题开始。查询对底层数据模型产生了相当大的影响。你还需要考虑物理存储和集群拓扑。因此，查询和数据模型是孪生兄弟，因为它们是同时诞生的。Cassandra数据建模是基于对查询在Cassandra内部如何工作的清晰理解的结果导向型。
- en: Owing to the unique architecture of Cassandra, many simple things in a relational
    database, such as sequence and sorting, cannot be presumed. They require your
    special handling in implementing the same. Furthermore, they are usually design
    decisions that you need to make upfront in the process of data modeling. Perhaps
    it is the cost of the trade-off for the attainment of superb scalability, performance,
    and fault tolerance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cassandra独特的架构，关系型数据库中的许多简单事物，如序列和排序，不能假设。它们在实现时需要你特别处理。此外，它们通常是你在数据建模过程中需要提前做出的设计决策。这可能是在获得卓越的可伸缩性、性能和容错能力的过程中所付出的代价。
- en: To enjoy reading this book, you are advised to temporarily think in both relational
    and NoSQL ways. Although you may not become a friend of Cassandra, you will have
    an eye-opening experience in realizing the fact that there exists a different
    way of working in the world.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了享受阅读这本书，建议你暂时以关系型和NoSQL两种方式思考。尽管你可能不会成为Cassandra的朋友，但你将会有一个令人耳目一新的体验，意识到世界上存在不同的工作方式。
- en: What is unique to the Cassandra data model?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cassandra数据模型有什么独特之处？
- en: If you want me to use just one sentence to describe Cassandra's data model,
    I will say it is a non-relational data model, period. It implies that you need
    to forget the way you do data modeling in a relational database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果让我用一句话来描述Cassandra的数据模型，我会说它是一个非关系型数据模型，仅此而已。这意味着你需要忘记你在关系型数据库中进行数据建模的方式。
- en: You focus on modeling the data according to relational theories. However, in
    Cassandra and even in other NoSQL databases, you need to focus on the application
    in addition to the data itself. This means you need to think about how you will
    query the data in the application. It is a paradigm shift for those of you coming
    from the relational world. Examples are given in the subsequent sections to make
    sure that you understand why you cannot apply relational theories to model data
    in Cassandra.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据关系理论来建模数据。然而，在 Cassandra 以及其他 NoSQL 数据库中，除了数据本身之外，你还需要关注应用。这意味着你需要考虑在应用中如何查询数据。对于那些来自关系世界的人来说，这是一个范式转变。接下来的章节中会给出示例，以确保你理解为什么不能将关系理论应用于
    Cassandra 中的数据建模。
- en: Another important consideration in Cassandra data modeling is that you need
    to take the physical topology of a Cassandra cluster into account. In a relational
    database, the primary goal is to remove data duplication through normalization
    to have a single source of data. It makes a relational database ACID compliant
    very easily. The related storage space required is also optimized. Conversely,
    Cassandra is designed to work in a massive-scale, distributed environment in which
    ACID compliance is difficult to achieve, and replication is a must. You must be
    aware of such differences in the process of data modeling in Cassandra.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cassandra 数据建模中，另一个重要的考虑因素是你需要考虑 Cassandra 集群的物理拓扑。在关系型数据库中，主要目标是通过对数据进行规范化来消除数据冗余，以有一个单一的数据源。这使得关系型数据库很容易实现
    ACID 一致性。相关的存储空间需求也得到了优化。相反，Cassandra 是设计用于在难以实现 ACID 一致性和必须进行复制的海量规模分布式环境中工作。你必须意识到在
    Cassandra 数据建模过程中这些差异。
- en: Map and SortedMap
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map 和 SortedMap
- en: 'In [Chapter 1](ch01.html "Chapter 1. Bird''s Eye View of Cassandra"), *Bird''s
    Eye View of Cassandra*, you learned that Cassandra''s storage model is based on
    BigTable, a column-oriented store. A column-oriented store is a multidimensional
    map. Specifically, it is a data structure known as **Map**. An example of the
    declaration of map data structure is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章. Cassandra 的鸟瞰图") 中，你学习了 Cassandra 的存储模型是基于 BigTable，一个列式存储。列式存储是一个多维映射。具体来说，它是一个称为
    **Map** 的数据结构。以下是一个声明 Map 数据结构的示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Map` data structure gives efficient key lookup, and the sorted nature provides
    efficient scans. `RowKey` is a unique key and can hold a value. The inner `SortedMap`
    data structure allows a variable number of `ColumnKey` values. This is the trick
    that Cassandra uses to be schemaless and to allow the data model to evolve organically
    over time. It should be noted that each column has a client-supplied timestamp
    associated, but it can be ignored during data modeling. Cassandra uses the timestamp
    internally to resolve transaction conflicts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 数据结构提供了高效的关键字查找，并且其排序特性提供了高效的扫描。`RowKey` 是一个唯一键，可以存储一个值。内部的 `SortedMap`
    数据结构允许存储可变数量的 `ColumnKey` 值。这是 Cassandra 使用以实现无模式并且允许数据模型随时间自然演化的技巧。需要注意的是，每个列都有一个客户端提供的时间戳与之关联，但在数据建模过程中可以忽略。Cassandra
    在内部使用时间戳来解决事务冲突。'
- en: In a relational database, column names can be only strings and be stored in
    the table metadata. In Cassandra, both `RowKey` and `ColumnKey` can be strings,
    long integers, Universal Unique IDs, or any kind of byte arrays. In addition,
    `ColumnKey` is stored in each column. You may opine that it wastes storage space
    to repeatedly store the `ColumnKey` values. However, it brings us a very powerful
    feature of Cassandra. `RowKey` and `ColumnKey` can store data themselves and not
    just in `ColumnValue`. We will not go too deep into this at the moment; we will
    revisit it in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，列名只能是字符串，并存储在表元数据中。在 Cassandra 中，`RowKey` 和 `ColumnKey` 都可以是字符串、长整数、通用唯一标识符或任何类型的字节数组。此外，`ColumnKey`
    存储在每个列中。你可能认为反复存储 `ColumnKey` 值会浪费存储空间。然而，这为 Cassandra 带来了一个非常强大的特性。`RowKey` 和
    `ColumnKey` 可以存储数据，而不仅仅是 `ColumnValue`。我们目前不会深入探讨这一点；我们将在后面的章节中重新讨论。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Universal Unique ID**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用唯一标识符**'
- en: '**Universal Unique ID** (**UUID**) is an **Internet Engineering Task Force**
    (**IETF**) standard, **Request for Comments** (**RFC**) 4122, with the intent
    of enabling distributed systems to uniquely identify information without significant
    central coordination. It is a 128-bit number represented by 32 lowercase hexadecimal
    digits, displayed in five groups separated by hyphens, for example: `0a317b38-53bf-4cad-a2c9-4c5b8e7806a2`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用唯一标识符（UUID**）是**互联网工程任务组（IETF**）标准，**请求评论（RFC**）4122，旨在使分布式系统能够在不进行重大中央协调的情况下唯一标识信息。它是一个由32个小写十六进制数字表示的128位数字，以五组由连字符分隔的形式显示，例如：`0a317b38-53bf-4cad-a2c9-4c5b8e7806a2`'
- en: Logical data structure
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑数据结构
- en: There are a few logical building blocks to come up with a Cassandra data model.
    Each of them is introduced as follows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个逻辑构建块可以构建Cassandra数据模型。以下将逐一介绍它们。
- en: Column
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列
- en: 'Column is the smallest data model element and storage unit in Cassandra. Though
    it also exists in a relational database, it is a different thing in Cassandra.
    As shown in the following figure, a column is a name-value pair with a timestamp
    and an optional **Time-To-Live** (**TTL**) value:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列是Cassandra中最小的数据模型元素和存储单元。尽管它也存在于关系型数据库中，但在Cassandra中是不同的事物。如图所示，列是一个具有戳记和可选的**生存时间（Time-To-Live，TTL**）值的名称-值对：
- en: '![Column](img/8884OS_02_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![列](img/8884OS_02_01.jpg)'
- en: The elements of a column
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列的元素
- en: The name and the value (`ColumnKey` and `ColumnValue` in `SortedMap` respectively)
    are byte arrays, and Cassandra provides a bunch of built-in data types that influence
    the sort order of the values. The timestamp here is for conflict resolution and
    is supplied by the client application during a write operation. Time-To-Live is
    an optional expiration value used to mark the column deleted after expiration.
    The column is then physically removed during compaction.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和值（在`SortedMap`中分别为`ColumnKey`和`ColumnValue`）是字节数组，Cassandra提供了一组内置数据类型，这些数据类型会影响值的排序顺序。这里的戳记用于冲突解决，并在写入操作期间由客户端应用程序提供。生存时间（Time-To-Live）是一个可选的过期值，用于标记在过期后删除的列。然后，在压缩过程中物理删除该列。
- en: Row
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行
- en: 'One level up is a row, as depicted in the following figure. It is a set of
    orderable columns with a unique row key, also known as a primary key:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个级别是行，如图所示。它是一组具有唯一行键的可排序列，也称为主键：
- en: '![Row](img/8884OS_02_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![行](img/8884OS_02_02.jpg)'
- en: The structure of a row
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 行的结构
- en: The row key can be any one of the same built-in data types as those for columns.
    What orderable means is that columns are stored in sorted order by their column
    names.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 行键可以是与列相同的任何内置数据类型。可排序的意思是列按其列名排序存储。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sort order is extremely important because Cassandra cannot sort by value as
    we do in a relational database.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 排序顺序非常重要，因为Cassandra不能像我们在关系型数据库中那样按值排序。
- en: Different names in columns are possible in different rows. That is why Cassandra
    is both row oriented and column oriented. It should be remarked that there is
    no timestamp for rows. Moreover, a row cannot be split to store across two nodes
    in the cluster. It means that if a row exists on a node, the entire row exists
    on that node.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不同行中的列可能有不同的名称。这就是为什么Cassandra既是行导向又是列导向。应该指出的是，行没有戳记。此外，行不能分割以存储在集群的两个节点之间。这意味着如果行存在于一个节点上，整个行都存在于该节点上。
- en: Column family
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列族
- en: 'The next level up is a column family. As shown in the following figure, it
    is a container for a set of rows with a name:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个级别是列族。如图所示，它是一个具有名称的行集合的容器：
- en: '![Column family](img/8884OS_02_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![列族](img/8884OS_02_03.jpg)'
- en: The structure of a column family
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列族的结构
- en: The row keys in a column family must be unique and are used to order rows. A
    column family is analogous to a table in a relational database, but you should
    not go too far with this idea. A column family provides greater flexibility by
    allowing different columns in different rows. Any column can be freely added to
    any column family at any time. Once again, it helps Cassandra be schemaless.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列族中的行键必须是唯一的，并用于排序。列族在关系型数据库中类似于表，但你不应该过分依赖这个想法。列族通过允许不同行中的不同列提供了更大的灵活性。任何列都可以在任何时候自由添加到任何列族中。再次强调，这有助于Cassandra的无模式性。
- en: Columns in a column family are sorted by a comparator. The comparator determines
    how columns are sorted and ordered when Cassandra returns the columns in a query.
    It accepts long, byte and UTF8 for the data type of the column name, and the sort
    order in which columns are stored within a row.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列族中的列按比较器排序。比较器决定了Cassandra在查询中返回列时的排序和顺序。它接受列名的数据类型为长整型、字节和UTF8，以及列在行内存储的排序顺序。
- en: Physically, column families are stored in individual files on a disk. Therefore,
    it is important to keep related columns in the same column family to save disk
    I/O and improve performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 物理上，列族存储在磁盘上的单个文件中。因此，保持相关列在同一个列族中对于节省磁盘I/O和提高性能很重要。
- en: Keyspace
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键空间
- en: 'The outermost data model element is keyspace, as illustrated in the following
    figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示图所示，最外层数据模型元素是键空间：
- en: '![Keyspace](img/8884OS_02_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![键空间](img/8884OS_02_04.jpg)'
- en: The structure of a keyspace
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 键空间的结构
- en: Keyspace is a set of column families and super column families, which will be
    introduced in the following section. It is analogous to a schema or database in
    the relational world. Each Cassandra instance has a system keyspace to keep system-wide
    metadata.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 键空间是一组列族和超列族，将在下一节中介绍。它在关系世界中类似于模式或数据库。每个Cassandra实例都有一个系统键空间来存储系统级元数据。
- en: Keyspace contains replication settings controlling how data is distributed and
    replicated in the cluster. Very often, one cluster contains just one keyspace.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 键空间包含复制设置，控制数据在集群中的分布和复制方式。通常，一个集群中只有一个键空间。
- en: Super column and super column family
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超列和超列族
- en: 'As shown in the following figure, a super column is a named map of columns
    and a super column family is just a collection of super columns:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示图所示，超列是一组列的命名映射，而超列族只是超列的集合：
- en: '![Super column and super column family](img/8884OS_02_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![超列和超列族](img/8884OS_02_05.jpg)'
- en: The structure of a super column and a super column family
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 超列和超列族的结构
- en: Super columns were popular in the earlier versions of Cassandra but are not
    recommended anymore since they are not supported by the Cassandra Query Language
    (CQL), a SQL-like language to manipulate and query Cassandra, and must be accessed
    by using the low-level Thrift API. A column family is enough in most cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 超列在Cassandra的早期版本中很受欢迎，但不再推荐使用，因为它们不受Cassandra查询语言（CQL），一种类似于SQL的语言来操作和查询Cassandra的支持，并且必须通过使用低级的Thrift
    API来访问。在大多数情况下，一个列族就足够了。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Thrift**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thrift**'
- en: Thrift is a software framework for the development of scalable cross-language
    services. It combines a software stack with a code generation engine to build
    services that work efficiently and seamlessly with numerous programming languages.
    It is used as a **remote procedure call** (**RPC**) framework and was developed
    at Facebook Inc. It is now an open source project in the Apache Software Foundation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Thrift 是一个用于开发可扩展跨语言服务的软件框架。它结合了一个软件栈和一个代码生成引擎来构建与多种编程语言高效且无缝工作的服务。它被用作 **远程过程调用**
    (**RPC**) 框架，并由Facebook公司开发。现在它是Apache软件基金会的一个开源项目。
- en: There are other alternatives, for example, Protocol Buffers, Avro, MessagePack,
    JSON, and so on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他替代方案，例如，Protocol Buffers、Avro、MessagePack、JSON等等。
- en: Collections
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Cassandra allows collections, namely sets, lists, and maps, as parts of the
    data model. Collections are a complex type that can provide flexibility in querying.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 允许集合，即集合、列表和映射，作为数据模型的一部分。集合是一种复杂类型，可以在查询中提供灵活性。
- en: 'Cassandra allows the following collections:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra 允许以下集合：
- en: '**Sets**: These provide a way of keeping a unique set of values. It means that
    one can easily solve the problem of tracking unique values.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：这些提供了一种保持唯一值集的方法。这意味着可以轻松解决跟踪唯一值的问题。'
- en: '**Lists**: These are suitable for maintaining the order of the values in the
    collection. Lists are ordered by the natural order of the type selected.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：这些适合维护集合中值的顺序。列表按所选类型的自然顺序排序。'
- en: '**Maps**: These are similar to a store of key-value pairs. They are useful
    for storing table-like data within a single row. They can be a workaround of not
    having joins.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：这些类似于键值对的存储。它们对于在单行内存储类似表的数据很有用。它们可以作为一种在没有连接的情况下存储数据的解决方案。'
- en: Here we only provided a brief introduction, and we will revisit the collections
    in subsequent chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只提供了一个简要的介绍，我们将在后续章节中重新讨论集合。
- en: No foreign key
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有外键
- en: Foreign keys are used in a relational database to maintain referential integrity
    that defines the relationship between two tables. They are used to enforce relationships
    in a relational data model such that the data in different but related tables
    can be joined to answer a query. Cassandra does not have the concept of referential
    integrity and hence, joins are not allowed either.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 外键在关系数据库中用于维护引用完整性，这定义了两个表之间的关系。它们用于在关系数据模型中强制关系，以便不同但相关的表中的数据可以连接起来以回答查询。Cassandra没有引用完整性的概念，因此不允许连接。
- en: No join
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无连接
- en: Foreign keys and joins are the product of normalization in a relational data
    model. Cassandra has neither foreign keys nor joins. Instead, it encourages and
    performs best when the data model is denormalized.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 外键和连接是关系数据模型中规范化的产物。Cassandra既没有外键也没有连接。相反，它鼓励并在此数据模型去规范化时表现最佳。
- en: Indeed, denormalization is not completely disallowed in the relational world,
    for example, a data warehouse built on a relational database. In practice, denormalization
    is a solution to the problem of poor performance of highly complex relational
    queries involving a large number of table joins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在关系型世界中，去规范化并非完全被禁止，例如，建立在关系数据库之上的数据仓库。在实践中，去规范化是解决高度复杂的关系型查询性能不佳的问题的一种解决方案，这些查询涉及大量表连接。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Cassandra, denormalization is normal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cassandra中，去规范化是正常的。
- en: Foreign keys and joins can be avoided in Cassandra with proper data modeling.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过适当的数据建模，可以在Cassandra中避免外键和连接。
- en: No sequence
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无序列
- en: 'In a relational database, sequences are usually used to generate unique values
    for a surrogate key. Cassandra has no sequences because it is extremely difficult
    to implement in a peer-to-peer distributed system. There are however workarounds,
    which are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，序列通常用于为代理键生成唯一值。Cassandra没有序列，因为它在点对点分布式系统中实现起来极其困难。然而，有一些解决方案，如下所述：
- en: Using part of the data to generate a unique key
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用部分数据生成唯一键
- en: Using a UUID
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UUID
- en: In most cases, the best practice is to select the second workaround.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最佳实践是选择第二个解决方案。
- en: Counter
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数器
- en: A counter column is a special column used to store a number that keeps counting
    values. Counting can be either increment or decrement and timestamp is not required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计数列是一个特殊列，用于存储持续计数的数值。计数可以是增加或减少，且不需要时间戳。
- en: The counter column should not be used to generate surrogate keys. It is just
    designed to hold a distributed counter appropriate for distributed counting. Also
    bear in mind that updating a counter is not idempotent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计数列不应用于生成代理键。它只是设计用来存储适合分布式计数的分布式计数器。同时请注意，更新计数器不是幂等的。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Idempotent**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等（Idempotent**）'
- en: Idempotent was originally a term in mathematics. But in computer science, idempotent
    is used more comprehensively to describe an operation that will produce the same
    results if executed once or multiple times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等最初是数学中的一个术语。但在计算机科学中，幂等被更广泛地用来描述一个操作，如果执行一次或多次，将产生相同的结果。
- en: Time-To-Live
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存活时间（Time-To-Live）
- en: '**Time-To-Live** (**TTL**) is set on columns only. The unit is in seconds.
    When set on a column, it automatically counts down and will then be expired on
    the server side without any intervention of the client application.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**存活时间（TTL**）仅在列上设置。单位是秒。当在列上设置时，它将自动递减，然后在服务器端自动过期，无需客户端应用程序的任何干预。'
- en: Typical use cases are for the generation of security token and one-time token,
    automatic purging of outdated columns, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 典型用例包括生成安全令牌和一次性令牌、自动清除过时的列等。
- en: Secondary index
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二级索引
- en: One important thing you need to remember is that the secondary index in Cassandra
    is not identical to that in a relational database. The secondary index in Cassandra
    can be created to query a column that is not a part of the primary key. A column
    family can have more than one secondary index. Behind the scenes, it is implemented
    as a separate hidden table which is maintained automatically by Cassandra's internal
    process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一个重要事项是，Cassandra中的二级索引与关系数据库中的二级索引并不相同。Cassandra中的二级索引可以创建来查询不是主键部分的列。一个列族可以拥有多个二级索引。在幕后，它被实现为一个由Cassandra内部进程自动维护的独立隐藏表。
- en: The secondary index does not support collections and cannot be created on the
    primary key itself. The major difference between a primary key and a secondary
    index is that the former is a distributed index while the latter is a local index.
    The primary key is used to determine the node location and so, for a given row
    key, its node location can be found immediately. However, the secondary index
    is used just to index data on the local node, and it might not be possible to
    know immediately the locations of all matched rows without having examined all
    the nodes in the cluster. Hence, the performance is unpredictable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 二级索引不支持集合，并且不能创建在主键本身上。主键和二级索引之间的主要区别在于，前者是一个分布式索引，而后者是一个本地索引。主键用于确定节点位置，因此对于给定的行键，其节点位置可以立即找到。然而，二级索引仅用于在本地节点上索引数据，并且可能无法立即知道所有匹配行的位置，除非检查了集群中的所有节点。因此，性能是不可预测的。
- en: More information on secondary keys will be provided as we go through the later
    chapters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将提供有关二级索引的更多信息。
- en: Modeling by query
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询建模
- en: In the previous section, we gained a basic understanding of the differences
    between a relational database and Cassandra. The most important difference is
    that a relational database models data by relationships whereas Cassandra models
    data by query. Now let us start with a simple example to look into what modeling
    by query means.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们获得了关于关系型数据库和Cassandra之间差异的基本理解。最重要的差异是，关系型数据库通过关系来建模数据，而Cassandra通过查询来建模数据。现在让我们从一个简单的例子开始，看看查询建模意味着什么。
- en: Relational version
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系版本
- en: 'The following figure shows a simple relational data model of a stock quote
    application:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了股票报价应用的简单关系数据模型：
- en: '![Relational version](img/8884OS_02_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![关系版本](img/8884OS_02_06.jpg)'
- en: 'The relational data model of a stock quote application (Source: Yahoo! Finance)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 股票报价应用的关系数据模型（来源：Yahoo! Finance）
- en: The `stock_symbol` table is an entity representing the stock master information
    such as the symbol of a stock, the description of the stock, and the exchange
    that the stock is traded. The `stock_ticker` table is another entity storing the
    prices of `open`, `high`, `low`, `close`, and the transacted `volume` of a stock
    on a trading day. Obviously the two tables have a relationship based on the `symbol`
    column. It is a well-known one-to-many relationship.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_symbol`表是一个实体，代表股票主信息，如股票的符号、股票的描述以及股票交易的交易所。`stock_ticker`表是另一个实体，存储股票在交易日的开盘价、最高价、最低价、收盘价和成交量的价格。显然，这两个表基于`symbol`列存在关系。这是一个众所周知的一对多关系。'
- en: 'The following is the **Data Definition Language** (**DDL**) of the two tables:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个表是**数据定义语言**（**DDL**）：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Consider the following three cases: first, we want to list out all stocks and
    their description in all exchanges. The SQL query for this is very simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三种情况：首先，我们想要列出所有交易所中所有股票及其描述。这个SQL查询非常简单：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Second, if we want to know all the daily close prices and descriptions of the
    stocks listed in the `NASDAQ` exchange, we can write a SQL query as:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果我们想知道纳斯达克交易所上市的所有股票的每日收盘价和描述，我们可以编写以下SQL查询：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, if we want to know all the day close prices and descriptions of
    the stocks listed in the `NASDAQ` exchange on April 24, 2014, we can use the following
    SQL query:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想知道2014年4月24日纳斯达克交易所上市的所有股票的每日收盘价和描述，我们可以使用以下SQL查询：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By virtue of the relational data model, we can simply write different SQL queries
    to return different results with no changes to the underlying data model at all.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 依靠关系数据模型，我们可以简单地编写不同的SQL查询来返回不同的结果，而无需对底层数据模型进行任何更改。
- en: Cassandra version
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cassandra版本
- en: 'Now let us turn to Cassandra. The DDL statements in the last section can be
    slightly modified to create column families, or tables, in Cassandra, which are
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向Cassandra。上一节中的DDL语句可以稍作修改，以在Cassandra中创建列族，或表，如下所示：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: They seem to be correct at first sight.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它们乍一看似乎是正确的。
- en: 'As for `Query A`, we can query the Cassandra `stock_symbol` table exactly the
    same way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`查询A`，我们可以以完全相同的方式查询Cassandra的`stock_symbol`表：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following figure depicts the logical and physical storage views of the
    `stock_symbol` table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了`stock_symbol`表的逻辑和物理存储视图：
- en: '![Cassandra version](img/8884OS_02_07.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Cassandra版本](img/8884OS_02_07.jpg)'
- en: The Cassandra data model for Query A
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查询A的Cassandra数据模型
- en: 'The primary key of the `stock_symbol` table involves only one single column,
    `symbol`, which is also used as the row key and partition key of the column family.
    We can consider the `stock_symbol` table in terms of the SortedMap data structure
    mentioned in the previous section:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_symbol`表的主键只涉及一个单独的列，`symbol`，它也用作列族的行键和分区键。我们可以将`stock_symbol`表视为前一小节中提到的排序映射数据结构：'
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The assigned values are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的值如下：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So far so good, right?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，对吧？
- en: However, without foreign keys and joins, how can we obtain the same results
    for `Query B` and `Query C` in Cassandra? It indeed highlights that we need another
    way to do so. The short answer is to use denormalization.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有外键和连接，我们如何在Cassandra中获取`Query B`和`Query C`相同的查询结果？这确实突显了我们需要另一种方式来做。简短的答案是使用反规范化。
- en: For `Query B`, what we want is all the day close prices and descriptions of
    the stocks listed in the `NASDAQ` exchange. The columns involved are `symbol`,
    `description`, `tick_date`, `close`, and `exchange`. The first four columns are
    obvious, but why do we need the `exchange` column? The `exchange` column is necessary
    because it is used as a filter for the query. Another implication is that the
    `exchange` column is required to be the row key, or at least part of the row key.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Query B`，我们想要的是在纳斯达克交易所上市的股票的当日收盘价和描述。涉及的列有`symbol`、`description`、`tick_date`、`close`和`exchange`。前四列很明显，但为什么我们需要`exchange`列呢？`exchange`列是作为查询的过滤器的必要条件。另一个含义是，`exchange`列必须是行键，或者至少是行键的一部分。
- en: 'Remember two rules:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住两个规则：
- en: A row key is regarded as a partition key to locate the nodes storing that row
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行键被视为分区键以定位存储该行的节点。
- en: A row cannot be split across two nodes
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行不能跨越两个节点。
- en: In a distributed system backed by Cassandra, we should minimize unnecessary
    network traffic as much as possible. In other words, the lesser the number of
    nodes the query needs to work with, the better the performance of the data model.
    We must cater to the cluster topology as well as the physical storage of the data
    model.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在由Cassandra支持的分布式系统中，我们应该尽可能减少不必要的网络流量。换句话说，查询需要与之交互的节点越少，数据模型的表现就越好。我们必须迎合集群拓扑以及数据模型的物理存储。
- en: 'Therefore we should create a column family for `Query B` similar to the previous
    one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该为`Query B`创建一个类似于之前的列族：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The logical and physical storage views of `stock_ticker_by_exchange` are shown
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_ticker_by_exchange`的逻辑和物理存储视图如下所示：'
- en: '![Cassandra version](img/8884OS_02_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Cassandra版本](img/8884OS_02_08.jpg)'
- en: The Cassandra data model for Query B
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query B`的Cassandra数据模型'
- en: The row key is the `exchange` column. However, this time, it is very strange
    that the column keys are no longer `symbol`, `tick_date`, `close`, and `description`.
    There are now 12 columns including `APPL:2014-04-24:`, `APPL:2014-04-24:close`,
    `APPL:2014-04-24:description`, `APPL:2014-04-25:`, `APPL:2014-04-25:close`, `APPL:2014-04-25:description`,
    `FB:2014-04-24:`, `FB:2014-04-24:close`, `FB:2014-04-24:description`, `FB:2014-04-25:`,
    `FB:2014-04-25:close`, and `FB:2014-04-25:description`, respectively. Most importantly,
    the column keys are now dynamic and are able to store data in just a single row.
    The row of this dynamic usage is called a wide row, in contrast to the row containing
    static columns of the `stock_symbol` table—termed as a skinny row.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 行键是`exchange`列。然而，这次，列键不再是`symbol`、`tick_date`、`close`和`description`。现在有12个列，包括`APPL:2014-04-24:`、`APPL:2014-04-24:close`、`APPL:2014-04-24:description`、`APPL:2014-04-25:`、`APPL:2014-04-25:close`、`APPL:2014-04-25:description`、`FB:2014-04-24:`、`FB:2014-04-24:close`、`FB:2014-04-24:description`、`FB:2014-04-25:`、`FB:2014-04-25:close`和`FB:2014-04-25:description`，分别。最重要的是，列键现在是动态的，并且能够在单行中存储数据。这种动态使用的行称为宽行，与包含`stock_symbol`表静态列的行相对——称为瘦行。
- en: Whether a column family stores a skinny row or a wide row depends on how the
    primary key is defined.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列族存储的是瘦行还是宽行，取决于主键是如何定义的。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the primary key contains only one column, the row is a skinny row.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主键只包含一个列，则行是一个瘦行。
- en: If the primary key contains more than one column, it is called a compound primary
    key and the row is a wide row.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主键包含多个列，则称为复合主键，行就是一个宽行。
- en: In either case, the first column in the primary key definition is the row key.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，主键定义中的第一列都是行键。
- en: Finally, we come to `Query C`. Similarly, we make use of denormalization. `Query
    C` differs from `Query B` by an additional date filter on April 24, 2014\. You
    might think of reusing the `stock_ticker_by_exchange` table for `Query C`. The
    answer is wrong. Why? The clue is the primary key which is composed of three columns,
    `exchange`, `symbol`, and `tick_date`, respectively. If you look carefully at
    the column keys of the `stock_ticker_by_exchange` table, you find that the column
    keys are dynamic as a result of the `symbol` and `tick_date` columns. Hence, is
    it possible for Cassandra to determine the column keys without knowing exactly
    which symbols you want? Negative.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了 `Query C`。同样，我们使用了反规范化。`Query C` 与 `Query B` 的不同之处在于在2014年4月24日添加了一个额外的日期过滤器。你可能认为可以重用
    `stock_ticker_by_exchange` 表来处理 `Query C`。答案是错误的。为什么？线索是主键，它由三个列组成，分别是 `exchange`、`symbol`
    和 `tick_date`。如果你仔细观察 `stock_ticker_by_exchange` 表的列键，你会发现由于 `symbol` 和 `tick_date`
    列的存在，列键是动态的。因此，Cassandra是否能够在不知道你确切想要哪些符号的情况下确定列键？否定。
- en: 'A suitable column family for `Query C` should resemble the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `Query C` 选择合适的列族应类似于以下代码：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This time you should be aware of the definition of the primary key. It is interesting
    that there is an additional pair of parentheses for the `exchange` and `tick_date`
    columns. Let''s look at the logical and physical storage views of `stock_ticker_by_exchange_date`,
    as shown in the following figure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你应该注意主键的定义了。有趣的是，`exchange` 和 `tick_date` 列还有一个额外的括号。让我们看看 `stock_ticker_by_exchange_date`
    的逻辑和物理存储视图，如图所示：
- en: '![Cassandra version](img/8884OS_02_09.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![Cassandra版本](img/8884OS_02_09.jpg)'
- en: The Cassandra data model for Query C
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query C` 的Cassandra数据模型'
- en: You should pay attention to the number of column keys here. It is only six instead
    of 12 as in `stock_ticker_by_exchange` for `Query B`. The column keys are still
    dynamic according to the `symbol` column but the row key is now `NASDAQ:2014-04-24`
    instead of just `NASDAQ` in `Query B`. Do you remember the previously mentioned
    additional pair of parentheses? If you define a primary key in that way, you intend
    to use more than one column to be the row key and the partition key. It is called
    a composite partition key. For the time being, it is enough for you to know the
    terminology only. Further information will be given in later chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意这里的列键数量。它只有六个，而不是 `stock_ticker_by_exchange` 的 `12` 个。列键仍然是根据 `symbol`
    列动态的，但行键现在是 `NASDAQ:2014-04-24`，而不是 `Query B` 中的仅仅 `NASDAQ`。你还记得之前提到的额外一对括号吗？如果你以这种方式定义主键，你打算使用多个列作为行键和分区键。这被称为复合分区键。目前，你只需要知道这个术语即可。更多信息将在后面的章节中给出。
- en: Until now, you might have felt dizzy and uncomfortable, especially for those
    of you having so many years of expertise in the relational data model. I also
    found the Cassandra data model very difficult to comprehend at the first time.
    However, you should be aware of the subtle differences between a relational data
    model and Cassandra data model. You must also be very cautious of the query that
    you handle. A query is always the starting point of designing a Cassandra data
    model. As an analogy, a query is a question and the data model is the answer.
    You merely use the data model to answer the query. It is exactly what modeling
    by query means.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经感到头晕目眩，尤其是对于那些在关系数据模型方面有多年经验的人。我也发现Cassandra数据模型在第一次接触时非常难以理解。然而，你应该意识到关系数据模型和Cassandra数据模型之间的细微差别。你必须非常小心地处理你的查询。查询始终是设计Cassandra数据模型的起点。作为一个类比，查询是一个问题，数据模型是答案。你只是使用数据模型来回答查询。这正是查询建模的含义。
- en: Data modeling considerations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模考虑因素
- en: Apart from modeling by query, we need to bear in mind a few important points
    when designing a Cassandra data model. We can also consider a few good patterns
    that will be introduced in this section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查询建模之外，在设计Cassandra数据模型时，我们还需要牢记一些重要的要点。我们还可以考虑一些在本节中将要介绍的良好模式。
- en: Data duplication
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据重复
- en: Denormalization is an evil in a relational data model, but not in Cassandra.
    Indeed, it is a good and common practice. It is solely based on the fact that
    Cassandra does not use high-end disk storage subsystem. Cassandra loves commodity-grade
    hard drives, and hence disk space is cheap. Data duplication as a result of denormalization
    is by no means a problem anymore; Cassandra welcomes it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a relational database, sorting can be easily controlled using the `ORDER
    BY` clause in a SQL query. Alternatively, a secondary index can be created to
    further speed up the sorting operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: In Cassandra, however, sorting is by design because you must determine how to
    compare data for a column family at the time of its creation. The comparator of
    the column family dictates how the rows are ordered on reads. Additionally, columns
    are ordered by their column names, also by a comparator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Wide row
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common to use wide rows for ordering, grouping and efficient filtering.
    Besides, you can use skinny rows. All you have to consider is the number of columns
    the row contains.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that for a column family storing skinny rows, the column
    key is repeatedly stored in each column. Although it wastes some storage space,
    it is not a problem on inexpensive commodity hard disks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Bucketing
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though a wide row can accommodate up to 2 billion variable columns, it
    is still a hard limit that cannot prevent voluminous data from filling up a node.
    In order to break through the 2 billion column limit, we can use a workaround
    technique called bucketing to split the data across multiple nodes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Bucketing requires the client application to generate a bucket ID, which is
    often a random number. By including the bucket ID into a composite partition key,
    you can break up and distribute segments of the data to different nodes. However,
    it should not be abused. Breaking up the data across multiple nodes causes reading
    operations to consume extra resources to merge and reorder data. Thus, it is expensive
    and not a favorable method, and therefore should only be a last resort.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Valueless column
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Column keys can store values as shown in the *Modeling by query* section. There
    is no "Not Null" concept in Cassandra such that column values can store empty
    values without any problem. Simply storing data in column keys while leaving empty
    values in the column, known as a valueless column, is sometimes used purposely.
    It's a common practice with Cassandra.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: One motivation for valueless columns is the sort-by-column-key feature of Cassandra.
    Nonetheless, there are some limitations and caveats. The maximum size of a column
    key is 64 KB, in contrast to 2 GB for a column value. Therefore, space in a column
    key is limited. Furthermore, using timestamp alone as a column key can result
    in timestamp collision.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Time-series data
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is time-series data? It is anything that varies on a temporal basis such
    as processor utilization, sensor data, clickstream, and stock ticker. The stock
    quote data model introduced earlier is one such example. Cassandra is a perfect
    fit for storing time-series data. Why? Because one row can hold as many as 2 billion
    variable columns. It is a single layout on disk, based on the storage model. Therefore,
    Cassandra can handle voluminous time-series data in a blazing fast fashion. TTL
    is another excellent feature to simplify data housekeeping.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the second half of this book, a complete stock quote technical analysis application
    will be developed to further explain the details of using Cassandra to handle
    time-series data.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra Query Language
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is quite common for other authors to start introducing the Cassandra data
    model from CQL. I use a different approach in this chapter. I try to avoid diving
    too deep in CQL before we have a firm understanding of how Cassandra handles its
    physical storage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of CQL is designed to be very similar to that of SQL. This intent
    is good for someone who is used to writing SQL statements in the relational world,
    to migrate to Cassandra. However, because of the high degree of similarity between
    CQL and SQL, it is even more difficult for us to throw away the relational mindsets
    if CQL is used to explain how to model data in Cassandra. It might cause more
    confusion in the end. I prefer the approach of a microscopic view of how the data
    model relates to the physical storage. By doing so, you can grasp the key points
    more quickly and understand the inner working mechanism more clearly. CQL is covered
    extensively in the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the basics of a Cassandra data model and are now
    familiar with the column, row, column family, keyspace, counter, and other related
    terms. A comparison of the main differences between a relational data model and
    the Cassandra data model was also given to explain the concept of modeling by
    query that may seem shocking and counterintuitive at first sight. Then a few important
    considerations on data modeling and typical usage patterns were introduced. Finally,
    the reason why the introduction of CQL is deliberately postponed was expressed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is only the first part on Cassandra data modeling. In the next
    chapter, we will continue the second part of the tour, Cassandra Query Language.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
