<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-113"><a id="_idTextAnchor124"/>5</h1>
<h1 id="_idParaDest-114"><a id="_idTextAnchor125"/>Joining and Comparing iSAX Indexes</h1>
<p>In the previous chapter, we developed a Python package called <code>isax</code> that creates iSAX indexes for indexing the subsequences of a time series given a sliding window.</p>
<p>In this chapter, we are going to experiment with how the sliding window size affects the number of splits and the number of accesses to subsequences while creating an iSAX index.</p>
<p>Then, we are going to use the iSAX indexes created by the <code>isax</code> package and try to join and compare them. By <em class="italic">comparing</em>, we aim to understand the efficiency of an iSAX index, and by <em class="italic">joining</em>, we mean being able to find similar nodes in two iSAX indexes based on SAX representations.</p>
<p>The last part of this chapter is going to briefly discuss Python testing before developing simple tests for the <code>isax</code> package. <em class="italic">Testing is a serious part of the development process and should not be overlooked</em>. The time spent writing tests is time well spent!</p>
<p>In this chapter, we are going to cover the following main topics:</p>
<ul>
<li>How the sliding window size affects the iSAX construction speed</li>
<li>Checking the search speed of iSAX indexes</li>
<li>Joining iSAX indexes</li>
<li>Implementing the joining of iSAX indexes</li>
<li>Explaining the Python code</li>
<li>Using the Python code</li>
<li>Writing Python tests</li>
</ul>
<h1 id="_idParaDest-115"><a id="_idTextAnchor126"/>Technical requirements</h1>
<p>The GitHub repository for this book can be found at <a href="https://github.com/PacktPublishing/Time-Series-Indexing">https://github.com/PacktPublishing/Time-Series-Indexing</a>. The code for each chapter is in its own directory. Therefore, the code for this chapter can be found in the <code>ch05</code> folder. You can download the entire repository on your computer using <code>git(1)</code> or you can access the desired files via the GitHub user interface.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor127"/>How the sliding window size affects the iSAX construction speed</h1>
<p>In this section, we <a id="_idIndexMarker310"/>are going to continue working with the <code>accessSplit.py</code> utility we developed in the previous <a id="_idIndexMarker311"/>chapter to find out whether the sliding window size affects the construction speed of an iSAX index, provided that the remaining iSAX parameters stay the same.</p>
<p>Put simply, we will use different methods to find out more about the quality of iSAX indexes and whether the sliding window size affects the construction speed. We are going to perform our experiments using the following sliding window sizes: <code>16</code>, <code>256</code>, <code>1024</code>, <code>4096</code>, and <code>16384</code>. We are going to experiment using the <code>500k.gz</code> time series from <a href="B14769_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>, 8 segments, a maximum cardinality value of <code>32</code>, and a threshold value of <code>500</code>.</p>
<p>For the window size of <code>16</code>, the results are the following:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 -t 500 -w 16 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 500 Default Promotion: False
Number of splits: 1376
Number of subsequence accesses: 2776741</pre>
<p>For the sliding window size of <code>256</code>, the results are the following:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 -t 500 -w 256 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 256 Threshold: 500 Default Promotion: False
Number of splits: 4234
Number of subsequence accesses: 10691624</pre>
<p>Compared<a id="_idIndexMarker312"/> to the sliding window size of <code>16</code>, the iSAX index created using a sliding window size of <code>256</code> had more than<a id="_idIndexMarker313"/> three times the number of splits and four times the number of subsequence accesses.</p>
<p>Next, for the window size of <code>1024</code>, the results are the following:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 -t 500 -w 1024 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 1024 Threshold: 500 Default Promotion: False
Number of splits: 5983
Number of subsequence accesses: 15403024</pre>
<p>As before, we have more splits than the <code>16</code> and <code>256</code> sliding window sizes and more subsequence accesses. Put simply, it took more CPU time for this iSAX index to be constructed.</p>
<p>Next, for the window size of <code>4096</code>, the results are the following:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 -t 500 -w 4096 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 4096 Threshold: 500 Default Promotion: False
OVERFLOW: 10000_10000_01111_01111_01111_10000_10000_01111
Number of splits: 6480
Number of subsequence accesses: 18537820</pre>
<p>In this case, it is not only <a id="_idIndexMarker314"/>slower to construct the iSAX index but we also have an <code>500.gz</code> time series are not going to fit into an iSAX index with these parameters and we are going to need to use different iSAX parameters for the iSAX index to work.</p>
<p class="callout-heading">Do overflows have an impact on the construction of iSAX indexes?</p>
<p class="callout">When we <a id="_idIndexMarker315"/>have one or multiple overflows on an iSAX index, it means that the full cardinality has been used on all SAX words—recall that the number of SAX words is defined by the number of segments. Therefore, we have multiple splits on terminal nodes that are fully based on the current threshold value, which means that we have many more subsequence accesses than usual. Therefore, overflows have a great impact on the construction time of iSAX indexes. Additionally, as if this were not bad enough, we have to find new iSAX parameters that prevent the overflow from happening while keeping the iSAX operation efficient. Keep in mind that the number of splits is also a naïve indication of how close we are to an overflow.</p>
<p>Lastly, for<a id="_idIndexMarker316"/> the biggest<a id="_idIndexMarker317"/> window size (<code>16384</code>), the results are the following:</p>
<pre class="source-code">
$ ./accessSplit.py -s 8 -c 32 -t 500 -w 16384 500k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16384 Threshold: 500 Default Promotion: False
OVERFLOW: 01111_10000_10000_01111_10000_01111_10000_01111
Number of splits: 6996
Number of subsequence accesses: 19201125</pre>
<p>Once again, we have an overflow situation with the sliding window size of <code>16384</code>, this time on a different SAX representation. We are going to leave both overflows as they are and create some plots of the results. The resolution of the overflows is left as an exercise for you.</p>
<p><em class="italic">Figure 5</em><em class="italic">.1</em> shows the number of splits per sliding window size where we can see that the bigger the sliding window size, the larger the number of splits that take place for that particular time series.</p>
<div><div><img alt="Figure 5.1– Splits per sliding window size plot" height="839" src="img/Figure_5.1_B14769.jpg" width="1391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1– Splits per sliding window size plot</p>
<p><em class="italic">Figure 5</em><em class="italic">.2</em> shows <a id="_idIndexMarker318"/>the number of<a id="_idIndexMarker319"/> subsequence accesses per sliding window size. In this case, instead of plotting the absolute number of subsequence accesses, we divide the number of total subsequence accesses by the total number of subsequences to display a fraction. This is a fair calculation as bigger time series have a larger number of subsequences.</p>
<div><div><img alt="Figure 5.2 – Subsequence accesses percentage per sliding window size plot" height="836" src="img/Figure_5.2_B14769.jpg" width="1391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Subsequence accesses percentage per sliding window size plot</p>
<p>In <em class="italic">Figure 5</em><em class="italic">.2</em>, we <a id="_idIndexMarker320"/>can see that the bigger the sliding window size, the bigger the number of subsequence accesses. For the smallest <a id="_idIndexMarker321"/>sliding window (<code>16</code>), we have about eight times fewer accesses to the subsequence of the time series compared to the largest sliding window (<code>16384</code>).</p>
<p>The construction speed of an iSAX index is one important factor. However, it is not the only criterion for the quality of iSAX indexes. The next section investigates the search speed of iSAX indexes.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor128"/>Checking the search speed of iSAX indexes</h1>
<p>This <a id="_idIndexMarker322"/>section presents a utility that takes two time series, named <code>TS1</code> and <code>TS2</code>, which ideally have<a id="_idIndexMarker323"/> similar lengths, creates two iSAX indexes, named <code>D1</code> and <code>D2</code>, and performs the following searches:</p>
<ul>
<li>Searches <code>D1</code> for all the subsequences of <code>TS2</code>. In this case, we are not sure whether a subsequence from <code>TS2</code> is in <code>D1</code> or not. In most cases, <em class="italic">we are not going to be able to find the subsequences of TS2 in TS1</em>. This is the main reason that a <em class="italic">join</em> based on the SAX representations of the iSAX nodes might be more appropriate when looking for similarities between subsequences.</li>
<li>Searches <code>D2</code> for all the subsequences of <code>TS1</code>. In this case, we are not sure whether a subsequence from <code>TS1</code> is in <code>D2</code> or not. As before, in most cases, we are <a id="_idIndexMarker324"/>not going to be able to find the subsequences of <code>TS1</code> in <code>TS2</code> and therefore, in the iSAX index created from <code>TS2</code> (<code>D2</code>).</li>
<li>Searches <code>D1</code> for<a id="_idIndexMarker325"/> all the subsequences of <code>TS1</code>, which means that all subsequences of <code>TS1</code> are in <code>D1</code>. With that test, we just want to discover more about the speed of an iSAX index when performing search operations. This search operation mainly depends on the threshold size because a bigger threshold value means more subsequences to look for once we come to the appropriate terminal node.</li>
<li>Searches <code>D2</code> for all the subsequences of <code>TS2</code>, which means that all subsequences of <code>TS2</code> are in <code>D2</code> and are going to be found.</li>
</ul>
<p>All these searches are implemented in a Python script named <code>speed.py</code>.</p>
<p>The core functionality of <code>speed.py</code> is implemented in functions. The first function contains the following code:</p>
<pre class="source-code">
def createISAX(file, w, s):
    # Read Sequence as Pandas
    ts = pd.read_csv(file, names=['values'],
        compression='gzip').astype(np.float64)
    # Convert to NParray
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    ISAX = isax.iSAX()
    ISAX.length = length
    # Split sequence into subsequences
    for i in range(length - w + 1):
        # Get the subsequence
        ts = ts_numpy[i:i+w]
        # Create new TS node based on ts
        ts_node = isax.TS(ts, s)
        ISAX.insert(ts_node)
    return ISAX, ts_numpy</pre>
<p>The <code>createISAX()</code> function <a id="_idIndexMarker326"/>creates an iSAX index and<a id="_idIndexMarker327"/> returns a link to an <code>isax.ISAX()</code> class as well as a NumPy array with all the elements of the time series.</p>
<p>The second function is implemented as follows:</p>
<pre class="source-code">
def query(ISAX, q):
    global totalQueries
    totalQueries = totalQueries + 1
    Accesses = 0
    # Create TS Node
    qTS = isax.TS(q, variables.segments)
    segs = [1] * variables.segments
    #If the relevant child of root is not there, we have a miss
    lower_cardinality = tools.lowerCardinality(segs, qTS)
    lower_cardinality_str = ""
    for i in lower_cardinality:
        lower_cardinality_str = lower_cardinality_str + "_"
            + i</pre>
<p>In the<a id="_idIndexMarker328"/> first part of <code>query()</code>, we construct the SAX representation<a id="_idIndexMarker329"/> of a potential child of the root node of the iSAX index using <code>tools.lowerCardinality()</code> and <code>segs</code>. From that, we construct the <code>lower_cardinality_str</code> string:</p>
<pre class="source-code">
    # Remove _ at the beginning
    Lower_cardinality_str = lower_cardinality_str[1:len(
        lower_cardinality_str)]
    if ISAX.ht.get(lower_cardinality_str) == None:
        <strong class="bold">return False, 0</strong>
    # Otherwise, we have a hit
    n = ISAX.ht.get(lower_cardinality_str)
    while n.terminalNode == False:
        left = n.left
        right = n.right
        leftSegs = left.word.split('_')
        # Promote
        tempCard = tools.promote(qTS, leftSegs)
        if tempCard == left.word:
            n = left
        elif tempCard == right.word:
            n = right
    # Iterate over the subsequences of the terminal node
    for i in range(0, variables.threshold):
        Accesses = Accesses + 1
        child = n.children[i]
        if type(child) == isax.TS:
            # print("Shapes:", child.ts.shape, qTS.ts.shape)
            if np.allclose(child.ts, qTS.ts):
                return True, Accesses
        else:
            return False, Accesses
    return False, Accesses</pre>
<p>In the <a id="_idIndexMarker330"/>second part of <code>query()</code>, we check whether <a id="_idIndexMarker331"/>the <code>lower_cardinality_str</code> key can be found in the iSAX index.</p>
<p>If it can be found, then we follow that subtree, which begins with a child of the root node of the iSAX index, until we find the appropriate terminal node. If it cannot be found, then we have a miss, and the process terminates.</p>
<p>The <code>query()</code> function returns <code>True</code> if the subsequence is found and <code>False</code> otherwise. Its second return value is the number of subsequence accesses that took place while trying to find that query subsequence.</p>
<p>The rest <a id="_idIndexMarker332"/>of the code of <code>speed.py</code> is placed in the <code>main()</code> function<a id="_idIndexMarker333"/> and is going to be presented in three parts – the first part being the following:</p>
<pre class="source-code">
    # Build iSAX for TS1
    i1, ts1 = createISAX(f1, windowSize, segments)
    totalSplits = totalSplits + variables.nSplits
    totalAccesses = totalAccesses + variables.nSubsequences
    # Build iSAX for TS2
    variables.nSubsequences = 0
    variables.nSplits = 0
    i2, ts2 = createISAX(f2, windowSize, segments)
    totalSplits = totalSplits + variables.nSplits
    totalAccesses = totalAccesses + variables.nSubsequences</pre>
<p>In this first part, we construct the two iSAX indexes and store the number of splits and accesses to subsequences.</p>
<p>The second part of <code>speed.py</code> contains the following code:</p>
<pre class="source-code">
    # Query iSAX for TS1
    for idx in range(0, len(ts1)-windowSize+1):
        currentQuery = ts1[idx:idx+windowSize]
        found, ac = <strong class="bold">query(i1, currentQuery)</strong>
        if found == False:
            print("This cannot be happening!")
            return
        totalAccesses = totalAccesses + ac
    # Query iSAX for TS1
    for idx in range(0, len(ts2)-windowSize+1):
        currentQuery = ts2[idx:idx+windowSize]
        found, ac = query<strong class="bold">(i1, currentQuery)</strong>
        totalAccesses = totalAccesses + ac</pre>
<p>In this <a id="_idIndexMarker334"/>part of the program, we query the first iSAX index. In <a id="_idIndexMarker335"/>the first <code>for</code> block, we search iSAX for all the subsequences of the first time series. As this iSAX indexes the first time series, all subsequences are going to be found in the iSAX index. While doing that, we store the number of accesses to subsequences, which is returned by the <code>query()</code> function. In the second <code>for</code> block, we do the same but this time, for the second time series. Therefore, there is a small possibility of finding the subsequences of the second time series (<code>TS2</code>) in the iSAX index of the first time series (<code>TS1</code>).</p>
<p>The last part of <code>speed.py</code> is as follows:</p>
<pre class="source-code">
    # Query iSAX for TS2
    for idx in range(0, len(ts2)-windowSize+1):
        currentQuery = ts2[idx:idx+windowSize]
        found, ac = query(i2, currentQuery)
        if found == False:
            print("This cannot be happening!")
            return
        totalAccesses = totalAccesses + ac
    # Query iSAX for TS2
    for idx in range(0, len(ts1)-windowSize+1):
        currentQuery = ts1[idx:idx+windowSize]
        found, ac = query(i2, currentQuery)
        totalAccesses = totalAccesses + ac</pre>
<p>This<a id="_idIndexMarker336"/> last part of <code>main()</code>is similar to the previous code. The<a id="_idIndexMarker337"/> only difference is that this time, we query the second iSAX index instead of the first one. Once again, we store the number of accesses to subsequences.</p>
<p>Before running <code>speed.py</code>, we need to create another time series, which is going to be stored in <code>506k.gz</code>. In this case, the second time series was created as follows:</p>
<pre class="source-code">
$ ../ch01/synthetic_data.py 506218 -10 10 &gt; 506k
$ gzip 506k</pre>
<p>Although the two time series do not need to have the same length, we have decided to make them pretty close in length.</p>
<p>Using <code>speed.py</code> generates the following kind of output:</p>
<pre class="source-code">
$ ./speed.py -s 8 500k.gz 506k.gz
Max Cardinality: 16 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Total subsequence accesses: 1060326778
Total splits: 1106
Total queries: 2012376</pre>
<p>Keep in mind that the previous command took <em class="italic">more than three hours</em> on a MacBook Pro machine! The speed will depend on your CPU.</p>
<p>If we used different SAX parameters, the output would look as follows:</p>
<pre class="source-code">
$ ./speed.py -s 4 -c 64 500k.gz 506k.gz
Max Cardinality: 64 Segments: 4 Sliding Window: 16 Threshold: 1000 Default Promotion: False
Total subsequence accesses: 1083675402
Total splits: 2034
Total queries: 2012376</pre>
<p>Although the first run of <code>speed.py</code> required 1,106 splits and the second one 2,034 splits, both<a id="_idIndexMarker338"/> results were close as far as the total number of subsequence accesses is concerned.</p>
<p>As expected, the<a id="_idIndexMarker339"/> number of total queries is the same in both cases because we are dealing with the same time series and, therefore, the same number of subsequences.</p>
<p>Now that we know how to perform lookups and searches on iSAX indexes, it is time to learn about another important operation, which is the joining of iSAX indexes.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor129"/>Joining iSAX indexes</h1>
<p>At this <a id="_idIndexMarker340"/>point, we have iSAX indexes that we want to use to perform basic time series data mining tasks. One of them is <strong class="bold">finding similar subsequences</strong> between two or more time series. In our case, we are working with two time series, but the method can be extended to more time series with small changes.</p>
<p class="callout-heading">How to join iSAX indexes</p>
<p class="callout">Given two or more iSAX indexes, it is up to us to decide how and why we are going to join them. We can even join them using SAX representations with a cardinality value of <code>2</code>. However, using the SAX representations of the nodes as our keys for the join is the most logical choice.In our case, we are going to use the iSAX indexes and the SAX representations of the nodes to look for similar subsequences. This is because we have the intuition that subsequences in nodes with the same SAX representation are <em class="italic">close</em> to each other. The term <em class="italic">close</em> is defined relative to <a id="_idIndexMarker341"/>a <strong class="bold">distance metric</strong>. For the purposes of this chapter, we are going to use the Euclidean distance to compare subsequences of the same size.</p>
<p>Now, let us rephrase that in a more precise way. A <strong class="bold">join</strong> of <a id="_idIndexMarker342"/>two iSAX indexes that is based on the SAX representation is a way of finding the most similar node (based on the SAX representation) for each of the nodes of the first iSAX index when searching the nodes of the second iSAX index, which was constructed using the same parameters. This way, we save time because we only have to compare subsequences of similar terminal nodes. Is similarity based on SAX representation perfect? No, it is not. But we are using a time series index to make things faster.</p>
<p>The idea behind this <a id="_idIndexMarker343"/>join came after reading the <em class="italic">Scalable Hybrid Similarity Join over Geolocated Time Series</em> paper, which was written by Georgios Chatzigeorgakidis, Kostas Patroumpas, Dimitrios Skoutas, Spiros Athanasiou, and Spiros Skiadopoulos.</p>
<p>The next section is going to show how to implement the joining of iSAX indexes based on the SAX representations of their nodes.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor130"/>Implementing the joining of iSAX indexes</h1>
<p>For the<a id="_idIndexMarker344"/> implementation of the iSAX index join, we are going to assume <a id="_idIndexMarker345"/>that we have two iSAX indexes ready to be used saved in two separate Python variables, and continue from there. We are going to need a Python function that accepts two iSAX indexes and returns a list of Euclidean distances, which are the nearest neighbors of all subsequences in both time series. Keep in mind that if a node from one of the iSAX indexes does not match the other iSAX index, then that node, and as a consequence its subsequences, is not going to get processed. Therefore, the list of Euclidean distances might be a little shorter than expected. That is the main reason why we must not use unnecessarily big iSAX parameters. Put simply, do not use 16 segments when 4 segments can do the job.</p>
<p>Additionally, keep in mind that the real nearest neighbor of a subsequence might not be located in the terminal node with the same SAX representation – this is the price we pay for the extra speed and avoiding the quadratic processing cost (comparing every subsequence of the first time series with all subsequences of the second time series, and vice versa).</p>
<p>So, we need to implement the previous functionality for the <code>isax</code> package based on the current implementation and representation of the iSAX index.</p>
<p>As a result, we are going to put that functionality inside the <code>isax</code> package, using a separate file named <code>iSAXjoin.py</code>.</p>
<p>Apart from that file, we added a function for calculating the Euclidean distance between two subsequences in <code>isax/tools.py</code>:</p>
<pre class="source-code">
def euclidean(a, b):
    return np.linalg.norm(a-b)</pre>
<p>If you recall from <a href="B14769_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, in the <code>ch01/ed.py</code> script, <code>euclidean()</code> uses the magic of <a id="_idIndexMarker346"/>NumPy to calculate Euclidean distances between two <a id="_idIndexMarker347"/>subsequences. Do not forget that we always <a id="_idIndexMarker348"/>compare <strong class="bold">normalized subsequences</strong> in this book.</p>
<p>Lastly, we added the following variable to <code>isax/variables.py</code>:</p>
<pre class="source-code">
# List of Euclidean distances
ED = []</pre>
<p>The <code>ED</code> global variable is a Python list used to hold the result of the join between two iSAX indexes, which is a list of Euclidean distances.</p>
<p>Let us now present and explain the code of <code>isax/iSAXjoin.py</code>.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor131"/>Explaining the Python code</h1>
<p>The <a id="_idIndexMarker349"/>code in <code>iSAXjoin.py</code> is going <a id="_idIndexMarker350"/>to be presented in five parts.</p>
<p>The first part is the following:</p>
<pre class="source-code">
from isax import variables
from isax import tools
def Join(iSAX1, iSAX2):
    # Begin with the children of the root node.
    # That it, the nodes with SAX words
    # with a Cardinality of 1.
    for t1 in iSAX1.children:
        k1 = iSAX1.children[t1]
        if k1 == None:
            continue
        for t2 in iSAX2.children:
            k2 = iSAX2.children[t2]
            if k2 == None:
                continue
            # J_AB
            _Join(k1, k2)
            # J_BA
            _Join(k2, k1)
    return</pre>
<p>The <code>Join()</code> function<a id="_idIndexMarker351"/> is the entry point to the join of the two iSAX indexes. However, that <a id="_idIndexMarker352"/>function has a single purpose, which is creating all the combinations between the children of the two iSAX root nodes in order to pass control to <code>_Join()</code>. As the order of the arguments in <code>_Join()</code> is significant, <code>_Join()</code> is called two times. The first time, a root child node from the first iSAX index is the first parameter, and the second time, a root child node from the second iSAX index is the first parameter.</p>
<p>The second part of <code>iSAXjoin.py</code> is as follows:</p>
<pre class="source-code">
def _Join(t1, t2):
    if t1.word != t2.word:
        return
    # Inner + Inner
    if t1.terminalNode==False and t2.terminalNode==False:
        _Join(t1.left, t2.left)
        _Join(t1.right, t2.left)
        _Join(t1.left, t2.right)
        _Join(t1.right, t2.right)</pre>
<p>When we are dealing with inner nodes from both iSAX indexes, we just combine all their children – remember <a id="_idIndexMarker353"/>that each inner node has two children – and recursion<a id="_idIndexMarker354"/> takes care of the rest.</p>
<p>The third part contains the following code:</p>
<pre class="source-code">
    # Terminal + Inner
    elif t1.terminalNode==True and t2.terminalNode==False:
        _Join(t1, t2.left)
        _Join(t1, t2.right)</pre>
<p>If we are dealing with an inner node and a terminal node, we expand the inner node, and recursion takes care of the rest.</p>
<p>The fourth part of <code>iSAXjoin.py</code> is as follows:</p>
<pre class="source-code">
    # Inner + Terminal
    elif t1.terminalNode == False and t2.terminalNode == True:
        _Join(t1.left, t2)
        _Join(t1.right, t2)</pre>
<p>As before, when dealing with an inner node and a terminal node, we expand the inner node, and recursion takes care of the rest.</p>
<p>The last part comes with the following Python code:</p>
<pre class="source-code">
    # Terminal + Terminal
    # As both are terminal nodes, calculate
    # Euclidean Distances between Time Series pairs
    elif t1.terminalNode==True and t2.terminalNode==True:
        for i in range(t1.nTimeSeries()):
            minDistance = None
            for j in range(t2.nTimeSeries()):
                distance =round(tools.euclidean
                (t1.children[i].ts, t2.children[j].ts),
                variables.precision)
                # Keeping the smallest Euclidean Distance for each node
                # of the t1 Terminal node
                if minDistance == None:
                    minDistance = distance
                elif minDistance &gt; distance:
                    minDistance = distance
            # Insert distance to PQ
            if minDistance != None:
                variables.ED.append(minDistance)
    else:
        print("This cannot happen!")</pre>
<p>This<a id="_idIndexMarker355"/> last part is where the recursive calling to <code>_Join()</code> stops because<a id="_idIndexMarker356"/> we are dealing with two terminal nodes. This means that we are able to calculate the Euclidean distances of their subsequences. The fact that we are not normalizing the subsequences before calling <code>tools.euclidean()</code> means that we expect to have the subsequences in all terminal nodes in a normalized form. Notice that we store the results in the <code>variables.ED</code> list.</p>
<p>That is all regarding the implementation of the joining of two iSAX indexes. The next section covers how to use the (similarity) join code.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor132"/>Using the Python code</h1>
<p>In this <a id="_idIndexMarker357"/>section, we are going to use the similarity join code we have developed to start joining iSAX indexes. The source code of <code>join.py</code> is presented in three parts. The first part is the following:</p>
<pre class="source-code">
#!/usr/bin/env python3
from isax import variables
from isax import isax
from isax import tools
from isax.sax import normalize
from isax.iSAXjoin import Join
import sys
import pandas as pd
import time
import argparse
def buildISAX(file, windowSize):
    variables.overflow = 0
    # Read Sequence as Pandas
    ts = pd.read_csv(file, names=['values'],
        compression='gzip', header = None)
    ts_numpy = ts.to_numpy()
    length = len(ts_numpy)
    ISAX = isax.iSAX()
    ISAX.length = length
    for i in range(length - windowSize + 1):
        ts = ts_numpy[i:i+windowSize]
        # Create new TS node based on ts
        # Store the normalized version of the subsequence
        ts_node = isax.TS(normalize(ts),
            variables.segments)
        ISAX.insert(ts_node)
    if variables.overflow != 0:
        print("Number of overflows:", variables.overflow)
    return ISAX</pre>
<p>Nothing new<a id="_idIndexMarker358"/> here – we just have to import the necessary external packages, including <code>isax.iSAXjoin</code>, and develop a function that creates an iSAX index given a time series file and a sliding window size. The function returns the root node of the iSAX index. However, please note that <em class="italic">subsequences are stored in their normalized form</em> inside all <code>TS()</code> objects.</p>
<p>The second part is the beginning of the <code>main()</code> function and comes with the following Python code:</p>
<pre class="source-code">
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--segments",
        dest = "segments", default = "16",
        help="Number of Segments", type=int)
    parser.add_argument("-c", "--cardinality",
        dest = "cardinality", default = "256",
        help="Cardinality", type=int)
    parser.add_argument("-w", "--window", dest = "window",
        default = "16", help="Sliding Window Size",
        type=int)
    parser.add_argument("-t", "--threshold",
        dest = "threshold", default = "50",
        help="Threshold for split", type=int)
    parser.add_argument("-p", "--promotion",
        action='store_true',
        help="Define Promotion Strategy")
    parser.add_argument("TS1")
    parser.add_argument("TS2")
    args = parser.parse_args()
    variables.segments = args.segments
    variables.maximumCardinality = args.cardinality
    variables.slidingWindowSize = args.window
    variables.threshold = args.threshold
    variables.defaultPromotion = args.promotion
    windowSize = variables.slidingWindowSize
    maxCardinality = variables.maximumCardinality
    f1 = args.TS1
    f2 = args.TS2
    if tools.power_of_two(maxCardinality) == -1:
        print("Not a power of 2:", maxCardinality)
        sys.exit()
    if variables.segments &gt; variables.slidingWindowSize:
        print("Segments:", variables.segments,
            "Sliding window:", variables.slidingWindowSize)
        print("Sliding window size should be bigger than # of segments.")
        sys.exit()
    print("Max Cardinality:", maxCardinality, "Segments:",
        variables.segments,
        "Sliding Window:", variables.slidingWindowSize,
        "Threshold:", variables.threshold,
        "Default Promotion:", variables.defaultPromotion)</pre>
<p>As we are joining <a id="_idIndexMarker359"/>two iSAX indexes, we need two separate command-line arguments (<code>TS1</code> and <code>TS2</code>) to define the paths of the compressed plain text files with the time series data.</p>
<p>The last part of <code>join.py</code> is as follows:</p>
<pre class="source-code">
    # Build iSAX for TS1
    start_time = time.time()
    i1 = buildISAX(f1, windowSize)
    print("i1: %.2f seconds" % (time.time() - start_time))
    # Build iSAX for TS2
    start_time = time.time()
    i2 = buildISAX(f2, windowSize)
    print("i2: %.2f seconds" % (time.time() - start_time))
    # Join the two iSAX indexes
    Join(i1, i2)
    variables.ED.sort()
    print("variables.ED length:", len(variables.ED))
    maximumLength = i1.length+i2.length - 2*windowSize + 2
    print("Maximum length:", maximumLength)
if __name__ == '__main__':
    main()</pre>
<p>Here, we <a id="_idIndexMarker360"/>create the two iSAX indexes by calling <code>buildISAX()</code> two times and then join them using <code>Join()</code>, which returns no values. In order to look at the list of computed values, we need to access <code>variables.ED</code>. We print the length of the list of Euclidean distances as well as the theoretical maximum length of it, which is equal to <code>time_series_length – sliding_window_size + 1</code>, to have a better idea of the number of subsequences without a match. In the output, we also print the time it took to create each iSAX index as extra information about the process.</p>
<p>At this point, we are ready to use <code>join.py</code>. This means that we should provide it with the necessary parameters and input.</p>
<p>Using <code>join.py</code> produces the following kind of output:</p>
<pre class="source-code">
$ ./join.py -s 8 -c 32 -t 1000 500k.gz 506k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False
i1: 170.94 seconds
i2: 179.80 seconds
variables.ED length: 970603
Maximum length: 1006188</pre>
<p>So, it took <code>170.94</code> seconds <a id="_idIndexMarker361"/>to create the first index and <code>179.80</code> seconds to create the second iSAX index. The list of Euclidean distances has <code>970603</code> elements, whereas the maximum number of elements is <code>1006188</code>, which means that we missed some terminal nodes because their SAX representation did not have a match in the other iSAX index. This is not unusual and we should expect it most of the time as time series and their iSAX indexes differ.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor133"/>We have a long list of Euclidean distances, so what?</h2>
<p>You might be asking, “What do we do with that list of Euclidean distances?” Put simply, what is the main purpose of creating such a list of distances? There<a id="_idIndexMarker362"/> are many uses, including the following:</p>
<ul>
<li>Finding out how close two time series are by finding the minimum Euclidean distance in the list.</li>
<li>Finding out the list of Euclidean distances that are in a given numeric range. This is another way of comparing the similarity of two time series.</li>
<li>Finding subsequences that are more different than others based on a distance measure. In data mining terminology, these subsequences are<a id="_idIndexMarker363"/> called <strong class="bold">outliers</strong>.</li>
</ul>
<p>I think you get the idea of why we perform the join computation – we need to be able to better understand the connection between the two time series involved in the join. The reason for using the SAX representation is to prune nodes and subsequences and save CPU time.</p>
<p>As the joining operation can be slow, the next subsection presents a handy technique for saving the list of Euclidean distances on disk and loading the list from disk in order to use it without having to carry out the entire process from scratch.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor134"/>Saving the output</h2>
<p>The<a id="_idIndexMarker364"/> joining of iSAX indexes can take time. Is there a way to make that process less painful? Yes, we can save the contents of the similarity join, which<a id="_idIndexMarker365"/> is a list, into a file, which saves us from having to recreate that list from scratch each time we need it. Keep in mind that for this to work, the two iSAX indexes must be created with the same parameters for the exact same time series.</p>
<p>The <code>saveLoadList.py</code> script demonstrates the idea in the <code>main()</code> function – you can see the implementation of <code>buildISAX()</code> in <code>join.py</code>. The first part of <code>main()</code> is as follows. Some code is omitted for brevity:</p>
<pre class="source-code">
def main():
. . .
    # Reading command line parameters
. . .
    # Build iSAX for TS1
    start_time = time.time()
    i1 = buildISAX(f1, windowSize)
    print("i1: %.2f seconds" % (time.time() - start_time))
    # Build iSAX for TS2
    start_time = time.time()
    i2 = buildISAX(f2, windowSize)
    print("i2: %.2f seconds" % (time.time() - start_time))
    # Now, join the two iSAX indexes
    <strong class="bold">Join(i1, i2)</strong>
    variables.ED.sort()
    print("variables.ED length:", len(variables.ED))
    # Now save it to disk
    #
    # Define filename
    <strong class="bold">filename</strong> = "List_" + basename(f1) + "_" + basename(f2) + "_" + str(maxCardinality) + "_" + str(variables.segments) + "_" + str(windowSize) + ".txt"
    print("Output file:", filename)
    f = open(filename, "w")
    # Write to disk
    for item in variables.ED:
        f.write('%s\n' %item)
    f.close()</pre>
<p>In the previous <a id="_idIndexMarker366"/>code, we put the similarity join data into <code>variables.ED</code> by calling <code>Join()</code> from <code>isax.iSAXjoin</code> and printing its length. After that, we computed the filename of the output file that is saved in the <code>filename</code> variable, which is based on the parameters of the program. This is a handy way of creating <code>variables.ED</code> into that file.</p>
<p>The second part of <code>main()</code> contains the following code:</p>
<pre class="source-code">
    # Now try to open it
    f = open(filename, "r")
    PQ = []
    for item in f.readlines():
        PQ.append(float(item.rstrip()))
    f.close()
    print("PQ length:", len(PQ))</pre>
<p>In the<a id="_idIndexMarker368"/> previous code, we tried to read the filename that we used for storing the contents of <code>variables.ED</code> and put the contents of the plain text file into the <code>PQ</code> variable. Lastly, we printed the length of <code>PQ</code> in order to compare it with the length of <code>variables.ED</code> and make sure that everything worked as expected.</p>
<p>Running the <code>saveLoadList.py</code> script generates the following output:</p>
<pre class="source-code">
$ ./saveLoadList.py -s 8 -c 32 -t 1000 500k.gz 506k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 16 Threshold: 1000 Default Promotion: False
i1: 168.73 seconds
i2: 172.39 seconds
variables.ED length: 970603
Output file: List_500k.gz_506k.gz_32_8_16.txt
PQ length: 970603</pre>
<p>From the previous output, we understand that the list contains <code>970603</code> elements. Additionally, the filename where we saved the contents of the list is <code>List_500k.gz_506k.gz_32_8_16.txt</code>. The only information missing from the filename is the threshold value.</p>
<p>The next subsection presents a utility that finds the nodes of an iSAX index that do not have a match in another iSAX index, and vice versa.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor135"/>Finding iSAX nodes without a match</h2>
<p>In this subsection, we specify<a id="_idIndexMarker369"/> the nodes of an iSAX index that do not have a match in another iSAX index, and vice versa. In reality, we are going to print the SAX representations of the terminal nodes of each iSAX index that do not have a match to a terminal node on the other iSAX.</p>
<p>The <code>noMatch.py</code> script implements the idea using the following code – we assume that we have already created two iSAX indexes for the two time series so that we do not have to repeat the code for creating iSAX indexes:</p>
<pre class="source-code">
    # Visit all entries in Dictionary
    sum = 0
    for k in i1.ht:
        t = i1.ht[k]
        if t.terminalNode:
            saxWord = t.word
            # Look for a match in the other iSAX
            if saxWord in i2.ht.keys():
                i2Node = i2.ht[saxWord]
                # Need that to be a terminal node
                if i2Node.terminalNode == False:
                    sum = sum + 1
                    print(saxWord, end=' ')
    print()</pre>
<p>The previous code visits all the nodes of the first iSAX index looking for terminal nodes. Once a terminal node is found, we get its SAX representation and look in the other iSAX index for a terminal node with the same SAX representation. If such a node cannot be found, we print the SAX representation of the terminal node of the first iSAX index that does not have a match.</p>
<p>We should <a id="_idIndexMarker370"/>now use the same process for the second time series and the second iSAX index. The code presented here is similar to the previous one:</p>
<pre class="source-code">
    # Look at the other iSAX
    for k in i2.ht:
        t = i2.ht[k]
        if t.terminalNode:
            saxWord = t.word
            # Look for a match in the other iSAX
            if saxWord in i1.ht.keys():
                i1Node = i1.ht[saxWord]
                # Sstill need that to be a terminal node
                if i1Node.terminalNode == False:
                    sum = sum + 1
                    print(saxWord, end=' ')
    print()
    print("Number of iSAX nodes without a match:", sum)</pre>
<p>So, right after examining the second iSAX index, we print the total number of terminal nodes without a match.</p>
<p>Running <code>noMatch.py</code> generates the following kind of output:</p>
<pre class="source-code">
$ ./noMatch.py -s 8 -c 32 -t 1500 -w 128 500k.gz 506k.gz
Max Cardinality: 32 Segments: 8 Sliding Window: 128 Threshold: 1500 Default Promotion: False
011_10_10_10_01_10_10_01 011_01_01_10_10_10_10_10 011_01_10_01_10_10_10_10 011_10_01_10_10_10_10_01 100_01_01_10_01_01_01_10 011_10_10_01_01_10_10_10 100_01_01_01_10_10_01_01 011_01_10_10_10_01_10_10 100_100_011_100_01_10_01_01 100_011_100_100_01_01_01_10 100_011_011_011_10_01_10_10 011_011_100_011_10_10_01_10 100_100_011_100_10_01_01_01 100_011_011_011_10_10_10_01 100_011_100_100_10_01_01_01 011_100_011_100_01_01_10_10 100_011_011_011_10_10_01_10 011_011_011_100_01_10_10_10 100_100_011_011_01_01_10_10 011_011_011_100_10_01_10_10 011_100_011_100_10_10_01_01 100_100_100_10_10_01_01_01 011_011_011_10_10_01_01_10 100_100_100_10_01_10_01_01 100_100_100_01_01_01_10_10
100_10_01_10_01_01_01_01 100_01_01_10_01_10_01_01 100_01_01_01_10_01_10_01 100_01_01_01_10_01_01_10 100_01_10_01_01_01_10_01 011_10_10_10_10_01_01_10 100_011_100_100_01_01_10_01 011_011_100_011_10_01_10_10 011_100_100_100_01_10_01_01 011_100_100_100_10_01_01_01 011_100_011_100_10_01_01_10 011_011_011_100_10_10_01_10 011_011_100_100_10_10_01_01 011_011_011_01_01_10_10_10 011_011_011_01_10_10_10_01 100_100_100_011_01_01_10_01 011_011_011_10_01_10_01_10 011_011_011_100_10_10_10_01 100_100_100_01_01_10_01_10 011_011_011_10_10_01_10_01 100_100_100_10_01_01_10_01
Total number of SAX nodes without a match: 46</pre>
<p>As we are <a id="_idIndexMarker371"/>using the same promotion strategy for both iSAX indexes, the output shows that the two iSAX indexes have a different structure, hence the dissimilarities in the list of SAX representations without a match on the second iSAX index. Additionally, we can see that the maximum cardinality in the printed SAX representations is just <code>8</code> and that most SAX words have a cardinality of <code>4</code>, which means that there were not so many splits.</p>
<p>Lastly, keep in mind that, in general, the smaller the number of segments in a SAX representation, the smaller the number of nodes without a match is going to be. Additionally, the larger the threshold value, the smaller the number of nodes without a match is going to be, because large threshold values minimize splits. In general, <em class="italic">the smaller the number of possible SAX representations is, the smaller the number of nodes without a match is going </em><em class="italic">to be</em>.</p>
<p>This can be seen in the following output, where we have reduced the number of segments to <code>4</code> and increased the cardinality to <code>64</code>:</p>
<pre class="source-code">
$ ./noMatch.py -s 4 -c 64 -t 1500 -w 128 500k.gz 506k.gz
Max Cardinality: 64 Segments: 4 Sliding Window: 128 Threshold: 1500 Default Promotion: False
101_01_01_10 010_10_01_10 1001_0110_0110_100 01100_1001_1000_0111 01100_0111_1000_1001 01100_1001_0111_1000 10011_1000_0110_0111 01100_1000_0111_1001 011110_01111_10000_10000 0101_1000_1000_100 1000_0101_1000_100 0111_0111_011_101 01111_01101_1001_1000 10000_01101_10000_10001 10001_01110_10001_01110 01110_01101_1001_1000 01110_10001_01110_10001 01111_10010_01110_01111 01110_10000_01110_1001 01101_10001_10000_10000 10001_10010_0111_0110 01101_10000_10001_10000 01110_01110_10010_1000
1001_0110_1001_011 10011_0110_1000_0111 011110_10000_01111_10000 10010_01111_01111_01110 10001_01110_01110_10001 10001_10010_0110_0111 10001_10000_01101_10000 10010_01111_01110_01111 01110_01111_01111_10010 01111_01110_01111_10010 10001_10001_01101_0111
Total number of SAX nodes without a match: 34</pre>
<p>In this case, we <a id="_idIndexMarker372"/>have fewer terminal nodes without a match.</p>
<p>The next section briefly touches on the topic of testing Python code by writing three basic Python tests for the <code>isax</code> package.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor136"/>Writing Python tests</h1>
<p>In this last section<a id="_idIndexMarker373"/> of this chapter, we are going to learn about Python testing and write three tests for our code with the help of the <code>pytest</code> package.</p>
<p>As the <code>pytest</code> package is not installed by default, the first task you should carry out is installing it using your favorite method. Part of the <code>pytest</code> package is the <code>pytest</code> command-line utility, which is used for running the tests.</p>
<p class="callout-heading">Unit testing</p>
<p class="callout">In this section, we are writing unit tests, which are usually functions that we write to make sure that our code works as expected. The result of a unit test is either <code>PASS</code> or <code>FAIL</code>. The more extensive the unit testing is, the more useful it is.</p>
<p>After a <a id="_idIndexMarker374"/>successful installation, if you execute the <code>pytest</code> command on a directory that does not contain any valid tests, you are going to get information about your system and your Python installation. On a macOS machine, the output is the following:</p>
<pre class="source-code">
$ pytest
========================= test session starts ==========
platform darwin -- Python 3.10.9, pytest-7.2.1, pluggy-1.0.0
rootdir: /Users/mtsouk/code/ch05
collected 0 items
================ no tests ran in 0.00s ====================</pre>
<p>As far as testing functions are concerned, there is a simple rule that you have to keep in mind. A testing function when using the <code>pytest</code> package is any Python function that is prefixed with <code>test_</code> in a file where its filename is also prefixed by <code>test_</code>.</p>
<p>There are many tests that could be written. Usually, we want to test as much as possible, starting from the most critical parts of the code and moving to the less critical ones. For the purposes of this chapter, we have decided to test the core logic of the implementation by writing three tests.</p>
<p>The next subsection talks about the three tests that we are going to implement in this chapter in more detail.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor137"/>What are we going to test?</h2>
<p>The first thing to define<a id="_idIndexMarker375"/> is what we are going to test and why. For this chapter, we are <a id="_idIndexMarker376"/>going to write the following three tests:</p>
<ul>
<li>We are going to count the number of subsequences in an iSAX index and make sure that the iSAX index holds all the subsequences.</li>
<li>We are going to test the number of node splits of an iSAX construction – this time, the correct number of splits is going to be stored in a global variable.</li>
<li>Lastly, we are going to join the same time series with itself. This means that we should get a list of Euclidean distances where all values are equal to 0. Keep in mind that as we are talking about floating-point numbers, the Euclidean distances might be very close to 0 but not exactly 0.</li>
</ul>
<p>The list of tests is far from complete, but it is a good way to illustrate the use and usefulness of tests.</p>
<p>The filenames of the time series and the iSAX parameters, as well as the number of splits and subsequences, are going to be given as global variables in the source code file that holds the testing code for reasons of simplicity. If you want to dynamically pass parameters to <code>pytest</code> tests, visit the <em class="italic">Basic patterns and examples of pytest</em> link in the <em class="italic">Useful links</em> section at the end of the chapter for more information.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor138"/>Comparing the number of subsequences</h2>
<p>In this test, we <a id="_idIndexMarker377"/>compare the number of subsequences in an iSAX index to the theoretical number of subsequences based on the sliding window size and the time series length.</p>
<p>The relevant code is as follows:</p>
<pre class="source-code">
def test_count_subsequences():
    variables.nSplits = 0
    variables.segments = segments
    variables.maximumCardinality = cardinality
    variables.slidingWindowSize = slidingWindow
    variables.threshold = threshold
    i, ts = <strong class="bold">createISAX</strong>(TS, slidingWindow, segments)
    sum = 0
    for k in i.ht:
        t = i.ht[k]
        if t.terminalNode:
            sum += t.nTimeSeries()
    assert sum == len(ts) - slidingWindow + 1</pre>
<p>First, we<a id="_idIndexMarker378"/> appropriately set the global variables in <code>./isax/variables.py</code> based on the global values found in the preamble of <code>test_isax.py</code>.</p>
<p>The <code>createISAX()</code> helper function is used to create iSAX indexes for testing. You have seen that function before in the <code>speed.py</code> utility.</p>
<p>What is important and closely related to the test is the use of the <code>assert</code> keyword. <code>assert</code> checks the trueness of the statement that follows. If the statement is <code>True</code>, then the <code>assert</code> statement passes. Otherwise, it throws an exception, and as a result, the test function fails. The <code>assert</code> keyword is used in all our test functions.</p>
<p>Next, we are going to discuss the test that checks the number of node splits.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor139"/>Checking the number of node splits</h2>
<p>For the purposes <a id="_idIndexMarker379"/>of this test, we assume that we have a different program in any programming language that we consider correct that gives us the actual number of node splits. This number of node splits is stored in a global variable (<code>splits</code>) and read by the test function.</p>
<p>The relevant Python code is as follows:</p>
<pre class="source-code">
def test_count_splits():
    variables.nSplits = 0
    variables.segments = segments
    variables.maximumCardinality = cardinality
    variables.slidingWindowSize = slidingWindow
    variables.threshold = threshold
    variables.defaultPromotion = False
    i, ts = createISAX(TS, slidingWindow, segments)
    assert variables.nSplits == splits</pre>
<p>In this code, we<a id="_idIndexMarker380"/> first appropriately set the global variables in <code>./isax/variables.py</code> based on the global values found in <code>test_isax.py</code>. Do not forget to reset <code>variables.nSplits</code> and select the correct promotion strategy (<code>variables.defaultPromotion</code>) in your test function.</p>
<p>The last test function computes the join of a time series with itself, which means that all Euclidean distances after the join should be equal to <code>0</code>.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor140"/>All Euclidean distances are 0</h2>
<p>In this <a id="_idIndexMarker381"/>test, we are going to create the iSAX index of a time series and join it with itself. As we are comparing a time series with itself, the list of Euclidean distances should only <em class="italic">contain zeros</em>. Therefore, with this unit test, we examine the logical correctness of our code.</p>
<p>The relevant Python test function is implemented as follows:</p>
<pre class="source-code">
def test_join_same():
    variables.nSplits = 0
    variables.segments = segments
    variables.maximumCardinality = cardinality
    variables.slidingWindowSize = slidingWindow
    variables.threshold = threshold
    i, _ = createISAX(TS, slidingWindow, segments)
    Join(i, i)
    assert <strong class="bold">np.allclose</strong>(variables.ED, np.zeros(len(variables.ED))) == True</pre>
<p>First, we <a id="_idIndexMarker382"/>appropriately set the global variables in <code>./isax/variables.py</code> based on the global values found in <code>test_isax.py</code>. After that, we call <code>createISAX()</code> to construct the iSAX index and then call the <code>Join()</code> function to populate the list of Euclidean distances.</p>
<p>The NumPy <code>zeros()</code> function creates a NumPy array with all zeros. Its parameter defines the length of the NumPy array that is going to be returned. The NumPy <code>allclose()</code> function returns <code>True</code> if its two NumPy array arguments are equal within a tolerance. This is mainly the case because when using floating-point values, there might be small differences due to rounding.</p>
<p>In the next subsection, we are going to run the tests and see the results.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor141"/>Running the tests</h2>
<p>In this <a id="_idIndexMarker383"/>section, we are going to run the tests and see their results. All the previous code can be found in the <code>./</code><code>ch05/test_isax.py</code> file.</p>
<p>The results of the tests, which are all successful, are as follows:</p>
<pre class="source-code">
$ pytest
================= test session starts =====================
platform darwin -- Python 3.10.9, pytest-7.2.1, pluggy-1.0.0
rootdir: /Users/mtsouk/TSi/code/ch05
collected 3 items
test_isax.py ...                                    [100%]
============= 3 passed in 2784.53s (0:46:24) ==============</pre>
<p>In the case that there <a id="_idIndexMarker384"/>were one or more failed tests, the output would look like the following (in this case, only one test failed):</p>
<pre class="source-code">
$ pytest
====================== test session starts ================
platform darwin -- Python 3.10.9, pytest-7.2.1, pluggy-1.0.0
rootdir: /Users/mtsouk/TSi/code/ch05
collected 3 items
test_isax.py .F.                                  [100%]
=====================FAILURES ============================
____________________ test_count_splits ___________________
    variables.nSplits = 0
    variables.segments = segments
    variables.maximumCardinality = cardinality
    variables.slidingWindowSize = slidingWindow
    variables.threshold = threshold
    _, _ = createISAX(TS, slidingWindow, segments)
&gt;   assert variables.nSplits == splits
E   assert 5669 == 5983
E    +  where 5669 = variables.nSplits
test_isax.py:58: AssertionError
================ short test summary info ==================
FAILED test_isax.py::test_count_splits - assert 5669 == 5983
=========== 1 failed, 2 passed in 2819.21s (0:46:59) ======</pre>
<p>The good thing is<a id="_idIndexMarker385"/> that the output shows the reason that one or more tests have failed and includes the relevant code. In this case, it is the <code>assert variables.nSplits == splits</code> statement that failed.</p>
<p>This is the last section of this chapter, yet the most important one, as testing can save you lots of time during development. The main purpose of our tests is to test the logic and the correctness of the code, which is very important.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor142"/>Summary</h1>
<p>In this chapter, we have seen code for testing the speed of an iSAX index and joining two iSAX indexes based on the SAX representations of their nodes. Then, we briefly discussed the subject of testing Python code and implemented three tests for the <code>isax</code> package.</p>
<p>We also discussed the joining of iSAX indexes, which is based on the node types. Additionally, the tests we carried out made sure that the core logic of our code is correct.</p>
<p>In the next chapter, we are going to learn how to visualize iSAX indexes to better understand their structure and performance.</p>
<p>Before you start reading and working through <a href="B14769_06.xhtml#_idTextAnchor145"><em class="italic">Chapter 6</em></a>, experiment with the command-line utilities that we have developed in this chapter and try to create your own.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor143"/>Useful links</h1>
<ul>
<li>The <code>pytest</code> package: https://pypi.org/project/pytest/</li>
<li>Official <code>pytest</code> documentation: <a href="https://docs.pytest.org/%0D">https://docs.pytest.org/</a></li>
<li><em class="italic">Practices of the Python Pro</em>, written by Dane Hillard</li>
<li><em class="italic">Mastering Python, 2nd Edition</em>, written by Rick van Hattem</li>
<li><em class="italic">Robust Python: Write Clean and Maintainable Code</em>, written by Patrick Viafore</li>
<li><em class="italic">Python Testing with pytest, 2nd Edition</em>, written by Brian Okken</li>
<li>Basic patterns and examples of <code>pytest</code>: <a href="https://docs.pytest.org/en/latest/example/simple.xhtml%0D">https://docs.pytest.org/en/latest/example/simple.xhtml</a></li>
</ul>
<h1 id="_idParaDest-133"><a id="_idTextAnchor144"/>Exercises</h1>
<p>Try to work through the following exercises:</p>
<ul>
<li>Use <code>accessSplit.py</code> to learn how the sliding window size affects the construction speed of the <code>2M.gz</code> time series from <a href="B14769_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>. Perform your experiments for the following sliding window sizes: <code>16</code>, <code>256</code>, <code>1024</code>, <code>4096</code>, <code>16384</code>, and <code>32786</code>.</li>
<li>Can you resolve the overflow situations with <code>accessSplit.py</code> and the <code>500.gz</code> time series we came across at the beginning of the chapter?</li>
<li>Try reducing the threshold values in the <code>speed.py</code> examples presented in the <em class="italic">Checking the search speed of iSAX indexes</em> section and see what happens.</li>
<li>Create two time series with 250,000 elements each and use <code>speed.py</code> to understand their behavior when the number of segments is in the 20 to 40 range. Do not forget to use an appropriate sliding window size.</li>
<li>Experiment with <code>speed.py</code> but this time, change the threshold value instead of the number of segments. Is the threshold value more important than the number of segments in the search speed of an iSAX index?</li>
<li>Modify <code>speed.py</code> to display the number of misses in subsequence queries.</li>
<li>Modify <code>join.py</code> to print the time it took to perform the join.</li>
<li>Modify <code>saveLoadList.py</code> to include the threshold value in the filename where we save the contents of the list with the Euclidean distances.</li>
<li>Run the <code>pytest</code> command on your own machines and see the output that you get.</li>
</ul>
</div>
</div></body></html>