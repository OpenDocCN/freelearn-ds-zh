<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">PostGIS Programming</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Writing PostGIS vector data with Psycopg</li>
<li>Writing PostGIS vector data with OGR Python bindings</li>
<li>Writing PostGIS functions with PL/Python</li>
<li>Geocoding and reverse geocoding using the GeoNames datasets</li>
<li>Geocoding using the OSM datasets with trigrams</li>
<li>Geocoding with geopy and PL/Python</li>
<li>Importing NetCDF datasets with Python and GDAL</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>There are several ways to write PostGIS programs, and in this chapter we will see a few of them. You will mainly use the Python language throughout this chapter. Python is a fantastic language with a plethora of GIS and scientific libraries that can be combined with PostGIS to write awesome geospatial applications.</p>
<p>If you are new to Python, you can quickly get productive with these excellent web resources:</p>
<ul>
<li>The official Python tutorial at <a href="http://docs.python.org/2/tutorial/"><span class="URLPACKT">http://docs.python.org/2/tutorial/</span></a></li>
<li>The popular <em>Dive into Python</em> book at <a href="http://www.diveintopython.net/"><span class="URLPACKT">http://www.diveintopython.net/</span></a></li>
</ul>
<p>You can combine Python with some excellent and popular libraries, such as:</p>
<ul>
<li><strong>Psycopg</strong>: This is the most complete and popular Python DB API implementation for PostgreSQL; see <a href="http://initd.org/psycopg/"><span class="URLPACKT">http://initd.org/psycopg/</span></a></li>
<li><strong>GDAL</strong>: Used to unchain the powerful GDAL library in your Python scripts; see <a href="http://www.gdal.org/gdal_tutorial.html"><span class="URLPACKT">http://www.gdal.org/gdal_tutorial.html</span></a></li>
<li><strong>requests</strong>: This is a handy Python standard library to manage HTTP stuff, such as opening URLs</li>
<li><strong>simplejson</strong>: This is a simple and fast JSON encoder/decoder</li>
</ul>
<p>The recipes in this chapter will cover some other useful geospatial Python libraries that are worthy of being looked at if you are developing a geospatial application. Under these Python libraries, the following libraries are included:</p>
<ul>
<li><strong>Shapely</strong>: This is a Python interface to the GEOS library for the manipulation and analysis of planar geometric objects: <a href="http://toblerity.github.io/shapely/"><span class="URLPACKT">http://toblerity.github.io/shapely/</span></a></li>
<li><strong>Fiona</strong>: This is a very light OGR Python API, which can be used as an alternative to the OGR bindings used in this chapter to manage vector datasets: <a href="https://github.com/Toblerity/Fiona"><span class="URLPACKT">https://github.com/Toblerity/Fiona</span></a></li>
<li><strong>Rasterio</strong>: This a Pythonic GDAL Python API, which can be used as an alternative to the GDAL bindings used in this chapter in order to manage raster datasets: <a href="https://github.com/mapbox/rasterio"><span class="URLPACKT">https://github.com/mapbox/rasterio</span></a></li>
<li><strong>pyproj</strong>: This is the Python interface to the PROJ.4 library: <span class="URLPACKT"><a href="https://pypi.python.org/pypi/pyproj">https://pypi.python.org/pypi/pyproj</a></span></li>
<li><strong>Rtree</strong>: This is a <kbd>ctype</kbd> Python wrapper to the <kbd>libspatialindex</kbd> library, providing several spatial indexing features that can be extremely useful for some kinds of geospatial development: <a href="http://toblerity.github.io/rtree/"><span class="URLPACKT">http://toblerity.github.io/rtree/</span></a></li>
</ul>
<p>In the first recipe, you will write a program that uses Python and its utilities such as <kbd>psycopg</kbd>, <kbd>requests</kbd>, and <kbd>simplejson</kbd> to fetch weather data from the web and import it in PostGIS.</p>
<p>In the second recipe, we will drive you to use Python and the GDAL OGR Python bindings library to create a script for geocoding a list of place names using one of the GeoNames web services.</p>
<p>You will then write a Python function for PostGIS using the PL/Python language to query the <span class="URLPACKT"><a href="http://openweathermap.org/">http://openweathermap.org/</a>Â </span>web services, already used in the first recipe, to calculate the weather for a PostGIS geometry from within a PostgreSQL function.</p>
<p>In the fourth recipe, you will create two PL/pgSQL PostGIS functions that will let you perform geocoding and reverse geocoding using the GeoNames datasets.</p>
<p>After this, there is a recipe in which you will use the <kbd>OpenStreetMap</kbd> street datasets imported in PostGIS to implement a very basic Python class in order to provide a geocode implementation to the class's consumer using PostGIS trigram support.</p>
<p>The sixth recipe will show you how to create a PL/Python function using the geopy library to geocode addresses using a web geocoding API such as Google Maps, Yahoo! Maps, Geocoder, GeoNames, and others.</p>
<p>In the last recipe of this chapter, you will create a Python script to import data from the <kbd>netCDF</kbd> format to PostGIS using the GDAL Python bindings.</p>
<p>Let's see some notes before starting with the recipes in this chapter.</p>
<p>If you are using Linux or macOS, follow these steps:</p>
<ol>
<li>Create a Python <kbd>virtualenv</kbd> (<a href="http://www.virtualenv.org/en/latest/"><span class="URLPACKT">http://www.virtualenv.org/en/latest/</span></a>) to keep a Python-isolated environment to be used for all the Python recipes in this book and activate it. Create it in a central directory, as you will need to use it for most of the Python recipes in this book:</li>
</ol>
<pre>      <strong>$ cd ~/virtualenvs</strong>
      <strong>$ virtualenv --no-site-packages postgis-cb-env</strong>
      <strong>$ source postgis-cb-env/bin/activate</strong></pre>
<ol start="2">
<li>Once activated, you can install the Python libraries you will need for the recipes in this chapter:</li>
</ol>
<pre>      <strong>$ pip install simplejson</strong>
      <strong>$ pip install psycopg2</strong>
      <strong>$ pip install numpy</strong>
      <strong>$ pip install requests</strong>
      <strong>$ pip install gdal</strong>
      <strong>$ pip install geopy</strong></pre>
<ol start="3">
<li>If you are new to the virtual environment and you are wondering where the libraries have been installed, you should find everything in the <kbd>virtualenv</kbd> directory in our development box. You can find the libraries using the following command:</li>
</ol>
<pre>      <strong>$ ls /home/capooti/virtualenv/postgis-cb-env/lib/<br/>           python2.7/site-packages</strong></pre>
<p style="padding-left: 60px">If you are wondering what is going on with the previous command lines, then <kbd>virtualenv</kbd> is a tool that will be used to create isolated Python environments, and you can find more information about this tool at <a href="http://www.virtualenv.org"><span class="URLPACKT">http://www.virtualenv.org</span></a>, while <kbd>pip</kbd> (<a href="http://www.pip-installer.org"><span class="URLPACKT">http://www.pip-installer.org</span></a>) is a package management system used to install and manage software packages written in Python.</p>
<p>If you are using Windows, follow these steps:</p>
<ol>
<li>The easiest way to get Python and all the libraries needed for the recipes in this chapter is to use <strong>OSGeo4W</strong>, a popular binary distribution of open source geospatial software for Windows. You can download it from <a href="http://trac.osgeo.org/osgeo4w/"><span class="URLPACKT">http://trac.osgeo.org/osgeo4w/</span></a>.</li>
<li>In our Windows box the OSGeo4W shell, at the time of writing this book comes with Python 2.7, GDAL 2.2 Python bindings, simplejson, psycopg2, and numpy. You will only need to install geopy.</li>
<li>The easiest way to install geopy and to eventually add more Python libraries to the OSGeo4W shell is to install <kbd>setuptools</kbd> and <kbd>pip</kbd> by following the instructions found at <a href="http://www.pip-installer.org/en/latest/installing.html"><span class="URLPACKT">http://www.pip-installer.org/en/latest/installing.html</span></a>. Open the OSGeo4W shell and just enter the following commands:</li>
</ol>
<pre>      <strong>&gt; python ez_setup.py</strong>
      <strong>&gt; python get-pip.py</strong>
      <strong>&gt; pip install requests</strong>
      <strong>&gt; pip install geopy</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing PostGIS vector data with Psycopg</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will use Python combined with Psycopg, the most popular PostgreSQL database library for Python, in order to write some data to PostGIS using the SQL language.</p>
<p>You will write a procedure to import weather data for the most populated US cities. You will import such weather data from <a href="http://www.openweatherdata.org/"><span class="URLPACKT">http://www.openweatherdata.org/</span></a>, which is a web service that provides free weather data and a forecast API. The procedure you are going to write will iterate each major USA city and get the actual temperature for it from the closest weather stations using the <a href="http://www.openweatherdata.org/"><span class="URLPACKT">http://www.openweatherdata.org/</span></a> web service API, getting the output in JSON format. (In case you are new to the JSON format, you can find details about it at <a href="http://www.json.org/"><span class="URLPACKT">http://www.json.org/</span></a>.)</p>
<p>You will also generate a new PostGIS layer with the 10 closest weather stations to each city.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a database schema for the recipes in this chapter using the following command:</li>
</ol>
<pre>      <strong>postgis_cookbook=# CREATE SCHEMA chp08;</strong></pre>
<ol start="2">
<li>Download the USA cities' shapefile from theÂ <a href="https://nationalmap.gov/">https://nationalmap.gov/</a> website at <a href="http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz"><span class="URLPACKT">http://dds.cr.usgs.gov/pub/data/nationalatlas/citiesx020_nt00007.tar.gz</span></a> (this archive is also included in the book's dataset that is available with the code bundle), extract it to <kbd>working/chp08</kbd>, and import it in PostGIS, filtering out cities with less than 100,000 inhabitants:</li>
</ol>
<pre>      <strong>$ ogr2ogr -f PostgreSQL -s_srs EPSG:4269 -t_srs EPSG:4326 <br/>      -lco GEOMETRY_NAME=the_geom -nln chp08.cities <br/>      PG:"dbname='postgis_cookbook' user='me' <br/>      password='mypassword'" -where "POP_2000 $ 100000" citiesx020.shp</strong>
  </pre>
<ol start="3">
<li>Add a <kbd>real</kbd> field to store the temperature for each city using the following command:</li>
</ol>
<pre>    <strong>postgis_cookbook=# ALTER TABLE chp08.cities <br/>    ADD COLUMN temperature real;</strong></pre>
<ol start="4">
<li>If you are on Linux, ensure that you follow the initial instructions in this chapter and create a Python virtual environment in order to keep a Python-isolated environment to be used for all the Python recipes in this book. Then, activate it:</li>
</ol>
<pre>      <strong>$ source postgis-cb-env/bin/activate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Create the following table to host weather stations' data:</li>
</ol>
<pre><strong>      CREATE TABLE chp08.wstations 
      ( 
        id bigint NOT NULL, 
        the_geom geometry(Point,4326), 
        name character varying(48), 
        temperature real, 
        CONSTRAINT wstations_pk PRIMARY KEY (id ) 
      );</strong> </pre>
<ol start="2">
<li>Create an account atÂ <a href="https://openweathermap.org"><span class="URLPACKT">https://openweathermap.org</span></a> to get an API key. Then, check the JSON response for the web service you are going to use. If you want the 10 closest weather stations from a point (the city centroid), the request you need to run is as follows (test it in a browser):Â <a href="http://api.openweathermap.org/data/2.5/find?lat=55&amp;lon=37&amp;cnt=10&amp;appid=YOURKEY"><span class="URLPACKT">http://api.openweathermap.org/data/2.5/find?lat=55&amp;lon=37&amp;cnt=10&amp;appid=YOURKEY</span></a></li>
<li>You should get the following JSON response (the closest 10 stations and their relative data are ordered by their distance from the point coordinates, which in this case are <kbd>lon=37</kbd> and <kbd>lat=55</kbd>):</li>
</ol>
<pre>        { 
          "message": "accurate", 
          "cod": "200", 
          "count": 10, 
          "list": [ 
            { 
              "id": 529315, 
              "name": "Marinki", 
              "coord": { 
              "lat": 55.0944, 
              "lon": 37.03 
            }, 
            "main": { 
              "temp": 272.15, 
              "pressure": 1011, 
              "humidity": 80, 
              "temp_min": 272.15, 
              "temp_max": 272.15 
            },       "dt": 1515114000, 
            "wind": { 
              "speed": 3, 
              "deg": 140 
            }, 
            "sys": { 
              "country": "" 
            }, 
            "rain": null, 
            "snow": null, 
            "clouds": { 
              "all": 90 
            }, 
            "weather": [ 
              { 
                "id": 804, 
                "main": "Clouds", 
                "description": "overcast clouds", 
                "icon": "04n" 
              } 
            ] 
        }, </pre>
<ol start="4">
<li>Now, create the Python program that will provide the desired output and name it <kbd>get_weather_data.py</kbd>:</li>
</ol>
<pre>        import sys 
        import requests 
        import simplejson as json 
        import psycopg2 
 
        def GetWeatherData(lon, lat, key): 
          """ 
            Get the 10 closest weather stations data for a given point. 
          """ 
          # uri to access the JSON openweathermap web service 
          uri = ( 
            'https://api.openweathermap.org/data/2.5/find?<br/>             lat=%s&amp;lon=%s&amp;cnt=10&amp;appid=%s' 
            % (lat, lon, key)) 
          print 'Fetching weather data: %s' % uri 
          try: 
            data = requests.get(uri) 
            print 'request status: %s' % data.status_code 
            js_data = json.loads(data.text) 
            return js_data['list'] 
          except: 
            print 'There was an error getting the weather data.' 
            print sys.exc_info()[0] 
            return [] 
 
        def AddWeatherStation(station_id, lon, lat, name, temperature): 
          """ 
            Add a weather station to the database, but only if it does <br/>            not already exists. 
          """ 
          curws = conn.cursor() 
          curws.execute('SELECT * FROM chp08.wstations WHERE id=%s',<br/>                        (station_id,)) 
          count = curws.rowcount 
          if count==0: # we need to add the weather station 
              curws.execute( 
            """INSERT INTO chp08.wstations (id, the_geom, name,<br/>               temperature) VALUES (%s, ST_GeomFromText('POINT(%s %s)',<br/>               4326), %s, %s)""",<br/>            (station_id, lon, lat, name, temperature) 
          ) 
          curws.close() 
          print 'Added the %s weather station to the database.' % name 
          return True 
        else: # weather station already in database 
          print 'The %s weather station is already in the database.' % name 
          return False 
 
        # program starts here 
        # get a connection to the database 
        conn = psycopg2.connect('dbname=postgis_cookbook user=me <br/>                                 password=password') 
        # we do not need transaction here, so set the connection <br/>        # to autocommit mode 
        conn.set_isolation_level(0) 
 
        # open a cursor to update the table with weather data 
        cur = conn.cursor() 
 
        # iterate all of the cities in the cities PostGIS layer, <br/>        # and for each of them grap the actual temperature from the <br/>        # closest weather station, and add the 10 
        # closest stations to the city to the wstation PostGIS layer 
        cur.execute("""SELECT ogc_fid, name, 
          ST_X(the_geom) AS long, ST_Y(the_geom) AS lat<br/>          FROM chp08.cities;""") 
        for record in cur: 
          ogc_fid = record[0] 
          city_name = record[1] 
          lon = record[2] 
          lat = record[3] 
          stations = GetWeatherData(lon, lat, 'YOURKEY') 
          print stations 
          for station in stations: 
            print station 
            station_id = station['id'] 
            name = station['name'] 
            # for weather data we need to access the 'main' section in the
            # json 'main': {'pressure': 990, 'temp': 272.15, 'humidity': 54} 
            if 'main' in station: 
              if 'temp' in station['main']: 
                temperature = station['main']['temp'] 
            else: 
              temperature = -9999 <br/>              # in some case the temperature is not available 
            # "coord":{"lat":55.8622,"lon":37.395} 
            station_lat = station['coord']['lat'] 
            station_lon = station['coord']['lon'] 
            # add the weather station to the database 
            AddWeatherStation(station_id, station_lon, station_lat, <br/>                              name, temperature) 
            # first weather station from the json API response is always 
            # the closest to the city, so we are grabbing this temperature 
            # and store in the temperature field in cities PostGIS layer 
            if station_id == stations[0]['id']: 
              print 'Setting temperature to %s for city %s' <br/>                    % (temperature, city_name) 
              cur2 = conn.cursor() 
              cur2.execute( 
                'UPDATE chp08.cities SET temperature=%s WHERE ogc_fid=%s', 
                (temperature, ogc_fid)) 
              cur2.close() 
 
        # close cursor, commit and close connection to database 
        cur.close() 
        conn.close() </pre>
<ol start="5">
<li>Run the Python program:</li>
</ol>
<pre>      <strong>(postgis-cb-env)$ python get_weather_data.py</strong>
      <strong>Added the PAMR weather station to the database.</strong>
      <strong>Setting temperature to 268.15 for city Anchorage</strong>
      <strong>Added the PAED weather station to the database.</strong>
      <strong>Added the PANC weather station to the database.</strong>
      <strong>...</strong>
      <strong>The KMFE weather station is already in the database.</strong>
      <strong>Added the KOPM weather station to the database.</strong>
      <strong>The KBKS weather station is already in the database.</strong></pre>
<ol start="6">
<li>Check the output of the Python program you just wrote. Open the two PostGIS layers, <kbd>cities</kbd> and <kbd>wstations</kbd>, with your favorite GIS desktop tool and investigate the results. The following screenshot shows how it looks in QGIS:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d7c91e45-c87e-4835-9a31-c493c8b59bce.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><strong>Psycopg</strong> is the most popular PostgreSQL adapter for Python, and it can be used to create Python scripts that send SQL commands to PostGIS. In this recipe, you created a Python script that queries weather data from the <a href="https://openweathermap.org/"><span class="URLPACKT">https://openweathermap.org/</span></a> web server using the popular <strong>JSON</strong> format to get the output data and then used that data to update two PostGIS layers.</p>
<p>For one of the layers, <kbd>cities</kbd>, the weather data is used to update the <kbd>temperature</kbd> field using the temperature data of the weather station closest to the city. For this purpose, you used an <kbd>UPDATE SQL</kbd> command. The other layer, <kbd>wstations</kbd>, is updated every time a new weather station is identified from the weather data and inserted in the layer. In this case, you used an <kbd>INSERT SQL</kbd> statement.</p>
<p>This is a quick overview of the script's behavior (you can find more details in the comments within the Python code). In the beginning, a PostgreSQL connection is created using the Psycopg <kbd>connection</kbd> object. The <kbd>connection</kbd> object is created using the main connection parameters (<kbd>dbname</kbd>, <kbd>user</kbd>, and <kbd>password</kbd>, while default values for <kbd>server name</kbd> and <kbd>port</kbd> are not specified; instead,Â <kbd>localhost</kbd> and <kbd>5432</kbd> are used). The connection behavior is set to <kbd>auto commit</kbd> so that any SQL performed by Psycopg will be run immediately and will not be embedded in a transaction.</p>
<p>Using a cursor, you first iterate all of the records in the <kbd>cities</kbd> PostGIS layer; for each of the cities, you need to get the temperature from the <a href="https://openweathermap.org/"><span class="URLPACKT">https://openweathermap.org/</span></a> web server. For this purpose, for each city you make a call to the <kbd>GetWeatherData</kbd> method, passing the coordinates of the city to it. The method queries the server using the <kbd>requests</kbd> library and parses the JSON response using the <kbd>simplejson</kbd> Python library.</p>
<p>You should send the URL request to a <kbd>try...catch</kbd> block. This way, if there is any issue with the web service (internet connection not available, or any HTTP status codes different from 200, or whatever else), the process can safely continue with the data of the next city (iteration).</p>
<p>The JSON response contains, as per the request, the information about the 10 weather stations closest to the city. You will use the information of the first weather station, the closest one to the city, to set the <kbd>temperature</kbd> field for the city.</p>
<p>You then iterate all of the <kbd>station</kbd> JSON objects, and by using the <kbd>AddWeatherStation</kbd> method, you create a weather station in the <kbd>wstation</kbd> PostGIS layer, but only if a weather station with the same <kbd>id</kbd> does not exist.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing PostGIS vector data with OGR Python bindings</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will use Python and the Python bindings of the GDAL/OGR library to create a script for geocoding a list of the names of places using one of the GeoNames web services (<a href="http://www.geonames.org/export/ws-overview.html"><span class="URLPACKT">http://www.geonames.org/export/ws-overview.html</span></a>). You will use the <strong>Wikipedia Fulltext Search</strong> web service (<a href="http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch"><span class="URLPACKT">http://www.geonames.org/export/wikipedia-webservice.html#wikipediaSearch</span></a>), which for a given search string returns the coordinates of the places matching that search string as the output, and some other useful attributes from Wikipedia, including the Wikipedia <kbd>page title</kbd> and <kbd>url</kbd>.</p>
<p>The script should first create a PostGIS point layer named <kbd>wikiplaces</kbd> in which all of the locations and their attributes returned by the web service will be stored.</p>
<p>This recipe should give you the basis to use other similar web services, such as Google Maps, Yahoo! BOSS Geo Services, and so on, to get results in a similar way.</p>
<p>Before you start, please note the terms of use of GeoNames: <a href="http://www.geonames.org/export/"><span class="URLPACKT">http://www.geonames.org/export/</span></a>. In a few words, at the time of writing, you have a 30,000 credits' daily limit per application (identified by the <kbd>username</kbd> parameter); the hourly limit is 2,000 credits. A credit is a web service request hit for most services.</p>
<p>You will generate the PostGIS table containing the geocoded place names using the GDAL/OGR Python bindings (<a href="http://trac.osgeo.org/gdal/wiki/GdalOgrInPython"><span class="URLPACKT">http://trac.osgeo.org/gdal/wiki/GdalOgrInPython</span></a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>To access GeoNames web services, you need to create a user at <a href="http://www.geonames.org/login"><span class="URLPACKT">http://www.geonames.org/login</span></a>. The user we created for this recipe is <kbd>postgis</kbd>; you will need to change it with your username whenever you query the GeoNames web service URL.</li>
<li>If you are using Windows, be sure to have OSGeo4W installed as suggested in the initial instructions of this chapter.</li>
<li>If you are using Linux, follow the initial instructions for this chapter, create a Python <kbd>virtualenv</kbd> in order to keep a Python-isolated environment to be used for all the Python recipes in this book, and activate it:</li>
</ol>
<pre>      <strong>$ source postgis-cb-env/bin/activate</strong></pre>
<ol start="4">
<li>Once activated, if you still haven't done so, you have to install the <kbd>gdal</kbd> and <kbd>simplejson</kbd> <span>PythonÂ </span>packages needed for this recipe:</li>
</ol>
<pre>      <strong>(postgis-cb-env)$ pip install gdal</strong>
      <strong>(postgis-cb-env)$ pip install simplejson</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>First, test the web services and their JSON output yourself with the following request (change the <kbd>q</kbd> and <kbd>username</kbd> parameters as you wish):Â <span class="URLPACKT"><a href="http://api.geonames.org/wikipediaSearchJSON?formatted=true&amp;q=london&amp;maxRows=10&amp;username=postgis&amp;style=full">http://api.geonames.org/wikipediaSearchJSON?formatted=true&amp;q=london&amp;maxRows=10&amp;username=postgis&amp;style=full</a>.</span></li>
</ol>
<p style="padding-left: 60px">You should get the following JSON output:</p>
<pre>        {    
          "geonames": [ 
            { 
              "summary": "London is the capital and most populous city of <br/>                 England and United Kingdom. Standing on the River Thames,<br/>                 London has been a major settlement for two millennia, <br/>                 its history going back to its founding by the Romans, <br/>                 who named it Londinium (...)", 
              "elevation": 8, 
              "geoNameId": 2643743, 
              "feature": "city", 
              "lng": -0.11832, 
              "countryCode": "GB", 
              "rank": 100, 
              "thumbnailImg": "http://www.geonames.org/img/wikipedia/<br/>                               43000/thumb-42715-100.jpg", 
              "lang": "en", 
              "title": "London", 
              "lat": 51.50939, 
              "wikipediaUrl": "en.wikipedia.org/wiki/London" 
            }, 
            { 
              "summary": "New London is a city and a port of entry on the <br/>                 northeast coast of the United States. It is located at <br/>                 the mouth of the Thames River in New London County, <br/>                 southeastern Connecticut. New London is located about from <br/>                 the state capital of Hartford, <br/>                 from Boston, Massachusetts, from Providence, Rhode (...)", 
              "elevation": 27, 
              "feature": "landmark", 
              "lng": -72.10083333333333, 
              "countryCode": "US", 
              "rank": 100, 
              "thumbnailImg": "http://www.geonames.org/img/wikipedia/<br/>                              160000/thumb-159123-100.jpg", 
              "lang": "en", 
              "title": "New London, Connecticut", 
              "lat": 41.355555555555554, 
              "wikipediaUrl": "en.wikipedia.org/wiki/<br/>                               New_London%2C_Connecticut" 
            },... 
          ]<br/>        } </pre>
<ol start="2">
<li>As you can see from the JSON output for the GeoNames web service, for a given query string (a location name), you get a list of Wikipedia pages related to that location in JSON format. For each JSON object representing a Wikipedia page, you can get access to the attributes, such as the <kbd>page title</kbd>, <kbd>summary</kbd>, <kbd>url</kbd>, and the <kbd>coordinates</kbd> of the location.</li>
<li>Now, create a text file named <kbd>working/chp08/names.txt</kbd> with the names of places you would like to geocode from the <span class="packt_screen">Wikipedia Fulltext Search</span> web services. Add some place names, for example (in Windows, use a text editor such as Notepad):</li>
</ol>
<pre>      <strong>$ vi names.txt</strong>
    
      <strong>London</strong>
      <strong>Rome</strong>
      <strong>Boston</strong>
      <strong>Chicago</strong>
      <strong>Madrid</strong>
      <strong>Paris</strong>
      <strong>...</strong></pre>
<ol start="4">
<li>Now, create a file named <kbd>import_places.py</kbd> under <kbd>working/chp08/</kbd> and add to it the Python script for this recipe. The following is how the script should look (you should be able to follow it by reading the inline comments and the <em>How it works...</em> section):</li>
</ol>
<pre>        import sys 
        import requests 
        import simplejson as json 
        from osgeo import ogr, osr 
 
        MAXROWS = 10 
        USERNAME = 'postgis' #enter your username here 
   
        def CreatePGLayer(): 
          """ 
            Create the PostGIS table. 
          """ 
          driver = ogr.GetDriverByName('PostgreSQL') 
          srs = osr.SpatialReference() 
          srs.ImportFromEPSG(4326) 
          ogr.UseExceptions() 
          pg_ds = ogr.Open("PG:dbname='postgis_cookbook' host='localhost' <br/>             port='5432' user='me' password='password'", update = 1) 
          pg_layer = pg_ds.CreateLayer('wikiplaces', srs = srs, <br/>                geom_type=ogr.wkbPoint, options = [ 
            'DIM=3', <br/>             # we want to store the elevation value in point z coordinate 
            'GEOMETRY_NAME=the_geom', 
            'OVERWRITE=YES', <br/>            # this will drop and recreate the table every time 
            'SCHEMA=chp08', 
          ]) 
          # add the fields 
          fd_title = ogr.FieldDefn('title', ogr.OFTString) 
          pg_layer.CreateField(fd_title) 
          fd_countrycode = ogr.FieldDefn('countrycode', ogr.OFTString) 
          pg_layer.CreateField(fd_countrycode) 
          fd_feature = ogr.FieldDefn('feature', ogr.OFTString) 
          pg_layer.CreateField(fd_feature) 
          fd_thumbnail = ogr.FieldDefn('thumbnail', ogr.OFTString) 
          pg_layer.CreateField(fd_thumbnail) 
          fd_wikipediaurl = ogr.FieldDefn('wikipediaurl', ogr.OFTString) 
          pg_layer.CreateField(fd_wikipediaurl) 
          return pg_ds, pg_layer 
 
        def AddPlacesToLayer(places): 
        """ 
          Read the places dictionary list and add features in the <br/>          PostGIS table for each place. 
        """ 
        # iterate every place dictionary in the list 
        print "places: ", places 
        for place in places: 
          lng = place['lng'] 
          lat = place['lat'] 
          z = place.get('elevation') if 'elevation' in place else 0 
          # we generate a point representation in wkt, <br/>          # and create an ogr geometry 
          point_wkt = 'POINT(%s %s %s)' % (lng, lat, z) 
          point = ogr.CreateGeometryFromWkt(point_wkt) 
          # we create a LayerDefn for the feature using the one <br/>          # from the layer 
          featureDefn = pg_layer.GetLayerDefn() 
          feature = ogr.Feature(featureDefn) 
          # now time to assign the geometry and all the  
          # other feature's fields, if the keys are contained <br/>          # in the dictionary (not always the GeoNames 
          # Wikipedia Fulltext Search contains all of the information) 
          feature.SetGeometry(point) 
          feature.SetField('title', 
            place['title'].encode("utf-8") if 'title' in place else '') 
          feature.SetField('countrycode', 
            place['countryCode'] if 'countryCode' in place else '') 
          feature.SetField('feature', 
            place['feature'] if 'feature' in place else '') 
          feature.SetField('thumbnail', 
            place['thumbnailImg'] if 'thumbnailImg' in place else '') 
          feature.SetField('wikipediaurl', 
            place['wikipediaUrl'] if 'wikipediaUrl' in place else '') 
          # here we create the feature (the INSERT SQL is issued here) 
          pg_layer.CreateFeature(feature) 
          print 'Created a places titled %s.' % place['title'] 
 
        def GetPlaces(placename): 
          """ 
            Get the places list for a given placename. 
          """ 
          # uri to access the JSON GeoNames Wikipedia Fulltext Search <br/>          # web service 
          uri = ('http://api.geonames.org/wikipediaSearchJSON?<br/>              formatted=true&amp;q=%s&amp;maxRows=%s&amp;username=%s&amp;style=full' 
              % (placename, MAXROWS, USERNAME)) 
          data = requests.get(uri) 
          js_data = json.loads(data.text) 
          return js_data['geonames'] 
 
        def GetNamesList(filepath): 
          """ 
            Open a file with a given filepath containing place names <br/>            and return a list. 
          """ 
          f = open(filepath, 'r') 
          return f.read().splitlines() 
 
        # first we need to create a PostGIS table to contains the places 
        # we must keep the PostGIS OGR dataset and layer global, <br/>        # for the reasons 
        # described here: http://trac.osgeo.org/gdal/wiki/PythonGotchas 
        from osgeo import gdal 
        gdal.UseExceptions() 
        pg_ds, pg_layer = CreatePGLayer()</pre>
<pre>        try: 
          # query geonames for each name and store found <br/>          # places in the table 
          names = GetNamesList('names.txt') 
          print names 
            for name in names: 
            AddPlacesToLayer(GetPlaces(name)) 
        except Exception as e: 
          print(e) 
          print sys.exc_info()[0] </pre>
<ol start="5">
<li>Now, execute the Python script:</li>
</ol>
<pre>      <strong>(postgis-cb-env)$ python import_places.py</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e839b9f9-2cfe-4277-98de-15c07c383925.png" style="width:34.75em;height:27.75em;"/></div>
<ol start="6">
<li>Test whether the table was correctly created and populated using SQL and use your favorite GIS d<span>esktopÂ </span>tool to display the layer:</li>
</ol>
<pre>      <strong>postgis_cookbook=# select ST_AsText(the_geom), title,<br/>        countrycode, feature from chp08.wikiplaces;</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/139bfbcb-f27b-4e99-b0d5-d99f60ee79b7.png" style="width:39.25em;height:28.00em;"/></div>
<pre><strong>      (60 rows)</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>This Python script uses the <kbd>requests</kbd> and <kbd>simplejson</kbd> libraries to fetch data from the GeoNames <kbd>wikipediaSearchJSON</kbd> web service, and the GDAL/OGR library to store geographic information inside the PostGIS database.</p>
<p>First, you create a PostGIS point table to store the geographic data. This is made using the GDAL/OGR bindings. You need to instantiate an OGR PostGIS driver (<a href="http://www.gdal.org/drv_pg.html"><span class="URLPACKT">http://www.gdal.org/drv_pg.html</span></a>) from where it is possible to instantiate a dataset to connect to your <kbd>postgis_cookbook</kbd> database using a specified connection string.</p>
<p>The <kbd>update</kbd> parameter in the connection string specifies to the GDAL driver that you will open the dataset for updating.</p>
<p>From the PostGIS dataset, we created a PostGIS layer named <kbd>wikiplaces</kbd> that will store points (<kbd>geom_type=ogr.wkbPoint</kbd>) using the <em>WGS 84</em> spatial reference system (<kbd>srs.ImportFromEPSG(4326)</kbd>). When creating the layer, we specified other parameters as well, such as <kbd>dimension</kbd> (<kbd>3</kbd>, as you want to store the <kbd>z</kbd> values), <kbd>GEOMETRY_NAME</kbd> (name of the geometric field), and <kbd>schema</kbd>. After creating the layer, you can use the <kbd>CreateField</kbd> layer method to create all the fields that are needed to store the information. Each field will have a specific <kbd>name</kbd> and <kbd>datatype</kbd> (all of them are <kbd>ogr.OFTString</kbd> in this case).</p>
<p>After the layer has been created (note that we need to have the <kbd>pg_ds</kbd> and <kbd>pg_layer</kbd> objects always in context for the whole script, as noted at <a href="http://trac.osgeo.org/gdal/wiki/PythonGotchas"><span class="URLPACKT">http://trac.osgeo.org/gdal/wiki/PythonGotchas</span></a>), you can query the GeoNames web services for each place name in the <kbd>names.txt</kbd> file using the <kbd>urllib2</kbd> library.</p>
<p>We parsed the JSON response using the <kbd>simplejson</kbd> library, then iterated the JSON objects list and added a feature to the PostGIS layer for each of the objects in the JSON output. For each element, we created a feature with a point <kbd>wkt</kbd> geometry (using the <kbd>lng</kbd>, <kbd>lat</kbd>, and <kbd>elevation</kbd> object attributes) using the <kbd>ogr.CreateGeometryFromWkt</kbd> method, and updated the other fields using the other object attributes returned by GeoNames, using the feature <kbd>setField</kbd> method (<kbd>title</kbd>, <kbd>countryCode</kbd>, and so on).</p>
<p>You can get more information on programming with GDAL Python bindings by using the following great resource by <em>Chris Garrard</em>:</p>
<p><a href="https://www.manning.com/books/geoprocessing-with-python"><span class="URLPACKT">https://www.manning.com/books/geoprocessing-with-python</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing PostGIS functions with PL/Python</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will write a Python function for PostGIS using the PL/Python language. The PL/Python procedural language allows you to write PostgreSQL functions with the Python language.</p>
<p>You will use Python to query the <span class="URLPACKT"><a href="http://openweathermap.org/">http://openweathermap.org/</a>Â </span>web services, already used in a previous recipe, to get the weather for a PostGIS geometry from within a PostgreSQL function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Verify your PostgreSQL server installation has PL/Python support. In Windows, this should be already included, but this is not the default if you are using, for example, Ubuntu 16.04 LTS, so you will most likely need to install it:</li>
</ol>
<pre>      <strong>$ sudo apt-get install postgresql-plpython-9.1</strong></pre>
<ol start="2">
<li>Install PL/Python on the database (you could consider installing it in your <kbd>template1</kbd> database; in this way, every newly created database will have PL/Python support by default):</li>
</ol>
<div class="packt_infobox">You could alternatively add PL/Python support to your database, using the <kbd>createlang</kbd> shell command (this is the only way if you are using PostgreSQL version 9.1 or lower):<br/>
<kbd>$ createlang plpythonu postgis_cookbook</kbd><br/>
<kbd>$ psql -U me postgis_cookbook</kbd><br/>
<kbd>postgis_cookbook=# CREATE EXTENSION plpythonu;</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>In this recipe, as with the previous one, you will use aÂ <a href="http://openweathermap.org/"><span class="URLPACKT">http://openweathermap.org/</span></a> web service to get the temperature for a point from the closest weather station. The request you need to run (test it in a browser) is <a href="http://api.openweathermap.org/data/2.5/find?lat=55&amp;lon=37&amp;cnt=10&amp;appid=YOURKEY"><span class="URLPACKT">http://api.openweathermap.org/data/2.5/find?lat=55&amp;lon=37&amp;cnt=10&amp;appid=YOURKEY</span></a>.</li>
<li>You should get the following JSON output (the closest weather station's data from which you will read the temperature to the point, with the coordinates of the given longitude and latitude):</li>
</ol>
<pre>        {<br/>          message: "",<br/>          cod: "200",<br/>          calctime: "",<br/>          cnt: 1,<br/>          list: [<br/>            {<br/>              id: 9191,<br/>              dt: 1369343192,<br/>              name: "100704-1",<br/>              type: 2,<br/>              coord: {<br/>                lat: 13.7408,<br/>                lon: 100.5478<br/>              },<br/>              distance: 6.244,<br/>              main: {<br/>                temp: 300.37<br/>              },<br/>              wind: {<br/>                speed: 0,<br/>                deg: 141<br/>              },<br/>              rang: 30,<br/>              rain: {<br/>                1h: 0,<br/>                24h: 3.302,<br/>                today: 0<br/>              }<br/>            }<br/>          ]  
        } </pre>
<ol start="3">
<li>Create the following PostgreSQL function in Python, using the PL/Python language:</li>
</ol>
<pre>        CREATE OR REPLACE FUNCTION chp08.GetWeather(lon float, lat float)<br/>          RETURNS float AS $$<br/>          import urllib2<br/>          import simplejson as json<br/>          data = urllib2.urlopen(<br/>            'http://api.openweathermap.org/data/<br/>             2.1/find/station?lat=%s&amp;lon=%s&amp;cnt=1'<br/>            % (lat, lon))<br/>          js_data = json.load(data)<br/>          if js_data['cod'] == '200': <br/>          # only if cod is 200 we got some effective results<br/>            if int(js_data['cnt'])&gt;0: <br/>            # check if we have at least a weather station<br/>              station = js_data['list'][0]<br/>              print 'Data from weather station %s' % station['name']<br/>              if 'main' in station:<br/>                if 'temp' in station['main']:<br/>                  temperature = station['main']['temp'] - 273.15 <br/>                  # we want the temperature in Celsius<br/>                else:<br/>                  temperature = None<br/>          else:<br/>            temperature = None<br/>          return temperature 
        $$ LANGUAGE plpythonu; </pre>
<ol start="4">
<li>Now, test your function; for example, get the temperature from the weather station closest to Wat Pho Templum in Bangkok:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT chp08.GetWeather(100.49, 13.74);</strong><br/><strong>      getweather 
      ------------ 
      27.22 
      (1 row)</strong> </pre>
<ol start="5">
<li>If you want to get the temperature for the point features in a PostGIS table, you can use the coordinates of each feature's geometry:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT name, temperature,<br/>      chp08.GetWeather(ST_X(the_geom), ST_Y(the_geom)) <br/>      AS temperature2 FROM chp08.cities LIMIT 5; 
      name     | temperature | temperature2 
      -------------+-------------+-------------- 
      Minneapolis |      275.15 |           15 
      Saint Paul  |      274.15 |           16 
      Buffalo     |      274.15 |        19.44 
      New York    |      280.93 |        19.44 
      Jersey City |      282.15 |        21.67 
      (5 rows)</strong> </pre>
<ol start="6">
<li>Now it would be nice if our function could accept not only the coordinates of a point, but also a true PostGIS geometry as well as an input parameter. For the temperature of a feature, you could return the temperature of the weather station closest to the centroid of the feature geometry. You can easily get this behavior using function overloading. Add a new function, with the same name, supporting a PostGIS geometry directly as an input parameter. In the body of the function, call the previous function, passing the coordinates of the centroid of the geometry. Note that in this case, you can write the function without using Python, with the PL/PostgreSQL language:</li>
</ol>
<pre><strong>      CREATE OR REPLACE FUNCTION chp08.GetWeather(geom geometry)</strong><br/><strong>      RETURNS float AS $$ 
      BEGIN 
        RETURN chp08.GetWeather(ST_X(ST_Centroid(geom)),<br/>               ST_Y(ST_Centroid(geom)));</strong></pre>
<pre><strong>      END; 
      $$ LANGUAGE plpgsql;</strong> </pre>
<ol start="7">
<li>Now, test the function, passing a PostGIS geometry to the function:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT chp08.GetWeather(<br/>        ST_GeomFromText('POINT(-71.064544 42.28787)')); 
        getweather 
      ------------ 
      23.89 
      (1 row)</strong> </pre>
<ol start="8">
<li>If you use the function on a PostGIS layer, you can pass the feature's geometries to the function directly, using the overloaded function written in the PL/PostgreSQL language:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT name, temperature,<br/>      chp08.GetWeather(the_geom) AS temperature2 <br/>      FROM chp08.cities LIMIT 5; 
      name     | temperature | temperature2 
      -------------+-------------+-------------- 
      Minneapolis |      275.15 |        17.22 
      Saint Paul  |      274.15 |           16 
      Buffalo     |      274.15 |        18.89 
      New York    |      280.93 |        19.44 
      Jersey City |      282.15 |        21.67 
      (5 rows)</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you wrote a Python function in PostGIS, using the PL/Python language. Using Python inside PostgreSQL and PostGIS functions gives you the great advantage of being able to use any Python library you wish. Therefore, you will be able to write much more powerful functions compared to those written using the standard PL/PostgreSQL language.</p>
<p>In fact, in this case, you used the <kbd>urllib2</kbd> and <kbd>simplejson</kbd> Python libraries to query a web service from within a PostgreSQL functionâthis would be an impossible operation to do using plain PL/PostgreSQL. You have also seen how to overload functions in order to provide the function's user a different way to access the function, using input parameters in a different way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Geocoding and reverse geocoding using the GeoNames datasets</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will write two PL/PostgreSQL PostGIS functions that will let you perform geocoding and reverse geocoding using the GeoNames datasets.</p>
<p>GeoNames is a database of place names in the world, containing over 8 million records that are available for download free of charge. For the purpose of this recipe, you will download a part of the database, load it in PostGIS, and then use it within two functions to perform geocoding and reverse geocoding. <strong>Geocoding</strong> is the process of finding coordinates from geographical data, such as an address or a place name, while <strong>reverse geocoding</strong> is the process of finding geographical data, such as an address or place name, from its coordinates.</p>
<p>You are going to write the two functions using PL/pgSQL, which adds on top of the PostgreSQL SQL commands the ability to tie more commands and queries together, a bunch of control structures, cursors, error management, and other goodness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Download a GeoNames dataset. At the time of writing, you can find some of the datasets ready to be downloaded from <a href="http://download.geonames.org/export/dump/"><span class="URLPACKT">http://download.geonames.org/export/dump/</span></a>. You may decide which dataset you want to use; if you want to follow this recipe, it will be enough to download the Italian dataset, <kbd>IT.zip</kbd>Â (included in the book's dataset, in the <kbd>chp08</kbd> directory).</p>
<p>If you want to download the full GeoNames dataset, you need to download the <kbd>allCountries.zip</kbd> file; it will take longer as it is about 250 MB.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>Unzip the <kbd>IT.zip</kbd> file to the <kbd>working/chp08</kbd> directory. Two files will be extracted: the <kbd>readme.txt</kbd> file that contains information on the GeoNames database structureâyou can read it to get some more informationâand the <kbd>IT.txt</kbd> file, which is a <kbd>.csv</kbd> file containing all the GeoNames entities for Italy. As suggested in the <kbd>readme.txt</kbd> file, the content of the CSV file is composed of records with the following attributes:</li>
</ol>
<pre><strong>      geonameid         : integer id of record in geonames  database 
      name              : name of geographical point (utf8) varchar(200) 
      asciiname         : name of geographical point in  plain <br/>                          ascii characters, varchar(200) 
      alternatenames    : alternatenames, comma separated varchar(5000) 
      latitude          : latitude in decimal degrees (wgs84) 
      longitude         : longitude in decimal degrees (wgs84) 
      ...</strong> </pre>
<ol start="2">
<li>Get an overview of this CSV dataset, using <kbd>ogrinfo</kbd>:</li>
</ol>
<pre>      <strong>$ ogrinfo CSV:IT.txt IT -al -so</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/37ab3ab7-3de1-4e6a-8766-fe4fe01b6e85.png" style="width:29.00em;height:32.08em;"/></div>
<ol start="3">
<li>You could query the <kbd>IT.txt</kbd> file as an OGR entity. For example, analyze one of the dataset features, as shown in the following code:</li>
</ol>
<pre>      <strong>$ ogrinfo CSV:IT.txt IT -where "NAME = 'San Gimignano'"</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d93ac89a-d5aa-40dd-a285-10dc580af64a.png" style="width:37.67em;height:28.83em;"/></div>
<ol start="4">
<li>For your purpose, you just need the <kbd>name</kbd>, <kbd>asciiname</kbd>, <kbd>latitude</kbd>, and <kbd>longitude</kbd> attributes. You will import the file to PostGIS using the CSV OGR driver (<a href="http://www.gdal.org/drv_csv.html"><span class="URLPACKT">http://www.gdal.org/drv_csv.html</span></a>). Use the <kbd>ogr2ogr</kbd> command to import this GeoNames dataset in PostGIS:</li>
</ol>
<pre><strong>      $ ogr2ogr -f PostgreSQL -s_srs EPSG:4326 -t_srs EPSG:4326 <br/>      -lco GEOMETRY_NAME=the_geom -nln chp08.geonames <br/>      PG:"dbname='postgis_cookbook' user='me' password='mypassword'" <br/>      CSV:IT.txt -sql "SELECT NAME, ASCIINAME FROM IT"</strong> </pre>
<ol start="5">
<li>Try to query the new <kbd>geonames</kbd> table in PostGIS to see if the process works correctly:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT ST_AsText(the_geom), name <br/>      FROM chp08.geonames LIMIT 10;</strong></pre>
<ol start="6">
<li>Now, create a PL/PostgreSQL function that will return the five place names closest to the given point and their coordinates (reverse geocoding):</li>
</ol>
<pre><strong>      CREATE OR REPLACE FUNCTION chp08.Get_Closest_PlaceNames(<br/>        in_geom geometry, num_results int DEFAULT 5, <br/>        OUT geom geometry, OUT place_name character varying)</strong><br/><strong>      RETURNS SETOF RECORD A</strong><strong>S $$</strong><br/><strong>      BEGIN</strong><br/><strong>        RETURN QUERY</strong><br/><strong>        SELECT the_geom as geom, name as place_name</strong><br/><strong>        FROM chp08.geonames</strong><br/><strong>        ORDER BY the_geom &lt;-&gt; ST_Centroid(in_geom) LIMIT num_results;</strong><br/><strong>      END; 
      $$ LANGUAGE plpgsql;</strong> </pre>
<ol start="7">
<li>Query the new function. You can specify the number of results you want by passing the optional <kbd>num_results</kbd> input parameter:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT * FROM chp08.Get_Closest_PlaceNames(<br/>        ST_PointFromText('POINT(13.5 42.19)', 4326), 10);</strong> </pre>
<p style="padding-left: 60px">The following is the output for this query:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/d3aadd6e-c073-40b7-97f5-6af6abf6c0a9.png" style="width:17.00em;height:19.50em;"/></div>
<ol start="8">
<li>If you don't specify the <kbd>num</kbd><kbd>_results</kbd> optional parameter, it will default to five results:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT * FROM chp08.Get_Closest_PlaceNames(<br/>      ST_PointFromText('POINT(13.5 42.19)', 4326));</strong> </pre>
<p style="padding-left: 60px">And you will get the following rows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/885f1bfc-c639-4bc3-b80e-820ac913d97e.png" style="width:16.67em;height:11.25em;"/></div>
<ol start="9">
<li>Now, create a PL/pgSQL function that will return a list of place names and geometries containing a text search in their name field (geocoding):</li>
</ol>
<pre><strong>      CREATE OR REPLACE FUNCTION chp08.Find_PlaceNames(search_string text,</strong><br/><strong>        num_results int DEFAULT 5,</strong><br/><strong>        OUT geom geometry,</strong><br/><strong>        OUT place_name character varying)</strong><br/><strong>      RETURNS SETOF RECORD </strong><strong>AS $$</strong><br/><strong>      BEGIN</strong><br/><strong>        RETURN QUERY</strong><br/><strong>        SELECT the_geom as geom, name as place_name</strong><br/><strong>        FROM chp08.geonames</strong><br/><strong>        WHERE name @@ to_tsquery(search_string)</strong><br/><strong>        LIMIT num_results;</strong><br/><strong>      END; 
      $$ LANGUAGE plpgsql;</strong> </pre>
<ol start="10">
<li>Query this second function to check if it is working properly:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT * FROM chp08.Find_PlaceNames('Rocca', 10);</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2c7d1318-9afa-40bf-953b-9ba113f1b229.png" style="width:17.17em;height:19.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, you wrote two PostgreSQL functions to perform geocoding and reverse geocoding. For both the functions, you defined a set of input and output parameters, and after some PL/PostgreSQL processing, you returned a set of records to the function client, given by executing a query.</p>
<p>As the input parameters, the <kbd>Get_Closest_PlaceNames</kbd> function accepts a PostGIS geometry and an optional <kbd>num_results</kbd> parameter that is set to a default of 5 in case the function caller does not provide it. The output of this function is <kbd>SETOF RECORD</kbd>, which is returned after running a query in the function body (defined by the <kbd>$$</kbd> notation). Here, the query finds the places closest to the centroid of the input geometry. This is done using an indexed nearest neighbor search (KNN index), a new feature available in PostGIS 2.</p>
<p>The <kbd>Find_PlaceNames</kbd> function accepts as the input parameters a search string to look for and an optional <kbd>num_results</kbd> parameter, which in this case is also set to a default of <kbd>5</kbd> if not provided by the function caller. The output is a <kbd>SETOF RECORD</kbd>, which is returned after running a query that uses the <kbd>to_tsquery</kbd> PostgreSQL text search function. The results of the query are the places from the database that contain the <kbd>search_string</kbd> value in the name field.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Geocoding using the OSM datasets with trigrams</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will use <strong>OpenStreetMap</strong> streets' datasets imported in PostGIS to implement a very basic Python class in order to provide geocoding features to the class' consumer. The geocode engine will be based on the implementation of the PostgreSQL trigrams provided by the <kbd>contrib</kbd> module of PostgreSQL: <kbd>pg_trgm</kbd>.</p>
<p>A trigram is a group of three consecutive characters contained in a string, and it is a very effective way to measure the similarity of two strings by counting the number of trigrams they have in common.</p>
<p>This recipe aims to be a very basic sample to implement some kinds of geocoding functionalities (it will just return one or more points from a street name), but it could be extended to support more advanced features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>For this recipe, make sure you have the latest GDAL, at least version 1.10, as you will use it with the <kbd>ogr2ogr</kbd> the OGR OSM driver (<a href="http://www.gdal.org/drv_osm.html"><span class="URLPACKT">http://www.gdal.org/drv_osm.html</span></a>):</li>
</ol>
<pre>      <strong>$ ogrinfo --version GDAL 2.1.2, released 2016/10/24</strong>
      <strong>$ ogrinfo --formats | grep -i osm</strong>
    <strong>  -&gt; "OSM -vector- (rov): OpenStreetMap XML and PBF"</strong></pre>
<ol start="2">
<li>As you will use PostgreSQL trigrams, install the PostgreSQL <kbd>contrib</kbd> package (which includes <kbd>pg_trgm</kbd>). The Windows EDB installer should already include this. In an Ubuntu 12.4 box, the following command will help you to do it:</li>
</ol>
<pre>      <strong>$ sudo apt-get install postgresql-contrib-9.1</strong></pre>
<ol start="3">
<li>Make sure to add the <kbd>pg_trgm</kbd> extension to the database:</li>
</ol>
<pre>      <strong>postgis_cookbook=# CREATE EXTENSION pg_trgm;</strong>
      <strong>CREATE EXTENSION</strong></pre>
<p style="padding-left: 60px">You will need to use some OSM datasets included in the source for this chapter. (in the <kbd>data/chp08</kbd> book's dataset directory). If you are using Windows, be sure to have installed the OSGeo4W suite, as suggested in the initial instructions for this chapter.</p>
<ol start="4">
<li>If you are using Linux, follow the initial instructions for this chapter and create a Python virtual environment in order to keep a Python-isolated environment to be used for all the Python recipes of this book. Then, activate it as follows:</li>
</ol>
<pre>      <strong>$ source postgis-cb-env/bin/activate</strong></pre>
<ol start="5">
<li>Once the environment has been activated, if you still haven't done so, you can install the Python packages needed for this recipe:</li>
</ol>
<pre>      <strong>(postgis-cb-env)$ pip install pygdal</strong>
      <strong>(postgis-cb-env)$ pip install psycopg2</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>First, check out how the OSM <kbd>.pbf</kbd> file is built using <kbd>ogrinfo</kbd>. PBF is a binary format intended as an alternative to the OSM XML format, mainly because it is much smaller. As you must have noticed, it is composed of several layersâyou will export the <kbd>lines</kbd> layer to PostGIS as that layer contains the street names that you will use for the overall geocoding process:</li>
</ol>
<pre><strong>      $ ogrinfo lazio.pbf</strong><br/><strong>        Had to open data source read-only.</strong><br/><strong>        INFO: Open of `lazio.pbf'</strong><br/><strong>          using driver `OSM' successful.</strong><br/><strong>      1: points (Point)</strong><br/><strong>      2: lines (Line String)</strong><br/><strong>      3: multilinestrings (Multi Line String)</strong><br/><strong>      4: multipolygons (Multi Polygon) 
      5: other_relations (Geometry Collection)</strong></pre>
<ol start="2">
<li>Export the lines' OSM features to a PostGIS table, using <kbd>ogr2ogr</kbd> (<kbd>ogr2ogr</kbd>, as always, will implicitly create the GiST index that is needed by the <kbd>pg_trgm</kbd> module to run):</li>
</ol>
<pre><strong>      $ ogr2ogr -f PostgreSQL -lco GEOMETRY_NAME=the_geom <br/>      -nln chp08.osm_roads <br/>      PG:"dbname='postgis_cookbook' user='me' <br/>      password='mypassword'" lazio.pbf lines</strong> </pre>
<ol start="3">
<li>Now try a trigram matching to identify the road names similar to a given search text, using a query such as the following. Note that the <kbd>similarity</kbd> function returns a value that decreases from <kbd>1</kbd> to <kbd>0</kbd> as the similarity of the word decreases (with <kbd>1</kbd>, the strings are identical; with <kbd>0</kbd>, they are totally different):</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT name, <br/>        similarity(name, 'via benedetto croce') AS sml,<br/>        ST_AsText(ST_Centroid(the_geom)) AS the_geom</strong><br/><strong>      FROM chp08.osm_roads</strong><br/><strong>      WHERE name % 'via benedetto croce'</strong><br/><strong>      ORDER BY sml DESC, name;</strong> </pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/e54ab1a5-61ee-44b3-b120-653b6206aaa8.png" style="width:22.33em;height:27.08em;"/></div>
<ol start="4">
<li>As a variant, you will use the following query to completeÂ the recipe (in this case, when the weight is 0, the strings are identical):</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT name, <br/>        name &lt;-&gt; 'via benedetto croce' AS weight</strong><br/><strong>      FROM chp08.osm_roads</strong><br/><strong>      ORDER BY weight LIMIT 10;</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6075ff38-c013-4785-9269-c431ec2e6447.png" style="width:16.25em;height:18.92em;"/></div>
<ol start="5">
<li>We will use the last query as the SQL core of a Python class, which will provide geocoding features to the consumer, using the layer we just imported in PostGIS (<kbd>chp08.osm_roads</kbd>). First, create a file named <kbd>osmgeocoder.py</kbd> and add the following class to it:</li>
</ol>
<pre>        import sys 
        import psycopg2 
 
        class OSMGeocoder(object): 
          """ 
            A class to provide geocoding features using an OSM <br/>            dataset in PostGIS. 
          """ 
 
          def __init__(self, db_connectionstring): 
            # initialize db connection parameters 
            self.db_connectionstring = db_connectionstring 
 
          def geocode(self, placename): 
            """ 
              Geocode a given place name. 
            """ 
            # here we create the connection object 
            conn = psycopg2.connect(self.db_connectionstring) 
            cur = conn.cursor() 
            # this is the core sql query, using trigrams to detect  
            # streets similar to a given placename 
            sql = """ 
              SELECT name, name &lt;-&gt; '%s' AS weight, 
              ST_AsText(ST_Centroid(the_geom)) as  point 
              FROM chp08.osm_roads 
              ORDER BY weight LIMIT 10; 
            """ % placename 
            # here we execute the sql and return all of the results 
            cur.execute(sql) 
            rows = cur.fetchall() 
            cur.close() 
            conn.close() 
            return rows </pre>
<ol start="6">
<li>Now, add the <kbd>__main__</kbd> check to provide the class user a method to directly use the geocoder from the command line:</li>
</ol>
<pre>        if __name__ == '__main__': 
          # the user must provide at least two parameters, the place name 
          # and the connection string to PostGIS 
          if len(sys.argv) &lt; 3 or len(sys.argv) &gt; 3: 
            print "usage: &lt;placename&gt; &lt;connection string&gt;" 
            raise SystemExit 
          placename = sys.argv[1] 
          db_connectionstring = sys.argv[2] 
          # here we instantiate the geocoder, providing the needed 
          # PostGIS connection parameters 
          geocoder = OSMGeocoder(db_connectionstring) 
          # here we query the geocode method, for getting the  
          # geocoded points for the given placename 
          results = geocoder.geocode(placename) 
          print results </pre>
<ol start="7">
<li>Now you can test the class by calling the script, as shown here:</li>
</ol>
<pre><strong>      (postgis-cb-env)$ python osmgeocoder.py "Via Benedetto Croce" <br/>        "dbname=postgis_cookbook user=me password=mypassword"</strong><br/><strong>      [('Via Benedetto Croce', 0.0, 'POINT(12.6999095325807<br/>                                           42.058016054317)'),...</strong></pre>
<ol start="8">
<li>So, now that you wrote a class that can be used to geocode street names, let's suppose that another user wants to use it to geocode a file with a list of street names in order to import it in a new PostGIS layer. Here is how the user could do this (try this as well). First, create a <kbd>streets.txt</kbd> file with a list of street names; for example:</li>
</ol>
<pre>      <strong>Via Delle Sette Chiese<br/>      Via Benedetto Croce<br/>      Lungotevere Degli Inventori<br/>      Viale Marco Polo</strong>
      <strong>Via Cavour</strong></pre>
<ol start="9">
<li>Now, create a file named <kbd>geocode_streets.py</kbd>Â and add this Python code to it (you are going to use the <kbd>OSMGeocoder</kbd> class to geocode the street name list, and GDAL/OGR to create a new PostGIS layer for storing the geocoded points for the street names):</li>
</ol>
<pre>        from osmgeocoder import OSMGeocoder<br/>        from osgeo import ogr, osr<br/><br/>        # here we read the file<br/>        f = open('streets.txt')<br/>        streets = f.read().splitlines()<br/>        f.close()<br/><br/>        # here we create the PostGIS layer using gdal/ogr<br/>        driver = ogr.GetDriverByName('PostgreSQL')<br/>        srs = osr.SpatialReference()<br/>        srs.ImportFromEPSG(4326)<br/>        pg_ds = ogr.Open(<br/>          "PG:dbname='postgis_cookbook' host='localhost' port='5432' <br/>             user='me' password='mypassword'", update = 1 )<br/>           pg_layer = pg_ds.CreateLayer('geocoded_points', srs = srs, <br/>                 geom_type=ogr.wkbPoint, options = [<br/>             'GEOMETRY_NAME=the_geom',<br/>             'OVERWRITE=YES', <br/>               # this will drop and recreate the table every time<br/>             'SCHEMA=chp08',<br/>          ])<br/>          # here we add the field to the PostGIS layer<br/>          fd_name = ogr.FieldDefn('name', ogr.OFTString)<br/>          pg_layer.CreateField(fd_name)<br/>          print 'Table created.'<br/><br/>          # now we geocode all of the streets in the file <br/>          # using the osmgeocoder class<br/>          geocoder = OSMGeocoder('dbname=postgis_cookbook user=me <br/>                                  password=mypassword')<br/>          for street in streets:<br/>            print street<br/>            geocoded_street = geocoder.geocode(street)[0]<br/>            print geocoded_street<br/>            # format is<br/>            # ('Via delle Sette Chiese', 0.0,<br/>            #  'POINT(12.5002166330412 41.859774874774)')<br/>            point_wkt = geocoded_street[2]<br/>            point = ogr.CreateGeometryFromWkt(point_wkt)<br/>            # we create a LayerDefn for the feature using the <br/>            # one from the layer<br/>            featureDefn = pg_layer.GetLayerDefn()<br/>            feature = ogr.Feature(featureDefn)<br/>            # now we store the feature geometry and <br/>            # the value for the name field<br/>            feature.SetGeometry(point)<br/>            feature.SetField('name', geocoded_street[0])<br/>            # finally we create the feature <br/>            # (an INSERT command is issued only here) 
            pg_layer.CreateFeature(feature) </pre>
<ol start="10">
<li>Run the preceding script, and then check with your favorite PostgreSQL client or with a GIS desktop tool if the points for the street names were correctly geocoded:</li>
</ol>
<pre><strong>      (postgis-cb-env)capooti@ubuntu:~/postgis_cookbook/working/chp08$  <br/>      python geocode_streets.py</strong><br/><strong>      Table created.</strong><br/><strong>      Via Delle Sette Chiese</strong><br/><strong>      ('Via delle Sette Chiese', 0.0, <br/>       'POINT(12.5002166330412 41.859774874774)')</strong><br/><strong>      ...</strong><br/><strong>      Via Cavour 
      ('Via Cavour', 0.0, 'POINT(12.7519263341222 41.9631244835521)')</strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>For this recipe, you first imported an OSM dataset to PostGIS with <kbd>ogr2ogr</kbd>, using the GDAL OSM driver.</p>
<p>Then, you created a Python class, <kbd>OSMGeocoder</kbd>, to provide very basic support to the class consumer for geocoding street names, using the OSM data imported in PostGIS. For this purpose, you used the trigram support included in PostgreSQL with the <kbd>pg_trgm contrib</kbd> module.</p>
<p>The class that you have written is mainly composed of two methods: the <kbd>__init__</kbd> method, where the connection parameters must be passed in order to instantiate an <kbd>OSMGeocoder</kbd> object, and the <kbd>geocode</kbd> method. The <kbd>geocode</kbd> method accepts an input parameter, <kbd>placename</kbd>, and creates a connection to the PostGIS database using the Psycopg2 library in order to execute a query to find the streets in the database with a name similar to the <kbd>placename</kbd> parameter.</p>
<p>The class can be consumed both from the command line, using the <kbd>__name__ == '__main__'</kbd> code block, or from an external Python code. You tried both approaches. In the latter, you created another Python script, where you imported the <kbd>OSMGeocoder</kbd> class combined with the GDAL/OGR Python bindings to generate a new PostGIS point layer with features resulted from a list of geocoded street names.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Geocoding with geopy and PL/Python</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will geocode addresses using web geocoding APIs, such as Google Maps, Yahoo! Maps, Geocoder, GeoNames, and so on. Be sure to read the terms of service of these APIs carefully before using them in production.</p>
<p>The <kbd>geopy</kbd> Python library (<a href="https://github.com/geopy/geopy"><span class="URLPACKT">https://github.com/geopy/geopy</span></a>) offersÂ convenient uniform access to all of these web services. Therefore, you will use it to create a PL/Python PostgreSQL function that can be used in your SQL commands to query all of these engines.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>Install <kbd>geopy</kbd> globally. (You cannot use a virtual environment in this case, as the user running the PostgreSQL service needs to access it on its Python path.)</li>
</ol>
<p style="padding-left: 60px">In a Debian/Ubuntu box, it is as easy as typing the following:</p>
<pre>      <strong>$ sudo pip install geopy</strong></pre>
<p style="padding-left: 60px">In Windows, you can use the following command:</p>
<pre>      <strong>&gt; pip install geopy</strong></pre>
<ol start="2">
<li>If you still have not used PL/Python, verify whether your PostgreSQL server installation supports it. The Windows EDB installer should already include support, but this is not the default if you are using, for example, Ubuntu 16.04 LTS, so you most likely need to install it:</li>
</ol>
<pre>      <strong>$ sudo apt-get install postgresql-plpython-9.1</strong></pre>
<ol start="3">
<li>Install PL/Python in the database (you could consider installing it in the <kbd>template1</kbd> database; this way, every newly created database will have PL/Python support by default):</li>
</ol>
<pre><strong>      $ psql -U me postgis_cookbook</strong><br/><strong>      psql (9.1.6, server 9.1.8)</strong><br/><strong>      Type "help" for help. 
      postgis_cookbook=# CREATE EXTENSION plpythonu; </strong></pre>
<div class="packt_infobox"><span class="InformationBoxPACKTChar">Alternatively, you could add PL/Python support to your database, using theÂ </span><kbd>createlang</kbd><span class="InformationBoxPACKTChar">Â shell command (this is the only way if you are using PostgreSQL Version 9.1 and lower):<br/>
<kbd>$ createlang plpythonu postgis_cookbook</kbd></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>As the first test, open your favorite SQL client (<kbd>psql</kbd> or <kbd>pgAdmin</kbd>), and write a very basic PL/Python function, just using the GoogleV3 geocoding API with <kbd>geopy</kbd>. The function will accept the address string as an input parameter and, after importing <kbd>geopy</kbd>, it will instantiate a <kbd>geopy</kbd> Google Geocoder, run the geocode process, and then return the point geometry, using the <kbd>ST_GeomFromText</kbd> function and the <kbd>geopy</kbd> output:</li>
</ol>
<pre>        CREATE OR REPLACE FUNCTION chp08.Geocode(address text)<br/>          RETURNS geometry(Point,4326) AS $$<br/>          from geopy import geocoders<br/>          g = geocoders.GoogleV3()<br/>          place, (lat, lng) = g.geocode(address)<br/>          plpy.info('Geocoded %s for the address: %s' % (place, address))<br/>          plpy.info('Longitude is %s, Latitude is %s.' % (lng, lat))<br/>          plpy.info("SELECT ST_GeomFromText('POINT(%s %s)', 4326)" <br/>                    % (lng, lat))<br/>          result = plpy.execute("SELECT ST_GeomFromText('POINT(%s %s)',<br/>                                4326) AS point_geocoded" % (lng, lat))<br/>          geometry = result[0]["point_geocoded"]<br/>          return geometry 
        $$ LANGUAGE plpythonu; </pre>
<ol start="2">
<li>After creating the function, try to test it:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT chp08.Geocode('Viale Ostiense 36, Rome');</strong><br/><strong>      INFO:  Geocoded Via Ostiense, 36, 00154 Rome, <br/>      Italy for the address: Viale Ostiense 36, Rome</strong><br/><strong>      CONTEXT:  PL/Python function "geocode"</strong><br/><strong>      INFO:  Longitude is 12.480457, Latitude is 41.874345.</strong><br/><strong>      CONTEXT:  PL/Python function "geocode"</strong><br/><strong>      INFO:  SELECT ST_GeomFromText('POINT(12.480457 41.874345)', 4326)</strong><br/><strong>      CONTEXT:  PL/Python function "geocode"</strong><br/><strong>                       geocode 
      ---------------------------------------------------- 
      0101000020E6100000BF44BC75FEF52840E7357689EAEF4440 
      (1 row)</strong> </pre>
<ol start="3">
<li>Now, you will make the function a little bit more sophisticated. First, you will add another input parameter to let the user specify the geocode API engine (defaulting to GoogleV3). Then, using the Python <kbd>try...except</kbd> block, you will try to add some kind of error management in case the geopy Geocoder cannot manage to return valid results for any reason:</li>
</ol>
<pre>        CREATE OR REPLACE FUNCTION chp08.Geocode(address text,<br/>                                                 api text DEFAULT 'google')<br/>        RETURNS geometry(Point,4326) AS $$<br/>        from geopy import geocoders<br/>        plpy.info('Geocoing the given address using the %s api' % (api))<br/>        if api.lower() == 'geonames':<br/>          g = geocoders.GeoNames()<br/>        elif api.lower() == 'geocoderdotus':<br/>          g = geocoders.GeocoderDotUS()<br/>        else: # in all other cases, we use google<br/>          g = geocoders.GoogleV3()<br/>        try:<br/>          place, (lat, lng) = g.geocode(address)<br/>          plpy.info('Geocoded %s for the address: %s' % (place, address))<br/>           plpy.info('Longitude is %s, Latitude is %s.' % (lng, lat))<br/>          result = plpy.execute("SELECT ST_GeomFromText('POINT(%s %s)',<br/>                                4326) AS point_geocoded" % (lng, lat))<br/>          geometry = result[0]["point_geocoded"]<br/>          return geometry<br/>        except:<br/>          plpy.warning('There was an error in the geocoding process,<br/>                        setting geometry to Null.')<br/>          return None 
        $$ LANGUAGE plpythonu; </pre>
<ol start="4">
<li>Test the new version of your function without specifying the parameter for the API. In such a case, it should default to the Google API:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT chp08.Geocode('161 Court Street, <br/>                         Brooklyn, NY');</strong><br/><strong>      INFO:  Geocoing the given address using the google api</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  Geocoded 161 Court Street, Brooklyn, NY 11201, <br/>             USA for the address: 161 Court Street, Brooklyn, NY</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  Longitude is -73.9924659, Latitude is 40.688665.</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  SELECT ST_GeomFromText('POINT(-73.9924659 40.688665)', 4326)</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>                       geocode2</strong><br/><strong>      ----------------------------------------------------</strong><br/><strong>      0101000020E61000004BB9B18F847F52C02E73BA2C26584440 
      (1 row)</strong> </pre>
<ol start="5">
<li>If you test it by specifying a different API, it should return the result processed for the given API. For example:</li>
</ol>
<pre><strong>      postgis_cookbook=# SELECT chp08.Geocode('161 Court Street, <br/>                         Brooklyn, NY', 'GeocoderDotUS');</strong><br/><strong>      INFO:  Geocoing the given address using the GeocoderDotUS api</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  Geocoded 161 Court St, New York, NY 11201 for the address: 161 <br/>             Court Street, Brooklyn, NY</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  Longitude is -73.992809, Latitude is 40.688774.</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>      INFO:  SELECT ST_GeomFromText('POINT(-73.992809 40.688774)', 4326)</strong><br/><strong>      CONTEXT:  PL/Python function "geocode2"</strong><br/><strong>                       geocode2</strong><br/><strong>      ----------------------------------------------------</strong><br/><strong>      0101000020E61000002A8BC22E8A7F52C0E52A16BF29584440 
      (1 row)</strong></pre>
<ol start="6">
<li>As a bonus step, create a table in PostgreSQL with street addresses, and generate a new point PostGIS layer storing the geocoded points returned by the Geocode function.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You wrote a PL/Python function to geocode an address. For this purpose, you used the <kbd>geopy</kbd> Python library, which lets you query several geocoding APIs in the same manner.</p>
<p>Using geopy, you need to instantiate a <kbd>geocoder</kbd> object with a given API and query it to get the results, such as a place name and a couple of coordinates. You can use the <kbd>plpy</kbd> module utilities to run a query on the database using the PostGIS <kbd>ST_GeomFromText</kbd> function, and log informative messages and warnings for the user.</p>
<p>If the geocoding process fails, you return a <kbd>NULL</kbd> geometry to the user with a warning message, using a <kbd>try..except</kbd> Python block.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing NetCDF datasets with Python and GDAL</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will write a Python script to import data from the NetCDF format to PostGIS.</p>
<p>NetCDF is an open standard format, widely used for scientific applications, and can contain multiple raster datasets, each composed of a spectrum of bands. For this purpose, you will use the GDAL Python bindings and the popular NumPy (<a href="http://www.numpy.org/"><span class="URLPACKT">http://www.numpy.org/</span></a>) scientific library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<ol>
<li>If you are using Windows, be sure to install OSGeo4W, as suggested in the initial instructions for this chapter. This will include Python and GDAL Python bindings with NumPy support.</li>
</ol>
<p style="padding-left: 60px">For Linux users, in case you did not do it yet, follow the initial instructions for this chapter and create a Python virtual environment in order to keep a Python-isolated environment to be used for all the Python recipes in this book. Then, activate it:</p>
<pre>      <strong>$ source postgis-cb-env/bin/activate</strong></pre>
<ol start="2">
<li>For this recipe, you need the GDAL Python bindings and NumPy, the latter being needed by a GDAL method (<kbd>ReadAsArray</kbd>) for arrays. In the most likely case, you have already installed GDAL in your virtual environment as you have been using it for other recipes, so be sure to remove it and reinstall it after installing NumPy. In fact, GDAL needs to be compiled with NumPy support if you want to use its array's features:</li>
</ol>
<pre>      <strong>(postgis-cb-env)$ pip uninstall gdal<br/>      (postgis-cb-env)$ pip install numpy</strong>
      <strong>(postgis-cb-env)$ pip install gdal</strong></pre>
<ol start="3">
<li>For the purpose of this recipe, you will use a sample dataset from NOAA <strong>Earth System Research Laboratory</strong> (<strong>ESRL</strong>). The excellent ESRL web portal offers a plethora of data in the NetCDF format to be freely downloaded. For example, download the following dataset from the ESRL CPC Soil Moisture data repository (you can find, as usual, a copy of this dataset in the book's dataset directory for this chapter):Â <a href="https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html">https://www.esrl.noaa.gov/psd/data/gridded/data.cpcsoil.html</a><span class="URLPACKT">.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Carry out the following steps:</p>
<ol>
<li>As the first step, investigate the NetCDF format of the dataset you downloaded using <kbd>gdalinfo</kbd>. This kind of dataset is composed of several subdatasets, as you may have realized by looking at the <kbd>gdalinfo</kbd> output:</li>
</ol>
<pre>      <strong>$ gdalinfo NETCDF:"soilw.mon.ltm.v2.nc"</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/595b0036-e52e-4066-bd6b-84032572cfb1.png" style="width:47.50em;height:26.08em;"/></div>
<ol start="2">
<li>Use <kbd>gdalinfo</kbd> to investigate one of the file's subdatasets. The syntax that the NetCDF GDAL driver (<a href="http://www.gdal.org/frmt_netcdf.html"><span class="URLPACKT">http://www.gdal.org/frmt_netcdf.html</span></a>) uses is to append a colon followed by the variable name at the end of the filename. For example, try to figure out how many bands the <kbd>soilw</kbd> subdataset is composed of. This subdataset, representing <kbd>lwe_thickness_of_soil_moisture_content</kbd>, is composed of 12 bands. Each band, according to the information derived by its metadata, represents the CPC Monthly Soil Moisture for a given month. The month is identified by the <kbd>NETCDF_DIM_time</kbd> metadata value, which is the number of days from the beginning of the year (<kbd>0</kbd> for January, <kbd>31</kbd> for February, <kbd>59</kbd> for March, and so on):</li>
</ol>
<pre>      <strong>$  gdalinfo NETCDF:"soilw.mon.ltm.v2.nc":soilw</strong></pre>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/91f75db2-f04e-488e-927f-034fcabc25f8.png" style="width:47.25em;height:30.83em;"/>'</div>
<pre>      <strong>...(12 bands)...</strong></pre>
<ol start="3">
<li>What you are going to do is create a Python script using GDAL and NumPy. You will read a given NetCDF dataset, iterate its subdatasets, and then iterate each subdataset's bands. For each subdataset, you will create a point PostGIS layer, and you will add a field for each band in order to store the band values in the layer table. Then, you will iterate the band's cells, and for each cell, you will add a point in the layer with the corresponding band's values. Therefore, create a <kbd>netcdf2postgis.py</kbd> file and add the following Python code to it:</li>
</ol>
<pre>        import sys<br/>          from osgeo import gdal, ogr, osr<br/>          from osgeo.gdalconst import GA_ReadOnly, GA_Update<br/><br/>        def netcdf2postgis(file_nc, pg_connection_string,<br/>                           postgis_table_prefix):<br/>          # register gdal drivers<br/>          gdal.AllRegister()<br/>          # postgis driver, needed to create the tables<br/>          driver = ogr.GetDriverByName('PostgreSQL')<br/>          srs = osr.SpatialReference()<br/>          # for simplicity we will assume all of the bands in the datasets<br/>          # are in the same spatial reference, wgs 84<br/>          srs.ImportFromEPSG(4326)<br/><br/>          # first, check if dataset exists<br/>          ds = gdal.Open(file_nc, GA_ReadOnly)<br/>          if ds is None:<br/>            print 'Cannot open ' + file_nc<br/>            sys.exit(1)<br/><br/>          # 1. iterate subdatasets<br/>          for sds in ds.GetSubDatasets():<br/>            dataset_name = sds[0]<br/>            variable = sds[0].split(':')[-1]<br/>            print 'Importing from %s the variable %s...' %<br/>                  (dataset_name, variable)<br/>            # open subdataset and read its properties<br/>            sds = gdal.Open(dataset_name, GA_ReadOnly)<br/>            cols = sds.RasterXSize<br/>            rows = sds.RasterYSize<br/>            bands = sds.RasterCount<br/><br/>            # create a PostGIS table for the subdataset variable<br/>            table_name = '%s_%s' % (postgis_table_prefix, variable)<br/>            pg_ds = ogr.Open(pg_connection_string, GA_Update )<br/>            pg_layer = pg_ds.CreateLayer(table_name, srs = srs, <br/>            geom_type=ogr.wkbPoint, options = [<br/>              'GEOMETRY_NAME=the_geom',<br/>              'OVERWRITE=YES', <br/>                # this will drop and recreate the table every time<br/>              'SCHEMA=chp08',<br/>             ])<br/>            print 'Table %s created.' % table_name<br/><br/>            # get georeference transformation information<br/>            transform = sds.GetGeoTransform()<br/>            pixelWidth = transform[1]<br/>            pixelHeight = transform[5]<br/>            xOrigin = transform[0] + (pixelWidth/2)<br/>            yOrigin = transform[3] - (pixelWidth/2)<br/><br/>            # 2. iterate subdataset bands and append them to data<br/>            data = []<br/>            for b in range(1, bands+1):<br/>              band = sds.GetRasterBand(b)<br/>              band_data = band.ReadAsArray(0, 0, cols, rows)<br/>              data.append(band_data)<br/>              # here we add the fields to the table, a field for each band<br/>              # check datatype (Float32, 'Float64', ...)<br/>              datatype = gdal.GetDataTypeName(band.DataType)<br/>              ogr_ft = ogr.OFTString # default for a field is string<br/>              if datatype in ('Float32', 'Float64'):<br/>                ogr_ft = ogr.OFTReal<br/>              elif datatype in ('Int16', 'Int32'):<br/>                ogr_ft = ogr.OFTInteger<br/>              # here we add the field to the PostGIS layer<br/>              fd_band = ogr.FieldDefn('band_%s' % b, ogr_ft)<br/>              pg_layer.CreateField(fd_band)<br/>              print 'Field band_%s created.' % b<br/><br/>            # 3. iterate rows and cols<br/>            for r in range(0, rows):<br/>              y = yOrigin + (r * pixelHeight)<br/>              for c in range(0, cols):<br/>                x = xOrigin + (c * pixelWidth)<br/>                # for each cell, let's add a point feature<br/>                # in the PostGIS table<br/>                point_wkt = 'POINT(%s %s)' % (x, y)<br/>                point = ogr.CreateGeometryFromWkt(point_wkt)<br/>                featureDefn = pg_layer.GetLayerDefn()<br/>                feature = ogr.Feature(featureDefn)<br/>                # now iterate bands, and add a value for each table's field<br/>                for b in range(1, bands+1):<br/>                  band = sds.GetRasterBand(1)<br/>                  datatype = gdal.GetDataTypeName(band.DataType)<br/>                  value = data[b-1][r,c]<br/>                  print 'Storing a value for variable %s in point x: %s, <br/>                   y: %s, band: %s, value: %s' % (variable, x, y, b, value)<br/>                  if datatype in ('Float32', 'Float64'):<br/>                    value = float(data[b-1][r,c])<br/>                  elif datatype in ('Int16', 'Int32'):<br/>                    value = int(data[b-1][r,c])<br/>                  else:<br/>                    value = data[r,c]<br/>                  feature.SetField('band_%s' % b, value)<br/>                # set the feature's geometry and finalize its creation<br/>                feature.SetGeometry(point) 
                pg_layer.CreateFeature(feature) </pre>
<ol start="4">
<li>To run the <kbd>netcdf2postgis</kbd> method from the command line, add the entry point for the script. The code will check whether the script user is correctly using the three required parameters, which are the NetCDF file path, the GDAL PostGIS connection string, and a prefix/suffix to use for table names in PostGIS:</li>
</ol>
<pre>        if __name__ == '__main__':<br/>          # the user must provide at least three parameters, <br/>          # the netCDF file path, the PostGIS GDAL connection string 
          # and the prefix suffix to use for PostGIS table names<br/>          if len(sys.argv) &lt; 4 or len(sys.argv) &gt; 4:<br/>            print "usage: &lt;netCDF file path&gt; &lt;GDAL PostGIS connection <br/>                   string&gt;&lt;PostGIS table prefix&gt;"<br/>            raise SystemExit<br/>          file_nc = sys.argv[1]<br/>          pg_connection_string = sys.argv[2]<br/>          postgis_table_prefix = sys.argv[3] 
          netcdf2postgis(file_nc, pg_connection_string,<br/>                         postgis_table_prefix) </pre>
<ol start="5">
<li>Run the script. Be sure to use the correct NetCDF file path, GDAL PostGIS connection string (check the format at <a href="http://www.gdal.org/drv_pg.html"><span class="URLPACKT">http://www.gdal.org/drv_pg.html</span></a>), and a table prefix that has to be appended to the table names for tables that will be created in PostGIS:</li>
</ol>
<pre><strong>      (postgis-cb-env)$ python netcdf2postgis.py</strong><br/><strong>      NETCDF:"soilw.mon.ltm.v2.nc"</strong><br/><strong>      "PG:dbname='postgis_cookbook' host='localhost'</strong><br/><strong>      port='5432' user='me' password='mypassword'" netcdf</strong><br/><strong>      Importing from NETCDF:"soilw.mon.ltm.v2.nc":</strong><br/><strong>        climatology_bounds the variable climatology_bounds...</strong><br/><strong>      ...</strong><br/><strong>      Importing from NETCDF:"soilw.mon.ltm.v2.nc":soilw the <br/>        variable soilw...</strong><br/><strong>      Table netcdf_soilw created.</strong><br/><strong>      Field band_1 created.</strong><br/><strong>      Field band_2 created.</strong><br/><strong>      ...</strong><br/><strong>      Field band_11 created.</strong><br/><strong>      Field band_12 created.</strong><br/><strong>      Storing a value for variable soilw in point x: 0.25,</strong><br/><strong>                y: 89.75, band: 2, value: -9.96921e+36</strong><br/><strong>      Storing a value for variable soilw in point x: 0.25,</strong><br/><strong>                y: 89.75, band: 3, value: -9.96921e+36 
      ...</strong> </pre>
<ol start="6">
<li>At the end of the process, check the results by opening one of the output PostGIS tables using your favorite GIS d<span>esktopÂ </span>tool. The following screenshot shows how it looks in the QGIS <kbd>soilw</kbd> layer with the original NetCDF dataset behind it:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c91741bf-91cd-4ad3-8fac-98b45e2400ee.png" style="width:45.50em;height:33.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have used Python with GDAL and NumPy in order to create a command-line utility to import a NetCDF dataset into PostGIS.</p>
<p>A NetCDF dataset is composed of multiple subdatasets, and each subdataset is composed of multiple raster bands. Each band is composed of cells. This structure should be clear to you after investigating a sample NetCDF dataset using the <kbd>gdalinfo</kbd> GDAL command tool.</p>
<p>There are several approaches to exporting cell values to PostGIS. The approach you adopted here is to generate a PostGIS point layer for each subdataset, which is composed of one field for each subdataset band. You then iterated the raster cells and appended a point to the PostGIS layer with the values read from each cell band.</p>
<p>The way you do this with Python is by using the GDAL Python bindings. For reading, you open the NetCDF dataset, and for updating, you open the PostGIS database, using the correct GDAL and OGR drivers. Then, you iterate the NetCDF subdatasets, using the <kbd>GetSubDatasets</kbd> method, and create a PostGIS table named <kbd>NetCDF subdataset variable</kbd> (with the prefix) for each subdataset, using the <kbd>CreateLayer</kbd> method.</p>
<p>For each subdataset, you iterate its bands, using the <kbd>GetRasterBand</kbd> method. To read each band, you run the <kbd>ReadAsArray</kbd> method which uses NumPy to get the band as an array.</p>
<p>For each band, you create a field in the PostGIS layer with the correct field data type that will be able to store the band's values. To choose the correct data type, you investigate the band's data type, using the <kbd>DataType</kbd> property.</p>
<p>Finally, you iterate the raster cells, by reading the correct <em>x</em> and <em>y</em> coordinates using the subdataset transform parameters, available via the <kbd>GetGeoTransform</kbd> method. For each cell, you create a point with the <kbd>CreateGeometryFromWkt</kbd> method, then set the field values, and read from the band array using the <kbd>SetField</kbd> feature method.</p>
<p>Finally, you append the new point to the PostGIS layer using the <kbd>CreateFeature</kbd> method.</p>


            </article>

            
        </section>
    </body></html>