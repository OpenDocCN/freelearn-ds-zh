<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Automating Cloud Cartography</h1>
                </header>
            
            <article>
                
<p class="mce-root">Mapbox has become synonymous with mobile mapping and data visualizations. In addition to their basemap styling toolset, which has been adopted by app developers and cartographers, they are also producing interesting mapping tools written in Python and JavaScript. </p>
<p class="mce-root">Combining those two useful languages into one package, Mapbox recently released the new MapboxGL—Jupyter Python module. This new module allows for instant data visualization creation within a Jupyter Notebook environment. Along with the Mapbox Python SDK, a module that allows API access to account services, Python make it easy to add Mapbox tools and services to enterprise geospatial applications. </p>
<p>In this chapter, we'll learn:</p>
<ul>
<li>How to create a Mapbox account to  generate access tokens</li>
<li>How to style a custom basemap</li>
<li>Read/write access to cloud data and basemaps</li>
<li>How to create a choropleth map </li>
<li>How to create a graduated circle visualization</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">All things cartographic</h1>
                </header>
            
            <article>
                
<p>Founded in 2010 by Eric Gunderson, Mapbox has expanded rapidly and grown beyond its startup roots to become a leader in the cartographic renaissance. Their MapboxGL JavaScript API is a useful library for creating interactive web maps and data visualizations. They have contributed multiple open mapping specifications, including vector tiles, to the geospatial community.  </p>
<p>With a core focus on providing custom basemap tiles to map and app developers, Mapbox has positioned themselves as the leading <span>software company</span> for web mapping and <span>mobile applications</span>. The two Python modules used in this chapter allow GIS managers and developers to integrate their services and tools into an enterprise geographic information ecosystem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to integrate Mapbox into your GIS </h1>
                </header>
            
            <article>
                
<p>With their JavaScript libraries and the new MapboxGL—Jupyter Python module, Mapbox tools are easier than ever to use. Geospatial developers and programmers can integrate their tools into existing GIS workflows or can create new maps and apps that take advantage of the suite of offerings by Mapbox. </p>
<p>Mapbox, like CARTO, allows for account-based cloud data storage. However, their focus is less on analytical tools and more on cartographic tools. For mapping teams, large and small, using Mapbox tools eases the cost of creating and supporting a custom basemap for interactive web maps, and offers greater savings over other map tile options such as the Google Maps API.</p>
<p>Mapbox Studio makes it easy to create a map with a cartographic look and feel that can match the branding of the company or department. The basemaps can be built using existing styles and overlaid with your organization's layers, or a completely new basemap can be designed. It even allows for styling to be based on an image that is dropped into the studio, assigning colors to features based on a histogram generated from the pixels in the image. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapbox tools</h1>
                </header>
            
            <article>
                
<p><span>Employing leaders in the geospatial field (such as Mapbox open source lead Sean Gillies, a major developer of Shapely, Fiona, and Rasterio), Mapbox has contributed to analysis and mapping Python libraries that are available under open source license. Their new MapboxGL—Jupyter library represents a new way to take advantage of their suite of tools in combination with other Python modules (such as Pandas/GeoPandas) and multiple data types, such as GeoJSON, CSVs, and even shapefiles.</span></p>
<p><span>Besides the new Python module, Mapbox's open source tools include the MapboxGL JavaScript library, built on the <strong>Web Graphics Library</strong> (<strong>WebGL</strong>), and the Mapbox Python SDK.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MapboxGL.js</h1>
                </header>
            
            <article>
                
<p><span>MapboxGL is built on top of <kbd>Leaflet.js</kbd>, a well-known JavaScript mapping library. Released in 2011, Leaflet supports a wide variety of well-known web mapping applications, including Foursquare, Craigslist, and Pinterest. The developer of Leaflet, Vladimir Agafonkin, has been working for Mapbox since 2013.</span></p>
<p>Building on the original Leaflet development effort, <kbd>MapboxGL.js</kbd> incorporates the WebGL library, which takes advantage of the HTML 5 <kbd>canvas</kbd> tag to support web graphics without a plug-in. <kbd>MapboxGL.js</kbd> supports vector tiles, as well as 3D environments that zoom and pan smoothly. It supports GeoJSON overlays as well as markers and shapes. Events, including clicks, zooms, and pans, can be used to trigger data processing functions, making it perfect for interactive web mapping applications. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapbox Python SDK</h1>
                </header>
            
            <article>
                
<p>The Mapbox Python SDK is used to access most Mapbox services, including directions, geocoding, analytics, and datasets. Low-level access to the cloud-based services supporting data editing and upload, administrative management, and location-based queries, allows for enterprise integration with, and extension of, local GIS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the Python SDK</h1>
                </header>
            
            <article>
                
<p>Use <kbd>pip</kbd> to install the Python SDK, allowing API access to the Mapbox services. This module is not required to use the MapboxGL—Jupyter tools, but it is useful for uploads and queries:</p>
<pre><strong>C:\Python3Geospatial&gt;pip install mapbox</strong></pre>
<div class="packt_infobox">Download the Mapbox Python SDK here: <br/>
<a href="https://github.com/mapbox/mapbox-sdk-py">https://github.com/mapbox/mapbox-sdk-py</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Mapbox</h1>
                </header>
            
            <article>
                
<p>To get started using Mapbox tools and Mapbox Studio, you'll need to sign up for an account. This will allow you to generate API keys that are required for adding Mapbox basemap tiles to web maps, as well as to create the custom basemaps that will differentiate your maps. With this account, you can also load data into the cloud to use within your maps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Signing up for a Mapbox account</h1>
                </header>
            
            <article>
                
<p>To use Mapbox tools and basemaps, you must sign up for an account. This is a straightforward process and involves supplying a username, an email, and a password:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7e90dd7d-5cb0-4c8f-82a5-4e283e818c38.png" style="width:54.58em;height:42.50em;"/></div>
<p>Once you are signed up, you'll be taken to the <span class="packt_screen">Account</span> <span class="packt_screen">Dashboard</span>, where API access token can be generated and <span class="packt_screen">Mapbox Studio</span> can be accessed. The <span class="packt_screen">Dashboard</span> also has your account statistics on the number of API calls to the variety of services available, including directions, geocoding, and datasets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an API token</h1>
                </header>
            
            <article>
                
<p>With the new account comes the <span class="packt_screen">Account Dashboard</span>, which supplies an API access token by default. This public access token or key begins with <span class="packt_screen">pk</span> and is a long string of characters. This API access token is used to authenticate all of the maps and apps that will be built using this account. Copy the string of characters and add it to your maps:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7c65efb6-75f3-4db5-bf14-e0688f5c508b.png" style="width:50.58em;height:27.00em;"/></div>
<p>To create a new API access token, push the <span class="packt_screen">Create a token</span> button and select the access levels that it will allow:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b3f8431-1c31-4e78-9584-5e72c58de0d7.png" style="width:39.67em;height:42.83em;"/></div>
<p>Within the JavaScript code, the API <span>access token</span> is passed to the MapboxGL object to enable access to tiles and tools. Here is a simple web map using HTML/JavaScript as an example of how the access token is used to create a map. Replace the access token mentioned in the following code with your own public access token:</p>
<pre>&lt;html&gt;&lt;head&gt;<br/>&lt;script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'&gt;&lt;/script&gt;<br/>&lt;link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css' rel='stylesheet' /&gt;<br/>&lt;/head&gt;&lt;body&gt;<br/>&lt;div id='map' style='width: 400px; height: 300px;'&gt;&lt;/div&gt;<br/>&lt;script&gt;<br/>mapboxgl.accessToken = '<strong>pk.eyJ1IjoibG9raXByZXNpZGVud0.8S8l9kH4Ws_ES_ZCjw2i8A</strong>';<br/>var map = new mapboxgl.Map({<br/>    container: 'map',<br/>    style: 'mapbox://styles/mapbox/streets-v9'<br/>});<br/>&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</pre>
<p>Save this code as "index.html", and open it using a browser to see the simple map. Make sure that you replace the API <span>access token</span> in the earlier example with your own key, or the map will not appear. </p>
<div class="packt_infobox">Explore the documentation to understand the various configurations available for the API access token:<br/>
<a href="https://www.mapbox.com/help/how-access-tokens-work/">https://www.mapbox.com/help/how-access-tokens-work/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding data to a Mapbox account</h1>
                </header>
            
            <article>
                
<p>Mapbox supports the use of your own data. Not only can you style basemap tiles, but you can even add your own data to the tiles to make them more relevant to your customers or users. This can be managed programmatically using the Mapbox Python SDK and the uploads and datasets APIs. </p>
<p>To upload data, you must create a secret API access token. These are created using the same <span class="packt_screen">Create a token</span> process detailed earlier, but include secret scopes. Choose the following scopes to allow for dataset and tileset read and write capabilities:</p>
<ul>
<li><span class="packt_screen">DATASETS:WRITE</span></li>
<li><span class="packt_screen">UPLOADS:READ</span></li>
<li><span class="packt_screen">UPLOADS:WRITE</span></li>
<li><span class="packt_screen">TILESETS:READ</span></li>
<li><span class="packt_screen">TILESETS:WRITE</span></li>
</ul>
<div class="packt_infobox"><span>Read more about loading data into your Mapbox account here:</span><br/>
<a href="https://www.mapbox.com/help/how-uploads-work/">https://www.mapbox.com/help/how-uploads-work/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tilesets</h1>
                </header>
            
            <article>
                
<p>Tilesets are rasters which are tiled to create <strong>slippy maps</strong>, allowing them to overlay on a basemap. They can be generated from vector data to create custom basemaps with your own data featured. Using the <kbd>Uploader</kbd> class from the Mapbox Python SDK, GeoJSON files and shapefiles can be programmatically loaded as tilesets into your cloud account.</p>
<div class="packt_infobox">Read more about tilesets here:<br/>
<a href="https://www.mapbox.com/api-documentation/#tilesets">https://www.mapbox.com/api-documentation/#tilesets</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Datasets</h1>
                </header>
            
            <article>
                
<p>Datasets are GeoJSON layers, which can be more frequently edited than tilesets. While you can upload datasets using the <span class="packt_screen">Account Dashboard</span>, to load a dataset larger than 5 MB you must use the datasets API. </p>
<div class="packt_infobox"><span>Read more about datasets here:</span><br/>
<a href="https://www.mapbox.com/api-documentation/#datasets"><span>https://www.mapbox.com/api-documentation/#datasets</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example – uploading a GeoJSON dataset</h1>
                </header>
            
            <article>
                
<p>The <kbd>mapbox</kbd> module has a <kbd>Datasets</kbd> class that is used to create and populated datasets in the account. This demonstration code will read from a zip code GeoJSON file and load one zip code GeoJSON object into a new dataset. Pass the secret access token to the <kbd>Datasets</kbd> class:</p>
<pre>from mapbox import Datasets<br/>import json<br/>datasets = Datasets(access_token='{secrettoken}')<br/>create_resp = <strong>datasets.create</strong>(name="Bay Area Zips", <br/>              description = "ZTCA zones for the Bay Area")<br/>listing_resp = datasets.list()<br/>dataset_id = [ds['id'] for ds in listing_resp.json()][0]<br/>data = json.load(open(r'ztca_bayarea.geojson'))<br/>for count,feature in enumerate(data['features'][:1]):<br/>    resp = <strong>datasets.update_feature</strong>(dataset_id, count, feature)</pre>
<p>This will add one zip code to the layer, which can be viewed from the <span class="packt_screen">Account Dashboard</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9deb66ea-c49d-465f-a445-6cb157c5e3db.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example – uploading data as a tileset</h1>
                </header>
            
            <article>
                
<p>Tilesets can be added to custom basemap styles, making it possible to quickly load your data layers. This demonstration code uses the secret token with read and write capabilities to upload a GeoJSON file as a tileset using the Mapbox Python SDK:</p>
<pre>token = 'sk.eyJ1IjoibG9oxZGdqIn0.Y-qlJfzFzr3MGkOPPbtZ5g' #example secret token<br/>from mapbox import Uploader<br/>import uuid<br/>set_id = uuid.uuid4().hex<br/>service = Uploader(access_token=token)<br/>with open('ztca_bayarea.geojson', 'rb') as src:<br/>    response = service.upload(src, set_id)<br/>print(response)</pre>
<p>If the response returned is a <kbd>201</kbd> response, the upload has succeeded.</p>
<div class="packt_infobox">Read more about the Uploads API here:<br/>
<a href="https://www.mapbox.com/api-documentation/?language=Python">https://www.mapbox.com/api-documentation/?language=Python</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapbox Studio</h1>
                </header>
            
            <article>
                
<p>Creating a custom basemap can be a time-consuming process for even experienced cartographers. To help ease this process, Mapbox engineers have used <strong>Open Street Map</strong> (<strong>OSM</strong>) data to generate pre-built custom basemaps that can be used in commercial and non-commercial applications. Using Mapbox Studio, these styles can also be adjusted to add more custom touches. Also, basemaps can be built from the ground up to create a specific look for your application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c15cb8cd-5290-41d8-9a58-6e51f5ccc3a1.png"/></div>
<p><span>To access Mapbox Studio, log into the <span class="packt_screen">Account Dashboard</span> and click the <span class="packt_screen">Mapbox Studio</span> link. In this Studio environment, you can manage basemaps, tilesets, and datasets.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Customizing a basemap</h1>
                </header>
            
            <article>
                
<p>Click the <span class="packt_screen">New Style</span> button and select the <span class="packt_screen">Satellite Streets</span> theme:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/379c4100-c11a-4300-9c9d-533480bfc71a.png" style="width:61.00em;height:28.75em;"/></div>
<p>A quick tutorial explains the customization options. A variety of available layers have been added, and both their labeling and styling can be adjusted by clicking on the layers in the table of contents. New layers can be added as well, including account tilesets:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cadcf094-22bc-47d5-9fd6-015e22207530.png" style="width:60.25em;height:33.75em;"/></div>
<p><span>Map zoom levels, bearing, pitch, and initial coordinates can be adjusted. Using the <span class="packt_screen">Map position</span> menu, these map parameters can be changed and locked as the default position using the <span class="packt_screen">Lock</span> button at the bottom:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c13f6524-9725-4c66-8731-776797dc370f.png"/></div>
<p>Explore other styling options, such as label colors and layer scale levels. Once you have completed the customizations, publish the style by clicking the <span class="packt_screen">Publish style</span> button. The style URL is added to MapboxGL visualizations for these Jupyter Notebook exercises or in web maps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a tileset</h1>
                </header>
            
            <article>
                
<p>To add your data to the basemap style, push the Layer button and select a tileset from the available selection. The zip codes tileset loaded earlier using the Mapbox Python SDK should be available, and can be added to the basemap and styled:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cfc3fdb9-9c6c-46aa-9bd9-5de97af7eea2.jpg" style="width:89.25em;height:45.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Virtual environment</h1>
                </header>
            
            <article>
                
<p>Start a virtual environment using <kbd>virtualenv</kbd> (see the previous chapter for installation) and use <kbd>pip</kbd> to install the modules listed as follows. If you had a folder path of <kbd>C:\Python3Geospatial</kbd>, <kbd>virtualenv</kbd> will create a virtual environment folder, here called <kbd>mapboxenv</kbd>, which can be activated as shown: </p>
<pre><strong>C:\Python3Geospatial&gt;virtualenv mapboxenv</strong><br/><strong>Using base prefix 'c:\\users\\admin\\appdata\\local\\programs\\python\\python36'</strong><br/><strong>New python executable in C:\Python3Geospatial\mapboxenv\python.exe</strong><br/><strong>Installing setuptools, pip, wheel...done.</strong><br/><br/><strong>C:\Python3Geospatial&gt;mapboxenv\Scripts\activate</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing MapboxGL – Jupyter</h1>
                </header>
            
            <article>
                
<p>The MapboxGL—Jupyter library is available using <kbd>pip</kbd> from the <a href="http://pypi.org">PyPI.org</a> repository:</p>
<pre><strong>(mapboxenv) C:\Python3Geospatial&gt;pip install mapboxgl</strong></pre>
<p>All of the supporting modules will be located and installed along with the core libraries created by Mapbox.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Jupyter Notebooks</h1>
                </header>
            
            <article>
                
<p>Install the Jupyter Notebooks library in the virtual environment:</p>
<pre><strong>(mapboxenv) C:\Python3Geospatial&gt;pip install jupyter</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Pandas and GeoPandas</h1>
                </header>
            
            <article>
                
<p>Pandas should already be installed, as it is installed with GeoPandas, but if it has not yet been installed, use <kbd>pip</kbd> to find it in the <a href="http://pypi.org">PyPI.org</a> repository:</p>
<pre><strong><span>(mapboxenv) C:\Python3Geospatial&gt;</span>pip install geopandas</strong></pre>
<div class="packt_infobox">If you have any issues installing these modules on a Windows computer, explore the pre-built wheel binaries here (use <kbd>pip</kbd> to install them after download):<br/>
<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">https://www.lfd.uci.edu/~gohlke/pythonlibs/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Jupyter Notebook server</h1>
                </header>
            
            <article>
                
<p>Starting a Jupyter Notebook server is easy. When using a virtual environment, you'll need to activate the environment first, and then start the server. If not, make sure that Python and the location of the Notebook server are in the path environment variable.</p>
<p>Open the command prompt and enter <kbd>jupyter notebook</kbd> to start the server:</p>
<pre><strong>(mapboxenv) C:\Python3Geospatial&gt;jupyter notebook</strong></pre>
<p>The server will start and indicate the specifics of its port number and a token that can be used to relog into the web browser:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42a1dabb-19f7-4b47-ba68-cacfeb5191ac.png" style="width:52.17em;height:19.92em;"/></div>
<p>Starting the server will open a browser window in the system browser. The server address is <kbd>localhost</kbd>, and the default port is <kbd>8888</kbd>. The browser will open at <kbd>http://localhost:8888/tree</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b060dfb-333b-4206-af65-68be15997378.png" style="width:39.67em;height:29.75em;"/></div>
<p>Click the <span class="packt_screen">New</span> button to create a new Notebook. Select the Python version from the Notebook section, and the new Notebook will open in a second tab. This Notebook should be renamed, as it quickly becomes difficult to organize Notebooks that are untitled:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ac90a315-68f3-4341-9e0e-e0532f262576.png" style="width:56.42em;height:27.42em;"/></div>
<p>Once the window has opened, the coding environment is live. In this example, we will import census tract data using GeoPandas, convert it to point data, select specific columns, and visualize it using MapboxGL—Jupyter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importing data using GeoPandas</h1>
                </header>
            
            <article>
                
<p>Import the required modules and assign the API key to a variable. These commands should be added into Jupyter Notebook cells:</p>
<pre>import geopandas as gpd<br/>import pandas as pd<br/>import os<br/>from mapboxgl.utils import *<br/>from mapboxgl.viz import *<br/>token = '{user API Key}'</pre>
<p>The API key can also be assigned to a Windows path environment variable (for example, <kbd>"MAPBOX_ACCESS_TOKEN"</kbd>) and called using the <kbd>os</kbd> module:</p>
<pre>token = os.getenv("MAPBOX_ACCESS_TOKEN")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating point data from polygons</h1>
                </header>
            
            <article>
                
<p>The Bay Area census tracts GeoJSON file has population data with polygon <kbd>geometry</kbd>. To create the first visualization we need to convert the geometry type to point:</p>
<pre>tracts = gpd.read_file(r'tracts_bayarea.geojson')<br/>tracts['centroids'] = <strong>tracts.centroid</strong><br/>tract_points = tracts<br/>tract_points = tract_points.set_geometry('centroids')<br/>tract_points.plot()</pre>
<p>The output of the previous code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b962da69-204f-43c7-8b1b-7fa6822742c8.png" style="width:46.67em;height:28.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data cleanup </h1>
                </header>
            
            <article>
                
<p>This data visualization will compare the male and female population in the Bay Area. To generate the circle visualization, we can rename and eliminate unnecessary columns using Geopandas' dataframe manipulation:</p>
<pre>tract_points['Total Population'] = tract_points['ACS_15_5YR_S0101_with_ann_Total; Estimate; Total population']<br/>tract_points['Male Population'] = tract_points['ACS_15_5YR_S0101_with_ann_Male; Estimate; Total population']<br/>tract_points['Female Population'] = tract_points['ACS_15_5YR_S0101_with_ann_Female; Estimate; Total population']<br/>tract_points = tract_points[['Total Population',<br/>                'Male Population','Female Population',<br/>                'centroids' ]]</pre>
<p>This code created three new columns from three existing columns, by passing the name of the new columns and assigning the data values to be equal to the existing column. Then, the entire GeoDataFrame is rewritten (in memory) to only contain the three new columns and the centroids column, eliminating unwanted columns. Exploring the first five rows of the new GeoDataFrame allows us to see the new data structure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/acb4b206-d9c9-4841-817d-ca598cf087f5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving the points as GeoJSON</h1>
                </header>
            
            <article>
                
<p>Saving the newly cleaned GeoDataFrame is required for loading into the Mapbox <kbd>CircleViz</kbd> class. The GeoJSON driver must be specified, as the default output file format is shapefile:</p>
<pre>tract_points.to_file('tract_points.geojson',driver="GeoJSON")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the points to a map</h1>
                </header>
            
            <article>
                
<p>To simply see the points on the map, we can supply a few parameters and call the <kbd>show</kbd> property of the <kbd>CircleViz</kbd> object:</p>
<pre>viz = CircleViz('tract_points.geojson', access_token=token, <br/>                radius = 2, center = (-122, 37.75), zoom = 8)<br/>viz.show()</pre>
<p>The previous code will produce the output as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c1ed2c88-cd1c-46d8-a99e-7ccf7bfdc893.png"/></div>
<p>To classify the data, we can set color stops for specific fields, passing class breaks as a list with associated color information:</p>
<pre>color_stops = [<br/>    [0.0, 'rgb(255,255,204)'],    [500.0, 'rgb(255,237,160)'],<br/>    [1000.0, 'rgb(252,78,42)'],    [2500.0, 'rgb(227,26,28)'],<br/>    [5000.0, 'rgb(189,0,38)'],<br/>    [max(tract_points['Total Population']),'rgb(128,0,38)']<br/>]<br/>viz.color_property = 'Total Population'<br/>viz.color_function_type = 'interpolate'<br/>viz.color_stops = color_stops<br/>viz.radius = 1<br/>viz.center = (-122, 37.75)<br/>viz.zoom = 8<br/><br/>viz.show() </pre>
<p>The output will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed8a327a-6925-47b3-b346-59c846a3442f.png"/></div>
<p>Add some new fields to the <kbd>tract_points</kbd> GeoDataFrame and resave it:</p>
<pre>tract_points['Percent Male'] = tract_points['Male Population']/tract_points['Total Population']<br/>tract_points['Percent Female'] = tract_points['Female Population']/tract_points['Total Population']<br/>tract_points.to_file("tract_points2.geojson", driver="GeoJSON")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a graduated color visualization</h1>
                </header>
            
            <article>
                
<p>This code will manually assign colors to specific sections of the data, breaking the data into categories. This also assigns specific radius sizes to data so that the visualization will convey information with both color and circle size:</p>
<pre>color_stops = [<br/>    [0.0, 'rgb(107,174,214)'],    [3000.0, 'rgb(116,196,118)'],<br/>    [8000.0, 'rgb(254,153,41)'],<br/>    [max(tract_points['Total Population']), 'rgb(222,45,38)'], <br/>]<br/><br/>minmax = [min(tract_points['Percent Male']),<br/>          max(tract_points['Percent Male'])]<br/>diff = minmax[1] - minmax[0]<br/>radius_stops = [<br/>    [round(minmax[0],2), 4.0],<br/>    [round(minmax[0]+(diff/6.0),2), 7.0],<br/>    [round(minmax[1]-(diff/2.0),2), 10.0],<br/>    [minmax[1], 15.0],]</pre>
<p>With these radius sizes and color ranges set, they can be applied to two fields within the new GeoJSON: <kbd>Total Population</kbd> and <kbd>Percent Male</kbd>. For this visualization, the size of the circle will indicate the male percentage of the population, and the color will indicate the total population:</p>
<pre>vizGrad = GraduatedCircleViz('tract_points2.geojson', access_token=token)<br/><br/>vizGrad.color_function_type = 'interpolate'<br/>vizGrad.color_stops = color_stops<br/>vizGrad.color_property = 'Total Population'<br/>vizGrad.color_default = 'grey'<br/>vizGrad.opacity = 0.75<br/><br/>vizGrad.radius_property = 'Percent Male'<br/>vizGrad.radius_stops = radius_stops<br/>vizGrad.radius_function_type = 'interpolate'<br/>vizGrad.radius_default = 1<br/><br/>vizGrad.center = (-122, 37.75)<br/>vizGrad.zoom = 9<br/>vizGrad.show()</pre>
<p>This will produce an interactive map like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/546f3b6a-2201-409c-8b2b-85b79b3442e2.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Automatically setting colors, sizes, and breaks</h1>
                </header>
            
            <article>
                
<p>Instead of manually setting the colors, radius sizes, and breaks, MapboxGL—Jupyter includes utilites (such as <kbd>create_color_stops</kbd>) that create a match between colors (or sizes) and break values. The color schema is set by passing the <kbd>YlOrRd</kbd> keyword ( which means <strong>Yellow Orange Red</strong>). Also, we can adjust the basemap using another pre-set style or our own custom styles by setting the visualization style to the style URL:</p>
<pre>measure_color = 'Percent Male'<br/>color_breaks = [round(tract_points[measure_color].quantile(q=x*0.1),3) for x in range(1, 11,3)]<br/>color_stops = <strong>create_color_stops</strong>(color_breaks, colors='<strong>YlOrRd</strong>')<br/>measure_radius = 'Total Population'<br/>radius_breaks = [round(tract_points[measure_radius].quantile(q=x*0.1),1) for x in range(2, 12,2)]<br/>radius_stops = <strong>create_radius_stops</strong>(radius_breaks, 5.0, 20)<br/>vizGrad = GraduatedCircleViz('tract_points2.geojson', <br/>                          access_token=token,<br/>                          color_property = measure_color,<br/>                          color_stops = color_stops,<br/>                          radius_property = measure_radius,<br/>                          radius_stops = radius_stops,<br/>                          stroke_color = 'black',<br/>                          stroke_width = 0.5,<br/>                          center = (-122, 37.75),<br/>                          zoom = 9,<br/>                          opacity=0.75)<br/>vizGrad.style=<strong>'mapbox://styles/mapbox/dark-v9'</strong><br/>vizGrad.show()</pre>
<p>The dark basemap allows for the graduated circle visualizations to be more clearly seen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/18546256-83fb-42d9-8220-298df0f4268f.png"/></div>
<div class="packt_infobox">Explore the visualization options available in the documentation here:<br/>
<a href="https://github.com/mapbox/mapboxgl-jupyter/blob/master/docs-markdown/viz.md">https://github.com/mapbox/mapboxgl-jupyter/blob/master/docs-markdown/viz.md.<br/></a><br/>
Explore the data utilities available here:<br/>
<a href="https://github.com/mapbox/mapboxgl-jupyter/blob/master/docs-markdown/utils.md">https://github.com/mapbox/mapboxgl-jupyter/blob/master/docs-markdown/utils.md</a>.<br/>
<br/>
Explore the color ramps available here:<br/>
<a href="https://github.com/mapbox/mapboxgl-jupyter/blob/master/mapboxgl/colors.py">https://github.com/mapbox/mapboxgl-jupyter/blob/master/mapboxgl/colors.py</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a choropleth map</h1>
                </header>
            
            <article>
                
<p>With a choropleth map, we can display a polygon GeoJSON file. Using the <kbd>tracts</kbd> GeoDataFrame, we'll create another GeoDataFrame with polygon <kbd>geometry</kbd> and one tabular field, and save it to a file as <kbd>GeoJSON</kbd>:</p>
<pre>tract_poly = tracts<br/>tract_poly['Male Population'] = tract_poly['ACS_15_5YR_S0101_with_ann_Male; Estimate; Total population']<br/>tract_poly = tract_poly[['Male Population','geometry' ]]<br/>tract_poly.to_file('tracts_bayarea2.geojson', driver="GeoJSON")</pre>
<p>The visualization is created using the <kbd>ChoroplethViz</kbd> class. The basemap style is the URL of the satellite imagery style created earlier in the <em>MapBox Studio</em>, section of the chapter:</p>
<pre>vizClor = ChoroplethViz('tracts_bayarea2.geojson', <br/>    access_token=API_TOKEN,<br/>    color_property='Male Population',<br/>    color_stops=create_color_stops([0, 2000, 3000,5000,7000, 15000], <br/>    colors='YlOrRd'),<br/>    color_function_type='interpolate',<br/>    line_stroke='-',<br/>    line_color='rgb(128,0,38)',<br/>    line_width=1,<br/>    opacity=0.6,<br/>    center=(-122, 37.75),<br/>    zoom=9)<br/>vizClor.style='mapbox://styles/lokipresident/cjftywpln22sp9fcpqa8rl'<br/>vizClor.show()</pre>
<p>The output generated is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b769edfc-3131-4be3-a7d9-1b79b9541fda.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Saving the map</h1>
                </header>
            
            <article>
                
<p>To save the choropleth map, use the <kbd>create_html</kbd> method of the visualization:</p>
<pre>with open('mpop.html', 'w') as f:<br/>    f.write(vizClor.create_html())</pre>
<p>To view the saved HTML file locally, open command prompt and start a local HTTP server using Python in the same folder as the saved HTML file. Then, open a browser at <kbd>http://localhost:8000/mpop.html</kbd> to see the map:</p>
<pre><strong>C:\Python3Geospatial&gt;python -m http.server</strong><br/><strong>Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a heat map</h1>
                </header>
            
            <article>
                
<p>Use the <kbd>HeatmapViz</kbd> class to generate a heat map from the data:</p>
<pre>measure = 'Female Population'<br/>heatmap_color_stops = create_color_stops([0.01, 0.25, 0.5, 0.75, 1], colors='PuRd')<br/>heatmap_radius_stops = [[0, 3], [14, 100]] <br/>color_breaks = [round(tract_poly[measure].quantile(q=x*0.1), 2) for x in range(2,10)]<br/>color_stops = create_color_stops(color_breaks, colors='Spectral')<br/>heatmap_weight_stops = create_weight_stops(color_breaks) <br/>vizheat = HeatmapViz('tracts_points2.geojson', <br/>                  access_token=token,<br/>                  weight_property = "Female Population",<br/>                  weight_stops = heatmap_weight_stops,<br/>                  color_stops = heatmap_color_stops,<br/>                  radius_stops = heatmap_radius_stops,<br/>                  opacity = 0.8,<br/>                  center=(-122, 37.78),<br/>                  zoom=7,<br/>                  below_layer='waterway-label'<br/>                 )<br/>vizheat.show()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading data using the Mapbox Python SDK</h1>
                </header>
            
            <article>
                
<p>Storing datasets in the account and joining them to other tabular data is possible using MapboxGL—Jupyter and the Mapbox Python SDK. Loading a GeoJSON file requires specific permissions assigned only to secret API access tokens. To ensure that the API token used has the correct scope, you may have to generate a new API token. Go to your <span class="packt_screen">Account Dashboard</span> and generate a new token, and ensure that you check the read and write capabilities for uploads and datasets as shown in the <em>Getting started with Mapbox</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the dataset</h1>
                </header>
            
            <article>
                
<p>The first step is to create a dataset, if you haven't created it already. This code generates an empty dataset in the account, which will have a name and description as provided to the <kbd>datasets.create</kbd> method:</p>
<pre>from mapbox import Datasets<br/>import json<br/>datasets = Datasets(access_token={secrettoken})<br/>create_resp = datasets.create(name="Bay Area Zips", <br/>              description = "ZTCA zones for the Bay Area")</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading the data into the dataset</h1>
                </header>
            
            <article>
                
<p>To load the data into the new dataset, we will iterate through the features contained in the zip codes GeoJSON, writing them all to the dataset (instead of just one as demonstrated earlier). As this file is larger than 5MB, it must be loaded using the API, which is accessed using the <kbd>mapbox</kbd> module. The ID of the dataset (retrieved using the <kbd>datasets.list</kbd> method), the row ID, and the <kbd>feature</kbd>, are all required parameters for the <kbd>update_feature</kbd> method:</p>
<pre>listing_resp = datasets.list()<br/>dataset_id = [ds['id'] for ds in listing_resp.json()][0]<br/>data = json.load(open(r'ztca_bayarea.geojson'))<br/>for count,feature in enumerate(data['features']):<br/>    resp = datasets.update_feature(dataset_id, count, feature)</pre>
<p>The completed dataset now looks like this in Mapbox Studio:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4b9c0414-eea1-400e-a41d-a19037ae1776.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading data from a dataset</h1>
                </header>
            
            <article>
                
<p>To read the JSON data stored in the dataset, use the <kbd>read_dataset</kbd> method:</p>
<pre> datasets.read_dataset(dataset_id).json()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a row</h1>
                </header>
            
            <article>
                
<p>To delete a specific row from the dataset, pass the dataset ID and the row ID to the <kbd>datasets.delete_feature</kbd> method:</p>
<pre>resp = datasets.delete_feature(dataset_id, 0)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to use the MapboxGL—Jupyter and Mapbox Python SDK to create data visualizations and to upload data into the Mapbox account. We created point data visualizations, choropleth maps, heat maps, and graduated circle visualizations. We learned how to style a custom basemap, how to add it to an HTML map, and how to add custom tilesets to the basemap. We learned how to use GeoPandas to convert Polygon data into point data, and how to visualize the result. </p>
<p><span><span>In the next chapter, we will explore the use of Python modules and Hadoop to perform geospatial analysis.</span></span></p>


            </article>

            
        </section>
    </body></html>