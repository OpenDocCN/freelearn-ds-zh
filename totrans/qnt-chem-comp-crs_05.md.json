["```py\npip install numpy\n```", "```py\npip install qiskit\n```", "```py\npip install 'qiskit[visualization]'\n```", "```py\npip install qiskit-nature\n```", "```py\npip install pyscf\n```", "```py\npip install qutip\n```", "```py\npip install ase\n```", "```py\npip install pyqmc --upgrade\n```", "```py\npip install h5py\n```", "```py\npip install scipy\n```", "```py\nimport numpy as np\n```", "```py\nimport matplotlib.pyplot as plt\n```", "```py\nfrom qiskit.visualization import array_to_latex, plot_bloch_vector, plot_bloch_multivector, plot_state_qsphere, plot_state_city\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile\nfrom qiskit import execute, Aer\nimport qiskit.quantum_info as qi\nfrom qiskit.extensions import Initialize\nfrom qiskit.providers.aer import extensions  # import aer snapshot instructions\n```", "```py\nfrom qiskit import Aer\nfrom qiskit_nature.drivers import UnitsType, Molecule\nfrom qiskit_nature.drivers.second_quantization import ElectronicStructureDriverType, ElectronicStructureMoleculeDriver\nfrom qiskit_nature.problems.second_quantization import ElectronicStructureProblem\nfrom qiskit_nature.mappers.second_quantization import ParityMapper, JordanWignerMapper, BravyiKitaevMapper\nfrom qiskit_nature.converters.second_quantization import QubitConverter\nfrom qiskit_nature.transformers.second_quantization.electronic import ActiveSpaceTransformer, FreezeCoreTransformer\nfrom qiskit_nature.operators.second_quantization import FermionicOp\nfrom qiskit_nature.circuit.library.initial_states import HartreeFock\nfrom qiskit_nature.circuit.library.ansatzes import UCCSD\n```", "```py\nfrom qiskit_nature.properties import Property, GroupedProperty\n```", "```py\n# https://qiskit.org/documentation/nature/tutorials/08_property_framework.html\nfrom qiskit_nature.properties.second_quantization.electronic import (\n    ElectronicEnergy,\n    ElectronicDipoleMoment,\n    ParticleNumber,\n    AngularMomentum,\n    Magnetization,\n)\n```", "```py\nfrom qiskit_nature.properties.second_quantization.electronic.integrals import (\n    ElectronicIntegrals,\n    OneBodyElectronicIntegrals,\n    TwoBodyElectronicIntegrals,\n    IntegralProperty,\n)\nfrom qiskit_nature.properties.second_quantization.electronic.bases import ElectronicBasis\n```", "```py\nfrom qiskit.providers.aer import StatevectorSimulator\nfrom qiskit import Aer\nfrom qiskit.utils import QuantumInstance\nfrom qiskit_nature.algorithms import VQEUCCFactory, GroundStateEigensolver, NumPyMinimumEigensolverFactory, BOPESSampler\nfrom qiskit.algorithms import NumPyMinimumEigensolver, VQE, HamiltonianPhaseEstimation\nfrom qiskit.circuit.library import TwoLocal\nfrom qiskit.algorithms.optimizers import QNSPSA\nfrom qiskit.opflow import StateFn, PauliExpectation,  CircuitSampler, PauliTrotterEvolution\nfrom functools import partial as apply_variation\n```", "```py\nfrom pyscf import gto, scf\n```", "```py\nimport pyqmc.api as pyq\n```", "```py\nimport h5py\n```", "```py\nfrom ase import Atoms\nfrom ase.build import molecule\nfrom ase.visualize import view\n```", "```py\nimport cmath\nimport math\n```", "```py\nimport scipy.stats as stats\n```", "```py\nimport qutip\n```", "```py\nimport time, datetime\n```", "```py\nimport pandas as pd\nimport os.path\n```", "```py\nn = 10000 # Size of the Markov chain stationary distribution\n# Use np.linspace to create an array of n numbers between 0 and n\nindex = np.linspace(0, n, num=n)\nx = np.linspace(0, n, num=n)\nx[0] = 3     # Initialize to 3\nfor i in range(1, n):\n  current_x = x[i-1]\n  # We add a N(0,1) random number to x\n  proposed_x = current_x + stats.norm.rvs(loc=0, scale=1, size=1, random_state=None)\n  A = min(1, p(proposed_x)/p(current_x))\n  r = np.random.uniform(0,1) # Generate a uniform random number in [0, 1]\n  if r < A:\n    x[i] = proposed_x       # Accept move with probabilty min(1,A)\n  else:\n    x[i] = current_x        # Otherwise “reject” move, and stay where we are\n```", "```py\nplt.plot(index, x, label=”Trace plot”)\nplt.xlabel('Index')\nplt.ylabel('MH value')\nplt.legend()\nplt.show()\n```", "```py\nq25, q75 = np.percentile(x, [25, 75])\nbin_width = 2 * (q75 - q25) * len(x) ** (-1/3)\nbins = round((x.max() - x.min()) / bin_width)\nprint(“Freedman–Diaconis number of bins:”, bins)\n```", "```py\nFreedman–Diaconis number of bins: 109\n```", "```py\nplt.hist(x, density=True, bins=bins)\nplt.ylabel('Density')\nplt.xlabel('x');\n```", "```py\ndef run_PySCF(molecule, pyqmc=True, show=True):\n```", "```py\n  # Reset the files\n  for fname in ['mf.hdf5','optimized_wf.hdf5']:\n    if os.path.isfile(fname):\n        os.remove(fname)\n```", "```py\n  mol_PySCF = gto.M(atom = [“ “.join(map(str, (name, *coord))) for (name, coord) in molecule.geometry])\n```", "```py\n  mf = scf.RHF(mol_PySCF)\n  mf.chkfile = “mf.hdf5”\n\n  conv, e, mo_e, mo, mo_occ = scf.hf.kernel(mf)\n  if show:\n    if conv:\n      print(“PySCF restricted HF (RHF) converged ground-state energy: {:.12f}”.format(e))\n    else:\n      print(“PySCF restricted HF (RHF) ground-state computation failed to converge”)\n```", "```py\n  if pyqmc:\n    pyq.OPTIMIZE(“mf.hdf5”,# Construct a Slater-Jastrow wave function from the pyscf output\n      “optimized_wf.hdf5”, # Store optimized parameters in this file.\n      nconfig=100,         # Optimize using this many Monte Carlo samples/configurations\n      max_iterations=4,    # 4 optimization steps\n      verbose=False)\n```", "```py\n    with h5py.File(“optimized_wf.hdf5”) as f:\n      iter = f['iteration']\n      energy = f['energy']\n      error = f['energy_error']\n      l = energy.shape[0]\n      e = energy[l-1]\n      err = error[l-1]\n      if show:\n        if err < 0.1:\n          print(“Iteration, Energy, Error”)\n          for k in iter:\n            print(“{}:         {:.4f} {:.4f}”.format(k, energy[k], error[k]))\n          print(“PyQMC Monte Carlo converged ground-state energy: {:.12f}, error: {:.4f}”.format(e, err))\n        else:\n          print(“PyQMC Monte Carlo failed to converge”)\n```", "```py\nreturn conv, e\n```", "```py\ndef U(theta):\n  unitary = QuantumCircuit(1)\n  unitary.p(np.pi*2*theta, 0)\n  return unitary\n```", "```py\ndef do_qpe(unitary, nqubits=3, show=True):\n  state_in = QuantumCircuit(1)\n  state_in.x(0)\n  pe = PhaseEstimation(num_evaluation_qubits=nqubits, quantum_instance=quantum_instance)\n  result = pe.estimate(unitary, state_in)\n  phase_out = result.phase\n  if show:\n    print(“Number of qubits: {}, QPE phase estimate: {}”.format(nqubits, phase_out))\n  return(phase_out)\n```", "```py\nquantum_instance = QuantumInstance(backend = Aer.get_backend('aer_simulator_statevector'))\ntheta = 1/2 + 1/4 + 1/8\nprint(“theta: {}”.format(theta))\nunitary = U(theta)\nresult = do_qpe(unitary, nqubits=3)\n```", "```py\ntheta: 0.875\nNumber of qubits: 3, QPE phase estimate: 0.875 \n```", "```py\ntheta = 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/128 + 1/256\nprint(“theta: {}”.format(theta))\nunitary = U(theta)\nresult = do_qpe(unitary, nqubits=8)\n```", "```py\ntheta: 0.99609375\nNumber of qubits: 8, QPE phase estimate: 0.99609375 \n```", "```py\nquantum_instance = QuantumInstance(backend = Aer.get_backend('aer_simulator_statevector'))\n```", "```py\nnumpy_solver = NumPyMinimumEigensolver()\n```", "```py\ntl_circuit = TwoLocal(rotation_blocks = ['h', 'rx'], entanglement_blocks = 'cz',\n                      entanglement='full', reps=2, parameter_prefix = 'y')\n```", "```py\nvqe_tl_solver = VQE(ansatz = tl_circuit,\n                     quantum_instance = QuantumInstance(Aer.get_backend('aer_simulator_statevector')))\n```", "```py\nvqe_ucc_solver = VQEUCCFactory(quantum_instance, ansatz=tl_ circuit)\n```", "```py\nqnspsa_loss = []\ndef qnspsa_callback(nfev, x, fx, stepsize, accepted):\n    qnspsa_loss.append(fx)\n```", "```py\ndef run_vqe(name, f_op, qubit_converter, solver, show=True):\n  calc = GroundStateEigensolver(qubit_converter, solver)\n  start = time.time()\n  ground_state = calc.solve(f_op)\n  elapsed = str(datetime.timedelta(seconds = time.time()-start))\n  if show:\n    print(“Running the VQE using the {}”.format(name))\n    print(“Elapsed time: {} \\n”.format(elapsed))\n    print(ground_state)\n  return ground_state\n```", "```py\ndef run_qpe(particle_number, qubit_converter, qubit_op, n_ancillae=3, num_time_slices = 1, show=True):\n  initial_state = HartreeFock(particle_number.num_spin_orbitals, \n                            (particle_number.num_alpha, \n                             particle_number.num_beta), qubit_converter)\n\n  state_preparation = StateFn(initial_state)\n  evolution = PauliTrotterEvolution('trotter', reps=num_time_slices)\n  qpe = HamiltonianPhaseEstimation(n_ancillae, quantum_instance=quantum_instance)\n  result = qpe.estimate(qubit_op, state_preparation, evolution=evolution)\n  if show:\n    print(“\\nQPE initial Hartree Fock state”)\n    display(initial_state.draw(output='mpl'))\n    eigv = result.most_likely_eigenvalue\n    print(“QPE computed electronic ground state energy (Hartree): {}”.format(eigv))\n\n  return eigv\n```", "```py\ndef plot_energy_landscape(energy_surface_result):\n  if len(energy_surface_result.points) > 1:\n      plt.plot(energy_surface_result.points, energy_surface_result.energies, label=”VQE Energy”)\n      plt.xlabel('Atomic distance Deviation(Angstrom)')\n      plt.ylabel('Energy (hartree)')\n      plt.legend()\n      plt.show()\n  else:\n      print(“Total Energy is: “, energy_surface_result.energies[0], “hartree”)\n      print(“(No need to plot, only one configuration calculated.)”)\n  return\n```", "```py\ndef plot_loss(loss, label, target):\n  plt.figure(figsize=(12, 6))\n  plt.plot(loss, 'tab:green', ls='--', label=label)\n  plt.axhline(target, c='tab:red', ls='--', label='target')\n  plt.ylabel('loss')\n  plt.xlabel('iterations')\n  plt.legend()\n```", "```py\ndef solve_ground_state(\n    molecule,\n    mapper =”Parity”,\n    num_electrons=None,\n    num_molecular_orbitals=None,\n    transformers=None,\n    two_qubit_reduction=False,\n    z2symmetry_reduction = “Auto”,\n    name_solver='NumPy exact solver',\n    solver=NumPyMinimumEigensolver(),\n    plot_bopes=False,\n    perturbation_steps=np.linspace(-1, 1, 3),\n    pyqmc=True,\n    n_ancillae=3, \n    num_time_slices=1,\n    loss=[],\n    label=None,\n    target=None,\n    show=True\n):\n```", "```py\n    # Defining the electronic structure molecule driver\n    driver = ElectronicStructureMoleculeDriver(molecule, basis='sto3g', driver_type=ElectronicStructureDriverType.PYSCF)\n```", "```py\n# Splitting into classical and quantum\n    if num_electrons != None and num_molecular_orbitals != None:\n      split = ActiveSpaceTransformer(num_electrons=num_electrons, num_molecular_orbitals=num_molecular_orbitals)\n    else:\n      split = None\n```", "```py\n# Defining a fermionic Hamiltonian operator\n    if split != None:\n      fermionic_hamiltonian = ElectronicStructureProblem(driver, [split])\n    elif transformers != None:\n      fermionic_hamiltonian = ElectronicStructureProblem(driver, transformers=transformers)\n    else:\n      fermionic_hamiltonian = ElectronicStructureProblem(driver)\n```", "```py\nsecond_q_op = fermionic_hamiltonian.second_q_ops()\n```", "```py\n    # Get particle number\n    particle_number = get_particle_number(fermionic_hamiltonian, show=show)\n```", "```py\nif show:\n      # We set truncation to 1000 with the method set_truncation(1000)\n      second_q_op[0].set_truncation(1000)\n      # then we print the first 20 terms of the fermionic Hamiltonian operator of the molecule\n      print(“Fermionic Hamiltonian operator”)\n      print(second_q_op[0])\n```", "```py\n# Use the function fermion_to_qubit() to convert a fermionic operator to a qubit operator\n    if show:\n      print(“ “)\n    qubit_op, qubit_converter = fermion_to_qubit(fermionic_hamiltonian, second_q_op, mapper=mapper, two_qubit_reduction=two_qubit_reduction, z2symmetry_reduction=z2symmetry_reduction, show=show)\n```", "```py\n    # Run the the PySCF RHF method\n    if show:\n      print(“ “)\n    conv, e = run_PySCF(molecule, pyqmc=pyqmc, show=show)\n```", "```py\n # Run QPE\n    eigv = run_qpe(particle_number, qubit_converter, qubit_op, n_ancillae=n_ancillae, num_time_slices=num_time_slices, show=True)\n```", "```py\n    # Run VQE\n    if show:\n      print(“ “)\n    ground_state = run_vqe(name_solver, fermionic_hamiltonian, qubit_converter, solver, show=show)\n```", "```py\n    # Plot loss function\n    if loss != []:\n      plot_loss(loss, label, target)\n```", "```py\nif plot_bopes:\n      # Compute the potential energy surface as follows:\n      energy_surface = BOPESSampler(gss=GroundStateEigensolver(qubit_converter, solver), bootstrap=False)\n      # Set default to an empty dictionary instead of None:\n      energy_surface._points_optparams = {}\n      energy_surface_result = energy_surface.sample(fermionic_hamiltonian, perturbation_steps)\n      # Plot the energy as a function of atomic separation\n      plot_energy_landscape(energy_surface_result)\n```", "```py\nreturn fermionic_hamiltonian, particle_number, qubit_op, qubit_converter, ground_state\n```", "```py\nhydrogen_molecule = Molecule(geometry=[['H', [0., 0., 0.]],\n                              ['H', [0., 0., 0.735]]],\n                     charge=0, multiplicity=1)\n```", "```py\nmolecular_variation = Molecule.absolute_stretching\n```", "```py\nspecific_molecular_variation = apply_variation(molecular_variation, atom_pair=(1, 0))\n```", "```py\nhydrogen_molecule_stretchable = Molecule(geometry=\n                                 [['H', [0., 0., 0.]],\n                                  ['H', [0., 0., 0.735]]],\n                                  charge=0, multiplicity=1,\n                                  degrees_of_freedom=[specific_molecular_variation])\n```", "```py\nH2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \\\n                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,\n                   two_qubit_reduction=True, z2symmetry_reduction=None, \n                   name_solver = 'NumPy exact solver', solver = numpy_solver)\n```", "```py\nH2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \\\n                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,\n                   two_qubit_reduction=True, z2symmetry_reduction=None, \n                   name_solver = 'Unitary Coupled Cluster (UCC) factory ansatz', solver = vqe_ucc_solver)\n```", "```py\nH2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \\\n                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,\n                   two_qubit_reduction=True, z2symmetry_reduction=None, \n                   name_solver = 'Heuristic ansatz, the Two-Local circuit with SLSQP',solver = vqe_tl_solver)\n```", "```py\nqnspsa_loss = []\nansatz = tl_circuit\nfidelity = QNSPSA.get_fidelity(ansatz, quantum_instance, expectation=PauliExpectation())\nqnspsa = QNSPSA(fidelity, maxiter=200, learning_rate=0.01, perturbation=0.7, callback=qnspsa_callback)\n```", "```py\nvqe_tl_QNSPSA_solver = VQE(ansatz=tl_circuit, optimizer=qnspsa,\n                     quantum_instance=quantum_instance)\n```", "```py\nH2_fermionic_hamiltonian, H2_particle_number, H2_qubit_op, H2_qubit_converter, H2_ground_state = \\\n                  solve_ground_state(hydrogen_molecule, mapper =”Parity”,\n                  two_qubit_reduction=True, z2symmetry_reduction=None, loss=qnspsa_loss, label='QN-SPSA', target=-1.857274810366,\n                  name_solver='Two-Local circuit and the QN-SPSA optimizer', solver=vqe_tl_QNSPSA_solver)\n```", "```py\nperturbation_steps = np.linspace(-0.5, 2, 25) # 25 equally spaced points from -0.5 to 2, inclusive.\nH2_stretchable_fermionic_hamiltonian, H2_stretchable_particle_number, H2_stretchable_qubit_op, H2_stretchable_qubit_converter, H2_stretchable_ground_state = \\\n                  solve_ground_state(hydrogen_molecule_stretchable, mapper =”Parity”,\n                   two_qubit_reduction=True, z2symmetry_reduction=None, \n                   name_solver = 'NumPy exact solver', solver = numpy_solver,\n                   plot_bopes = True, perturbation_steps=perturbation_steps)\n```", "```py\nLiH_molecule = Molecule(geometry=[['Li', [0., 0., 0.]],\n                              ['H', [0., 0., 1.5474]]],\n                     charge=0, multiplicity=1)\n```", "```py\nLiH_molecule_stretchable = Molecule(geometry=[['Li', [0., 0., 0.]],\n                              ['H', [0., 0., 1.5474]]],\n                    charge=0, multiplicity=1,\n                    degrees_of_freedom=[specific_molecular_variation])\nreduction=True, z2symmetry_reduction=”auto”)\n```", "```py\nLiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \\\n                  solve_ground_state(LiH_molecule, mapper =”Parity”,\n                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],\n                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, \n                  name_solver = 'NumPy exact solver', solver = numpy_solver)\n```", "```py\nLiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \\\n                  solve_ground_state(LiH_molecule, mapper =”Parity”,\n                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],\n                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, \n                  name_solver = 'Heuristic ansatz, the Two-Local circuit with SLSQP', solver = vqe_tl_solver)\n```", "```py\nqnspsa_loss = []\nansatz = tl_circuit\nfidelity = QNSPSA.get_fidelity(ansatz, quantum_instance, expectation=PauliExpectation())\nqnspsa = QNSPSA(fidelity, maxiter=500, learning_rate=0.01, perturbation=0.7, callback=qnspsa_callback)\n```", "```py\nvqe_tl_QNSPSA_solver = VQE(ansatz=tl_circuit, optimizer=qnspsa,\n                     quantum_instance=quantum_instance)\n```", "```py\nLiH_fermionic_hamiltonian, LiH_particle_number, LiH_qubit_op, LiH_qubit_converter, LiH_ground_state = \\\n                  solve_ground_state(LiH_molecule, mapper=”Parity”,\n                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],\n                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, loss=qnspsa_loss, label='QN-SPSA', target=-1.0703584,\n                  name_solver='Two-Local circuit and the QN-SPSA optimizer', solver=vqe_tl_QNSPSA_solver)\n```", "```py\nperturbation_steps = np.linspace(-0.8, 0.8, 10) # 10 equally spaced points from -0.8 to 0.8, inclusive.\nLiH_stretchable_fermionic_hamiltonian, LiH_stretchable_particle_number, LiH_stretchable_qubit_op, LiH_stretchable_qubit_converter, LiH_stretchable_ground_state = \\\n                  solve_ground_state(LiH_molecule_stretchable, mapper =”Parity”,\n                  transformers=[FreezeCoreTransformer(freeze_core=True, remove_orbitals=[4, 3])],\n                   two_qubit_reduction=True, z2symmetry_reduction=”auto”, \n                   name_solver='NumPy exact solver', solver=numpy_solver,\n                   plot_bopes = True, perturbation_steps=perturbation_steps)\n```", "```py\nmacro_ASE = Atoms('ONCHHHC', [(1.1280, 0.2091, 0.0000), \n                          (-1.1878, 0.1791, 0.0000), \n                          (0.0598, -0.3882, 0.0000),\n                          (-1.3085, 1.1864, 0.0001),\n                          (-2.0305, -0.3861, -0.0001),\n                          (-0.0014, -1.4883, -0.0001),\n                          (-0.1805, 1.3955, 0.0000)])\n```", "```py\nview(macro_ASE, viewer='x3d')\n```", "```py\nmolecular_variation = Molecule.absolute_stretching\n```", "```py\nspecific_molecular_variation = apply_variation(molecular_variation, atom_pair=(6, 1))\n```", "```py\nmacromolecule = Molecule(geometry=\n   [['O', [1.1280, 0.2091, 0.0000]],\n   ['N', [-1.1878, 0.1791, 0.0000]],\n   ['C', [0.0598, -0.3882, 0.0000]],\n   ['H', [-1.3085, 1.1864, 0.0001]],\n   ['H', [-2.0305, -0.3861, -0.0001]],\n   ['H', [-0.0014, -1.4883, -0.0001]],\n   ['C', [-0.1805, 1.3955, 0.0000]]],\n   charge=0, multiplicity=1,\n   degrees_of_freedom=[specific_molecular_variation])\n```", "```py\nprint(“Macro molecule”)\nprint(“Using the ParityMapper with two_qubit_reduction=True to eliminate two qubits”)\nprint(“Parameters ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)”)\nprint(“Setting z2symmetry_reduction=\\”auto\\””)\n```", "```py\nMacro molecule\nUsing the ParityMapper with two_qubit_reduction=True to eliminate two qubits\nParameters ActiveSpaceTransformer(num_electrons=2, num_molecular_orbitals=2)\nSetting z2symmetry_reduction=”auto”\n```", "```py\nmacro_fermionic_hamiltonian, macro_particle_number, macro_qubit_op, macro_qubit_converter, macro_ground_state = \\\n                  solve_ground_state(macromolecule, mapper=”Parity”,\n                  num_electrons=2, num_molecular_orbitals=2,\n                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, \n                  name_solver='NumPy exact solver', solver=numpy_solver, pyqmc=False)\n```", "```py\nperturbation_steps = np.linspace(-0.5, 3, 10) # 10 equally spaced points from -0.5 to 3, inclusive.\nmacro_fermionic_hamiltonian, macro_particle_number, macro_qubit_op, macro_qubit_converter, macro_ground_state = \\\n                  solve_ground_state(macromolecule, mapper =”Parity”,\n                  num_electrons=2, num_molecular_orbitals=2,\n                  two_qubit_reduction=True, z2symmetry_reduction=”auto”, \n                  name_solver='NumPy exact solver', solver=numpy_solver, pyqmc=False,\n                  plot_bopes=True, perturbation_steps=perturbation_steps)\n```"]