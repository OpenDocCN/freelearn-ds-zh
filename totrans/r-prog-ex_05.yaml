- en: Communicating Sales with Visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore a very important and useful aspect of data
    analysis, data visualization. We will show how to create graph functions, which
    are the functions that encapsulate the process of creating a graph and output
    a graph object that can be seen or saved to disk. Working with graphs this way
    increases efficiency, adds flexibility, and provides repeatable processes.
  prefs: []
  type: TYPE_NORMAL
- en: The types of graphs we will create during this chapter include bar graphs, boxplots,
    scatter plots with marginal distributions, radar graphs, 3D interactive scatter
    plots, time-series graphs, static and interactive maps, and a cool globe visualization.
    The chapter will show the fundamentals you need to create a great variety of high-quality
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Working efficiently with graph functions and graph objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with important graphing packages such as `ggplot2` and `leaflet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transformations to accommodate different visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph generalization through variable parameterization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing dimensions shown with colors and shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending `ggplot2` with custom graph types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical data exploration with interactive graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Geographical data exploration with interactive maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During this chapter we will make use of the following R packages. If you don''t
    already have them installed, you can look into [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)*,
    Required Packages *for instructions on how do so. These packages will fall in
    one of two categories: packages for creating graphs and packages for working with
    data. Some of the packages used for interactive graphs (graphs that are not static,
    meaning you can *move them around* in your screen to see different angles of the
    data) will require system dependencies to work (for example, `rgl` and `rgdal`),
    and others will work through your web browser (for example, `threejs`, `leaflet`,
    and `plotly`). They have been tested using Google Chrome as a web browser. If
    you encounter any problems with your particular web browser, try using Google
    Chrome. The *static* graphics will be created using `ggplot2` and some packages
    that extend it (for example, `viridis` and `ggExtra`).'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `ggplot2` |  High-quality graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `viridis`  | Color palette for graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `ggExtra` | Graphs with marginal distributions |'
  prefs: []
  type: TYPE_TB
- en: '| `threejs`  | Interactive globe |'
  prefs: []
  type: TYPE_TB
- en: '| `leaflet`  | Interactive high-quality maps |'
  prefs: []
  type: TYPE_TB
- en: '| `plotly`  | Interactive high-quality graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `rgl`  | Interactive 3D graphs |'
  prefs: []
  type: TYPE_TB
- en: '| `rgdal`  | Manipulating geographic data |'
  prefs: []
  type: TYPE_TB
- en: '| `tidyr`  | Manipulating data |'
  prefs: []
  type: TYPE_TB
- en: Extending our data with profit metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, our objective for this chapter is to diagnose the current
    state of business and find new opportunities. To start with, we will look at three
    business metrics from different angles. The metrics are number of sales, profits,
    and profit ratios. They tell us how much The Food Factory is selling in quantity,
    how much it's earning in money (profit), and where it's growth opportunities are
    (profit ratio). Keep in mind that this is not a professional financial assessment
    and, as always, the focus is on the programming techniques not the actual results
    from the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add to each sale its corresponding profits
    and profit ratio. We assume that the only way we can count a profit is if the
    sale order has been delivered and has been paid. Otherwise, we''ll state the profit
    and profit ratio as zero. If the sale qualifies for a profit, then the profit
    calculation is *PROFIT = PRICE - COST - DISCOUNT*. Note that this allows for sales
    that are not profitable (The Food Factory loses money) if the *COST + DISCOUNT
    > PRICE*. If there''s a profit, then the profit ratio is *PROFIT / COST*. What
    we just described is programmed inside the `add_profits()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the `add_profit()` function, we simply apply it to our sales
    data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building blocks for reusable high-quality graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To diagnose the business state and find new opportunities, in this chapter,
    we will use various types of graphs. When it comes to developing static high-quality
    graphs, you can't go wrong with the `ggplot2` package. Standard (built-in) graphs
    in R are fine for exploratory purposes, but are not as flexible or nice-looking
    as `ggplot2` graphs. Since we want to show how to create high-quality graphs,
    we will focus on using this package (and others extending it) for static graphs.
    However, since the vanilla `ggplot2` package only works for static graphs, we
    will use other packages for high-quality interactive graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A downside of having so much flexibility when using `ggplot2` is that it''s
    very verbose, thus requiring a lot of code to create graphs (specially when compared
    to standard R built-in graphing functions). We want to avoid having to copy-paste
    code if we are going to create similar graphs, so we will develop reusable functions
    that we can use to easily create similar graphs. For example, we could do something
    like the following instead of repeating more than 10 lines of `ggplot2` code to
    only make a few small changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, people are not comfortable working this way, but these graphing
    functions are just the same as any other kind of function. The only difference
    is that, whenever we can, we will return a graph object instead of other data
    types. These graph objects are a nice feature when working with `ggplot2` because
    they can''t be passed to other functions (not all graphing packages are designed
    this way). For example, while writing this book, we used the following `save_png()` function,
    which takes a graph object and saves it to disk. All we needed it to do was to
    optionally change a graph''s dimensions when we saved it to make sure that it''s
    the right size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you're working with lots of graphs, if you get an error while creating one
    of them and you print it, you may be confused to see a previous graph you were
    working on. To avoid this confusion, you may execute `graph <- NULL` after every
    print or save function call to make sure that it's evident where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you want to create a graph and save it into a 1024x768 pixels image,
    you can use the `save_png()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The standard way of developing analyzing data is an iterative process closely
    related to the scientific method. However, we will only focus on the code that
    generates the graphs during this chapter. We will interpret the results in [Chapter
    7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730), *Developing Automatic
    Presentations*. We think this helps focus on each topic adequately in it's corresponding
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with simple applications for bar graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with simple graphs and build our way up towards advanced graphs.
    The first graph we will create is a bar graph. We will plot a frequency table
    that shows how many sale orders we have for each `QUANTITY` number in our sales.
    To do so, we use the `ggplot()` function using `sales` as the data and setting
    up the aesthetics with the `aes()` function with `QUANTITY` in the *x* axis (the
    first argument).
  prefs: []
  type: TYPE_NORMAL
- en: After we create a graph base with the `ggplot()` function, we add layers for
    different objects we want to see in the graph (for example, bars, lines, and points).
    In this case, we add bars with the `geom_bar()` function. Note how this layer
    is added using the `+` (plus) sign to the graph base. After that, we add another
    layer for the title with `ggtitle()`. Finally, we add an *x* axis specification
    with the `scale_x_continuous()` function that will allow us to see a number for
    each bar in the graph. If you don't add this layer, your graph may not show a
    number for each bar, which may be a little confusing. The way we specify it is
    by sending a sequence of numbers that should be used as the breaks (where tick
    data is shown). Since the numbers in the data may vary with different simulations,
    we make sure that we use the correct numbers by creating a sequence with the `seq()` function
    from the minimum number in the `QUANTITY` variable to the maximum. This will automatically
    show the correct numbers even if the `QUANTITY` variable has vastly different
    ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'These may seem like a lot of code to build a simple graph. However, it''s precisely
    the amount of code that allows us to be very specific about what we want to see
    in the graph as you''ll see in the following examples. Also, note that only the
    `ggplot()` (with its corresponding `aes()` function) and `geom_bar()` functions
    are required to actually produce the graph. The `ggtitle()` and `scale_x_continuous()` functions
    are only there to improve the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph shows the **QUANTITY frequency** for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: QUANTITY Frequency
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be creating lots of bar graphs, we want to avoid having to copy-paste
    the code we just wrote, and not only that, but also make it more flexible. To
    accomplish this, we will generalize our code by parameterizing it and considering
    different scenarios we should cover.
  prefs: []
  type: TYPE_NORMAL
- en: So, what may we want our custom `graph_bars()` function to allow us to do? To
    start with, we may want to specify different variables for our *x* axis and *y*
    axis. To do this, we need to understand how the `geom_bar()` function works internally.
    If you look back at the code, we never specified the variable for the *y* axis,
    and `ggplot()` automatically used the number of times a `QUANTITY` number appeared
    in the data (the frequency).
  prefs: []
  type: TYPE_NORMAL
- en: What if we want to use the `PROFIT` value for each sale as the variable for
    the *y* axis? In that case, we need to realize that we have more than 2,000 potentially
    different values as `PROFIT` when `QUANTITY` is two or three, and less so in the
    other cases. We need to aggregate those `PROFIT` values somehow before we can
    use `PROFIT` in the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Any function that can reduce the `PROFIT` values into a single value for all
    the transactions, for each value of `QUANTITY`, could be used to aggregate the
    data. However, the most common choices are using the mean or the sum. The mean
    would show a graph where we see the average `PROFIT` for each `QUANTITY` value.
    The sum would show us the total `PROFIT` for each `QUANTITY` value. The same would
    apply if we want to use `PROFIT_RATIO` (or any other numerical variable) in the
    *y* axis. The most intuitive choices are using sum for `PROFIT` (total profit)
    and mean for `PROFIT_RATIO` (average profit ratio), so we will use those.
  prefs: []
  type: TYPE_NORMAL
- en: For the *x* axis, we may have categorical, numerical, or date variables. For
    this particular case, the default *x* axis options are fine for categorical and
    date variables, but we still want to see all the numbers in the ticks when working
    with numerical variables. This means that we need to provide a check for the type
    of variable in the *x* axis, and if it's numerical, then we need to do the proper
    adjustment (the same adjustment we saw in the previous code).
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have explained before is what is programmed in our `graph_bars()` function.
    It receives as parameters the data and the *x* axis and *y* axis variables. First,
    it checks whether or not we specified a particular *y* axis variable. We use the
    "NULL check" technique mentioned in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*. If we don''t receive a *y* axis variable, then we create
    a bar graph as we did earlier (using the frequency of the *x* axis variable by
    default), and we create the corresponding title using the `paste()` function.
    If we do get a variable for the *y* axis (meaning that we are in the `else` block),
    then we need to find out what type of aggregation we need to do, and we do so
    using our `get_aggregation()` function, which returns the sum as the aggregation
    method if we are asked to graph the `PROFIT` variable in the *y* axis, and returns
    the mean in any other case. We then use this function name as the value for the
    `fun.y` parameter (which is read as *function* *for* `y`), and specify that we
    are working with a summary function (when you don''t need aggregation for a variable
    you should send the `stat = ''identity''` parameter to the `geom_bar()` function
    and avoid sending it to the `fun.y` parameter). Then we specify the title of the
    graph as needed. After the `if else` block, we check if the variable type for
    the *x* axis is numeric, and if it is we apply the interval names transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with this special-case function, we recommend that you put the
    special case in the `if` part of the check to make sure that you only catch the
    special cases we''re looking for, and return the generic case otherwise. If you
    do this the other way around (checking for generic cases first) you''ll undoubtedly
    encounter some tricky bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create many more bar graphs with our custom `graph_bars()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: All of the following graphs are shown together for easier visualization and
    space preservation, but you would get them one-by-one when executing the code
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bar graphs
  prefs: []
  type: TYPE_NORMAL
- en: Adding a third dimension with colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As often happens, we want to work on some code we had already created to add
    more features. In this case, we want to add a third dimension to the graphs using
    colors. We want to be able to specify a `color` variable that will be used to
    further divide the data in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we add a `color` parameter to the function's signature using
    the "NULL check" pattern and we add the corresponding parameter in each case.
    Adding the parameter directly in the `aes_string()` function is not problematic
    in case of `NULL` because `NULL` values indicate to `ggplot()` we don't want to
    use a fill color for the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, note that we are not able to use the same technique with `y` . Instead,
    we check whether we should send `y` or not, and only send it to the `ggplot()` function
    if we have a non-`NULL` value. Also, we add the `position = "dodge"` parameter
    to the `geom_bar()` function so that we get unstacked bar graphs. If we don''t
    send this parameter we would get stacked bar graphs, and for these particular
    graphs, we thought the unstacked version looked better. Feel free to try the stacked
    version yourself. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that now we have four different cases we may want to graph, first, when
    specify only the `x` value, second, when we specify the `x` and `y` values, third,
    when we specify the `x` and `color` values, fourth, when we specify all three
    of them. Since the `ggplot()` specification for each of those cases is unique,
    we can't collapse them into a lower number of cases. You should also note that
    we only keep inside the conditional blocks the code that is specific for a particular
    check, and bring out of the conditional block the code that is not specific to
    the check and should be applied to two cases every time. That's what we do with
    the `ylab()` and `geom_bar()` functions in the outer `if` block and with the `get_aggregation()` and
    `geom_bar()` functions in the outer `else` block. Otherwise, we would be repeating
    code unnecessarily, which is a very bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bar graphs with colors
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can produce bar graphs that optionally receive a third parameter `color` (shown
    above), and if sent, it will be used to divide the data using colors. Note that
    in the first line of the following code, we need to explicitly send the `color` parameter.
    This is because we''re omitting the `y` parameter from the function call, and
    if we are not explicit about the `color` parameter, it will be interpreted as
    being the `x` parameter. You can take a refresher on function calls in [Chapter
    1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730), *Introduction to R*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Graphing top performers with bar graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bar graphs are one of the most used graphing tools in the world and this chapter
    is no exception. In our last bar graph example, we will show how to graph the
    top performers for a given variable in the decreasing order. Our objective is
    to graph either `PROFIT` or `Frequency` in the *y* axis and a parameterized variable
    for the *x* axis. We want to show the top `n` performers for the `x` variable
    in a decreasing order from left to right, as is shown in the graph below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Top n bar graphs
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this, we receive as parameters the data (`sales` in this case),
    the variable that will be used for the *x* axis `x`, the number of top performers
    we want to show `n`, and whether we want to use `PROFIT` in the *y* axis or not
    (in which case we will use the `Frequency`) by using the Boolean `by_profit`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is check for the `by_profit` parameter; if it's `TRUE`,
    then we aggregate the `PROFIT` data for each `CLIENT_ID` with the `aggregate()` function
    using the `sum` operator (we want the total profit by client, not the average
    profit by client). Then we order the results with the `order()` function. The
    minus sign (`-`) just before the `profit_by_client$x` value means that we want
    a decreasing order, and the `x` that follows `profit_by_client` is because the
    result of the `aggregate()` function is a data frame with `Group.1` and `x` columns,
    which store the `CLIENT_ID` and the `PROFIT` sum, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to avoid unnecessary duplication of the code when we return the
    graph we want, we need to make sure that both cases in the `if else` block use
    the same names for the variables we will use in the `ggplot()` function. That's
    why we explicitly assign the `x` and `y_bar` names to the `top_df` data frame.
    If you looked inside the `top_df` object during execution, you would find that
    it has duplicated data with different column names. We could take care of this
    by removing the columns with the names we don't want, but it's unnecessary at
    this point since it's a throwaway object anyway. However, in certain situations
    this may be a performance issue we need to deal with, but not in this case.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `else` block, conceptually we do the same thing. However,
    technically we implement differently. In this case, we create a table where each
    entry in the table is a unique `CLIENT_ID` value and the value for each entry
    is the number of times the `CLIENT_ID` appears in the data (`Frequency`), and
    we do so with the `table()` function. Then we sort these results in the decreasing
    order with the `sort()` function and take the top `n` results. Then we use these
    results to create the `top_df` data frame with the corresponding columns. Note
    that we need an auxiliary name `aux_name` for the `x` variable since we can't
    create a data frame by specifying a column name with a variable. What we do is
    then copy the data from the `aux_name` column to the actual name we need (contained
    in the `x` variable).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create a graph and immediately return it without intermediate storage.
    The specifics on what each line is doing in that part of the code should be clear
    to you by this point, so we will avoid explaining that again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you create *top n* graphs easily with the following code. We suggest that
    you try to create similar graphs for other categorical variables (for example,
    `CONTINENT` or `PROTEIN_SOURCE`). Note that the `CLIENT_ID` values in each case
    are different, meaning that the clients that buy the most from The Food Factory
    are not necessarily the clients that generate the most profit for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We wanted to start simple and show the basic concepts of working with graph
    functions before we complicate things in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing disaggregated data with boxplots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating bar graphs is useful when presenting results to people who are not
    familiar with statistics, but the fact that bar graphs aggregate information (just
    as we did in the bar graphs for top performers) means that, in reality, we lose
    information due to the reduction. If you're working with people who understand
    what quartiles are, then boxplots may be a useful visualization. They are an easy
    way to see individual distributions for different levels of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Each box represents the first quartile at the bottom, the third quartile at
    the top, and the median on the line in the middle. The lines that extend vertically
    reach up to any observation within *1.5 * IQR*, where the **interquartile range**
    (**IQR**) is the distance between the first and third quartiles. Any observation
    beyond *1.5 * IQR* is treated as an outlier and is shown individually.
  prefs: []
  type: TYPE_NORMAL
- en: Our objective is to show the bar graph we created for top performers according
    to `PROFIT`, but in a disaggregated way. When using bar graphs, the difficulty
    comes from aggregating the data correctly, but since we don't need to aggregate
    data for boxplots, their creation is very simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `graph_top_n_boxplots()` function takes as parameters the `data` value,
    the variables for the *x* and *y* axis, the number of top performers to show as
    `n`, and optionally the line and fill colors, as `c` and `f`, respectively. If
    no colors are specified, a selection of blues is used. The color specification
    must be done either in a HEX notation ([https://en.wikipedia.org/wiki/Web_colors#Hex_triplet](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet))
    or with R color names ([http://sape.inf.usi.ch/quick-reference/ggplot2/colour](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)).
    We simply filter the data with our `filter_n_top()` function and use the `boxplot()` layer
    to produce the boxplots with the adequate colors. We also specify the title as
    the combination of the parameters received by the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `filter_n_top()` function receives as parameters the `data` value, the number
    of top performers we want to keep as `n`, and the identifier for the performers
    as `by`. First, we use the `aggregate()` function to aggregate the `PROFIT` variable
    by the chosen identifier (which is sent as a list, as is required by the function),
    and do the aggregation with the `sum` operator to get the total `PROFIT` per client.
    If we had used the `mean` operator, we would see a graph for the average `PROFIT` per
    client. Then we order the results, which are contained in the second column of
    the `aggr` object in decreasing order, and take the top `n` values from the first
    column, which contain the identifiers (the `CLIENT_ID` values in the example below).
    Finally, we keep only those observations in the data that correspond to the top
    identifiers we have in the `top` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we can easily replicate the bar graph we created in the previous section
    using boxplots.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Top m boxplots
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have more information shown in the graph, but we loose the
    ability to easily spot the total `PROFIT` value for each `CLIENT_ID`. Choosing
    the graph type depends on what information you''re trying to communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Scatter plots with joint and marginal distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create scatter plots with `ggplot()` in previous chapters.
    Therefore, in this section, we will only focus on the parts that we have not seen
    before. Our objective is to create scatter plots that not only show the scatter
    plot, but extend it by showing the marginal distributions on both axes. These
    are called **marginal plots** and are useful for understanding how data is jointly
    (two variables) as well as marginally (one variable) distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing and profitability by protein source and continent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we start developing our graph function. We receive as parameters
    the `data`, and the variables for the *x* axis (`x`) and *y* axis (`y`), and,
    in this case, we anticipate four cases that correspond to the combinations of
    including or not the `color` and `shape` variables for the graph. We do the standard
    checking and create the corresponding graph base. Here comes the different part,
    we call the `ggMarginal()` function of the `ggExtra` package with the graph object
    we want (in this case, the base graph plus the points layer), and specify the
    type of graph to be used for the marginal distributions. You can chose from `density`,
    `histogram`, and `boxplot`. We choose `histogram`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we are able to easily create scatter plots with marginal distributions on
    the sides. In the first graph (left), we show the relation among `PRICE`, `COST`,
    `PROTEIN_SOURCE`, and `CONTINENT`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Marginal distributions
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are very distinguishable groups. In the second graph (right),
    we show the relation among `PRICE`, `PROFIT_RATIO`, `PROTEIN_SOURCE`, and `CONTINENT`.
    Note that we find the same relation we did in our 3D interactive scatter plots,
    the higher the `PRICE` value, the higher the `PROFIT_RATIO` value. However, there
    are two interesting findings here that we will mention in [Chapter 7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730),
    *Developing Automatic Presentations*. Can you tell what they are?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `graph_marginal_distributions()` function to graph the combination
    of `COST`, `PRICE`, `STATUS`, and `PAID`, you should see no pattern emerge as
    those distributions were randomly simulated to be normally distributed in [Chapter
    4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730), *Simulating Sales Data
    and Working with Databases*, and no skewing process was applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: Client birth dates, gender, and ratings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A problem you will encounter when programming is that sometimes a function you
    thought would be general enough needs to be changed in some way. Sometimes the
    right decision is to change the existing function, but other times, the right
    decision is to create a new function (maybe based on the original one) that can
    be modified as needed without breaking old code that used it. This happens when
    the assumptions for the function are not met, and can't be easily accommodated.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, what happens if we want to use the `clients` data to graph our
    clients' birth dates using the year in the *x* axis, month in the *y* axis, color
    by gender, and show the rating adjusting the size of the dots? Well, the *x* axis
    and the *y* axis data assumptions may be fulfilled with minor data transformations,
    the color assumption is already met, but the size assumption doesn't seem to fit
    our previous model.
  prefs: []
  type: TYPE_NORMAL
- en: In our `graph_marginal_distributions()` function, we assumed that we would use
    the `shape` as the fourth variable to represent categorical variables, but it
    seems that, even though the `STARS` variable is technically a factor, it would
    be better represented using size rather than different shapes. The fact that we
    need to deal with the *x* axis, *y* axis, and size assumptions within special
    cases for the `clients` data, is reason enough to decide to create its own function
    based on the original one. If at some point we want to merge these two functions
    into a single one, we can do so, but there's no need to over complicate things
    for ourselves at this point.
  prefs: []
  type: TYPE_NORMAL
- en: In our `graph_marginal_distributions_client_birth_dates()` function, we only
    need to receive the data we will be working on (`clients` in this case). There's
    no need for other parameters because all the assumptions will be hardcoded inside
    the function in this case, because we're not looking to generalize the code. To
    make the code a little more readable, we will use short variable names to contain
    the string we will use to create the specification for the plot. That's what those
    `x`, `y`, `x_noise`, and `y_noise` variables are.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, we need to slightly transform the data before we are able to produce
    the plot. First, we need to disaggregate the `BIRTH_DATE` into `BD_YEAR` and `BD_MONTH` (`BD` is
    short for birth date). Then we add noise to the dates because if just kept dates
    as they are, we would get a grid of values, not a distribution, and that's because
    both the year and the month are integer values, so there would be a lot of dots
    stacked up on each other and a lot of space empty between them, we can see a mixed
    version of the data, and that's why we need to add noise to it. See below how
    both of these functions work internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have our short names and have transformed our data, we are ready to
    create a scatter plot just as we have done before. Here''s where the distinction
    between dates with and without noise comes into play. If we used the dates with
    noise to display the tick values for the axis, we would see year labels like 1953.51,
    1973.85, 1993.23, and so on. Clearly, it''s not intuitive to display the year
    axis with such values. Similarly, for the *y* axis, we would see month values
    like 1.24, 4.09, 8.53, and so on. The same problem. That''s why we need two versions
    of the data, the one with the noise (real values) that is used to place the dots
    in the graph, and the one without the noise (integer values) that is used to show
    values in the axis. Finally, we add the axis labels and send the graph through
    the `ggMarginal()` function as we had done earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding noise to the data is straightforward, we simply create new variables
    (`BD_YEAR_NOISE` and `BD_MONTH_NOISE`) that have the original (integer) values
    and we add a random number from the normal distribution with a mean of 0 and a
    standard deviation of 0.5\. We need a small standard deviation to make sure that
    our data is not changed too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To disaggregate the dates, we simply create new variables (`BD_YEAR` and `BD_MONTH`)
    that contain the corresponding date value extracted using the date format specification
    that comes with R (`%Y` for year and `%m` for numeric month) converted to numbers
    (so that we can add noise to them and plot them). For more information on the
    date format specification, take a look at the *Dates and Times in R* page from
    Berkeley University ([https://www.stat.berkeley.edu/~s133/dates.html](https://www.stat.berkeley.edu/~s133/dates.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the client birth dates with the help of a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Client birth dates with marginal distribution
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can easily create this graph anytime we want without having to worry
    about the details of how to create it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Developing our own graph type – radar graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will take our graph functions to the next level as we develop our
    own custom graph type. The `ggplot2` package does not have a way to produce radar
    graphs by default, so we will develop it ourselves during this section. There
    are packages that extend `ggplot2` with radar graph capabilities (for example,
    `ggradar`), but we will show how to create it yourself from scratch. After reading
    this section, you'll be equipped to develop complex graphs on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Radar graphs are plotted on a circular canvas and can show many variables values
    at the same time. They form a *radar-looking* shape and are useful if you want
    to compare different variable values among various *entities*. Sometimes they
    are used to visually get a sense of how similar or different *entities* are. If
    you're not familiar with this type of graphs, there's one shown in the following
    image. In our example, instead of measuring speed, durability, comfort, power,
    and space, as this example does, we will measure the three different macronutrients
    for The Food Factory's top five clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `graph_radar()` function receives as parameters the `data` data frame and
    the variable by which we want to show radars (`CLIENT_ID` in our case). First,
    it transforms the data we need from wide to long format using the `gather()` function.
    Then it creates the labels that will be used in top of each radar graph, which
    show the profit produced by each `CLIENT_ID`. Finally it returns the graph object,
    which is created by specifying the macronutrients and percentages, adding a polygon
    layer groups, colors, and fills by the `CLIENT_ID`, and adjusting the `alpha`(transparency)
    and line size to look good.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `facet_wrap()` function is used to repeat the same plot for each instance
    of the `by` variable in the data (`CLIENT_ID` in our case). Since it requires
    a formula, and we want to generalize its usage, we use a combination of the `as.formula()` and
    `paste()` functions. To recall how these work, look at [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730),
    *Predicting Votes with Linear Models*. We also pass the `nrow = 1` parameter to
    make sure that we get a single row of graphs. We remove any legend information
    with the `guides()` function by sending the `"none"` string to the corresponding
    legends, apply our `coord_radar()` function (more on this below), and remove the
    axis labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `coord_radar()` function is not a built-in function in the `ggplot2` package,
    and we need to program it ourselves. The version we will work with here is a slightly
    modified version of the `coord_radar()` found around the internet first attributed
    to Hadley Wickham. It leverages the `ggproto()` function to inherit and modify
    the polar coordinates layer in `ggplot2`, which receives parameters `theta` (angle),
    `r` (radius), `start` (starting point), `direction` (whether to use positive or
    negative units), and a hack that returns the function required by the `is_linear` parameter
    such that its value is always `TRUE`. If we did not send this last hack, we would
    get circular shapes just as we do with polar coordinates when trying to graph
    a straight line. The preceding code simply selects the appropriate axis for the
    angle so that we get the radar shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `ggproto()` function is used as an *internal object system* within the `ggplot2` package,
    and was developed to avoid having to change too much of the code base when implementing
    layered objects. It's not recommended for you to use it unless absolutely necessary.
    For more information on object systems, look at [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies.*
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our graph function ready, we need to make sure that our data
    is formatted correctly. To do so, we create the `filter_data()` function to filter
    the data and produce the expected structure. The function receives as parameters
    the `data` we will use, the number of days to keep backwards from the current
    date as `n_days`, the number of top performers we will show as `n_top`, and the
    variable we will aggregate by as `aggregate_by`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we filter the data `n` days back and then keep the observations only
    for the `n_top` performers according to the `aggregate_by` variable. As we do,
    we update the `data` accordingly. Then, we aggregate the data twice, once by `PROFIT` and
    the other time by macronutrients (`PROTEIN`, `CARBS`, and `FAT`), and we get back
    the `CLIENT_ID` name into the data frame. Doing so produces two data frames, `aggr_profit` and
    `aggr_macros`, where each one aggregates its respective variables for each unique
    `CLIENT_ID`. Note that we separate this process into two independent parts because
    we want to aggregate `PROTEIN`, `CARBS`, and `FAT` with `mean` to get the average
    preference for each `CLIENT_ID`, but at the same time, we want to aggregate `PROFIT` with
    `sum` to get the total profit (not the average profit) for each `CLIENT_ID`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we merge the data with the `merge()` function using our `aggregate_by` variable
    to be the index by which we join the data, drop residue columns from the data
    frame, and order it by `PROFIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you read the code carefully, you may have noticed a detail we did not mention,
    the usage of the `PROFIT_RATIO` variable in the aggregation even if we don't use
    it later in the function. The reason for including `PROFIT_RATIO` in the `aggregate()` computation
    is because of the side-effect it produces. When specifying two or more variables
    inside the data for the `aggregate()` function, the result comes back with the
    actual data frame column names in the resulting data frame `aggr_profit`. If we
    only specify `PROFIT` by itself, the result will have a column named `x` instead
    of `PROFIT`, as we have seen and used in the previous code during this chapter.
    It's an easy way to avoid dealing with variable name changes. In my opinion, the
    `aggregate()` function should always return the original data frame names, but
    it does not so we have to work around it. Remember to keep this usability in mind
    when programming for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how we actually filter dates, we look inside the `filter_n_days_back()` function.
    As you can see, we receive as parameter the `data` we want to filter and the number
    of days we want to keep backwards as `n`. If `n` is `NULL`, meaning that the user
    did not want to filter the data backward, then we simply return the same `data` we
    got. If you do receive a number in `n`, then we get the current date and subtract
    `n` days from it with `Sys.Date() - n`. This simple subtraction is automatically
    done with days as units, thanks to a technique called **operator overloading**.
    We will look at the details of how it works in [Chapter 8](part0178.html#59O440-f494c932c729429fb734ce52cafce730),
    *Object-Oriented System to Track Cryptocurrencies*. Finally, we simply keep those
    dates that is at least the `n_days_back` date (another usage of the *operator
    overloading* technique which allows us to compare dates). The `filter_n_top()` function
    is the one we created earlier for the boxplots code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `filter_data()` function is very useful in itself. For example, we can
    easily show the average macronutrients for the top 5 clients during the last 30
    days by executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Having made the investment in creating the corresponding graph function, we
    are now able to easily produce our own radar graphs. For example, we can easily
    produce the corresponding radar graph for the data we just showed earlier with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image gives a representation of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Top clients' macronutrients average radar
  prefs: []
  type: TYPE_NORMAL
- en: Exploring with interactive 3D scatter plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When exploring data, sometimes it''s useful to look at a 3D scatter plot. However,
    if the scatter plot is fixed (meaning that you cannot move it around), it may
    not be easy to interpret. Having an interactive plot (one you can move around)
    to see different angles of the data is very useful in these cases. These graphs
    don''t normally go into static reports because they are hard to interpret correctly
    when fixed, but are very useful to do data exploration. Luckily, they are also
    very easy to create with the `plot3d()` function from the `rgl` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once you create these plots in your computer, remember to move them around with
    your mouse! The first time you do this, it's pretty amazing. In this case, you
    can see two phenomenons that occur in the `sales` data. First, macronutrient percentages
    must add to one, and since there are three of them, what you will see in the graph
    on the left is a triangle shape in such a way that the sum of the coordinates
    for each point inside it is equal to one. Second, the graph on the right shows
    the relation among `PRICE`, `QUANTITY`, and `PROFIT_RATIO`. It shows that there
    are no fractional quantities in our sales data (just as we designed it), that
    there are lots of orders with zero `PROFIT_RATIO` because they are not fulfilled
    or payed for, and that the higher the `PRICE` is, the higher the `PROFIT_RATIO` is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's not much more to explain about these graphs. They are simple to create,
    have a simple purpose which sometimes can be very useful, but you will not normally
    see them in written reports.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at dynamic data with time-series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are going to focus on another very common type of graph: time-series.
    Our objective is to understand how our data is behaving for the last `n` days,
    and, as we have done before, we want to further disaggregate using colors, like
    the graph below shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have read all the chapter up until this point, you should be able to
    understand most of what the function is doing. The only new function is `scale_x_date()`.
    It allows us to specify date formats for the axis ticks other than the default.
    In this case, we want to use breaks by day (as we had done in some examples before),
    but we want the format of the labels to be similar to **July 30, 2017**, for example.
    To do so we make use of the date formats mentioned in a previous section in this
    chapter and send the desired string structure to the `date_labels` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to look at simple line graphs that show either the frequency, `PROFIT`,
    or `PROFIT_RATIO` for the last 30 days, you can use the following code. We don''t
    show these images to preserve space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To look at line graphs for frequency, `PROFIT`, and `PROFIT_RATIO`, that distinguish
    `PROTEIN_SOURCE` with colors, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `graph_last_n_days()` function with other data frames. For example,
    graph the `STARS` ratings during the last 30 days coming from `client_messages`, you
    simply need to transform the categorical variable `STARS` into a numeric variable
    with the `as.numeric()` function so that you don't get errors for type mismatches,
    and call the function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t specify a variable to disaggregate using colors, it will graph
    with black by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Looking at geographical data with static maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps can be very useful tools to get an intuition behind geographical data.
    In this section, we will produce a map with the `ggplot2` package. The objective
    is to show the location of our client's messages, the `PRICE` associated to their
    purchases, and the corresponding `PROFIT_RATIO`. This example will show us how
    to join data from the `sales` and `client_messages` data frames.
  prefs: []
  type: TYPE_NORMAL
- en: Our `graph_client_messages_static()` function receives as parameters the `client_messages` and
    `sales` data frames, and that's all it needs as we are showing unfiltered (full)
    datasets. First, we need to merge our two data frames using the identifier they
    share, which is `SALE_ID`. To do so we use the `merge()` function, and we specify
    that we want to keep all observation on the `x` data frame, which is the first
    one (`client_messages`), and we don't want to keep observations from the `y` data
    frame, which is the second one (`sales`), if they don't have a corresponding identifier
    in the first data frame. This allows us to keep only data that has client messages
    associated with it. Then we produce the map geographical data with the `map_data()` (it
    comes in the `ggplot2` package), and we filter it to remove any region marked
    as `"Antarctica"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually create the graph we are going to use two main layers. The first
    one is the geographical data, which is added with the `geom_polygon()` function,
    using the `world_map` data, specifying the coordinates and groups (groups define
    countries), and use some dark colors to contrast with our dots. The second layer
    is the messages data, which is added with the `geom_point()` function, using the
    merged `data` data frame, with the corresponding coordinates, and adding colors
    and sizes with `PRICE` and `PROFIT_RATIO`, respectively. Since we are using a
    numeric variable to specify the color in this example, we will get a gradient
    of colors instead of discrete colors as in previous examples. Finally, we specify
    the actual color palette using the `scale_color_viridis()` function, set up the
    appropriate axis labels, and make the coordinates have equal units with the `coord_fixed()` function.
    If we don''t use this last function, we can get maps which are deformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create our maps with the following function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so, results in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, if you want to generalize this function, you can parameterize some
    of the variables used for the graph's specification as we have done in previous
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating geographical data with interactive maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can navigate the geographical data with the help of interactive maps, which
    are explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Maps you can navigate and zoom-in to
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section, we will create interactive maps that we can navigate.
    This is a very powerful tool that can be embedded in your R projects, greatly
    increasing their value and impact on your audience. We will use the `leaflet` package
    to develop this map. Our objective is to show a map with the locations of the
    messages we receive from our clients with icons that represent the type of rating
    we got using the `STARS` variable of the message and tooltips that show the `PROFIT` associated
    to the corresponding purchase of each message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `graph_client_messages_interactive()` function receives the `client_messages` and
    `sales` data frames. As in the previous map, we will show all data without any
    filters, so that''s all we need as parameters. The first thing we do, as we did
    earlier, is merge the data so that we keep only observations that have an associated
    message. Then we add a new variable to the `data` data frame that contains the
    icon specification that will be used by `leaflet`. To do so, we use the `awesomeIcons()` function
    (it''s part of the `leaflet` package) and specify the functions used to specify
    the icon, the marker color, and say we want our icons to be white and that they
    should come from the `ion` icon library ([http://ionicons.com/](http://ionicons.com/)).
    Other icon libraries available are `glyphicon` ([http://glyphicons.com/](http://glyphicons.com/))
    and `fa` (`fontawesome`, [http://fontawesome.io/icons/](http://fontawesome.io/icons/)).
    You may find the icon you''re looking for in the referenced websites. Finally,
    we return the *leaflet graph* by creating markers with the `addAwesomeMarkers()` function,
    which receives a *leaflet object* created with the `leaflet()` function wrapped
    around our `data`, the formulas for longitudes and latitudes, the formula for
    icons, and the formula for the labels. Optionally, we wrap the *leaflet graph* with
    the `addProviderTiles()` to make sure that we get *tiles* (geographical background
    images) in our web browser. We need this because at the time of this writing there''s
    a bug that will not show geographic data (only the markers) under specific circumstances
    and we want to avoid that problem, which we can easily do with the mentioned technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will explain the functions that specify the icons and marker colors.
    The `get_icon_color()` function will receive our `data` data frame and return
    a vector with string, which is either `"green"` or `"red"`, depending on whether
    or not the associated `STARS` where higher or equal to 4, or not. We do so using
    the `sapply()` function. If you need a refresher on these vectorized functions,
    take a look at [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_icon()` function is very similar but it will return the name of the
    icon we want. We got these names from the `ion` icon library website (referenced
    earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now we can easily produce the interactive maps for our clients' messages using
    the following code. It will open a web browser and show you a map that you can
    move around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The initial position for the map will show the full geographical data as is
    shown in the following image. As you can see, the markers contain either a happy
    or a sad face, depending on the rating each message had. Also, the color of the
    marker is either green or red, again depending on the rating.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A zoomed-in version of the interactive map can be seen in the following image.
    Depending on the provider you choose in the `addProviderTiles()` function, you
    will get different types of geographical images (you can see some of them in action
    at [htt://leaflet-extras.github.io/leaflet-providers/preview/](http://leaflet-extras.github.io/leaflet-providers/preview/)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: High-tech-looking interactive globe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To finish this chapter, we will build an interactive high-tech-looking globe
    you can move around and show off to your friends. These types of visualizations
    are normally not very useful for analysis, but they are cool!
  prefs: []
  type: TYPE_NORMAL
- en: Our objective is to show a globe that will show geographical data coming from
    clients' messages as well as bars whose height represents the `PROFIT` associated
    to each sale and colors for `PROTEIN_SOURCE`. To accomplish this, we will use
    the `threejs` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did earlier, our `graph_client_message_in_globe()` function receives
    the `client_messages` and `sales` data and sets it up using the `setup_globe_data()` function.
    Then it will get world `data` using the `get_world_map_data()` function and append
    it to the `data` data frame using the `rbind.fill()` function from the `plyr` package.
    This function resembles R''s own `rbind()` function, but won''t complain if columns
    do not match. Instead, it will fill the empty values with missing data indicators.
    Finally, we return a globe object with the `globejs()` function, which receives
    the coordinates in `lat` and `long`, the bar height under the `val` parameter,
    which comes from the `PROFIT` variable, the `color` which comes from a `COLOR` variable
    created during the data setup (see in the following example), and the `atmosphere
    = TRUE` parameter to show a glowing effect around the globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup_globe_data()` function does the standard merging we''ve done with
    all maps and adds a new variable named `COLOR` that contains the colors that should
    be used for each observation. In the case of the `ggplot2` package, this color
    assignment was done automatically for us, but in the `threejs` package, we need
    do it ourselves. It will simply be a different color for each value in the `PROTEIN_SOURCE` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `get_world_map_data()` function is somewhat complicated. If you don't understand
    how it works, don't worry too much, as you probably won't need to do this yourself.
    We can't just use the data we had used before to create maps that we crated with
    the `map_data()` function, because the required data structure is different. In
    this case, we will create a temporary file named `cache` with the `tempfile()` function.
    Then we will read a binary file coming from a URL with the `url()` and `readBin()` functions.
    The file is a TIFF file, which we open in a `"raw"` format to keep all the data
    as is and avoid any data interpretation within R. The `n` parameter is the maximum
    number of records to be read from the data, which is 1 million in this case. Then
    we send this data through the `writeBin()` function so that it gets written to
    the `cache` file we created before. This mechanism is a way of downloading some
    temporary data so that we can read it into a function that does not support reading
    from online resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the temporary file ready, we read it with the `readGDAL()` function
    from the `rgdal` package, which will read it as geographical data. The specific
    format for this data includes longitude, latitude, and an altitude metric. The
    altitude metric is used to identify areas without land (oceans), which contain
    a value higher than or equal to 255 in this data. We proceed to remove any `NA` values
    in the data and assign default `PROFIT` and `COLOR` values. Note that we create
    these `PROFIT` and `COLOR` values to facilitate merging the data later on. We
    use the `PROFIT` column name for the altitude metric just for convenience since
    we will want to show the geographic areas with low bars, and we know that we will
    use `PROFIT` to generate the height for each bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we invested in creating our graph function, we can create high-tech looking
    maps that display the location of messages we get from our clients, with bars
    and colors that indicate related `PROFIT` and `PROTEIN_SOURCE` for each message,
    respectively. Feel free to move the globe around in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's a pretty cool effect isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create various types of data visualizations
    and how to work with graph functions and graph objects efficiently. Apart from
    the basic graph types, you learned how to create interactive graphs and maps and
    how to create our own custom types of graphs. The fundamentals shown in this chapter
    allow you to create high-quality visualizations using important and popular packages
    such as `ggplot2` and `leaflet`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [Chapter 6](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730),
    *Understanding Reviews with Text Analysis*, we will analyze the text data we have
    from client messages as well as data we retrieve from Twitter in real-time. We
    will show how to generate sentiment analysis given textual data, and we will prepare
    ourselves to put the graphs in this chapter together with the text analysis in
    the following chapter into automatic reports in [Chapter 7](part0147.html#4C62M0-f494c932c729429fb734ce52cafce730),
    *Developing Automatic Presentations.*
  prefs: []
  type: TYPE_NORMAL
