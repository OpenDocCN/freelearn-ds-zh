- en: Chapter 10. Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how functional programming and metaprogramming
    make it possible to customize the behavior of functions. We can create a function
    within a certain context, which is called a closure. We can also use higher order
    functions by passing functions around just like other objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to customize the behavior of objects by
    walking into the world of object-oriented programming. R provides several different
    object-oriented systems to work with. At first glance, they look quite different
    from the object-oriented systems in other programming languages. However, the
    idea is mostly the same. I will briefly explain the concept of class and method
    of objects, and show you how they can be useful in unifying the way we work with
    data and models.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics at the beginner level in the subsequent
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S4 system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reference class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R6 package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will compare these systems in several aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a developer from programming languages such as Java, Python, C++,
    C#, you should feel familiar with the object-oriented style of coding. However,
    if you are not familiar with any other object-oriented programming languages,
    you will probably be puzzled by this term, as it sounds a bit abstract. However,
    don't worry; this is much easier to understand than it looks if we think about
    the core of programming.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about programming, we are actually talking about using programming
    tools to solve problems. Before solving the problem, we need to model the problem
    first. Traditionally, we usually figured out an algorithm that takes several steps
    to solve a numeric computing problem. Then, we wrote some procedural code to implement
    the algorithm. For example, most statistical algorithms are implemented in a procedural
    style, that is, by transforming the input into the output according to the theory,
    step by step.
  prefs: []
  type: TYPE_NORMAL
- en: However, many problems are so closely bounded to the real world that it can
    be very intuitive to model the problem by defining some classes of objects as
    well as the interaction between them. In other words, by programming in an object-oriented
    style, we simply try to mimic the important features of the objects in concern
    at an appropriate level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concepts involved in object-oriented programming. Here, we will
    only focus on the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding classes and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important concepts in this chapter are classes and methods. A class
    describes what the object is, and a method defines what it can do. There are countless
    real-world examples for these concepts. For example, `animal` can be a class.
    In this class, we can define methods such as make sound and move. The `vehicle`
    can be a class, too. In this class, we can define methods such as start, move,
    and stop. The `person` can be a class that has methods such as wake up, talk to
    another person, and go somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: For a particular problem, we can define classes according to our need to model
    the objects we are dealing with and define methods for them to model the interaction
    between the objects. The objects need not be physical or tangible. One practical
    example is a bank account. It only exists in the data storage of banks, but it
    can be useful to model bank accounts with some data fields such as balance and
    owner, and some methods such as deposit, withdraw, and transfer between two accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important concept of object-oriented programming is inheritance, that
    is, we can define a class that inherits the behavior of a base (or super) class
    and has some new behavior. Usually, the base class is more abstract and general
    in concept, and the inheriting class is more concrete and specific. This is simply
    true for the concepts in our everyday life.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `dog` and `cat` are two classes that inherit from the `animal`
    class. The `animal` class defines methods such as make sound and move. The `dog`
    and `cat` classes inherit these methods but implement them in different ways so
    that they make different sounds and move in different manners.
  prefs: []
  type: TYPE_NORMAL
- en: Also, `car`, `bus`, and `airplane` are classes that inherit from the `vehicle`
    class. The `vehicle` class defines methods such as `start`, `move`, and `stop`.
    The `car`, `bus`, and `airplane` classes inherit these functionalities but work
    in different ways. The `car` and `bus` can move in two dimensions on the surface,
    while airplane can move in three dimensions in the air.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other concepts in the system of object-oriented programming,
    but we are not going to focus on them in this chapter. Let's keep in mind the
    concepts we mentioned and see how these concepts work in R programming.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the S3 object system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The S3 object system in R is a simple, loose, object-oriented system. Every
    basic object type has an S3 class name. For example, `integer`, `numeric`, `character`, `logical`, `list`,
     `data.frame`, and so on are all S3 classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the type of `vec1` class is `double`, which means the internal
    type or storage mode of `vec1` is double floating numbers. However, its S3 class
    is `numeric`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `data1` class is `list`, which means the internal type or storage
    mode of `data1` is a list, but its S3 class is `data.frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, we'll explain the difference between the internal
    type of an object and its S3 class.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generic functions and method dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, a class can possess a number of methods
    that define its behavior, mostly with other objects. In the S3 system, we can
    create generic functions and implement them for different classes as methods.
    This is how the S3 method dispatch works to make the class of an object important.
  prefs: []
  type: TYPE_NORMAL
- en: There are many simple examples of the S3 generic function in R. Each of them
    is defined for a general purpose and allows different classes of objects to have
    their own implementation for that purpose. Let's first take a look at the `head()`
    and `tail()` functions. Their functionality is simple: `head()` gets the first `n`
    records of a data object, while `tail()` gets the last `n` records of a data object.
    It is different from`x[1:n]` because it has different definitions of record for
    different classes of objects. For an atomic vector (numeric, character, and so
    on), the first `n` records just means the first `n` elements. However, for a data
    frame, the first `n` record means the first `n` rows rather than columns. Since
    a data frame is essentially a list, directly taking out the first `n` elements
    from a data frame is actually taking out the first `n` columns, which is not what `head()`
    is intended for.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s type `head` and see what''s inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We find that there are no actual implementation details in this function. Instead,
    it calls `UseMethod("head")` to make `head` a so-called **generic function** to
    perform method dispatch, that is, it may behave in different ways for different
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create two data objects of `numeric` class and `data.frame` class,
    respectively, and see how method dispatch works when we pass each object to the
    generic function `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For a numeric vector, `head` simply takes its first several elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for a data frame, `head` takes its first several rows rather than
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can use a function to mimic the behavior of `head`. The following
    code is a simple implementation that takes the first `n` elements of any given
    object `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For a numeric vector, it works in exactly the same way as `head`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for a data frame, it actually tries to take out the first `n` columns.
    Recall that the data frame is a list, and each column of the data frame is an
    element of the list. It may cause an error if `n` exceeds the number of columns
    of the data frame or, equivalently, the number of elements of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve the implementation, we can check whether the input object `x` is
    a data frame before taking any measures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the behavior of `simple_head2` is almost the same with `head` for atomic
    vectors and data frames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `head` offers more than this. To see the methods implemented for `head`,
    we can call `methods()`, which returns a character vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It shows that there is already a bunch of built-in methods of `head` for a number
    of classes other than vectors and data frames. Note that the methods are all in
    the form of `method.class`. If we input a `data.frame` object, `head` will call `head.data.frame`
    internally. Similarly, if we input a `table` object, it will call `head.table`
    internally. What if we input a numeric vector? When no method is found that matches
    the class of the input object, it will turn to `method.default`, if defined. In
    this case, all atomic vectors are matched by `head.default`. The process through
    which a generic function finds the appropriate method for a certain input object
    is called **method dispatch**.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like we can always check the class of the input object in a function
    to achieve the goal of method dispatch. However, it is easier to implement a method
    for another class to extend the functionality of a generic function because you
    don't have to modify the original generic function by adding specific class-checking
    conditions each time. We'll cover this later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with built-in classes and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'S3 generic functions and methods are most useful in unifying the way we work
    with all kinds of models. For example, we can create a linear model and use generic
    functions to view the model from different perspectives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In previous chapters, we mentioned that a linear model is essentially a list
    of data fields resulted from model fitting. That''s why the type of `lm1` is `list`,
    but its class is `lm` so that generic functions will choose methods for `lm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The S3 method dispatch even happens without explicit calling of S3 generic
    functions. If we type `lm1` and see what it is, the model object is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, `print` is implicitly called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that `lm1` is essentially a list. Why does it not look like a list
    when it is printed? This is because `print` is a generic function, and it has
    a method for `lm` that prints the most important information of the linear model.
    We can get the actual method we call by `getS3method("print", "lm")`. In fact, `print(lm1)`
    goes to `stats:::print.lm`, which can be verified by checking whether they are
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that `print.lm` is defined in the `stats` package, but is not exported
    for public use, so we have to use `:::` to access it. Generally, it is a bad idea
    to access internal objects in a package, because they may change in different
    releases and have no changes visible to the user. In most cases, we simply don't
    need to because generic functions such as `print` automatically choose the right
    method to call.
  prefs: []
  type: TYPE_NORMAL
- en: 'In R, `print` has methods implemented for many classes. The following code
    shows how many methods are implemented for different classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can call `methods("print")` to view the whole list. In fact, if more packages
    are loaded, there will be more methods defined for classes in these packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `print` shows a brief version of the model, `summary` shows detailed
    information. This function is also a generic function that has many methods for
    all kinds of model classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The summary of a linear model provides not only what `print` shows but also
    some important statistics for the coefficients and the overall model. In fact,
    the output of `summary` is another object that can be accessed for the data it
    contains. In this case, it is a list of the `summary.lm` class, and it has its
    own method of `print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To list what elements `lm1summary` contains, we can view the names on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access each element in exactly the same way as we extract an element
    from a typical list. For example, to access the estimated coefficients of the
    linear model, we can use `lm1$coefficients`. Alternatively, we will use the following
    code to access the estimated coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `coef` is also a generic function that extracts the vector of coefficients
    from a model object. To access the detailed coefficient table in the model summary,
    we can use `lm1summary$coefficients` or, again, `coef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are other useful model-related generic functions such as `plot`, `predict`,
    and so on. All these generic functions we mentioned are standard ways in R for
    users to interact with an estimated model. Different built-in models and those
    provided by third-party packages all try to implement these generic functions
    so that we don't need to remember different sets of functions to work with each
    model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use the `plot` function to the linear model with 2-by-2
    partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following image with four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with built-in classes and methods](img/image_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we used `plot` function to a linear model, which will result
    in four diagnostic plots that show the features of the residuals, which can be
    helpful in getting an impression on whether the model fit is good or bad. Note
    that if we directly call the `plot` function to a `lm` in a console, the four
    plots are interactively done in turn. To avoid this, we call `par()` to divide
    the plot area into 2-by-2 subareas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most statistical models are useful because they can be used to predict with
    new data. To do this, we use `predict`. In this case, we can supply the linear
    model and the new data to `predict`, and it will find the right method to make
    predictions with new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be used both in sample and out of sample. If we supply new
    data to the model, it is out-of-sample prediction. If the data we supply is already
    in the sample, it is in-sample prediction. Here, we can create a scatter plot
    between actual values `(mtcars$mpg)` and fitted values to see how well the fitted
    linear model predicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with built-in classes and methods](img/image_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `fitted` is also a generic function, which, in this case, is equivalent
    to `lm1$fitted.values`, fitted values are also equal to the predicted values with
    the original dataset using `predict(lm1, mtcars)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between the actual values and fitted values of the response
    variable is called residuals. We can use another generic function `residuals`
    to access the numeric vector, or equivalently, use `lm1$residuals`. Here, we will
    make a density plot of the residuals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot generated is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with built-in classes and methods](img/image_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding function call, all involved functions are generic functions.
    The `residuals` function extracts the residuals from `lm1` and returns a numeric
    vector. The `density` function creates a list of class `density` to store the
    estimated data of density function of the residuals. Finally, `plot` turns to `plot.density`
    to create a density plot.
  prefs: []
  type: TYPE_NORMAL
- en: These generic functions work not only with `lm`, `glm`, and other built-in models,
    but also with models provided by other packages. For example, we use the `rpart`
    package to fit a regression tree model using the same data and the same formula
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have the package installed, you need run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the package is ready to attach. We call `rpart` in exactly the same way
    as `lm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do so because the package authors want the function call to be consistent
    with how we call built-in functions in R. The resulted object is a list of class
    `rpart`, which works in the same way with `lm` is a list of class `rpart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `lm` object, `rpart` also has a number of generic methods implemented.
    For example, we use the `print` function to print the model in its own way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output indicates that `print` has a method for `rpart`, which briefly shows
    what the regression tree looks like. In addition to `print`, `summary` gives more
    detailed information about the model fitting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, `plot` and `text` also have methods for `rpart` to visualize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the following tree graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with built-in classes and methods](img/image_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use `predict` to make predictions with new data, just like what we did
    with the linear model in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that not all models implement methods for all the generic functions. For
    example, since the regression tree is not a simple parametric model, it does not
    implement a method for `coef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Defining generic functions for existing classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use existing classes and methods
    to work with model objects. The S3 system, however, also allows us to create our
    own classes and generic functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the example where we used conditional expressions to mimic the method
    dispatch of `head`. We mentioned that it works, but is often not the best practice.
    S3 generic functions are more flexible and easier to extend. To define a generic
    function, we usually create a function in which  `UseMethod` is called to trigger
    method dispatch. Then, we create method functions in the form of `method.class`
    for the classes we want the generic function to work with and usually a default
    method in the form of `method.default` to capture all other cases. Here is a simple
    rewriting of this example using generic function and methods. Here, we will create
    a new generic function, `generic_head`, with two arguments: the input object `x`
    and the number of records to take, `n`. The generic function only calls `UseMethod("generic_head")`
    to ask R for method dispatch according to the class of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For atomic vectors (numeric, character, logical, and so on), the first `n`
    elements should be taken. We can define `generic_head.numeric`, `generic_head.character`,
    and so on respectively, but in this case, it looks better to define a default
    method to capture all cases that are not matched by other `generic_head.class`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `generic_head` has only one method, which is equivalent to not using generic
    function at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we haven''t defined the method for class `data.frame`, supplying a data
    frame will fall back to `generic_head.default`, which causes an error due to the
    invalid access of an out-of-bound column index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let''s assume we define a method for `data.frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic function works as it is supposed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the methods we implemented earlier are not robust because
    we don't have the argument checked. For example, if `n` is greater than the number
    of elements of the input object, the function will behave differently and usually
    in an undesirable way. I'll leave it as an exercise for you to make the methods
    more robust and behave appropriately for corner cases.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects of new classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it is time to have some examples of defining new classes. Note that `class(x)`
    gets the class of `x`, while `class(x) <- "some_class"` sets the class of `x`
    to `some_class`.
  prefs: []
  type: TYPE_NORMAL
- en: Using list as the underlying data structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `lm` and `rpart`, list is probably the most widely used underlying
    data structure to create a new class. This is because a class represents a type
    of object that can store different kinds of data with different lengths and has
    some methods to interact with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will define a function called `product` that creates
    a list of the class `product` with a name, price, and inventory. We''ll define
    its own `print` method and add more behaviors as we go ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we created a list first, replaced its class with `product`, and finally
    returned the object. In fact, the class of an object is a character vector. An
    alternative way is to use `structure()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a function that produced objects of the class `product`. In the
    following code, we will call `product()` and create an instance of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Like all previous objects, we can see its internal data structure and its S3
    class for method dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, `laptop` is a list of class `product` as we created it. Since we
    haven''t defined any methods for this class, its behavior is no different from
    an ordinary list object. If we type it, it will be printed as a list with its
    customized class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we can implement the `print` method for this class. Here, we want the
    class and the data fields in it to be printed in a compact style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It is a convention that the `print` method returns the input object itself for
    further use. If the printing is customized, then we often use `invisible` to suppress
    repeated printing of the same object that the function returns. You may try returning `x`
    directly and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we type the variable again. The `print` method will be dispatched to `print.product`
    since it is already defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the elements in `laptop` just like extracting elements from a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create another instance and put the two instances into a list, `print.product`
    will still be called when the list is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is because when `products` is printed as a list, it calls `print` on each
    of the elements, which also causes method dispatch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an S3 class is much simpler than most other programming languages that
    require formal definition of classes. It is important to have sufficient checking
    on the arguments to ensure that the created object is internally consistent with
    what the class represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, without proper checking, we can create a product with negative
    and non-integer inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this, we need to add some checking conditions in the object-generating
    function, `product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is enhanced, in that `name` must be a single string, `price` must
    be a single positive number, and `inventory` must be a single non-negative number.
    With this function, we cannot create ridiculous products by mistake, and such
    errors can be found in an early stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to defining new classes, we can also define new generic functions.
    In the following code, we will define a new generic function called `value` and
    implement a method for `product` by measuring the value of the inventory of the
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For other classes, it calls `value.default` and stops. Now, `value` can be
    used with all instances of `product` we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic function also works with apply family functions by performing method
    dispatch for each element in the input vector or list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'One more question is once we create the object of a certain class, does that
    mean that we can no longer change it? No, we still can change it. In this case,
    we can modify an existing element of `laptop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a new element in `laptop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can take a look at it, and the changes are effective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: What's worse is that we can even remove an element by setting it to `NULL`.
    This is why the S3 system is considered to be loose. You can't make sure that
    the object of a certain type has a fixed set of data fields and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using an atomic vector as the underlying data structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we demonstrated an example of creating a new class
    from a list object. In fact, it is sometimes useful to create a new class of object
    from an atomic vector. In this section, I will show you a series of steps to create
    vectors with a percentage representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define a function, `percent`. This function simply checks whether
    the input is a numeric vector and alters its class to `percent`, which inherits
    from `numeric`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The inheritance here means that method dispatch first looks for methods of `percent`.
    If none is found, then it looks for methods of `numeric`. Therefore, the order
    of the class names matters. S3 inheritance will be covered in detail in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a percent vector from a numeric vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, there is no method implemented for `percent`. So, `pct` looks
    like an ordinary numeric vector with a customized class attribute. The purpose
    of this class is to show its values in percentage form, such as 25 percent instead
    of its original decimal representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal, we first implement `as.character` for the `percent` class
    by producing the correct string representation of the percentage form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can get the desired string representation of a given percent vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we need to implement `format` for `percent` by directly calling `as.character`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `format` has the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement `print` for `percent` by calling `format.percent` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we specify `quote = FALSE` when we print the formatted strings to
    make it look like numbers rather than strings. This is exactly the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that arithmetic operators such as `+` and `*` automatically preserve the
    class of the output vector. As a result, the output vector is still printed in
    percentage form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, other functions may not preserve the class of their input. For
    example, `sum`, `mean`, `max`, and `min` will drop the customized class and return
    a plain numeric vector instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure the percentage form is preserved when we perform these calculations,
    we need to implement these methods for the `percent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first method, `NextMethod("sum")` calls `sum` for numeric class, and
    the output numeric vector is wrapped with `percent` again. The same logic also
    applies to the implementation of the other three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, these functions return values in percentage form, too. However, if we
    combine a percent vector with other numeric values, the percent class will be
    gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same thing to `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, combining percent vectors with numeric values result in percent vectors
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'However, from the other side, when we subset the percent vector or extract
    a value from it, the percent class will be dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this, we need to implement `[` and `[[` for `percent` in exactly the
    same way. You might be surprised to see a method called `[.percent`, but it will
    indeed match the `percent` class when we use these operators on a percent vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, both subsetting and extracting preserve the percent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With all these methods implemented, we can place a percent vector as a column
    of a data frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The percentage form is correctly preserved as a column in the data frame.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding S3 inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The S3 system is loose. You only need to create a function in the form of `method.class`
    to implement a method for a generic function. You only need to supply a character
    vector with multiple elements to indicate the inheritance relationship along the
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, the class vector determines the order
    of matching classes in method dispatch. To demonstrate it, we will use a simple
    example in which we construct a number of classes with inheritance relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to model some vehicles such as a car, bus, and airplane. These
    vehicles have something in common. They all have name, speed, and position, and
    they can move. To model them, we can define a base class called `vehicle`, which
    stores the common parts. We also define `car`, `bus`, and `airplane` that inherit
    from `vehicle` but have customized behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a function to create the `vehicle` object, which is essentially
    an environment. We choose an environment over a list because we need its reference
    semantics, that is, we pass around the object, and modifying it will not cause
    a copy of the object. So, the object always refers to the same vehicle, no matter
    where it is passed around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `class(obj) <- c(class, "vehicle")` may look ambiguous because `class`
    is both a function argument and a basic function. In fact, `class(obj) <-` will
    look for the `class<-` function so that the usage does not cause ambiguity. The
    `Vehicle` function is a general creator of vehicle class objects with common data
    fields. The following function is specialized functions to create `car`, `bus`
    and `airplane` that inherit vehicle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'With the three preceding functions, we can create `car`, `bus`, and `airplane`
    objects. All inherit from the `vehicle` class. Now, we create an instance for
    each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will implement a common `print` method for `vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Since no `print.car`, `print.bus` or `print.airplane` is defined, typing those
    variables will print them with `print.vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A vehicle is a carrier designed to be driven and to move. Naturally, we define
    a generic function called `move`, which modifies the position of a vehicle to
    reflect a user-supplied movement in a three-dimensional space. Since different
    vehicles move in different ways with distinct limitations, we can further implement
    several `move` methods for the various classes of vehicle we just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will limit the movement that can happen to a car and a bus to two
    dimensions. Therefore, we will implement `move.bus` and `move.car` by checking
    the length of the `movement` vector, which is only allowed to be `2`. If the movement
    is valid, then, we would force the third dimension of `movement` to be `0` and
    then call `NextMethod("move")` to call `move.vehicle` with `vehicle` and the latest
    value of `movement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'An airplane can move in either two or three dimensions. Therefore, `move.airplane`
    can be flexible to accept both. If the `movement` vector is two dimensional, then
    the movement on the third dimension is regarded as zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'With `move` implemented for all three vehicles, we can test them with the three
    instances. First, let''s see if the following expression goes into an error if
    we want the car to move with a three-dimensional vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The method dispatch of the preceding function call finds `move.car` and stops
    for the invalid movement. The following code is a two-dimensional movement, which
    is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can move the airplane in two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also move it in three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that the position of `airplane` is accumulated because it is essentially
    an environment, so modifying `position` in `move.vehicle` does not cause a copy
    of it. Therefore, no matter where you pass it, there is only one instance of it.
    If you are not familiar with the reference semantics of environments, go through [Chapter
    8](ch08.html "Chapter 8. Inside R"), *Inside R*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with S4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced the S3 system. Unlike the object-oriented
    systems in most other programming languages, the S3 system is much less strict
    than a system in which classes are defined with a fixed structure and certain
    method dispatch as the program compiles. When we define an S3 class, almost nothing
    can be sure. We can not only add or remove methods of the class at any time but
    also insert or delete data elements from the object as we wish. In addition, S3
    only supports single dispatch, that is, methods are chosen according to the class
    of only one argument, mostly the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Then, R introduces a more formal and stricter object-oriented system, S4\. This
    system allows us to define formal classes with pre-specified definition and inheritance
    structure. It also supports multiple dispatch, that is, methods are chosen according
    to the classes of multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to define S4 classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Defining S4 classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike S3 classes, which are simply represented by character vectors, S4 classes
    require formal definition of classes and methods. To define an S4 class, we need
    to call `setClass` and supply a representation of the class members, which are
    called **slots**. The representation is specified by the name and class of each
    slot. In this section, we''ll redefine the product objects using an S4 class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the class is defined, we can get the slots from its class definition by
    `getSlots()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'S4 is stricter than S3, not only because S4 requires class definition, but
    also because R will ensure that the classes of the members that create a new instance
    are consistent with the class representation. Now, we will use `new()` to create
    a new instance of an S4 class and specify the values of the slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'It might surprise you that the preceding code produces an error. If you take
    a closer look at the class representation, you will find that `inventory` must
    be an integer. In other words, `100` is a numeric value, which is not of class `integer`.
    It requires `100L` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now, a new instance of `Product`, `laptop`, is created. It is printed as an
    object of class `Product`. The values of all slots are automatically printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an S4 object, we can still use `typeof()` and `class()` to get some type
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the type is `S4` instead of `list` or other data types, and the
    class is the name of the S4 class. The S4 object is also a first-class citizen
    in R because it has a checking function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike accessing a list or environment with `$`, we need to use `@` to access
    a slot of an S4 object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can call `slot()` to access a slot with its name as a string.
    This is equivalent to accessing an element of a list or environment with double
    brackets (`[[]]`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also modify an S4 object in the same way we modify a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we cannot supply to a slot something that is not consistent with the
    class representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither can we create a new slot just like adding a new element to a list because
    the structure of an S4 object is fixed to its class representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create another instance with the values of slots partially supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not specify `inventory`, so the resulting object, `toy`,
    takes an empty integer vector as `inventory`. If you think it is not a good default
    value, we can specify a prototype of the class so that each instance will be created
    from it as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding prototype, we set the default value of `price` to be the numeric
    missing value and inventory to be integer zero. Note that `NA` is logical and
    cannot be used here because it is not consistent with the class representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will recreate `toy` with the same code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `inventory` takes the default value `0L` from the prototype. However,
    what if we need more constraints on the input arguments? Although the classes
    of the arguments are checked, we can still supply values that are not meaningful
    as an instance of `Product`. For example, we can create a `bottle` class with
    negative inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The following code is a validation function that ensures that the slots of a
    `Product` object are meaningful. The validation function is somehow special because
    when there is no error about the input object, it should return `TRUE`. When there
    are errors, it should return a character vector that describe the errors. Therefore,
    it is best not to use `stop()` or `warning()` when a slot is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will validate the object by checking the length of each slot and whether
    they are missing values. Also, the price must be positive, and the inventory must
    be non-negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We write a long combination of values to make up the error messages. This works
    because `if (FALSE) expr` returns `NULL` and `c(x, NULL)` returns `x`. At last,
    if no error message is produced, the function returns `TRUE`, otherwise it returns
    the error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function defined, we can directly use it to validate `bottle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation results in an error message as supposed. Now, we need to make
    the class perform validation each time an instance is being created. We only need
    to specify the `validity` argument when we use `setClass` for `Product` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, each time we try to create an instance of the `Product` class, the supplied
    values are automatically checked. Even the prototype is checked. Here are two
    cases that fail the validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code fails because the default value of `price` is `NA_real_`
    in the prototype. In the validation, however, the price cannot be a missing value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This fails because `inventory` must be a non-negative integer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the validation only occurs when we create a new instance of an S4
    class. Once the object is created, however, the validation does not happen anymore.
    In other words, we can still set a slot to a bad value unless we explicitly validate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding S4 inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The S3 system is loose and flexible. Each S3 object of the same class may have
    different members. For S4, however, this cannot happen, that is, we cannot arbitrarily
    add a slot that is not in the class definition when we create a new instance of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we cannot put a `volume` slot when we create a new instance of `Product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can only do this through proper inheritance. We need to create
    a new class that contains (or inherits from) the original class. In this case,
    we can define a `Container` class that inherits from `Product` and has a new numeric
    slot named `volume`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Container` inherits from `Product`, any instance of `Container` has
    all the slots of `Product`. We can use `getSlots()` to view them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an instance of `Container` that has a `volume` slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the validation of `Product` still functions when we create an instance
    of `Container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the checking ensures it is a valid `Product` class, but it still
    does not check anything about `Container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we defined a validation function for `Product`, we can define another
    for `Container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will redefine `Container` with this validation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we don''t need to call `validate_product` in `validate_container`
    because both validation functions will be called in turn to make sure all classes
    in the inheritance chain are properly checked with their validation functions.
    You may add some text-printing code to the validating functions to confirm that `validate_product`
    is always called before `validate_container` when we create an instance of `Container`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Defining S4 generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, we saw that S4 is much more formal than S3 because
    the S4 class requires a class definition. Likewise, S4 generic functions are more
    formal too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example where we define a series of S4 classes with a simple hierarchy
    of inheritance relationships. The example is about shapes. First, `Shape` is a
    root class. Both `Polygon` and `Circle` inherit from `Shape`, while `Triangle`
    and `Rectangle` inherit from `Polygon`. The inheritance structure of these shapes
    is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining S4 generic functions](img/image_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each class except `Shape` has some necessary slots to describe itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'With these classes defined, we can set up a generic function to calculate the
    area of a `Shape` object. To do this, we need to call `setGeneric()` upon `area`
    and supply a function that calls `standardGeneric("area")` to make `area` a generic
    function and ready for S4 method dispatch. The `valueClass` is used to ensure
    that the return value of each method must be of class `numeric`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the generic function is set up, we go on to implement different methods
    for different kinds of shapes. For `Triangle`, we use Heron''s formula ([https://en.wikipedia.org/wiki/Heron''s_formula](https://en.wikipedia.org/wiki/Heron''s_formula))
    to calculate its area, given the lengths of the three sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'For `Rectangle` and `Circle`, it is easy to write out the area formula for
    each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an instance of `Triangle` and see whether `area()` dispatches
    to the correct method and returns the correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'We also create an instance of `Circle` and see whether method dispatch works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Both answers are correct. The `area()` function just works like an S3 generic
    function that performs method dispatch according to the class of the input object.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding multiple dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An S4 generic function is more flexible because it also supports multiple dispatch,
    that is, it can perform method dispatch according to the classes of multiple arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will define another family of S4 classes: `Object` with a numeric `height`.
    Both `Cylinder` and `Cone` inherit from `Object`. Later, we will use multiple
    dispatch to calculate the volume of a certain type of geometric object with a
    certain shape of the bottom surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will define a new generic function named `volume`. As its name suggests,
    this function is used to calculate the volume of an object that is described by
    the shape of the bottom surface and the form of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we will implement two cases: one is for a rectangle-shaped
    cylinder and the other is for a rectangle-shaped cone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all existing methods for `volume` require two arguments. Therefore,
    the method dispatch happens with both arguments, that is, it requires the classes
    of both input objects to match to choose the correct method. Now, we will test `volume`
    with an instance of `Rectagle` and an instance of `Cylinder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a relationship holds for a cylinder and a cone with the same height and
    the shape of bottom surface, the volume of the cylinder is three times that of
    the cone. To simplify the implementation of `volume` methods, we can directly
    put `Shape` in the method signature and call `area()` of the shape and directly
    use its area in the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `volume` is automatically applicable to `Circle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'To make `volume` easier to use, we can also define a method that takes an instance
    of `Shape` and a numeric value as the height of the cylinder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can directly use numeric values in calculating the volume of the cylinder
    given its shape and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can simplify the notation by implementing a method of `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can calculate the volume by simply multiplying the shape and the object
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Note that an S4 object is not a list or environment, but it has copy-on-modify
    semantics. In this sense, when the value of a slot of an S4 object is modified
    by `<-` in a function, it behaves more like a list, that is, the S4 object is
    copied in the function and the original object is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code, we will define a function that tries to
    lengthen `Object` by multiplying its height with a numeric factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this function on `cylinder`, which we previously created, its
    height is not changed at all. Instead, it is copied inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Working with the reference class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also a class system that has reference semantics. It is more like the
    class system in other object-oriented programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to define a reference class (**RC**), we supply a class definition to `setRefClass()`.
    Unlike the S4 class system where we use `new()` to create an instance, `setRefClass()`
    returns an instance generator. For example, we define a class named `Vehicle`,
    which has two fields: a numeric position and a numeric distance. We store the
    instance generator to a variable named `Vehicle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an instance, we use `Vehicle$new` to create new instances of the `Vehicle`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike S4, the fields of RC are not slots, so we can use `$` to access them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Each instance we create with `Vehicle$new` is an object of reference semantics.
    It behaves like a combination of S4 object and environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will create a function that modifies the fields in
    a `Vehicle` object. More specifically, we define `move` that modifies `position`
    in relative terms, and all movements are accumulated to `distance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will call `move` with `car`, and the instance we created is modified
    rather than copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Since RC itself is a class system more like ordinary object-oriented system,
    a better way to do this is to define its own methods of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike S3 and S4 systems where methods are stored in the environment, RC directly
    include its methods. Therefore, we can directly call the method inside an instance.
    Note that to modify the value of a field in a method, we need to use `<<-` instead
    of `<-`. The following code is a simple test to check whether the method works
    and whether the reference object is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding examples, we can see that RC looks more like the objects
    in C++ and Java. For more detailed introduction, read `?ReferenceClasses`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with R6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enhanced version of RC is R6, a package that implements a more efficient
    reference class that supports public and private fields and methods, and some
    other powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following code to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The R6 class allows us to define classes that are even more like popular object-oriented
    programming languages. The following code is an example where we define the `Vehicle`
    class. It has some public fields and methods for users and some private fields
    and methods for internal use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'From the user side, we can only access the public fields and methods. Only
    the class methods have access to the private fields and methods. Although the
    vehicle has a position, we don''t want the user to modify its value. Therefore,
    we put it in the private part and expose its value through `get_position()` so
    that it is hard for users to modify the position from outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'When `car` is printed, all public and private fields and methods are displayed.
    Then, we will call the `move()` method, and we can find the position is changed
    with `get_position()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the inheritance of R6 class, we define a new class named `MeteredVehicle`
    that records the sum of distance it moves in history. To define the class, we
    need to add a private field `distance`, a public override of `move` that first
    calls `super$move()` to move the vehicle to get the right position and then accumulates
    the distance resulted from the movement in absolute terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can do some experiments with `MeteredVehicle`. In the following code,
    we will create a `bus`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let `bus` move `10` units forward, and then, the position is changed
    and the distance is accumulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let `bus` move `5` units backward. The position is closer to the origin,
    while the distance that sums up all movements becomes greater:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R6 also supports some other powerful features. For more details, read its vignettes
    at [https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html](https://cran.r-project.org/web/packages/R6/vignettes/Introduction.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the basic concepts of object-oriented programming:
    class and methods and how they are connected by generic functions in R through
    method dispatch. You learned how to create S3, S4, RC, and R6 classes and methods.
    These systems share similar ideas but are distinct in implementation and usage.
    Hadley Wickham gives some nice suggestions in picking a system ([http://adv-r.had.co.nz/OO-essentials.html#picking-a-system](http://adv-r.had.co.nz/OO-essentials.html#picking-a-system)).'
  prefs: []
  type: TYPE_NORMAL
- en: After getting familiar with R's most important features, we will discuss more
    practical topics in the subsequent chapters. In the next chapter, you will learn
    about the packages and techniques used to access popular databases. You will gain
    necessary knowledge and techniques to connect R to relational databases such as
    SQLite and MySQL as well as the upcoming non-relational databases such as MongoDB
    and Redis.
  prefs: []
  type: TYPE_NORMAL
