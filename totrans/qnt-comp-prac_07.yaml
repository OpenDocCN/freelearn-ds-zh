- en: '*Chapter 7*: Simulating Quantum Computers with Aer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have mainly been running our quantum programs on our local QASM simulator,
    which out of the box simulates a **universal error-correcting quantum computer**—the
    type of machine that the quantum computing world expects, or at least hopes, will
    be a reality within the next few years.
  prefs: []
  type: TYPE_NORMAL
- en: But these amazing machines are not available yet, so in this chapter, we will
    explore quantum simulators both locally with **Qiskit Aer** and in the cloud with
    **IBM Quantum®** simulators. We will understand how to run your quantum circuits
    on these simulated perfect backends.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can also use Qiskit Aer to simulate today's **Noisy Intermediate-Scale
    Quantum** (**NISQ**) computers by setting up noise profiles for the simulator
    to emulate the real IBM Quantum® hardware, with gate errors and noise. So, we
    will take a look at that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also look at two other local simulator types and what you can use them
    for: the **unitary simulator** and the **state vector simulator**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the usage of quantum simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the Qiskit Aer simulator with an IBM quantum computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding noise profiles of IBM Quantum® backends to local simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding your circuits by using the unitary simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running diagnostics with the state vector simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of the chapter is to get equipped with the tools to use the simulators
    when you develop and test your quantum programs so that you do not have to wait
    in line for your IBM Quantum® backends to run your tests. We will start by exploring
    the `qasm_simulator` backend, and then take a look at the unitary and state vector
    simulators.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the usage of quantum simulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **quantum computer simulator** is a software program that simulates the quantum
    mechanical behavior of a real quantum computer. Simulators are useful for testing
    your quantum circuits in a local environment before you run them on the IBM Quantum®
    backends in the cloud. You can also use cloud-based simulators to test larger
    quantum circuits that might not yet be possible to run on actual quantum computers
    or just take too long to run on your local simulator.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will take a quick tour to compare the available Qiskit® simulators—both
    local on **Qiskit Aer** and in the cloud on **IBM Quantum®**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have everything working from [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we start by importing the classes and we need. We import both `Aer`
    and `IBMQ`, as we will work with simulators both locally and remotely. If needed,
    we also load our account and get our providers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the `backends()` method to take a look at the available local
    Qiskit Aer backends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code should give the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The local Aer backends; all simulators'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.1_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.1 – The local Aer backends; all simulators
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can store the configuration details for these simulators in a `simulators`
    list for further processing. Use the `backend.configuration()` method to pull
    out this information and loop through the available backends, appending the data
    for each to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For completeness, we''ll add the configuration details for the IBM Quantum®
    simulator by appending that information to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display the raw simulator configuration details. Let''s cycle through the `simulators`
    list to print out and look at the available configuration details for our simulators:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code should be similar to the following output for each simulator:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A heap of simulator configuration details'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.2_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.2 – A heap of simulator configuration details
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This raw printout will produce a slew of information to wade through. In the
    next step, we will sort out and display a few common parameters for comparison.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compare the simulators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, there is an awful lot of information for each simulator. To make a comparison,
    let''s grab a few parameters of interest and list them for each simulator. For
    our purposes, the following parameters might be interesting:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ibmq_qasm_simulator` details, you will see that this non-local IBM Quantum®
    simulator doesn''t have a description:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.3 – ibmq_qasm_simulator has no description'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.3_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – ibmq_qasm_simulator has no description
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, we add our own description for completeness by using an `if`/`elif`
    command for the `local` attribute for each simulator, adding our own description
    if `local==False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous sample code will result in something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – A list of selected simulator properties](img/Figure_7.4_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – A list of selected simulator properties
  prefs: []
  type: TYPE_NORMAL
- en: 'From this list, we can get a high-level overview of what the simulators can
    do, and what the specific criteria for each are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qasm_simulator`: This simulator lets you run your quantum programs and returns
    results as if you were running on a perfect quantum computer, with no errors and
    no noise, but with the option to add errors and a noise profile to simulate a
    *NISQ backend*. This simulator is written in C++ and runs locally on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '`statevector_simulator`: With this simulator, you can simulate the state vector
    for your qubits at any point in your circuit. This simulator is written in C++
    and runs locally on your machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unitary_simulator`: With the unitary simulator, you can compute the unitary
    matrix for your circuit. This simulator is implemented as a local Python simulator.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pulse_simulator`: A pulse-based Hamiltonian simulator for Pulse Qobj files.
    With this simulator, you can test interacting with the backend qubits directly
    using pulse-based programming that bypasses the standard gates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ibmq_qasm_simulator`: This is the only non-local simulator in the group. It
    works much like the local `qasm_simulator` simulator but with higher performance.'
  prefs: []
  type: TYPE_NORMAL
- en: We now know what simulators are available for us to work with, and we will explore
    them further in this chapter. The only simulator we will not touch is the `pulse_simulator`
    as using this simulator is beyond the scope of this book. If you are interested,
    do take a look at the *Get to the heart of real quantum hardware* link at the
    end of the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the performance data for the two QASM simulators—**Number of
    qubits** and **Max shots**. They both let you play with around *30 qubits* and
    run many thousands of shots with each run. So, what is the difference?
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind when running the simulators is that they are simulating
    quantum computers—the very computers that we expect to beat classical computers
    at complex problems going forward. This essentially means that simulating quantum
    computers on a classical computer like yours gets roughly twice as complicated
    with each added qubit.
  prefs: []
  type: TYPE_NORMAL
- en: For the online `ibmq_qasm_simulator` simulator, this doesn't necessarily pose
    a big problem as it is running on an IBM POWER9™ server, which is a fairly massive
    piece of hardware. You can throw seriously sized quantum programs, up to *32 qubits*,
    at it with no problems.
  prefs: []
  type: TYPE_NORMAL
- en: Your own hardware, on the other hand, is a different matter. The performance
    of the local `qasm_simulator` simulator will depend on the hardware you run it
    on. When you start to feel a lag and slowness on your local machine, it might
    be time for the online `ibmq_qasm_simulator` simulator.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*An Open High-Performance Simulator for Quantum Circuits, IBM Research Blog*,
    May 1, 2018: [https://www.ibm.com/blogs/research/2018/05/quantum-circuits/](https://www.ibm.com/blogs/research/2018/05/quantum-circuits/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Get to the heart of real quantum hardware, IBM Research Blog*, December 12,
    2019: [https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/](https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IBM Power systems*: [https://www.ibm.com/it-infrastructure/power](https://www.ibm.com/it-infrastructure/power)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the Qiskit Aer simulator with an IBM quantum computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a long quantum circuit that *swaps* a ![](img/Formula_07_001.png)
    state between two qubits. You will see that the circuit provides perfect results
    on your local Qiskit Aer simulator but not quite so perfect results on an actual
    IBM Quantum® machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the code, stored in the `ch7_r2_ootb.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, start by importing the required classes and methods and load your
    account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select the number of SWAP gates to include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now build a quantum circuit with the selected number of SWAP gates in a
    row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the circuit on the `qasm_simulator` and get the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result is displayed with a prompt to run the same circuit on an IBM Quantum®
    backend. Take a break here and read on.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run this quantum circuit on a simulator, it simulates perfectly and
    we get a perfect 100% result of the expected outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you follow along in the following circuit, you will see that we first use
    an X gate to set qubit **q0** to ![](img/Formula_02_029.png), and then we swap
    qubits **q0** and **q1** 10 times. What we expect to end up with is **q0** in
    ![](img/Formula_07_003.png) and **q1** in ![](img/Formula_07_004.png), or, in
    two-qubit notation, ![](img/Formula_07_005.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – A quantum circuit with 10 SWAP gates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.5_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – A quantum circuit with 10 SWAP gates
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note the *barrier gates* here. These are to instruct the Qiskit® transpiler
    to not transpile across the barriers, and not simplify the circuit by just removing
    the consecutive SWAP gates as they negate each other. For a quick reminder, refer
    to the *Tossing a quantum coin* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the program for 10 SWAP gates, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is seen numerically and in the following bar diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum
    computer: 01'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.6_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum computer:
    01'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the program ran perfectly and that we swapped the initial ![](img/Formula_07_006.png)
    qubit back and forth 10 times to end up with the qubits back where they started,
    in ![](img/Formula_07_007.png). There were no errors.
  prefs: []
  type: TYPE_NORMAL
- en: In a future **universal error-correcting quantum computer**, you will be able
    to run long quantum circuits like this with perfectly consistent error-corrected
    logical qubits throughout your calculations. By default, a Qiskit Aer simulator
    emulates an error-free universal quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you run the same program on today's **NISQ** hardware, errors
    start to pile up as your quantum circuits grow in size and execution time. To
    check this out, you can now press *Enter* and run the circuit on an IBM Quantum®
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now import the least-busy backend with five qubits, and run the same circuit
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code might give the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is seen numerically and in the bar diagram that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results
    other than the expected 01](img/Figure_7.7_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results
    other than the expected 01
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the crystal-clear result of the QASM simulator turned a little
    murky when run on one of the IBM Quantum® machines. You will most likely still
    get a prominent peak for the correct result (01), but also a lot of wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might think that 10 SWAP gates would be a fairly small example of a quantum
    circuit and that we shouldn't see errors like these in a circuit that size. What
    you have to keep in mind, though, is that the relatively simple logical circuit
    that you build will get transpiled into a circuit that can be run using just the
    basis gates that are available to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following `transpile` example to print the basis gates for the backend,
    and check the gate depth for the SWAP circuit before and after transpiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should give the following result on an IBM Quantum® five-qubit
    machine such as `ibmq_vigo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like](img/Figure_7.8_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code sample should give an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you run on a real quantum computer, noise and gate errors are introduced
    for each gate. As you can see in the previous figure, a single SWAP gate, when
    transpiled, might turn into three successive CX gates, and adding 10 of these
    in a row results in 30 CX gates. This makes for some potential big errors. Note
    that the number of transpiled gates depends on the selected backend and might
    be larger than the 30 in this example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Quantum Computing in the NISQ era and beyond* by John Preskill from the Institute
    for Quantum Information and Matter and the Walter Burke Institute for Theoretical
    Physics, California Institute of Technology, Pasadena, CA, 91125, USA: [https://quantum-journal.org/papers/q-2018-08-06-79/](https://quantum-journal.org/papers/q-2018-08-06-79/).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding noise profiles of IBM Quantum® backends to local simulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we find the noise data for the IBM Quantum® backends to build
    a noise profile that we can then add to our simulator when we run it. This will
    make the simulator behave like a *real NISQ backend*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of the available backends and select one to simulate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will get the noise profile of one of the IBM Quantum® backends and use it
    with our simulators. First, we use the `select_backend()` function to list the
    backends and make the selection:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code might result in the following listing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.9 – List of available IBM Quantum® backends'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.9 – List of available IBM Quantum® backends
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we will also run the quantum circuit on the backend, you should pick one
    with a reasonably short queue to avoid having to wait excessively for the results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get the noise profile. The noise model can be extracted from the backend by
    using the `NoiseModel.from_backend(backend)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The noise model will look different depending on the backend that you selected.
    A sample model is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Noise model for an IBM Quantum® backend'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.10 – Noise model for an IBM Quantum® backend
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now run the simulator with the noise model and other parameters to have
    the NISQ characteristics of the selected backend applied to the simulator calculations
    and make it behave like an actual physical backend and not a perfect simulator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build a GHZ state circuit and run it on four different backends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `execute_circuit()` function to run on the backends with all the variations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In Python, we start by getting the basis gates and a coupling map for the backend:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then build a GHZ state quantum circuit, execute it on a simulator, and get
    the counts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use the noise model and coupling map to execute a noisy simulation
    on both the local and the IBM Quantum® QASM simulator and get the counts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we execute the job on the IBM Quantum® backend and get the counts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step is to display the collected results for all runs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we walk through these four executions of the GHZ circuit, we will see how
    the initial perfect simulation, which provides an output of only ![](img/Formula_07_008.png)
    or ![](img/Formula_07_009.png) with ~50% chance, gets *contaminated* with errors;
    we get outputs in all possible states.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the final output, we compare all the executions with the final execution
    on the selected backend. What you might see when running the program would look
    something like the following set of screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we run on the simulator without noise and you get the following output:![Figure
    7.11 – First, ideal run on the local simulator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.11_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.11 – First, ideal run on the local simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we add the noise model and run it again:![Figure 7.12 – Adding the noise
    model to the local simulator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.12_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.12 – Adding the noise model to the local simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we can now see, we no longer get the nice, clean, and perfect quantum computer
    result but rather a result that is much closer to what you would get if you run
    the circuit on an actual IBM Quantum® backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We test one more time by running with the noise model on the online IBM Quantum®
    QASM simulator:![Figure 7.13 – Adding the noise model to the IBM Quantum® simulator](img/Figure_7.13_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 7.13 – Adding the noise model to the IBM Quantum® simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we run the circuit one final time, now on the backend that we selected
    at the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Running the circuit on the IBM Quantum® backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.14_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – Running the circuit on the IBM Quantum® backend
  prefs: []
  type: TYPE_NORMAL
- en: The result of this run should be similar to our simulated runs based on the
    noise model we derived from the actual IBM Quantum® backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now merge all the results into a single diagram for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.15_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend
  prefs: []
  type: TYPE_NORMAL
- en: In the final output, you can see that the simulators with the added noise model
    behave, at least statistically, like the IBM Quantum® backend on which they are
    modeled. As you can see, for the **Baseline** Aer simulation, we only get the
    expected ![](img/Formula_07_008.png) and ![](img/Formula_07_009.png) results for
    a GHZ state, but for all the other runs, we also get *noise* in the form of results
    such as ![](img/Formula_07_059.png) and ![](img/Formula_07_060.png).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments*, arXiv,
    IBM Research et.al., September 11, 2018: [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding your circuits by using the unitary simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it turns out, any valid quantum circuit that consists only of gates can be
    translated into a unitary matrix that describes the expected outcome for each
    possible state vector input. As you have seen in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, each quantum gate is in itself a **unitary
    matrix**, and the combination of the unitaries that make up the complete quantum
    circuit can in itself be described as a **unitary**.
  prefs: []
  type: TYPE_NORMAL
- en: Qiskit® lets you use the Qiskit Aer `unitary_simulator` simulator to return
    the unitary matrix that corresponds with your quantum circuit. You run the job
    just like you would for `qasm_simulator` jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `unitary_simulator`, you only run the circuit once. We can then
    use the `get_unitary(qc)` method on the returned results to see the unitary as
    a matrix for a circuit, such as this one-qubit superposition circuit using a Hadamard
    gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Quantum circuit with one Hadamard gate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.16_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – Quantum circuit with one Hadamard gate
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit corresponds to the following unitary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a cleaner printout, this would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_07_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might recognize this as the *Hadamard gate* matrix, which is just what it
    is. Just like this, you can use the unitary simulator to return the unitary matrixes
    for any valid quantum circuit. That is what we will explore in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a few simple quantum circuits and run them through a unitary
    simulator to get the unitary matrix. We then compare the Qiskit® unitary with
    the theoretical unitary for the gate combination that is represented by the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we run the circuit on the `qasm` simulator and compare the result with
    a calculation of the input qubit state vectors, **[1,0]** (for one qubit) and
    **[1,0,0,0]** (for two qubits), which represent all qubits starting in the state
    ![](img/Formula_07_0041.png).
  prefs: []
  type: TYPE_NORMAL
- en: The script includes a set of functions that we define to control the creation
    of circuits and other calculations that need to be done.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we use the `circuits()` function to create three basic quantum
    circuits and store them in a list for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the script, we are also using two functions that we create ourselves to
    process the unitary information: `show_unitary()` and `calc_unitary()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The input and function calls are controlled by the `main` loop at the end of
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your Python environment, run `ch7_r4_unitary.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you first launch the script, you get an input menu:![Figure 7.17 – Input
    menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.17_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.17 – Input menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter a number to select the circuit to run with. Options **1**–**3** are predefined
    in the script, while option **4** lets you input QASM code from IBM Quantum Experience®
    to test, much like we did in the *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Important: No measurement instructions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you include measurement instructions with your quantum circuit, you must
    strip these out before you submit it as input. If the code includes measurement
    circuits, the simulator will crash with an Aer error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After you select the circuit to explore, the program creates the circuits we
    need, and return them as a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now send the circuit that we selected to print the unitary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `show_unitary()`, we set the backend to `unitary_simulator` and run the
    circuit. The returned unitary is retrieved from the execution results and printed
    as a matrix:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, the unitary is used to calculate the predicted outcome for the circuit
    and the circuit is run on `qasm_simulator` for comparison.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `calc_unitary()` function, we use the returned unitary as input together
    with the quantum circuit. We then create a state vector for the number of qubits
    specified by the circuit and use `qasm_simulator` to compare the calculated results
    with the simulated results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All in all, if we run the script with input **1**, for *one-qubit superposition*,
    we will get a result that is similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.18 – One-qubit superposition output](img/Figure_7.18_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 7.18 – One-qubit superposition output
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the one-qubit superposition, we will create a simple quantum circuit with
    just a Hadamard gate. The unitary for this circuit is as follows:![](img/Formula_07_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calculated outcomes correspond nicely with the returned counts from running
    the circuit on the QASM simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, test options **2** and **3** to see what the unitaries look like for slightly
    more complicated circuits. When you feel that you have a good grasp of what is
    going on, take a look at the next recipe to import any circuit as a QASM string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running diagnostics with the state vector simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore the state vector simulator and see how you can
    use it to run diagnostics on your circuits to see how your qubits are behaving.
    The state vector simulator is not a quantum computer simulator per se, but a tool
    that runs through your quantum circuit with one shot and returns the qubit state
    vector that results. As these are simulators, you can actually use them to do
    diagnostic tests of your circuits without disturbing them and breaking the quantum
    state.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we have used the state vector simulator before, when displaying
    the qubits as **Bloch spheres**, but we did not go into any great detail at that
    point. Using Bloch sphere visualization works well with single or multiple qubit
    visualization when each qubit has a definite simple state that can be projected
    on a Bloch sphere.
  prefs: []
  type: TYPE_NORMAL
- en: There is a different output—actually, several—that we will touch on. Each of
    these lets you present the state of your qubits at a specific point in your circuit,
    before measuring.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s what we will work with. The state vector simulator returns a state
    vector, much like the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a qubit in superposition: `[0.707+0.j 0.707+0.j]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a Bell-state entangled qubit pair: `[0.707+0.j 0\. +0.j 0\. +0.j 0.707+0.j]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Written out in standard matrix form, these correspond to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qubit in superposition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_07_018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An entangled qubit pair:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_07_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can try displaying these using the `plot_bloch_multivector()` method. This
    visualization lets you observe how each individual qubit changes as the circuit
    progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Single qubit in state'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.19_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – Single qubit in state ![](img/Formula_07_020.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'This works fine as long as the qubits can be expressed individually. For entangled
    qubits, this visualization method no longer works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Entangled qubit pair in state](img/Figure_7.20_B14436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Entangled qubit pair in state ![](img/Formula_07_021.png)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Bloch spheres are not a good tool for entangled visualization,
    where the qubits cannot be described individually, but only as a combined entity.
    For more complex visualizations like these, we can use the `plot_state_qsphere()`
    method instead. The Q-sphere visualization is unique to Qiskit® and displays the
    quantum state as one or more vectors on a Q-sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Q-sphere displays a circle (for single-qubit states) or a sphere (for multiple-qubit
    states), with one or more vectors that represent the state. The relative size
    of the vector and tip shows the probability of measuring the indicated state;
    for a one-qubit Q-sphere, the north pole represents the ground state, ![](img/Formula_07_022.png),
    and the south pole the excited state, ![](img/Formula_07_0031.png), and the color
    indicates the phase angle of the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Single qubit in state  with a 100% probability of measuring
    0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.21_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – Single qubit in state ![](img/Formula_07_024.png) with a 100%
    probability of measuring 0
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the one-qubit example indicates that the probability of measuring
    the state ![](img/Formula_07_025.png) is 1 (vector pointing up), and the phase
    angle is 0\. You can use the Q-sphere to visualize the entangled qubit pair that
    we could not visualize with the Bloch sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Entangled qubit pair in state , with'
  prefs: []
  type: TYPE_NORMAL
- en: a 50% probability of measuring either 0 or 1
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.22_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Entangled qubit pair in state ![](img/Formula_07_026.png), with
    a 50% probability of measuring either 0 or 1
  prefs: []
  type: TYPE_NORMAL
- en: 'In the entangled qubit example, there are two possible outcomes with equal
    probability: ![](img/Formula_07_027.png) (vector pointing up) and ![](img/Formula_07_028.png)
    (vector pointing down), both with phase 0\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that for the two-qubit example, you also see an equator for the sphere.
    The reason for the equator is the two additional possible outcomes: ![](img/Formula_07_031.png)
    and ![](img/Formula_07_030.png) for a two-qubit system. In this case, the results
    occupy two opposite nodes along the equator: ![](img/Formula_07_031.png) on the
    left extreme and ![](img/Formula_07_032.png) on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Entangled qubit pair in state , with an'
  prefs: []
  type: TYPE_NORMAL
- en: equal 50% probability of measuring 01 and 10
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.23_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – Entangled qubit pair in state ![](img/Formula_07_033.png), with
    an equal 50% probability of measuring 01 and 10
  prefs: []
  type: TYPE_NORMAL
- en: As we will see, if you add more qubits, the Q-sphere will come equipped with
    additional latitude lines like these, each representing states with equal **Hamming**
    values, or the number of qubits in state ![](img/Formula_07_034.png). For example,
    a three-qubit Q-sphere will have two latitude lines, each with three possible
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three qubits in individual superposition are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three-qubit superposition state vector: `[0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j
    0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three-qubit superposition in standard matrix form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_07_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following outcomes will be displayed on the Q-sphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '**North pole**: ![](img/Formula_07_036.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First latitude line**: ![](img/Formula_07_037.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Second latitude line**: ![](img/Formula_07_038.png)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**South pole**: ![](img/Formula_07_039.png):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Example of a three-qubit Q-sphere with nodes for'
  prefs: []
  type: TYPE_NORMAL
- en: equal probability (  , or 12.5%) of all the outcomes
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.24_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.24 – Example of a three-qubit Q-sphere with nodes for equal probability
    ( ![](img/Formula_07_040.png) , or 12.5%) of all the outcomes
  prefs: []
  type: TYPE_NORMAL
- en: Alright, with that under our belt, let's dive straight in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, we will set up a quantum circuit with either simple superpositions
    on all qubits, or with entanglement between all the qubits. As we build the circuit,
    we will do a state vector measurement after each gate, storing the results in
    a list. We will then print the returned state vectors and plot them on Bloch spheres
    and Q-spheres to illustrate how the qubit moves around as the circuit is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the number of qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this first step, we set the number of qubits, and then select to build a
    superposition circuit or a circuit with entanglement by using `s` or `e` as input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Selecting the number of qubits and the type of circuit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_7.25_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The state vector simulator can be selected by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that simulator chosen, when you execute a quantum circuit, the simulator
    runs through the circuit one time, one shot, and returns the calculated state
    vector of your qubits. The outcome for a two-qubit circuit should look like this:![Figure
    7.26 – Two-qubit circuit as Bloch spheres and a Q-sphere
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.26_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, with an empty two-qubit circuit, we expect the measurement
    result 00 with 100% certainty, which we can see from the state vector:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Formula_07_044.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can also see both qubits pointing to ![](img/Formula_07_045.png), and the
    Q-sphere vector pointing to ![](img/Formula_07_046.png).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, hit **Return** to add a first Hadamard gate to one of the qubits and run
    the display function again:![Figure 7.27 – Two qubits, with one in superposition,
    as Bloch spheres and a Q-sphere
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.27_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.27 – Two qubits, with one in superposition, as Bloch spheres and a
    Q-sphere
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we see the effect on the state vector when the second qubit is set in superposition
    with the Bloch vector pointing to the ![](img/Formula_07_041.png) state. Looking
    at the Q-sphere, we now see two possible outcomes, each with equal probability:
    ![](img/Formula_07_042.png) and ![](img/Formula_07_043.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, press **Return** again to add the second Hadamard, and display it again:![Figure
    7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_7.28_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now walked ourselves through our superposition step by step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the final step, you can see that the two-qubit Bloch vectors are both in
    the ![](img/Formula_07_047.png) state for a ![](img/Formula_07_048.png) superposition.
    The state vector is now as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is reflected in the final outcome, where the following states all have
    the same 25%, probability, as displayed by the Q-sphere: ![](img/Formula_07_050.png).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can now run the circuit again with two qubits, but select **e** for entanglement
    to see how the qubits behave step by step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, try running the program with `sp` or `ep` as input, to include a phase
    angle to your superposition or entanglement circuit by adding a T-gate to the
    final qubit. As you will recall from [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, this will introduce a ![](img/Formula_07_051.png)
    phase to that qubit, which will be reflected in the Q-sphere output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.29 – A  phase added to qubit 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.29_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.29 – A ![](img/Formula_07_052.png) phase added to qubit 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you can see the expected measurement results of ![](img/Formula_07_053.png)
    with 25% certainty, with the added twist that the ![](img/Formula_07_054.png)
    and ![](img/Formula_07_055.png) states have the phase ![](img/Formula_07_056.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – The  results now have a  phase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.30_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.30 – The ![](img/Formula_07_057.png) results now have a ![](img/Formula_07_058.png)
    phase
  prefs: []
  type: TYPE_NORMAL
- en: Note how there is no change to the counts output; adding a phase to a qubit
    does not change the probability of the outcomes. The phase, however, can be very
    useful for other, more complex quantum algorithms, as we will see in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover's Search Algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, you might have a feeling of déjà vu; you have seen this before,
    and you are right. Flip back to the *Building quantum scores with Circuit Composer*
    recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063), *IBM
    Quantum Experience® – Quantum Drag and Drop*, and take a look at the **Inspect**
    feature that we discussed there. What we have discussed in this recipe is the
    corresponding way to inspect your circuits in Qiskit®.
  prefs: []
  type: TYPE_NORMAL
- en: This has been a whirlwind tour of the simulators that are included with Qiskit®.
    We have touched on the most basic examples of how to use them when coding your
    quantum programs but have just barely scratched the surface of all of the features
    that are available to you. Go explore, take them for a spin, and see how they
    can be used as tools when developing your real quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
