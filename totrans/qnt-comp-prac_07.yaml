- en: '*Chapter 7*: Simulating Quantum Computers with Aer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用Aer模拟量子计算机'
- en: So far, we have mainly been running our quantum programs on our local QASM simulator,
    which out of the box simulates a **universal error-correcting quantum computer**—the
    type of machine that the quantum computing world expects, or at least hopes, will
    be a reality within the next few years.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要在我们的本地QASM模拟器上运行我们的量子程序，它默认模拟了一个**通用纠错量子计算机**——量子计算界期望或至少希望在未来几年内成为现实的机器类型。
- en: But these amazing machines are not available yet, so in this chapter, we will
    explore quantum simulators both locally with **Qiskit Aer** and in the cloud with
    **IBM Quantum®** simulators. We will understand how to run your quantum circuits
    on these simulated perfect backends.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些令人惊叹的机器目前还不可用，因此在本章中，我们将探索量子模拟器，无论是在本地使用**Qiskit Aer**还是在云端的**IBM Quantum®**模拟器。我们将了解如何在这些模拟的完美后端上运行您的量子电路。
- en: However, you can also use Qiskit Aer to simulate today's **Noisy Intermediate-Scale
    Quantum** (**NISQ**) computers by setting up noise profiles for the simulator
    to emulate the real IBM Quantum® hardware, with gate errors and noise. So, we
    will take a look at that as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您也可以通过为模拟器设置噪声配置文件来模拟今天的**有噪声的中规模量子**（**NISQ**）计算机，以模拟真实的IBM Quantum®硬件，包括门错误和噪声。因此，我们也将探讨这一点。
- en: 'We will also look at two other local simulator types and what you can use them
    for: the **unitary simulator** and the **state vector simulator**.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨两种其他本地模拟器类型及其用途：**幺正模拟器**和**状态向量模拟器**。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding the usage of quantum simulators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解量子模拟器的使用
- en: Comparing the Qiskit Aer simulator with an IBM quantum computer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较Qiskit Aer模拟器和IBM量子计算机
- en: Adding noise profiles of IBM Quantum® backends to local simulators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将IBM Quantum®后端的噪声配置文件添加到本地模拟器中
- en: Understanding your circuits by using the unitary simulator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用幺正模拟器理解您的电路
- en: Running diagnostics with the state vector simulator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态向量模拟器进行诊断
- en: The goal of the chapter is to get equipped with the tools to use the simulators
    when you develop and test your quantum programs so that you do not have to wait
    in line for your IBM Quantum® backends to run your tests. We will start by exploring
    the `qasm_simulator` backend, and then take a look at the unitary and state vector
    simulators.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是让您在开发和测试量子程序时能够使用模拟器，这样您就不必等待您的IBM Quantum®后端运行测试。我们将首先探索`qasm_simulator`后端，然后查看幺正和状态向量模拟器。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的量子程序可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter07)。
- en: Understanding the usage of quantum simulators
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解量子模拟器的使用
- en: A **quantum computer simulator** is a software program that simulates the quantum
    mechanical behavior of a real quantum computer. Simulators are useful for testing
    your quantum circuits in a local environment before you run them on the IBM Quantum®
    backends in the cloud. You can also use cloud-based simulators to test larger
    quantum circuits that might not yet be possible to run on actual quantum computers
    or just take too long to run on your local simulator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**量子计算机模拟器**是一种软件程序，它模拟真实量子计算机的量子力学行为。模拟器在您在云端的IBM Quantum®后端运行之前，在本地环境中测试您的量子电路非常有用。您还可以使用基于云的模拟器来测试可能还无法在实际量子计算机上运行或运行时间太长的较大量子电路。'
- en: In this recipe, we will take a quick tour to compare the available Qiskit® simulators—both
    local on **Qiskit Aer** and in the cloud on **IBM Quantum®**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将快速浏览可用的Qiskit®模拟器——无论是在本地的**Qiskit Aer**上还是在云端的**IBM Quantum®**上。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have everything working from [*Chapter 1*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021),
    *Preparing Your Environment*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您从[*第1章*](B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021)，“准备您的环境”中的一切都正常工作。
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r1_aer.py)。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s take a look at the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: 'As usual, we start by importing the classes and we need. We import both `Aer`
    and `IBMQ`, as we will work with simulators both locally and remotely. If needed,
    we also load our account and get our providers:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们首先导入所需的类。我们导入`Aer`和`IBMQ`，因为我们将在本地和远程使用模拟器。如果需要，我们也会加载我们的账户并获取我们的提供商：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we use the `backends()` method to take a look at the available local
    Qiskit Aer backends:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`backends()`方法查看可用的本地Qiskit Aer后端：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code should give the following result:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码应该给出以下结果：
- en: '![Figure 7.1 – The local Aer backends; all simulators'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.1 – 本地Aer后端；所有模拟器'
- en: '](img/Figure_7.1_B14436.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.1_B14436.jpg)'
- en: Figure 7.1 – The local Aer backends; all simulators
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1 – 本地Aer后端；所有模拟器
- en: 'We can store the configuration details for these simulators in a `simulators`
    list for further processing. Use the `backend.configuration()` method to pull
    out this information and loop through the available backends, appending the data
    for each to the list:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将这些模拟器的配置细节存储在`simulators`列表中，以供进一步处理。使用`backend.configuration()`方法提取这些信息，并遍历可用的后端，将每个的数据添加到列表中：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For completeness, we''ll add the configuration details for the IBM Quantum®
    simulator by appending that information to the list:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完整性，我们将通过将信息附加到列表中为IBM Quantum®模拟器添加配置细节：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Display the raw simulator configuration details. Let''s cycle through the `simulators`
    list to print out and look at the available configuration details for our simulators:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示原始模拟器配置细节。让我们遍历`simulators`列表，打印并查看我们模拟器的可用配置细节：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code should be similar to the following output for each simulator:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码应该类似于每个模拟器的以下输出：
- en: '![Figure 7.2 – A heap of simulator configuration details'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.2 – 模拟器配置细节的堆叠'
- en: '](img/Figure_7.2_B14436.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.2_B14436.jpg)'
- en: Figure 7.2 – A heap of simulator configuration details
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.2 – 模拟器配置细节的堆叠
- en: This raw printout will produce a slew of information to wade through. In the
    next step, we will sort out and display a few common parameters for comparison.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这原始的打印输出将产生大量需要处理的信息。在下一步中，我们将整理并显示一些用于比较的常见参数。
- en: Compare the simulators.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较模拟器。
- en: 'So, there is an awful lot of information for each simulator. To make a comparison,
    let''s grab a few parameters of interest and list them for each simulator. For
    our purposes, the following parameters might be interesting:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，每个模拟器都有大量的信息。为了进行比较，让我们抓取一些感兴趣的参数，并为每个模拟器列出它们。就我们的目的而言，以下参数可能很有趣：
- en: '`ibmq_qasm_simulator` details, you will see that this non-local IBM Quantum®
    simulator doesn''t have a description:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ibmq_qasm_simulator`的详细信息，你会看到这个非本地的IBM Quantum®模拟器没有描述：'
- en: '![Figure 7.3 – ibmq_qasm_simulator has no description'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – ibmq_qasm_simulator没有描述'
- en: '](img/Figure_7.3_B14436.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.3_B14436.jpg)'
- en: Figure 7.3 – ibmq_qasm_simulator has no description
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – ibmq_qasm_simulator没有描述
- en: 'In the code, we add our own description for completeness by using an `if`/`elif`
    command for the `local` attribute for each simulator, adding our own description
    if `local==False`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们为了完整性，使用`if`/`elif`命令为每个模拟器的`local`属性添加自己的描述，如果`local==False`则添加自己的描述：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous sample code will result in something similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码将产生以下类似的结果：
- en: '![Figure 7.4 – A list of selected simulator properties](img/Figure_7.4_B14436.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 选择模拟器属性列表](img/Figure_7.4_B14436.jpg)'
- en: Figure 7.4 – A list of selected simulator properties
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 选择模拟器属性列表
- en: 'From this list, we can get a high-level overview of what the simulators can
    do, and what the specific criteria for each are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中，我们可以获得模拟器能做什么以及每个的具体标准的概述：
- en: '`qasm_simulator`: This simulator lets you run your quantum programs and returns
    results as if you were running on a perfect quantum computer, with no errors and
    no noise, but with the option to add errors and a noise profile to simulate a
    *NISQ backend*. This simulator is written in C++ and runs locally on your machine.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`qasm_simulator`：这个模拟器允许你运行你的量子程序，并返回结果，就像你在一个完美的量子计算机上运行一样，没有错误和噪声，但可以选择添加错误和噪声配置文件来模拟
    *NISQ 后端*。这个模拟器是用 C++ 编写的，并在你的本地机器上运行。'
- en: '`statevector_simulator`: With this simulator, you can simulate the state vector
    for your qubits at any point in your circuit. This simulator is written in C++
    and runs locally on your machine.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`statevector_simulator`：使用这个模拟器，你可以在电路的任何位置模拟你的量子比特的状态向量。这个模拟器是用 C++ 编写的，并在你的本地机器上运行。'
- en: '`unitary_simulator`: With the unitary simulator, you can compute the unitary
    matrix for your circuit. This simulator is implemented as a local Python simulator.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`unitary_simulator`：使用这个模拟器，你可以计算电路的单位矩阵。这个模拟器是一个本地 Python 模拟器。'
- en: '`pulse_simulator`: A pulse-based Hamiltonian simulator for Pulse Qobj files.
    With this simulator, you can test interacting with the backend qubits directly
    using pulse-based programming that bypasses the standard gates.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pulse_simulator`：这是一个基于脉冲的哈密顿模拟器，用于脉冲 Qobj 文件。使用这个模拟器，你可以通过基于脉冲的编程直接与后端量子比特交互进行测试，从而绕过标准门。'
- en: '`ibmq_qasm_simulator`: This is the only non-local simulator in the group. It
    works much like the local `qasm_simulator` simulator but with higher performance.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ibmq_qasm_simulator`：这是该组中唯一的非本地模拟器。它的工作方式与本地 `qasm_simulator` 模拟器类似，但性能更高。'
- en: We now know what simulators are available for us to work with, and we will explore
    them further in this chapter. The only simulator we will not touch is the `pulse_simulator`
    as using this simulator is beyond the scope of this book. If you are interested,
    do take a look at the *Get to the heart of real quantum hardware* link at the
    end of the recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了我们可以使用哪些模拟器来工作，我们将在本章中进一步探讨它们。我们将不会触及的唯一模拟器是 `pulse_simulator`，因为使用这个模拟器超出了本书的范围。如果你感兴趣，请查看食谱末尾的
    *深入真实量子硬件核心* 链接。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a look at the performance data for the two QASM simulators—**Number of
    qubits** and **Max shots**. They both let you play with around *30 qubits* and
    run many thousands of shots with each run. So, what is the difference?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查看两个 QASM 模拟器的性能数据——**量子比特数量**和**最大射击次数**。它们都允许你玩大约 *30 个量子比特*，并且每次运行都可以进行数千次射击。那么，它们之间有什么区别呢？
- en: One thing to keep in mind when running the simulators is that they are simulating
    quantum computers—the very computers that we expect to beat classical computers
    at complex problems going forward. This essentially means that simulating quantum
    computers on a classical computer like yours gets roughly twice as complicated
    with each added qubit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行模拟器时需要记住的一点是，它们正在模拟量子计算机——正是我们期望在未来能够解决复杂问题的量子计算机。这本质上意味着在像你的这样的经典计算机上模拟量子计算机，每增加一个量子比特，其复杂性大约会增加两倍。
- en: For the online `ibmq_qasm_simulator` simulator, this doesn't necessarily pose
    a big problem as it is running on an IBM POWER9™ server, which is a fairly massive
    piece of hardware. You can throw seriously sized quantum programs, up to *32 qubits*,
    at it with no problems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在线的 `ibmq_qasm_simulator` 模拟器，由于它运行在 IBM POWER9™ 服务器上，这是一台相当庞大的硬件设备，因此这并不一定是一个大问题。你可以向它投递规模相当大的量子程序，高达
    *32 个量子比特*，而不会有任何问题。
- en: Your own hardware, on the other hand, is a different matter. The performance
    of the local `qasm_simulator` simulator will depend on the hardware you run it
    on. When you start to feel a lag and slowness on your local machine, it might
    be time for the online `ibmq_qasm_simulator` simulator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，你自己的硬件则是另一回事。本地 `qasm_simulator` 模拟器的性能将取决于你运行它的硬件。当你开始感觉到本地机器上的延迟和缓慢时，可能就是时候使用在线的
    `ibmq_qasm_simulator` 模拟器了。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*An Open High-Performance Simulator for Quantum Circuits, IBM Research Blog*,
    May 1, 2018: [https://www.ibm.com/blogs/research/2018/05/quantum-circuits/](https://www.ibm.com/blogs/research/2018/05/quantum-circuits/)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《一个用于量子电路的开源高性能模拟器，IBM 研究博客》，2018 年 5 月 1 日：[https://www.ibm.com/blogs/research/2018/05/quantum-circuits/](https://www.ibm.com/blogs/research/2018/05/quantum-circuits/)*'
- en: '*Get to the heart of real quantum hardware, IBM Research Blog*, December 12,
    2019: [https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/](https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《深入真实量子硬件核心，IBM 研究博客》，2019 年 12 月 12 日：[https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/](https://www.ibm.com/blogs/research/2019/12/qiskit-openpulse/)*'
- en: '*IBM Power systems*: [https://www.ibm.com/it-infrastructure/power](https://www.ibm.com/it-infrastructure/power)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IBM Power系统*：[https://www.ibm.com/it-infrastructure/power](https://www.ibm.com/it-infrastructure/power)'
- en: Comparing the Qiskit Aer simulator with an IBM quantum computer
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较Qiskit Aer模拟器和IBM量子计算机
- en: In this recipe, we will create a long quantum circuit that *swaps* a ![](img/Formula_07_001.png)
    state between two qubits. You will see that the circuit provides perfect results
    on your local Qiskit Aer simulator but not quite so perfect results on an actual
    IBM Quantum® machine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个长的量子电路，*交换*两个量子比特之间的![img/Formula_07_001.png]状态。你会发现电路在你的本地Qiskit
    Aer模拟器上提供了完美的结果，但在实际的IBM Quantum®机器上并不完全完美。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r2_ootb.py).
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here''s the code, stored in the `ch7_r2_ootb.py` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码，存储在`ch7_r2_ootb.py`文件中：
- en: 'As always, start by importing the required classes and methods and load your
    account:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，首先导入所需的类和方法，并加载你的账户：
- en: '[PRE6]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Select the number of SWAP gates to include:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要包含的SWAP门数量：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now build a quantum circuit with the selected number of SWAP gates in a
    row:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们构建一个包含一排选定数量的SWAP门的量子电路：
- en: '[PRE8]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the circuit on the `qasm_simulator` and get the results:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`qasm_simulator`上运行电路并获取结果：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result is displayed with a prompt to run the same circuit on an IBM Quantum®
    backend. Take a break here and read on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 结果会显示一个提示，要求在IBM Quantum®后端上运行相同的电路。在这里休息一下，继续阅读。
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you run this quantum circuit on a simulator, it simulates perfectly and
    we get a perfect 100% result of the expected outcome:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上运行这个量子电路时，它会完美模拟，我们得到了预期的完美100%的结果：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you follow along in the following circuit, you will see that we first use
    an X gate to set qubit **q0** to ![](img/Formula_02_029.png), and then we swap
    qubits **q0** and **q1** 10 times. What we expect to end up with is **q0** in
    ![](img/Formula_07_003.png) and **q1** in ![](img/Formula_07_004.png), or, in
    two-qubit notation, ![](img/Formula_07_005.png):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跟随以下电路，你会看到我们首先使用一个X门将量子比特**q0**设置为![img/Formula_02_029.png]，然后我们交换量子比特**q0**和**q1**
    10次。我们期望最终得到的是**q0**在![img/Formula_07_003.png]和**q1**在![img/Formula_07_004.png]，或者用两个量子比特的表示法，![img/Formula_07_005.png]：
- en: '![Figure 7.5 – A quantum circuit with 10 SWAP gates'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 一个包含10个SWAP门的量子电路'
- en: '](img/Figure_7.5_B14436.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.5_B14436.jpg)'
- en: Figure 7.5 – A quantum circuit with 10 SWAP gates
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 一个包含10个SWAP门的量子电路
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the *barrier gates* here. These are to instruct the Qiskit® transpiler
    to not transpile across the barriers, and not simplify the circuit by just removing
    the consecutive SWAP gates as they negate each other. For a quick reminder, refer
    to the *Tossing a quantum coin* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的*屏障门*。这些是为了指示Qiskit®编译器不要跨越屏障进行编译，并且不要通过仅仅移除连续的SWAP门来简化电路，因为它们会相互抵消。为了快速回顾，请参考[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)中的*抛量子硬币*食谱，*IBM
    Quantum Experience® – 量子拖放*。
- en: 'When running the program for 10 SWAP gates, you should get the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行10个SWAP门的程序时，你应该得到以下输出：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is seen numerically and in the following bar diagram:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这在数字和以下条形图中都可以看到：
- en: '![Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum
    computer: 01'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 在完美的量子计算机上经过10个SWAP门后的预期结果：01'
- en: '](img/Figure_7.6_B14436.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.6_B14436.jpg)'
- en: 'Figure 7.6 – The expected result after 10 SWAP gates on a perfect quantum computer:
    01'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 在完美的量子计算机上经过10个SWAP门后的预期结果：01
- en: This means that the program ran perfectly and that we swapped the initial ![](img/Formula_07_006.png)
    qubit back and forth 10 times to end up with the qubits back where they started,
    in ![](img/Formula_07_007.png). There were no errors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着程序运行得非常完美，我们将初始的![img/Formula_07_006.png]量子比特来回交换了10次，最终使量子比特回到它们开始的位置，在![img/Formula_07_007.png]。没有错误。
- en: In a future **universal error-correcting quantum computer**, you will be able
    to run long quantum circuits like this with perfectly consistent error-corrected
    logical qubits throughout your calculations. By default, a Qiskit Aer simulator
    emulates an error-free universal quantum computer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的**通用纠错量子计算机**中，您将能够在整个计算过程中使用完全一致的纠错逻辑量子位运行像这样的长量子电路。默认情况下，Qiskit Aer模拟器模拟一个无错误的通用量子计算机。
- en: However, when you run the same program on today's **NISQ** hardware, errors
    start to pile up as your quantum circuits grow in size and execution time. To
    check this out, you can now press *Enter* and run the circuit on an IBM Quantum®
    backend.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您在今天的**NISQ**硬件上运行相同的程序时，随着您的量子电路规模和执行时间的增长，错误开始累积。为了检查这一点，您现在可以按*Enter*键，并在IBM
    Quantum®后端上运行电路。
- en: 'We now import the least-busy backend with five qubits, and run the same circuit
    on it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在导入最不繁忙的后端，具有五个量子位，并在其上运行相同的电路：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code might give the following result:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可能会产生以下结果：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is seen numerically and in the bar diagram that follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这在数值和随后的条形图中都可以看到：
- en: '![Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results
    other than the expected 01](img/Figure_7.7_B14436.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 在10个SWAP门之后，一些错误已经渗透进来；我们得到的结果不是预期的01](img/Figure_7.7_B14436.jpg)'
- en: Figure 7.7 – After 10 SWAP gates, some errors have crept in; we get results
    other than the expected 01
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 在10个SWAP门之后，一些错误已经渗透进来；我们得到的结果不是预期的01
- en: As you can see, the crystal-clear result of the QASM simulator turned a little
    murky when run on one of the IBM Quantum® machines. You will most likely still
    get a prominent peak for the correct result (01), but also a lot of wrong results.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，QASM模拟器的清晰结果在运行于IBM Quantum®机器之一时变得有些模糊。您很可能会仍然得到正确结果（01）的显著峰值，但也会有大量错误结果。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You might think that 10 SWAP gates would be a fairly small example of a quantum
    circuit and that we shouldn't see errors like these in a circuit that size. What
    you have to keep in mind, though, is that the relatively simple logical circuit
    that you build will get transpiled into a circuit that can be run using just the
    basis gates that are available to the backend.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为10个SWAP门是一个相当小的量子电路的例子，我们不应该在这么大的电路中看到这样的错误。但是，您必须记住的是，您构建的相对简单的逻辑电路将被转译成一个可以使用后端可用的基础门运行的电路。
- en: 'Use the following `transpile` example to print the basis gates for the backend,
    and check the gate depth for the SWAP circuit before and after transpiling:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下`transpile`示例来打印后端的基础门，并在转译前后检查SWAP电路的门深度：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code should give the following result on an IBM Quantum® five-qubit
    machine such as `ibmq_vigo`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码应该在IBM Quantum®五量子位机器（如`ibmq_vigo`）上产生以下结果：
- en: '![Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like](img/Figure_7.8_B14436.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 转译后的10个SWAP门电路的外观](img/Figure_7.8_B14436.jpg)'
- en: Figure 7.8 – What a transpiled 10 SWAP gate circuit looks like
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 转译后的10个SWAP门电路的外观
- en: 'The previous code sample should give an output similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例应该会产生以下类似的输出：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you run on a real quantum computer, noise and gate errors are introduced
    for each gate. As you can see in the previous figure, a single SWAP gate, when
    transpiled, might turn into three successive CX gates, and adding 10 of these
    in a row results in 30 CX gates. This makes for some potential big errors. Note
    that the number of transpiled gates depends on the selected backend and might
    be larger than the 30 in this example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在真实的量子计算机上运行时，每个门都会引入噪声和门错误。正如您在前面的图中所见，一个单独的SWAP门在转译后可能会变成三个连续的CX门，而连续添加10个这样的门会导致30个CX门。这可能导致一些潜在的大错误。请注意，转译门的数量取决于所选的后端，可能比本例中的30个更多。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Quantum Computing in the NISQ era and beyond* by John Preskill from the Institute
    for Quantum Information and Matter and the Walter Burke Institute for Theoretical
    Physics, California Institute of Technology, Pasadena, CA, 91125, USA: [https://quantum-journal.org/papers/q-2018-08-06-79/](https://quantum-journal.org/papers/q-2018-08-06-79/).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*量子计算在NISQ时代及其之后*，作者为加州理工学院信息与物质研究所和沃尔特·伯克理论物理研究所的约翰·普雷斯科尔，地址：美国加利福尼亚州帕萨迪纳，加州理工学院，91125：[https://quantum-journal.org/papers/q-2018-08-06-79/](https://quantum-journal.org/papers/q-2018-08-06-79/).'
- en: Adding noise profiles of IBM Quantum® backends to local simulators
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将IBM Quantum®后端的噪声配置文件添加到本地模拟器中
- en: In this recipe, we find the noise data for the IBM Quantum® backends to build
    a noise profile that we can then add to our simulator when we run it. This will
    make the simulator behave like a *real NISQ backend*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们找到IBM Quantum®后端的噪声数据，以构建一个噪声配置文件，然后在我们运行模拟器时将其添加到模拟器中。这将使模拟器表现得像真实的NISQ后端。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r3_noise.py)。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s look at the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: Get a list of the available backends and select one to simulate.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取可用后端的列表并选择一个进行模拟。
- en: 'We will get the noise profile of one of the IBM Quantum® backends and use it
    with our simulators. First, we use the `select_backend()` function to list the
    backends and make the selection:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将获取一个IBM Quantum®后端的噪声配置文件，并将其与我们的模拟器一起使用。首先，我们使用`select_backend()`函数列出后端并做出选择：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code might result in the following listing:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码可能会导致以下列表：
- en: '![Figure 7.9 – List of available IBM Quantum® backends'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.9 – 可用的IBM Quantum®后端列表'
- en: '](img/Figure_7.9_B14436.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.9_B14436.jpg)'
- en: Figure 7.9 – List of available IBM Quantum® backends
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.9 – 可用的IBM Quantum®后端列表
- en: As we will also run the quantum circuit on the backend, you should pick one
    with a reasonably short queue to avoid having to wait excessively for the results.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们还将量子电路运行在后台上，您应该选择一个队列时间相对较短的，以避免等待结果的时间过长。
- en: 'Get the noise profile. The noise model can be extracted from the backend by
    using the `NoiseModel.from_backend(backend)` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取噪声配置文件。可以通过使用`NoiseModel.from_backend(backend)`方法从后端提取噪声模型：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The noise model will look different depending on the backend that you selected.
    A sample model is shown here:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 噪声模型将根据您选择的后端而有所不同。这里展示了一个示例模型：
- en: '![Figure 7.10 – Noise model for an IBM Quantum® backend'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.10 – IBM Quantum®后端的噪声模型'
- en: '](img/Figure_7.10_B14436.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.10_B14436.jpg)'
- en: Figure 7.10 – Noise model for an IBM Quantum® backend
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.10 – IBM Quantum®后端的噪声模型
- en: We can now run the simulator with the noise model and other parameters to have
    the NISQ characteristics of the selected backend applied to the simulator calculations
    and make it behave like an actual physical backend and not a perfect simulator.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以使用噪声模型和其他参数运行模拟器，将所选后端的NISQ特性应用于模拟器计算，并使其表现得像一个实际的物理后端，而不是一个完美的模拟器。
- en: Build a GHZ state circuit and run it on four different backends.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个GHZ状态电路并在四个不同的后端上运行它。
- en: The `execute_circuit()` function to run on the backends with all the variations.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`execute_circuit()`函数用于在所有后端上运行所有变体。'
- en: 'In Python, we start by getting the basis gates and a coupling map for the backend:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Python中，我们首先获取后端的基本门和耦合图：
- en: '[PRE18]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then build a GHZ state quantum circuit, execute it on a simulator, and get
    the counts:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们然后构建一个GHZ状态量子电路，在模拟器上执行它，并获取计数：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we use the noise model and coupling map to execute a noisy simulation
    on both the local and the IBM Quantum® QASM simulator and get the counts:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用噪声模型和耦合图在本地和IBM Quantum® QASM模拟器上执行有噪声的模拟，并获取计数：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we execute the job on the IBM Quantum® backend and get the counts:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们在IBM Quantum®后端上执行作业并获取计数：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final step is to display the collected results for all runs:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是显示所有运行的收集结果：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we walk through these four executions of the GHZ circuit, we will see how
    the initial perfect simulation, which provides an output of only ![](img/Formula_07_008.png)
    or ![](img/Formula_07_009.png) with ~50% chance, gets *contaminated* with errors;
    we get outputs in all possible states.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历这四个GHZ电路的执行过程中，我们将看到初始完美的模拟，它只提供输出![](img/Formula_07_008.png)或![](img/Formula_07_009.png)，概率约为50%，是如何被错误*污染*的；我们得到所有可能的状态输出。
- en: 'In the final output, we compare all the executions with the final execution
    on the selected backend. What you might see when running the program would look
    something like the following set of screenshots:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终输出中，我们比较所有执行与所选后端的最终执行。运行程序时您可能会看到以下一系列截图：
- en: First, we run on the simulator without noise and you get the following output:![Figure
    7.11 – First, ideal run on the local simulator
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在无噪声的模拟器上运行，得到以下输出：![图 7.11 – 首次在本地模拟器上理想运行
- en: '](img/Figure_7.11_B14436.jpg)'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B14436.jpg)'
- en: Figure 7.11 – First, ideal run on the local simulator
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.11 – 首次在本地模拟器上理想运行
- en: Then, we add the noise model and run it again:![Figure 7.12 – Adding the noise
    model to the local simulator
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加噪声模型并再次运行：![图 7.12 – 将噪声模型添加到本地模拟器
- en: '](img/Figure_7.12_B14436.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.12_B14436.jpg)'
- en: Figure 7.12 – Adding the noise model to the local simulator
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.12 – 将噪声模型添加到本地模拟器
- en: As we can now see, we no longer get the nice, clean, and perfect quantum computer
    result but rather a result that is much closer to what you would get if you run
    the circuit on an actual IBM Quantum® backend.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们现在所看到的，我们不再得到漂亮、干净、完美的量子计算机结果，而是得到一个结果，这个结果与您在实际上运行电路时得到的结果非常接近。
- en: We test one more time by running with the noise model on the online IBM Quantum®
    QASM simulator:![Figure 7.13 – Adding the noise model to the IBM Quantum® simulator](img/Figure_7.13_B14436.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次通过在在线 IBM Quantum® QASM 模拟器上运行带有噪声模型进行测试：![图 7.13 – 将噪声模型添加到 IBM Quantum®
    模拟器](img/Figure_7.13_B14436.jpg)
- en: Figure 7.13 – Adding the noise model to the IBM Quantum® simulator
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.13 – 将噪声模型添加到 IBM Quantum® 模拟器
- en: 'Finally, we run the circuit one final time, now on the backend that we selected
    at the beginning:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们再次运行电路，现在是在我们最初选择的后端上：
- en: '![Figure 7.14 – Running the circuit on the IBM Quantum® backend'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – 在 IBM Quantum® 后端运行电路'
- en: '](img/Figure_7.14_B14436.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B14436.jpg)'
- en: Figure 7.14 – Running the circuit on the IBM Quantum® backend
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 在 IBM Quantum® 后端运行电路
- en: The result of this run should be similar to our simulated runs based on the
    noise model we derived from the actual IBM Quantum® backend.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行的结果应该与我们根据从实际 IBM Quantum® 后端推导出的噪声模型进行的模拟运行相似。
- en: 'We can now merge all the results into a single diagram for comparison:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将所有结果合并到一个单独的图表中进行比较：
- en: '![Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 – 模拟器和 IBM Quantum® 后端之间的输出比较'
- en: '](img/Figure_7.15_B14436.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B14436.jpg)'
- en: Figure 7.15 – Output comparison between simulators and the IBM Quantum® backend
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 模拟器和 IBM Quantum® 后端之间的输出比较
- en: In the final output, you can see that the simulators with the added noise model
    behave, at least statistically, like the IBM Quantum® backend on which they are
    modeled. As you can see, for the **Baseline** Aer simulation, we only get the
    expected ![](img/Formula_07_008.png) and ![](img/Formula_07_009.png) results for
    a GHZ state, but for all the other runs, we also get *noise* in the form of results
    such as ![](img/Formula_07_059.png) and ![](img/Formula_07_060.png).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终输出中，您可以看到，添加了噪声模型的模拟器在统计上至少表现得像它们所模拟的 IBM Quantum® 后端。如您所见，对于 **基线** Aer
    模拟，我们只得到 GHZ 状态的预期 ![](img/Formula_07_008.png) 和 ![](img/Formula_07_009.png) 结果，但对于所有其他运行，我们还得到了
    *噪声*，如 ![](img/Formula_07_059.png) 和 ![](img/Formula_07_060.png) 等结果。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments*, arXiv,
    IBM Research et.al., September 11, 2018: [https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments*，arXiv，IBM
    Research 等人，2018 年 9 月 11 日：[https://arxiv.org/pdf/1809.03452.pdf](https://arxiv.org/pdf/1809.03452.pdf)。'
- en: Understanding your circuits by using the unitary simulator
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过使用单位矩阵模拟器理解您的电路
- en: As it turns out, any valid quantum circuit that consists only of gates can be
    translated into a unitary matrix that describes the expected outcome for each
    possible state vector input. As you have seen in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*, each quantum gate is in itself a **unitary
    matrix**, and the combination of the unitaries that make up the complete quantum
    circuit can in itself be described as a **unitary**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，任何仅由门组成的有效量子电路都可以被转换成一个单位矩阵，该矩阵描述了每个可能的状态向量输入的预期结果。正如您在 [*第 2 章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)
    中所看到的，*使用 Python 进行量子计算和量子比特*，每个量子门本身就是一个 **单位矩阵**，构成完整量子电路的单位矩阵的组合本身也可以描述为 **单位**。
- en: Qiskit® lets you use the Qiskit Aer `unitary_simulator` simulator to return
    the unitary matrix that corresponds with your quantum circuit. You run the job
    just like you would for `qasm_simulator` jobs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit® 允许您使用 Qiskit Aer `unitary_simulator` 模拟器返回与您的量子电路相对应的单位矩阵。您运行作业的方式与
    `qasm_simulator` 作业相同。
- en: 'When running `unitary_simulator`, you only run the circuit once. We can then
    use the `get_unitary(qc)` method on the returned results to see the unitary as
    a matrix for a circuit, such as this one-qubit superposition circuit using a Hadamard
    gate:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`unitary_simulator`时，您只运行电路一次。然后，我们可以使用返回结果上的`get_unitary(qc)`方法查看电路的单位算符，例如这个使用Hadamard门的单量子比特叠加电路：
- en: '![Figure 7.16 – Quantum circuit with one Hadamard gate'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16 – 带有一个Hadamard门的量子电路'
- en: '](img/Figure_7.16_B14436.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.16_B14436.jpg)'
- en: Figure 7.16 – Quantum circuit with one Hadamard gate
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 带有一个Hadamard门的量子电路
- en: 'The circuit corresponds to the following unitary:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路对应以下单位算符：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a cleaner printout, this would look as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在更清晰的打印输出中，它将如下所示：
- en: '![](img/Formula_07_014.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_014.jpg)'
- en: You might recognize this as the *Hadamard gate* matrix, which is just what it
    is. Just like this, you can use the unitary simulator to return the unitary matrixes
    for any valid quantum circuit. That is what we will explore in this recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认出这是*Hadamard门*矩阵，这正是它所代表的。就像这样，您可以使用单位算符模拟器返回任何有效量子电路的单位算符矩阵。这正是我们将在这个食谱中探讨的内容。
- en: We will create a few simple quantum circuits and run them through a unitary
    simulator to get the unitary matrix. We then compare the Qiskit® unitary with
    the theoretical unitary for the gate combination that is represented by the circuit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个简单的量子电路，并通过单位算符模拟器运行它们以获取单位算符矩阵。然后，我们将Qiskit®单位算符与电路表示的门的组合的理论单位算符进行比较。
- en: Finally, we run the circuit on the `qasm` simulator and compare the result with
    a calculation of the input qubit state vectors, **[1,0]** (for one qubit) and
    **[1,0,0,0]** (for two qubits), which represent all qubits starting in the state
    ![](img/Formula_07_0041.png).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`qasm`模拟器上运行电路，并将结果与输入量子比特状态向量的计算进行比较，**[1,0]**（对于单个量子比特）和**[1,0,0,0]**（对于两个量子比特），它们代表所有量子比特从状态![img/Formula_07_0041.png](img/Formula_07_0041.png)开始。
- en: The script includes a set of functions that we define to control the creation
    of circuits and other calculations that need to be done.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包括一组我们定义的函数，用于控制电路的创建和其他需要完成的计算。
- en: For example, we use the `circuits()` function to create three basic quantum
    circuits and store them in a list for later use.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用`circuits()`函数创建三个基本的量子电路，并将它们存储在列表中以供以后使用。
- en: 'In the script, we are also using two functions that we create ourselves to
    process the unitary information: `show_unitary()` and `calc_unitary()`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们还使用了两个我们自己创建的函数来处理单位算符信息：`show_unitary()`和`calc_unitary()`。
- en: The input and function calls are controlled by the `main` loop at the end of
    the script.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和函数调用由脚本末尾的`main`循环控制。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r4_unitary.py)。
- en: How to do it…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In your Python environment, run `ch7_r4_unitary.py`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Python环境中运行`ch7_r4_unitary.py`。
- en: When you first launch the script, you get an input menu:![Figure 7.17 – Input
    menu
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您首次运行脚本时，您会看到一个输入菜单：![图7.17 – 输入菜单
- en: '](img/Figure_7.17_B14436.jpg)'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.17_B14436.jpg)'
- en: Figure 7.17 – Input menu
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.17 – 输入菜单
- en: Enter a number to select the circuit to run with. Options **1**–**3** are predefined
    in the script, while option **4** lets you input QASM code from IBM Quantum Experience®
    to test, much like we did in the *Moving between worlds* recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063),
    *IBM Quantum Experience® – Quantum Drag and Drop*.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入一个数字以选择要运行的电路。脚本中预定义了**1**至**3**选项，而**4**选项允许您从IBM Quantum Experience®输入QASM代码进行测试，就像我们在[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)的*在两个世界之间移动*食谱中所做的那样，*IBM
    Quantum Experience® – 量子拖放*。
- en: 'Important: No measurement instructions'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要：无测量指令
- en: If you include measurement instructions with your quantum circuit, you must
    strip these out before you submit it as input. If the code includes measurement
    circuits, the simulator will crash with an Aer error.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在量子电路中包含测量指令，您必须在提交为输入之前将其删除。如果代码包含测量电路，模拟器将因Aer错误而崩溃。
- en: 'After you select the circuit to explore, the program creates the circuits we
    need, and return them as a list:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择了要探索的电路之后，程序会创建我们需要的电路，并将它们作为列表返回：
- en: '[PRE24]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will now send the circuit that we selected to print the unitary.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将选定的电路发送以打印单位算符。
- en: 'In `show_unitary()`, we set the backend to `unitary_simulator` and run the
    circuit. The returned unitary is retrieved from the execution results and printed
    as a matrix:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `show_unitary()` 中，我们将后端设置为 `unitary_simulator` 并运行电路。从执行结果中检索返回的单位算符，并以矩阵形式打印：
- en: '[PRE25]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, the unitary is used to calculate the predicted outcome for the circuit
    and the circuit is run on `qasm_simulator` for comparison.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用单位算符来计算电路的预测结果，并在 `qasm_simulator` 上运行电路以进行比较。
- en: 'In the `calc_unitary()` function, we use the returned unitary as input together
    with the quantum circuit. We then create a state vector for the number of qubits
    specified by the circuit and use `qasm_simulator` to compare the calculated results
    with the simulated results:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `calc_unitary()` 函数中，我们使用返回的单位算符以及量子电路作为输入。然后我们为电路指定的量子比特数量创建一个状态向量，并使用 `qasm_simulator`
    来比较计算结果与模拟结果：
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All in all, if we run the script with input **1**, for *one-qubit superposition*,
    we will get a result that is similar to the following:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总的来说，如果我们用输入 **1** 运行脚本，对于 *单量子比特叠加态*，我们将得到一个类似于以下的结果：
- en: '![Figure 7.18 – One-qubit superposition output](img/Figure_7.18_B14436.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.18 – 单量子比特叠加态输出](img/Figure_07_18_B14436.jpg)'
- en: Figure 7.18 – One-qubit superposition output
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.18 – 单量子比特叠加态输出
- en: For the one-qubit superposition, we will create a simple quantum circuit with
    just a Hadamard gate. The unitary for this circuit is as follows:![](img/Formula_07_017.jpg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于单量子比特叠加态，我们将创建一个仅包含Hadamard门的简单量子电路。这个电路的单位算符如下：![](img/Formula_07_017.jpg)
- en: The calculated outcomes correspond nicely with the returned counts from running
    the circuit on the QASM simulator.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算结果与在QASM模拟器上运行电路返回的计数很好地对应。
- en: Now, test options **2** and **3** to see what the unitaries look like for slightly
    more complicated circuits. When you feel that you have a good grasp of what is
    going on, take a look at the next recipe to import any circuit as a QASM string.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，测试选项 **2** 和 **3**，看看稍微复杂一些的电路的单位算符是什么样的。当你觉得你对正在发生的事情有了很好的把握时，看看下一个菜谱，了解如何将任何电路作为QASM字符串导入。
- en: Running diagnostics with the state vector simulator
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态向量模拟器进行诊断
- en: In this recipe, we will explore the state vector simulator and see how you can
    use it to run diagnostics on your circuits to see how your qubits are behaving.
    The state vector simulator is not a quantum computer simulator per se, but a tool
    that runs through your quantum circuit with one shot and returns the qubit state
    vector that results. As these are simulators, you can actually use them to do
    diagnostic tests of your circuits without disturbing them and breaking the quantum
    state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索状态向量模拟器，看看你如何使用它来对你的电路进行诊断，以了解你的量子比特是如何表现的。状态向量模拟器本身不是一个量子计算机模拟器，而是一个工具，它通过一次运行你的量子电路，并返回结果量子比特状态向量。由于这些是模拟器，你可以实际上使用它们来对你的电路进行诊断测试，而不会干扰它们并破坏量子状态。
- en: You will notice that we have used the state vector simulator before, when displaying
    the qubits as **Bloch spheres**, but we did not go into any great detail at that
    point. Using Bloch sphere visualization works well with single or multiple qubit
    visualization when each qubit has a definite simple state that can be projected
    on a Bloch sphere.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在显示量子比特作为 **布洛赫球** 之前已经使用了状态向量模拟器，但当时我们没有深入探讨。使用布洛赫球可视化在单量子比特或多量子比特可视化中效果很好，当每个量子比特都有一个可以投影到布洛赫球上的简单确定状态时。
- en: There is a different output—actually, several—that we will touch on. Each of
    these lets you present the state of your qubits at a specific point in your circuit,
    before measuring.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的输出——实际上，有几个——我们将涉及到。这些中的每一个都让你能够在测量之前，在电路的特定点上展示你的量子比特的状态。
- en: 'So, here''s what we will work with. The state vector simulator returns a state
    vector, much like the following examples:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是我们将会处理的。状态向量模拟器返回一个状态向量，类似于以下示例：
- en: 'For a qubit in superposition: `[0.707+0.j 0.707+0.j]`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处于叠加态的量子比特：`[0.707+0.j 0.707+0.j]`
- en: 'For a Bell-state entangled qubit pair: `[0.707+0.j 0\. +0.j 0\. +0.j 0.707+0.j]`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于贝尔态纠缠的量子比特对：`[0.707+0.j 0\. +0.j 0\. +0.j 0.707+0.j]`
- en: 'Written out in standard matrix form, these correspond to the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 用标准矩阵形式写出来，这些对应于以下：
- en: 'Qubit in superposition:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处于叠加态的量子比特：
- en: '![](img/Formula_07_018.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_018.png)'
- en: 'An entangled qubit pair:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个纠缠量子比特对：
- en: '![](img/Formula_07_019.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_019.jpg)'
- en: 'We can try displaying these using the `plot_bloch_multivector()` method. This
    visualization lets you observe how each individual qubit changes as the circuit
    progresses:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用 `plot_bloch_multivector()` 方法来显示这些。这种可视化让你可以观察随着电路的进行，每个量子比特如何变化：
- en: '![Figure 7.19 – Single qubit in state'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.19 – 状态'
- en: '](img/Figure_7.19_B14436.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.19_B14436.jpg)'
- en: Figure 7.19 – Single qubit in state ![](img/Formula_07_020.png)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 状态 ![](img/Formula_07_020.png) 的单量子比特
- en: 'This works fine as long as the qubits can be expressed individually. For entangled
    qubits, this visualization method no longer works:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 只要量子比特可以单独表示，这种方法就适用。对于纠缠量子比特，这种可视化方法就不再适用：
- en: '![Figure 7.20 – Entangled qubit pair in state](img/Figure_7.20_B14436.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 状态 的纠缠量子比特对](img/Figure_7.20_B14436.jpg)'
- en: Figure 7.20 – Entangled qubit pair in state ![](img/Formula_07_021.png)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 状态 ![](img/Formula_07_021.png) 的纠缠量子比特对
- en: As you can see, Bloch spheres are not a good tool for entangled visualization,
    where the qubits cannot be described individually, but only as a combined entity.
    For more complex visualizations like these, we can use the `plot_state_qsphere()`
    method instead. The Q-sphere visualization is unique to Qiskit® and displays the
    quantum state as one or more vectors on a Q-sphere.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，布洛赫球体并不是一个很好的纠缠可视化工具，因为量子比特不能单独描述，只能作为一个整体。对于这些更复杂的可视化，我们可以使用 `plot_state_qsphere()`
    方法。Q-球体可视化是 Qiskit® 的独特功能，它将量子状态显示为 Q-球体上的一或多个矢量。
- en: 'The Q-sphere displays a circle (for single-qubit states) or a sphere (for multiple-qubit
    states), with one or more vectors that represent the state. The relative size
    of the vector and tip shows the probability of measuring the indicated state;
    for a one-qubit Q-sphere, the north pole represents the ground state, ![](img/Formula_07_022.png),
    and the south pole the excited state, ![](img/Formula_07_0031.png), and the color
    indicates the phase angle of the state:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Q-球体显示一个圆（表示单量子比特状态）或一个球体（表示多量子比特状态），其中有一个或多个矢量代表状态。矢量的大小和尖端表示测量指示状态的概率；对于单量子比特
    Q-球体，北极代表基态，![](img/Formula_07_022.png)，南极代表激发态，![](img/Formula_07_0031.png)，颜色表示状态的相位角：
- en: '![Figure 7.21 – Single qubit in state  with a 100% probability of measuring
    0'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.21 – 状态 的单量子比特，测量 0 的概率为 100%'
- en: '](img/Figure_7.21_B14436.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.21_B14436.jpg)'
- en: Figure 7.21 – Single qubit in state ![](img/Formula_07_024.png) with a 100%
    probability of measuring 0
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 状态 ![](img/Formula_07_024.png) 的单量子比特，测量 0 的概率为 100%
- en: 'For example, the one-qubit example indicates that the probability of measuring
    the state ![](img/Formula_07_025.png) is 1 (vector pointing up), and the phase
    angle is 0\. You can use the Q-sphere to visualize the entangled qubit pair that
    we could not visualize with the Bloch sphere:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单量子比特示例表明测量状态 ![](img/Formula_07_025.png) 的概率是 1（向上指的矢量），相位角是 0。你可以使用 Q-球体来可视化我们无法用布洛赫球体可视化的纠缠量子比特对：
- en: '![Figure 7.22 – Entangled qubit pair in state , with'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.22 – 状态 的纠缠量子比特对，带有'
- en: a 50% probability of measuring either 0 or 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 测量 0 或 1 的概率各为 50%
- en: '](img/Figure_7.22_B14436.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.22_B14436.jpg)'
- en: Figure 7.22 – Entangled qubit pair in state ![](img/Formula_07_026.png), with
    a 50% probability of measuring either 0 or 1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 状态 ![](img/Formula_07_026.png) 的纠缠量子比特对，测量 0 或 1 的概率各为 50%
- en: 'In the entangled qubit example, there are two possible outcomes with equal
    probability: ![](img/Formula_07_027.png) (vector pointing up) and ![](img/Formula_07_028.png)
    (vector pointing down), both with phase 0\.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在纠缠量子比特示例中，有两种可能的结果，概率相等：![](img/Formula_07_027.png)（向上指的矢量）和 ![](img/Formula_07_028.png)（向下指的矢量），两者相位角均为
    0。
- en: 'Note that for the two-qubit example, you also see an equator for the sphere.
    The reason for the equator is the two additional possible outcomes: ![](img/Formula_07_031.png)
    and ![](img/Formula_07_030.png) for a two-qubit system. In this case, the results
    occupy two opposite nodes along the equator: ![](img/Formula_07_031.png) on the
    left extreme and ![](img/Formula_07_032.png) on the right:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于双量子比特示例，你也会看到球体的赤道。赤道存在的原因是双量子比特系统有另外两种可能的结果：![](img/Formula_07_031.png)
    和 ![](img/Formula_07_030.png)。在这种情况下，结果占据了赤道上的两个相对节点：![](img/Formula_07_031.png)
    在左端极限处，![](img/Formula_07_032.png) 在右端：
- en: '![Figure 7.23 – Entangled qubit pair in state , with an'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.23 – 状态 的纠缠量子比特对，带有'
- en: equal 50% probability of measuring 01 and 10
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 测量 01 和 10 的概率各为 50%
- en: '](img/Figure_7.23_B14436.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.23_B14436.jpg)'
- en: Figure 7.23 – Entangled qubit pair in state ![](img/Formula_07_033.png), with
    an equal 50% probability of measuring 01 and 10
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 处于 ![](img/Formula_07_033.png) 状态的纠缠量子比特对，测量 01 和 10 的概率均为 50%
- en: As we will see, if you add more qubits, the Q-sphere will come equipped with
    additional latitude lines like these, each representing states with equal **Hamming**
    values, or the number of qubits in state ![](img/Formula_07_034.png). For example,
    a three-qubit Q-sphere will have two latitude lines, each with three possible
    nodes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，如果你添加更多的量子比特，Q-球将配备额外的纬度线，就像这些一样，每条纬度线代表具有相等 **汉明** 值的状态，或者处于状态 ![](img/Formula_07_034.png)
    的量子比特数量。例如，三量子比特 Q-球将有两个纬度线，每个纬度线有三个可能的节点。
- en: 'Three qubits in individual superposition are of two types:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 单个量子比特叠加的三种类型：
- en: 'Three-qubit superposition state vector: `[0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j
    0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j]`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三量子比特叠加状态向量：`[0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j 0.354+0.j
    0.354+0.j]`
- en: 'Three-qubit superposition in standard matrix form:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准矩阵形式下的三量子比特叠加：
- en: '![](img/Formula_07_035.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_07_035.jpg)'
- en: 'The following outcomes will be displayed on the Q-sphere:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结果将在 Q-球上显示：
- en: '**North pole**: ![](img/Formula_07_036.png)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**北极**： ![](img/Formula_07_036.png)'
- en: '**First latitude line**: ![](img/Formula_07_037.png)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一纬度线**： ![](img/Formula_07_037.png)'
- en: '**Second latitude line**: ![](img/Formula_07_038.png)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二纬度线**： ![](img/Formula_07_038.png)'
- en: '**South pole**: ![](img/Formula_07_039.png):'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**南极**： ![](img/Formula_07_039.png)：'
- en: '![Figure 7.24 – Example of a three-qubit Q-sphere with nodes for'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.24 – 具有等概率（'
- en: equal probability (  , or 12.5%) of all the outcomes
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 等概率（  ，或 12.5%）的所有结果
- en: '](img/Figure_7.24_B14436.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.24_B14436.jpg)'
- en: Figure 7.24 – Example of a three-qubit Q-sphere with nodes for equal probability
    ( ![](img/Formula_07_040.png) , or 12.5%) of all the outcomes
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 – 具有等概率（ ![](img/Formula_07_040.png) ，或 12.5%）所有结果节点的三量子比特 Q-球示例
- en: Alright, with that under our belt, let's dive straight in.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，有了这个基础，让我们直接深入。
- en: Getting ready
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 该配方的示例代码可以在以下位置找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter07/ch7_r5_state_vector.py)。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'For this recipe, we will set up a quantum circuit with either simple superpositions
    on all qubits, or with entanglement between all the qubits. As we build the circuit,
    we will do a state vector measurement after each gate, storing the results in
    a list. We will then print the returned state vectors and plot them on Bloch spheres
    and Q-spheres to illustrate how the qubit moves around as the circuit is executed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将设置一个量子电路，其中所有量子比特要么是简单的叠加，要么是所有量子比特之间的纠缠。当我们构建电路时，我们将在每个门之后进行状态向量测量，并将结果存储在列表中。然后我们将打印返回的状态向量，并将它们绘制在
    Bloch 球和 Q-球上，以说明量子比特在电路执行过程中的移动情况：
- en: Set the number of qubits.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置量子比特的数量。
- en: 'In this first step, we set the number of qubits, and then select to build a
    superposition circuit or a circuit with entanglement by using `s` or `e` as input:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步中，我们设置量子比特的数量，然后通过使用 `s` 或 `e` 作为输入来选择构建叠加电路或纠缠电路：
- en: '![Figure 7.25 – Selecting the number of qubits and the type of circuit'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.25 – 选择量子比特数量和电路类型'
- en: '](img/Figure_7.25_B14436.jpg)'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.25_B14436.jpg)'
- en: '[PRE27]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The state vector simulator can be selected by using the following command:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下命令选择状态向量模拟器：
- en: '[PRE28]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With that simulator chosen, when you execute a quantum circuit, the simulator
    runs through the circuit one time, one shot, and returns the calculated state
    vector of your qubits. The outcome for a two-qubit circuit should look like this:![Figure
    7.26 – Two-qubit circuit as Bloch spheres and a Q-sphere
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该模拟器后，当你执行一个量子电路时，模拟器会一次性运行整个电路，并返回你的量子比特计算出的状态向量。对于双量子比特电路的结果应该如下所示：![图 7.26
    – 双量子比特电路作为 Bloch 球和 Q-球
- en: '](img/Figure_7.26_B14436.jpg)'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.26_B14436.jpg)'
- en: '[PRE29]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, with an empty two-qubit circuit, we expect the measurement
    result 00 with 100% certainty, which we can see from the state vector:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，对于一个空的双量子比特电路，我们期望以 100% 的确定性测量到 00，这可以从状态向量中看出：
- en: '![](img/Formula_07_044.jpg)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/Formula_07_044.jpg)'
- en: You can also see both qubits pointing to ![](img/Formula_07_045.png), and the
    Q-sphere vector pointing to ![](img/Formula_07_046.png).
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以看到两个量子比特都指向![图片](img/Formula_07_045.png)，Q球矢量指向![图片](img/Formula_07_046.png)。
- en: Next, hit **Return** to add a first Hadamard gate to one of the qubits and run
    the display function again:![Figure 7.27 – Two qubits, with one in superposition,
    as Bloch spheres and a Q-sphere
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按**Return**键向一个量子比特添加一个Hadamard门，并再次运行显示函数：![图7.27 – 两个量子比特，其中一个处于叠加状态，作为布洛赫球和Q球
- en: '](img/Figure_7.27_B14436.jpg)'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.27_B14436.jpg)'
- en: Figure 7.27 – Two qubits, with one in superposition, as Bloch spheres and a
    Q-sphere
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.27 – 两个量子比特，其中一个处于叠加状态，作为布洛赫球和Q球
- en: 'Now we see the effect on the state vector when the second qubit is set in superposition
    with the Bloch vector pointing to the ![](img/Formula_07_041.png) state. Looking
    at the Q-sphere, we now see two possible outcomes, each with equal probability:
    ![](img/Formula_07_042.png) and ![](img/Formula_07_043.png).'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们看到当第二个量子比特与布洛赫矢量指向![图片](img/Formula_07_041.png)状态叠加时，对状态矢量的影响。查看Q球，我们现在看到两个可能的结果，每个结果都有相同的概率：![图片](img/Formula_07_042.png)和![图片](img/Formula_07_043.png)。
- en: Finally, press **Return** again to add the second Hadamard, and display it again:![Figure
    7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次按**Return**键添加第二个Hadamard门，并再次显示：![图7.28 – 两个量子比特在叠加状态作为布洛赫球和Q球
- en: '](img/Figure_7.28_B14436.jpg)'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.28_B14436.jpg)'
- en: Figure 7.28 – Two qubits in superposition as Bloch spheres and a Q-sphere
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.28 – 两个量子比特在叠加状态作为布洛赫球和Q球
- en: We have now walked ourselves through our superposition step by step.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已经一步一步地走过了我们的叠加步骤。
- en: 'In the final step, you can see that the two-qubit Bloch vectors are both in
    the ![](img/Formula_07_047.png) state for a ![](img/Formula_07_048.png) superposition.
    The state vector is now as follows:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一步，你可以看到两个量子比特的布洛赫矢量都处于![图片](img/Formula_07_047.png)状态，这是一个![图片](img/Formula_07_048.png)叠加状态。状态矢量现在如下所示：
- en: 'This is reflected in the final outcome, where the following states all have
    the same 25%, probability, as displayed by the Q-sphere: ![](img/Formula_07_050.png).'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这在最终结果中得到了反映，其中以下状态都具有相同的25%概率，如Q球所示：![图片](img/Formula_07_050.png)。
- en: You can now run the circuit again with two qubits, but select **e** for entanglement
    to see how the qubits behave step by step.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以用两个量子比特再次运行电路，但选择**e**来选择纠缠，以查看量子比特如何一步一步地表现。
- en: 'Finally, try running the program with `sp` or `ep` as input, to include a phase
    angle to your superposition or entanglement circuit by adding a T-gate to the
    final qubit. As you will recall from [*Chapter 6*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156),
    *Understanding the Qiskit® Gate Library*, this will introduce a ![](img/Formula_07_051.png)
    phase to that qubit, which will be reflected in the Q-sphere output:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，尝试用`sp`或`ep`作为输入运行程序，通过向最后一个量子比特添加T门来向你的叠加或纠缠电路添加相位角。正如你从[*第6章*](B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156)，“理解Qiskit®门库”中回忆的那样，这将向该量子比特引入![图片](img/Formula_07_051.png)相位，这将反映在Q球输出中：
- en: '![Figure 7.29 – A  phase added to qubit 1'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.29 – 向量子比特1添加相位'
- en: '](img/Figure_7.29_B14436.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.29_B14436.jpg)'
- en: Figure 7.29 – A ![](img/Formula_07_052.png) phase added to qubit 1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29 – 向量子比特1添加![图片](img/Formula_07_052.png)相位
- en: 'Again, you can see the expected measurement results of ![](img/Formula_07_053.png)
    with 25% certainty, with the added twist that the ![](img/Formula_07_054.png)
    and ![](img/Formula_07_055.png) states have the phase ![](img/Formula_07_056.png):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，你可以看到以25%的确定性预期的测量结果![图片](img/Formula_07_053.png)，增加了![图片](img/Formula_07_054.png)和![图片](img/Formula_07_055.png)状态具有![图片](img/Formula_07_056.png)相位的附加变化： '
- en: '![Figure 7.30 – The  results now have a  phase'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.30 – 现在的结果具有相位'
- en: '](img/Figure_7.30_B14436.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.30_B14436.jpg)'
- en: Figure 7.30 – The ![](img/Formula_07_057.png) results now have a ![](img/Formula_07_058.png)
    phase
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30 – 现在的结果具有![图片](img/Formula_07_057.png)相位
- en: Note how there is no change to the counts output; adding a phase to a qubit
    does not change the probability of the outcomes. The phase, however, can be very
    useful for other, more complex quantum algorithms, as we will see in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover's Search Algorithm*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出计数没有变化；给量子比特添加一个相位不会改变结果的可能性。然而，相位对于其他更复杂的量子算法可能非常有用，正如我们将在[*第9章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)，“Grover搜索算法”中看到的。
- en: There's more...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At this point, you might have a feeling of déjà vu; you have seen this before,
    and you are right. Flip back to the *Building quantum scores with Circuit Composer*
    recipe in [*Chapter 3*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063), *IBM
    Quantum Experience® – Quantum Drag and Drop*, and take a look at the **Inspect**
    feature that we discussed there. What we have discussed in this recipe is the
    corresponding way to inspect your circuits in Qiskit®.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会有一种似曾相识的感觉；你之前确实见过这个，而且你是对的。翻回到[*第3章*](B14436_03_Final_PG_ePub.xhtml#_idTextAnchor063)中的*使用电路作曲家构建量子分数*配方，*IBM
    Quantum Experience® – 量子拖放*，看看我们之前讨论的**检查**功能。我们在该配方中讨论的是在Qiskit®中检查你的电路的相应方法。
- en: This has been a whirlwind tour of the simulators that are included with Qiskit®.
    We have touched on the most basic examples of how to use them when coding your
    quantum programs but have just barely scratched the surface of all of the features
    that are available to you. Go explore, take them for a spin, and see how they
    can be used as tools when developing your real quantum algorithms.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对Qiskit®中包含的模拟器的一次快速浏览。我们简要介绍了如何在编写量子程序时使用它们的最基本示例，但只是刚刚触及了所有可用功能的一角。去探索吧，亲自试一试，看看它们如何在开发你的真实量子算法时作为工具使用。
