<html><head></head><body>
		<div id="_idContainer776">
			<h1 id="_idParaDest-220"><em class="italic"><a id="_idTextAnchor220"/>Chapter 8</em>: Cleaning Up Your Quantum Act with Ignis</h1>
			<p>We have explored running our quantum programs on idealized Qiskit Aer simulators and gotten our hands dirty with the actual IBM Quantum machines. We understand that real qubits are noisy and that we cannot expect quantum computers to solve actual real-world problems of any significant magnitude (yet). On the path to this future application lies ﬁghting and mitigating noise and errors, and on that path lies Qiskit Ignis.</p>
			<p>Qiskit® includes a lot of automation, such as the optimization of the assigned qubits according to connectivity and performance; but this automation is, to an extent, limited by the physical layout of a quantum chip, which controls how the qubits can communicate with each other. By studying the qubit performance and specifying which actual physical qubits you want to use with your quantum programs, you can optimize your circuits for optimal entanglement and decoherence, to name a few examples. </p>
			<p>In this chapter, we will explore how running your programs on different sets of qubits on the same backend might cause you to end up with different results. We will also use the Qiskit Ignis methods to do readout correction on our simpler algorithms on simulated and existing hardware. </p>
			<p>Finally, we will take a look at quantum error correction using the Shor code, seeing how you can create a single logical qubit by using several physical qubits for quantum error correction.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Exploring your qubits to understand T1, T2, errors, and gates</li>
				<li>Comparing the qubits on a chip</li>
				<li>Estimating the number of gates you have time for</li>
				<li>Correcting the expected with readout correction</li>
				<li>Mitigating the unexpected with quantum error correction</li>
			</ul>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor221"/>Technical requirements</h2>
			<p>The quantum programs that we'll discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter08</a>.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor222"/>Exploring your qubits to understand T1, T2, errors, and gates </h1>
			<p>Let's start off<a id="_idIndexMarker600"/> with<a id="_idIndexMarker601"/> a <a id="_idIndexMarker602"/>quick <a id="_idIndexMarker603"/>overview of some things that can go wrong when you send your perfectly working and simulator-verified quantum program to an actual, physical quantum computer. As we have seen, as soon as we step away from our perfect simulated qubits and start using physical qubits that work quantum-mechanically, we also have to contend with another physical feature of reality: noise.</p>
			<p>In a quantum computer, the noise differs between backends, between qubits on a backend, between different types of gates, and between the readouts of each qubit. Building and programming quantum computers really is a complex task.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor223"/>Getting ready</h2>
			<p>The file required for this recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r1_gates_data.py</a>.</p>
			<p>This recipe builds on the work we did in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit® Tools</em>, but this time we are specifically looking at the qubit properties that hint at the many ways that things can go wrong.</p>
			<p>We will be using the <strong class="source-inline">backend.properties()</strong> Qiskit® method to pull out the following properties for qubits:</p>
			<ul>
				<li><strong class="source-inline">t1()</strong>: The T1 or relaxation time for the given qubit</li>
				<li><strong class="source-inline">t2()</strong>: The T2 or dephasing time for the given qubit</li>
				<li><strong class="source-inline">readout_error()</strong>: The risk of misreading the qubit during measurement</li>
				<li><strong class="source-inline">gate_length()</strong>: The duration of the gate in units of seconds</li>
				<li><strong class="source-inline">gate_error()</strong>: The gate error estimate</li>
			</ul>
			<h3>The sample code</h3>
			<ol>
				<li>First, we<a id="_idIndexMarker604"/> import the class that we need and load our account:<p class="source-code">from qiskit import IBMQ</p><p class="source-code">print("Getting providers...")</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>We use <strong class="source-inline">select_backend()</strong> here to load and display the data for the available backends, and then prompt to select one:<p class="source-code">def select_backend():</p><p class="source-code">    # Get all available and operational backends.</p><p class="source-code">    print("Getting backends...")</p><p class="source-code">    available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits &gt; 0 and         b.status().operational)</p><p class="source-code">    # Fish out criteria to compare</p><p class="source-code">    print("{0:20} {1:&lt;10}".format("Name","#Qubits"))</p><p class="source-code">    print("{0:20} {1:&lt;10}".format("----","-------"))        </p><p class="source-code">    for n in range(0, len(available_backends)):</p><p class="source-code">        backend = provider.get_backend(str(            available_backends[n]))</p><p class="source-code">        print("{0:20} {1:&lt;10}".format(        backend.name(),backend.configuration().n_qubits))</p><p class="source-code">    select_backend=input("Select a backend ('exit' to         end): ")</p><p class="source-code">    if select_backend!="exit":</p><p class="source-code">        backend = provider.get_backend(select_backend)</p><p class="source-code">    else:</p><p class="source-code">        backend=select_backend</p><p class="source-code">    return(backend)F</p></li>
				<li>The <strong class="source-inline">display_information(backend)</strong> function retrieves the backend information such as the number of qubits and the qubit coupling map, and then uses that to cycle <a id="_idIndexMarker605"/>through the backend's qubits to retrieve the T1, T1, readout error, and gate information. The function comprises two parts.<p>First, we gather the qubit information:</p><p class="source-code">def display_information(backend):</p><p class="source-code">    basis_gates=backend.configuration().basis_gates</p><p class="source-code">    n_qubits=backend.configuration().n_qubits</p><p class="source-code">    if n_qubits&gt;1:</p><p class="source-code">        coupling_map=backend.configuration().coupling_map</p><p class="source-code">    else:</p><p class="source-code">        coupling_map=[]</p><p class="source-code">    micro=10**6</p><p>Then, we print out the basic qubit information and the qubit-specific information<a id="_idIndexMarker606"/> for each gate:</p><p class="source-code">    for qubit in range(n_qubits):</p><p class="source-code">        print("\nQubit:",qubit)</p><p class="source-code">        print("T1:",int(backend.properties().            t1(qubit)*micro),"\u03BCs")</p><p class="source-code">        print("T2:",int(backend.properties().            t2(qubit)*micro),"\u03BCs")</p><p class="source-code">        print("Readout error:",round(backend.            properties().readout_error(qubit)*100,2),"%")</p><p class="source-code">        for bg in basis_gates:</p><p class="source-code">            if bg!="cx":</p><p class="source-code">                if backend.properties().                   gate_length(bg,[qubit])!=0:</p><p class="source-code">                    print(bg,round(                        backend.properties().gate_                        length(bg,[0])*micro,2),"\                        u03BCs", "Err:",round(backend.                        properties().gate_error(bg,                        [qubit])*100,2),"%") </p><p class="source-code">                else:    </p><p class="source-code">                    print(bg,round(                       backend.properties().gate_                       length(bg,[0])*micro,2),"\                       u03BCs", "Err:",round(backend.                       properties().gate_                       error(bg,[qubit])*100,2),"%")</p><p class="source-code">        if n_qubits&gt;0:</p><p class="source-code">            for cm in coupling_map:</p><p class="source-code">                if qubit in cm:</p><p class="source-code">                    print("cx",cm,round(                       backend.properties().gate_                       length("cx",cm)*micro,2),"\                       u03BCs", "Err:",round(backend.                       properties().gate_                       error("cx",cm)*100,2),"%")</p></li>
				<li>The main function calls the <strong class="source-inline">select_backend()</strong> and <strong class="source-inline">display_information(backend)</strong> functions to help you see all the qubit information for a<a id="_idIndexMarker607"/> selected backend:<p class="source-code">def main():</p><p class="source-code">    backend=select_backend()</p><p class="source-code">    display_information(backend)</p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    main()</p></li>
			</ol>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor224"/>How to do it...</h2>
			<p>To explore the qubit properties of a specific backend, follow these steps:</p>
			<ol>
				<li value="1">In your Python environment, run <strong class="source-inline">ch8_r1_gates_data.py</strong>.<p>The script loads Qiskit® and grabs and displays a list of the available backends as shown here:</p><div class="IMG---Figure" id="_idContainer645"><img alt="Figure 8.1 – Select a backend to investigate&#13;&#10;" src="image/Figure_8.1_B14436.jpg"/></div><p class="figure-caption">Figure 8.1 – Select a backend to investigate</p></li>
				<li>When<a id="_idIndexMarker608"/> prompted, enter <a id="_idIndexMarker609"/>the <a id="_idIndexMarker610"/>name o<a id="_idIndexMarker611"/>f the IBM Quantum® backend that you want to take a look at:<p>We now pull in <strong class="source-inline">backend.properties()</strong> for the selected backend, and from these, sift through and display the following parameters: qubit readout error, T1 and T2 decoherence times, gate length, and error for all the basis gates for the backend. </p><div class="IMG---Figure" id="_idContainer646"><img alt="Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend &#13;&#10;" src="image/Figure_8.2_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.2 – Qubit data for the ibmq_vigo 5-qubit backend </p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor225"/>How it works...</h2>
			<p>That is<a id="_idIndexMarker612"/> a<a id="_idIndexMarker613"/> fair bit<a id="_idIndexMarker614"/> of<a id="_idIndexMarker615"/> data, but it only represents a small piece of the data that can be collected for a specific backend. For a refresher, see the <em class="italic">Exploring a selected backend using Qiskit®</em> recipe in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit® Tools</em>.</p>
			<p>The first pieces<a id="_idIndexMarker616"/> of data that we will touch on are the <strong class="bold">T1</strong> and <strong class="bold">T2</strong> times and the <strong class="bold">readout error</strong>: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer647">
					<img alt="Figure 8.3 – Data for qubit 0&#13;&#10;" src="image/Figure_8.3_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Data for qubit 0</p>
			<p>This first set of data represents the physical reasons that you might not get the results that you expect when you<a id="_idIndexMarker617"/> run your quantum code on the backend:</p>
			<ul>
				<li><strong class="bold">T1</strong>,<strong class="bold"> or relaxation</strong><strong class="bold"><a id="_idIndexMarker618"/></strong><strong class="bold"> time</strong>: The T1 value, displayed as <img alt="" src="image/Formula_008_100.png"/> in <em class="italic">Figure 8.3,</em> is a statistical value of how long it takes for the qubit to spontaneously relax from the "excited" state <img alt="" src="image/Formula_008_001.png"/> to<a id="_idIndexMarker619"/> the ground state <img alt="" src="image/Formula_008_002.png"/>. In essence, T1 is an estimate of the time that you have at your disposal to perform high-quality actions on the qubit. </li>
				<li><strong class="bold">T2</strong>, <strong class="bold">or </strong><strong class="bold"><a id="_idIndexMarker620"/></strong><strong class="bold">dephasing </strong><strong class="bold"><a id="_idIndexMarker621"/></strong><strong class="bold">time:</strong> Similar to T1, the T2 value, displayed as <em class="italic">ms</em> in <em class="italic">Figure 8.3,</em> is a measure of how phase information is lost for a qubit. An example of phase change is <a id="_idIndexMarker622"/>when the state <img alt="" src="image/Formula_008_003.png"/> spontaneously changes to <img alt="" src="image/Formula_008_004.png"/>. Again, if the running time for your circuit starts to approach the T2 time, the quality of your readout data will suffer.</li>
			</ul>
			<p>Now for the rest of the data that we pulled in:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer653">
					<img alt="Figure 8.4 – Data for qubit 0&#13;&#10;" src="image/Figure_8.4_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Data for qubit 0</p>
			<p><strong class="source-inline">readout_error</strong>, <strong class="source-inline">gate_length</strong>, and <strong class="source-inline">gate_error</strong> represent the quality of the gates that you can run on each qubit. </p>
			<ul>
				<li><strong class="source-inline">readout_error</strong>: The readout error rate, displayed as a percentage in <em class="italic">Figure 8.4</em>, is simply the probability that you will get the incorrect value when reading the qubit. For example, a qubit in state <img alt="" src="image/Formula_06_0221.png"/> will be read as <img alt="" src="image/Formula_06_023.png"/> and vice versa. This really has nothing to do with any other qubit manipulations but is simply the error rate for the final readout of the collapsed qubit. It is possible to get a statistical picture of each qubit and mitigate these readout errors. We will do that in the <em class="italic">Correct the expected with readout correction</em> recipe.</li>
				<li><strong class="source-inline">gate_length</strong>: The gate length, displayed as <em class="italic"><img alt="" src="image/Formula_008_100.png"/></em> in <em class="italic">Figure 8.4</em>, represents the time it takes to make the adjustment to the qubit that corresponds to the gate. If you look<a id="_idIndexMarker623"/> at the <a id="_idIndexMarker624"/>data returned, you see<a id="_idIndexMarker625"/> that <a id="_idIndexMarker626"/>the gate length for a U3 gate might be in the order of a twentieth of a microsecond or so, whereas the T1/T2 times might be much longer than that. This, however, doesn't mean that you can just add hundreds or thousands of these gates within that time span and expect the results to be great. This is where gate errors come in.</li>
				<li><strong class="source-inline">gate_error</strong>: The gate error, displayed as a percentage in <em class="italic">Figure 8.4</em>, is a statistical value for how accurate the gate is at executing the expected results. As you can see, the errors range from 0.05% to a few percent. For short circuits of just a few gates, we can run the circuit many times and statistically derive the correct values even with gate errors popping up. For longer circuits, of hundreds or thousands of gates, even these small gate errors start to make an impact. In <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, you will build quantum circuits with hundreds of gates. </li>
			</ul>
			<p>Remember from the <em class="italic">What are the IBM Quantum® machines?</em> recipe in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®</em>, that the gates are not physical things like the bundles of transistors that make up the gates in classical computing. Instead, quantum gate logic constitutes a series of microwave pulses that are sent down to and interact with the cryogenically chilled qubits. The quality of gates thus hinges on quite a few things: the physical properties of the <strong class="bold">Josephson junction</strong> and resonator circuit that constitute the physical qubit, the accuracy of the carrier wave and gate-coded wave package, the microwave resonators, the cryostats, and much more. </p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor226"/>There's more</h2>
			<p>You can also get <a id="_idIndexMarker627"/>to the backend <a id="_idIndexMarker628"/>qubit data from IBM Quantum Experience®.  </p>
			<p>Let's take a look:</p>
			<ol>
				<li value="1">Log in to IBM Quantum Experience® at <a href="https://quantum-computing.ibm.com">https://quantum-computing.ibm.com</a>.</li>
				<li>On the <strong class="bold">Welcome</strong> page, on the right side, you'll see a list of the available backends:<div class="IMG---Figure" id="_idContainer657"><img alt="Figure 8.5 – The IBM Quantum Experience® home page&#13;&#10;" src="image/Figure_3.1_B14436.jpg"/></div><p class="figure-caption">Figure 8.5 – The IBM Quantum Experience® home page</p></li>
				<li>Click on the <a id="_idIndexMarker629"/>backend that you <a id="_idIndexMarker630"/>are interested in, for example, <strong class="source-inline">ibmq_vigo</strong>, to see the chip layout and additional information:<div class="IMG---Figure" id="_idContainer658"><img alt="Figure 8.6 – Details of the ibmq_vigo backend&#13;&#10;" src="image/Figure_8.6_B14436.jpg"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.6 – Details of the ibmq_vigo backend</p></li>
				<li>Click <strong class="bold">Download Calibrations</strong> for <a id="_idIndexMarker631"/>a CSV<a id="_idIndexMarker632"/> file with the qubit information. The downloaded calibration data looks as shown in the following screenshot:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer659">
					<img alt="Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®&#13;&#10;" src="image/Figure_8.7_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Downloaded calibration data from IBM Quantum Experience®</p>
			<p>You can now<a id="_idIndexMarker633"/> bring the data into your<a id="_idIndexMarker634"/> favorite spreadsheet software for further processing as needed.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor227"/>Comparing the qubits on a chip</h1>
			<p>In the previous <a id="_idIndexMarker635"/>recipe, we looked at some of the pieces of information that you can glean about the IBM Quantum® hardware, illustrating the nature of today's NISQ machines. In this recipe, we will show a real comparison between the different qubits of a selected IBM backend.</p>
			<p>We will run the same Bell state quantum program on three different setups: an ideal quantum computer (<strong class="source-inline">qasm_simulator</strong>), the best qubit pair, and the worst qubit pair on a 5-qubit, least busy IBM Quantum® machine.</p>
			<p>We will print and plot the end result to compare the ideal result (<img alt="" src="image/Formula_008_007.png"/> and <img alt="" src="image/Formula_008_008.png"/> at 50%) with the real results (a probabilistic mix of <img alt="" src="image/Formula_008_009.png"/>) to illustrate how today's quantum computers still have a little way to go. </p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor228"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r2_compare_qubits.py</a></p>
			<h3>The sample code</h3>
			<ol>
				<li value="1">First, we import <a id="_idIndexMarker636"/>the classes and methods that we need and load our account. In this recipe, we combine a lot of important concepts from earlier in the book, such as simulators and noise models: <p class="source-code">from qiskit import IBMQ, Aer, QuantumCircuit, ClassicalRegister, QuantumRegister, execute</p><p class="source-code">from qiskit.tools.monitor import job_monitor</p><p class="source-code">from qiskit.visualization import plot_histogram, plot_error_map</p><p class="source-code">from IPython.core.display import display</p><p class="source-code">print("Getting provider...")</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>The <strong class="source-inline">select_backend()</strong> function lets you select an available backend. You can also have the <a id="_idIndexMarker637"/>system pick the least busy one:<p class="source-code">def select_backend():</p><p class="source-code">    # Get all available and operational backends.</p><p class="source-code">    available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits &gt; 1 and         b.status().operational)</p><p class="source-code">    # Fish out criteria to compare</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".        format("Name","#Qubits","Pending jobs"))</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".format("----",        "-------","------------"))        </p><p class="source-code">    for n in range(0, len(available_backends)):</p><p class="source-code">        backend = provider.get_backend(str(            available_backends[n]))</p><p class="source-code">        print("{0:20} {1:&lt;10}".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)</p><p class="source-code">    select_backend=input("Select a backend ('LB' for         least busy): ")</p><p class="source-code">    if select_backend not in ["LB","lb"]:</p><p class="source-code">        backend = provider.get_backend(str(            select_backend))</p><p class="source-code">    else:</p><p class="source-code">        from qiskit.providers.ibmq import least_busy</p><p class="source-code">        backend = least_busy(provider.backends(            filters=lambda b: not b.configuration().            simulator and b.configuration().n_qubits &gt; 1             and b.status().operational))</p><p class="source-code">    print("Selected backend:",backend.status().       backend_name)</p><p class="source-code">    return(backend)</p></li>
				<li>Pull out the best <a id="_idIndexMarker638"/>and worst CX gate performance information, then cycle through the CX gate couplings to find the best and worst performing connection, before returning this information as a <strong class="source-inline">cx_best_worst</strong> list for later usage. We can now take a look at the best and worst performing CX gate information that we stored. To verify that we have collected the correct information, we can display the error map for the backend, and check that the CX connectors really do represent the best and worst: <p class="source-code">def get_gate_info(backend):</p><p class="source-code">    # Pull out the gates information.</p><p class="source-code">    gates=backend.properties().gates</p><p class="source-code">    #Cycle through the CX gate couplings to find the best     # and worst </p><p class="source-code">    cx_best_worst = [[[0,0],1],[[0,0],0]]</p><p class="source-code">    for n in range (0, len(gates)):</p><p class="source-code">        if gates[n].gate ==  "cx":</p><p class="source-code">            print(gates[n].name, ":", gates[n].                parameters[0].name,"=",                 gates[n].parameters[0].value)</p><p class="source-code">            if cx_best_worst[0][1]&gt;gates[n].                parameters[0].value:</p><p class="source-code">                cx_best_worst[0][1]=gates[n].                    parameters[0].value</p><p class="source-code">                cx_best_worst[0][0]=gates[n].qubits</p><p class="source-code">            if cx_best_worst[1][1]&lt;gates[n].                parameters[0].value:</p><p class="source-code">                cx_best_worst[1][1]=gates[n].                    parameters[0].value</p><p class="source-code">                cx_best_worst[1][0]=gates[n].qubits</p><p class="source-code">    print("Best cx gate:", cx_best_worst[0][0], ",",         round(cx_best_worst[0][1]*100,3),"%")</p><p class="source-code">    print("Worst cx gate:", cx_best_worst[1][0], ",",         round(cx_best_worst[1][1]*100,3),"%")</p><p class="source-code">    return(cx_best_worst)</p></li>
				<li>Create two quantum circuits sized for the selected backend. With the qubit information gathered, we can create a quantum program that specifies CX gates for the best and worst qubit pairs. Here is where we use that qubits variable we pulled earlier. First, we build two circuits (<strong class="source-inline">qc_best</strong> and <strong class="source-inline">qc_worst</strong>) that have the correct number of qubits depending on the selected backend. That information is gathered using the <strong class="source-inline">backend.configuration().n_qubits</strong> method. We use the <strong class="source-inline">cx_best_worst</strong> list that we created earlier to place the H and CX gates on the correct<a id="_idIndexMarker639"/> qubits and then print the circuits:<p class="source-code">def create_circuits(backend, cx_best_worst):</p><p class="source-code">    print("Building circuits...")</p><p class="source-code">    q1 = QuantumRegister(backend.configuration().        n_qubits)</p><p class="source-code">    c1 = ClassicalRegister(backend.configuration().        n_qubits)</p><p class="source-code">    qc_best = QuantumCircuit(q1, c1)</p><p class="source-code">    qc_worst = QuantumCircuit(q1, c1)</p><p class="source-code">    </p><p class="source-code">    #Best circuit</p><p class="source-code">    qc_best.h(q1[cx_best_worst[0][0][0]])</p><p class="source-code">    qc_best.cx(q1[cx_best_worst[0][0][0]], q1[cx_best_        worst[0][0][1]])</p><p class="source-code">    qc_best.measure(q1[cx_best_worst[0][0][0]], c1[0])</p><p class="source-code">    qc_best.measure(q1[cx_best_worst[0][0][1]], c1[1])</p><p class="source-code">    print("Best CX:")</p><p class="source-code">    display(qc_best.draw('mpl'))</p><p class="source-code">    </p><p class="source-code">    #Worst circuit</p><p class="source-code">    qc_worst.h(q1[cx_best_worst[1][0][0]])</p><p class="source-code">    qc_worst.cx(q1[cx_best_worst[1][0][0]], q1[cx_best_        worst[1][0][1]])</p><p class="source-code">    qc_worst.measure(q1[cx_best_worst[1][0][0]], c1[0])</p><p class="source-code">    qc_worst.measure(q1[cx_best_worst[1][0][1]], c1[1])</p><p class="source-code">    </p><p class="source-code">    print("Worst CX:")</p><p class="source-code">    display(qc_worst.draw('mpl'))</p><p class="source-code">    </p><p class="source-code">    return(qc_best,qc_worst)</p></li>
				<li>Run the best<a id="_idIndexMarker640"/> and worst circuits on the backend. With all pieces assembled, we can now run the best circuit, followed by the worst. Of course, we also want a benchmark job on the perfect <strong class="source-inline">qasm_simulator</strong> using the same number of qubits as when we ran on the actual backend. Create and run a benchmark circuit on a local simulator. Print the results for the best, worst, and baseline qubit pair and plot the results in a diagram. We can also use the Qiskit® histogram feature to display the results in diagram form for clarity.</li>
				<li>We start by displaying the best and worst CX-pair circuits, and running these on the selected backend:<p class="source-code">def compare_cx(backend,qc_best,qc_worst):</p><p class="source-code">    print("Comparing CX pairs...")</p><p class="source-code">    print("Best CX 2:")</p><p class="source-code">    display(qc_best.draw('mpl'))</p><p class="source-code">    job_best = execute(qc_best, backend, shots=8192)</p><p class="source-code">    job_monitor(job_best)</p><p class="source-code">    print("Worst CX 2:")</p><p class="source-code">    display(qc_worst.draw('mpl'))</p><p class="source-code">    job_worst = execute(qc_worst, backend, shots=8192)</p><p class="source-code">    job_monitor(job_worst)</p></li>
				<li>Then we build a generic CX circuit (Bell circuit), and run this one on the local <strong class="source-inline">qasm_simulator</strong> to get <a id="_idIndexMarker641"/>a baseline result:<p class="source-code">    q = QuantumRegister(backend.configuration().n_qubits)</p><p class="source-code">    c = ClassicalRegister(backend.configuration().        n_qubits)</p><p class="source-code">    qc = QuantumCircuit(q, c)</p><p class="source-code">    qc.h(q[0])</p><p class="source-code">    qc.cx(q[0], q[1])</p><p class="source-code">    qc.measure(q[0], c[0])</p><p class="source-code">    qc.measure(q[1], c[1])</p><p class="source-code">    backend_sim = Aer.get_backend('qasm_simulator')</p><p class="source-code">    job_sim = execute(qc, backend_sim)</p></li>
				<li>Finally, we collect the best, worst, and baseline job results. We then print them and display them together in a diagram for comparison:<p class="source-code">    best_result = job_best.result()</p><p class="source-code">    counts_best  = best_result.get_counts(qc_best)</p><p class="source-code">    print("Best qubit pair:")</p><p class="source-code">    print(counts_best)</p><p class="source-code">    worst_result = job_worst.result()</p><p class="source-code">    counts_worst  = worst_result.get_counts(qc_worst)</p><p class="source-code">    print("Worst qubit pair:")</p><p class="source-code">    print(counts_worst)</p><p class="source-code">    sim_result = job_sim.result()</p><p class="source-code">    counts_sim  = sim_result.get_counts(qc)</p><p class="source-code">    print("Simulated baseline:")</p><p class="source-code">    print(counts_sim)</p><p class="source-code">    display(plot_histogram([counts_best, counts_worst,                            counts_sim],                            title = "Best and worst qubit                            pair for: " + backend.name(),                            legend = ["Best qubit                            pair","Worst qubit                            pair","Simulated baseline"],</p><p class="source-code">                           sort = 'desc',</p><p class="source-code">                           figsize = (15,12),</p><p class="source-code">                           color = ['green',                            'red','blue'],</p><p class="source-code">                           bar_labels = True))</p></li>
				<li>And <a id="_idIndexMarker642"/>finally, the <strong class="source-inline">main</strong> function pulls it all together: <p class="source-code">def main():</p><p class="source-code">    backend=select_backend()</p><p class="source-code">    cx_best_worst=get_gate_info(backend)</p><p class="source-code">    qc_best, qc_worst=create_circuits(backend,         cx_best_worst)</p><p class="source-code">    compare_cx(backend,qc_best,qc_worst)</p><p class="source-code">       </p><p class="source-code">if __name__ == '__main__':</p><p class="source-code">    main()</p></li>
			</ol>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor229"/>How to do it...</h2>
			<p>The IBM Quantum® backends <a id="_idIndexMarker643"/>are actual physical semiconductor circuits, each with slightly different behavior. In addition, the qubits are physically connected to make it possible to directly entangle them the way that you specify in your quantum programs. This type of qubit communication can only take place directly as specified by the coupling map that we looked at in the <em class="italic">Visualizing the backends</em> recipe in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®</em>.</p>
			<p>In this recipe, we extract the error rate for 2-qubit communication from our selected backend. We then pick the best and the worst qubit pairs and run the same quantum program on each pair to see how the outcome of the program differs.</p>
			<p>Let's see how it is done:</p>
			<ol>
				<li value="1">In your Python environment, run <strong class="source-inline">ch8_r3_time.py</strong>. The script loads Qiskit® and grabs and displays a list of the available backends: <div class="IMG---Figure" id="_idContainer663"><img alt="Figure 8.8 – First, we select a backend to test on, such as ibmq_santiago&#13;&#10;" src="image/Figure_8.8_B14436.jpg"/></div><p class="figure-caption">Figure 8.8 – First, we select a backend to test on, such as ibmq_santiago</p><p>Enter the name of a backend that you want to test on or enter <strong class="source-inline">LB</strong> to have the system pick the least busy system for you. </p></li>
				<li>The best and worst CX gate performance information is displayed as a list and as an error map:<div class="IMG---Figure" id="_idContainer664"><img alt="Figure 8.9 – The various CX gate errors for the qubit combinations of ibmq_santiago&#13;&#10;" src="image/Figure_8.9_B14436.jpg"/></div><p class="figure-caption">Figure 8.9 – The various CX gate errors for the qubit combinations of ibmq_santiago</p><p>To verify that we<a id="_idIndexMarker644"/> have collected the correct information, we display the error map for the backend.</p><p>Take a look at the CNOT error rate legend in <em class="italic">Figure 8.10</em> and verify that the CX connectors that we have selected really are the best [1,2] and worst [3,4]: </p><div class="IMG---Figure" id="_idContainer665"><img alt="Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors for ibmq_santiago" src="image/Figure_8.10_B14436.jpg"/></div><p class="figure-caption">Figure 8.10 – Error map showing the best [1,2] and worst [3,4] CX connectors for ibmq_santiago</p></li>
				<li>Two quantum circuits <a id="_idIndexMarker645"/>sized for the selected backend are created and displayed. These circuits represent the best and the worst CX connections for the backend.<p>The best Bell circuit for the backend is shown in the next figure:</p><div class="IMG---Figure" id="_idContainer666"><img alt="Figure 8.11 – A Bell-state circuit for the best performing CX gate&#13;&#10;" src="image/Figure_8.11_B14436.jpg"/></div><p class="figure-caption">Figure 8.11 – A Bell-state circuit for the best performing CX gate</p><p>The worst Bell circuit for the backend is shown in the following figure:</p><div class="IMG---Figure" id="_idContainer667"><img alt="Figure 8.12 – A Bell-state circuit for the worst-performing CX gate&#13;&#10;" src="image/Figure_8.12_B14436.jpg"/></div><p class="figure-caption">Figure 8.12 – A Bell-state circuit for the worst-performing CX gate</p><p>If you, like me, are <a id="_idIndexMarker646"/>curious about what the transpiled circuit that we will run on the backend actually looks like, you can test-transpile the circuits by adding a test transpilation right after you create the circuits in <strong class="source-inline">create_circuits()</strong>; something like this:</p><p class="source-code">...</p><p class="source-code">trans_qc_best = transpile(qc_best, backend)</p><p class="source-code">print("Transpiled qc_best circuit:")</p><p class="source-code">display(trans_qc_best.draw())</p><p class="source-code">...</p><p>The result of the preceding code will be something like this:</p><div class="IMG---Figure" id="_idContainer668"><img alt="Figure 8.13 – A transpiled Bell-state circuit for the best performing CX gate&#13;&#10;" src="image/Figure_8.13_B14436.jpg"/></div><p class="figure-caption">Figure 8.13 – A transpiled Bell-state circuit for the best performing CX gate</p><p>As you can see, when we follow the qubit coupling map, our transpiled CX circuit looks<a id="_idIndexMarker647"/> exactly like the original circuit.</p></li>
				<li>We now run the best and worst circuits on the backend together with a baseline execution of the same circuit on the Aer simulator: <div class="IMG---Figure" id="_idContainer669"><img alt="Figure 8.14 – The results of the best, worst, and benchmark CX gate pairs&#13;&#10;" src="image/Figure_8.14_B14436.jpg"/></div><p class="figure-caption">Figure 8.14 – The results of the best, worst, and benchmark CX gate pairs</p></li>
				<li>And finally, we plot the results in a diagram for comparison:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer670">
					<img alt="Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago backend&#13;&#10;" src="image/Figure_8.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – The benchmark, best, and worst results on the 5-qubit ibmq_santiago backend</p>
			<p>You now have a visual <a id="_idIndexMarker648"/>view, as well as numerical evidence that the qubits and gates on a chip differ in performance.</p>
			<p>Take a look at the results here. We expect the simulated baseline (blue bars) to return perfect results for <img alt="" src="image/Formula_008_007.png"/> and <img alt="" src="image/Formula_008_008.png"/> only at the expected 50/50 spread. Note how there are no blue <img alt="" src="image/Formula_008_012.png"/> and <img alt="" src="image/Formula_008_013.png"/> results for the simulator.</p>
			<p>On a real machine, the results are affected by qubit errors, as can be seen in the red (worst) and<a id="_idIndexMarker649"/> green (best) bars, with the IBM backends to return noisy results for all combinations <img alt="" src="image/Formula_008_014.png"/>, with the best qubit pair slightly less noisy than the worst pair.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor230"/>There's more...</h2>
			<p>Keep in mind that the <a id="_idIndexMarker650"/>results that you see are not just based on the CNOT coupling error, but also on qubit errors and read and write errors for your qubits. To completely understand the results of runs like these, you need to consider error mitigation. </p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor231"/>See also</h2>
			<ul>
				<li><em class="italic">Qiskit Backend Specifications for OpenQASM and OpenPulse Experiments: </em><a href="https://arxiv.org/pdf/1809.03452.pdf">https://arxiv.org/pdf/1809.03452.pdf</a>.</li>
			</ul>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor232"/>Estimating the number of gates you have time for</h1>
			<p>In addition to the<a id="_idIndexMarker651"/> gate errors that we have explored in the first two recipes, the end result of your recipes depends on another physical aspect of the qubits that we run on: the T1 and T2 times. We first discussed these in the <em class="italic">Explore your qubits to understand T1, T2, and errors</em> recipe:</p>
			<ul>
				<li><strong class="bold">T1</strong>, or <strong class="bold">relaxation time</strong>: The T1 value is a statistical value of how long it takes for the qubit to spontaneously relax from the "excited" state <img alt="" src="image/Formula_008_015.png"/> to the ground state <img alt="" src="image/Formula_008_016.png"/>. In essence, T1 is the upper limit, in microseconds, that you have at your disposal to perform high-quality actions on the qubit. </li>
				<li><strong class="bold">T2</strong>, or <strong class="bold">dephasing time</strong>: Similar to T1, the T2 value is a statistical measure of how phase information is lost for a qubit. An example of phase change is when the state <img alt="" src="image/Formula_008_003.png"/> spontaneously changes to <img alt="" src="image/Formula_008_018.png"/>. Again, if the running time for your circuit starts to approach the T2 time, the quality of your readout data will suffer.</li>
			</ul>
			<p>With this data, we can make a rough estimate of how the size of our programs might affect the end result. Not only do we have to take into account the error rates for the individual gates but we have to also understand how the T1/T2 times limit the number of gates that can <a id="_idIndexMarker652"/>actually be run. How many gates can we squeeze into our programs before they just return garbage? Let's take a look.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor233"/>Getting ready</h2>
			<p>The file required in the following recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r3_time.py</a>.</p>
			<h3>The sample code </h3>
			<ol>
				<li value="1">First, we import the class that we need and load our account. In this recipe, we combine a lot of important concepts from earlier in the book, such as simulators and noise models: <p class="source-code">from qiskit import Aer, IBMQ, QuantumCircuit, execute</p><p class="source-code">from qiskit.providers.aer.noise import NoiseModel</p><p class="source-code">from qiskit.tools.visualization import plot_histogram</p><p class="source-code">from qiskit.tools.monitor import job_monitor</p><p class="source-code">from IPython.core.display import display</p><p class="source-code">print("Getting providers...")</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>The <strong class="source-inline">select_backend()</strong> function lets you select an available backend:<p class="source-code">def select_backend():</p><p class="source-code">    # Get all available and operational backends.</p><p class="source-code">    print("Getting backends...")</p><p class="source-code">    available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits &gt; 0 and         b.status().operational)</p><p class="source-code">    # Fish out criteria to compare</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".        format("Name","#Qubits","Pending jobs"))</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".format("----",       "-------","------------"))</p><p class="source-code">    for n in range(0, len(available_backends)):</p><p class="source-code">        backend = provider.get_backend(str(            available_backends[n]))</p><p class="source-code">        print("{0:20} {1:&lt;10}".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)</p><p class="source-code">    select_backend=input("Select a backend:\n")</p><p class="source-code">    backend = provider.get_backend(select_backend)</p><p class="source-code">    return(backend)</p></li>
				<li>When passed an<a id="_idIndexMarker653"/> IBM Quantum® backend name, the <strong class="source-inline">display_information(backend,n_id,ttype)</strong> function pulls the T1, T2, readout error, and length of an <strong class="source-inline">id</strong> gate for qubit 0 of that backend:<p class="source-code">def display_information(backend,n_id,ttype):</p><p class="source-code">    micro=10**6</p><p class="source-code">    qubit=0</p><p class="source-code">    T1=int(backend.properties().t1(qubit)*micro)</p><p class="source-code">    T2=int(backend.properties().t2(qubit)*micro)</p><p class="source-code">    id_len=backend.properties().        gate_length("id",[0])*micro</p><p class="source-code">    if ttype=="T1":</p><p class="source-code">        T=T1</p><p class="source-code">    else:</p><p class="source-code">        T=T2</p><p class="source-code">    print("\nBackend data:")</p><p class="source-code">    print("\nBackend online since:",backend.        configuration().online_date.strftime('%Y-%m-%d'))</p><p class="source-code">    print("Qubit:",qubit)</p><p class="source-code">    print("T1:",T1,"\u03BCs")</p><p class="source-code">    print("T2:",T2,"\u03BCs")</p><p class="source-code">    print("Readout error:",round(backend.properties().        readout_error(qubit)*100,2),"%")</p><p class="source-code">    print("Qubit",qubit,"Id length:",round(id_len,3),        "\u03BCs") </p><p class="source-code">    print(ttype,"-id =", round(T-n_id*id_len,2),        "\u03BCs",int((100*n_id*id_len)/T),"%")</p><p class="source-code">    return(T)</p></li>
				<li>The <strong class="source-inline">build_circuit(ttype,n_id)</strong> function <a id="_idIndexMarker654"/>takes a number and builds a basic circuit that includes that amount of Id gates. It starts the circuit with an X gate to place the qubit in the <img alt="" src="image/Formula_008_015.png"/>, or excited state. The purpose of the circuit is to wait for a period of time and then measure the qubit, and the Id gate is perfect for the job; it doesn't perform any qubit manipulation, but still takes a certain amount of time to execute. If we have waited long enough, the qubit will spontaneously relax down to the ground state, or <img alt="" src="image/Formula_008_016.png"/>. This will require more or less gates depending on the T1 value for the qubit.<p>Depending on the value of the <strong class="source-inline">ttype</strong> parameter, we will build one of the following:</p><p><strong class="source-inline">T1</strong>: Set up a simple circuit that puts the qubit in state <img alt="" src="image/Formula_008_021.png"/>, then add a number of Id gates to make time pass, and finally perform the measurement of the outcome at different <a id="_idIndexMarker655"/>circuit lengths. </p><p><strong class="source-inline">T2</strong>: Similarly, set up a simple circuit that puts the qubit in state <img alt="" src="image/Formula_008_015.png"/>, then in superposition <img alt="" src="image/Formula_008_003.png"/> with phase <img alt="" src="image/Formula_008_024.png"/>. Then add a number of Id gates to make time pass, and finally apply another H gate and measure. If the qubit is still in <img alt="" src="image/Formula_008_003.png"/>, it will now measure as <img alt="" src="image/Formula_008_015.png"/>, but if it has spontaneously changed phase, approaching <img alt="" src="image/Formula_008_018.png"/>, it will read as <img alt="" src="image/Formula_008_016.png"/> with a certain probability:</p><p class="source-code">def build_circuit(ttype,n_id):</p><p class="source-code">    qc = QuantumCircuit(1,1)</p><p class="source-code">    qc.x(0)</p><p class="source-code">    if ttype in ["T2","t2"]:</p><p class="source-code">        qc.h(0)</p><p class="source-code">    for n in range(int(n_id)):</p><p class="source-code">        qc.id(0)</p><p class="source-code">        qc.barrier(0)</p><p class="source-code">    if ttype in ["T2","t2"]:</p><p class="source-code">        qc.h(0)</p><p class="source-code">    qc.measure(0,0)</p><p class="source-code">    return(qc)</p></li>
				<li>If we run the circuit on a simulator, we use the <strong class="source-inline">build_noisemodel(backend)</strong> function to build a noise model for the selected backend. We then use the noise model in <strong class="source-inline">execute_circuit()</strong> to simulate running the circuit on the actual backend:<p class="source-code">def build_noise_model(backend):</p><p class="source-code">    print("Building noise model...")</p><p class="source-code">    # Construct the noise model from backend</p><p class="source-code">    noise_model = NoiseModel.from_backend(backend)</p><p class="source-code">    return(noise_model)</p></li>
				<li>With the <strong class="source-inline">execute_circuit(backend, circuit,noise_model, n_id)</strong> function, we <a id="_idIndexMarker656"/>run the circuit on a simulated version of the selected backend by using the noise model we created in <strong class="source-inline">build_noisemodel()</strong>: <p class="source-code">def execute_circuit(backend, circuit,noise_model, n_id):</p><p class="source-code">    # Basis gates for the noise model</p><p class="source-code">    basis_gates = noise_model.basis_gates</p><p class="source-code">    # Coupling map</p><p class="source-code">    coupling_map = backend.configuration().coupling_map </p><p class="source-code">    # Execute noisy simulation on QASM simulator and get     # counts</p><p class="source-code">    noisy_counts = execute(circuit,         Aer.get_backend('qasm_simulator'),         noise_model=noise_model, coupling_map=coupling_        map, basis_gates=basis_gates).result().get_        counts(circuit)</p><p class="source-code">    return(noisy_counts)</p></li>
				<li>The <strong class="source-inline">main</strong> function can be broken up into a set of processes, starting with the input and information<a id="_idIndexMarker657"/> section:<p class="source-code">def main():</p><p class="source-code">    # Set the time type</p><p class="source-code">    ttype="T1"</p><p class="source-code">    # Select the backend to simulate or run on</p><p class="source-code">    backend=select_backend()</p><p class="source-code">    back_sim=input("Enter Q to run on the selected         backend, S to run on the simulated backend:\n")</p><p class="source-code">    if back_sim in ["Q","q"]:</p><p class="source-code">        sim=False</p><p class="source-code">    else:</p><p class="source-code">        sim=True</p><p class="source-code">        noise_model=build_noise_model(backend)</p><p class="source-code">    n_id=int(input("Number of id gates:\n"))</p><p class="source-code">    t=display_information(backend,n_id,ttype)</p><p class="source-code">    qc=build_circuit(ttype,n_id)  </p><p class="source-code">    # Print sample circuit</p><p class="source-code">    print("\nSample 5-Id gate",ttype,"circuit:")</p><p class="source-code">    display(build_circuit(ttype,5).draw('mpl'))</p><p>With all input, noise model, and initial circuit creation taken care of, we can now run the circuit on a pure simulator and then on the selected backend, either simulated or on IBM Quantum®. We store our results in an <strong class="source-inline">entry</strong> dictionary, and the lengths of the executed circuits in a <strong class="source-inline">legend</strong> array, then use them to present the<a id="_idIndexMarker658"/> results:</p><p class="source-code">    job = execute(qc, backend=Aer.get_backend(       'qasm_simulator'), shots=8192)</p><p class="source-code">    results = job.result()</p><p class="source-code">    sim_counts = results.get_counts()</p><p class="source-code">    print("\nRunning:")</p><p class="source-code">    print("Results for simulator:",sim_counts)</p><p class="source-code">    # Run the circuit</p><p class="source-code">    entry={'sim':sim_counts}</p><p class="source-code">    legend=['sim']</p><p class="source-code">    length=n_id</p><p class="source-code">    while length!=0:</p><p class="source-code">        qc=build_circuit(ttype,length)</p><p class="source-code">        if sim:</p><p class="source-code">            noisy_counts=execute_circuit(backend,qc,                noise_model,length)</p><p class="source-code">        else:</p><p class="source-code">            job = execute(qc, backend=backend,                shots=8192)</p><p class="source-code">            job_monitor(job)</p><p class="source-code">            results = job.result()</p><p class="source-code">            noisy_counts = results.get_counts()</p><p class="source-code">        print("Results for",length,"Id gates:",            noisy_counts)</p><p class="source-code">        entry.update({str(length):noisy_counts})</p><p class="source-code">        legend.append(str(length))</p><p class="source-code">        length=int(length/4)</p></li>
				<li>Finally, we merge the results from the results dictionary into a <strong class="source-inline">results_array</strong> array, matching the lengths from the <strong class="source-inline">legend</strong> array, then display all the results<a id="_idIndexMarker659"/> in a combined diagram:<p class="source-code">    results_array=[]</p><p class="source-code">    for i in legend:</p><p class="source-code">        results_array.append(entry[i])</p><p class="source-code">    # Display the final results</p><p class="source-code">    title="ID-circuits on "+str(backend)+" with         "+ttype+"= "+str(t)+" \u03BCs"</p><p class="source-code">    if sim:</p><p class="source-code">        title+=" (Simulated)"</p><p class="source-code">    title+=" \nOnline since: "+str(backend.        configuration().online_date.strftime('%Y-%m-%d'))</p><p class="source-code">    display(plot_histogram(results_array, legend=legend,         title=title))</p></li>
			</ol>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor234"/>How to do it...</h2>
			<p>To explore how a qubit relaxes from the excited <img alt="" src="image/Formula_06_023.png"/> state to the ground state <img alt="" src="image/Formula_06_0221.png"/>, follow these steps:</p>
			<ol>
				<li value="1">In your Python environment, run <strong class="source-inline">ch8_r3_time.py</strong>.<p>The script loads Qiskit® and grabs and displays a list of the available backends. Enter the name of a backend that you want to test on, then enter <strong class="source-inline">S</strong> to run on a noise-simulated version of the backend. Finally, enter the number of Id gates that you <a id="_idIndexMarker660"/>want to include in your circuit, for example, <strong class="source-inline">1024</strong>:</p><div class="IMG---Figure" id="_idContainer692"><img alt="Figure 8.16 – Select a backend, whether to run on the actual backend, and enter a number of Id gates&#13;&#10;" src="image/Figure_8.16_B14436.jpg"/></div><p class="figure-caption">Figure 8.16 – Select a backend, whether to run on the actual backend, and enter a number of Id gates</p></li>
				<li>Various pieces of data for the first qubit of the selected backend are displayed. We are particularly interested in the T1 value and the Id gate length. From these, we can estimate how long our circuit will take to run, and the percentage of the T1 time that will be consumed. We are not particularly concerned about gate errors; the Id gate does not do any qubit manipulation but is really only a delay gate: <div class="IMG---Figure" id="_idContainer693"><img alt="Figure 8.17 – The backend data&#13;&#10;" src="image/Figure_8.17_B14436.jpg"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 8.17 – The backend data</p></li>
				<li>We also display <a id="_idIndexMarker661"/>a representative sample circuit with five Id gates. Your actual circuit will be much, much bigger, but with the same architecture; a long string of barriers and Id gates:<div class="IMG---Figure" id="_idContainer694"><img alt="Figure 8.18 – Sample Id-circuit&#13;&#10;" src="image/Figure_8.18_B14436.jpg"/></div><p class="figure-caption">Figure 8.18 – Sample Id-circuit</p></li>
				<li>The circuit now runs, first on the build in the Qiskit Aer <strong class="source-inline">qasm_simulator</strong> for a clean result, then on the simulated or actual backend. It starts with a circuit with the selected number of Id gates, and then runs successively shorter circuits until it reaches a circuit with just one Id gate: <div class="IMG---Figure" id="_idContainer695"><img alt="Figure 8.19 – Raw T1 results on the simulated ibmq_valencia backend&#13;&#10;" src="image/Figure_8.19_B14436.jpg"/></div><p class="figure-caption">Figure 8.19 – Raw T1 results on the simulated ibmq_valencia backend</p></li>
				<li>Finally, it collects <a id="_idIndexMarker662"/>and displays the results of all the runs in one diagram:<div class="IMG---Figure" id="_idContainer696"><img alt="Figure 8.20 – T1 results on the simulated ibmq_valencia backend &#13;&#10;" src="image/Figure_8.20_B14436.jpg"/></div></li>
			</ol>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.20 – T1 results on the simulated ibmq_valencia backend </p>
			<p>Alright, so what do these results mean? Let's take a look…</p>
			<p>As you can see, the probability of getting the result <img alt="" src="image/Formula_06_023.png"/> gets lower and lower as the number of gates increases. At 1,024 gates, we are down to roughly 70%, which is pretty close to just noise. Try doubling the number of gates to 2,048 and see if the curve lands you somewhere close to 50% or so. So, where do you need to be to have a stab at actually getting good results from your circuits? Take a look at <em class="italic">Figure 8.20</em> again – this time, at the 1 Id gate circuit end. The probability of getting the result <img alt="" src="image/Formula_06_139.png"/> hovers around 93-95%, and a bit of the uncertainty here comes from the readout error, which in our case was around 3.5%. This hints at a max circuit length of around 64 Id gates before things start to go wrong.</p>
			<p>Also remember that this measurement only takes into account the T1 relaxation time, and only really measures the performance of the qubit at various circuit lengths, only using Id gates, which are not really useful for building actual quantum circuits. </p>
			<p>For actual, useful <a id="_idIndexMarker663"/>circuits, we also need to take into account other factors such as gate errors, transpiling architecture, and more. This means that you cannot just extrapolate the circuit count you deem OK quality-wise from this experiment and set that as your gate limit for a backend. Take a look back at the <em class="italic">Comparing the Qiskit Aer simulator with an IBM quantum computer</em> recipe in <a href="B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197"><em class="italic">Chapter 7</em></a>, <em class="italic">Simulating Quantum Computers with Aer</em>, for a rudimentary example of what gate errors can do in long circuits.</p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor235"/>There's more</h2>
			<p>After this first run-through, you can test a couple of other scenarios, as discussed next.</p>
			<h3>Comparing backends</h3>
			<p>Try running identical <a id="_idIndexMarker664"/>circuits on different backends to see how the results differ. IBM Quantum® is hard at work—developing better and better qubits and control circuitry and you can see how progressively newer backends generally have longer T1/T2 times, and better performing qubits. You can estimate how old a backend is by looking at the <strong class="bold">online since</strong> dates in <em class="italic">Figure 8.21</em>.</p>
			<p>Here, for example, are the results of the 1,024 Id gate circuit on the <strong class="source-inline">ibmqx2</strong> backend, which came online in January 2017. Compare these to the <strong class="source-inline">ibmq_valencia</strong> results that we just obtained. That backend has been online since July 2019:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer699">
					<img alt="Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1&#13;&#10;" src="image/Figure_8.21_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Results on ibmqx2, an older backend with a shorter T1</p>
			<p>By comparing the data in <em class="italic">Figure 8.20</em> (<strong class="source-inline">ibmq_valencia</strong>) with the data in <em class="italic">Figure 8.21</em> (<strong class="source-inline">ibmqx2</strong>), you can see that the T1 time is more than twice as long for the newer <strong class="source-inline">ibmq_valencia</strong> backend and that the probability of getting the correct result after 1,024 Id gates is <a id="_idIndexMarker665"/>much higher (70% versus 46%).</p>
			<h3>Running on an IBM Quantum<span class="superscript">®</span> backend</h3>
			<p>Now, test running the<a id="_idIndexMarker666"/> same test on the actual backend by running the sample script <strong class="source-inline">ch8_r3_time.py</strong> again and entering <strong class="source-inline">Q</strong> when prompted. </p>
			<p class="callout-heading">Pick a suitable backend</p>
			<p class="callout">As we will be running about half a dozen individual jobs or so, the complete run might take some time depending on the number of users that are running jobs on the backend. Before you pick a backend to run on, check the <strong class="bold">pending jobs</strong> number for the backend.</p>
			<p>When running on the actual backend, the job monitor provides information about your place in the queue. For the backend <strong class="source-inline">ibmq_valencia</strong>, this might give the following result: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer700">
					<img alt="Figure 8.22 – Raw T1 results on the ibmq_valencia backend&#13;&#10;" src="image/Figure_8.22_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22 – Raw T1 results on the ibmq_valencia backend</p>
			<p>Plotted side by<a id="_idIndexMarker667"/> side, you get a visual comparison: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer701">
					<img alt="Figure 8.23 – T1 results on the ibmq_valencia backend&#13;&#10;" src="image/Figure_8.23_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23 – T1 results on the ibmq_valencia backend</p>
			<p>See how the qubit relaxes from <img alt="" src="image/Formula_008_033.png"/> as the number of Id gates increases, and thus the <em class="italic">wait</em> time gets longer. Note how the actual backend results match the simulated results pretty well. </p>
			<h3>Testing T2 dephasing</h3>
			<p>You can also<a id="_idIndexMarker668"/> test the T2 value – how your qubit dephases – by changing the type parameter from <strong class="source-inline">"T1"</strong> to <strong class="source-inline">"T2"</strong> in the sample code:</p>
			<p class="source-code"># Main </p>
			<p class="source-code">def main():</p>
			<p class="source-code">    # Set the time type</p>
			<p class="source-code">    ttype="T2"</p>
			<p>How is the sample circuit different in this case? As the T2 time measures dephasing, we must first set up our qubit to actually have phase information. We start off our circuit with an X gate, putting our qubit in the <img alt="" src="image/Formula_06_023.png"/> state. We then add an H gate, which brings the qubit to the <img alt="" src="image/Formula_008_035.png"/> state, which is the same as the <img alt="" src="image/Formula_008_036.png"/> state phase-shifted by <img alt="" src="image/Formula_008_037.png"/> radians: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer707">
					<img alt="Figure 8.24 – The T2 circuit includes H gates to place our qubit in the  state, with a  phase" src="image/Figure_8.24_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24 – The T2 circuit includes H gates to place our qubit in the <img alt="" src="image/Formula_008_035.png"/> state, with a <img alt="" src="image/Formula_008_039.png"/> phase</p>
			<p>We then let time pass, giving the qubit the opportunity to dephase a bit from the initial <img alt="" src="image/Formula_008_040.png"/> phase, before adding another H gate to bring us back to the computational basis so that we can measure the qubit:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer711">
					<img alt="Figure 8.25 – T2 results on the ibmqx2 backend&#13;&#10;" src="image/Figure_8.25_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25 – T2 results on the ibmqx2 backend</p>
			<p>By looking at <em class="italic">Figure 8.25</em> and <em class="italic">Figure 8.21</em>, you can now get a complete picture of the T1 and T2 impact on <a id="_idIndexMarker669"/>your qubit. Try running with even more Id gates to see how the behavior changes.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor236"/>See also</h2>
			<p>For a much more detailed description of T1 and T2 and how to measure it, take a look at <em class="italic">Learn Quantum Computing with Python and IBM Quantum Experience</em>, <em class="italic">Chapter 11</em>, <em class="italic">Mitigating Quantum Errors Using Ignis</em>, by Robert Loredo, Packt, 2020.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor237"/>Correcting for the expected with readout correction</h1>
			<p>Now that we have<a id="_idIndexMarker670"/> some knowledge about <a id="_idIndexMarker671"/>what might go wrong when we use our qubits for quantum calculations, is there anything that we can do about it? There are essentially two approaches here, at least for the small quantum backends that we have at our disposal. </p>
			<p>First, we can make sure that the quantum programs that we run have a fighting chance of completing before the qubits get lost due to decoherence, the T1 and T2 times that we explored. This means that we make the programs short.</p>
			<p>Second, we can take a good look at various readout errors and see if we can mitigate those. If you remember in <a href="B14436_07_Final_PG_ePub.xhtml#_idTextAnchor197"><em class="italic">Chapter 7</em></a>, <em class="italic">Simulating Quantum Computers with Aer</em>, we could pull in actual <a id="_idIndexMarker672"/>backend qubit data to <strong class="source-inline">qasm_simulator</strong> and have it behave like an NISQ backend. We can do the same in reverse, analyze the measurement errors for a backend, and use that data to create a mitigation map to counteract erroneous measurements. </p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor238"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r4_ignis.py</a>.</p>
			<h3>The sample code</h3>
			<p>To handle the creation <a id="_idIndexMarker673"/>and running of the readout correction, we build a number of functions in the <strong class="source-inline">ch8_r4_ignis.py</strong> script:</p>
			<ol>
				<li value="1">First, we import the classes and methods that we need. You can import Qiskit® and load the account by running the following code:<p class="source-code">from qiskit import Aer, IBMQ, QuantumRegister, execute</p><p class="source-code">from qiskit import QuantumCircuit</p><p class="source-code">from qiskit.tools.visualization import plot_histogram</p><p class="source-code">from qiskit.tools.monitor import job_monitor</p><p class="source-code">from IPython.core.display import display</p><p class="source-code">print("Getting providers...")</p><p class="source-code">if not IBMQ.active_account():</p><p class="source-code">    IBMQ.load_account()</p><p class="source-code">provider = IBMQ.get_provider()</p></li>
				<li>Using <strong class="source-inline">select_backend()</strong>, we load and display the data for the available backends, and<a id="_idIndexMarker674"/> then prompt to select one:<p class="source-code">def select_backend():</p><p class="source-code">    # Get all available and operational backends.</p><p class="source-code">    available_backends = provider.backends(filters=lambda         b: not b.configuration().simulator and         b.configuration().n_qubits &gt; 1 and         b.status().operational)</p><p class="source-code">    # Fish out criteria to compare</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".        format("Name","#Qubits","Pending jobs"))</p><p class="source-code">    print("{0:20} {1:&lt;10} {2:&lt;10}".format("----",        "-------","------------"))        </p><p class="source-code">    for n in range(0, len(available_backends)):</p><p class="source-code">        backend = provider.get_backend(str(            available_backends[n]))</p><p class="source-code">        print("{0:20} {1:&lt;10}".format(backend.            name(),backend.configuration().            n_qubits),backend.status().pending_jobs)</p><p class="source-code">    select_backend=input("Select a backend ('exit' to         end): ")</p><p class="source-code">    if select_backend!="exit":</p><p class="source-code">        backend = provider.get_backend(select_backend)</p><p class="source-code">    else:</p><p class="source-code">        backend=select_backend</p><p class="source-code">    return(backend)</p></li>
				<li>Using <strong class="source-inline">create_circuit()</strong>, we create a basic GHZ-state circuit for which we know the expected outcomes – <img alt="" src="image/Formula_008_041.png"/>:<p class="source-code">def create_circuit():</p><p class="source-code">     #Create the circuit</p><p class="source-code">    circuit = QuantumCircuit(3)</p><p class="source-code">    circuit.h(0)</p><p class="source-code">    circuit.cx(0,1)</p><p class="source-code">    circuit.cx(0,2) </p><p class="source-code">    circuit.measure_all()</p><p class="source-code">    print("Our circuit:")</p><p class="source-code">    display(circuit.draw('mpl'))</p><p class="source-code">    return(circuit)</p></li>
				<li><strong class="source-inline">simulator_results(circuit)</strong> runs<a id="_idIndexMarker675"/> the provided circuit on the local Qiskit Aer simulator:<p class="source-code">def simulator_results(circuit):</p><p class="source-code">    # Run the circuit on the local simulator</p><p class="source-code">    job = execute(circuit, backend=Aer.get_backend(        'qasm_simulator'), shots=8192)</p><p class="source-code">    job_monitor(job)</p><p class="source-code">    results = job.result()</p><p class="source-code">    sim_counts = results.get_counts()</p><p class="source-code">    print("Simulator results:\n",sim_counts)</p><p class="source-code">    return(sim_counts)</p></li>
				<li><strong class="source-inline">noisy_results(circuit,backend)</strong> runs the provided circuit on the provided backend:<p class="source-code">def noisy_results(circuit,backend):</p><p class="source-code">    # Select backend and run the circuit</p><p class="source-code">    job = execute(circuit, backend=backend, shots=8192)</p><p class="source-code">    job_monitor(job)</p><p class="source-code">    results = job.result()</p><p class="source-code">    noisy_counts = results.get_counts()</p><p class="source-code">    print(backend,"results:\n",noisy_counts)</p><p class="source-code">    return(noisy_counts,results)</p></li>
				<li>This <strong class="source-inline">mitigated_results(backend,circuit,results)</strong> function is the main<a id="_idIndexMarker676"/> function we build to run error mitigation on the provided results, based on backend measurement error data:<p class="source-code">def mitigated_results(circuit,backend,results):</p><p class="source-code">    # Import the required methods</p><p class="source-code">    from qiskit.providers.aer.noise import NoiseModel</p><p class="source-code">    from qiskit.ignis.mitigation.measurement import         (complete_meas_cal,CompleteMeasFitter)</p><p class="source-code">    # Get noise model for backend</p><p class="source-code">    noise_model = NoiseModel.from_backend(backend)</p><p class="source-code">    # Create the measurement fitter</p><p class="source-code">    qr = QuantumRegister(circuit.num_qubits)</p><p class="source-code">    meas_calibs, state_labels = complete_meas_cal(qr=qr,         circlabel='mcal')</p><p class="source-code">    job = execute(meas_calibs, backend=Aer.get_        backend('qasm_simulator'), shots=8192,         noise_model=noise_model)</p><p class="source-code">    cal_results = job.result()</p><p class="source-code">    meas_fitter = CompleteMeasFitter(cal_results,         state_labels, circlabel='mcal')</p><p class="source-code">    # Plot the calibration matrix</p><p class="source-code">    print("Calibration matrix")</p><p class="source-code">    meas_fitter.plot_calibration()</p><p class="source-code">    # Get the filter object</p><p class="source-code">    meas_filter = meas_fitter.filter</p><p class="source-code">    # Results with mitigation</p><p class="source-code">    mitigated_results = meas_filter.apply(results)</p><p class="source-code">    mitigated_counts = mitigated_results.get_counts(0)</p><p class="source-code">    print("Mitigated",backend,"results:\n",        mitigated_counts)</p><p class="source-code">    return(mitigated_counts)</p></li>
				<li>And finally, the <strong class="source-inline">main()</strong> function<a id="_idIndexMarker677"/> helps in wrapping up the function flow and final data presentation:<p class="source-code">def main():</p><p class="source-code">   backend=select_backend()</p><p class="source-code">   circ=create_circuit()</p><p class="source-code">   sim_counts=simulator_results(circ)</p><p class="source-code">   noisy_counts,results=noisy_results(circ,backend)</p><p class="source-code">   # Analyze and error correct the measurements</p><p class="source-code">   mitigated_counts=mitigated_results(circ,backend,        results)</p><p class="source-code">   # Show all results as a comparison</p><p class="source-code">   print("Final results:")</p><p class="source-code">   display(plot_histogram([sim_counts, noisy_counts,         mitigated_counts], legend=['sim','noisy',         'mitigated']))</p></li>
			</ol>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor239"/>How to do it…</h2>
			<ol>
				<li value="1">In your local Qiskit® <a id="_idIndexMarker678"/>environment, run the <strong class="source-inline">ch8_r4_ignis.py</strong> sample, then select one of the available backends to test on:<div class="IMG---Figure" id="_idContainer713"><img alt="Figure 8.26 – Select an available backend&#13;&#10;" src="image/Figure_8.26_B14436.jpg"/></div><p class="figure-caption">Figure 8.26 – Select an available backend</p></li>
				<li>We'll now build the GHZ-state circuit that we will be testing with. We know that the expected outcomes are <img alt="" src="image/Formula_008_043.png"/>, and can use that information to validate how well our circuit runs on the selected backend, and how well we can error correct:<div class="IMG---Figure" id="_idContainer715"><img alt="Figure 8.27 – The GHZ-state circuit that we will test with&#13;&#10;" src="image/Figure_8.27_B14436.jpg"/></div><p class="figure-caption">Figure 8.27 – The GHZ-state circuit that we will test with</p></li>
				<li>The script now runs<a id="_idIndexMarker679"/> the circuit on a local simulator and on the selected backend:<div class="IMG---Figure" id="_idContainer716"><img alt="Figure 8.28 – Results on the local qasm_simulator and on the ibmqx2 backend&#13;&#10;" src="image/Figure_8.28_B14436.jpg"/></div><p class="figure-caption">Figure 8.28 – Results on the local qasm_simulator and on the ibmqx2 backend</p></li>
				<li>Now that we have the results of the circuit when run on the backend, we can pull in the actual qubit and gate data from the backend and build a noise model. <p>The model includes statistics on the measurement behavior for the backend's qubits: </p><div class="IMG---Figure" id="_idContainer717"><img alt="Figure 8.29 – Calibration matrix with the expected results and the statistical measurement errors&#13;&#10;" src="image/Figure_8.29_B14436.jpg"/></div><p class="figure-caption">Figure 8.29 – Calibration matrix with the expected results and the statistical measurement errors</p><p>In <em class="italic">Figure 8.29</em>, you can see the expected results in the diagonal, and the statistical measurement errors as gray shading away from the diagonal. The darker the<a id="_idIndexMarker680"/> shading, the higher the probability of getting that result.</p><p>We can use this data to rerun the circuit on the local simulator, with the measurement calibration data as input. We can then run the original results through a measurement filter and get the mitigated results as follows:</p><div class="IMG---Figure" id="_idContainer718"><img alt="Figure 8.30 – The mitigated results for ibmq_16_melbourne &#13;&#10;" src="image/Figure_8.30_B14436.jpg"/></div><p class="figure-caption">Figure 8.30 – The mitigated results for ibmq_16_melbourne </p></li>
				<li>Finally, we can plot the simulator results, the original backend results, and the mitigated results for comparison:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer719">
					<img alt="Figure 8.31 – A comparison of results for simulator, backend, and mitigated backend&#13;&#10;" src="image/Figure_8.31_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.31 – A comparison of results for simulator, backend, and mitigated backend</p>
			<p>From the final chart, you can see that the expected results for a GHZ-state circuit, <img alt="" src="image/Formula_008_042.png"/> with roughly a 50/50 chance, is not what we get on the backend. There are a large number of<a id="_idIndexMarker681"/> noisy bars between the expected results. With the error mitigation, we shrink these bars and bring the results closer to the expected.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor240"/>Mitigating the unexpected with quantum error correction</h1>
			<p>As we saw in the<a id="_idIndexMarker682"/> previous recipe, it is good to understand how your measurements behave, to statistically be able to correct incorrect readouts. But in the end, a measurement is just a measurement, and a measurement of a qubit will result in either 0 or 1. If the state of the qubit that you measure turns out to be <img alt="" src="image/Formula_06_058.png"/> instead of the expected <img alt="" src="image/Formula_008_045.png"/>, it doesn't matter that you statistically corrected for measurement mistakes; your qubit is off by 100%.</p>
			<p>There are a lot of things that can perturb our qubits, from gate errors to just plain physics that causes the qubit to decohere and dephase (remember the T1 and T2 times). In the classical computing world, we can periodically check in on our bits, and apply error correction coding to make sure that they behave. Digital error correction is one of the reasons that digital communication works and that you can play digital media, CDs, DVDs, and Blu-ray disks and actually hear or see what you expect.</p>
			<p>One way of performing classical error correction is to duplicate one bit that you want to transfer into three bits, and at the end compare the bit with its duplicated brethren. If they are different, then at least one of the bits has been <em class="italic">errored</em>. Very simply put, you can then take a <a id="_idIndexMarker683"/>majority vote and flip the offending bit, and thus get the original back. </p>
			<p>For qubits, it is not so simple. For one, you cannot make copies of qubits like you can for classical bits. Instead, we have to make use of <strong class="bold">superposition</strong> and <strong class="bold">entanglement</strong>. </p>
			<p>We discussed superposition at length in the <em class="italic">Comparing a bit and a qubit</em> recipe of <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, and entanglement in the <em class="italic">Quantum-cheating in a coin toss? – Introducing the Bell State</em> recipe of <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>. Feel free to go back for a refresher.</p>
			<p>Let's use these tools to explore further... Read on!</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor241"/>Getting ready</h2>
			<p>The sample code for this recipe can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter08/ch8_r5_shor.py</a>.</p>
			<h3>The sample code</h3>
			<p>To handle the creation <a id="_idIndexMarker684"/>and running of the Shor code algorithm, we will build a number of functions in the <strong class="source-inline">ch8_r5_shor.py</strong> script:</p>
			<ol>
				<li value="1">First, we import the methods that we need and set the backend:<p class="source-code">from qiskit import QuantumCircuit, execute, Aer</p><p class="source-code">from qiskit.visualization import plot_bloch_multivector, plot_state_qsphere</p><p class="source-code"># Supporting methods</p><p class="source-code">from math import pi</p><p class="source-code">from random import random</p><p class="source-code">from IPython.core.display import display</p><p class="source-code"># Set the Aer simulator backend</p><p class="source-code">backend = Aer.get_backend('qasm_simulator')</p></li>
				<li>The <strong class="source-inline">get_psi(qc)</strong> function is an old friend that we are reusing to return the state vector of the<a id="_idIndexMarker685"/> circuit, to display Bloch spheres and Q-spheres:<p class="source-code">def get_psi(qc):</p><p class="source-code">    global psi</p><p class="source-code">    backend = Aer.get_backend('statevector_simulator') </p><p class="source-code">    result = execute(qc, backend).result()</p><p class="source-code">    psi = result.get_statevector(qc)</p><p class="source-code">    return(psi)</p></li>
				<li>Instead of expecting the first qubit errors to occur naturally, we use the <strong class="source-inline">add_error(error, circuit,ry_error, rz_error)</strong> function to create<a id="_idIndexMarker686"/> four<a id="_idIndexMarker687"/> different <a id="_idIndexMarker688"/>types <a id="_idIndexMarker689"/>of errors – <strong class="bold">Bit flip</strong>, <strong class="bold">Bit flip + phase flip</strong>, <strong class="bold">Theta + phi shift</strong>, and <strong class="bold">Random</strong>:<p class="source-code">def add_error(error, circuit,ry_error, rz_error):</p><p class="source-code">    circuit.barrier([x for x in range(circuit.num_        qubits)])</p><p class="source-code">    if error=="1": #Bit flip error</p><p class="source-code">        circuit.x(0)</p><p class="source-code">    elif error=="2": #Bit flip plus phase flip error</p><p class="source-code">        circuit.x(0)</p><p class="source-code">        circuit.z(0)</p><p class="source-code">    else: #Theta plus phi shift and Random</p><p class="source-code">        circuit.ry(ry_error,0)</p><p class="source-code">        circuit.rz(rz_error,0)</p><p class="source-code">    circuit.barrier([x for x in range(circuit.num_        qubits)])</p><p class="source-code">    return(circuit)</p></li>
				<li>The <strong class="source-inline">not_corrected(error, ry_error, rz_error)</strong> function creates a simple 1-qubit<a id="_idIndexMarker690"/> circuit and introduces the error that we select in the main process, then displays the results as a Bloch sphere and a Q-sphere. We also run the circuit on the Qiskit Aer <strong class="source-inline">qasm_simulator</strong> to see the results of our contaminated qubit:<p class="source-code">def not_corrected(error, ry_error, rz_error):</p><p class="source-code">    # Non-corrected code</p><p class="source-code">    qco = QuantumCircuit(1,1)</p><p class="source-code">    print("\nOriginal qubit, in state <img alt="" src="image/Formula_008_046.png"/>")</p><p class="source-code">    display(plot_bloch_multivector(get_psi(qco)))</p><p class="source-code">    display(plot_state_qsphere(get_psi(qco)))</p><p class="source-code">    # Add error</p><p class="source-code">    add_error(error,qco, ry_error, rz_error)</p><p class="source-code">    print("\nQubit with error...")</p><p class="source-code">    display(plot_bloch_multivector(get_psi(qco)))</p><p class="source-code">    display(plot_state_qsphere(get_psi(qco)))</p><p class="source-code">    qco.measure(0,0)</p><p class="source-code">    display(qco.draw('mpl'))</p><p class="source-code">    job = execute(qco, backend, shots=1000)        </p><p class="source-code">    counts = job.result().get_counts()</p><p class="source-code">    print("\nResult of qubit error:")</p><p class="source-code">    print("-----------------------")</p><p class="source-code">    print(counts)</p></li>
				<li>Now it is time to add the quantum correction code that Peter Shor developed. We are building the <a id="_idIndexMarker691"/>same circuit as before, but with 8 <strong class="bold">ancilla</strong> qubits, which we use to process the qubit information. Our creation will be a combination of a 3-qubit phase flip code, and 3-qubit bit flip codes. This displays the qubit state (actually the state of all 9 qubits, but we are mainly interested in the state of the first qubit, the least significant bit in the ket-notation: <img alt="" src="image/Formula_008_047.png"/>). It also displays the final result of measuring the qubit after quantum error correction.<p>The function contains several sections:</p><p><strong class="bold">The first half of the phase-flip correction</strong>: Here, we create the quantum circuit and put together the start of the phase-flip correction part of the circuit:</p><p class="source-code">def shor_corrected(error, ry_error, rz_error):    </p><p class="source-code">    # A combination of a three qubit phase flip code, and     # 3 bit flip codes</p><p class="source-code">    qc = QuantumCircuit(9,1)</p><p class="source-code">    print("\nOriginal LSB qubit, in state <img alt="" src="image/Formula_008_048.png"/>")</p><p class="source-code">    display(plot_state_qsphere(get_psi(qc)))</p><p class="source-code">    # Start of phase flip code</p><p class="source-code">    qc.cx(0,3)</p><p class="source-code">    qc.cx(0,6)</p><p class="source-code">    qc.h(0)</p><p class="source-code">    qc.h(3)</p><p class="source-code">    qc.h(6)</p><p class="source-code">    qc.barrier([x for x in range(qc.num_qubits)])</p><p><strong class="bold">The first half of the bit-flip correction</strong>: Each of the 3 qubits used for the phase-flip correction<a id="_idIndexMarker692"/> must now be protected against phase-flip. We have now engaged all 9 qubits to help us:</p><p class="source-code">    qc.cx(0,1)</p><p class="source-code">    qc.cx(3,4)</p><p class="source-code">    qc.cx(6,7)</p><p class="source-code">    qc.cx(0,2)</p><p class="source-code">    qc.cx(3,5)</p><p class="source-code">    qc.cx(6,8)</p><p><strong class="bold">Introduce errors to the first qubit</strong>: At this stage in the circuit creation, we now add some errors to the first qubit by using the <strong class="source-inline">add_error()</strong> function. This simulates real-world perturbance of the qubit:</p><p class="source-code">    add_error(error,qc, ry_error, rz_error)</p><p class="source-code">    print("Qubit with error... LSB can be in <img alt="" src="image/Formula_008_049.png"/> and in         <img alt="" src="image/Formula_008_050.png"/>, with various phase.")</p><p class="source-code">    display(plot_state_qsphere(get_psi(qc)))</p><p class="source-code">    display(qc.draw('mpl'))</p><p><strong class="bold">The end of the bit-flip correction</strong>: After the errors have been introduced, we now start collecting our qubits again, starting with wrapping up the bit-flip correction and adjusting each of the phase-shift qubits if needed:</p><p class="source-code">    qc.cx(0,1)</p><p class="source-code">    qc.cx(3,4)</p><p class="source-code">    qc.cx(6,7)</p><p class="source-code">    qc.cx(0,2)</p><p class="source-code">    qc.cx(3,5)</p><p class="source-code">    qc.cx(6,8)</p><p class="source-code">    qc.ccx(1,2,0)</p><p class="source-code">    qc.ccx(4,5,3)</p><p class="source-code">    qc.ccx(8,7,6)</p><p><strong class="bold">The end of the phase-flip correction</strong>: And similar to the bit flip wrapping up, we now close the <a id="_idIndexMarker693"/>phase-flip correction, applying any necessary correction to the first qubit:</p><p class="source-code">    qc.h(0)</p><p class="source-code">    qc.h(3)</p><p class="source-code">    qc.h(6)</p><p class="source-code">    qc.cx(0,3)</p><p class="source-code">    qc.cx(0,6)</p><p class="source-code">    qc.ccx(6,3,0)</p><p><strong class="bold">Measure and print</strong>: We can now measure the qubit and print the result:</p><p class="source-code">    qc.barrier([x for x in range(qc.num_qubits)])</p><p class="source-code">    qc.measure(0,0)</p><p class="source-code">    print("Error corrected qubit... LSB in <img alt="" src="image/Formula_008_051.png"/>        with phase 0.")</p><p class="source-code">    display(plot_state_qsphere(get_psi(qc)))</p><p class="source-code">    display(qc.draw('mpl'))</p><p class="source-code">    job = execute(qc, backend, shots=1000)        </p><p class="source-code">    counts = job.result().get_counts()</p><p class="source-code">    print("\nResult of qubit error after         Shor code correction:")</p><p class="source-code">    print("----------------------------------------------        ----")</p><p class="source-code">    print(counts)</p></li>
				<li>The program<a id="_idIndexMarker694"/> prompts for a numeric input to select the error to introduce, and then runs the <strong class="source-inline">not_corrected()</strong> and <strong class="source-inline">shor_corrected()</strong> functions:<p class="source-code"> def main():</p><p class="source-code">    error="1"</p><p class="source-code">    ry_error=0</p><p class="source-code">    rz_error=0</p><p class="source-code">    while error!="0":</p><p class="source-code">        error=input("Select an error:\n1. Bit flip\n2.             Bit flip plus phase flip\n3. Theta plus phi             shift\n4. Random\n")</p><p class="source-code">        if error=="3":</p><p class="source-code">            ry_error=float(input("Enter theta:\n"))</p><p class="source-code">            rz_error=float(input("Enter phi:\n"))</p><p class="source-code">        if error=="4":</p><p class="source-code">            ry_error=pi*random()</p><p class="source-code">            rz_error=2*pi*random()</p><p class="source-code">        not_corrected(error, ry_error, rz_error)</p><p class="source-code">        input("Press enter for error correction...")</p><p class="source-code">        shor_corrected(error, ry_error, rz_error)</p></li>
			</ol>
			<p>The code we have <a id="_idIndexMarker695"/>built here can now be run, simulating the quantum error correction of any phase and the bit perturbation of the qubit.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor242"/>How to do it…</h2>
			<p>Let's take the Shor code for a spin:</p>
			<ol>
				<li value="1">In your Python environment, run <strong class="source-inline">ch8_r5_shor.py</strong>.</li>
				<li>When prompted, enter the error type for a bit flip: <strong class="source-inline">1</strong>.</li>
				<li>The error-free qubit is displayed:<div class="IMG---Figure" id="_idContainer729"><img alt="Figure 8.32 – The qubit with no error, in state &#13;&#10;" src="image/Figure_8.32_B14436.jpg"/></div><p class="figure-caption">Figure 8.32 – The qubit with no error, in state <img alt="" src="image/Formula_008_052.png"/></p></li>
				<li>Then, the <a id="_idIndexMarker696"/>selected error is added, and the results are displayed. The qubit has now flipped from <img alt="" src="image/Formula_008_053.png"/>:<div class="IMG---Figure" id="_idContainer732"><img alt="Figure 8.33 – The qubit with the selected bit-flip error, turning the qubit from &#13;&#10;" src="image/Figure_8.33_B14436.jpg"/></div><p class="figure-caption">Figure 8.33 – The qubit with the selected bit-flip error, turning the qubit from <img alt="" src="image/Formula_008_054.png"/></p></li>
				<li>Now, press <em class="italic">Enter</em> to create a new circuit and display the undisturbed qubit with its 8 ancilla qubits. The Q-sphere displays the possible outcomes of this new unperturbed circuit, all 9 qubits in <img alt="" src="image/Formula_06_057.png"/>:<div class="IMG---Figure" id="_idContainer735"><img alt="Figure 8.34 – Undisturbed qubit with 8 ancilla qubits&#13;&#10;" src="image/Figure_8.34_B14436.jpg"/></div><p class="figure-caption">Figure 8.34 – Undisturbed qubit with 8 ancilla qubits</p></li>
				<li>We now start<a id="_idIndexMarker697"/> the Shor code creation and add the simulated error. The Q-sphere now shows a number of possible outcomes as qubits 0, 3, and 6 are now in a superposition, giving a probabilistic outcome for those qubits, and for their entangled counterparts. Notice that qubit 0 can now appear as both <img alt="" src="image/Formula_008_056.png"/>:<div class="IMG---Figure" id="_idContainer737"><img alt="Figure 8.35 – Qubit with added bit-flip error, turning the qubit from &#13;&#10;" src="image/Figure_8.35_B14436.jpg"/></div><p class="figure-caption">Figure 8.35 – Qubit with added bit-flip error, turning the qubit from <img alt="" src="image/Formula_008_0541.png"/></p></li>
				<li>Finally, we complete <a id="_idIndexMarker698"/>the Shor code, display the expected outcomes for the circuit, and then run it on the Aer <strong class="source-inline">qasm_simulator</strong>: </li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer739">
					<img alt="Figure 8.36 – Result of the error-corrected qubit, back at  again" src="image/Figure_8.36_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.36 – Result of the error-corrected qubit, back at <img alt="" src="image/Formula_008_052.png"/> again</p>
			<p>Take a look at the Q-sphere <a id="_idIndexMarker699"/>and the results count. The state vector has safely put our qubit back at <img alt="" src="image/Formula_008_059.png"/> again; note how the least-significant bit that represents the first qubit is now <img alt="" src="image/Formula_008_060.png"/>. The result also points to our qubit being safely error-corrected, with a 100% chance of 0.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor243"/>How it works…</h2>
			<p>Here's a short explanation of how qubit error correction works. We first create what is called a <strong class="bold">syndrome</strong> by <a id="_idIndexMarker700"/>entangling our qubit with two other ancilla qubits. The entangled qubits now walk through life as one entity, indistinguishable from each other with one exception: errors to the qubits are not entangled, but unique to each qubit. </p>
			<p>Before using our qubit for anything, we first disentangle it from the other 2 qubits; it is now a standalone qubit again. Now it is time to use the <strong class="bold">syndrome</strong> to correct any errors. </p>
			<p>To do this, we set up a Toffoli (<strong class="bold">CCX</strong>) gate from our two syndrome qubits to our qubit of interest. If the syndrome qubits differ from our original qubit, that is, our qubit has been disturbed, the <a id="_idIndexMarker701"/>CCX flips the qubit right again. </p>
			<p>That's it. Simple, eh? Well, let's take a closer look.</p>
			<p>There are two methods we can use, for two different qubit errors:</p>
			<ul>
				<li><strong class="bold">Bit-flip correction</strong>: Correcting flipped qubits, from <img alt="" src="image/Formula_008_061.png"/> and vice versa</li>
				<li><strong class="bold">Phase-flip</strong>: Correcting flipped phases, from <img alt="" src="image/Formula_008_062.png"/> and vice versa</li>
			</ul>
			<h3>Bit-flip correction</h3>
			<p>In the bit correction<a id="_idIndexMarker702"/> method, we set up a GHZ-state entangled circuit, using the first qubit as the controller for a CXX gate (or two CX gates in this case), where two additional ancilla qubits are used as the error correction syndrome only and are not used in the final measurement:</p>
			<ol>
				<li value="1">If the first qubit is <img alt="" src="image/Formula_008_063.png"/>, we now have the following state:<p><img alt="" src="image/Formula_008_064.png"/></p><p>If it is <img alt="" src="image/Formula_008_065.png"/>, we now have <img alt="" src="image/Formula_008_066.png"/> – nothing new there.</p></li>
				<li>After setting up the initial qubit and its ancillas, we let the world act on the first qubit, potentially introducing bit-flip errors, sending our <img alt="" src="image/Formula_008_067.png"/>, for example, to <img alt="" src="image/Formula_008_068.png"/>. <p>In the diagram that follows, this is represented by the two barriers between the two sets of CX gates.</p></li>
				<li>Our 3 qubits might now be in the following two states:<p><img alt="" src="image/Formula_008_069.png"/></p></li>
				<li>We then run a <a id="_idIndexMarker703"/>second GHZ-entanglement to disentangle the first qubit, and end up with the following states:<p><img alt="" src="image/Formula_008_070.png"/>, nothing changes as the first qubit is now <img alt="" src="image/Formula_008_071.png"/>, and <img alt="" src="image/Formula_008_072.png"/> if the first qubit is <img alt="" src="image/Formula_008_073.png"/>.</p></li>
				<li>At this point, we add a supremely clever piece of coding by adding a Toffoli gate, with the two syndrome qubits as controllers, and the first qubit as the controlled qubit. What happens?<p><img alt="" src="image/Formula_008_074.png"/> turns into <img alt="" src="image/Formula_008_075.png"/>, and <img alt="" src="image/Formula_008_076.png"/> into <img alt="" src="image/Formula_008_074.png"/>, and like magic, our first qubit has returned to its original state of <img alt="" src="image/Formula_008_078.png"/>:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer761">
					<img alt="Figure 8.37 – The bit-flip quantum correction circuit" src="image/Figure_8.37_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.37 – The bit-flip quantum correction circuit </p>
			<h3>Phase-flip correction</h3>
			<p>But a qubit also differs <a id="_idIndexMarker704"/>from a classical bit by one critical aspect: in addition to 0 and 1, a qubit can also have a phase value, and thus also phase errors. Can we error correct for that? Turns out that we can, with basically the same method, with yet another clever twist: </p>
			<ol>
				<li value="1">Like before, we start out with our 3 qubits, and our GHZ-state:<p><img alt="" src="image/Formula_008_079.png"/></p></li>
				<li>The next step is to transform our measurement basis state into a state where we can work with phase information, by adding a Hadamard gate to each qubit. We now have the following two states instead:<p><img alt="" src="image/Formula_008_080.png"/></p></li>
				<li>Again, we let nature act on the first qubit, potentially ending up with a phase-shifted first qubit, like this:<p><img alt="" src="image/Formula_008_081.png"/></p><p>In the diagram that follows, the error occurs between the two barriers between the H gates.</p></li>
				<li>Like in the bit-flip example, we now apply the Hadamard gate and the GHZ-creating CXX gates again, and now end up with the following:<p><img alt="" src="image/Formula_008_082.png"/></p><p><img alt="" src="image/Formula_008_083.png"/></p></li>
				<li>And finally, the Toffoli (CCX) gate turns the qubit trio into the following:<p><img alt="" src="image/Formula_008_084.png"/></p><p>Again, our first <a id="_idIndexMarker705"/>qubit has returned to its original state of <img alt="" src="image/Formula_008_085.png"/> and <img alt="" src="image/Formula_008_086.png"/>:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer770">
					<img alt="Figure 8.38 – The phase-flip quantum correction circuit&#13;&#10;" src="image/Figure_8.38_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.38 – The phase-flip quantum correction circuit</p>
			<h3>Shor code</h3>
			<p>That is all great; we can <a id="_idIndexMarker706"/>tackle bit-flip errors as well as phase-flip errors. But what if both types of errors occur? After all, qubits are physical entities, and who really knows how they will behave? It turns out that we can do that as well. Peter Shor, of Shor's algorithm fame (see <a href="B14436_10_Final_PG_ePub.xhtml#_idTextAnchor271"><em class="italic">Chapter 10</em></a>, <em class="italic">Getting to Know Algorithms with Aqua</em>) invented the Shor code, which is a combination of the phase-flip and bit-flip methods using 9 qubits in total. The first qubit is the one we want to do quantum error correction on, and the eight following are the ancillas, only used for working the correction magic:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer771">
					<img alt="Figure 8.39 – The Shor code circuit&#13;&#10;" src="image/Figure_8.39_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.39 – The Shor code circuit</p>
			<p>Here's a quick <a id="_idIndexMarker707"/>description, but do take a look at <em class="italic">Figure 8.39</em>:</p>
			<ol>
				<li value="1">Set up the first half of the phase-flip circuit using qubits 0, 3, and 6.</li>
				<li>Set up the first half of three bit-flip circuits for qubits 0, 3, and 6.</li>
				<li>Leave some room for nature and the error to happen to qubit 0. The two barriers between the triplicate CX gate sets below.</li>
				<li>Set up the second half of three bit-flip circuits for qubits 0, 3, and 6, effectively correcting any bit flips on these 3 qubits.</li>
				<li>Set up the second half of the phase-flip circuit for qubits 0, 3, and 6, correcting any phase shifts for these three qubits.</li>
				<li>Measure qubit 0.</li>
			</ol>
			<p>Now the math turns somewhat complicated, with Ket-representations for 9 qubits looking like this, for <a id="_idIndexMarker708"/>example: |011000101<img alt="" src="image/Formula_008_090.png"/>. Not to mention what unitary matrices for 9-qubit circuits look like.  </p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor244"/>There's more</h2>
			<p>The first example that we ran, a simple bit-flip error, didn't really make use of the full power of the Shor code. Try some of the other options to simulate any type of conceivable error that might occur, from the simple to the very complex.</p>
			<p>The following options are available:</p>
			<ul>
				<li><strong class="bold">Bit flip</strong>: This error flips the bit upside-down, from <img alt="" src="image/Formula_008_087.png"/>.</li>
				<li><strong class="bold">Bit flip plus phase flip</strong>: A combined bit and phase flip. </li>
				<li><strong class="bold">Theta plus phi shift</strong>: Create your own error by entering the theta <img alt="" src="image/Formula_008_088.png"/> and phi <img alt="" src="image/Formula_008_089.png"/> angles to point your state vector at any point on the Bloch sphere. If you need a reminder about what these two angles represent, take a quick look at the <em class="italic">Visualizing a qubit in Python</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>.</li>
				<li><strong class="bold">Random</strong>: A random error. </li>
			</ul>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor245"/>See also</h2>
			<ul>
				<li><em class="italic">Quantum Error Correction for Beginners</em>, Simon J. Devitt, William J. Munro, and Kae Nemoto, June 24, 2013, <a href="https://arxiv.org/pdf/0905.2794.pdf ">https://arxiv.org/pdf/0905.2794.pdf</a></li>
				<li><em class="italic">Quantum Computation and Quantum Information</em> by Isaac L. Chuang; Michael A. Nielsen, Cambridge University Press, 2010, Chapter 10.2 Shor code</li>
			</ul>
		</div>
	</body></html>