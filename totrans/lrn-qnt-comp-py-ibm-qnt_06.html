<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer560" class="Basic-Text-Frame">
    <h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-92" class="chapterTitle">Understanding Quantum Logic Gates</h1>
    <p class="normal">Quantum logic gates are very similar to their classical counterparts in that they are used to perform operations by manipulating the qubits in such a way that the results serve to provide a solution. Of course, that’s about as far as the comparison can go. Classical gates transition the state of a bit from one to the other by a single operation, in this case, flipping the bit <a id="_idIndexMarker450"/>value from 0 to 1, or vice versa. <strong class="keyWord">Quantum gates</strong>, sometimes <a id="_idIndexMarker451"/>referred to as <strong class="keyWord">qubit gates</strong>, are different in part because they perform linear transformations on one or more qubits in a complex vector space to transition them from one state to another.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Reviewing classical logic gates</li>
      <li class="bulletList">Understanding unitary operators</li>
      <li class="bulletList">Understanding single-qubit gates</li>
      <li class="bulletList">Understanding multi-qubit gates</li>
      <li class="bulletList">Understanding non-reversible operators</li>
    </ul>
    <p class="normal">After reading this chapter, you will have gained knowledge about the fundamental operations that can be performed on both single and multiple qubits. But before we dive right in, let’s discuss the format with which I’ll try to explain each qubit gate. First, from a learning perspective, some people tend to learn quicker when content is presented purely with mathematics; others prefer visual aids such as graphs; others still prefer a more intuitive approach with analogies and examples.</p>
    <p class="normal">With that in mind, I shall do my best to ensure that each gate is presented by combining as many of these learning styles as possible. This will be done by providing not only the mathematical representation of each qubit gate, but also a visual representation, and of course, the source code to run the qubit gate operation and its result.</p>
    <h1 id="_idParaDest-93" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, we will discuss linear <a id="_idIndexMarker452"/>transformations of matrices in the <strong class="keyWord">Hilbert space</strong>, so it is highly recommended that you should know the basics of linear algebra.</p>
    <p class="normal">Knowledge of the qubit <a id="_idIndexMarker453"/>and how its states are represented on a Bloch sphere, <strong class="keyWord">QSphere</strong>, or mathematically, is recommended as this chapter will perform complex linear transitions of those qubit states. Knowledge of basic classical single-bit and multi-bit gates is also recommended, but not required, as there is a refresher if needed.</p>
    <p class="normal">Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-94" class="heading-1">Reviewing classical logic gates</h1>
    <p class="normal">This section will serve as a refresher for classical logic gates such as <strong class="keyWord">AND</strong>, <strong class="keyWord">OR</strong>, <strong class="keyWord">NOR</strong>, and so on. If you <a id="_idIndexMarker454"/>are familiar with this subject, you can either skim through it to refresh your memory or skip it entirely and jump to the next section. <em class="italic">Otherwise, let’s get logical!</em></p>
    <p class="normal"><strong class="keyWord">Logic gates</strong> are defined <a id="_idIndexMarker455"/>as a device, electronic or otherwise, that implements a logical (usually Boolean) operation. Single-bit and two-bit gates have one or two inputs, respectively. Each input bit value is a state value of either 0 or 1. The operation carried out on the input varies by the type of gate. Each gate operation is usually described using logic truth tables, as illustrated in the following table:</p>
    <table id="table001" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Gate</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Operation</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Input</strong></p>
            <p class="center"><strong class="keyWord">A B</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Output</strong></p>
            <p class="center"><strong class="keyWord">Y</strong></p>
          </td>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Graphical Representation</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">Buffer</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs the same value as the input</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-09.png" alt="" width="139" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">NOT</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Reverses the input state</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-08.png" alt="" width="139" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">AND</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 1 if and only if both inputs are 1, otherwise output is 0</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">0</p>
            <p class="center">0</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-07.png" alt="" width="161" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">OR</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 0 if and only if none of the inputs is 1, otherwise output is 1</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">1</p>
            <p class="center">1</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-06.png" alt="" width="159" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">XOR</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 1 if and only if both inputs are different, otherwise output is 0</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">0</p>
            <p class="center">1</p>
            <p class="center">1</p>
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-05.png" alt="" width="159" height="65"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">NAND</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 0 if and only if both inputs are 1, otherwise output is 1</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
            <p class="center">1</p>
            <p class="center">1</p>
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-03.png" alt="" width="161" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">NOR</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 1 if and only if both inputs are 0, otherwise outputs a 0</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
            <p class="center">0</p>
            <p class="center">0</p>
            <p class="center">0</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-02.png" alt="" width="161" height="66"/></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="center"><strong class="keyWord">XNOR</strong></p>
          </td>
          <td class="table-cell">
            <p class="center">Outputs a 1 if and only if inputs are both either 0 or 1, otherwise outputs 0</p>
          </td>
          <td class="table-cell">
            <p class="center">0 0</p>
            <p class="center">0 1</p>
            <p class="center">1 0</p>
            <p class="center">1 1</p>
          </td>
          <td class="table-cell">
            <p class="center">1</p>
            <p class="center">0</p>
            <p class="center">0</p>
            <p class="center">1</p>
          </td>
          <td class="table-cell">
            <p class="center"><img src="../Images/Table_06_01_icon-01.png" alt="" width="161" height="65"/></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 6.1: Classical logic gates</p>
    <p class="normal">The preceding table lists some of the common classical gates, descriptions of the operation that each gate performs on the input state, the result (output) of the gate operation, and their graphical representations.</p>
    <p class="normal">Let’s consider <a id="_idIndexMarker456"/>some things of note regarding classical bits that will help you later understand the differences they have compared to <strong class="keyWord">quantum bits</strong> (<strong class="keyWord">qubits</strong>). First is that there are only two single-bit gates, the buffer and the NOT gate. Among <a id="_idIndexMarker457"/>these two, only the NOT gate performs a Boolean operation on the classical bit by flipping the bit value of the input, so if the input to the NOT gate was a 0, then the output would be a 1. On the other hand, the buffer gate simply outputs the same value as the input. All the other gates operate on two input bit values that output a single value, which is determined by the gate’s Boolean operation. For example, if both input values to an AND gate are 1, it will output a 1. Otherwise, the output will be 0.</p>
    <p class="normal">One problem, however, particularly with regard to the two-bit gates, is that if you only have access to the output, then the information about the input is lost. For example, if you obtain the result from an AND bit and the value is 0, <em class="italic">could you tell what the input values were for A and B (the inputs)?</em> Unfortunately, the answer to this question is no. The input information is lost because the output does not include any information about the input value, which renders the gates irreversible. Likewise, with other two-bit gates, if I gave you just the output value of the gate, you could not tell me with 100% certainty what the input values were.</p>
    <p class="normal"><strong class="keyWord">Reversibility</strong> is a <a id="_idIndexMarker458"/>unique property that qubit gates have, in that you can reverse the operation of the qubit gate to obtain the previous state. This is also because the second postulate of quantum mechanics states that transformations between quantum states must be unitary, therefore reversible. We see this when we apply a Hadamard gate to a single qubit in the ground state 0; if we apply another Hadamard gate after the first one, then the state of the qubit returns to the ground state 0. </p>
    <p class="normal">And finally, to close <a id="_idIndexMarker459"/>our discussion on classical gates, we’ll discuss <strong class="keyWord">universal logic gates</strong>. These gates are the type of gates used to create other logic gates. <strong class="keyWord">NOR</strong> and <strong class="keyWord">NAND</strong> gates are good examples of universal gates in that they can be used to create NOT and AND gates. Let’s take a look at the following diagram that illustrates creating a NOT gate (inverter) by using a NAND gate:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_01.png" alt="Figure 6.1 – Using a NAND gate to create a NOT gate " width="181" height="54"/></figure>
    <p class="packt_figref">Figure 6.1: Using a NAND gate to create a NOT gate</p>
    <p class="normal">As you can see, by wiring both inputs of the NAND gate together, forming a single input (<strong class="keyWord">A</strong>), this logically creates a NOT gate that flips the value of the input. Computational systems having universal gates is an important feature as it provides the ability to compose complex logical circuits to solve problems. This of course led to the creation of integrated circuits, which are specialized circuits used to compute problems or to perform specific operations such as an adder or a counter, respectively.</p>
    <p class="normal">Now that we have reviewed the functionality of classical gates, we can continue to the next section where we will cover the basics of quantum logic gates. There, we will also see some similarities and some unique properties that they display with regard to the classical bit.</p>
    <h1 id="_idParaDest-95" class="heading-1">Understanding quantum unitary operators</h1>
    <p class="normal"><strong class="keyWord">Unitary operators</strong> are defined as a unitary transformation of a rigid body rotation of the Hilbert space. When <a id="_idIndexMarker460"/>these unitary operators are applied to the basis states of the Hilbert space, for example, the <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker461"/> and <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker462"/> state, the results transform the state vector position but it does not change its length. Let’s see what this means for a qubit. The basis states of a qubit are mapped on the Hilbert space <img src="../Images/B18420_06_003.png" alt="" width="13" height="25"/><a id="_idIndexMarker463"/> as described in <em class="chapterRef">Chapter 5</em>, <em class="italic">Understanding a Qubit</em>, <img src="../Images/B18420_06_004.png" alt="" width="154" height="25"/><a id="_idIndexMarker464"/> and <img src="../Images/B18420_06_005.png" alt="" width="150" height="25"/><a id="_idIndexMarker465"/>, where <img src="../Images/B18420_06_006.png" alt="" width="50" height="25"/><a id="_idIndexMarker466"/>, and <img src="../Images/B18420_06_007.png" alt="" width="46" height="25"/><a id="_idIndexMarker467"/> are linear transformations that preserve orthogonality over unitary transformations. We’ll wrap our heads around this definition a bit by looking at this mathematically first.</p>
    <p class="normal">A linear transformation on a complex vector space can be described by a 2x2 matrix, <strong class="keyWord">U</strong>:</p>
    <p class="center"><img src="../Images/B18420_06_008.png" alt="" width="100" height="42"/><a id="_idIndexMarker468"/></p>
    <p class="normal">Furthermore, if we <a id="_idIndexMarker469"/>obtain the complex transpose of the matrix U as <img src="../Images/B18420_06_009.png" alt="" width="21" height="27"/><a id="_idIndexMarker470"/>, by transposing the matrix U and applying the complex conjugate, as illustrated:</p>
    <p class="center"><img src="../Images/B18420_06_010.png" alt="" width="131" height="56"/><a id="_idIndexMarker471"/></p>
    <p class="normal">Then we can say that the matrix U is unitary if <img src="../Images/B18420_06_011.png" alt="" width="67" height="27"/><a id="_idIndexMarker472"/>, where I represents the Identity matrix <img src="../Images/B18420_06_012.png" alt="" width="60" height="42"/><a id="_idIndexMarker473"/>, as shown here:</p>
    <p class="center"><img src="../Images/B18420_06_013.png" alt="" width="388" height="56"/><a id="_idIndexMarker474"/></p>
    <p class="normal">An intuitive way to think of this is to just imagine unitary transformation simply as rotations of the complex vector space that preserve the length of the original vector. The rotation of the complex vector space further ensures that quantum transformations are not just <a id="_idIndexMarker475"/>unitary operations but are also <strong class="keyWord">reversible operations</strong> as they would rotate around a specified axis.</p>
    <p class="normal"><strong class="keyWord">Reversibility of quantum gates</strong> is realized by unitary transformations. As seen in the previous unitary equation, if you have a unitary operator <strong class="keyWord">U</strong> applied to a qubit via a gate, then by applying the complex conjugate <img src="../Images/B18420_06_009.png" alt="" width="21" height="27"/><a id="_idIndexMarker476"/> of the unitary operator to the qubit via a second gate, the result would be equivalent to applying an Identity matrix to the original vector.</p>
    <p class="normal">An example of this would be if you were to trigger an operation that would rotate the vector space around the <em class="italic">x</em> axis by an angle π, and you then apply the complex conjugate of that operation, then you’ll return to the original position from which you started. This reversible functionality is something that is not possible with some classical-bit gates we mentioned earlier, such as an AND gate.</p>
    <p class="normal">With quantum <a id="_idIndexMarker477"/>unitary transformations, there is no loss of information. Should you need to return to the previous state, you would merely have to use their conjugate transpose, in reverse order, and you’d get back to where you originally started. We will see some interesting examples of reversibility in all gates.</p>
    <div class="note">
      <p class="normal">There is a <a id="_idIndexMarker478"/>special case operator that is not reversible, the <strong class="keyWord">measurement</strong> operator, which we will learn about in the <em class="italic">Understanding non-reversible operators</em> section.</p>
    </div>
    <p class="normal">Now that we understand unitary and reversible operators, we can get down to learning about quantum gates.</p>
    <h1 id="_idParaDest-96" class="heading-1">Understanding single-qubit gates</h1>
    <p class="normal">Before we start digging into the description of quantum gates, let’s simplify the format so it’s easy <a id="_idIndexMarker479"/>to both understand and reference. Intuitively, the easiest way to imagine the operation of each gate is by rotating the vector that ends on the surface of the Bloch sphere around a specified axis. Recall as well that the Bloch sphere always starts with the unit vector set to the initial state. The initial state is set when the quantum circuit is first created; in this case, it is initialized to the basis state <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker480"/> (the north pole of the Bloch sphere), as illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_02.png" alt="A picture containing dome  Description automatically generated" width="247" height="289"/></figure>
    <p class="packt_figref">Figure 6.2: Bloch sphere representation of the basis state <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker481"/></p>
    <p class="normal">One thing that <a id="_idIndexMarker482"/>will help us understand some of the labels we will see in the gate’s truth table is to define the values of each axis, where each axis is referred to as <strong class="keyWord">basis elements</strong>. For example, we can see from the previous figure that the <em class="italic">z</em> axis has the north pole labeled as <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker483"/> and the south pole as <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker484"/>. These two points form the computational basis elements for the basis state vectors <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker485"/> and <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker486"/>. However, we do not yet have labels for the <em class="italic">x</em> or <em class="italic">y</em> axes. Let’s define them now.</p>
    <p class="normal">Each basis element (axis) has a positive and negative side that originates at the center of the Bloch sphere. Each basis has a name associated with each axis:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Computational</strong> for the <em class="italic">z</em> axis</li>
      <li class="bulletList"><strong class="keyWord">Hadamard</strong> for the <em class="italic">x</em> axis</li>
      <li class="bulletList"><strong class="keyWord">Circular</strong> for the <em class="italic">y</em> axis</li>
    </ul>
    <p class="normal">The x basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_021.png" alt="" width="248" height="29"/><a id="_idIndexMarker487"/></p>
    <p class="normal">The -x basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_022.png" alt="" width="263" height="29"/><a id="_idIndexMarker488"/></p>
    <p class="normal">The y basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_023.png" alt="" width="244" height="29"/><a id="_idIndexMarker489"/></p>
    <p class="normal">The -y basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_024.png" alt="" width="250" height="29"/><a id="_idIndexMarker490"/></p>
    <p class="normal">The z basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_025.png" alt="" width="71" height="25"/><a id="_idIndexMarker491"/></p>
    <p class="normal">The -z basis has a label defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_026.png" alt="" width="83" height="25"/><a id="_idIndexMarker492"/></p>
    <p class="normal">The labels <a id="_idIndexMarker493"/>are also illustrated at the ends of each axis in the following Bloch sphere diagram, where the dotted line indicates the negative direction of the axis:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_03.png" alt="Figure 6.3 – Basis state labels of each axis of a Bloch sphere " width="537" height="301"/></figure>
    <p class="packt_figref">Figure 6.3: Basis state labels of each axis of a Bloch sphere</p>
    <p class="normal">Each gate we apply in the code snippets will operate on the qubit starting from the initial |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker494"/> state. There are some gates you will see that we will have to prepare into a superposition state using an H gate to see the effects.</p>
    <p class="normal">In this case, by transitioning the vector down onto the <em class="italic">x</em> axis, and then applying a Z gate rotation, you can then more clearly see the rotation take effect. Details on how this is done will be in the description of—yes, you guessed it—the Z gate. But for now, let’s open the helper file and review one of the functions that will help us visualize the gates without having <a id="_idIndexMarker495"/>to write so much code, and handle some of the repetitive functions such as executing and visualizing the circuits. This way, we will just create the quantum circuits, add the gates, and execute the circuits using a function that will return the results and the images to visualize the results and the circuit diagrams. To start, let’s review the function titled <code style="font-weight: bold;" class="codeHighlighted">execute_circuit_sv</code> from our helper file that will handle this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Will run the circuit on the state vector (sv) simulator</span>
<span class="hljs-comment"># Returns state vector results, circuit diagram, BlochSphere and QSphere</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">execute_circuit_sv</span>(<span class="hljs-params">quantum_circuit</span>):
    <span class="hljs-comment">#Get the state vector results</span>
    statevectorResults = run_sv_circuit(quantum_circuit)
    <span class="hljs-comment">#Draw the circuit diagram</span>
    circuit_diagram = quantum_circuit.draw(output="mpl")
    <span class="hljs-comment">#Draw the QSphere</span>
    q_sphere = statevectorResults.draw('qsphere')
    <span class="hljs-comment">#Draw the Bloch sphere </span>    bloch_sphere = statevectorResults.draw('bloch')
    <span class="hljs-comment">#Return the results, circuit diagram, and QSphere </span>    return statevectorResults, circuit_diagram, q_sphere, bloch_sphere
</code></pre>
    <p class="normal">The preceding code will return the four components: state vector results, the circuit diagram, and both the QSphere and the Bloch sphere. We will use each of these to illustrate each state vector result, each gate on a circuit, and the visual representation.</p>
    <p class="normal">Now we can focus on the quantum gates and their effect on the qubits, and not so much on executing the circuits or displaying the results.</p>
    <h2 id="_idParaDest-97" class="heading-2">Hadamard (H) gate</h2>
    <p class="normal">The<strong class="keyWord"> H </strong>gate is one of the most commonly used quantum gates. It’s not surprising as this is the gate <a id="_idIndexMarker496"/>that places the quantum state of the qubit into a complex linear superposition of the two basis states. This is what establishes the superposition <a id="_idIndexMarker497"/>of all qubits that are leveraged by most quantum algorithms. It is denoted as follows:</p>
    <p class="center"><img src="../Images/B18420_06_028.png" alt="" width="154" height="50"/><a id="_idIndexMarker498"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the state vector of the qubit along the <em class="italic">x</em> axis and <em class="italic">z</em> axis by <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker499"/> (90°), causing the state vector to be in a complex linear superposition of <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker500"/> and <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker501"/>:</p>
    <figure class="mediaobject"><img src="../Images/Table_06_02.png" alt="Table 6.5 – Truth table of a Hadamard operation " width="259" height="160"/></figure>
    <p class="packt_figref">Table 6.2: Truth table of a Hadamard operation</p>
    <p class="normal">Let’s continue and create a new notebook and add a circuit using these steps:</p>
    <ol>
      <li class="numberedList" value="1">First, we add an H gate to the qubit, and execute it on the backend, the same as we did in the previous example:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Load helper file</span>
%run helper_file_1<span class="hljs-number">.0</span>.ipynb
<span class="hljs-comment">#H-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the following state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the H gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This <a id="_idIndexMarker502"/>displays the circuit diagram <a id="_idIndexMarker503"/>with the <strong class="screenText">H</strong> gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_04.png" alt="Figure 6.8 – Circuit diagram with an H gate " width="132" height="39"/></figure>
    <p class="packt_figref">Figure 6.4: Circuit diagram with an H gate</p>
    <ol>
      <li class="numberedList" value="4">Now to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch sphere representation has changed into a superposition state, which means it will have an equal probability result of <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker504"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker505"/>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_05.png" alt="A picture containing building, dome  Description automatically generated" width="230" height="278"/></figure>
    <p class="packt_figref">Figure 6.5: H gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has an equal probability of being either <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker506"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker507"/>. The tip of the vectors, as you’ll <a id="_idIndexMarker508"/>notice, have the same diameter, indicating visually <a id="_idIndexMarker509"/>that both have equal probability:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_06.png" alt="Chart  Description automatically generated" width="377" height="437"/></figure>
    <p class="packt_figref">Figure 6.6: H gate QSphere representation</p>
    <p class="normal">The Hadamard (H) gate is a unique gate. We will see this gate many more times in this chapter and future chapters—having the ability to negate a state vector, also referred to as a phase kick, is very useful in many quantum algorithms.</p>
    <h2 id="_idParaDest-98" class="heading-2">Pauli gates</h2>
    <p class="normal">The first <a id="_idIndexMarker510"/>group of single-qubit gates we will discuss are <a id="_idIndexMarker511"/>commonly referred to as <strong class="keyWord">Pauli matrix</strong> gates, named after the physicist Wolfgang Pauli. The complex matrix representation of the four gates, <strong class="keyWord">I</strong>, <strong class="keyWord">X</strong>, <strong class="keyWord">Y</strong>, and <strong class="keyWord">Z</strong>, are defined as <em class="italic">2 x 2</em> complex matrices, which are both Hermitian and unitary and are represented by the Greek letter sigma <img src="../Images/B18420_06_036.png" alt="" width="117" height="27"/><a id="_idIndexMarker512"/>, respectively. <a id="_idIndexMarker513"/>When the conjugate transpose of a complex N x N matrix is <a id="_idIndexMarker514"/>equal to itself, then such a matrix is known as a Hermitian matrix.</p>
    <div class="note">
      <p class="normal">Note that the Identity matrix is subscripted with a 0, and the <em class="italic">x, y, z</em> subscripts can also be represented as <img src="../Images/B18420_06_037.png" alt="" width="88" height="25"/><a id="_idIndexMarker515"/>.</p>
    </div>
    <p class="normal">We’ll start with the easiest of the gates, the Identity gate.</p>
    <h3 id="_idParaDest-99" class="heading-3">Identity (I) Pauli gate</h3>
    <p class="normal">The<strong class="keyWord"> I gate</strong>, also <a id="_idIndexMarker516"/>known as the <strong class="keyWord">Identity gate,</strong> is a gate <a id="_idIndexMarker517"/>that does not perform any operation on the qubit. It does <a id="_idIndexMarker518"/>not change the state of the qubit. Mathematically, this is represented as an Identity matrix, hence the name of the gate. This equation is given as follows:</p>
    <p class="center"><img src="../Images/B18420_06_038.png" alt="" width="140" height="42"/><a id="_idIndexMarker519"/></p>
    <p class="normal">The truth table for this gate shows that the input and output have the same state:</p>
    <p class="center"><img src="../Images/Table_06_03.png" alt="Table 6.2 – Truth table of Identity gate " width="326" height="92"/></p>
    <p class="packt_figref">Table 6.3: Truth table of Identity gate</p>
    <p class="normal">The idea of an Identity gate is generally used mathematically to illustrate certain properties of operations, as we did earlier in this chapter to prove that unitary operators are reversible. In that example, the Identity matrix was used to illustrate that multiplying a unitary operator with its complex conjugate would produce the same output as applying no operation, or an Identity matrix, to the qubit.</p>
    <p class="normal">Let’s move on to the next gate section.</p>
    <h3 id="_idParaDest-100" class="heading-3">NOT (X) Pauli gate</h3>
    <p class="normal">The<strong class="keyWord"> X gate</strong> is also called the NOT gate because of the similar effect it has on the basis states as its <a id="_idIndexMarker520"/>classical-bit gate counterpart. One notable difference <a id="_idIndexMarker521"/>is that the X gate moves the state vector from one basis state to <a id="_idIndexMarker522"/>the other, as illustrated in <em class="italic">Table 6.4</em>. Visualizing this operation can be seen via the Bloch sphere result as a rotation of the vector from the initial state, <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker523"/>. Because of its spherical presentation, we refer to operations as rotations around some axis, in this case, the X gate is a π (180° ) rotation about the <em class="italic">x</em> axis, which is represented by the Pauli X-gate operator as follows:</p>
    <p class="center"><img src="../Images/B18420_06_040.png" alt="" width="144" height="42"/><a id="_idIndexMarker524"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the input around the <em class="italic">x</em> axis by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker525"/> (180), hence if the input is <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker526"/>, then the output is <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker527"/>, and vice versa:</p>
    <p class="center"><img src="../Images/Table_06_04.png" alt="Table 6.3 – Truth table of X (NOT) gate  " width="297" height="96"/></p>
    <p class="packt_figref">Table 6.4: Truth table of X (NOT) gate</p>
    <p class="normal">Let’s now create a circuit by following the next steps to include in our notebook:</p>
    <ol>
      <li class="numberedList" value="1">First, add an X gate to it, and execute it using our helper function to do the heavy lifting for us:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#X-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an X gate to the qubit</span>
qc.x(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit, which we expect should represent <img src="../Images/B18420_06_044.png" alt="" width="146" height="25"/><a id="_idIndexMarker528"/>, where <em class="italic">a</em>=0 and <em class="italic">b</em>=1, as shown in the following result:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">1.</span>+<span class="hljs-number">0.j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">Then, to draw the circuit diagram for the X gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays <a id="_idIndexMarker529"/>the circuit diagram with <a id="_idIndexMarker530"/>the <strong class="keyWord">X</strong> gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_07.png" alt="Figure 6.4 – X gate " width="208" height="62"/></figure>
    <p class="packt_figref">Figure 6.7: X gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch sphere representation has changed the state of the qubit from <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker531"/>to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker532"/>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_08.png" alt="A picture containing building, dome  Description automatically generated" width="250" height="290"/></figure>
    <p class="packt_figref">Figure 6.8: X gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">Now, to view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere represents the transition of the quantum state of the qubit from <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker533"/> to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker534"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_09.png" alt="Diagram  Description automatically generated with low confidence" width="416" height="441"/></figure>
    <p class="packt_figref">Figure 6.9: X gate QSphere</p>
    <p class="normal">As we <a id="_idIndexMarker535"/>have seen, the X gate serves as a good example that quantum <a id="_idIndexMarker536"/>gates can also be used to perform the same operations as classical gates. One other thing you will notice from the QSphere result is the color wheel that represents the phase of the state vector, which in this case is blue to indicate it’s in phase (0).</p>
    <h3 id="_idParaDest-101" class="heading-3">Y Pauli gate</h3>
    <p class="normal">The<strong class="keyWord"> Y gate</strong> is a <a id="_idIndexMarker537"/>rotation <a id="_idIndexMarker538"/>around the <em class="italic">y</em> axis by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker539"/> (180°), shown as follows:</p>
    <p class="center"><img src="../Images/B18420_06_050.png" alt="" width="154" height="42"/><a id="_idIndexMarker540"/></p>
    <p class="normal">Here, the following truth table illustrates that the operation rotates the input around the <em class="italic">y</em> axis by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker541"/> (180°), hence if the input to the gate is <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker542"/>, then the output from the gate is <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker543"/> and vice versa; note the phase difference where <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker544"/> has the phase at <em class="italic">i</em>, and <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker545"/> has a phase shift, indicated by the <em class="italic">-i</em>:</p>
    <p class="center"><img src="../Images/Table_06_05.png" alt="Table 6.4 – Truth table representing phase rotation of y axis " width="268" height="96"/></p>
    <p class="packt_figref">Table 6.5: Truth table representing phase rotation of the y axis</p>
    <p class="normal">Let’s now <a id="_idIndexMarker546"/>create a circuit by using the following steps:</p>
    <ol>
      <li class="numberedList" value="1">First, add a Y gate to it, and execute it using our helper function, which provides the quantum <a id="_idIndexMarker547"/>circuit and the visual representations of each circuit we execute:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Y-gate operation on a qubit</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
<span class="hljs-attribute">qc</span> = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add a Y gate to the qubit</span>
<span class="hljs-attribute">qc</span>.y(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results returned</span>
<span class="hljs-attribute">result</span>, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.</span>-<span class="hljs-number">0.j</span>, <span class="hljs-number">0.</span>+<span class="hljs-number">1.j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the Y gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code displays the circuit diagram with the Y gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_10.png" alt="Figure 6.6 – Y gate " width="180" height="59"/></figure>
    <p class="packt_figref">Figure 6.10: Y gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch sphere representation has changed from <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker548"/> to <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker549"/>; however, the rotation was done around the <em class="italic">y</em> axis as opposed to the <em class="italic">x</em> axis, and the result, in this case, is the same.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_11.png" alt="A picture containing building, dome  Description automatically generated" width="269" height="311"/></figure>
    <p class="packt_figref">Figure 6.11: Y gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view <a id="_idIndexMarker550"/>the QSphere representation, run the <a id="_idIndexMarker551"/>following in a cell. Of course, you can also use <code class="inlineCode">bloch_sphere</code> to view the Bloch sphere:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has transitioned the state of the qubit from |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker552"/> to |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker553"/>. Note that the colors indicating states might be different based on your system settings or as they could change over time in the code itself when visualized:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_12.png" alt="Figure 6.7 – Y gate QSphere " width="513" height="433"/></figure>
    <p class="packt_figref">Figure 6.12: Y gate QSphere</p>
    <p class="normal">The Y gate, as we <a id="_idIndexMarker554"/>can see from the results, operates very similarly to the X gate, at least <a id="_idIndexMarker555"/>when the origin of the state vector is the same.</p>
    <p class="normal">Now, let’s proceed to the final Pauli gate.</p>
    <h3 id="_idParaDest-102" class="heading-3">Z gate</h3>
    <p class="normal">The <strong class="keyWord">Z gate</strong> is also <a id="_idIndexMarker556"/>commonly referred to as a <strong class="keyWord">phase gate</strong>, mostly <a id="_idIndexMarker557"/>because <a id="_idIndexMarker558"/>rather than rotating along the vertical axis as the X and Y gates do, the Z gate rotates along the longitude of the Hilbert space, hence the phase of the Hilbert space. This is denoted as follows:</p>
    <p class="center"><img src="../Images/B18420_06_060.png" alt="" width="158" height="42"/><a id="_idIndexMarker559"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the input around the <em class="italic">z</em> axis by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker560"/> (180°). If the rotation initializes from the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker561"/> basis state, then the phase does not change; however, if the input initializes from the <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker562"/> state, then the output is a phase shift of <em class="italic">p</em> to <img src="../Images/B18420_06_064.png" alt="" width="40" height="25"/><a id="_idIndexMarker563"/>. This negation is a very important feature that you will see in many quantum algorithms:</p>
    <p class="center"><img src="../Images/Table_06_06.png" alt="Table 6.6 – Truth table of a phase shift around the x axis  " width="220" height="96"/></p>
    <p class="packt_figref">Table 6.6: Truth table of a phase shift around the x axis</p>
    <p class="normal">Let’s now create a circuit for the Z gate:</p>
    <ol>
      <li class="numberedList" value="1">First, we place the qubit into a superposition state using the H gate, and then add a Z gate operator to it:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Z-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit to set the qubit in #superposition</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add a Z gate to the qubit to rotate out of phase by π/2</span>
qc.z(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s <a id="_idIndexMarker564"/>examine the state vector results by running <a id="_idIndexMarker565"/>the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit. Note that depending on how you have things set up, the very small values may be truncated to 0. If this is not set, you may see a very small value, such as <code class="inlineCode">0.00000000e+00j</code>:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([ <span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span>, -<span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the Z gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram with the H gate removed, so don’t think you have to include the H gate in order to use the Z gate—as mentioned earlier, the H gate was just added to illustrate the operational effect of the gate:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_13.png" alt="" width="182" height="60"/></figure>
    <p class="packt_figref">Figure 6.13: Circuit diagram with a Z gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch <a id="_idIndexMarker566"/>sphere representation has changed into a superposition <a id="_idIndexMarker567"/>state between <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker568"/> and <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker569"/>; however, it is on the negative side of the <em class="italic">x</em> axis.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_14.png" alt="A picture containing dome, building  Description automatically generated" width="280" height="317"/></figure>
    <p class="packt_figref">Figure 6.14: Z gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has an equal probability of being |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker570"/> and |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker571"/>; however, the |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker572"/> state you see is out of phase by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker573"/>, as illustrated in the following output:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_15.png" alt="Chart  Description automatically generated" width="458" height="532"/></figure>
    <p class="packt_figref">Figure 6.15: Z gate QSphere representation after first applying an H gate</p>
    <p class="normal">As you can <a id="_idIndexMarker574"/>see in the preceding diagram, the Z gate provides a way <a id="_idIndexMarker575"/>to perform a phase shift on a qubit, causing the state of the qubit to change its sign from positive to negative. If you want to see this for yourself, then try the following.</p>
    <p class="normal">Recall the code you ran earlier to execute an X gate. In that example, we started with the qubit initially at the basis state |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker576"/>, and we then applied an X gate that resulted in the state |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker577"/>. Now, add another line after adding the X gate and include the Z gate. You’ll notice that the result is the same, |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker578"/>, only now you’ll notice that the state result is negative. I’ll leave it to you to try it out for yourself and observe the difference.</p>
    <p class="normal">Let’s move on to the next section, where we will discuss <strong class="keyWord">phase gates</strong>.</p>
    <h2 id="_idParaDest-103" class="heading-2">Phase gates</h2>
    <p class="normal">Phase gates <a id="_idIndexMarker579"/>are what <a id="_idIndexMarker580"/>we use to map |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker581"/> to <img src="../Images/B18420_06_075.png" alt="" width="25" height="27"/><a id="_idIndexMarker582"/>|<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker583"/>, where <img src="../Images/B18420_06_075.png" alt="" width="25" height="27"/><a id="_idIndexMarker584"/> is Euler’s equation. This does not have an effect on the probability of measuring a |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker585"/> or a |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker586"/>; however, it does affect the phase of the quantum state. This may not make sense just yet, but once you start learning about some advanced <a id="_idIndexMarker587"/>features that leverage phase shifts, it will <a id="_idIndexMarker588"/>be very clear. For now, let’s learn about the gates that operate the various phase shifts on a qubit.</p>
    <h3 id="_idParaDest-104" class="heading-3">S gate</h3>
    <p class="normal">The<strong class="keyWord"> S gate</strong> is like <a id="_idIndexMarker589"/>a Z gate; the only difference is the amount by <a id="_idIndexMarker590"/>which the state vector is rotating. For the S gate, that rotation is <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker591"/>. The matrix representation of the S gate is described here:</p>
    <p class="center"><img src="../Images/B18420_06_081.png" alt="" width="129" height="54"/><a id="_idIndexMarker592"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the input around the <em class="italic">z</em> axis by <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker593"/> (90°), hence if the input is |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker594"/>, then the output is a phase shift of <img src="../Images/B18420_06_084.png" alt="" width="58" height="35"/><a id="_idIndexMarker595"/>:</p>
    <p class="center"><img src="../Images/Table_06_07.png" alt="Table 6.7 – Truth table representing phase rotation S  " width="280" height="121"/></p>
    <p class="packt_figref">Table 6.7: Truth table representing phase rotation S</p>
    <p class="normal">We will follow these steps to create a circuit with an S gate:</p>
    <ol>
      <li class="numberedList" value="1">The truth table is best illustrated by placing the vector onto the <em class="italic">x</em> axis first; we will add an H gate first before appending the S gate:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#S-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit to drop the vector onto the #X-axis</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add an S gate to the qubit</span>
qc.s(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints <a id="_idIndexMarker596"/>out the state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">7.07106781e-01</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">4.32978028e-17</span>+<span class="hljs-number">0.70710678j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw <a id="_idIndexMarker597"/>the circuit diagram for the S gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram where we added an H gate to induce superposition and then apply the <strong class="keyWord">S</strong> gate to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_16.png" alt="Figure 6.12 – Circuit with a S gate " width="204" height="49"/></figure>
    <p class="packt_figref">Figure 6.16: Circuit with an S gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch sphere representation has changed into a superposition state, which means it will have an equal probability result of <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker598"/>or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker599"/> but with a phase shift of <img src="../Images/B18420_06_087.png" alt="" width="33" height="25"/><a id="_idIndexMarker600"/>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_17.png" alt="A picture containing text, building, dome, aircraft  Description automatically generated" width="212" height="241"/></figure>
    <p class="packt_figref">Figure 6.17: S gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view <a id="_idIndexMarker601"/>the QSphere representation, run the following <a id="_idIndexMarker602"/>in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has an equal probability of being <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker603"/> and <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker604"/> with a phase shift of <img src="../Images/B18420_06_087.png" alt="" width="33" height="25"/><a id="_idIndexMarker605"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_18.png" alt="Chart, radar chart  Description automatically generated" width="362" height="415"/></figure>
    <p class="packt_figref">Figure 6.18: S gate, <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker606"/> phase rotation on the QSphere</p>
    <p class="normal">As the S gate transitions the state to the positive Z axis by <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker607"/>, we will now see how to transition the state to the negative Z axis by <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker608"/>.</p>
    <h3 id="_idParaDest-105" class="heading-3">S† (dagger) gate</h3>
    <p class="normal">The <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker609"/> gate is the same as the S gate, except it <a id="_idIndexMarker610"/>rotates in the opposite, or negative, direction. Hence the <a id="_idIndexMarker611"/>results are the same, but negated. The matrix representation illustrates this by including the negative in the phase shift:</p>
    <p class="center"><img src="../Images/B18420_06_095.png" alt="" width="140" height="54"/><a id="_idIndexMarker612"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the input around the <em class="italic">z</em> axis by <img src="../Images/B18420_06_096.png" alt="" width="48" height="25"/><a id="_idIndexMarker613"/> (-90). As with the S gate, if the input is the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker614"/> state, then the output is <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker615"/>, but if the input is the <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker616"/> state, the output is a phase rotation in the negative direction:</p>
    <p class="center"><img src="../Images/Table_06_08.png" alt="Table 6.8 – Truth table representation of phase gate  " width="279" height="116"/></p>
    <p class="packt_figref">Table 6.8: Truth table representation of phase gate <img src="../Images/B18420_06_100.png" alt="" width="19" height="25"/><a id="_idIndexMarker617"/></p>
    <p class="normal">This is best illustrated by placing the qubit into a superposition first with an H gate. We then create a circuit diagram for <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker618"/> gate by using these steps:</p>
    <ol>
      <li class="numberedList" value="1">We will add an H gate first before appending the <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker619"/> (<code class="inlineCode">sdg</code>) gate:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Sdg-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit to drop the vector onto the #X-axis</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add an S† gate to the qubit</span>
qc.sdg(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints <a id="_idIndexMarker620"/>out the state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">4.32978028e-17</span>-<span class="hljs-number">0.70710678j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw <a id="_idIndexMarker621"/>the circuit diagram for the <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker622"/> gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram with the <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker623"/> gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_19.png" alt="Figure 6.14 – Circuit with a  gate " width="193" height="41"/></figure>
    <p class="packt_figref">Figure 6.19: Circuit with an <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker624"/> gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch sphere representation has changed into a superposition state, which means it will have an equal probability result of <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker625"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker626"/> with a phase shift of <img src="../Images/B18420_06_108.png" alt="" width="44" height="25"/><a id="_idIndexMarker627"/> or <img src="../Images/B18420_06_096.png" alt="" width="48" height="25"/><a id="_idIndexMarker628"/>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_20.png" alt="A picture containing dome, building  Description automatically generated" width="241" height="273"/></figure>
    <p class="packt_figref">Figure 6.20: <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker629"/> gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view <a id="_idIndexMarker630"/>the QSphere representation, run the following <a id="_idIndexMarker631"/>in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has an equal probability of being <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker632"/> and <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker633"/> with a phase shift of <img src="../Images/B18420_06_108.png" alt="" width="44" height="25"/><a id="_idIndexMarker634"/> or <img src="../Images/B18420_06_096.png" alt="" width="48" height="25"/><a id="_idIndexMarker635"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_21.png" alt="Chart  Description automatically generated" width="392" height="456"/></figure>
    <p class="packt_figref">Figure 6.21: <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker636"/> gate, <img src="../Images/B18420_06_096.png" alt="" width="48" height="25"/><a id="_idIndexMarker637"/> phase rotation on the QSphere</p>
    <p class="normal">Now that <a id="_idIndexMarker638"/>we have created the circuit with an <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker639"/> gate and can shift the phase of the qubit in opposite <a id="_idIndexMarker640"/>directions and are not limited to a single direction to apply phase shifts, we will move on to the next section, which will help us understand how to create a circuit with a T gate.</p>
    <h3 id="_idParaDest-106" class="heading-3">T gate</h3>
    <p class="normal">The <strong class="keyWord">T gate</strong> is the <a id="_idIndexMarker641"/>same as the S gate, only the rotation is <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker642"/>. The matrix representation of the gate is as follows:</p>
    <p class="center"><img src="../Images/B18420_06_119.png" alt="" width="131" height="54"/><a id="_idIndexMarker643"/></p>
    <p class="normal">The following <a id="_idIndexMarker644"/>truth table illustrates that the operation rotates the input around the <em class="italic">z</em> axis by <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker645"/> (45°), hence if the input is the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker646"/> state, then the output will be the same. If the input is <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker647"/>, however, then the output would be a phase rotation of <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker648"/>:</p>
    <p class="packt_figref"><img src="../Images/Table_06_09.png" alt="Table 6.9 – Truth table representation of phase gate T  " width="311" height="147"/></p>
    <p class="packt_figref">Table 6.9: Truth table representation of phase gate T</p>
    <p class="normal">As with all <a id="_idIndexMarker649"/>phase gates, it’s best to begin in a superposition state, so we will start <a id="_idIndexMarker650"/>by including a Hadamard gate, then we will create a circuit using the T gate, as illustrated in the following steps:</p>
    <ol>
      <li class="numberedList" value="1">First, we add an H gate before appending the T gate:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#T-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit to drop the vector onto the #X-axis</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add a T gate to the qubit</span>
qc.t(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">We then examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span> , <span class="hljs-number">0.5</span>+<span class="hljs-number">0.5j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the T gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram with the <strong class="keyWord">T</strong> gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_22.png" alt="Figure 6.16 – Circuit representation of the T gate " width="225" height="50"/></figure>
    <p class="packt_figref">Figure 6.22: Circuit representation of the T gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch <a id="_idIndexMarker651"/>sphere representation has changed into a <a id="_idIndexMarker652"/>superposition state, which means it will have an equal probability result of <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker653"/> or <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker654"/>, and transitioned the phase of the state by <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker655"/>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_23.png" alt="A picture containing dome, building  Description automatically generated" width="291" height="329"/></figure>
    <p class="packt_figref">Figure 6.23: <img src="../Images/B18420_06_094.png" alt="" width="19" height="27"/><a id="_idIndexMarker656"/> gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has transitioned the phase of the state by <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker657"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_24.png" alt="Chart  Description automatically generated" width="358" height="416"/></figure>
    <p class="packt_figref">Figure 6.24: T gate, <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker658"/> phase rotation on the QSphere</p>
    <p class="normal">Similar to <a id="_idIndexMarker659"/>the S gate, we will want to rotate in all directions, so let’s take a look at a <a id="_idIndexMarker660"/>phase gate that transitions the state of the qubit in the opposite direction.</p>
    <h3 id="_idParaDest-107" class="heading-3">T† (dagger) gate</h3>
    <p class="normal">The <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker661"/> gate has the same phase rotation <a id="_idIndexMarker662"/>as the T gate, that is, <img src="../Images/B18420_06_118.png" alt="" width="33" height="25"/><a id="_idIndexMarker663"/>, only in the opposite direction. Its matrix <a id="_idIndexMarker664"/>representation is given as follows:</p>
    <p class="center"><img src="../Images/B18420_06_132.png" alt="" width="142" height="54"/><a id="_idIndexMarker665"/></p>
    <p class="normal">The following truth table illustrates that the operation rotates the input around the <em class="italic">z</em> axis by <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker666"/> (-45 °), so if the input is |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker667"/>, then the output is |<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker668"/>. If the input is |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker669"/>, then the output is a negative rotation of <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker670"/>:</p>
    <p class="center"><img src="../Images/Table_06_10.png" alt="Table 6.10 – Truth table representation of phase gate  " width="273" height="114"/></p>
    <p class="packt_figref">Table 6.10: Truth table representation of phase gate <img src="../Images/B18420_06_138.png" alt="" width="19" height="25"/><a id="_idIndexMarker671"/></p>
    <p class="normal">This too <a id="_idIndexMarker672"/>is best illustrated by placing the vector onto the <em class="italic">x</em> axis first, so we <a id="_idIndexMarker673"/>will create a circuit using the <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker674"/> gate by following these steps:</p>
    <ol>
      <li class="numberedList" value="1">First, we add an H gate before then appending the <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker675"/> (<code class="inlineCode">tdg</code>) gate:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Tdg-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add an H gate to the qubit to drop the vector onto the #X-axis</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add a Tdg gate to the qubit</span>
qc.tdg(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Next, we examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit, where you will notice that the imaginary number is now negative:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.70710678</span>+<span class="hljs-number">0.j</span> , <span class="hljs-number">0.5</span> -<span class="hljs-number">0.5j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker676"/> gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram with the <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker677"/> gate added to the qubit, as shown in the following diagram:</p>
    <p class="packt_figref"><img src="../Images/B18420_06_25.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="182" height="53"/></p>
    <p class="packt_figref">Figure 6.25: Circuit representation using a <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker678"/> gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch <a id="_idIndexMarker679"/>sphere representation has changed <a id="_idIndexMarker680"/>into a superposition state, which means it will have an equal probability result of <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker681"/> or <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker682"/>, and has transitioned the state of the qubit by <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker683"/>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_26.png" alt="A picture containing building, dome  Description automatically generated" width="259" height="294"/></figure>
    <p class="packt_figref">Figure 6.26: <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker684"/> gate, <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker685"/> phase rotation on the Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has transitioned the state of the qubit by <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker686"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_27.png" alt="Chart  Description automatically generated" width="382" height="427"/></figure>
    <p class="packt_figref">Figure 6.27: <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker687"/> gate, <img src="../Images/B18420_06_133.png" alt="" width="48" height="25"/><a id="_idIndexMarker688"/> phase transition on the QSphere</p>
    <p class="normal">The preceding gates, as you might have noticed, have predetermined rotation angles from the <a id="_idIndexMarker689"/>horizontal or vertical axis to help you set the state of the qubit. If you <a id="_idIndexMarker690"/>wish to specify the angle of rotation yourself, the following rotation gates allow you to specify the angle by which to rotate around a given axis. Like the other gates, these rotation gates are also reversible and unitary.</p>
    <h3 id="_idParaDest-108" class="heading-3">Rx gate</h3>
    <p class="normal">You can think of <strong class="keyWord">Rx gates</strong> as your <a id="_idIndexMarker691"/>custom rotation gates. Note that I <a id="_idIndexMarker692"/>used the term <em class="italic">rotate</em> and not <em class="italic">flip</em>. This is because visualizing the operation of the quantum gates is usually done via the QSphere.</p>
    <p class="normal">Because of its spherical presentation, we refer to operations as rotations around the axis by <img src="../Images/B18420_06_152.png" alt="" width="119" height="25"/><a id="_idIndexMarker693"/> (we will see this clearly in the following code examples):</p>
    <p class="center"><img src="../Images/B18420_06_153.png" alt="" width="335" height="48"/><a id="_idIndexMarker694"/></p>
    <p class="normal">By applying a Y rotation, we get the following formula:</p>
    <p class="center"><img src="../Images/B18420_06_154.png" alt="" width="288" height="48"/><a id="_idIndexMarker695"/></p>
    <p class="normal">Finally, a Z rotation will yield the following formula:</p>
    <p class="center"><img src="../Images/B18420_06_155.png" alt="" width="175" height="44"/><a id="_idIndexMarker696"/></p>
    <p class="normal">We’ll create <a id="_idIndexMarker697"/>a circuit using one of the rotation gates – let’s go with the Rz gate:</p>
    <ol>
      <li class="numberedList" value="1">First, we will <a id="_idIndexMarker698"/>rotate along the <em class="italic">z</em> axis by <img src="../Images/B18420_06_156.png" alt="" width="33" height="25"/><a id="_idIndexMarker699"/>. We’ll be using the <code class="inlineCode">math</code> library to <code class="inlineCode">import</code> <code class="inlineCode">pi</code>, and our friendly H gate will be applied to help illustrate the phase shift:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Rz-gate</span>
<span class="hljs-comment">#Create the single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Import pi from the math library</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi
<span class="hljs-comment">#Add an H gate to help visualize phase rotation</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add an RZ gate with an arbitrary angle theta of pi/6</span>
qc.rz(pi/<span class="hljs-number">6</span>, <span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
      <li class="numberedList">Next, we examine the state vector results by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the state vector values of the qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">0.06830127</span>-<span class="hljs-number">0.1830127j</span>, <span class="hljs-number">0.6830127</span>+<span class="hljs-number">0.1830127j</span>], dim=(<span class="hljs-number">2</span>,))
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the Rz gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This displays the circuit diagram with the <strong class="keyWord">Rz </strong>gate added to the qubit, as shown in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_28.png" alt="Diagram  Description automatically generated with medium confidence" width="176" height="50"/></figure>
    <p class="packt_figref">Figure 6.28: Circuit representation using an Rz gate</p>
    <ol>
      <li class="numberedList" value="4">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
      <li class="numberedList">The Bloch <a id="_idIndexMarker700"/>sphere representation has changed into a <a id="_idIndexMarker701"/>superposition state, which means it will have an equal probability result of <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker702"/> or <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker703"/> and has rotated the state by a phase of <img src="../Images/B18420_06_156.png" alt="" width="33" height="25"/><a id="_idIndexMarker704"/>.</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_29.png" alt="A picture containing building, dome  Description automatically generated" width="252" height="285"/></figure>
    <p class="packt_figref">Figure 6.29: RZ gate Bloch sphere</p>
    <ol>
      <li class="numberedList" value="6">To view the QSphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">qsphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The QSphere, as you can see, has transitioned the state by a phase of <img src="../Images/B18420_06_156.png" alt="" width="33" height="25"/><a id="_idIndexMarker705"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_30.png" alt="Chart  Description automatically generated" width="422" height="463"/></figure>
    <p class="packt_figref">Figure 6.30: RZ gate QSphere transitioned phase of π/6</p>
    <p class="normal">These rotation <a id="_idIndexMarker706"/>gates help us provide specific gate rotations around each axis.</p>
    <p class="normal">There are <a id="_idIndexMarker707"/>other universal gates that imitate the function of a custom gate using a more general alternative, so let’s review them next.</p>
    <h2 id="_idParaDest-109" class="heading-2">Universal U gate</h2>
    <p class="normal">The<strong class="keyWord"> U gate</strong>, as mentioned <a id="_idIndexMarker708"/>earlier in the book, is used in order to define a universal <a id="_idIndexMarker709"/>quantum system where you would need to ensure that the quantum system adheres to certain criteria, the most popular <a id="_idIndexMarker710"/>of which are the <strong class="keyWord">DiVincenzo criteria</strong> one of which states that it should have a universal set of quantum gates.</p>
    <p class="normal">We discussed how, in a classical system, both NOR and NAND gates are considered classical universal gates. In a quantum system, the <strong class="keyWord">U</strong> gate is defined as a universal gate, due to its ability to provide multiple degrees of freedom to rotate about the Hilbert space of a qubit. The U gate has parameter fields that determine how much the state vector should move along the given axis. Let’s look at them individually first, and then we’ll apply each gate to a qubit to examine the results.</p>
    <p class="normal">The <strong class="keyWord">U </strong>gate has three parameters that are applied as rotations on all axes, that is, the <em class="italic">x</em> axis, <em class="italic">y</em> axis, and <em class="italic">z</em> axis, respectively. The matrix representation of the U gate is defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_161.png" alt="" width="371" height="54"/><a id="_idIndexMarker711"/></p>
    <p class="normal">In the preceding equation, <img src="../Images/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker712"/>, <img src="../Images/B18420_06_163.png" alt="" width="10" height="25"/><a id="_idIndexMarker713"/>, and <img src="../Images/B18420_06_164.png" alt="" width="10" height="25"/><a id="_idIndexMarker714"/> are the angles of rotation in radians as described in <a id="_idIndexMarker715"/>the preceding <img src="../Images/B18420_06_165.png" alt="" width="75" height="25"/><a id="_idIndexMarker716"/> equation. Note that for the U gate to remain a <a id="_idIndexMarker717"/>unitary operation, that is, <img src="../Images/B18420_06_166.png" alt="" width="55" height="22"/><a id="_idIndexMarker718"/>, the angles must be confined to the range <img src="../Images/B18420_06_167.png" alt="" width="73" height="25"/><a id="_idIndexMarker719"/>, and <img src="../Images/B18420_06_168.png" alt="" width="83" height="25"/><a id="_idIndexMarker720"/>. We can also see these ranges in the U matrix, where these values lie in the arguments of the matrix, which leaves the phase l to also have a range of <img src="../Images/B18420_06_169.png" alt="" width="85" height="25"/><a id="_idIndexMarker721"/>.</p>
    <p class="normal">Let’s create a circuit that implements the U gate:</p>
    <ol>
      <li class="numberedList" value="1">First, we will create a single-qubit circuit and apply the U gate to it with each angle set to <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker722"/>. We’ll reuse our state vector helper function, <code class="inlineCode">execute_circuit_sv</code>, so we can extract the state vector results, and the QSphere to visualize the state vector:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#U-gate</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi
<span class="hljs-comment">#Create a single qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Add a U gate and rotate all parameters by pi/2, and #apply it to the qubit</span>
qc.u(pi/<span class="hljs-number">2</span>, pi/<span class="hljs-number">2</span>, pi/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result value we shall see is set to the following:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([<span class="hljs-number">7.07106781e-01</span>+<span class="hljs-number">0.j</span>, <span class="hljs-number">4.32978028e-17</span>+<span class="hljs-number">0.70710678j</span>], dims=(<span class="hljs-number">2</span>,))
</code></pre>
    <p class="normal-one">Note that for convenience, I replaced the value <code class="inlineCode">4.32978028e-17</code> from the results with a <code class="inlineCode">0</code>, because the number is too small and insignificant.</p>
    <ol>
      <li class="numberedList" value="2">The expected <a id="_idIndexMarker723"/>circuit diagram for <strong class="keyWord">U</strong> is as follows, with the <a id="_idIndexMarker724"/>parameters listed at the bottom:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_31.png" alt="A picture containing diagram  Description automatically generated" width="264" height="80"/></figure>
    <p class="packt_figref">Figure 6.31: The U gate set with all rotation parameters to <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker725"/></p>
    <ol>
      <li class="numberedList" value="3">Now, to view the Bloch sphere representation, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">bloch_sphere
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The Bloch sphere representation has changed so that the state is set after all parameters have applied the specified rotation.</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_32.png" alt="A picture containing text, building, dome  Description automatically generated" width="259" height="302"/></figure>
    <p class="packt_figref">Figure 6.32: U gate, Bloch sphere representation with all parameters set to <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker726"/></p>
    <p class="normal-one">The QSphere representation, produced by executing the <code class="inlineCode">qsphere</code> command, is shown as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_33.png" alt="Chart  Description automatically generated" width="367" height="430"/></figure>
    <p class="packt_figref">Figure 6.33: The QSphere representation of the U gate set with all parameters to <img src="../Images/B18420_06_029.png" alt="" width="33" height="25"/><a id="_idIndexMarker727"/></p>
    <p class="normal">As you <a id="_idIndexMarker728"/>can see, you can apply various angles to the U gate in order to <a id="_idIndexMarker729"/>set the state of the qubit into any point in the Hilbert space. This also allows you to initialize the state of a qubit using the U gate to set the state.</p>
    <p class="normal">Now you know that single-qubit gates provide many ways to create a complex linear combination of their basis states, but manipulation of a single qubit alone is not enough to carry out <a id="_idIndexMarker730"/>the functionality that most quantum algorithms require. One such example is <strong class="keyWord">quantum entanglement</strong>. This is where multi-qubit gates come into play. Let’s learn about those in the next section.</p>
    <h1 id="_idParaDest-110" class="heading-1">Understanding multi-qubit gates</h1>
    <p class="normal">As <a id="_idIndexMarker731"/>described in <em class="chapterRef">Chapter 5, Understanding the Qubit</em>, two or more qubits can <a id="_idIndexMarker732"/>combine their states by their <strong class="keyWord">tensor product</strong>, sometimes <a id="_idIndexMarker733"/>referred to as the <strong class="keyWord">Kronecker product</strong>.</p>
    <p class="normal">In this section, we will discuss the multi-qubit gates and how they operate on the qubits similarly to how single-qubit gates do, which includes them being unitary and reversible.</p>
    <p class="normal">To keep the descriptions and examples uniform, the following descriptions of the multi-qubit gates will be presented the same way as the single-qubit gates. We will open the helper file again and review another function titled <code class="inlineCode">execute_circuit_returns</code>. The helper function will have a few differences, the first of which will be the Qiskit primitive Sampler to run our circuits. We are using this for now so that you don’t use up your quantum hardware allotted time on these simple circuits. Save the hardware for the fun work later in this book. Also, just like the previous helper function we used for single qubit gates, this will <a id="_idIndexMarker734"/>return multiple values including: total counts, circuit diagram, and histogram (or distribution) of results. Let’s review the code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Will execute the circuit on the Sampler primitive</span>
<span class="hljs-comment"># Returns results, circuit diagram, and histogram</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">execute_circuit_returns</span>(<span class="hljs-params">quantum_circuit</span>):
    <span class="hljs-keyword">from</span> qiskit.primitives <span class="hljs-keyword">import</span> Sampler
    sampler = Sampler()
   
result = sampler.run(quantum_circuit, shots=<span class="hljs-number">1024</span>).result()
    quasi_dists = result.quasi_dists
<span class="hljs-comment">#Get the counts</span>
counts = quasi_dists[<span class="hljs-number">0</span>].binary_probabilities()
circuit_diagram = quantum_circuit.draw(output="mpl")
    <span class="hljs-comment">#Create a histogram of the results</span>
    histogram = plot_distribution(counts)
    <span class="hljs-comment">#Return the results, circuit diagram, and histogram</span>
    <span class="hljs-keyword">return</span> counts, circuit_diagram, histogram
</code></pre>
    <p class="normal">The purpose of switching over to the Sampler primitive is not that we can’t use the state vector simulator; it’s primarily so we can observe some of the interesting characteristics of our circuit and the gates. For those who wish to use the state vector simulator, do not worry. There will be some challenges in the <em class="italic">Questions</em> section at the end of this chapter that will allow you to use it.</p>
    <p class="normal">Another difference you will see is that we are no longer using the Bloch sphere or QSphere to visualize the quantum states. Rather, we will replace them with a <code class="inlineCode">histogram</code> plot of the quasi-distribution, which is a dict-like class for representing the quasi-probabilities. For each circuit we will be creating, we will include more than one qubit, as these multi-qubit gates all operate on two or more qubits.</p>
    <p class="normal">Now that we <a id="_idIndexMarker735"/>have reviewed our helper function, let’s move on to the next set of gates, the <strong class="keyWord">multi-qubit gates</strong>,<strong class="keyWord"> specifically 2-qubit gates</strong>. These include the following:</p>
    <ul>
      <li class="bulletList">The<strong class="keyWord"> CNOT</strong> gate</li>
      <li class="bulletList">The<strong class="keyWord"> Toffoli</strong> gate</li>
      <li class="bulletList">The<strong class="keyWord"> Swap</strong> gate</li>
    </ul>
    <p class="normal">We will learn about these gates in the following sections.</p>
    <h2 id="_idParaDest-111" class="heading-2">CNOT two-qubit gate</h2>
    <p class="normal">The <strong class="keyWord">CNOT gate</strong>, often referred <a id="_idIndexMarker736"/>to as a <strong class="keyWord">Control-NOT</strong> gate, is <a id="_idIndexMarker737"/>similar to the <strong class="keyWord">XOR</strong> classical-bit gate in that if you provide two input states of either 0 or 1, the results will be the same as if the input states were run through an XOR gate. The CNOT gate is composed of two parts.</p>
    <p class="normal">The first part is the <strong class="keyWord">Control</strong>, which is connected to one of the qubits, and is what triggers the CNOT gate to perform an operation on the other qubit connected to the other end of the CNOT gate, the <strong class="keyWord">Target</strong>.</p>
    <p class="normal">The Target is an operation that will be performed on the other qubit; in this case, it’s a <strong class="keyWord">NOT</strong> operation. Recall from the previous section on single-qubit gates that the NOT gate rotates the qubit about the <em class="italic">x</em> axis by <img src="../Images/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker738"/>. The CNOT gate is one of the more commonly used multi-qubit gates as it is how qubits get entangled.</p>
    <p class="normal">The CNOT gate is also <a id="_idIndexMarker739"/>described as a <strong class="keyWord">Control-X</strong> (<strong class="keyWord">CX</strong>) gate since the target is often coded as an X operation. You will see this CX gate convention when running the following example.</p>
    <p class="normal">The matrix representation of a CNOT gate is a <em class="italic">4 x 4</em> matrix due to the tensor product of two qubits, as illustrated here:</p>
    <p class="center"><img src="../Images/B18420_06_175.png" alt="" width="160" height="88"/><a id="_idIndexMarker740"/></p>
    <p class="normal">Notice that the top-left <em class="italic">2 x 2</em> quadrant of the CNOT matrix represents an Identity matrix, I, and the bottom-right <em class="italic">2 x 2</em> quadrant represents the <strong class="keyWord">X</strong> matrix. This matrix describes the state when the first qubit, q<sub class="subscript">0</sub>, is the Target and the second qubit, q<sub class="subscript">1</sub>, is the Control.</p>
    <p class="normal">The following truth table illustrates that when the Control qubit (the left side of the input vector) is 0, there is no change to the Target qubit (the right side of the input vector). When <a id="_idIndexMarker741"/>the Control qubit is set to 1, then the <a id="_idIndexMarker742"/>Target qubit operation is enabled and therefore rotates the Target qubit around the <em class="italic">x</em> axis by π (that is, 180°):</p>
    <p class="center"><img src="../Images/Table_06_11.png" alt="Table 6.11 – Truth table representation of CNOT gate " width="254" height="160"/></p>
    <p class="packt_figref">Table 6.11: Truth table representation of CNOT gate</p>
    <p class="normal">Let’s now create a circuit, add a CNOT gate, and execute it:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by creating a two-qubit quantum circuit and applying a Hadamard gate on the first qubit, and a CNOT gate on the two qubits, where the Control is set to the first qubit and the Target is set to the second qubit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#CNOT-gate</span>
<span class="hljs-comment">#Create a two-qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">2</span>)
<span class="hljs-comment">#Add an H gate to the qubit</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add an CNOT gate where, control = first, target = second #qubit</span>
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment">#Measure all qubits and send results to classical bits</span>
qc.measure_all()
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
counts, img, histogram = execute_circuit_returns(qc)
</code></pre>
      </li>
      <li class="numberedList">Then, we will review the result counts by running the following cell:
        <pre class="programlisting code-one"><code class="hljs-code">counts
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the count results:</p>
    <pre class="programlisting code-one"><code class="hljs-code">{<span class="hljs-string">'11'</span>: <span class="hljs-number">526</span>, <span class="hljs-string">'00'</span>: <span class="hljs-number">498</span>}
</code></pre>
    <ol>
      <li class="numberedList" value="3">To draw the circuit diagram for the CNOT gate, run the following in a cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The following <a id="_idIndexMarker743"/>circuit diagram <a id="_idIndexMarker744"/>illustrates the CNOT gate, where the Control is q<sub class="subscript">0</sub> and the Target is q<sub class="subscript">1</sub>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_34.png" alt="A picture containing text, clock  Description automatically generated" width="509" height="270"/></figure>
    <p class="packt_figref">Figure 6.34: Circuit representation using a CNOT gate</p>
    <ol>
      <li class="numberedList" value="4">To view the histogram results with the counts after executing the previous circuit, enter the following into a cell:
        <pre class="programlisting code-one"><code class="hljs-code">histogram
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The following illustrates the results including an H gate. The following graph shows the probabilities of the results being either 00 or 11:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_06_35.png" alt="Chart, bar chart  Description automatically generated" width="579" height="388"/></figure>
    <p class="packt_figref">Figure 6.35: Histogram representation of CNOT results from circuit, where the y axis represents the quasi-probabilities of the result.</p>
    <p class="normal">The results <a id="_idIndexMarker745"/>from the previous circuit <a id="_idIndexMarker746"/>illustrate how the CNOT gates can be used to entangle two qubits, where one qubit can control the operation of another qubit, in this case, applying a NOT gate to the target qubit.</p>
    <p class="normal">In the following section, I will clarify what the entanglement of multiple qubits means. There are other <a id="_idIndexMarker747"/>Control gates that implement other operations, such as <strong class="keyWord">Control-Y</strong> (<strong class="keyWord">CY</strong>), <strong class="keyWord">Control-Z</strong> (<strong class="keyWord">CZ</strong>), <strong class="keyWord">Control-H</strong> (<strong class="keyWord">CH</strong>), and more. These gates all share the same <a id="_idIndexMarker748"/>characteristics <a id="_idIndexMarker749"/>as the CNOT (<strong class="keyWord">CX</strong>, <strong class="keyWord">Control-X</strong>) gate in that they have a Source and Target. The main difference, as you can imagine, is the operation that the Target would follow. For the CNOT gate, the Target would operate with an X gate, and naturally, a Control-Y gate would operate a Y gate on the Target qubit. Try out a few for yourself and see how the results differ. Notice that the operations will be the same as if you run the single gate to the Target gate.</p>
    <p class="normal">The last multi-qubit gate we will focus on, which is also used in a variety of quantum algorithms, is the <strong class="keyWord">Toffoli</strong> gate.</p>
    <h2 id="_idParaDest-112" class="heading-2">Toffoli multi-qubit gate</h2>
    <p class="normal">The <strong class="keyWord">Toffoli</strong> gate is <a id="_idIndexMarker750"/>named after Tommaso Toffoli, an Italian-American professor in <a id="_idIndexMarker751"/>computer and electrical engineering at Boston University. This gate is very similar to the multi-qubit Control gates mentioned earlier, only this gate has multiple Controls and a single Target, which in this case is a NOT gate. To simplify the description of multi-control gates, they are written out in the following format: <strong class="keyWord">CCX</strong>. This is to indicate it is a dual-controlled Control-Not gate, and a <strong class="keyWord">CCCX</strong> is a triple-controlled Control-Not gate.</p>
    <p class="normal">The general matrix representation of a Toffoli gate is an <em class="italic">8 x 8</em> matrix because of the tensor product of three qubits, as illustrated in the following matrix. Notice that the first three diagonal <em class="italic">2 x 2</em> matrix blocks are the Identity matrix and the last <em class="italic">2 x 2</em> matrix (bottom right) is a NOT gate representation that flips the qubit. Note that the matrix for the Toffoli gate in Qiskit is slightly different as it increases the matrix size by 2<sup class="superscript">n</sup>, where <em class="italic">n</em> is the number <a id="_idIndexMarker752"/>of qubits onto which the gate is applied. In this case, we have 2<sup class="superscript">3</sup> since we <a id="_idIndexMarker753"/>have a three-qubit gate:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_176.png" alt="" width="246" height="177"/><a id="_idIndexMarker754"/></figure>
    <p class="normal">Let’s run this gate to see the results of it on our quantum circuit:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by creating a three-qubit quantum circuit and applying a <code class="inlineCode">CCX</code> (Toffoli) gate, where the first two qubits are the control qubits, and the third qubit is the target qubit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Toffoli (CCX)-gate</span>
<span class="hljs-comment">#Create a three-qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">3</span>)
<span class="hljs-comment">#Enable the Control qubits, first two qubits, of the Toffoli gate</span>
qc.x(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>))
<span class="hljs-comment">#Add the Toffoli gate (CCX)</span>
qc.ccx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of executing this circuit will be no surprise, and consists of 8 possible states since we are running everything on a three-qubit circuit, which means 2<sup class="superscript">3</sup> basis states, where the last state, 111, is the only one set:</p>
    <pre class="programlisting code-one"><code class="hljs-code">[0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j
 0.+0.00000000e+00j 0.+0.00000000e+00j 0.+0.00000000e+00j
 0.+0.00000000e+00j 1.-3.05311332e-16j]
</code></pre>
    <ol>
      <li class="numberedList" value="2">Let’s <a id="_idIndexMarker755"/>visualize the Bloch sphere in a new cell:
        <pre class="programlisting gen-one"><code class="hljs">bloch_sphere
</code></pre>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_36.png" alt="A picture containing text, dome, building  Description automatically generated" width="757" height="261"/></figure>
    <p class="packt_figref">Figure 6.36: Bloch sphere representation from the Toffoli (CCX) gate circuit results</p>
    <ol>
      <li class="numberedList" value="3">And now <a id="_idIndexMarker756"/>let’s see our results on the QSphere with the <code class="inlineCode">qsphere</code> command:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_37.png" alt="A picture containing text, dome  Description automatically generated" width="396" height="415"/></figure>
    <p class="packt_figref">Figure 6.37: Qsphere representation from the Toffoli (CCX) gate circuit results</p>
    <p class="normal-one">As we can see from the above results, the final state is <img src="../Images/B18420_06_177.png" alt="" width="44" height="25"/><a id="_idIndexMarker757"/>, as expected, since the qubits all start in the <img src="../Images/B18420_06_178.png" alt="" width="44" height="25"/><a id="_idIndexMarker758"/> state, but as the control qubits are each set to <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker759"/>, this sets the target qubit, a NOT gate, to enable and, therefore, change the state of the target qubit q<sub class="subscript">2</sub> to the <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker760"/> state, therefore rendering <a id="_idIndexMarker761"/>the results <img src="../Images/B18420_06_177.png" alt="" width="44" height="25"/><a id="_idIndexMarker762"/>.</p>
    <p class="normal-one">The circuit <a id="_idIndexMarker763"/>diagram for the Toffoli gate is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_38.png" alt="Figure 6.31 – Circuit representation of a Toffoli (CCX) gate " width="210" height="175"/></figure>
    <p class="packt_figref">Figure 6.38: Circuit representation of a Toffoli (CCX) gate</p>
    <ol>
      <li class="numberedList" value="4">Let’s see how the base gates are used to create this three-qubit gate. In a new cell, run the <code class="inlineCode">decompose</code> function of the quantum circuit:
        <pre class="programlisting gen-one"><code class="hljs">qc_decomposed = qc.decompose()
qc_decomposed.draw(output="mpl")
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will result in the following illustration of all the gates needed to create a single Toffoli gate. Note that this may be different as this was how it was displayed at the time of writing:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_39.png" alt="Figure 6.32 – Gates necessary to create a Toffoli (CCX) gate " width="762" height="170"/></figure>
    <p class="packt_figref">Figure 6.39: Gates necessary to create a Toffoli (CCX) gate</p>
    <p class="normal">This looks very complicated. You can see that the use of the various single-qubit and multi-qubit gates used to represent this one gate are quite complex. In this example, you can see the use of H, CNOT, and <img src="../Images/B18420_06_130.png" alt="" width="21" height="27"/><a id="_idIndexMarker764"/> gates. There <a id="_idIndexMarker765"/>are other multi-qubit gates that leverage single and two-qubit <a id="_idIndexMarker766"/>gates in order to operate. The Toffoli gate allows us to operate on multiple qubits, which we shall see later on when we start to delve into quantum algorithms.</p>
    <p class="normal">Let’s look at a gate we would use to swap information between one qubit and another.</p>
    <h2 id="_idParaDest-113" class="heading-2">Swap gate</h2>
    <p class="normal">The<strong class="keyWord"> swap gate</strong> is used <a id="_idIndexMarker767"/>to swap two qubit values. The matrix <a id="_idIndexMarker768"/>representation of the swap gate is defined as follows:</p>
    <p class="center"><img src="../Images/B18420_06_183.png" alt="" width="171" height="88"/><a id="_idIndexMarker769"/></p>
    <p class="normal">Let’s create a circuit and implement this by swapping two qubits:</p>
    <ol>
      <li class="numberedList" value="1">We will set the first qubit to the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker770"/> state and the second qubit to the <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker771"/> state. Then, we will invoke a swap between the two using the <code class="inlineCode">swap</code> gate and verify the results of each qubit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Swap-gate</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi
<span class="hljs-comment">#Create a two-qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">2</span>)
<span class="hljs-comment">#Qubit 0 is initialized to |0&gt; state</span>
<span class="hljs-comment">#Prepare qubit 1 to the |1&gt; state</span>
qc.x(<span class="hljs-number">1</span>)
<span class="hljs-comment">#Now swap gates</span>
qc.swap(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, qsphere, bloch_sphere = execute_circuit_sv(qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">By viewing the resulting diagram of the circuit (<code class="inlineCode">img</code>) you will see a circuit diagram of the swap gate as shown here, just after the X gate we included for comparison:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_40.png" alt="Figure 6.33 – Circuit diagram of an X gate followed by a Swap gate " width="259" height="115"/></figure>
    <p class="packt_figref">Figure 6.40: Circuit diagram of an X gate followed by a Swap gate</p>
    <ol>
      <li class="numberedList" value="2">Before viewing the Bloch sphere and QSphere result for each qubit, let’s take a moment to review what we expect to see. Our two qubits are first initialized <a id="_idIndexMarker772"/>to the <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker773"/> state, and we then applied an X gate <a id="_idIndexMarker774"/>to the second qubit (q1) to change its state to <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker775"/>. Finally, we added a Swap gate to swap the value of q<sub class="subscript">0</sub> and q<sub class="subscript">1</sub>, which would result in <img src="../Images/B18420_06_188.png" alt="" width="71" height="25"/><a id="_idIndexMarker776"/> and <img src="../Images/B18420_06_189.png" alt="" width="69" height="25"/><a id="_idIndexMarker777"/>. Let’s see the results of both the Bloch sphere and QSphere:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_41.png" alt="A picture containing text, dome, building  Description automatically generated" width="436" height="236"/></figure>
    <p class="packt_figref">Figure 6.41: Bloch sphere representation of a Swap gate</p>
    <ol>
      <li class="numberedList" value="3">Here, the results you see swap the value of one qubit with the other, which ends up with qubit 0 with the value we set or qubit 1, and vice versa. Let’s now look at the QSphere results:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_06_42.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="467" height="413"/></figure>
    <p class="packt_figref">Figure 6.42: QSphere representation after applying the Swap gate</p>
    <p class="normal-one">Excellent! The <a id="_idIndexMarker778"/>results, as we can see in the previous <a id="_idIndexMarker779"/>diagram, show that the state vectors for both qubits are set as expected, with <img src="../Images/B18420_06_188.png" alt="" width="71" height="25"/><a id="_idIndexMarker780"/> and <img src="../Images/B18420_06_191.png" alt="" width="69" height="25"/><a id="_idIndexMarker781"/>.</p>
    <div class="note">
      <p class="normal">This is a good opportunity to describe how the order of the qubit results is displayed in the Bra-Ket notation. Note from the values in the QSphere in the previous figure that the qubit at position 0 (the right-most value) is set to one and the qubit at position 1 is set to zero. This is the Bra-Ket qubit order. As more qubits are added, they are therefore appended to the left of the previous qubits, for example, <img src="../Images/B18420_06_192.png" alt="" width="58" height="28"/><a id="_idIndexMarker782"/></p>
    </div>
    <p class="normal">In this section, we have learned about multi-qubit gates, namely, CNOT and Toffoli gates. We also learned about an extra gate, that is, the Swap gate.</p>
    <p class="normal">Now that we are familiar with single-qubit and multi-qubit gates, let’s review the non-reversible measurement operators.</p>
    <h1 id="_idParaDest-114" class="heading-1">Understanding the measurement operator</h1>
    <p class="normal">A <strong class="keyWord">non-reversible operator</strong> is an operator that is applied on a qubit(s), and if applying the same operator <a id="_idIndexMarker783"/>again on the same qubits, then the results will not return the qubits to the same state that they had prior to applying the operator.</p>
    <p class="normal">This section will cover the non-reversible operators, specifically the measurement operator, and the reasons why they are just as important as the other operators discussed previously.</p>
    <p class="normal"><strong class="keyWord">Measurement</strong> is an <a id="_idIndexMarker784"/>operator that instructs the quantum system to measure the quantum state of the system. Before we dive into how we include the measurement instruction in our quantum circuits, let’s first define what is meant by measuring the quantum state of the system.</p>
    <div class="note">
      <p class="normal">Note that measurement outcomes are in general probabilistic. What we lose in information is the complex amplitude of each computational basis state, into which we can encode information. At best, we can rerun and measure the circuit multiple times to at least get statistics.</p>
    </div>
    <p class="normal">We know from quantum mechanics that the information about a quantum system is impossible to access, specifically the measurement of the qubit’s complex amplitudes. For example, let’s say that we have a qubit in a superposition state <img src="../Images/B18420_06_193.png" alt="" width="25" height="25"/><a id="_idIndexMarker785"/>, where the complex amplitudes sum to 1:</p>
    <p class="center"><img src="../Images/B18420_06_194.png" alt="" width="117" height="71"/><a id="_idIndexMarker786"/></p>
    <p class="normal">A measurement of the preceding cannot provide the complex amplitude information in <img src="../Images/B18420_06_195.png" alt="" width="13" height="25"/><a id="_idIndexMarker787"/>. What the measurement of a qubit returns is the basis <img src="../Images/B18420_06_196.png" alt="" width="19" height="25"/><a id="_idIndexMarker788"/> with a probability <img src="../Images/B18420_06_197.png" alt="" width="35" height="25"/><a id="_idIndexMarker789"/> of the state <img src="../Images/B18420_06_193.png" alt="" width="25" height="25"/><a id="_idIndexMarker790"/> in the standard basis.</p>
    <p class="normal">We viewed an example of this earlier when describing the Hadamard gate. When we set the qubit in a complex linear combination of a|<img src="../Images/B18420_06_027.png" alt="" width="19" height="25"/><a id="_idIndexMarker791"/> and b|<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker792"/>, where a and b are the complex amplitudes of the basis states, the measurement result was based on the probability <img src="../Images/B18420_06_201.png" alt="" width="31" height="25"/><a id="_idIndexMarker793"/> of measuring <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker794"/> and <img src="../Images/B18420_06_203.png" alt="" width="29" height="25"/><a id="_idIndexMarker795"/> of measuring |<img src="../Images/B18420_04_055.png" alt="" width="19" height="25"/><a id="_idIndexMarker796"/>, which for a Hadamard gate results in 50%, or <img src="../Images/B18420_06_205.png" alt="" width="60" height="29"/><a id="_idIndexMarker797"/>.</p>
    <p class="normal">An important thing to note about measuring the state of a system is that once you measure it, the quantum information of the system is lost. What this means is that by measuring the qubit(s), the state will collapse into one of the two basis states, <img src="../Images/B18420_06_015.png" alt="" width="23" height="25"/><a id="_idIndexMarker798"/> or <img src="../Images/B18420_06_018.png" alt="" width="23" height="25"/><a id="_idIndexMarker799"/>, based on the amplitude of the components, <img src="../Images/B18420_06_195.png" alt="" width="13" height="25"/><a id="_idIndexMarker800"/> and <img src="../Images/B18420_06_209.png" alt="" width="13" height="25"/><a id="_idIndexMarker801"/>, of the quantum state. After the measurement, you no longer have the information contained in a and b to do anything else.</p>
    <p class="normal">If you were <a id="_idIndexMarker802"/>to try to measure the same qubit that you just measured, the result will be the same as the first measurement but will not set the qubit back <a id="_idIndexMarker803"/>to the quantum state in which it was prior to the measurement. Therefore, measurement is a non-reversible operator.</p>
    <p class="normal">Once the measurement is completed, the result is then sent over to the classical bit, which will return the information back to the classical system. Now that we understand how the measurement works and what the results of the measurements are, let’s run some code to see it at work!</p>
    <p class="normal">In this example, we will create a Bell state circuit (we covered these in detail in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Quantum Computing Principles</em>), which contains a Hadamard followed by a CNOT gate:</p>
    <ol>
      <li class="numberedList" value="1">First, we will add the measurement function, <code class="inlineCode">measure_all(),</code> at the end of the circuit, which will automatically map the results of measuring the qubits to their respective classical bits. We will also add Hadamard and CNOT gates:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#CNOT-gate</span>
<span class="hljs-comment">#Create a two-qubit circuit</span>
qc = QuantumCircuit(<span class="hljs-number">2</span>)
<span class="hljs-comment">#Add an H gate to the qubit</span>
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Add a CNOT gate where, control = first, target = second</span>
<span class="hljs-comment">#qubit</span>
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment">#Measure qubits and map to classical bits</span>
qc.measure_all()
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, histogram = execute_circuit_returns(qc)
</code></pre>
      </li>
      <li class="numberedList">Let’s now view our results by entering the following in a new cell:
        <pre class="programlisting code-one"><code class="hljs-code">Result
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Our results are as follows:</p>
    <pre class="programlisting code-one"><code class="hljs-code">{<span class="hljs-string">'11'</span>: <span class="hljs-number">448</span>, <span class="hljs-string">'00'</span>: <span class="hljs-number">512</span>}
</code></pre>
    <ol>
      <li class="numberedList" value="3">Our helper <a id="_idIndexMarker804"/>function also included the <code class="inlineCode">histogram</code> plot, which <a id="_idIndexMarker805"/>helps visualize the preceding results. To view the histogram, enter the following into the next cell:
        <pre class="programlisting code-one"><code class="hljs-code">histogram
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The output is the following histogram plot:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_43.png" alt="Chart, bar chart  Description automatically generated" width="661" height="445"/></figure>
    <p class="packt_figref">Figure 6.43: Histogram chart of measured results</p>
    <ol>
      <li class="numberedList" value="4">Now let’s see what the circuit looks like with the measurement operators added. Run the following in another cell:
        <pre class="programlisting code-one"><code class="hljs-code">img
</code></pre>
      </li>
    </ol>
    <p class="normal-one">At the end of the circuit illustrated in the following diagram, you will see that the measurement operators were added to all qubits. You’ll see that the labels for the classical bits are titled <strong class="keyWord">measure</strong>, and the qubits are mapped <a id="_idIndexMarker806"/>to their respective bits labeled by the index <a id="_idIndexMarker807"/>numbers where the measurement terminates onto the classical bit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_06_44.png" alt="Figure 6.36 – Measurement operators added to a quantum circuit " width="428" height="148"/></figure>
    <p class="packt_figref">Figure 6.44: Measurement operators added to a quantum circuit</p>
    <p class="normal-one">The barrier is added there just for convenience to visualize where the circuit operations end and where the measurement will commence.</p>
    <ol>
      <li class="numberedList" value="5">The <code class="inlineCode">measure_all()</code> function is a nice and convenient way to apply measurement operators to your quantum circuit. You can also apply a <code class="inlineCode">measurement</code> operator to each qubit separately and at separate times, or you can arrange the mapping using a list if you wish to change the assignment of a qubit to a classical bit. Let’s rewrite our function again, only this time we’ll add the measurement operators individually for the first circuit (<code class="inlineCode">qc1</code>) and then do the same with the second circuit (<code class="inlineCode">qc2</code>) using a list. This way you can see the various ways in which you can apply measurement operators, either to all at once, or just to measure certain qubits:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Measurement operator</span>
<span class="hljs-comment">#Create two separate two-qubit,</span>
<span class="hljs-comment">#and two classical bit circuits</span>
qc1 = QuantumCircuit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
qc2 = QuantumCircuit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
<span class="hljs-comment">#In the first circuit (qc1), measure qubits individually</span>
qc1.measure(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)
qc1.measure(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment">#In the second circuit (qc2) measure using a list</span>
qc2.measure([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])
<span class="hljs-comment">#Execute the circuit and capture all the results</span>
result, img, histogram = execute_circuit_returns(qc1)
result2, img2, histogram2 = execute_circuit_returns(qc2)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">After <a id="_idIndexMarker808"/>executing the code, display the two images (<code class="inlineCode">img</code> and <code class="inlineCode">img2</code>) in separate cells and notice that both circuits appear the same <a id="_idIndexMarker809"/>with respect to the measurement operators.</p>
    <p class="normal">In this section, you learned about non-reversible operators. We also created a simple two-qubit circuit using a measurement operator.</p>
    <h1 id="_idParaDest-115" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned all the various ways you can operate on both single and multiple qubits. The operations provide various vector states that each qubit can rotate into. You also learned how to visualize the gates on a circuit and learned to decompose them down to universal gates so you can realize the information that is passed onto the quantum system.</p>
    <p class="normal">You have now understood how these gates operate on qubits. You now have skills that will greatly help you understand how gates are used in many quantum algorithms to position the vectors in the Hilbert space of each qubit to help resolve various problems.</p>
    <p class="normal">In the next chapter, we will learn about the <strong class="keyWord">Quantum Information Science Kit</strong> (<strong class="keyWord">Qiskit</strong>), pronounced <em class="italic">kiss-kit</em> (depending on who you ask, it may also be pronounced <em class="italic">kwis-kit</em>). Qiskit provides, besides many of the objects and functions we have been using so far to manipulate qubits, other functionality that helps to create quantum algorithms, mitigate against noise found in near-term devices, and produce quantum algorithms for users to leverage without having to learn about them at the gate level.</p>
    <h1 id="_idParaDest-116" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">For the multi-qubit gates, try flipping the Source and Target. Do you see a difference when you decompose the circuit?</li>
      <li class="numberedList">Decompose all the gates for both single and multi-qubit circuits. What do you notice about how the universal gates are constructed?</li>
      <li class="numberedList">Implement the Toffoli gate where the target is the center qubit of a three-qubit circuit.</li>
      <li class="numberedList">Decompose the Toffoli gate. How many gates in total are used to construct it?</li>
      <li class="numberedList">Apply the Toffoli gate along with a Hadamard gate to a state vector simulator and compare the results to that from the Sampler primitive. What differences do you see and why?</li>
      <li class="numberedList">If you wanted to sort three qubits in the opposite direction, which gates would you use and in which order?</li>
    </ol>
    <h1 id="_idParaDest-117" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_6.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code261762599683826593.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>