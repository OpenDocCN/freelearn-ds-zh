- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iSAX – The Required Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know all about SAX, including normalization and computing the SAX
    representation of a subsequence, it is time to learn the theory behind the iSAX
    index, which, at the time of writing, is considered one of the best time-series
    indexes. Improved versions of iSAX that make iSAX faster and more compact exist,
    but the core ideas remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed from its name, iSAX depends on SAX in some way. Put
    simply, **the keys to every iSAX index are SAX representations**. Therefore, searching
    in an iSAX index depends on SAX representations.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, I believe it would be good to provide more information about
    iSAX to help you while reading this chapter. An **iSAX index** is a tree-like
    structure where the root, and only the root, can have multiple children, and all
    the children of the root are binary trees underneath. Additionally, to create
    an iSAX index, we need a time series and a threshold value, which is the maximum
    number of subsequences that a leaf node (a terminal node in iSAX terminology)
    can store, as well as a segment value and a cardinality value. The last two parameters
    are related to the SAX representation. All of this is explained in more detail
    in this chapter, but it’s good to have the big picture in mind as early on as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, in this chapter, we are going to manually construct a small iSAX
    index step by step to better understand the process, using lots of visualizations.
    Please make sure that you carry out this process on your own after you finish
    reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Background information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how iSAX works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How iSAX is constructed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually constructing an iSAX index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the `counting.py` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repository for this book can be found at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    3*](B14769_03.xhtml#_idTextAnchor081) can be found in the `ch03` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Background information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first section, we are going to learn about the basic definitions and
    concepts related to iSAX. But first, we are going to mention the research paper
    that describes the operation of iSAX. iSAX and its operation are described in
    *iSAX: disk-aware mining and indexing of massive time series datasets*, which
    was written by Jin Shieh and Eamonn Keogh. You do not have to read this paper
    from start to finish but, as we mentioned for the SAX research paper, it would
    benefit you to read its abstract and introduction section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there have been various improvements to iSAX, mainly to make
    it faster, which are presented in the following research papers:'
  prefs: []
  type: TYPE_NORMAL
- en: '*iSAX 2.0: Indexing and Mining One Billion Time Series*, written by Alessandro
    Camerra, Themis Palpanas, Jin Shieh, and Eamonn Keogh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Beyond one billion time series: Indexing and mining very large time series
    collections with iSAX2+*, written by Alessandro Camerra, Jin Shieh, Themis Palpanas,
    Thanawin Rakthanmanon, and Eamonn Keogh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DPiSAX: Massively Distributed Partitioned iSAX*, written by Djamel-Edine Yagoubi,
    Reza Akbarinia, Florent Masseglia, and Themis Palpanas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Evolution of a Data Series Index: The iSAX Family of Data Series Indexes:
    iSAX, iSAX2.0, iSAX2+, ADS, ADS+, ADS-Full, ParIS, ParIS+, MESSI, DPiSAX, ULISSE,
    Coconut-Trie/Tree, Coconut-LSM*, written by Themis Palpanas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are not going to deal with the aforementioned research papers in this book
    as we are working with the initial version of the iSAX index. You do not have
    to read all these papers for the purposes of this book, but it would be a great
    exercise to have a look through them when you feel comfortable with iSAX.
  prefs: []
  type: TYPE_NORMAL
- en: As iSAX is a tree, the next subsection presents basic information about trees
    and binary trees.
  prefs: []
  type: TYPE_NORMAL
- en: Trees and binary trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us begin by explaining what a directed graph is. A **directed graph** is
    a graph where the edges have a direction associated with them. A **directed acyclic
    graph** (**DAG**) is a directed graph with no cycles in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer science, a **tree** is a DAG data structure that satisfies the
    following three principles:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a root node that is the entry point to the tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every vertex, except the root, has one and only one entry point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a path that connects the root to each vertex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already stated, the **root of a tree** is the first node of the tree. Each
    node can be connected to one or more nodes depending on the tree type. If each
    node leads to one and only one node, then the tree becomes a linked list! A leaf
    node is a node without any children. Leaves are also called external nodes, whereas
    a node with at least one child is called an internal node.
  prefs: []
  type: TYPE_NORMAL
- en: A **binary tree** is a tree where underneath each node, there are at most two
    more nodes. *At most* means that it can be connected to one, two, or no other
    nodes. The **depth**, which is also called the **height**, of a tree is defined
    as the longest path from the root node to a leaf, whereas the depth of a node
    is the number of edges from the node to the root node of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you create two binary trees using the same set of elements
    added in a different order, you are going to get two completely different trees.
    The simplest way to do that is by starting from a different root node. So, we
    do not know in advance the final shape of a tree.
  prefs: []
  type: TYPE_NORMAL
- en: A tree has internal nodes and leaf nodes. In iSAX terminology, these are called
    **inner nodes** and **terminal nodes**, respectively. *Inner nodes* have a parent
    and at least one child and *terminal nodes* have a parent node but no children
    of their own.
  prefs: []
  type: TYPE_NORMAL
- en: A binary tree is considered a **balanced tree** when the difference between
    the longest length from the root node to a leaf node and the shortest such length
    is 0 or 1\. An **unbalanced tree** is a tree that is not balanced. Although the
    iSAX index can be characterized by its length, there is no point in finding out
    whether an iSAX index is balanced or not because this is not how indexes work
    and this mainly has to do with the data. However, having balanced trees is a good
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, although iSAX indexes are trees, we cannot apply all the binary tree
    rules to an iSAX index. However, it is good to know all these details to have
    a better understanding of why a particular iSAX index might be faster or slower
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: Balanced binary trees
  prefs: []
  type: TYPE_NORMAL
- en: If a binary tree is balanced, its search, insert, and delete operations take
    about `log(n)` steps, where `n` is the total number of elements in the tree. Additionally,
    the height of a balanced binary tree is approximately `log`2`n`,  which means
    that a balanced tree with 10,000 elements has a height of 14, which is remarkably
    small. The height of a balanced tree with 100,000 elements will be 17 and the
    height of a balanced tree with 1,000,000 elements will be 20! In other words,
    putting a significantly large number of elements into a balanced binary tree does
    not change the search speed of the tree extremely. Put differently, you can reach
    any node in a balanced tree with 1,000,000 nodes in at most 20 steps!
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.1* shows a small iSAX index, which allows us to learn more about
    iSAX indexes without getting lost in the details. We are going to learn more about
    the details of an iSAX index starting in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A small iSAX index](img/Figure_3.1_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A small iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: So, what do we have here and what does it tell us?
  prefs: []
  type: TYPE_NORMAL
- en: As each node of the iSAX index has four SAX words, we know that the segment
    value is 4\. However, we cannot be sure about the cardinality as cardinalities
    begin from the smallest value and are increased when needed, that is, when there
    is a split. However, even on splits, only a single SAX word is promoted to a higher
    cardinality value. The root of this particular iSAX index has three children –
    we assume that the remaining children of the root node are empty. The terminal
    nodes are `[0 0 1 1]`, `[0 1 0 1]`, `[11 1 0 0]`, `[10 11 0 0]`, `[10 10 00 0]`,
    and `[10 10 01 0]`, and the inner nodes are `[1 1 0 0]`, `[10 1 0 0]`, and `[10
    10 0 0]`. We cannot make any assumptions about the threshold value.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B14769_06.xhtml#_idTextAnchor145) is going to present techniques
    for visualizing iSAX indexes, which can be very handy when we are working with
    big iSAX indexes and want to have an overview of the indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section will provide more details about iSAX.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how iSAX works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the way iSAX works, which includes the construction
    phase as well as its usage and parameters. Apart from the required theory, we
    will also present a handy command-line utility that helps you understand how many
    subsequences an iSAX index can have, given its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How iSAX and SAX are related
  prefs: []
  type: TYPE_NORMAL
- en: The way iSAX and the SAX representation are related is simple. The keys on all
    the nodes of an iSAX index, apart from the root node, which has no key, are all
    SAX representations. So, a big part of building and searching an iSAX index is
    based on SAX.
  prefs: []
  type: TYPE_NORMAL
- en: We do not delete or update elements in an iSAX index not because it is not possible
    but because this is not how an iSAX index works.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to discuss the parameters of an iSAX index because the construction
    of an iSAX depends on them.
  prefs: []
  type: TYPE_NORMAL
- en: The cardinality parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `[1 000 0 11]` SAX representation and another one with the `[10001 00 0
    1]` SAX representation. The second difference is that we begin with a cardinality
    value of 2\. This means that all the children of the root node have a cardinality
    value of 2 in all their SAX words.
  prefs: []
  type: TYPE_NORMAL
- en: The segments parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **segments** parameter of an iSAX index works in completely the same way
    as in every SAX representation and defines *the number of SAX words* in each SAX
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: The threshold parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **threshold** parameter is new and defines *the maximum number of subsequences*
    a terminal node can store. We cannot exceed that value. The threshold parameter
    defines when the split of a node is going to take place.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection presents a command line utility that computes the mean values
    of a normalized subsequence based on the number of segments because the mean values
    define the SAX words.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the normalized mean values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This subsection presents a utility that outputs the mean values of all normalized
    subsequences of a time series based on the segment value. It would make no sense
    to count the mean values of all normalized subsequences without splitting them
    based on the segment value because after normalization, the mean value of a subsequence
    is very close to 0, which is one of the points of normalization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `meanValues.py` script in this example. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the number of segments, the utility splits each subsequence into parts
    and calculates the mean value of each part. The last part of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `meanValues.py` is the following (a big part of the output is
    omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can save the output and process it with a utility such as `histogram.py`,
    which was presented in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.2* shows the output of `histogram.py` from two different time series
    with about 500,000 elements each when processed with `meanValues.py` using a sliding
    window size of `1024` and 4 segments. Four segments means that for each subsequence,
    we have to compute four mean values because we split each subsequence into four
    parts. Therefore, a 500,000-element time series produces 2,000,000 mean values
    that go into the histogram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The output of histogram.py from two time series](img/Figure_3.2_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The output of histogram.py from two time series
  prefs: []
  type: TYPE_NORMAL
- en: What does *Figure 3**.2* tell us? The upper plot is of a time series named ECG
    and the lower histogram is of a time series named EEG. The vast majority (around
    2 million values) of the mean values of the ECG time series, *and therefore the
    cardinality values*, falls into the `-0.5` to `0.5` value range. This means that,
    based on the breakpoint values, many SAX words are going to be very similar to
    each other and therefore are going to fall into a small amount of iSAX branches,
    making *the iSAX index of the ECG dataset really unbalanced*. On the other hand,
    for the EEG dataset, the mean values are better distributed in the histogram,
    which means that the SAX words they are going to produce are going to be better
    distributed and the generated iSAX index is going to be more balanced.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about the distribution of values in a histogram,
    you can increase the number of bins and get a more detailed output.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection presents a command line utility that computes the maximum
    number of subsequences an iSAX index with the given parameters can store. Keep
    in mind that this is an **ideal case** where the iSAX index is completely balanced
    and all terminal nodes have the maximum number of subsequences, which is not usually
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: How big can an iSAX index get?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, we are going to calculate the maximum number of subsequences
    an iSAX index can store in the ideal condition. As you already know, the root
    of an iSAX index can have more than two children, whereas all other inner nodes
    have one or two children, which can either be other inner nodes or terminal nodes.
    An inner node can have any combination of inner nodes and terminal nodes as children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us do an exercise together: imagine that we want to find out the maximum
    number of nodes an iSAX with a cardinality of `4` and `2` segments can have. As
    we are interested in nodes, the threshold parameter does not play a key role in
    our discussion, so it is ignored for now. We are going to come back to the threshold
    parameter at the end of our discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to calculate the number of children of the root node. This
    only depends on the number of segments because all the children of the root have
    a cardinality of `2`. Therefore, if we have 2 segments, the maximum number of
    children of the root node is 4, which is 2 2\. These have the following SAX representations:
    `[0, 0]`, `[0, 1]`, `[1, 0]`, and `[1, 1]`. If you are familiar with the binary
    system, these are all values that can be represented with 2 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have 3 segments, the maximum number of children of the root node is 8,
    which is 2 3\. These have the following SAX representations: `[0, 0, 0]`, `[0,
    0, 1]`, `[0, 1, 0]`, `[0, 1, 1]`, `[1, 0, 0]`, `[1, 0, 1]`, `[1, 1, 0]`, and `[1,
    1, 1]`. If you are familiar with the binary system, these are all values that
    can be represented with 3 bits. For each of these children of the root, each SAX
    word can be as big as the cardinality value.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, back to our original problem, which is computing the maximum number of
    nodes an iSAX with a cardinality of 4 and 2 segments can have. As proved, when
    there are 2 segments, the number of children of the root node is 4\. Each segment
    can have as many values as the cardinality, which in this case is 4\. So, with
    2 segments, we can have 4 times 4 possible combinations, which is 16\. This is
    the maximum value of terminal nodes that this iSAX index can store. So, *when
    we have a cardinality of 4 and 2 segments, the maximum number of terminal nodes*
    *is 16*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the total number of terminal nodes, it is time to stop ignoring
    the threshold parameter and see what kind of information it can provide us. The
    threshold parameter can help us compute the maximum number of subsequences this
    iSAX index can hold in an **ideal situation**. The reason we are talking about
    an ideal situation is that most of the time, iSAX indexes are not balanced and
    there is no way of making sure that an iSAX index is going to be balanced. This
    is because this depends on the subsequences and the sliding window size.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, *when we have 64 terminal nodes and a threshold value of 100, the
    maximum number of subsequences that can be stored in an iSAX index in an ideal
    case* *is 6,400*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that information in mind, we are going to develop a small Python script
    to do the calculations for us. The code for `maximumISAX.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `maximumISAX.py` is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, the previous output tells us that an iSAX index with 4 segments, a cardinality
    value of 4, and a threshold value of 100 can hold up to `25600` subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run `maximumISAX.py` with the same number of segments and a different
    cardinality, we are going to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, the previous output tells us that an iSAX index with 4 segments, a cardinality
    value of 16, and a threshold value of 100 can hold up to `6553600` subsequences
    despite the fact that the root node still has 16 children.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection will discuss what happens when there is no space to add
    a given subsequence to an iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when there is no space left for adding more subsequences to an
    iSAX index?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An iSAX index can *overflow*. In practice, this means that an iSAX index might
    not have enough space to add more subsequences. This happens when one or more
    branches of an iSAX index have used the full cardinality for all segments and
    the threshold value has been reached in these terminal nodes. *Figure 3**.3* visualizes
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – iSAX overflow](img/Figure_3.3_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – iSAX overflow
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the nodes with SAX representations of `[10 10 00 00]` and `[10
    10 00 01]` are full and are using their full cardinality. This means that we cannot
    promote the nodes with the `[10 10 00 00]` and `[10 10 00 01]` SAX representations
    anymore unless we increase one or more relevant parameters of the iSAX index.
    So, if we have a subsequence with a SAX representation of either `[10 10 00 00]`
    or `[10 10 00 01]`, we do not know what to do with it, hence the overflow of the
    iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned basic information about iSAX. The next section discusses
    the iSAX construction in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How iSAX is constructed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is going to describe the way an iSAX index is constructed. All
    the presented information is based on the research paper that describes iSAX.
    The logical steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a node that is the root of the iSAX index. The root contains no
    actual data (subsequences) but it contains pointers to all nodes with the specified
    segments value and a cardinality value of `2`, which is a single bit that can
    only have two values, `0` and `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we construct the children of the root node, which at this initial
    point are all terminal nodes without any subsequences in them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now begin adding subsequences to the children of the root based on their
    SAX representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the threshold value of a terminal node is reached, we perform the splits,
    based on the specified **promotion strategy**, and we distribute the subsequences
    to the two newly created terminal nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process goes on until all subsequences have been inserted into the iSAX
    index or there is no place left to add a subsequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will explain how iSAX is searched in order to get a better
    idea of how the construction process is related to the search operation.
  prefs: []
  type: TYPE_NORMAL
- en: How iSAX is searched
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The search process of an iSAX index can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have a subsequence that we want to look for in an iSAX index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we must compute the SAX representation of that subsequence, using the
    same parameters as the iSAX index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we use the SAX representation of the subsequence to find out the
    child of the root that it belongs to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we keep searching that binary tree until we find a node with the same
    SAX representation. Keep in mind that we might need to reduce some of the SAX
    words of the subsequence based on the iSAX nodes. If such a node does not exist,
    then the iSAX index does not contain that subsequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last, we examine the subsequences of that node – provided that such a terminal
    node exists – and look for that specific subsequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally speaking, the process is the same as if we added that subsequence
    to the iSAX index up to the point where we found the node that it belongs to.
    After that, we search the subsequences of that node.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection will discuss the promotion strategy, which has to do with
    which SAX word is going to get promoted when a split needs to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Promotion strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **promotion strategy** refers to the selection of the segment that
    is going to be updated to a higher cardinality when a split is about to happen.
    Splits happen when we are about to add a new subsequence to a terminal node that
    already holds a number of subsequences that is equal to the threshold value. *Only
    that terminal node is going to* *be split*.
  prefs: []
  type: TYPE_NORMAL
- en: The threshold value
  prefs: []
  type: TYPE_NORMAL
- en: The only parameter that is responsible for the splitting of a terminal node
    is the threshold parameter. If the threshold parameter were limitless, then all
    iSAX indexes would have terminal nodes with a cardinality value of 2, which are
    the root children.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two promotion strategies when splitting a node:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[0 1 0 0]` SAX representation. For the first promotion that needs to take
    place, we promote the first SAX word and get `[00 1 0 0]` and `[01 1 0 0]`. In
    the next promotion, we are going to promote the second SAX word, even if this
    promotion takes place on a different SAX representation. So, if we need to promote
    `[1 1 0 1]`, then this is going to give us `[1 10 0 1]` and `[1 11` `0 1]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[00 1 0 0]` is going to give us `[000 1 0 0]` and `[001 1 0 0]`, given that
    we have a cardinality value of at least 8\. When the leftmost SAX word has reached
    its full cardinality, we continue with the next one to its right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no right or wrong promotion strategy – use what you like best.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection presents an essential operation of iSAX, which is node splitting.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This subsection discusses the node-splitting process in more detail. Splitting
    happens in one case only: when a terminal node is about to have more subsequences
    than the ones permitted by the threshold value. In that case, **that terminal
    node becomes an inner node**. Then, two terminal nodes are created based on the
    promotion strategy, which are the children of the newly created inner node. Imagine
    having the iSAX index presented in *Figure 3**.4*, which currently stores 10 subsequences:
    S 0 to S 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to add the S 10 subsequence to that index, but `[10 10 00 0]` is
    full:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Before node splitting](img/Figure_3.4_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Before node splitting
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to add a subsequence with a SAX representation of `[10 10 00 01]`,
    we need to split the `[10 10 00 0]` terminal node, which now becomes an inner
    node with the same SAX representation, and `[10 10 00 00]` and `[10 10 00 01]`
    SAX representations, respectively. So, in that case, we promoted the last SAX
    word.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we iterate all the subsequences that were previously stored in `[10
    10 00 0]` in order to put them in either `[10 10 00 00]` or `[10 10 00 01]` based
    on their promoted SAX representations. We are not going to go into more detail
    about how the subsequences are distributed after the splitting because this is
    explained in detail in the *Manually constructing an iSAX index* section that
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: What if splitting does not solve the issue?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, S 10 is going to go to the `[10 10 00 01]` terminal
    node, *provided that there is enough space* there. In the rare case where the
    new subsequences as well as all previously stored ones go to the same terminal
    node, the splitting process keeps going until the situation is resolved on its
    own or there is an iSAX overflow.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.5* shows the new version of the iSAX index, after the node splitting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – After node splitting](img/Figure_3.5_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – After node splitting
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the stages of the iSAX construction process.
    The following section will show the manual construction of an iSAX index using
    a real example and diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: Manually constructing an iSAX index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to manually create a small iSAX index. For a better
    understanding of the process, we are going to present all the steps and describe
    all the required computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall from earlier on in this chapter, the steps for creating an iSAX
    index can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate a time series into subsequences based on the given sliding window size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each subsequence, calculate its SAX representation, based on the given parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin inserting the subsequences of the time series into the iSAX index. In
    the beginning, all iSAX nodes are terminal nodes, apart from the root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a terminal node is full – the threshold value has been reached – split
    that node by increasing the cardinality of one of its segments and create two
    new terminal nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original terminal node becomes an inner node, which is now the father of
    the new newly created terminal nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split the subsequences of the original terminal node into the two new terminal
    nodes based on their SAX representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does a subsequence go?
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that a subsequence with the `[00 10 10 11]` SAX representation
    *must go* under the `[0 1 1 1]` child of the root. After that, the exact place
    (terminal node) depends on the promotion that is going to take place in the process,
    which can be `[00 10 10 1]`, `[00 1 1 11]`, `[0 1 10 11]`, and so on. However,
    if we use its full SAX representation, it can only go in the `[00 10 10 11]` terminal
    node.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a small time series for the iSAX construction process to
    not take too long to finish. However, the principles remain the same. We are also
    going to need the help of the `ts2PAA.py` utility from the previous chapter to
    get the SAX representation of each subsequence – we do not want to calculate everything
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: As we are dealing with a small time series, we are going to use a segment value
    of `2`, a cardinality value of `8`, which means that we are going to be using
    3 bits for the cardinality, and a threshold value of `15`. The sliding window
    size is `8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the output of `ts2PAA.py` when processing `ts1.gz` is as follows (we are
    ignoring the normalized part of the output at this point, which is omitted for
    brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As `ts1.gz` contains a time series with 50 elements, we are going to get 43
    subsequences from it. Given the previous output, we are going to assign a name
    to each one of the subsequences – the name is based on the starting index of the
    subsequence in the original time series – and associate that name with the SAX
    representation. So, the first subsequence is going to be named S 0, the second
    S 1, and so on. The last one is going to be called S 42.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating the structure presented in *Figure 3**.6*. In this structure,
    we have the root node and its children, which are currently empty. Those children
    are constructed by creating all SAX representations using the specified number
    of segments and a cardinality value of 2, which means that each SAX word has a
    single digit, which can be either `0` or `1`. At this point, all these children
    are terminal nodes. This is just the initial version of the iSAX index, which
    means that at the end of the day, *there might be children without any subsequences*
    (empty). However, this representation helps us programmatically. Also, bear in
    mind that *each child of the root node is the root node of its own* *binary tree*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, all subsequences are associated with the *maximum cardinality*,
    based on the iSAX parameters. However, initially, this *maximum cardinality* is
    reduced to a cardinality value of 2 according to the rule presented in the *Reducing
    the cardinality of a SAX representation* subsection of [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053).
    Only after a split do we need to use a cardinality other than 2 – and this only
    happens for the subsequences that are part of the split. Of course, on big iSAX
    indexes, there are not many terminal nodes that use a *cardinality value of 2
    on all their segments* – it should be clear by now that such terminal nodes are
    directly connected to the root node. Refer to the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The initial version of iSAX with the root and its children](img/Figure_3.6_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The initial version of iSAX with the root and its children
  prefs: []
  type: TYPE_NORMAL
- en: So, first, we put subsequence S 0 into the index. Before doing that, we need
    to reduce its cardinality, which goes from `[011, 100]` to `[0, 1]`. At this point,
    we find its matching cardinality in the children of the root based on the reduced
    cardinality, and we put it there. Now, we put subsequence S 1into the index, which
    has the `[011, 100]` SAX representation, which becomes `[0, 1]`. Now, we put subsequence
    S 2 into the index, which has the `[100, 011]` SAX representation, which becomes
    `[1, 0]`. Then, we put subsequence S 3 into the index, which has the `[011, 100]`
    SAX representation, which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we have an iSAX index that looks like the one presented in *Figure
    3**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Adding four subsequences to the iSAX index](img/Figure_3.7_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Adding four subsequences to the iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 4 into the index, which has the `[011, 100]` SAX representation,
    which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we put subsequence S 5 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we insert subsequence S 6 into the index, which has the `[010, 101]`
    SAX representation, which when reduced becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 7 into the index, which has the `[011, 100]` SAX representation,
    which when reduced is `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 8 into the index, which has the `[011, 100]` SAX representation,
    which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we put subsequence S 9 into the index, which has the `[010, 101]` SAX
    representation, which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put subsequence S 10 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the node with the SAX representation of `[0, 1]` has 9 subsequences
    (*Figure 3**.8*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The iSAX index with 11 subsequences](img/Figure_3.8_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The iSAX index with 11 subsequences
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 11 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[0, 1]`. Then, we put subsequence S 12 into the
    index, which has the `[100, 011]` SAX representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we insert subsequence S 13 into the index, which has the `[101, 010]` SAX
    representation, which when reduced becomes `[1, 0]`. After that, we put subsequence
    S 14 into the index, which has the `[100, 011]` SAX representation, which when
    reduced is `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 15 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[0, 1]`. Then, we put subsequence S 16 into the
    index, which has the `[010, 101]` SAX representation, which becomes `[``0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 17 into the index, which has the `[010, 101]` SAX
    representation, which becomes `[0, 1]`. After that, we put subsequence S 18 into
    the index, which has the `[011, 100]` SAX representation, which becomes `[``0,
    1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 19 into the iSAX index, which has the `[100, 011]`
    SAX representation, which when reduced is `[1, 0]`. Then, we put subsequence S 20
    into the iSAX index, which has the `[101, 010]` SAX representation, which becomes
    `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 21 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we put subsequence S 22 into the iSAX index, which has the `[101, 010]`
    SAX representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 23 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we put subsequence S 24 into the iSAX index, which has the `[011,
    100]` SAX representation, which becomes `[0, 1]`. At this point, the iSAX node
    with the SAX representation of `[0, 1]` is full.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put subsequence S 25 into the iSAX index, which has the `[100, 011]`
    SAX representation, which becomes `[``1, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.9* shows the current version of the iSAX index (the root node is
    omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Adding subsequences to the iSAX index](img/Figure_3.9_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Adding subsequences to the iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we try to insert subsequence S 26 into the iSAX index, which has the `[011,
    100]` SAX representation, which becomes `[0, 1]`. At this point, we must perform
    a split of the `[0, 1]` terminal node. Therefore, `[0, 1]` becomes an inner node
    and two new terminal nodes are created, which become the children of `[0, 1]`:
    `[00, 1]` and `[``01, 1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must calculate the SAX representations of all the existing subsequences
    of `[0, 1]` according to the new cardinality in order to put them into one of
    the two newly created terminal nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new SAX representations of the subsequences of the previous `[0, 1]` terminal
    node are as follows: S 0 --> `[01, 1]`, S 1 --> `[01, 1]`, S 3 --> `[01, 1]`,
    S 4 --> `[01, 1]`, S 6 --> `[01, 1]`, S 7 --> `[01, 1]`, S 8 --> `[01, 1]`, S 9
    --> `[01, 1]`, S 10 --> `[01, 1]`, S 11 --> `[01, 1]`, S 15 --> `[01, 1]`, S 16
    --> `[01, 1]`, S 17 --> `[01, 1]`, S 18 --> `[01, 1]`, S 24 --> `[01, 1]`, and
    S 26 --> `[01, 1]`. If you look closely, you are going to discover that the first
    SAX word in all previous subsequences is the same: `01`. This means that the split
    is not going to work and we are going to need to perform an additional split.
    For no particular reason, we are going to keep promoting the first SAX word. Therefore,
    `[01, 1]` is going to become an inner node and create two new terminal nodes:
    `[010, 1]` and `[011, 1]`. There is no need to promote the other terminal node
    (`[00, 1]`) as there is no issue there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here are the new SAX representations of the previous subsequences: S 0
    --> `[011, 1]`, S 1 --> `[011, 1]`, S 3 --> `[011, 1]`, S 4 --> `[011, 1]`, S 6
    --> `[010, 1]`, S 7 --> `[011, 1]`, S 8 --> `[011, 1]`, S 9 --> `[010, 1]`, S 10
    --> `[011, 1]`, S 11 --> `[011, 1]`, S 15 --> `[011, 1]`, S 16 --> `[010, 1]`,
    S 17 --> `[010, 1]`, S 18 --> `[011, 1]`, S 24 --> `[011, 1]`, and S 26 --> `[``011,
    1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: This split resolves the issue, so the subsequences are put into the appropriate
    terminal node. *Figure 3**.10* shows the latest version of the iSAX index (the
    root node is omitted for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Node splitting of an iSAX index](img/Figure_3.10_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Node splitting of an iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: As stated before, the reason for having to perform a split is that we do not
    want the number of subsequences stored in a terminal node to be greater than the
    threshold value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 27 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[1, 0]`. Next, we insert subsequence S 28 into
    the index, which has the `[110, 001]` SAX representation, which becomes `[``1,
    0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 29 into the index, which has the `[101, 010]` SAX
    representation, which becomes `[1, 0]`. Next, we insert subsequence S 30 into
    the index, which has the `[101, 010]` SAX representation, which becomes `[``1,
    0]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we put subsequence S 31 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[1, 0]`. At this point, we must split the `[1,
    0]` terminal node, which becomes an inner node with two new terminal nodes as
    its children: `[10, 0]` and `[11, 0]`. Therefore, the new SAX representations
    of the subsequences that were stored in `[1, 0]` are as follows: S 2 --> `[10,
    0]`, S 5 --> `[10, 0]`, S 12 --> `[10, 0]`, S 13 --> `[10, 0]`, S 14 --> `[10,
    0]`, S 19 --> `[10, 0]`, S 20 --> `[10, 0]`, S 21 --> `[10, 0]`, S 22 --> `[10,
    0]`, S 23 --> `[10, 0]`, S 25 --> `[10, 0]`, S 27 --> `[10, 0``]`, S 28 --> `[11,
    0]`, S 29 --> `[10, 0]`, S 30 --> `[10, 0]`, and S 31 --> `[``10, 0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.11* shows the latest version of the iSAX index (the root node is
    omitted for brevity). Notice that `[10, 0]` terminal node is full and cannot store
    any more subsequences.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – More node splitting in the iSAX index](img/Figure_3.11_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – More node splitting in the iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: Now, we put subsequence S 32 into the index, which has the `[011, 100]` SAX
    representation, which becomes `[011, 1]` (we reduce the cardinality according
    to our needs). Next, we insert subsequence S 33 into the index, which has the
    `[010, 101]` SAX representation, which when reduced becomes `[``010, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we put subsequence S 34 into the index, which has the `[001, 110]`
    SAX representation, which becomes `[00, 1]`. Next, we insert subsequence S 35
    into the index, which has the `[010, 101]` SAX representation, which becomes `[``010,
    1]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we put subsequence S 36 into the index, which has the `[011, 100]`
    SAX representation, which becomes `[011, 1]`. Next, we insert subsequence S 37
    into the index, which has the `[100, 011]` SAX representation, which when reduced
    becomes `[10, 0]`. The last subsequence causes a split to the `[10, 0]` node,
    which becomes an inner node with two children: `[100, 0]` and `[``101, 0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the new SAX representations of the subsequences that were stored
    in `[10, 0]` are as follows: S 2 --> `[100, 0]`, S 5 --> `[100, 0]`, S 12 -->
    `[100, 0]`, S 13 --> `[101, 0]`, S 14 --> `[100, 0]`, S 19 --> `[100, 0]`, S 20
    --> `[101, 0]`, S 21 --> `[100, 0]`, S 22 --> `[101, 0]`, S 23 --> `[100, 0]`,
    S 25 --> `[100, 0]`, S 27 --> `[100, 0]`, S 29 --> `[101, 0]`, S 30 --> `[101,
    0]`, S 31 --> `[100, 0]`, and S 37 --> `[``100, 0]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.12* shows the updated iSAX index (the root node is omitted for
    brevity).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Updated version of the iSAX index with 38 subsequences](img/Figure_3.12_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Updated version of the iSAX index with 38 subsequences
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put S 38 into the index, which has the `[110, 001]` SAX representation,
    which becomes `[11, 0]`. Then, we insert subsequence S 39 into the index, which
    has the `[100, 011]` SAX representation, which becomes `[``100, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we put subsequence S 40 into the index, which has the `[100, 011]` SAX
    representation, which becomes `[100, 0]`. After that, we insert subsequence S 41,
    which becomes `[``100, 0]`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.13* shows the final version of the iSAX index. If you count the
    subsequences in the terminal nodes, you are going to find that they are 43, which
    is the correct number based on the sliding window size and the time series length.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The final version of the iSAX index](img/Figure_3.13_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The final version of the iSAX index
  prefs: []
  type: TYPE_NORMAL
- en: You should agree by now that creating an iSAX index manually is a tedious process
    and nobody should have to do that. This makes it a perfect candidate to be carried
    out using a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to manually populate an iSAX index, it is time to update
    the `counting.py` utility from [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053).
  prefs: []
  type: TYPE_NORMAL
- en: Updating the counting.py utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the `counting.py` utility from [*Chapter 2*](B14769_02_MA.xhtml#_idTextAnchor053)?
    In this section, we are going to update it and use it for some important tasks.
    We are not going to completely change the existing functionality or throw away
    all the existing code. We are going to build on the existing code of the `counting.py`
    utility, which is a great and productive way to develop new software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated version of the utility can be used for the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Seeing whether a time series can fit into an iSAX index. This computation is
    based on the existing functionality of `counting.py` combined with a test of whether
    the values of all dictionary entries are smaller than the threshold value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing whether a time series can fit into an iSAX index using more segments
    or by increasing the threshold. Again, this computation is based on the existing
    functionality of `counting.py`, which is enhanced with some extra computations
    and testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing whether an iSAX index is relatively balanced or not. This can have a
    great impact on the performance of the index. However, as you already know, indexes
    are not balanced in general. The idea behind this functionality is based on counting
    the number of subsequences that go under each child of the root. Put simply, we
    count the subsequences on nodes that have a cardinality value of 2 on all their
    SAX words because these are the children of the root, and we print the results
    on screen. Although this test is not conclusive, it gives us a good idea of how
    the subsequences are going to be distributed in the iSAX index. Keep in mind that
    if you use a segments value larger than 4, you are going to get a large amount
    of output from the utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The new version of the `counting.py` utility, which is called `countingv2.py`
    and has been refactored to include a function, contains the following code, which
    is presented in four parts. The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `calculate()` function, which computes the number of subsequences per SAX
    representation, is called multiple times and is what might slow down the script.
    Therefore, before seeing `countingv2.py` in action, let me warn you that the utility
    might become slow when processing time series with millions of elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition for an overflow is as follows: *if any node, which is identified
    by its SAX representation, has more subsequences than the threshold value, then
    we have an overflow*. Instead of checking all nodes, we get the maximum value
    of subsequences found in a node (`max(KEYS.values())`) and we compare that to
    the given threshold value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part contains the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous code works as follows.
  prefs: []
  type: TYPE_NORMAL
- en: If we have an overflow, then the code doubles the value of the parameter that
    holds the number of segments while having in mind that the `segments` parameter
    cannot be greater than the sliding window size. This is going to keep happening
    as long as there is an overflow and the segments are not bigger than the sliding
    window size. If we do not have an overflow in the first place, the code tries
    to reduce the value of the `cardinality` parameter by half and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This last part of the code uses **a cardinality value of 2** to find out under
    which child of the root each subsequence is going to be placed. In this case,
    we do not care about overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me now present you with some actual uses of `countingv2.py`. Imagine having
    a time series with 450,000 elements and you want to know whether it can fit into
    an iSAX index with 4 segments, a cardinality of `32`, and a threshold value of
    `1500` when using a sliding window of `1024`. If you want to perform this test,
    please create a time series with synthetic data using the `synthetic_data.py`
    script from [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015). The output of `countingv2.py`
    is going to be as follows (your output is going to vary as we are not using the
    same time series):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the previous output tell us? The first line tells us that we could
    have used a threshold value of `317` with the original SAX parameters and the
    entire time series would have fit into the iSAX index – this means that *the time
    series can fit into the iSAX index*. However, when reducing the cardinality to
    `16`, the iSAX index cannot fit the entire time series using 4 segments and a
    threshold value of `1500`. Finally, the last lines tell us that `76534` subsequences
    belong to the `[1 1 0 0]` SAX representation and `11942` subsequences belong to
    the `[0 0 1 0]` SAX representation. The number of subsequences under the rest
    of the children of the root is between `76534` and `11942`. Generally speaking,
    this is not a bad subsequence distribution for an iSAX index, despite the fact
    that two of the potential children of the root do not appear in the output: `[0
    0 0 0]` and `[1 1` `1 1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us do the same test using the same sliding window length but this
    time using an iSAX index with 2 segments, a cardinality of `128`, and a threshold
    value of `1500`. This time, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the previous output tell us? It tells us that the given iSAX parameters
    are not enough for hosting the provided time series in an iSAX index. However,
    increasing the number of segments to 4 would do the trick. The last two lines
    show a part of the problem: all subsequences go to either `[0 1]` or `[1 0]`,
    which means that both the `[1 1]` and `[0 0]` children of the root node are not
    being used at all, which might be a bad situation. Apart from the data itself,
    this also depends on the sliding window size.'
  prefs: []
  type: TYPE_NORMAL
- en: Normalization and SAX representation
  prefs: []
  type: TYPE_NORMAL
- en: After running `countingv2.py` many times, it came to my attention that it is
    very rare to get SAX representations with all zeros or all ones, especially when
    dealing with a cardinality of 2\. The main reason for this phenomenon is **normalization**.
    Due to normalization, the normalized values of a subsequence cannot fall entirely
    on the left side or right side of 0 unless we are working with a subsequence that
    is all zeros. In that case, the normalized version is the same as the original
    and the mean value is exactly 0\. According to our way of treating zero, which
    means that we must decide whether it going to be included in the left area or
    right area of the 0 breakpoint, we can easily have a SAX representation with all
    zeros or all ones. However, having both in the same iSAX index is extremely rare
    or not possible at all. Keep that in mind when interpreting the results of the
    presented utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, let us do the same check using an iSAX index with 4 segments, a cardinality
    of `64`, and a threshold value of `250`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous output informs us that the selected parameters create an iSAX index
    that can host all the subsequences of the time series, but we cannot reduce the
    cardinality to `32`. Additionally, as we are using the same number of segments,
    the results regarding the subsequence distribution are exactly the same as in
    the first example execution of `countingv2.py`.
  prefs: []
  type: TYPE_NORMAL
- en: When you have such command-line utilities, it is good to experiment with them
    as much as you can in order to get a better insight into iSAX and how the parameters
    affect its shape.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this last section of the chapter, we have improved the `counting.py`
    utility to make it even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the theory behind the iSAX index and how the SAX
    representation is related to the iSAX index. We also learned how to manually create
    an iSAX index given a time series and the required parameters. Additionally, we
    developed some handy command-line utilities that support iSAX indexes. We now
    understand the necessary theory behind iSAX and are ready to apply it.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter uses this chapter as its foundation in order to develop a Python
    package for computing iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Useful links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web page of Eamonn Keogh: [https://www.cs.ucr.edu/~eamonn/](https://www.cs.ucr.edu/~eamonn/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For research issues regarding time series, read the research paper titled *Big
    Sequence Management: A glimpse of the Past, the Present, and the Future* by Themis
    Palpanas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Themis Palpanas''s home page: [https://helios2.mi.parisdescartes.fr/~themisp/](https://helios2.mi.parisdescartes.fr/~themisp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OK! So* was used for some of the diagrams in this chapter: [https://okso.app/](https://okso.app/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to work through the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually create an iSAX index for the `{1, 2, -2, 2, 0, 1, 3, 4}` time series
    with a sliding window of 4 and a SAX representation with 2 segments, a cardinality
    of 4, and a threshold value of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually create an iSAX index for the `{1, 0, 0, 2, 0, 1, -3, 0}` time series
    with a sliding window of 4 and a SAX representation with 2 segments, a cardinality
    of 4, and a threshold value of 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually create an iSAX index for the `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8,
    10}` time series with a sliding window of 6, a SAX representation with 2 segments,
    a cardinality value of 8, and a threshold value of 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually create an iSAX index for the `{1, -1, -1, 2, 0, 1, -3, 0, 4, 6, 8,
    10}` time series with a sliding window of 4 and a SAX representation with 2 segments,
    a cardinality of 4, and a threshold value of 4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually create an iSAX index for the `{0, 0, 0, 0, 1, -1, -1, 2, 0, 1, -3,
    0, 4, 6, 8, 10, 0, 0}` time series with a sliding window of 4 and a SAX representation
    with 2 segments, a cardinality of 4, and a threshold value of 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a sample time series with 2,000,000 elements and check whether it can
    theoretically fit into an iSAX index with 6 segments, a cardinality of 32, and
    a threshold value of 500.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
