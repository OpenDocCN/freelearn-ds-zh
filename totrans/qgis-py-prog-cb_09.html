<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Other Tips and Tricks"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Other Tips and Tricks</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating tiles from a QGIS map</li><li class="listitem">Adding a layer to geojson.io</li><li class="listitem">Rendering map layers based on rules</li><li class="listitem">Creating a layer style file</li><li class="listitem">Using NULL values in PyQGIS</li><li class="listitem">Using generators for layer queries</li><li class="listitem">Using alpha values to show data density</li><li class="listitem">Using the <code class="literal">__geo_interface__</code> protocol</li><li class="listitem">Generating points along a line</li><li class="listitem">Using expression-based labels</li><li class="listitem">Creating dynamic forms in QGIS</li><li class="listitem">Calculating length for all the selected lines</li><li class="listitem">Using a different status bar CRS than the map</li><li class="listitem">Creating HTML labels in QGIS</li><li class="listitem">Using OpenStreetMap's points of interest in QGIS</li><li class="listitem">Visualizing data in 3D with WebGL</li><li class="listitem">Visualizing data on a globe</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Other Tips and Tricks">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec150" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">This chapter provides interesting and valuable QGIS Python tricks that didn't fit into any topics in other chapters. Each recipe has a specific purpose, but in many cases, a recipe may demonstrate multiple concepts that you'll find useful in other programs. All the recipes in this chapter run in the QGIS Python console.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating tiles from a QGIS map"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec151" class="calibre1"/>Creating tiles from a QGIS map</h1></div></div></div><p class="calibre9">This recipe<a id="id696" class="calibre1"/> creates a set of Internet web map tiles from your QGIS map. What's interesting about this recipe is that once the static map tiles are generated, you can <a id="id697" class="calibre1"/>serve them up locally or from any web-accessible directory using the client-side browser's JavaScript without the need of a map server, or you can serve them (for example, distribute them on a portable USB drive).</p></div>

<div class="book" title="Creating tiles from a QGIS map">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec440" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/countries.zip">https://geospatialpython.googlecode.com/svn/countries.zip</a>.</p><p class="calibre9">Unzip the shapefile to a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory. Next, create a directory called <code class="literal">tilecache</code> in your <code class="literal">qgis_data</code> directory. You will also need to install the <span class="strong"><strong class="calibre2">QTiles</strong></span> plugin using the <span class="strong"><strong class="calibre2">QGIS Plugin Manager</strong></span>. This plugin is experimental, so make sure that the <span class="strong"><strong class="calibre2">Show also experimental plugins</strong></span> checkbox is checked in the QGIS Plugin Manager's <span class="strong"><strong class="calibre2">Settings</strong></span> tab.</p></div></div>

<div class="book" title="Creating tiles from a QGIS map">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec441" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the shapefile and randomly color each country. We'll then manipulate the <span class="strong"><strong class="calibre2">QTiles</strong></span> plugin using Python to generate map tiles for <code class="literal">5</code> zoom levels' worth of tiles. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import all the necessary Python libraries, including the QTiles plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
<span class="strong"><strong class="calibre2">import qtiles</strong></span>
<span class="strong"><strong class="calibre2">import random</strong></span>
</pre></div></li><li class="listitem" value="2">Now, we create a color function that can produce random colors. This function accepts a mixed color, which defaults to white, to change the overall tone of the color palette:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def randomColor(mix=(255,255,255)):</strong></span>
<span class="strong"><strong class="calibre2">  red = random.randrange(0,256)</strong></span>
<span class="strong"><strong class="calibre2">  green = random.randrange(0,256)</strong></span>
<span class="strong"><strong class="calibre2">  blue = random.randrange(0,256)</strong></span>
<span class="strong"><strong class="calibre2">  r,g,b = mix</strong></span>
<span class="strong"><strong class="calibre2">  red = (red + r) / 2</strong></span>
<span class="strong"><strong class="calibre2">  green = (green + g) / 2</strong></span>
<span class="strong"><strong class="calibre2">  blue = (blue + b) / 2</strong></span>
<span class="strong"><strong class="calibre2">  return (red, green, blue)</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we'll create a simple callback function for notification of when the tile generation is done. This <a id="id698" class="calibre1"/>function will normally be used to create a message bar or other notification, but we'll keep things simple here:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def done():</strong></span>
<span class="strong"><strong class="calibre2">  print "FINISHED!!"</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we <a id="id699" class="calibre1"/>set the path to the shapefile and the tile's output direction:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">shp = "/qgis_data/shapes/countries.shp"</strong></span>
<span class="strong"><strong class="calibre2">dir = "/qgis_data/tilecache"</strong></span>
</pre></div></li><li class="listitem" value="5">Then, we load the shapefile:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">layer = QgsVectorLayer(shp, "Countries", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="6">After that, we define the field that is used to color the countries:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">field = 'CNTRY_NAME'</strong></span>
</pre></div></li><li class="listitem" value="7">Now, we need to get all the features so that we can loop through them:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">features = layer.getFeatures()</strong></span>
</pre></div></li><li class="listitem" value="8">We'll build our color renderer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">categories = []</strong></span>
<span class="strong"><strong class="calibre2">for feature in features:</strong></span>
<span class="strong"><strong class="calibre2">    country = feature[field]</strong></span>
<span class="strong"><strong class="calibre2">    sym = QgsSymbolV2.defaultSymbol(layer.geometryType())</strong></span>
<span class="strong"><strong class="calibre2">    r,g,b = randomColor()</strong></span>
<span class="strong"><strong class="calibre2">    sym.setColor(QColor(r,g,b,255))</strong></span>
<span class="strong"><strong class="calibre2">    category = QgsRendererCategoryV2(country, sym, country)</strong></span>
<span class="strong"><strong class="calibre2">    categories.append(category)    </strong></span>
</pre></div></li><li class="listitem" value="9">Then, we'll set the layer renderer and add it to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">renderer = QgsCategorizedSymbolRendererV2(field, categories)</strong></span>
<span class="strong"><strong class="calibre2">layer.setRendererV2(renderer)</strong></span>
<span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(layer)</strong></span>
</pre></div></li><li class="listitem" value="10">Now, we'll set all the properties we need for the image tiles, including the map elements and image properties:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">canvas = iface.mapCanvas()</strong></span>
<span class="strong"><strong class="calibre2">layers = canvas.mapSettings().layers()</strong></span>
<span class="strong"><strong class="calibre2">extent = canvas.extent()</strong></span>
<span class="strong"><strong class="calibre2">minZoom = 0</strong></span>
<span class="strong"><strong class="calibre2">maxZoom = 5</strong></span>
<span class="strong"><strong class="calibre2">width = 256</strong></span>
<span class="strong"><strong class="calibre2">height = 256</strong></span>
<span class="strong"><strong class="calibre2">transp = 255</strong></span>
<span class="strong"><strong class="calibre2">quality = 70</strong></span>
<span class="strong"><strong class="calibre2">format = "PNG"</strong></span>
<span class="strong"><strong class="calibre2">outputPath = QFileInfo(dir)</strong></span>
<span class="strong"><strong class="calibre2">rootDir = "countries"</strong></span>
<span class="strong"><strong class="calibre2">antialiasing = False</strong></span>
<span class="strong"><strong class="calibre2">tmsConvention = True</strong></span>
<span class="strong"><strong class="calibre2">mapUrl = False</strong></span>
<span class="strong"><strong class="calibre2">viewer = True</strong></span>
</pre></div></li><li class="listitem" value="11">We are<a id="id700" class="calibre1"/> ready to generate the tiles using the efficient threading system of the <code class="literal">QTiles</code> plugin. We'll create a thread object and pass it all of the tile settings previously mentioned:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tt = qtiles.tilingthread.TilingThread(layers, extent, minZoom, maxZoom, width, height, transp,</strong></span>
<span class="strong"><strong class="calibre2">quality, format, outputPath, rootDir, antialiasing, tmsConvention,</strong></span>
<span class="strong"><strong class="calibre2">mapUrl, viewer)</strong></span>
</pre></div></li><li class="listitem" value="12">Then, we can <a id="id701" class="calibre1"/>connect the finish signal to our simple callback function:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tt.processFinished.connect(done)</strong></span>
</pre></div></li><li class="listitem" value="13">Finally, we start the tiling process:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tt.start()</strong></span>
</pre></div></li><li class="listitem" value="14">Once you receive the completion message, check the output directory and verify that there is an HTML file named <code class="literal">countries.html</code> and a directory named <code class="literal">countries</code>.</li><li class="listitem" value="15">Double-click on the <code class="literal">countries.html</code> page to open it in a browser.</li><li class="listitem" value="16">Once the map loads, click on the plus symbol (<span class="strong"><strong class="calibre2">+</strong></span>) in the upper-left corner twice to zoom the map.</li><li class="listitem" value="17">Next, pan around to see the tiled version of your map load.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating tiles from a QGIS map">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec442" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">You can generate up to 16 zoom levels with this plugin. After eight zoom levels, the tile generation process takes a long time and the tile set becomes quite large on the filesystem, totaling <a id="id702" class="calibre1"/>hundreds of megabytes. One way to avoid creating a lot of files is to use the <a id="id703" class="calibre1"/>
<span class="strong"><strong class="calibre2">mbtiles</strong></span> format, which stores all the data in a single file. However, you need a web application using GDAL to access it.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre9">You can see a working example of the output recipe stored in a<a id="id704" class="calibre1"/> <code class="literal">github.io</code> web directory at <a class="calibre1" href="http://geospatialpython.github.io/qgis/tiles/countries.html">http://geospatialpython.github.io/qgis/tiles/countries.html</a>.</p></div><p class="calibre9">The following<a id="id705" class="calibre1"/> image shows the output in a browser:</p><div class="mediaobject"><img src="../images/00064.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding a layer to geojson.io"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec152" class="calibre1"/>Adding a layer to geojson.io</h1></div></div></div><p class="calibre9">Cloud services <a id="id706" class="calibre1"/>have become common and geospatial maps are no exception. This recipe uses a service named geojson.io, which serves vector layers online, which you can upload from QGIS using Python.</p></div>

<div class="book" title="Adding a layer to geojson.io">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec443" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, you will need to install the <span class="strong"><strong class="calibre2">qgisio</strong></span> plugin using the <span class="strong"><strong class="calibre2">QGIS Plugin Manager</strong></span>.</p><p class="calibre9">You will also need a shapefile in a geodetic coordinate system (WGS84) from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/union.zip">https://geospatialpython.googlecode.com/svn/union.zip</a>.</p><p class="calibre9">Decompress the ZIP file and place it in your <code class="literal">qgis_data</code> directory named <code class="literal">shapes</code>.</p></div></div>

<div class="book" title="Adding a layer to geojson.io">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec444" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will convert our shapefile to GeoJSON using a temporary file. We'll then use Python to call the <span class="strong"><strong class="calibre2">qgisio</strong></span> plugin in order to upload the data to be displayed online. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import all the relevant Python libraries:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
<span class="strong"><strong class="calibre2">from qgis.core import *</strong></span>
<span class="strong"><strong class="calibre2">from tempfile import mkstemp</strong></span>
<span class="strong"><strong class="calibre2">import os</strong></span>
<span class="strong"><strong class="calibre2">from qgisio import geojsonio</strong></span>
</pre></div></li><li class="listitem" value="2">Now, we set up the layer and get the layer's name:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">layer = QgsVectorLayer("/qgis_data/shapes/building.shp", "Building", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">name = layer.name()</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we establish a temporary file using the Python tempfile module for the GeoJSON conversion:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">handle, tmpfile = mkstemp(suffix='.geojson')</strong></span>
<span class="strong"><strong class="calibre2">os.close(handle)</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we'll establish the coordinate reference system needed for the conversion, which must be WGS84 Geographic, to work with the cloud service:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">crs = QgsCoordinateReferenceSystem(4326,</strong></span>
<span class="strong"><strong class="calibre2">QgsCoordinateReferenceSystem.PostgisCrsId)</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we can write out the layer as GeoJSON:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">error = QgsVectorFileWriter.writeAsVectorFormat(layer, tmpfile,</strong></span>
<span class="strong"><strong class="calibre2">    "utf-8", crs, "GeoJSON", onlySelected=False)</strong></span>
</pre></div></li><li class="listitem" value="6">Then, we <a id="id707" class="calibre1"/>can make sure that the conversion didn't have any problems:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">if error != QgsVectorFileWriter.NoError:</strong></span>
<span class="strong"><strong class="calibre2">  print "Unable to write geoJSON!"</strong></span>
</pre></div></li><li class="listitem" value="7">Now, we can read the GeoJSON content:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">with open(str(tmpfile), 'r') as f:</strong></span>
<span class="strong"><strong class="calibre2">  contents = f.read()</strong></span>
</pre></div></li><li class="listitem" value="8">We then need to remove the temporary file:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">os.remove(tmpfile)</strong></span>
</pre></div></li><li class="listitem" value="9">We are ready to upload our GeoJSON to geojson.io using the <code class="literal">qgisio</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">url = geojsonio._create_gist(contents, "Layer exported from QGIS", name + ".geojson")</strong></span>
</pre></div></li><li class="listitem" value="10">We can then use the Qt library to open the map in a browser:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QDesktopServices.openUrl(QUrl(url))</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Adding a layer to geojson.io">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec445" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe actually uses two cloud services. The GeoJSON data is stored on a <a class="calibre1" href="https://github.com">https://github.com</a> service named Gist that allows you to store code snippets such as <code class="literal">JSON</code>. The geojson.io service can read data from Gist.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre9">Note that sometimes it can take several seconds to several minutes for the generated URL to become available online.</p></div><p class="calibre9">This screenshot shows the building layer on an OSM map on geojson.io, with the GeoJSON displayed next to the map:</p><div class="mediaobject"><img src="../images/00065.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Adding a layer to geojson.io">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec446" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">There are additional advanced services that can serve QGIS maps, including <a class="calibre1" href="http://www.QGISCloud.com">www.QGISCloud.com</a> and <a class="calibre1" href="http://www.CartoDB.com">www.CartoDB.com</a>, which can also display raster maps. Both of these services have free options and QGIS plugins. However, they are far more difficult to script from Python if you are trying to automate publishing maps to the Web as part of a workflow.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Rendering map layers based on rules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec153" class="calibre1"/>Rendering map layers based on rules</h1></div></div></div><p class="calibre9">Rendering<a id="id708" class="calibre1"/> rules provide a powerful way to control how and when a layer is displayed relative to other layers or to the properties of the layer itself. Using a rule-based renderer, this recipe demonstrates how to color code a layer based on an attribute.</p></div>

<div class="book" title="Rendering map layers based on rules">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec447" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download a zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip">https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip</a>.</p><p class="calibre9">Unzip it and place it in the directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory.</p><p class="calibre9">In this same directory, download and unzip the following shapefile:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>
</p><p class="calibre9">Finally, add this shapefile to the directory as well:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/jackson.zip">https://geospatialpython.googlecode.com/svn/jackson.zip</a>
</p></div></div>

<div class="book" title="Rendering map layers based on rules">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec448" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will set<a id="id709" class="calibre1"/> up a railroad layer, then we'll set up our rules as Python tuples to color code it based on the frequency of use. Finally, we'll add some other layers to the map for reference. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the QTGui library to work with colors:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll set up our data path to avoid typing it repeatedly. Replace this string with the path to your <code class="literal">qgis_data</code> directory:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">prefix = "/Users/joellawhead/qgis_data/ms/"</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we can load our railroad layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rails = QgsVectorLayer(prefix + "ms_rails_mstm.shp", "Railways", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we can define our rules as a set of tuples. Each rule defines a label and an expression, detailing which attribute values make up that rule, a color name, and the minimum/maximum map scale values at which the described features are visible:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rules = (</strong></span>
<span class="strong"><strong class="calibre2">    ('Heavily Used', '"DEN09CODE" &gt; 3', 'red', (0, 6000000)),</strong></span>
<span class="strong"><strong class="calibre2">    ('Moderately Used', '"DEN09CODE" &lt; 4 AND "DEN09CODE" &gt; 1', 'orange', (0, 1500000)),</strong></span>
<span class="strong"><strong class="calibre2">    ('Lightly Used', '"DEN09CODE" &lt; 2', 'grey', (0, 250000)),</strong></span>
<span class="strong"><strong class="calibre2">)</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we create a rule-based renderer and a base symbol to begin applying our rules:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">sym_rails = QgsSymbolV2.defaultSymbol(rails.geometryType())</strong></span>
<span class="strong"><strong class="calibre2">rend_rails = QgsRuleBasedRendererV2(sym_rails)</strong></span>
</pre></div></li><li class="listitem" value="6">The rules are a hierarchy based on a root rule, so we must access the root first:<div class="informalexample"><pre class="programlisting">root_rule = rend_rails.rootRule()</pre></div></li><li class="listitem" value="7">Now, we will loop through our rules, clone the default rule, and append our custom rule to the tree:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">for label, exp, color, scale in rules:</strong></span>
<span class="strong"><strong class="calibre2">    # create a clone (i.e. a copy) of the default rule</strong></span>
<span class="strong"><strong class="calibre2">  rule = root_rule.children()[0].clone()</strong></span>
<span class="strong"><strong class="calibre2">    # set the label, exp and color</strong></span>
<span class="strong"><strong class="calibre2">  rule.setLabel(label)</strong></span>
<span class="strong"><strong class="calibre2">  rule.setFilterExpression(exp)</strong></span>
<span class="strong"><strong class="calibre2">  rule.symbol().setColor(QColor(color))</strong></span>
<span class="strong"><strong class="calibre2">    # set the scale limits if they have been specified</strong></span>
<span class="strong"><strong class="calibre2">  if scale is not None:</strong></span>
<span class="strong"><strong class="calibre2">    rule.setScaleMinDenom(scale[0])</strong></span>
<span class="strong"><strong class="calibre2">    rule.setScaleMaxDenom(scale[1])</strong></span>
<span class="strong"><strong class="calibre2"># append the rule to the list of rules</strong></span>
<span class="strong"><strong class="calibre2">    root_rule.appendChild(rule)</strong></span>
</pre></div></li><li class="listitem" value="8">We can <a id="id710" class="calibre1"/>now delete the default rule, which isn't part of our rendering scheme:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">root_rule.removeChildAt(0)</strong></span>
</pre></div></li><li class="listitem" value="9">Now, we apply the renderer to our <code class="literal">rails</code> layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rails.setRendererV2(rend_rails)</strong></span>
</pre></div></li><li class="listitem" value="10">We'll establish and style a city layer, which will provide a focal point to zoom into so that we can easily see the scale-based rendering effect:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">jax = QgsVectorLayer(prefix + "jackson.shp", "Jackson", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">jax_style = {}</strong></span>
<span class="strong"><strong class="calibre2">jax_style['color'] = "#ffff00"</strong></span>
<span class="strong"><strong class="calibre2">jax_style['name'] = 'regular_star'</strong></span>
<span class="strong"><strong class="calibre2">jax_style['outline'] = '#000000'</strong></span>
<span class="strong"><strong class="calibre2">jax_style['outline-width'] = '1'</strong></span>
<span class="strong"><strong class="calibre2">jax_style['size'] = '8'</strong></span>
<span class="strong"><strong class="calibre2">sym_jax = QgsSimpleMarkerSymbolLayerV2.create(jax_style)</strong></span>
<span class="strong"><strong class="calibre2">jax.rendererV2().symbols()[0].changeSymbolLayer(0, sym_jax)</strong></span>
</pre></div></li><li class="listitem" value="11">Then, we'll set up and style a border layer around both the datasets:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">ms = QgsVectorLayer(prefix + "mississippi.shp", "Mississippi", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">ms_style = {}yea</strong></span>
<span class="strong"><strong class="calibre2">ms_style['color'] = "#F7F5EB"</strong></span>
<span class="strong"><strong class="calibre2">sym_ms = QgsSimpleFillSymbolLayerV2.create(ms_style)</strong></span>
<span class="strong"><strong class="calibre2">ms.rendererV2().symbols()[0].changeSymbolLayer(0, sym_ms)</strong></span>
</pre></div></li><li class="listitem" value="12">Finally, we'll add everything to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([jax, rails, ms])</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Rendering map layers based on rules">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec449" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Rules are a <a id="id711" class="calibre1"/>hierarchical collection of symbols and expressions. Symbols are collections of symbol layers. This recipe is relatively simple but contains over 50 lines of code. Rendering is one of the most complex features to code in QGIS. However, rules also have their own sets of properties, separate from layers and symbols. Notice that in this recipe, we are able to set labels and filters for the rules, properties that are normally relegated to layers. One way to think of rules is as separate layers. We can do the same thing by loading our railroad layer as a new layer for each rule. Rules are a more compact way to break up the rendering for a single layer.</p><p class="calibre9">This image shows the rendering at a scale where all the rule outputs are visible:</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating a layer style file"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec154" class="calibre1"/>Creating a layer style file</h1></div></div></div><p class="calibre9">Layer styling<a id="id712" class="calibre1"/> is <a id="id713" class="calibre1"/>one of the most complex aspects of the QGIS Python API. Once you've developed the style for a layer, it is often useful to save the styling to the <a id="id714" class="calibre1"/>
<span class="strong"><strong class="calibre2">QGIS Markup Language</strong></span> (<span class="strong"><strong class="calibre2">QML</strong></span>) in the XML format.</p></div>

<div class="book" title="Creating a layer style file">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec450" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped directory named <code class="literal">saveqml</code> and decompress it to your <code class="literal">qgis_data/rasters</code> directory from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/saveqml.zip">https://geospatialpython.googlecode.com/svn/saveqml.zip</a>.</p></div></div>

<div class="book" title="Creating a layer style file">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec451" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create <a id="id715" class="calibre1"/>a color ramp for a DEM and make it semi transparent to overlay a hillshaded tiff of the DEM. We'll save the style we create to a QML file. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll need the following Python Qt libraries:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll load our two raster layers:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">hs = QgsRasterLayer("/qgis_data/saveqml/hillshade.tif", "Hillshade")</strong></span>
<span class="strong"><strong class="calibre2">dem = QgsRasterLayer("/qgis_data/saveqml/dem.asc", "DEM")</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we'll perform a histogram stretch on our DEM for better visualization:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong></span>
<span class="strong"><strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong></span>
<span class="strong"><strong class="calibre2">dem.setContrastEnhancement(algorithm, limits)</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we'll create a visually pleasing color ramp based on the elevation values of the DEM as a renderer and apply it to the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">s = QgsRasterShader() </strong></span>
<span class="strong"><strong class="calibre2">c = QgsColorRampShader() </strong></span>
<span class="strong"><strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong></span>
<span class="strong"><strong class="calibre2">i = [] </strong></span>
<span class="strong"><strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(356.334, QColor(63,159,152,255), '356.334')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(649.292, QColor(96,235,155,255), '649.292')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(942.25, QColor(100,246,174,255), '942.25')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1235.21, QColor(248,251,155,255), '1235.21'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1528.17, QColor(246,190,39,255), '1528.17')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1821.13, QColor(242,155,39,255), '1821.13'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2114.08, QColor(165,84,26,255), '2114.08'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2300, QColor(236,119,83,255), '2300'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2700, QColor(203,203,203,255), '2700'))</strong></span>
<span class="strong"><strong class="calibre2">c.setColorRampItemList(i) </strong></span>
<span class="strong"><strong class="calibre2">s.setRasterShaderFunction(c) </strong></span>
<span class="strong"><strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(dem.dataProvider(), 1, s)</strong></span>
<span class="strong"><strong class="calibre2">ps.setOpacity(0.5) </strong></span>
<span class="strong"><strong class="calibre2">dem.setRenderer(ps)</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we can add the layers to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([dem, hs])</strong></span>
</pre></div></li><li class="listitem" value="6">Finally, with this line, we can save the DEM's styling to a reusable QML file:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">dem.saveNamedStyle("/qgis_data/saveqml/dem.qml")</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating a layer style file">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec452" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The QML format<a id="id716" class="calibre1"/> is easy to read and can be edited by hand. The <code class="literal">saveNamedStyle()</code> method works on vector layers in the exact same way. Instead of styling the preceding code, you can just reference the QML file using the <code class="literal">loadNamedStyle()</code> method:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">dem.loadNamedStyle("/qgis_data/saveqml/dem.qml")</strong></span>
</pre></div><p class="calibre9">If you save the QML file along with a shapefile and use the same filename (with the <code class="literal">.qml</code> extension), then QGIS will load the style automatically when the shapefile is loaded.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using NULL values in PyQGIS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec155" class="calibre1"/>Using NULL values in PyQGIS</h1></div></div></div><p class="calibre9">QGIS<a id="id717" class="calibre1"/> can use NULL values as field values. Python has no concept of NULL values. The closest type it has is the <code class="literal">None</code> type. You must be aware of <a id="id718" class="calibre1"/>this fact when working with Python in QGIS. In this recipe, we'll explore the implications of QGIS's NULL values in Python. The computing of a NULL value involves a pointer that is an uninitialized, undefined, empty, or meaningless value.</p></div>

<div class="book" title="Using NULL values in PyQGIS">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec453" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In your <code class="literal">qgis_data/shapes</code> directory, download the shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NullExample.zip">https://geospatialpython.googlecode.com/svn/NullExample.zip</a>, which contains some NULL field values, and unzip it.</p></div></div>

<div class="book" title="Using NULL values in PyQGIS">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec454" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the shapefile and grab its first feature. Then, we'll access one of its NULL field values. Next, we'll run<a id="id719" class="calibre1"/> through some tests that allow you to see how the NULL values behave in Python. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll load the shapefile and access its first feature:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">lyrPth = "/qgis_data/shapes/NullExample.shp"</strong></span>
<span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(lyrPth, "Null Field Example", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">features = lyr.getFeatures()</strong></span>
<span class="strong"><strong class="calibre2">f = features.next()</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll grab one of the NULL field values:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">value = f["SAMPLE"]</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we'll check the NULL value's type:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check python value type:"</strong></span>
<span class="strong"><strong class="calibre2">print type(value)</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we'll see whether the value is the Python <code class="literal">None</code> type:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check if value is None:"</strong></span>
<span class="strong"><strong class="calibre2">print value is None</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we'll see whether it is equivalent to <code class="literal">None</code>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check if value == None:"</strong></span>
<span class="strong"><strong class="calibre2">print value == None</strong></span>
</pre></div></li><li class="listitem" value="6">Next, we'll see whether the value matches the QGIS NULL type:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check if value == NULL:"</strong></span>
<span class="strong"><strong class="calibre2">print value == NULL</strong></span>
</pre></div></li><li class="listitem" value="7">Then, we'll see whether it is actually NULL:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check if value is NULL:"</strong></span>
<span class="strong"><strong class="calibre2">print value is NULL</strong></span>
</pre></div></li><li class="listitem" value="8">Finally, we'll do a type match to the QGIS NULL:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "Check type(value) is type(NULL):"</strong></span>
<span class="strong"><strong class="calibre2">print type(value) is type(NULL)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using NULL values in PyQGIS">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec455" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">As you can see, the<a id="id720" class="calibre1"/> type of the NULL value is <code class="literal">PyQt4.QtCore.QPyNullVariant</code>. This class is a special type injected into the PyQt framework. It is important to note the cases where the comparison using the <code class="literal">is</code> operator returns a different value than the <code class="literal">==</code> operator comparison. You should be aware of the differences to avoid unexpected results in your code.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using generators for layer queries"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec156" class="calibre1"/>Using generators for layer queries</h1></div></div></div><p class="calibre9">Python generators <a id="id721" class="calibre1"/>provide an efficient way to process large datasets. A QGIS developer named Nathan Woodrow has created a simple Python QGIS query engine that uses generators to easily fetch features from QGIS layers. We'll use this engine in this recipe to query a layer.</p></div>

<div class="book" title="Using generators for layer queries">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec456" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You need to install the query engine using <code class="literal">easy_install</code> or by downloading it and adding it to your QGIS Python installation. To use <code class="literal">easy_install</code>, run the following command from a console, which downloads a clone of the original code that includes a Python setup file:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">easy_install </strong></span>
</pre></div><p class="calibre9">
<a class="calibre1" href="https://github.com/GeospatialPython/qquery/archive/master.zip">https://github.com/GeospatialPython/qquery/archive/master.zip</a>
</p><p class="calibre9">You can also download the ZIP file from <a class="calibre1" href="https://github.com/NathanW2/qquery/archive/master.zip">https://github.com/NathanW2/qquery/archive/master.zip</a> and copy the contents to your working directory or the <code class="literal">site-packages</code> directory of your QGIS Python installation.</p><p class="calibre9">You will also need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following location:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p></div></div>

<div class="book" title="Using generators for layer queries">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec457" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll load a layer containing population data. Then, we'll use the query engine to perform a simple query for an urban area with less than 50,000 people. We'll filter the results to only give us three columns, place name, population level, and land area. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we import the query engine module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from query import query</strong></span>
</pre></div></li><li class="listitem" value="2">Then, we set up the path to our shapefile and load it as a vector layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/MS_UrbanAnC10.shp"</strong></span>
<span class="strong"><strong class="calibre2">layer = QgsVectorLayer(pth, "Urban Areas", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we can run the query, which uses Python's dot notation to perform a <code class="literal">where</code> clause search and then filter using a <code class="literal">select</code> statement. This line will return a generator with the result:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">q = (query(layer).where("POP &gt; 50000").select('NAME10', "POP", "AREALAND", "POPDEN"))</strong></span>
</pre></div></li><li class="listitem" value="4">Finally, we'll use the query's generator to iterate to the first result:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">q().next()</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using generators for layer queries">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec458" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">As you can see, this<a id="id722" class="calibre1"/> module is quite handy. To perform this same query using the default PyQGIS API, it would take nearly four times as much code.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using alpha values to show data density"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec157" class="calibre1"/>Using alpha values to show data density</h1></div></div></div><p class="calibre9">Thematic maps<a id="id723" class="calibre1"/> often use a color ramp based on a single color to show data density. Darker colors show a higher concentration of objects, while lighter colors show lower concentrations. You can use a transparency ramp instead<a id="id724" class="calibre1"/> of a color ramp to show density as well. This technique is useful if you want to overlay the density layer on imagery or other vector layers. In this recipe, we'll be using some bear-sighting data to show the concentration of bears over an area. We'll use alpha values to show the density. We'll use an unusual hexagonal grid to divide the area and a rule-based renderer to build the display.</p></div>

<div class="book" title="Using alpha values to show data density">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec459" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to install the MMQGIS plugin, which is used to build the hexagonal grid using the QGIS <span class="strong"><strong class="calibre2">Plugin Manager</strong></span>.</p><p class="calibre9">You also need to download the bear data from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/bear-data.zip">https://geospatialpython.googlecode.com/svn/bear-data.zip</a>, unzip the shapefile, and put it in the <code class="literal">ms</code> directory of your <code class="literal">qgis_data</code> directory.</p></div></div>

<div class="book" title="Using alpha values to show data density">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec460" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the bear data. Then, we will use the MMQGIS plugin to generate the hexagonal grid. Then, we'll use the Processing Toolbox to clip the hexagon to the bear shapefile, and join the shapefile attribute data to the hexagon grid. Finally, we'll use a rule-based renderer to apply alpha values based on bear-sighting density and add the result to the map. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we import all the libraries we'll need, including the processing engine, the PyQt GUI library for color management, and the MMQGIS plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
<span class="strong"><strong class="calibre2">from mmqgis import mmqgis_library as mmqgis</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll set <a id="id725" class="calibre1"/>up the paths for all of our input and output shapefiles:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">dir = "/qgis_data/ms/"</strong></span>
<span class="strong"><strong class="calibre2">source = dir + "bear-data.shp"</strong></span>
<span class="strong"><strong class="calibre2">grid = dir + "grid.shp"</strong></span>
<span class="strong"><strong class="calibre2">clipped_grid = dir + "clipped_grid.shp"</strong></span>
<span class="strong"><strong class="calibre2">output = dir + "ms-bear-sightings.shp"</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we<a id="id726" class="calibre1"/> can set up the input shapefile as a layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">layer = QgsVectorLayer(source, "bear data", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="4">We'll need the extent of the shapefile to create the grid as well as the width and height, in map units:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">e = layer.extent()</strong></span>
<span class="strong"><strong class="calibre2">llx = e.xMinimum()</strong></span>
<span class="strong"><strong class="calibre2">lly = e.yMinimum()</strong></span>
<span class="strong"><strong class="calibre2">w = e.width()</strong></span>
<span class="strong"><strong class="calibre2">h = e.height()</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we can use the MMQGIS plugin to generate the grid over the entire shapefile's extent. We'll use a grid cell size of one-tenth of a degree (approximately 6 miles):<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">mmqgis.mmqgis_grid(iface, grid, .1, .1, w, h, llx, lly, "Hexagon (polygon)", False)</strong></span>
</pre></div></li><li class="listitem" value="6">Then, we can clip the grid to the shape of our source data using the Processing Toolbox:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("qgis:clip",grid,source,clipped_grid)</strong></span>
</pre></div></li><li class="listitem" value="7">Next, we need to do a spatial join in order to match the source data's attributes based on counties to each grid cell:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("qgis:joinbylocation",source,clipped_grid,0,"sum,mean,min,max,median",0,0,output)</strong></span>
</pre></div></li><li class="listitem" value="8">Now, we can add this output as a layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">bears = QgsVectorLayer(output, "Bear Sightings", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="9">Next, we create our rendering rule set as Python tuples, specifying a label, value expression, color, and alpha level for the symbols between 0 and 1:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">rules = (</strong></span>
<span class="strong"><strong class="calibre2">    ('RARE', '"BEARS" &lt; 5', (227,26,28,255), .2),</strong></span>
<span class="strong"><strong class="calibre2">    ('UNCOMMON', '"BEARS" &gt; 5 AND "BEARS" &lt; 15', (227,26,28,255), .4),</strong></span>
<span class="strong"><strong class="calibre2">    ('OCCASIONAL', '"BEARS" &gt; 14 AND "BEARS" &lt; 50', (227,26,28,255), .6),</strong></span>
<span class="strong"><strong class="calibre2">    ('FREQUENT', '"BEARS" &gt; 50', (227,26,28,255), 1),</strong></span>
<span class="strong"><strong class="calibre2">)</strong></span>
</pre></div></li><li class="listitem" value="10">We then<a id="id727" class="calibre1"/> create the default <a id="id728" class="calibre1"/>symbol rule renderer and add the rules to the renderer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">sym_bears = QgsFillSymbolV2.createSimple({"outline_color":"white","outline_width":".26"}) </strong></span>
<span class="strong"><strong class="calibre2">rend_bears = QgsRuleBasedRendererV2(sym_bears)</strong></span>
<span class="strong"><strong class="calibre2">root_rule = rend_bears.rootRule()</strong></span>
<span class="strong"><strong class="calibre2">for label, exp, color, alpha in rules:</strong></span>
<span class="strong"><strong class="calibre2">    # create a clone (i.e. a copy) of the default rule</strong></span>
<span class="strong"><strong class="calibre2">rule = root_rule.children()[0].clone()</strong></span>
<span class="strong"><strong class="calibre2">    # set the label, exp and color</strong></span>
<span class="strong"><strong class="calibre2">rule.setLabel(label)</strong></span>
<span class="strong"><strong class="calibre2">rule.setFilterExpression(exp)</strong></span>
<span class="strong"><strong class="calibre2">r,g,b,a = color</strong></span>
<span class="strong"><strong class="calibre2">rule.symbol().setColor(QColor(r,g,b,a))</strong></span>
<span class="strong"><strong class="calibre2">    # set the transparency level</strong></span>
<span class="strong"><strong class="calibre2">rule.symbol().setAlpha(alpha)</strong></span>
<span class="strong"><strong class="calibre2">    # append the rule to the list of rules</strong></span>
<span class="strong"><strong class="calibre2">root_rule.appendChild(rule)</strong></span>
</pre></div></li><li class="listitem" value="11">We remove the default rule:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">root_rule.removeChildAt(0)</strong></span>
</pre></div></li><li class="listitem" value="12">We apply the renderer to the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">bears.setRendererV2(rend_bears)</strong></span>
</pre></div></li><li class="listitem" value="13">Finally, we add the finished density layer to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(bears)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using alpha values to show data density">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec461" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The rule-based renderer <a id="id729" class="calibre1"/>forms the core of this recipe. However, the hexagonal grid provides a more interesting way to visualize statistical<a id="id730" class="calibre1"/> data. Like a dot-based density map, hexagons are not entirely spatially accurate or precise but make it very easy to understand the overall trend of the data. The interesting feature of hexagons is their centroid, which is equidistant to each of their neighbors, whereas with a square grid, the diagonal neighbors are further away.</p><p class="calibre9">This image shows how the resulting map will look:</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using the __geo_interface__ protocol"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec158" class="calibre1"/>Using the __geo_interface__ protocol</h1></div></div></div><p class="calibre9">The <code class="literal">__geo_interface__</code> protocol is <a id="id731" class="calibre1"/>a new protocol created by Sean Gillies and is targeted mainly at Python to provide a string representation of geographic data following Python's built-in protocols. The string representation for geographic data is basically GeoJSON.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre9">You can read more about this protocol at <a class="calibre1" href="https://gist.github.com/sgillies/2217756">https://gist.github.com/sgillies/2217756</a>.</p></div><p class="calibre9">Two developers, Nathan Woodrow and Martin Laloux, refined a version of this protocol for QGIS Python data objects. This recipe borrows from their examples to provide a code snippet that you can put at the beginning of your Python scripts to retrofit QGIS features and geometry objects with a <code class="literal">__geo_interface__</code> method.</p></div>

<div class="book" title="Using the __geo_interface__ protocol">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec462" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">This recipe requires no preparation.</p></div></div>

<div class="book" title="Using the __geo_interface__ protocol">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec463" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create<a id="id732" class="calibre1"/> two functions: one for features and one for geometry. We'll then use Python's dynamic capability to patch the QGIS objects with a <code class="literal">__geo_interface__ built-in</code> method. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll need the Python <code class="literal">json</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import json</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll create our function for the features that take a feature as input and return a GeoJSON-like object:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def mapping_feature(feature):</strong></span>
<span class="strong"><strong class="calibre2">geom = feature.geometry()</strong></span>
<span class="strong"><strong class="calibre2">   properties = {}</strong></span>
<span class="strong"><strong class="calibre2">   fields = [field.name() for field in feature.fields()]</strong></span>
<span class="strong"><strong class="calibre2">   properties = dict(zip(fields, feature.attributes()))</strong></span>
<span class="strong"><strong class="calibre2">   return { 'type' : 'Feature',</strong></span>
<span class="strong"><strong class="calibre2">             'properties' : properties,</strong></span>
<span class="strong"><strong class="calibre2">             'geometry' : geom.__geo_interface__}</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we'll create the <code class="literal">geometry</code> function:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def mapping_geometry(geometry):</strong></span>
<span class="strong"><strong class="calibre2">geo = geometry.exportToGeoJSON()</strong></span>
<span class="strong"><strong class="calibre2">return json.loads(geo)</strong></span>
</pre></div></li><li class="listitem" value="4">Finally, we'll patch the QGIS feature and geometry objects with our custom built-in to call our functions when the built-in is accessed:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsFeature.__geo_interface__ = property(lambda self: mapping_feature(self))</strong></span>
<span class="strong"><strong class="calibre2">QgsGeometry.__geo_interface__ = property(lambda self: mapping_geometry(self))</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using the __geo_interface__ protocol">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec464" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe is surprisingly simple but exploits some of Python's most interesting features. First, note that the<a id="id733" class="calibre1"/> feature function actually calls the geometry function as part of its output. Also, note that adding the <code class="literal">__geo_interface__</code> built-in function is as simple as using the double-underscore naming convention and Python's built-in property method to declare lambda functions as internal to the objects. Another interesting Python feature is that the QGIS objects are able to pass themselves to our custom functions using the self keyword.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Generating points along a line"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec159" class="calibre1"/>Generating points along a line</h1></div></div></div><p class="calibre9">You can<a id="id734" class="calibre1"/> generate points within a polygon in a fairly simple way by using the point in polygon method. However, sometimes you may want to generate points along a line. You can randomly place points inside the polygon's extent — which is essentially just a rectangular polygon — or you can place points at random locations along the line at random distances. In this recipe, we'll demonstrate both of these methods.</p></div>

<div class="book" title="Generating points along a line">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec465" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and place it in a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/path.zip">https://geospatialpython.googlecode.com/svn/path.zip</a>
</p></div></div>

<div class="book" title="Generating points along a line">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec466" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">First, we will generate random points along a line using a <code class="literal">grass()</code> function in the Processing Toolbox. Then, we'll generate points within the line's extent using a native QGIS processing function. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the processing module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="2">Then, we'll load the line layer onto the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">line = QgsVectorLayer("/qgis_data/shapes/path.shp", "Line", "ogr")</strong></span>
<span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(line)</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we'll generate points along the line by specifying the path to the shapefile, a maximum distance between the points in map units (meters), the type of feature we want to output (vertices), extent, snap tolerance option, minimum distance between the points, output type, and output name. We won't specify the name and tell QGIS to load the output automatically:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("grass:v.to.points",line,"1000",False, False,True,"435727.015026,458285.819185,5566442.32879,5591754.78979",-1,0.0001,0,None)</strong></span>
</pre></div></li><li class="listitem" value="4">Finally, we'll create some points within the lines' extent and load them as well:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runandload("qgis:randompointsinextent","435727.015026,458285.819185,5566442.32879,5591754.78979",100,100,None)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Generating points along a line">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec467" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The first algorithm<a id="id735" class="calibre1"/> puts the points on the line. The second places them within the vicinity. Both approaches have different use cases.</p></div></div>

<div class="book" title="Generating points along a line">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec468" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">Another option will be to create a buffer around the line at a specified distance and clip the output of the second algorithm so that the points aren't near the corners of the line extent. The <code class="literal">QgsGeometry</code> class also has an interpolate which allows you to create a point on a line at a specified distance from its origin. This is documented at <a class="calibre1" href="http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1">http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using expression-based labels"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec160" class="calibre1"/>Using expression-based labels</h1></div></div></div><p class="calibre9">Expressions<a id="id736" class="calibre1"/> are a kind of mini-programming language or SQL-like language found throughout different QGIS functions to select features. One important use of expressions is to control labels. Maps easily become cluttered if you label every single feature. Expressions make it easy to limit labels to important features. You can filter labels using expressions from within Python, as we will do in this recipe.</p></div>

<div class="book" title="Using expression-based labels">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec469" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p></div></div>

<div class="book" title="Using expression-based labels">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec470" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll use the QGIS PAL labeling engine to filter labels based on a field name. After loading the layer, we'll create our PAL settings and write them to the layer. Finally, we'll add the layer to the map. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll set up the path to our shapefile:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/MS_UrbanAnC10.shp"</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll load our layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(pth, "Urban Areas", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we create a labeling object and read the layer's current labeling settings:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">palyr = QgsPalLayerSettings()</strong></span>
<span class="strong"><strong class="calibre2">palyr.readFromLayer(lyr)</strong></span>
</pre></div></li><li class="listitem" value="4">We create our expression to only label the features whose population field is greater than 50,000:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">palyr.fieldName = 'CASE WHEN "POP" &gt; 50000 THEN NAME10 END'</strong></span>
</pre></div></li><li class="listitem" value="5">Then, we enable these settings:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">palyr.enabled = True</strong></span>
</pre></div></li><li class="listitem" value="6">Finally, we apply the labeling filter to the layer and add it to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">palyr.writeToLayer(lyr)</strong></span>
<span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using expression-based labels">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec471" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">While labels are <a id="id737" class="calibre1"/>a function of the layer, the settings for the labeling engine are controlled by an external object and then applied to the layer.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating dynamic forms in QGIS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec161" class="calibre1"/>Creating dynamic forms in QGIS</h1></div></div></div><p class="calibre9">When you <a id="id738" class="calibre1"/>edit the fields of a layer in QGIS, you have the option of using a spreadsheet-like table view or you can use a database-style form view. Forms are useful because you can change the design of the form and add interactive features that react to user input in order to better control data editing. In this recipe, we'll add some custom validation to a form that checks user input for valid values.</p></div>

<div class="book" title="Creating dynamic forms in QGIS">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec472" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p><p class="calibre9">You'll also need to create a blank Python file called <code class="literal">validate.py</code>, which you'll edit as shown in the following steps. Put the <code class="literal">validate.py</code> file in the <code class="literal">ms</code> directory of your <code class="literal">qgis_data</code> directory with the shapefile.</p></div></div>

<div class="book" title="Creating dynamic forms in QGIS">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec473" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll create the <a id="id739" class="calibre1"/>two functions we need for our validation engine. Then, we'll use the QGIS interface to attach the action to the layer. Make sure that you add the following code to the <code class="literal">validate.py</code> file in the same directory as the shapefile, as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll import the Qt libraries:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll create some global variables for the attribute we'll be validating and the form dialog:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">popFld = None</strong></span>
<span class="strong"><strong class="calibre2">dynamicDialog = None</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we'll begin building the function that changes the behavior of the dialog and create variables for the field we want to validate and the submit button:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def dynamicForm(dialog,lyrId,featId):</strong></span>
<span class="strong"><strong class="calibre2">  globaldynamicDialog</strong></span>
<span class="strong"><strong class="calibre2">  dynamicDialog = dialog</strong></span>
<span class="strong"><strong class="calibre2">  globalpopFld = dialog.findChild(QLineEdit,"POP")</strong></span>
<span class="strong"><strong class="calibre2">  buttonBox=\</strong></span>
<span class="strong"><strong class="calibre2">  dialog.findChild(QDialogButtonBox,"buttonBox")</strong></span>
</pre></div></li><li class="listitem" value="4">We must disconnect the dialog from the action that controls the form acceptance:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">buttonBox.accepted.disconnect(dynamicDialog.accept)</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we reconnect the dialogs, actions to our custom actions:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">buttonBox.accepted.connect(validate)</strong></span>
<span class="strong"><strong class="calibre2">buttonBox.rejected.connect(dynamicDialog.reject)</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we'll create the validation function that will reject the form if the population field has a value less than 1:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def validate():</strong></span>
<span class="strong"><strong class="calibre2">if not float(popFld.text()) &gt; 0:</strong></span>
<span class="strong"><strong class="calibre2">    msg = QMessageBox(f)</strong></span>
<span class="strong"><strong class="calibre2">    msg.setText("Population must be \ </strong></span>
<span class="strong"><strong class="calibre2">    greater than zero.")</strong></span>
<span class="strong"><strong class="calibre2">    msg.exec_()</strong></span>
<span class="strong"><strong class="calibre2">      else:</strong></span>
<span class="strong"><strong class="calibre2">        dynamicDialog.accept()</strong></span>
</pre></div></li><li class="listitem" value="7">Next, open <a id="id740" class="calibre1"/>QGIS and drag and drop the shapefile from your filesystem onto the map canvas.</li><li class="listitem" value="8">Save the project and give it a name in the same directory as the <code class="literal">validate.py</code> file.</li><li class="listitem" value="9">In the QGIS legend, double-click on the layer name.</li><li class="listitem" value="10">Select the <span class="strong"><strong class="calibre2">Fields</strong></span> tab on the left-hand side of the <span class="strong"><strong class="calibre2">Layer Properties</strong></span> dialog.</li><li class="listitem" value="11">In the <span class="strong"><strong class="calibre2">Fields</strong></span> tab at the top-right of the screen, enter the following line into the <span class="strong"><strong class="calibre2">PythonInit Function</strong></span> field:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">validate.dynamicForm</strong></span>
</pre></div></li><li class="listitem" value="12">Click on the <span class="strong"><strong class="calibre2">OK</strong></span> button, in the bottom-right of the <span class="strong"><strong class="calibre2">Layer Properties</strong></span> dialog.</li><li class="listitem" value="13">Now, use the identify tool to select a feature.</li><li class="listitem" value="14">In the <span class="strong"><strong class="calibre2">Feature Properties</strong></span> dialog, click on the form icon in the top-left of the image.</li><li class="listitem" value="15">Once the feature form is open, switch back to the <span class="strong"><strong class="calibre2">QGIS Legend</strong></span>, right-click on the layer name, and select <span class="strong"><strong class="calibre2">Toggle Editing</strong></span>.</li><li class="listitem" value="16">Switch back to the feature form, scroll down to the <span class="strong"><strong class="calibre2">POP</strong></span> field, and change the value to <code class="literal">0</code>.</li><li class="listitem" value="17">Now, click on the <span class="strong"><strong class="calibre2">OK</strong></span> button and verify that you've received the warning dialog, which requires the value to be greater than <code class="literal">0</code>.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating dynamic forms in QGIS">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec474" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">validate.py</code> file must be in your Python path. Putting this file in the same directory as the project makes the functions available. Validation is one of the simplest functions you can implement.</p><p class="calibre9">This screenshot shows the rejection message when the population is set to <code class="literal">0</code>:</p><div class="mediaobject"><img src="../images/00068.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Calculating length for all selected lines"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec162" class="calibre1"/>Calculating length for all selected lines</h1></div></div></div><p class="calibre9">If you need to <a id="id741" class="calibre1"/>calculate the total of a given dataset property, such as length, the easiest thing to do is use Python. In this recipe, we'll total the length of the railways in a dataset.</p></div>

<div class="book" title="Calculating length for all selected lines">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec475" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download a zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip">https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip</a>.</p><p class="calibre9">Unzip it and place it in directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div class="book" title="Calculating length for all selected lines">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec476" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the layer, loop through the features while keeping a running total of line lengths, and finally convert the result to kilometers. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we'll set up the path to our shapefile:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/ms_rails_mstm.shp"</strong></span>
</pre></div></li><li class="listitem" value="2">Then, we'll load the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(pth, "Railroads", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we need a variable to total the line lengths:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">total = 0</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we <a id="id742" class="calibre1"/>loop through the layer, getting the length of each line:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">for f in lyr.getFeatures():</strong></span>
<span class="strong"><strong class="calibre2">  geom = f.geometry()</strong></span>
<span class="strong"><strong class="calibre2">  total += geom.length()</strong></span>
</pre></div></li><li class="listitem" value="5">Finally, we print the total length converted to kilometers and format the string to only show two decimal places:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">print "%0.2f total kilometers of rails." % (total / 1000)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Calculating length for all selected lines">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec477" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This function is simple, but it's not directly available in the QGIS API. You can use a similar technique to total up the area of a set of polygons or perform conditional counting.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using a different status bar CRS than the map"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec163" class="calibre1"/>Using a different status bar CRS than the map</h1></div></div></div><p class="calibre9">Sometimes, you may want to display a different coordinate system for the mouse coordinates in the status bar<a id="id743" class="calibre1"/> than what the source data is. With this recipe, you can set a different coordinate system without changing the data coordinate reference system or the CRS for the map.</p></div>

<div class="book" title="Using a different status bar CRS than the map">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec478" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the zipped shapefile and unzip it to your <code class="literal">qgis_data/ms</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MSCities_Geo.zip">https://geospatialpython.googlecode.com/files/MSCities_Geo.zip</a>
</p></div></div>

<div class="book" title="Using a different status bar CRS than the map">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec479" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our layer, establish a message in the status bar, create a special event listener to transform the map coordinates at the mouse's location to our alternate CRS, and then connect the map signal for the mouse's map coordinates to our listener function. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the Qt core library:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
</pre></div></li><li class="listitem" value="2">Then, we will set up the path to the shapefile and load it as a layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/qgis_data/ms/MSCities_Geo_Pts.shp"</strong></span>
<span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(pth, "Cities", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we add the layer to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong></span>
</pre></div></li><li class="listitem" value="4">Next, we create a default message that will be displayed in the status bar and will be replaced by the alternate coordinates later, when the event listener is active:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">msg = "Alternate CRS ( x: %s, y: %s )"</strong></span>
</pre></div></li><li class="listitem" value="5">Then, we<a id="id744" class="calibre1"/> display our default message in the left-hand side of the status bar as a placeholder:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">iface.mainWindow().statusBar().showMessage(msg % ("--", "--"))</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we create our custom event-listener function to transform the mouse's map location to our custom CRS, which in this case is <a id="id745" class="calibre1"/><span class="strong"><strong class="calibre2">EPSG 3815</strong></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def listen_xyCoordinates(point):</strong></span>
<span class="strong"><strong class="calibre2">    crsSrc = iface.mapCanvas().mapRenderer().destinationCrs()</strong></span>
<span class="strong"><strong class="calibre2">    crsDest = QgsCoordinateReferenceSystem(3815)   </strong></span>
<span class="strong"><strong class="calibre2">    xform = QgsCoordinateTransform(crsSrc, crsDest)</strong></span>
<span class="strong"><strong class="calibre2">    xpoint = xform.transform(point)</strong></span>
<span class="strong"><strong class="calibre2">    iface.mainWindow().statusBar().showMessage(msg % (xpoint.x(), xpoint.y()))</strong></span>
</pre></div></li><li class="listitem" value="7">Next, we connect the map canvas signal that is emitted when the mouse coordinates are updated to our custom event listener:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QObject.connect(iface.mapCanvas(), SIGNAL("xyCoordinates(const QgsPoint &amp;)"), listen_xyCoordinates)</strong></span>
</pre></div></li><li class="listitem" value="8">Finally, verify that when you move the mouse around the map, the status bar is updated with the transformed coordinates.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using a different status bar CRS than the map">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec480" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The coordinate transformation engine in QGIS is very fast. Normally, QGIS tries to transform everything to WGS84 Geographic, but sometimes you need to view coordinates in a different reference system.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating HTML labels in QGIS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec164" class="calibre1"/>Creating HTML labels in QGIS</h1></div></div></div><p class="calibre9">QGIS map tips <a id="id746" class="calibre1"/>allow you to hover the mouse cursor over a feature in order to create a popup that displays information. This information is normally a data field, but you can also display other types of information using a subset of HTML tags. In this recipe, we'll create an HTML map tip that displays a Google Street View image at the feature's location.</p></div>

<div class="book" title="Creating HTML labels in QGIS">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec481" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In your <code class="literal">qgis_data</code> directory, create a directory named <code class="literal">tmp</code>.</p><p class="calibre9">You will also need to download the following zipped shapefile and place it in your <code class="literal">qgis_data/nyc</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip</a>
</p></div></div>

<div class="book" title="Creating HTML labels in QGIS">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec482" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create a function to process the Google data and register it as a QGIS function. Then, we'll load the layer and set its map tip display field. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the Python libraries we'll need:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from qgis.utils import qgsfunction</strong></span>
<span class="strong"><strong class="calibre2">from qgis.core import QGis</strong></span>
<span class="strong"><strong class="calibre2">import urllib    </strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll set a special QGIS Python decorator that registers our function as a QGIS function. The first argument, <code class="literal">0</code>, means that the function won't accept any arguments itself. The second argument, <code class="literal">Python</code>, defines the group in which the function will appear when you use the expression builder:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">@qgsfunction(0, "Python")</strong></span>
</pre></div></li><li class="listitem" value="3">We'll create a function that accepts a feature and uses its geometry to pull down a Google Street View image. We must cache the images locally because the Qt widget that displays the map tips only allows you to use local images:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def googleStreetView(values, feature, parent):</strong></span>
<span class="strong"><strong class="calibre2">x,y = feature.geometry().asPoint()</strong></span>
<span class="strong"><strong class="calibre2">baseurl = "https://maps.googleapis.com/maps/api/streetview?"</strong></span>
<span class="strong"><strong class="calibre2">w = 400</strong></span>
<span class="strong"><strong class="calibre2">h = 400</strong></span>
<span class="strong"><strong class="calibre2">fov = 90</strong></span>
<span class="strong"><strong class="calibre2">heading = 235</strong></span>
<span class="strong"><strong class="calibre2">pitch = 10</strong></span>
<span class="strong"><strong class="calibre2">params = "size=%sx%s&amp;" % (w,h)</strong></span>
<span class="strong"><strong class="calibre2">params += "location=%s,%s&amp;" % (y,x)</strong></span>
<span class="strong"><strong class="calibre2">params += "fov=%s&amp;heading=%s&amp;pitch=%s" % (fov, heading, pitch) </strong></span>
<span class="strong"><strong class="calibre2">url = baseurl + params</strong></span>
<span class="strong"><strong class="calibre2">tmpdir = "/qgis_data/tmp/"</strong></span>
<span class="strong"><strong class="calibre2">img = tmpdir + str(feature.id()) + ".jpg"</strong></span>
<span class="strong"><strong class="calibre2">urllib.urlretrieve(url, img)</strong></span>
<span class="strong"><strong class="calibre2">return img</strong></span>
</pre></div></li><li class="listitem" value="4">Now, we can load the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/qgis_data/nyc/nyc_museums_geo.shp"</strong></span>
<span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(pth, "New York City Museums", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="5">Next, we can set the display field using a special QGIS tag with the name of our function:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">lyr.setDisplayField('&lt;img src="[% $googleStreetView %]"/&gt;')</strong></span>
</pre></div></li><li class="listitem" value="6">Finally, we add it to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong></span>
</pre></div></li><li class="listitem" value="7">Select<a id="id747" class="calibre1"/> the map tips tool and hover over the different points to see the Google Street View images.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Creating HTML labels in QGIS">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec483" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The key to this recipe is the <code class="literal">@qgsfunction</code>
 decorator. When you register the function in this way, it shows up in the menus for Python functions in expressions. The function must also have the parent and value parameters, but we didn't need them in this case.</p><p class="calibre9">The following screenshot shows a Google Street View map tip:</p><div class="mediaobject"><img src="../images/00069.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div class="book" title="Creating HTML labels in QGIS">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec484" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">If you don't need the <a id="id748" class="calibre1"/>function any more, you must unregister it for the function to go away. The <code class="literal">unregister</code> command uses the following convention, referencing the function name with a dollar sign:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsExpression.unregisterFunction("$googleStreetView")</strong></span>
</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using OpenStreetMap's points of interest in QGIS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec165" class="calibre1"/>Using OpenStreetMap's points of interest in QGIS</h1></div></div></div><p class="calibre9">OpenStreetMap has <a id="id749" class="calibre1"/>an API called Overpass that lets you access OSM data dynamically. In this recipe, we'll add some OSM tourism points of interest to a map.</p></div>

<div class="book" title="Using OpenStreetMap's points of interest in QGIS">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec485" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to use the QGIS <span class="strong"><strong class="calibre2">Plugin Manager</strong></span> to install the <span class="strong"><strong class="calibre2">Quick OSM</strong></span> plugin.</p><p class="calibre9">You will also need to download the following shapefile and unzip it to your <code class="literal">qgis_data/ms</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip">https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip</a>
</p></div></div>

<div class="book" title="Using OpenStreetMap's points of interest in QGIS">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec486" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our base layer that defines the area of interest. Then, we'll use the Processing Toolbox <a id="id750" class="calibre1"/>to build a query for OSM, download the data, and add it to the map. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the <code class="literal">processing</code> module:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">import processing</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we need to load the base layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/ms/MSCoast_geo.shp", "MS Coast", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Then, we'll need the layer's extents for the processing algorithms:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">ext = lyr.extent()</strong></span>
<span class="strong"><strong class="calibre2">w =  ext.xMinimum()</strong></span>
<span class="strong"><strong class="calibre2">s =  ext.yMinimum()</strong></span>
<span class="strong"><strong class="calibre2">e =  ext.xMaximum()</strong></span>
<span class="strong"><strong class="calibre2">n =  ext.yMaximum()</strong></span>
</pre></div></li><li class="listitem" value="4">Next, we create the query:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">factory = processing.runalg("quickosm:queryfactory",\</strong></span>
<span class="strong"><strong class="calibre2">"tourism","","%s,%s,%s,%s" % (w,e,s,n),"",25)</strong></span>
<span class="strong"><strong class="calibre2">q = factory["OUTPUT_QUERY"]</strong></span>
</pre></div></li><li class="listitem" value="5">The Quick OSM algorithm has a bug in its output, so we'll create a properly formatted XML tag and perform a string replace:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">bbox_query = """&lt;bbox-query e="%s" n="%s" s="%s" \ w="%s"/&gt;""" % (e,n,s,w)</strong></span>
<span class="strong"><strong class="calibre2">bad_xml = """&lt;bbox-query %s,%s,%s,%s/&gt;""" % (w,e,s,n)</strong></span>
<span class="strong"><strong class="calibre2">good_query = q.replace(bad_xml, bbox_query)</strong></span>
</pre></div></li><li class="listitem" value="6">Now, we download the OSM data using our query:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">results = processing.runalg("quickosm:queryoverpassapiwithastring",\"http://overpass-api.de/api/",good_query,"0,0,0,0","",None)</strong></span>
<span class="strong"><strong class="calibre2">osm = results["OUTPUT_FILE"]</strong></span>
</pre></div></li><li class="listitem" value="7">We define the names of the shapefiles we will create from the OSM output:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">poly = "/qgis_data/ms/tourism_poly.shp"</strong></span>
<span class="strong"><strong class="calibre2">multiline = "/qgis_data/ms/tourism_multil.shp"</strong></span>
<span class="strong"><strong class="calibre2">line = "/qgis_data/ms/tourism_lines.shp"</strong></span>
<span class="strong"><strong class="calibre2">points = "/qgis_data/ms/tourism_points.shp"</strong></span>
</pre></div></li><li class="listitem" value="8">Now, we convert the OSM data to shapefiles:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">processing.runalg("quickosm:ogrdefault",osm,"","","","",poly,multiline,line,points)</strong></span>
</pre></div></li><li class="listitem" value="9">We place the points as a layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">tourism_points = QgsVectorLayer(points, "Points of Interest", "ogr")</strong></span>
</pre></div></li><li class="listitem" value="10">Finally, we can add them to a map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([tourism_points, lyr]</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Using OpenStreetMap's points of interest in QGIS">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec487" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The Quick OSM plugin <a id="id751" class="calibre1"/>manages the Overpass API. What's interesting about this plugin is that it provides processing algorithms in addition to a GUI interface. The processing algorithm that creates the query unfortunately formats the <code class="literal">bbox-query</code> tag improperly, so we need to work around this issue with the string replace. The API returns an OSM XML file that we must convert to shapefiles for use in QGIS.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Visualizing data in 3D with WebGL"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec166" class="calibre1"/>Visualizing data in 3D with WebGL</h1></div></div></div><p class="calibre9">QGIS displays<a id="id752" class="calibre1"/> data in a two-dimensions even if the data is three-dimensional. However, most modern browsers can display 3D data using the <a id="id753" class="calibre1"/>WebGL standard. In this recipe, we'll use the <span class="strong"><strong class="calibre2">Qgis2threejs</strong></span> plugin to display QGIS data in 3D in a browser.</p></div>

<div class="book" title="Visualizing data in 3D with WebGL">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec488" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download some raster elevation data in the zipped directory and place it in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/saveqml.zip">https://geospatialpython.googlecode.com/svn/saveqml.zip</a>
</p><p class="calibre9">You will also need to install the <span class="strong"><strong class="calibre2">Qgis2threejs</strong></span> plugin using the QGIS <span class="strong"><strong class="calibre2">Plugin Manager</strong></span>.</p></div></div>

<div class="book" title="Visualizing data in 3D with WebGL">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec489" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will set up a color ramp for a DEM draped over a hillshade image and use the plugin to create a WebGL page in order to display the data. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we will need to import the relevant libraries and the <span class="strong"><strong class="calibre2">Qgis2threejs</strong></span> plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from PyQt4.QtCore import *</strong></span>
<span class="strong"><strong class="calibre2">from PyQt4.QtGui import *</strong></span>
<span class="strong"><strong class="calibre2">import Qgis2threejs as q23js</strong></span>
</pre></div></li><li class="listitem" value="2">Next, we'll <a id="id754" class="calibre1"/>disable QGIS automatic reprojection to keep the data display in meters:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">iface.mapCanvas().setCrsTransformEnabled(False)</strong></span>
<span class="strong"><strong class="calibre2">iface.mapCanvas().setMapUnits(0)</strong></span>
</pre></div></li><li class="listitem" value="3">Now, we <a id="id755" class="calibre1"/>can load our raster layers:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">demPth = "/Users/joellawhead/qgis_data/saveqml/dem.asc"</strong></span>
<span class="strong"><strong class="calibre2">hillshadePth = "/Users/joellawhead/qgis_data/saveqml/hillshade.tif"</strong></span>
<span class="strong"><strong class="calibre2">dem = QgsRasterLayer(demPth, "DEM")</strong></span>
<span class="strong"><strong class="calibre2">hillshade = QgsRasterLayer(hillshadePth, "Hillshade")</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we can create the color ramp renderer for the DEM layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong></span>
<span class="strong"><strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong></span>
<span class="strong"><strong class="calibre2">dem.setContrastEnhancement(algorithm, limits)</strong></span>
<span class="strong"><strong class="calibre2">s = QgsRasterShader() </strong></span>
<span class="strong"><strong class="calibre2">c = QgsColorRampShader() </strong></span>
<span class="strong"><strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong></span>
<span class="strong"><strong class="calibre2">i = [] </strong></span>
<span class="strong"><strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(356.334, QColor(63,159,152,255), '356.334')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(649.292, QColor(96,235,155,255), '649.292')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(942.25, QColor(100,246,174,255), '942.25')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1235.21, QColor(248,251,155,255), '1235.21'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1528.17, QColor(246,190,39,255), '1528.17')) </strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(1821.13, QColor(242,155,39,255), '1821.13'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2114.08, QColor(165,84,26,255), '2114.08'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2300, QColor(236,119,83,255), '2300'))</strong></span>
<span class="strong"><strong class="calibre2">i.append(qri(2700, QColor(203,203,203,255), '2700'))</strong></span>
<span class="strong"><strong class="calibre2">c.setColorRampItemList(i) </strong></span>
<span class="strong"><strong class="calibre2">s.setRasterShaderFunction(c) </strong></span>
<span class="strong"><strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(dem.dataProvider(), 1,  s)</strong></span>
<span class="strong"><strong class="calibre2">ps.setOpacity(0.5) </strong></span>
<span class="strong"><strong class="calibre2">dem.setRenderer(ps) </strong></span>
</pre></div></li><li class="listitem" value="5">Now, we're ready to add the raster layers to the map:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([dem, hillshade])</strong></span>
</pre></div></li><li class="listitem" value="6">To create the <a id="id756" class="calibre1"/>WebGL interface, we need to take control of the plugin's GUI dialog, but we will keep it hidden:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">d = q23js.qgis2threejsdialog.Qgis2threejsDialog(iface)</strong></span>
</pre></div></li><li class="listitem" value="7">Next, we <a id="id757" class="calibre1"/>must create a dictionary of the properties required by the plugin. The most important is the layer ID of the DEM layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">props = [None,</strong></span>
<span class="strong"><strong class="calibre2"> None,</strong></span>
<span class="strong"><strong class="calibre2"> {u'spinBox_Roughening': 4,</strong></span>
<span class="strong"><strong class="calibre2">u'checkBox_Surroundings': False,</strong></span>
<span class="strong"><strong class="calibre2">u'horizontalSlider_Resolution': 2,</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_Color': u'',</strong></span>
<span class="strong"><strong class="calibre2"> 'visible': False,</strong></span>
<span class="strong"><strong class="calibre2"> 'dem_Height': 163,</strong></span>
<span class="strong"><strong class="calibre2">u'checkBox_Frame': False,</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_ImageFile': u'',</strong></span>
<span class="strong"><strong class="calibre2">u'spinBox_Size': 5,</strong></span>
<span class="strong"><strong class="calibre2">u'spinBox_sidetransp': 0,</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_xmax': u'',</strong></span>
<span class="strong"><strong class="calibre2">u'radioButton_MapCanvas': True,</strong></span>
<span class="strong"><strong class="calibre2"> 'dem_Width': 173,</strong></span>
<span class="strong"><strong class="calibre2">u'radioButton_Simple': True,</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_xmin': u'',</strong></span>
<span class="strong"><strong class="calibre2">u'checkBox_Sides': True,</strong></span>
<span class="strong"><strong class="calibre2">u'comboBox_DEMLayer': dem.id(),</strong></span>
<span class="strong"><strong class="calibre2">u'spinBox_demtransp': 0,</strong></span>
<span class="strong"><strong class="calibre2">u'checkBox_Shading': False,</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_ymax': u'',</strong></span>
<span class="strong"><strong class="calibre2">u'lineEdit_ymin': u'',</strong></span>
<span class="strong"><strong class="calibre2">u'spinBox_Height': {5},{},{},{},{}]}</strong></span>
</pre></div></li><li class="listitem" value="8">Now, we will apply these properties to the plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">d.properties = props</strong></span>
</pre></div></li><li class="listitem" value="9">We must set the output file for the HTML page:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">d.ui.lineEdit_OutputFilename.setText('/qgis_data/3D/3d.html')</strong></span>
</pre></div></li><li class="listitem" value="10">In the <a id="id758" class="calibre1"/>next step, we must override the method that saves the properties, otherwise it overwrites the properties we set:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">def sp(a,b):</strong></span>
<span class="strong"><strong class="calibre2">return</strong></span>
<span class="strong"><strong class="calibre2">d.saveProperties = sp</strong></span>
</pre></div></li><li class="listitem" value="11">Now, we are ready to run the plugin:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">d.run()</strong></span>
</pre></div></li><li class="listitem" value="12">On your filesystem, navigate to the HTML output page and open it in a browser.</li><li class="listitem" value="13">Follow the help instructions to move the 3D elevation display around.</li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Visualizing data in 3D with WebGL">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec490" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This plugin<a id="id759" class="calibre1"/> is absolutely not designed for script-level access. However, Python is so flexible that we can even script the plugin at the GUI level and avoid displaying the GUI, so it is seamless to the user. The only glitch in this approach is that the save method overwrites the properties we set, so we must insert a dummy function that prevents this overwrite.</p><p class="calibre9">The following image shows the WebGL viewer in action:</p><div class="mediaobject"><img src="../images/00070.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Visualizing data on a globe"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec167" class="calibre1"/>Visualizing data on a globe</h1></div></div></div><p class="calibre9">Ever <a id="id760" class="calibre1"/>since the<a id="id761" class="calibre1"/> release of Google Earth, <span class="strong"><em class="calibre10">spinning globe</em></span> applications have become a useful and popular method of geographic exploration. QGIS has an experimental plugin called <a id="id762" class="calibre1"/>
<span class="strong"><strong class="calibre2">QGIS Globe</strong></span>, which is similar to Google Earth; however, it is extremely unstable. In this recipe, we'll display a layer in Google Earth.</p></div>

<div class="book" title="Visualizing data on a globe">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec491" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to use the QGIS <span class="strong"><strong class="calibre2">Plugin Manager</strong></span> to install the <span class="strong"><strong class="calibre2">MMQGIS</strong></span> plugin.</p><p class="calibre9">Make sure you have Google Earth installed from <a class="calibre1" href="https://www.google.com/earth/">https://www.google.com/earth/</a>.</p><p class="calibre9">You will also need the following dataset from a previous recipe. It is a zipped directory called <code class="literal">ufo</code> which you should uncompress to your <code class="literal">qgis_data</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ufo.zip">https://geospatialpython.googlecode.com/svn/ufo.zip</a>
</p></div></div>

<div class="book" title="Visualizing data on a globe">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec492" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our layer and set up the attribute we want to use for the Google Earth KML output as the descriptor. We'll use the MMQIGS plugin to output our layer to KML. Finally, we'll use a cross-platform technique to open the file, which will trigger it to open in Google Earth. To do this, we need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, we will import the relevant Python libraries including the plugin. We will use the Python <code class="literal">webbrowser</code> module to launch Google Earth:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">from mmqgis import mmqgis_library as mmqgis</strong></span>
<span class="strong"><strong class="calibre2">import webbrowser</strong></span>
<span class="strong"><strong class="calibre2">import os</strong></span>
</pre></div></li><li class="listitem" value="2">Now, we'll load the layer:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/continental-us"</strong></span>
<span class="strong"><strong class="calibre2">lyrName = "continental-us"</strong></span>
<span class="strong"><strong class="calibre2">lyr = QgsVectorLayer(pth, lyrName, "ogr")</strong></span>
</pre></div></li><li class="listitem" value="3">Next, we'll set the output path for the KML:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">output = "/Users/joellawhead/qgis_data/us.kml"</strong></span>
</pre></div></li><li class="listitem" value="4">Then, we'll set up the variables needed by the plugin for the KML output which make up the layer identifier:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">nameAttr = "FIPS_CNTRY"</strong></span>
<span class="strong"><strong class="calibre2">desc = ["CNTRY_NAME",]</strong></span>
<span class="strong"><strong class="calibre2">sep = "Paragraph"</strong></span>
</pre></div></li><li class="listitem" value="5">Now, we can use the plugin to create the KML:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">mmqgis.mmqgis_kml_export(iface, lyrName, nameAttr, desc, \</strong></span>
<span class="strong"><strong class="calibre2">sep, output, False)</strong></span>
</pre></div></li><li class="listitem" value="6">Finally, we'll <a id="id763" class="calibre1"/>use the <code class="literal">webbrowser</code> module to open<a id="id764" class="calibre1"/> the KML file, which will default to opening in Google Earth. We need to add the <code class="literal">file</code> protocol at the beginning of our output for the <code class="literal">webbrowser</code> module to work:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong class="calibre2">webbrowser.open("file://" + output)</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Visualizing data on a globe">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec493" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The MMQGIS plugin does a good job with custom scripts and has easy-to-use functions. While our method for automatically launching Google Earth may not work in every possible case, it is almost perfect.</p></div></div></body></html>