<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Other Tips and Tricks</h1></div></div></div><p class="calibre9">In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Creating tiles from a QGIS map</li><li class="listitem">Adding a layer to geojson.io</li><li class="listitem">Rendering map layers based on rules</li><li class="listitem">Creating a layer style file</li><li class="listitem">Using NULL values in PyQGIS</li><li class="listitem">Using generators for layer queries</li><li class="listitem">Using alpha values to show data density</li><li class="listitem">Using the <code class="literal">__geo_interface__</code> protocol</li><li class="listitem">Generating points along a line</li><li class="listitem">Using expression-based labels</li><li class="listitem">Creating dynamic forms in QGIS</li><li class="listitem">Calculating length for all the selected lines</li><li class="listitem">Using a different status bar CRS than the map</li><li class="listitem">Creating HTML labels in QGIS</li><li class="listitem">Using OpenStreetMap's points of interest in QGIS</li><li class="listitem">Visualizing data in 3D with WebGL</li><li class="listitem">Visualizing data on a globe</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec150" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre9">This chapter provides interesting and valuable QGIS Python tricks that didn't fit into any topics in other chapters. Each recipe has a specific purpose, but in many cases, a recipe may demonstrate multiple concepts that you'll find useful in other programs. All the recipes in this chapter run in the QGIS Python console.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec151" class="calibre1"/>Creating tiles from a QGIS map</h1></div></div></div><p class="calibre9">This recipe<a id="id696" class="calibre1"/> creates a set of Internet web map tiles from your QGIS map. What's interesting about this recipe is that once the static map tiles are generated, you can <a id="id697" class="calibre1"/>serve them up locally or from any web-accessible directory using the client-side browser's JavaScript without the need of a map server, or you can serve them (for example, distribute them on a portable USB drive).</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec440" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/countries.zip">https://geospatialpython.googlecode.com/svn/countries.zip</a>.</p><p class="calibre9">Unzip the shapefile to a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory. Next, create a directory called <code class="literal">tilecache</code> in your <code class="literal">qgis_data</code> directory. You will also need to install the <strong class="calibre2">QTiles</strong> plugin using the <strong class="calibre2">QGIS Plugin Manager</strong>. This plugin is experimental, so make sure that the <strong class="calibre2">Show also experimental plugins</strong> checkbox is checked in the QGIS Plugin Manager's <strong class="calibre2">Settings</strong> tab.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec441" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the shapefile and randomly color each country. We'll then manipulate the <strong class="calibre2">QTiles</strong> plugin using Python to generate map tiles for <code class="literal">5</code> zoom levels' worth of tiles. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import all the necessary Python libraries, including the QTiles plugin:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">import qtiles</strong>
<strong class="calibre2">import random</strong>
</pre></div></li><li class="listitem" value="2">Now, we create a color function that can produce random colors. This function accepts a mixed color, which defaults to white, to change the overall tone of the color palette:<div><pre class="programlisting"><strong class="calibre2">def randomColor(mix=(255,255,255)):</strong>
<strong class="calibre2">  red = random.randrange(0,256)</strong>
<strong class="calibre2">  green = random.randrange(0,256)</strong>
<strong class="calibre2">  blue = random.randrange(0,256)</strong>
<strong class="calibre2">  r,g,b = mix</strong>
<strong class="calibre2">  red = (red + r) / 2</strong>
<strong class="calibre2">  green = (green + g) / 2</strong>
<strong class="calibre2">  blue = (blue + b) / 2</strong>
<strong class="calibre2">  return (red, green, blue)</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll create a simple callback function for notification of when the tile generation is done. This <a id="id698" class="calibre1"/>function will normally be used to create a message bar or other notification, but we'll keep things simple here:<div><pre class="programlisting"><strong class="calibre2">def done():</strong>
<strong class="calibre2">  print "FINISHED!!"</strong>
</pre></div></li><li class="listitem" value="4">Now, we <a id="id699" class="calibre1"/>set the path to the shapefile and the tile's output direction:<div><pre class="programlisting"><strong class="calibre2">shp = "/qgis_data/shapes/countries.shp"</strong>
<strong class="calibre2">dir = "/qgis_data/tilecache"</strong>
</pre></div></li><li class="listitem" value="5">Then, we load the shapefile:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer(shp, "Countries", "ogr")</strong>
</pre></div></li><li class="listitem" value="6">After that, we define the field that is used to color the countries:<div><pre class="programlisting"><strong class="calibre2">field = 'CNTRY_NAME'</strong>
</pre></div></li><li class="listitem" value="7">Now, we need to get all the features so that we can loop through them:<div><pre class="programlisting"><strong class="calibre2">features = layer.getFeatures()</strong>
</pre></div></li><li class="listitem" value="8">We'll build our color renderer:<div><pre class="programlisting"><strong class="calibre2">categories = []</strong>
<strong class="calibre2">for feature in features:</strong>
<strong class="calibre2">    country = feature[field]</strong>
<strong class="calibre2">    sym = QgsSymbolV2.defaultSymbol(layer.geometryType())</strong>
<strong class="calibre2">    r,g,b = randomColor()</strong>
<strong class="calibre2">    sym.setColor(QColor(r,g,b,255))</strong>
<strong class="calibre2">    category = QgsRendererCategoryV2(country, sym, country)</strong>
<strong class="calibre2">    categories.append(category)    </strong>
</pre></div></li><li class="listitem" value="9">Then, we'll set the layer renderer and add it to the map:<div><pre class="programlisting"><strong class="calibre2">renderer = QgsCategorizedSymbolRendererV2(field, categories)</strong>
<strong class="calibre2">layer.setRendererV2(renderer)</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(layer)</strong>
</pre></div></li><li class="listitem" value="10">Now, we'll set all the properties we need for the image tiles, including the map elements and image properties:<div><pre class="programlisting"><strong class="calibre2">canvas = iface.mapCanvas()</strong>
<strong class="calibre2">layers = canvas.mapSettings().layers()</strong>
<strong class="calibre2">extent = canvas.extent()</strong>
<strong class="calibre2">minZoom = 0</strong>
<strong class="calibre2">maxZoom = 5</strong>
<strong class="calibre2">width = 256</strong>
<strong class="calibre2">height = 256</strong>
<strong class="calibre2">transp = 255</strong>
<strong class="calibre2">quality = 70</strong>
<strong class="calibre2">format = "PNG"</strong>
<strong class="calibre2">outputPath = QFileInfo(dir)</strong>
<strong class="calibre2">rootDir = "countries"</strong>
<strong class="calibre2">antialiasing = False</strong>
<strong class="calibre2">tmsConvention = True</strong>
<strong class="calibre2">mapUrl = False</strong>
<strong class="calibre2">viewer = True</strong>
</pre></div></li><li class="listitem" value="11">We are<a id="id700" class="calibre1"/> ready to generate the tiles using the efficient threading system of the <code class="literal">QTiles</code> plugin. We'll create a thread object and pass it all of the tile settings previously mentioned:<div><pre class="programlisting"><strong class="calibre2">tt = qtiles.tilingthread.TilingThread(layers, extent, minZoom, maxZoom, width, height, transp,</strong>
<strong class="calibre2">quality, format, outputPath, rootDir, antialiasing, tmsConvention,</strong>
<strong class="calibre2">mapUrl, viewer)</strong>
</pre></div></li><li class="listitem" value="12">Then, we can <a id="id701" class="calibre1"/>connect the finish signal to our simple callback function:<div><pre class="programlisting"><strong class="calibre2">tt.processFinished.connect(done)</strong>
</pre></div></li><li class="listitem" value="13">Finally, we start the tiling process:<div><pre class="programlisting"><strong class="calibre2">tt.start()</strong>
</pre></div></li><li class="listitem" value="14">Once you receive the completion message, check the output directory and verify that there is an HTML file named <code class="literal">countries.html</code> and a directory named <code class="literal">countries</code>.</li><li class="listitem" value="15">Double-click on the <code class="literal">countries.html</code> page to open it in a browser.</li><li class="listitem" value="16">Once the map loads, click on the plus symbol (<strong class="calibre2">+</strong>) in the upper-left corner twice to zoom the map.</li><li class="listitem" value="17">Next, pan around to see the tiled version of your map load.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec442" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">You can generate up to 16 zoom levels with this plugin. After eight zoom levels, the tile generation process takes a long time and the tile set becomes quite large on the filesystem, totaling <a id="id702" class="calibre1"/>hundreds of megabytes. One way to avoid creating a lot of files is to use the <a id="id703" class="calibre1"/>
<strong class="calibre2">mbtiles</strong> format, which stores all the data in a single file. However, you need a web application using GDAL to access it.</p><div><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre9">You can see a working example of the output recipe stored in a<a id="id704" class="calibre1"/> <code class="literal">github.io</code> web directory at <a class="calibre1" href="http://geospatialpython.github.io/qgis/tiles/countries.html">http://geospatialpython.github.io/qgis/tiles/countries.html</a>.</p></div><p class="calibre9">The following<a id="id705" class="calibre1"/> image shows the output in a browser:</p><div><img src="img/00064.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec152" class="calibre1"/>Adding a layer to geojson.io</h1></div></div></div><p class="calibre9">Cloud services <a id="id706" class="calibre1"/>have become common and geospatial maps are no exception. This recipe uses a service named geojson.io, which serves vector layers online, which you can upload from QGIS using Python.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec443" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">For this recipe, you will need to install the <strong class="calibre2">qgisio</strong> plugin using the <strong class="calibre2">QGIS Plugin Manager</strong>.</p><p class="calibre9">You will also need a shapefile in a geodetic coordinate system (WGS84) from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/union.zip">https://geospatialpython.googlecode.com/svn/union.zip</a>.</p><p class="calibre9">Decompress the ZIP file and place it in your <code class="literal">qgis_data</code> directory named <code class="literal">shapes</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec444" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will convert our shapefile to GeoJSON using a temporary file. We'll then use Python to call the <strong class="calibre2">qgisio</strong> plugin in order to upload the data to be displayed online. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import all the relevant Python libraries:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from qgis.core import *</strong>
<strong class="calibre2">from tempfile import mkstemp</strong>
<strong class="calibre2">import os</strong>
<strong class="calibre2">from qgisio import geojsonio</strong>
</pre></div></li><li class="listitem" value="2">Now, we set up the layer and get the layer's name:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer("/qgis_data/shapes/building.shp", "Building", "ogr")</strong>
<strong class="calibre2">name = layer.name()</strong>
</pre></div></li><li class="listitem" value="3">Next, we establish a temporary file using the Python tempfile module for the GeoJSON conversion:<div><pre class="programlisting"><strong class="calibre2">handle, tmpfile = mkstemp(suffix='.geojson')</strong>
<strong class="calibre2">os.close(handle)</strong>
</pre></div></li><li class="listitem" value="4">Now, we'll establish the coordinate reference system needed for the conversion, which must be WGS84 Geographic, to work with the cloud service:<div><pre class="programlisting"><strong class="calibre2">crs = QgsCoordinateReferenceSystem(4326,</strong>
<strong class="calibre2">QgsCoordinateReferenceSystem.PostgisCrsId)</strong>
</pre></div></li><li class="listitem" value="5">Next, we can write out the layer as GeoJSON:<div><pre class="programlisting"><strong class="calibre2">error = QgsVectorFileWriter.writeAsVectorFormat(layer, tmpfile,</strong>
<strong class="calibre2">    "utf-8", crs, "GeoJSON", onlySelected=False)</strong>
</pre></div></li><li class="listitem" value="6">Then, we <a id="id707" class="calibre1"/>can make sure that the conversion didn't have any problems:<div><pre class="programlisting"><strong class="calibre2">if error != QgsVectorFileWriter.NoError:</strong>
<strong class="calibre2">  print "Unable to write geoJSON!"</strong>
</pre></div></li><li class="listitem" value="7">Now, we can read the GeoJSON content:<div><pre class="programlisting"><strong class="calibre2">with open(str(tmpfile), 'r') as f:</strong>
<strong class="calibre2">  contents = f.read()</strong>
</pre></div></li><li class="listitem" value="8">We then need to remove the temporary file:<div><pre class="programlisting"><strong class="calibre2">os.remove(tmpfile)</strong>
</pre></div></li><li class="listitem" value="9">We are ready to upload our GeoJSON to geojson.io using the <code class="literal">qgisio</code> module:<div><pre class="programlisting"><strong class="calibre2">url = geojsonio._create_gist(contents, "Layer exported from QGIS", name + ".geojson")</strong>
</pre></div></li><li class="listitem" value="10">We can then use the Qt library to open the map in a browser:<div><pre class="programlisting"><strong class="calibre2">QDesktopServices.openUrl(QUrl(url))</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec445" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe actually uses two cloud services. The GeoJSON data is stored on a <a class="calibre1" href="https://github.com">https://github.com</a> service named Gist that allows you to store code snippets such as <code class="literal">JSON</code>. The geojson.io service can read data from Gist.</p><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre9">Note that sometimes it can take several seconds to several minutes for the generated URL to become available online.</p></div><p class="calibre9">This screenshot shows the building layer on an OSM map on geojson.io, with the GeoJSON displayed next to the map:</p><div><img src="img/00065.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec446" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">There are additional advanced services that can serve QGIS maps, including <a class="calibre1" href="http://www.QGISCloud.com">www.QGISCloud.com</a> and <a class="calibre1" href="http://www.CartoDB.com">www.CartoDB.com</a>, which can also display raster maps. Both of these services have free options and QGIS plugins. However, they are far more difficult to script from Python if you are trying to automate publishing maps to the Web as part of a workflow.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec153" class="calibre1"/>Rendering map layers based on rules</h1></div></div></div><p class="calibre9">Rendering<a id="id708" class="calibre1"/> rules provide a powerful way to control how and when a layer is displayed relative to other layers or to the properties of the layer itself. Using a rule-based renderer, this recipe demonstrates how to color code a layer based on an attribute.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec447" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download a zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip">https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip</a>.</p><p class="calibre9">Unzip it and place it in the directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory.</p><p class="calibre9">In this same directory, download and unzip the following shapefile:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/Mississippi.zip">https://geospatialpython.googlecode.com/files/Mississippi.zip</a>
</p><p class="calibre9">Finally, add this shapefile to the directory as well:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/jackson.zip">https://geospatialpython.googlecode.com/svn/jackson.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec448" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will set<a id="id709" class="calibre1"/> up a railroad layer, then we'll set up our rules as Python tuples to color code it based on the frequency of use. Finally, we'll add some other layers to the map for reference. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the QTGui library to work with colors:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtGui import *</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll set up our data path to avoid typing it repeatedly. Replace this string with the path to your <code class="literal">qgis_data</code> directory:<div><pre class="programlisting"><strong class="calibre2">prefix = "/Users/joellawhead/qgis_data/ms/"</strong>
</pre></div></li><li class="listitem" value="3">Now, we can load our railroad layer:<div><pre class="programlisting"><strong class="calibre2">rails = QgsVectorLayer(prefix + "ms_rails_mstm.shp", "Railways", "ogr")</strong>
</pre></div></li><li class="listitem" value="4">Then, we can define our rules as a set of tuples. Each rule defines a label and an expression, detailing which attribute values make up that rule, a color name, and the minimum/maximum map scale values at which the described features are visible:<div><pre class="programlisting"><strong class="calibre2">rules = (</strong>
<strong class="calibre2">    ('Heavily Used', '"DEN09CODE" &gt; 3', 'red', (0, 6000000)),</strong>
<strong class="calibre2">    ('Moderately Used', '"DEN09CODE" &lt; 4 AND "DEN09CODE" &gt; 1', 'orange', (0, 1500000)),</strong>
<strong class="calibre2">    ('Lightly Used', '"DEN09CODE" &lt; 2', 'grey', (0, 250000)),</strong>
<strong class="calibre2">)</strong>
</pre></div></li><li class="listitem" value="5">Next, we create a rule-based renderer and a base symbol to begin applying our rules:<div><pre class="programlisting"><strong class="calibre2">sym_rails = QgsSymbolV2.defaultSymbol(rails.geometryType())</strong>
<strong class="calibre2">rend_rails = QgsRuleBasedRendererV2(sym_rails)</strong>
</pre></div></li><li class="listitem" value="6">The rules are a hierarchy based on a root rule, so we must access the root first:<div><pre class="programlisting">root_rule = rend_rails.rootRule()</pre></div></li><li class="listitem" value="7">Now, we will loop through our rules, clone the default rule, and append our custom rule to the tree:<div><pre class="programlisting"><strong class="calibre2">for label, exp, color, scale in rules:</strong>
<strong class="calibre2">    # create a clone (i.e. a copy) of the default rule</strong>
<strong class="calibre2">  rule = root_rule.children()[0].clone()</strong>
<strong class="calibre2">    # set the label, exp and color</strong>
<strong class="calibre2">  rule.setLabel(label)</strong>
<strong class="calibre2">  rule.setFilterExpression(exp)</strong>
<strong class="calibre2">  rule.symbol().setColor(QColor(color))</strong>
<strong class="calibre2">    # set the scale limits if they have been specified</strong>
<strong class="calibre2">  if scale is not None:</strong>
<strong class="calibre2">    rule.setScaleMinDenom(scale[0])</strong>
<strong class="calibre2">    rule.setScaleMaxDenom(scale[1])</strong>
<strong class="calibre2"># append the rule to the list of rules</strong>
<strong class="calibre2">    root_rule.appendChild(rule)</strong>
</pre></div></li><li class="listitem" value="8">We can <a id="id710" class="calibre1"/>now delete the default rule, which isn't part of our rendering scheme:<div><pre class="programlisting"><strong class="calibre2">root_rule.removeChildAt(0)</strong>
</pre></div></li><li class="listitem" value="9">Now, we apply the renderer to our <code class="literal">rails</code> layer:<div><pre class="programlisting"><strong class="calibre2">rails.setRendererV2(rend_rails)</strong>
</pre></div></li><li class="listitem" value="10">We'll establish and style a city layer, which will provide a focal point to zoom into so that we can easily see the scale-based rendering effect:<div><pre class="programlisting"><strong class="calibre2">jax = QgsVectorLayer(prefix + "jackson.shp", "Jackson", "ogr")</strong>
<strong class="calibre2">jax_style = {}</strong>
<strong class="calibre2">jax_style['color'] = "#ffff00"</strong>
<strong class="calibre2">jax_style['name'] = 'regular_star'</strong>
<strong class="calibre2">jax_style['outline'] = '#000000'</strong>
<strong class="calibre2">jax_style['outline-width'] = '1'</strong>
<strong class="calibre2">jax_style['size'] = '8'</strong>
<strong class="calibre2">sym_jax = QgsSimpleMarkerSymbolLayerV2.create(jax_style)</strong>
<strong class="calibre2">jax.rendererV2().symbols()[0].changeSymbolLayer(0, sym_jax)</strong>
</pre></div></li><li class="listitem" value="11">Then, we'll set up and style a border layer around both the datasets:<div><pre class="programlisting"><strong class="calibre2">ms = QgsVectorLayer(prefix + "mississippi.shp", "Mississippi", "ogr")</strong>
<strong class="calibre2">ms_style = {}yea</strong>
<strong class="calibre2">ms_style['color'] = "#F7F5EB"</strong>
<strong class="calibre2">sym_ms = QgsSimpleFillSymbolLayerV2.create(ms_style)</strong>
<strong class="calibre2">ms.rendererV2().symbols()[0].changeSymbolLayer(0, sym_ms)</strong>
</pre></div></li><li class="listitem" value="12">Finally, we'll add everything to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([jax, rails, ms])</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec449" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">Rules are a <a id="id711" class="calibre1"/>hierarchical collection of symbols and expressions. Symbols are collections of symbol layers. This recipe is relatively simple but contains over 50 lines of code. Rendering is one of the most complex features to code in QGIS. However, rules also have their own sets of properties, separate from layers and symbols. Notice that in this recipe, we are able to set labels and filters for the rules, properties that are normally relegated to layers. One way to think of rules is as separate layers. We can do the same thing by loading our railroad layer as a new layer for each rule. Rules are a more compact way to break up the rendering for a single layer.</p><p class="calibre9">This image shows the rendering at a scale where all the rule outputs are visible:</p><div><img src="img/00066.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec154" class="calibre1"/>Creating a layer style file</h1></div></div></div><p class="calibre9">Layer styling<a id="id712" class="calibre1"/> is <a id="id713" class="calibre1"/>one of the most complex aspects of the QGIS Python API. Once you've developed the style for a layer, it is often useful to save the styling to the <a id="id714" class="calibre1"/>
<strong class="calibre2">QGIS Markup Language</strong> (<strong class="calibre2">QML</strong>) in the XML format.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec450" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped directory named <code class="literal">saveqml</code> and decompress it to your <code class="literal">qgis_data/rasters</code> directory from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/saveqml.zip">https://geospatialpython.googlecode.com/svn/saveqml.zip</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec451" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create <a id="id715" class="calibre1"/>a color ramp for a DEM and make it semi transparent to overlay a hillshaded tiff of the DEM. We'll save the style we create to a QML file. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll need the following Python Qt libraries:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load our two raster layers:<div><pre class="programlisting"><strong class="calibre2">hs = QgsRasterLayer("/qgis_data/saveqml/hillshade.tif", "Hillshade")</strong>
<strong class="calibre2">dem = QgsRasterLayer("/qgis_data/saveqml/dem.asc", "DEM")</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll perform a histogram stretch on our DEM for better visualization:<div><pre class="programlisting"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong>
<strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong>
<strong class="calibre2">dem.setContrastEnhancement(algorithm, limits)</strong>
</pre></div></li><li class="listitem" value="4">Now, we'll create a visually pleasing color ramp based on the elevation values of the DEM as a renderer and apply it to the layer:<div><pre class="programlisting"><strong class="calibre2">s = QgsRasterShader() </strong>
<strong class="calibre2">c = QgsColorRampShader() </strong>
<strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong>
<strong class="calibre2">i = [] </strong>
<strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong>
<strong class="calibre2">i.append(qri(356.334, QColor(63,159,152,255), '356.334')) </strong>
<strong class="calibre2">i.append(qri(649.292, QColor(96,235,155,255), '649.292')) </strong>
<strong class="calibre2">i.append(qri(942.25, QColor(100,246,174,255), '942.25')) </strong>
<strong class="calibre2">i.append(qri(1235.21, QColor(248,251,155,255), '1235.21'))</strong>
<strong class="calibre2">i.append(qri(1528.17, QColor(246,190,39,255), '1528.17')) </strong>
<strong class="calibre2">i.append(qri(1821.13, QColor(242,155,39,255), '1821.13'))</strong>
<strong class="calibre2">i.append(qri(2114.08, QColor(165,84,26,255), '2114.08'))</strong>
<strong class="calibre2">i.append(qri(2300, QColor(236,119,83,255), '2300'))</strong>
<strong class="calibre2">i.append(qri(2700, QColor(203,203,203,255), '2700'))</strong>
<strong class="calibre2">c.setColorRampItemList(i) </strong>
<strong class="calibre2">s.setRasterShaderFunction(c) </strong>
<strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(dem.dataProvider(), 1, s)</strong>
<strong class="calibre2">ps.setOpacity(0.5) </strong>
<strong class="calibre2">dem.setRenderer(ps)</strong>
</pre></div></li><li class="listitem" value="5">Now, we can add the layers to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([dem, hs])</strong>
</pre></div></li><li class="listitem" value="6">Finally, with this line, we can save the DEM's styling to a reusable QML file:<div><pre class="programlisting"><strong class="calibre2">dem.saveNamedStyle("/qgis_data/saveqml/dem.qml")</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec452" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The QML format<a id="id716" class="calibre1"/> is easy to read and can be edited by hand. The <code class="literal">saveNamedStyle()</code> method works on vector layers in the exact same way. Instead of styling the preceding code, you can just reference the QML file using the <code class="literal">loadNamedStyle()</code> method:</p><div><pre class="programlisting"><strong class="calibre2">dem.loadNamedStyle("/qgis_data/saveqml/dem.qml")</strong>
</pre></div><p class="calibre9">If you save the QML file along with a shapefile and use the same filename (with the <code class="literal">.qml</code> extension), then QGIS will load the style automatically when the shapefile is loaded.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec155" class="calibre1"/>Using NULL values in PyQGIS</h1></div></div></div><p class="calibre9">QGIS<a id="id717" class="calibre1"/> can use NULL values as field values. Python has no concept of NULL values. The closest type it has is the <code class="literal">None</code> type. You must be aware of <a id="id718" class="calibre1"/>this fact when working with Python in QGIS. In this recipe, we'll explore the implications of QGIS's NULL values in Python. The computing of a NULL value involves a pointer that is an uninitialized, undefined, empty, or meaningless value.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec453" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In your <code class="literal">qgis_data/shapes</code> directory, download the shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/NullExample.zip">https://geospatialpython.googlecode.com/svn/NullExample.zip</a>, which contains some NULL field values, and unzip it.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec454" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the shapefile and grab its first feature. Then, we'll access one of its NULL field values. Next, we'll run<a id="id719" class="calibre1"/> through some tests that allow you to see how the NULL values behave in Python. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll load the shapefile and access its first feature:<div><pre class="programlisting"><strong class="calibre2">lyrPth = "/qgis_data/shapes/NullExample.shp"</strong>
<strong class="calibre2">lyr = QgsVectorLayer(lyrPth, "Null Field Example", "ogr")</strong>
<strong class="calibre2">features = lyr.getFeatures()</strong>
<strong class="calibre2">f = features.next()</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll grab one of the NULL field values:<div><pre class="programlisting"><strong class="calibre2">value = f["SAMPLE"]</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll check the NULL value's type:<div><pre class="programlisting"><strong class="calibre2">print "Check python value type:"</strong>
<strong class="calibre2">print type(value)</strong>
</pre></div></li><li class="listitem" value="4">Then, we'll see whether the value is the Python <code class="literal">None</code> type:<div><pre class="programlisting"><strong class="calibre2">print "Check if value is None:"</strong>
<strong class="calibre2">print value is None</strong>
</pre></div></li><li class="listitem" value="5">Now, we'll see whether it is equivalent to <code class="literal">None</code>:<div><pre class="programlisting"><strong class="calibre2">print "Check if value == None:"</strong>
<strong class="calibre2">print value == None</strong>
</pre></div></li><li class="listitem" value="6">Next, we'll see whether the value matches the QGIS NULL type:<div><pre class="programlisting"><strong class="calibre2">print "Check if value == NULL:"</strong>
<strong class="calibre2">print value == NULL</strong>
</pre></div></li><li class="listitem" value="7">Then, we'll see whether it is actually NULL:<div><pre class="programlisting"><strong class="calibre2">print "Check if value is NULL:"</strong>
<strong class="calibre2">print value is NULL</strong>
</pre></div></li><li class="listitem" value="8">Finally, we'll do a type match to the QGIS NULL:<div><pre class="programlisting"><strong class="calibre2">print "Check type(value) is type(NULL):"</strong>
<strong class="calibre2">print type(value) is type(NULL)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec455" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">As you can see, the<a id="id720" class="calibre1"/> type of the NULL value is <code class="literal">PyQt4.QtCore.QPyNullVariant</code>. This class is a special type injected into the PyQt framework. It is important to note the cases where the comparison using the <code class="literal">is</code> operator returns a different value than the <code class="literal">==</code> operator comparison. You should be aware of the differences to avoid unexpected results in your code.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec156" class="calibre1"/>Using generators for layer queries</h1></div></div></div><p class="calibre9">Python generators <a id="id721" class="calibre1"/>provide an efficient way to process large datasets. A QGIS developer named Nathan Woodrow has created a simple Python QGIS query engine that uses generators to easily fetch features from QGIS layers. We'll use this engine in this recipe to query a layer.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec456" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You need to install the query engine using <code class="literal">easy_install</code> or by downloading it and adding it to your QGIS Python installation. To use <code class="literal">easy_install</code>, run the following command from a console, which downloads a clone of the original code that includes a Python setup file:</p><div><pre class="programlisting"><strong class="calibre2">easy_install </strong>
</pre></div><p class="calibre9">
<a class="calibre1" href="https://github.com/GeospatialPython/qquery/archive/master.zip">https://github.com/GeospatialPython/qquery/archive/master.zip</a>
</p><p class="calibre9">You can also download the ZIP file from <a class="calibre1" href="https://github.com/NathanW2/qquery/archive/master.zip">https://github.com/NathanW2/qquery/archive/master.zip</a> and copy the contents to your working directory or the <code class="literal">site-packages</code> directory of your QGIS Python installation.</p><p class="calibre9">You will also need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following location:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec457" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll load a layer containing population data. Then, we'll use the query engine to perform a simple query for an urban area with less than 50,000 people. We'll filter the results to only give us three columns, place name, population level, and land area. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import the query engine module:<div><pre class="programlisting"><strong class="calibre2">from query import query</strong>
</pre></div></li><li class="listitem" value="2">Then, we set up the path to our shapefile and load it as a vector layer:<div><pre class="programlisting"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/MS_UrbanAnC10.shp"</strong>
<strong class="calibre2">layer = QgsVectorLayer(pth, "Urban Areas", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we can run the query, which uses Python's dot notation to perform a <code class="literal">where</code> clause search and then filter using a <code class="literal">select</code> statement. This line will return a generator with the result:<div><pre class="programlisting"><strong class="calibre2">q = (query(layer).where("POP &gt; 50000").select('NAME10', "POP", "AREALAND", "POPDEN"))</strong>
</pre></div></li><li class="listitem" value="4">Finally, we'll use the query's generator to iterate to the first result:<div><pre class="programlisting"><strong class="calibre2">q().next()</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec458" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">As you can see, this<a id="id722" class="calibre1"/> module is quite handy. To perform this same query using the default PyQGIS API, it would take nearly four times as much code.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec157" class="calibre1"/>Using alpha values to show data density</h1></div></div></div><p class="calibre9">Thematic maps<a id="id723" class="calibre1"/> often use a color ramp based on a single color to show data density. Darker colors show a higher concentration of objects, while lighter colors show lower concentrations. You can use a transparency ramp instead<a id="id724" class="calibre1"/> of a color ramp to show density as well. This technique is useful if you want to overlay the density layer on imagery or other vector layers. In this recipe, we'll be using some bear-sighting data to show the concentration of bears over an area. We'll use alpha values to show the density. We'll use an unusual hexagonal grid to divide the area and a rule-based renderer to build the display.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec459" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to install the MMQGIS plugin, which is used to build the hexagonal grid using the QGIS <strong class="calibre2">Plugin Manager</strong>.</p><p class="calibre9">You also need to download the bear data from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/bear-data.zip">https://geospatialpython.googlecode.com/svn/bear-data.zip</a>, unzip the shapefile, and put it in the <code class="literal">ms</code> directory of your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec460" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the bear data. Then, we will use the MMQGIS plugin to generate the hexagonal grid. Then, we'll use the Processing Toolbox to clip the hexagon to the bear shapefile, and join the shapefile attribute data to the hexagon grid. Finally, we'll use a rule-based renderer to apply alpha values based on bear-sighting density and add the result to the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we import all the libraries we'll need, including the processing engine, the PyQt GUI library for color management, and the MMQGIS plugin:<div><pre class="programlisting"><strong class="calibre2">import processing</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">from mmqgis import mmqgis_library as mmqgis</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll set <a id="id725" class="calibre1"/>up the paths for all of our input and output shapefiles:<div><pre class="programlisting"><strong class="calibre2">dir = "/qgis_data/ms/"</strong>
<strong class="calibre2">source = dir + "bear-data.shp"</strong>
<strong class="calibre2">grid = dir + "grid.shp"</strong>
<strong class="calibre2">clipped_grid = dir + "clipped_grid.shp"</strong>
<strong class="calibre2">output = dir + "ms-bear-sightings.shp"</strong>
</pre></div></li><li class="listitem" value="3">Now, we<a id="id726" class="calibre1"/> can set up the input shapefile as a layer:<div><pre class="programlisting"><strong class="calibre2">layer = QgsVectorLayer(source, "bear data", "ogr")</strong>
</pre></div></li><li class="listitem" value="4">We'll need the extent of the shapefile to create the grid as well as the width and height, in map units:<div><pre class="programlisting"><strong class="calibre2">e = layer.extent()</strong>
<strong class="calibre2">llx = e.xMinimum()</strong>
<strong class="calibre2">lly = e.yMinimum()</strong>
<strong class="calibre2">w = e.width()</strong>
<strong class="calibre2">h = e.height()</strong>
</pre></div></li><li class="listitem" value="5">Now, we can use the MMQGIS plugin to generate the grid over the entire shapefile's extent. We'll use a grid cell size of one-tenth of a degree (approximately 6 miles):<div><pre class="programlisting"><strong class="calibre2">mmqgis.mmqgis_grid(iface, grid, .1, .1, w, h, llx, lly, "Hexagon (polygon)", False)</strong>
</pre></div></li><li class="listitem" value="6">Then, we can clip the grid to the shape of our source data using the Processing Toolbox:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("qgis:clip",grid,source,clipped_grid)</strong>
</pre></div></li><li class="listitem" value="7">Next, we need to do a spatial join in order to match the source data's attributes based on counties to each grid cell:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("qgis:joinbylocation",source,clipped_grid,0,"sum,mean,min,max,median",0,0,output)</strong>
</pre></div></li><li class="listitem" value="8">Now, we can add this output as a layer:<div><pre class="programlisting"><strong class="calibre2">bears = QgsVectorLayer(output, "Bear Sightings", "ogr")</strong>
</pre></div></li><li class="listitem" value="9">Next, we create our rendering rule set as Python tuples, specifying a label, value expression, color, and alpha level for the symbols between 0 and 1:<div><pre class="programlisting"><strong class="calibre2">rules = (</strong>
<strong class="calibre2">    ('RARE', '"BEARS" &lt; 5', (227,26,28,255), .2),</strong>
<strong class="calibre2">    ('UNCOMMON', '"BEARS" &gt; 5 AND "BEARS" &lt; 15', (227,26,28,255), .4),</strong>
<strong class="calibre2">    ('OCCASIONAL', '"BEARS" &gt; 14 AND "BEARS" &lt; 50', (227,26,28,255), .6),</strong>
<strong class="calibre2">    ('FREQUENT', '"BEARS" &gt; 50', (227,26,28,255), 1),</strong>
<strong class="calibre2">)</strong>
</pre></div></li><li class="listitem" value="10">We then<a id="id727" class="calibre1"/> create the default <a id="id728" class="calibre1"/>symbol rule renderer and add the rules to the renderer:<div><pre class="programlisting"><strong class="calibre2">sym_bears = QgsFillSymbolV2.createSimple({"outline_color":"white","outline_width":".26"}) </strong>
<strong class="calibre2">rend_bears = QgsRuleBasedRendererV2(sym_bears)</strong>
<strong class="calibre2">root_rule = rend_bears.rootRule()</strong>
<strong class="calibre2">for label, exp, color, alpha in rules:</strong>
<strong class="calibre2">    # create a clone (i.e. a copy) of the default rule</strong>
<strong class="calibre2">rule = root_rule.children()[0].clone()</strong>
<strong class="calibre2">    # set the label, exp and color</strong>
<strong class="calibre2">rule.setLabel(label)</strong>
<strong class="calibre2">rule.setFilterExpression(exp)</strong>
<strong class="calibre2">r,g,b,a = color</strong>
<strong class="calibre2">rule.symbol().setColor(QColor(r,g,b,a))</strong>
<strong class="calibre2">    # set the transparency level</strong>
<strong class="calibre2">rule.symbol().setAlpha(alpha)</strong>
<strong class="calibre2">    # append the rule to the list of rules</strong>
<strong class="calibre2">root_rule.appendChild(rule)</strong>
</pre></div></li><li class="listitem" value="11">We remove the default rule:<div><pre class="programlisting"><strong class="calibre2">root_rule.removeChildAt(0)</strong>
</pre></div></li><li class="listitem" value="12">We apply the renderer to the layer:<div><pre class="programlisting"><strong class="calibre2">bears.setRendererV2(rend_bears)</strong>
</pre></div></li><li class="listitem" value="13">Finally, we add the finished density layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(bears)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec461" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The rule-based renderer <a id="id729" class="calibre1"/>forms the core of this recipe. However, the hexagonal grid provides a more interesting way to visualize statistical<a id="id730" class="calibre1"/> data. Like a dot-based density map, hexagons are not entirely spatially accurate or precise but make it very easy to understand the overall trend of the data. The interesting feature of hexagons is their centroid, which is equidistant to each of their neighbors, whereas with a square grid, the diagonal neighbors are further away.</p><p class="calibre9">This image shows how the resulting map will look:</p><div><img src="img/00067.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec158" class="calibre1"/>Using the __geo_interface__ protocol</h1></div></div></div><pre>__geo_interface__</code> method.</pre></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec462" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">This recipe requires no preparation.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec463" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create<a id="id732" class="calibre1"/> two functions: one for features and one for geometry. We'll then use Python's dynamic capability to patch the QGIS objects with a <code class="literal">__geo_interface__ built-in</code> method. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll need the Python <code class="literal">json</code> module:<div><pre class="programlisting"><strong class="calibre2">import json</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll create our function for the features that take a feature as input and return a GeoJSON-like object:<div><pre class="programlisting"><strong class="calibre2">def mapping_feature(feature):</strong>
<strong class="calibre2">geom = feature.geometry()</strong>
<strong class="calibre2">   properties = {}</strong>
<strong class="calibre2">   fields = [field.name() for field in feature.fields()]</strong>
<strong class="calibre2">   properties = dict(zip(fields, feature.attributes()))</strong>
<strong class="calibre2">   return { 'type' : 'Feature',</strong>
<strong class="calibre2">             'properties' : properties,</strong>
<strong class="calibre2">             'geometry' : geom.__geo_interface__}</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll create the <code class="literal">geometry</code> function:<div><pre class="programlisting"><strong class="calibre2">def mapping_geometry(geometry):</strong>
<strong class="calibre2">geo = geometry.exportToGeoJSON()</strong>
<strong class="calibre2">return json.loads(geo)</strong>
</pre></div></li><li class="listitem" value="4">Finally, we'll patch the QGIS feature and geometry objects with our custom built-in to call our functions when the built-in is accessed:<div><pre class="programlisting"><strong class="calibre2">QgsFeature.__geo_interface__ = property(lambda self: mapping_feature(self))</strong>
<strong class="calibre2">QgsGeometry.__geo_interface__ = property(lambda self: mapping_geometry(self))</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec464" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This recipe is surprisingly simple but exploits some of Python's most interesting features. First, note that the<a id="id733" class="calibre1"/> feature function actually calls the geometry function as part of its output. Also, note that adding the <code class="literal">__geo_interface__</code> built-in function is as simple as using the double-underscore naming convention and Python's built-in property method to declare lambda functions as internal to the objects. Another interesting Python feature is that the QGIS objects are able to pass themselves to our custom functions using the self keyword.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec159" class="calibre1"/>Generating points along a line</h1></div></div></div><p class="calibre9">You can<a id="id734" class="calibre1"/> generate points within a polygon in a fairly simple way by using the point in polygon method. However, sometimes you may want to generate points along a line. You can randomly place points inside the polygon's extent — which is essentially just a rectangular polygon — or you can place points at random locations along the line at random distances. In this recipe, we'll demonstrate both of these methods.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec465" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and place it in a directory named <code class="literal">shapes</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/path.zip">https://geospatialpython.googlecode.com/svn/path.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec466" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">First, we will generate random points along a line using a <code class="literal">grass()</code> function in the Processing Toolbox. Then, we'll generate points within the line's extent using a native QGIS processing function. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the processing module:<div><pre class="programlisting"><strong class="calibre2">import processing</strong>
</pre></div></li><li class="listitem" value="2">Then, we'll load the line layer onto the map:<div><pre class="programlisting"><strong class="calibre2">line = QgsVectorLayer("/qgis_data/shapes/path.shp", "Line", "ogr")</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(line)</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll generate points along the line by specifying the path to the shapefile, a maximum distance between the points in map units (meters), the type of feature we want to output (vertices), extent, snap tolerance option, minimum distance between the points, output type, and output name. We won't specify the name and tell QGIS to load the output automatically:<div><pre class="programlisting"><strong class="calibre2">processing.runandload("grass:v.to.points",line,"1000",False, False,True,"435727.015026,458285.819185,5566442.32879,5591754.78979",-1,0.0001,0,None)</strong>
</pre></div></li><li class="listitem" value="4">Finally, we'll create some points within the lines' extent and load them as well:<div><pre class="programlisting"><strong class="calibre2">processing.runandload("qgis:randompointsinextent","435727.015026,458285.819185,5566442.32879,5591754.78979",100,100,None)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec467" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The first algorithm<a id="id735" class="calibre1"/> puts the points on the line. The second places them within the vicinity. Both approaches have different use cases.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec468" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">Another option will be to create a buffer around the line at a specified distance and clip the output of the second algorithm so that the points aren't near the corners of the line extent. The <code class="literal">QgsGeometry</code> class also has an interpolate which allows you to create a point on a line at a specified distance from its origin. This is documented at <a class="calibre1" href="http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1">http://qgis.org/api/classQgsGeometry.html#a8c3bb1b01d941219f2321e6c6c3db7e1</a>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec160" class="calibre1"/>Using expression-based labels</h1></div></div></div><p class="calibre9">Expressions<a id="id736" class="calibre1"/> are a kind of mini-programming language or SQL-like language found throughout different QGIS functions to select features. One important use of expressions is to control labels. Maps easily become cluttered if you label every single feature. Expressions make it easy to limit labels to important features. You can filter labels using expressions from within Python, as we will do in this recipe.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec469" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec470" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll use the QGIS PAL labeling engine to filter labels based on a field name. After loading the layer, we'll create our PAL settings and write them to the layer. Finally, we'll add the layer to the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll set up the path to our shapefile:<div><pre class="programlisting"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/MS_UrbanAnC10.shp"</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll load our layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer(pth, "Urban Areas", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we create a labeling object and read the layer's current labeling settings:<div><pre class="programlisting"><strong class="calibre2">palyr = QgsPalLayerSettings()</strong>
<strong class="calibre2">palyr.readFromLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="4">We create our expression to only label the features whose population field is greater than 50,000:<div><pre class="programlisting"><strong class="calibre2">palyr.fieldName = 'CASE WHEN "POP" &gt; 50000 THEN NAME10 END'</strong>
</pre></div></li><li class="listitem" value="5">Then, we enable these settings:<div><pre class="programlisting"><strong class="calibre2">palyr.enabled = True</strong>
</pre></div></li><li class="listitem" value="6">Finally, we apply the labeling filter to the layer and add it to the map:<div><pre class="programlisting"><strong class="calibre2">palyr.writeToLayer(lyr)</strong>
<strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec471" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">While labels are <a id="id737" class="calibre1"/>a function of the layer, the settings for the labeling engine are controlled by an external object and then applied to the layer.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec161" class="calibre1"/>Creating dynamic forms in QGIS</h1></div></div></div><p class="calibre9">When you <a id="id738" class="calibre1"/>edit the fields of a layer in QGIS, you have the option of using a spreadsheet-like table view or you can use a database-style form view. Forms are useful because you can change the design of the form and add interactive features that react to user input in order to better control data editing. In this recipe, we'll add some custom validation to a form that checks user input for valid values.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec472" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download the zipped shapefile and decompress it to a directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip">https://geospatialpython.googlecode.com/files/MS_UrbanAnC10.zip</a>
</p><p class="calibre9">You'll also need to create a blank Python file called <code class="literal">validate.py</code>, which you'll edit as shown in the following steps. Put the <code class="literal">validate.py</code> file in the <code class="literal">ms</code> directory of your <code class="literal">qgis_data</code> directory with the shapefile.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec473" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We'll create the <a id="id739" class="calibre1"/>two functions we need for our validation engine. Then, we'll use the QGIS interface to attach the action to the layer. Make sure that you add the following code to the <code class="literal">validate.py</code> file in the same directory as the shapefile, as follows:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll import the Qt libraries:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll create some global variables for the attribute we'll be validating and the form dialog:<div><pre class="programlisting"><strong class="calibre2">popFld = None</strong>
<strong class="calibre2">dynamicDialog = None</strong>
</pre></div></li><li class="listitem" value="3">Now, we'll begin building the function that changes the behavior of the dialog and create variables for the field we want to validate and the submit button:<div><pre class="programlisting"><strong class="calibre2">def dynamicForm(dialog,lyrId,featId):</strong>
<strong class="calibre2">  globaldynamicDialog</strong>
<strong class="calibre2">  dynamicDialog = dialog</strong>
<strong class="calibre2">  globalpopFld = dialog.findChild(QLineEdit,"POP")</strong>
<strong class="calibre2">  buttonBox=\</strong>
<strong class="calibre2">  dialog.findChild(QDialogButtonBox,"buttonBox")</strong>
</pre></div></li><li class="listitem" value="4">We must disconnect the dialog from the action that controls the form acceptance:<div><pre class="programlisting"><strong class="calibre2">buttonBox.accepted.disconnect(dynamicDialog.accept)</strong>
</pre></div></li><li class="listitem" value="5">Next, we reconnect the dialogs, actions to our custom actions:<div><pre class="programlisting"><strong class="calibre2">buttonBox.accepted.connect(validate)</strong>
<strong class="calibre2">buttonBox.rejected.connect(dynamicDialog.reject)</strong>
</pre></div></li><li class="listitem" value="6">Now, we'll create the validation function that will reject the form if the population field has a value less than 1:<div><pre class="programlisting"><strong class="calibre2">def validate():</strong>
<strong class="calibre2">if not float(popFld.text()) &gt; 0:</strong>
<strong class="calibre2">    msg = QMessageBox(f)</strong>
<strong class="calibre2">    msg.setText("Population must be \ </strong>
<strong class="calibre2">    greater than zero.")</strong>
<strong class="calibre2">    msg.exec_()</strong>
<strong class="calibre2">      else:</strong>
<strong class="calibre2">        dynamicDialog.accept()</strong>
</pre></div></li><li class="listitem" value="7">Next, open <a id="id740" class="calibre1"/>QGIS and drag and drop the shapefile from your filesystem onto the map canvas.</li><li class="listitem" value="8">Save the project and give it a name in the same directory as the <code class="literal">validate.py</code> file.</li><li class="listitem" value="9">In the QGIS legend, double-click on the layer name.</li><li class="listitem" value="10">Select the <strong class="calibre2">Fields</strong> tab on the left-hand side of the <strong class="calibre2">Layer Properties</strong> dialog.</li><li class="listitem" value="11">In the <strong class="calibre2">Fields</strong> tab at the top-right of the screen, enter the following line into the <strong class="calibre2">PythonInit Function</strong> field:<div><pre class="programlisting"><strong class="calibre2">validate.dynamicForm</strong>
</pre></div></li><li class="listitem" value="12">Click on the <strong class="calibre2">OK</strong> button, in the bottom-right of the <strong class="calibre2">Layer Properties</strong> dialog.</li><li class="listitem" value="13">Now, use the identify tool to select a feature.</li><li class="listitem" value="14">In the <strong class="calibre2">Feature Properties</strong> dialog, click on the form icon in the top-left of the image.</li><li class="listitem" value="15">Once the feature form is open, switch back to the <strong class="calibre2">QGIS Legend</strong>, right-click on the layer name, and select <strong class="calibre2">Toggle Editing</strong>.</li><li class="listitem" value="16">Switch back to the feature form, scroll down to the <strong class="calibre2">POP</strong> field, and change the value to <code class="literal">0</code>.</li><li class="listitem" value="17">Now, click on the <strong class="calibre2">OK</strong> button and verify that you've received the warning dialog, which requires the value to be greater than <code class="literal">0</code>.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec474" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The <code class="literal">validate.py</code> file must be in your Python path. Putting this file in the same directory as the project makes the functions available. Validation is one of the simplest functions you can implement.</p><p class="calibre9">This screenshot shows the rejection message when the population is set to <code class="literal">0</code>:</p><div><img src="img/00068.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec162" class="calibre1"/>Calculating length for all selected lines</h1></div></div></div><p class="calibre9">If you need to <a id="id741" class="calibre1"/>calculate the total of a given dataset property, such as length, the easiest thing to do is use Python. In this recipe, we'll total the length of the railways in a dataset.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec475" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download a zipped shapefile from <a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip">https://geospatialpython.googlecode.com/svn/ms_rails_mstm.zip</a>.</p><p class="calibre9">Unzip it and place it in directory named <code class="literal">ms</code> in your <code class="literal">qgis_data</code> directory.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec476" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load the layer, loop through the features while keeping a running total of line lengths, and finally convert the result to kilometers. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we'll set up the path to our shapefile:<div><pre class="programlisting"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/ms/ms_rails_mstm.shp"</strong>
</pre></div></li><li class="listitem" value="2">Then, we'll load the layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer(pth, "Railroads", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Next, we need a variable to total the line lengths:<div><pre class="programlisting"><strong class="calibre2">total = 0</strong>
</pre></div></li><li class="listitem" value="4">Now, we <a id="id742" class="calibre1"/>loop through the layer, getting the length of each line:<div><pre class="programlisting"><strong class="calibre2">for f in lyr.getFeatures():</strong>
<strong class="calibre2">  geom = f.geometry()</strong>
<strong class="calibre2">  total += geom.length()</strong>
</pre></div></li><li class="listitem" value="5">Finally, we print the total length converted to kilometers and format the string to only show two decimal places:<div><pre class="programlisting"><strong class="calibre2">print "%0.2f total kilometers of rails." % (total / 1000)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec477" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This function is simple, but it's not directly available in the QGIS API. You can use a similar technique to total up the area of a set of polygons or perform conditional counting.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec163" class="calibre1"/>Using a different status bar CRS than the map</h1></div></div></div><p class="calibre9">Sometimes, you may want to display a different coordinate system for the mouse coordinates in the status bar<a id="id743" class="calibre1"/> than what the source data is. With this recipe, you can set a different coordinate system without changing the data coordinate reference system or the CRS for the map.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec478" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">Download the zipped shapefile and unzip it to your <code class="literal">qgis_data/ms</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/MSCities_Geo.zip">https://geospatialpython.googlecode.com/files/MSCities_Geo.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec479" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our layer, establish a message in the status bar, create a special event listener to transform the map coordinates at the mouse's location to our alternate CRS, and then connect the map signal for the mouse's map coordinates to our listener function. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the Qt core library:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
</pre></div></li><li class="listitem" value="2">Then, we will set up the path to the shapefile and load it as a layer:<div><pre class="programlisting"><strong class="calibre2">pth = "/qgis_data/ms/MSCities_Geo_Pts.shp"</strong>
<strong class="calibre2">lyr = QgsVectorLayer(pth, "Cities", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Now, we add the layer to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="4">Next, we create a default message that will be displayed in the status bar and will be replaced by the alternate coordinates later, when the event listener is active:<div><pre class="programlisting"><strong class="calibre2">msg = "Alternate CRS ( x: %s, y: %s )"</strong>
</pre></div></li><li class="listitem" value="5">Then, we<a id="id744" class="calibre1"/> display our default message in the left-hand side of the status bar as a placeholder:<div><pre class="programlisting"><strong class="calibre2">iface.mainWindow().statusBar().showMessage(msg % ("--", "--"))</strong>
</pre></div></li><li class="listitem" value="6">Now, we create our custom event-listener function to transform the mouse's map location to our custom CRS, which in this case is <a id="id745" class="calibre1"/><strong class="calibre2">EPSG 3815</strong>:<div><pre class="programlisting"><strong class="calibre2">def listen_xyCoordinates(point):</strong>
<strong class="calibre2">    crsSrc = iface.mapCanvas().mapRenderer().destinationCrs()</strong>
<strong class="calibre2">    crsDest = QgsCoordinateReferenceSystem(3815)   </strong>
<strong class="calibre2">    xform = QgsCoordinateTransform(crsSrc, crsDest)</strong>
<strong class="calibre2">    xpoint = xform.transform(point)</strong>
<strong class="calibre2">    iface.mainWindow().statusBar().showMessage(msg % (xpoint.x(), xpoint.y()))</strong>
</pre></div></li><li class="listitem" value="7">Next, we connect the map canvas signal that is emitted when the mouse coordinates are updated to our custom event listener:<div><pre class="programlisting"><strong class="calibre2">QObject.connect(iface.mapCanvas(), SIGNAL("xyCoordinates(const QgsPoint &amp;)"), listen_xyCoordinates)</strong>
</pre></div></li><li class="listitem" value="8">Finally, verify that when you move the mouse around the map, the status bar is updated with the transformed coordinates.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec480" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The coordinate transformation engine in QGIS is very fast. Normally, QGIS tries to transform everything to WGS84 Geographic, but sometimes you need to view coordinates in a different reference system.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec164" class="calibre1"/>Creating HTML labels in QGIS</h1></div></div></div><p class="calibre9">QGIS map tips <a id="id746" class="calibre1"/>allow you to hover the mouse cursor over a feature in order to create a popup that displays information. This information is normally a data field, but you can also display other types of information using a subset of HTML tags. In this recipe, we'll create an HTML map tip that displays a Google Street View image at the feature's location.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec481" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">In your <code class="literal">qgis_data</code> directory, create a directory named <code class="literal">tmp</code>.</p><p class="calibre9">You will also need to download the following zipped shapefile and place it in your <code class="literal">qgis_data/nyc</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip">https://geospatialpython.googlecode.com/files/NYC_MUSEUMS_GEO.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec482" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will create a function to process the Google data and register it as a QGIS function. Then, we'll load the layer and set its map tip display field. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the Python libraries we'll need:<div><pre class="programlisting"><strong class="calibre2">from qgis.utils import qgsfunction</strong>
<strong class="calibre2">from qgis.core import QGis</strong>
<strong class="calibre2">import urllib    </strong>
</pre></div></li><li class="listitem" value="2">Next, we'll set a special QGIS Python decorator that registers our function as a QGIS function. The first argument, <code class="literal">0</code>, means that the function won't accept any arguments itself. The second argument, <code class="literal">Python</code>, defines the group in which the function will appear when you use the expression builder:<div><pre class="programlisting"><strong class="calibre2">@qgsfunction(0, "Python")</strong>
</pre></div></li><li class="listitem" value="3">We'll create a function that accepts a feature and uses its geometry to pull down a Google Street View image. We must cache the images locally because the Qt widget that displays the map tips only allows you to use local images:<div><pre class="programlisting"><strong class="calibre2">def googleStreetView(values, feature, parent):</strong>
<strong class="calibre2">x,y = feature.geometry().asPoint()</strong>
<strong class="calibre2">baseurl = "https://maps.googleapis.com/maps/api/streetview?"</strong>
<strong class="calibre2">w = 400</strong>
<strong class="calibre2">h = 400</strong>
<strong class="calibre2">fov = 90</strong>
<strong class="calibre2">heading = 235</strong>
<strong class="calibre2">pitch = 10</strong>
<strong class="calibre2">params = "size=%sx%s&amp;" % (w,h)</strong>
<strong class="calibre2">params += "location=%s,%s&amp;" % (y,x)</strong>
<strong class="calibre2">params += "fov=%s&amp;heading=%s&amp;pitch=%s" % (fov, heading, pitch) </strong>
<strong class="calibre2">url = baseurl + params</strong>
<strong class="calibre2">tmpdir = "/qgis_data/tmp/"</strong>
<strong class="calibre2">img = tmpdir + str(feature.id()) + ".jpg"</strong>
<strong class="calibre2">urllib.urlretrieve(url, img)</strong>
<strong class="calibre2">return img</strong>
</pre></div></li><li class="listitem" value="4">Now, we can load the layer:<div><pre class="programlisting"><strong class="calibre2">pth = "/qgis_data/nyc/nyc_museums_geo.shp"</strong>
<strong class="calibre2">lyr = QgsVectorLayer(pth, "New York City Museums", "ogr")</strong>
</pre></div></li><li class="listitem" value="5">Next, we can set the display field using a special QGIS tag with the name of our function:<div><pre class="programlisting"><strong class="calibre2">lyr.setDisplayField('&lt;img src="img/[% $googleStreetView %]"/&gt;')</strong>
</pre></div></li><li class="listitem" value="6">Finally, we add it to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayer(lyr)</strong>
</pre></div></li><li class="listitem" value="7">Select<a id="id747" class="calibre1"/> the map tips tool and hover over the different points to see the Google Street View images.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec483" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The key to this recipe is the <code class="literal">@qgsfunction</code>
 decorator. When you register the function in this way, it shows up in the menus for Python functions in expressions. The function must also have the parent and value parameters, but we didn't need them in this case.</p><p class="calibre9">The following screenshot shows a Google Street View map tip:</p><div><img src="img/00069.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec484" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre9">If you don't need the <a id="id748" class="calibre1"/>function any more, you must unregister it for the function to go away. The <code class="literal">unregister</code> command uses the following convention, referencing the function name with a dollar sign:</p><div><pre class="programlisting"><strong class="calibre2">QgsExpression.unregisterFunction("$googleStreetView")</strong>
</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec165" class="calibre1"/>Using OpenStreetMap's points of interest in QGIS</h1></div></div></div><p class="calibre9">OpenStreetMap has <a id="id749" class="calibre1"/>an API called Overpass that lets you access OSM data dynamically. In this recipe, we'll add some OSM tourism points of interest to a map.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec485" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to use the QGIS <strong class="calibre2">Plugin Manager</strong> to install the <strong class="calibre2">Quick OSM</strong> plugin.</p><p class="calibre9">You will also need to download the following shapefile and unzip it to your <code class="literal">qgis_data/ms</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip">https://geospatialpython.googlecode.com/svn/MSCoast_geo.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec486" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our base layer that defines the area of interest. Then, we'll use the Processing Toolbox <a id="id750" class="calibre1"/>to build a query for OSM, download the data, and add it to the map. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we need to import the <code class="literal">processing</code> module:<div><pre class="programlisting"><strong class="calibre2">import processing</strong>
</pre></div></li><li class="listitem" value="2">Next, we need to load the base layer:<div><pre class="programlisting"><strong class="calibre2">lyr = QgsVectorLayer("/qgis_data/ms/MSCoast_geo.shp", "MS Coast", "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Then, we'll need the layer's extents for the processing algorithms:<div><pre class="programlisting"><strong class="calibre2">ext = lyr.extent()</strong>
<strong class="calibre2">w =  ext.xMinimum()</strong>
<strong class="calibre2">s =  ext.yMinimum()</strong>
<strong class="calibre2">e =  ext.xMaximum()</strong>
<strong class="calibre2">n =  ext.yMaximum()</strong>
</pre></div></li><li class="listitem" value="4">Next, we create the query:<div><pre class="programlisting"><strong class="calibre2">factory = processing.runalg("quickosm:queryfactory",\</strong>
<strong class="calibre2">"tourism","","%s,%s,%s,%s" % (w,e,s,n),"",25)</strong>
<strong class="calibre2">q = factory["OUTPUT_QUERY"]</strong>
</pre></div></li><li class="listitem" value="5">The Quick OSM algorithm has a bug in its output, so we'll create a properly formatted XML tag and perform a string replace:<div><pre class="programlisting"><strong class="calibre2">bbox_query = """&lt;bbox-query e="%s" n="%s" s="%s" \ w="%s"/&gt;""" % (e,n,s,w)</strong>
<strong class="calibre2">bad_xml = """&lt;bbox-query %s,%s,%s,%s/&gt;""" % (w,e,s,n)</strong>
<strong class="calibre2">good_query = q.replace(bad_xml, bbox_query)</strong>
</pre></div></li><li class="listitem" value="6">Now, we download the OSM data using our query:<div><pre class="programlisting"><strong class="calibre2">results = processing.runalg("quickosm:queryoverpassapiwithastring",\"http://overpass-api.de/api/",good_query,"0,0,0,0","",None)</strong>
<strong class="calibre2">osm = results["OUTPUT_FILE"]</strong>
</pre></div></li><li class="listitem" value="7">We define the names of the shapefiles we will create from the OSM output:<div><pre class="programlisting"><strong class="calibre2">poly = "/qgis_data/ms/tourism_poly.shp"</strong>
<strong class="calibre2">multiline = "/qgis_data/ms/tourism_multil.shp"</strong>
<strong class="calibre2">line = "/qgis_data/ms/tourism_lines.shp"</strong>
<strong class="calibre2">points = "/qgis_data/ms/tourism_points.shp"</strong>
</pre></div></li><li class="listitem" value="8">Now, we convert the OSM data to shapefiles:<div><pre class="programlisting"><strong class="calibre2">processing.runalg("quickosm:ogrdefault",osm,"","","","",poly,multiline,line,points)</strong>
</pre></div></li><li class="listitem" value="9">We place the points as a layer:<div><pre class="programlisting"><strong class="calibre2">tourism_points = QgsVectorLayer(points, "Points of Interest", "ogr")</strong>
</pre></div></li><li class="listitem" value="10">Finally, we can add them to a map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([tourism_points, lyr]</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec487" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The Quick OSM plugin <a id="id751" class="calibre1"/>manages the Overpass API. What's interesting about this plugin is that it provides processing algorithms in addition to a GUI interface. The processing algorithm that creates the query unfortunately formats the <code class="literal">bbox-query</code> tag improperly, so we need to work around this issue with the string replace. The API returns an OSM XML file that we must convert to shapefiles for use in QGIS.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec166" class="calibre1"/>Visualizing data in 3D with WebGL</h1></div></div></div><p class="calibre9">QGIS displays<a id="id752" class="calibre1"/> data in a two-dimensions even if the data is three-dimensional. However, most modern browsers can display 3D data using the <a id="id753" class="calibre1"/>WebGL standard. In this recipe, we'll use the <strong class="calibre2">Qgis2threejs</strong> plugin to display QGIS data in 3D in a browser.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec488" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to download some raster elevation data in the zipped directory and place it in your <code class="literal">qgis_data</code> directory from the following:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/saveqml.zip">https://geospatialpython.googlecode.com/svn/saveqml.zip</a>
</p><p class="calibre9">You will also need to install the <strong class="calibre2">Qgis2threejs</strong> plugin using the QGIS <strong class="calibre2">Plugin Manager</strong>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec489" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will set up a color ramp for a DEM draped over a hillshade image and use the plugin to create a WebGL page in order to display the data. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we will need to import the relevant libraries and the <strong class="calibre2">Qgis2threejs</strong> plugin:<div><pre class="programlisting"><strong class="calibre2">from PyQt4.QtCore import *</strong>
<strong class="calibre2">from PyQt4.QtGui import *</strong>
<strong class="calibre2">import Qgis2threejs as q23js</strong>
</pre></div></li><li class="listitem" value="2">Next, we'll <a id="id754" class="calibre1"/>disable QGIS automatic reprojection to keep the data display in meters:<div><pre class="programlisting"><strong class="calibre2">iface.mapCanvas().setCrsTransformEnabled(False)</strong>
<strong class="calibre2">iface.mapCanvas().setMapUnits(0)</strong>
</pre></div></li><li class="listitem" value="3">Now, we <a id="id755" class="calibre1"/>can load our raster layers:<div><pre class="programlisting"><strong class="calibre2">demPth = "/Users/joellawhead/qgis_data/saveqml/dem.asc"</strong>
<strong class="calibre2">hillshadePth = "/Users/joellawhead/qgis_data/saveqml/hillshade.tif"</strong>
<strong class="calibre2">dem = QgsRasterLayer(demPth, "DEM")</strong>
<strong class="calibre2">hillshade = QgsRasterLayer(hillshadePth, "Hillshade")</strong>
</pre></div></li><li class="listitem" value="4">Then, we can create the color ramp renderer for the DEM layer:<div><pre class="programlisting"><strong class="calibre2">algorithm = QgsContrastEnhancement.StretchToMinimumMaximum</strong>
<strong class="calibre2">limits = QgsRaster.ContrastEnhancementMinMax</strong>
<strong class="calibre2">dem.setContrastEnhancement(algorithm, limits)</strong>
<strong class="calibre2">s = QgsRasterShader() </strong>
<strong class="calibre2">c = QgsColorRampShader() </strong>
<strong class="calibre2">c.setColorRampType(QgsColorRampShader.INTERPOLATED) </strong>
<strong class="calibre2">i = [] </strong>
<strong class="calibre2">qri = QgsColorRampShader.ColorRampItem</strong>
<strong class="calibre2">i.append(qri(356.334, QColor(63,159,152,255), '356.334')) </strong>
<strong class="calibre2">i.append(qri(649.292, QColor(96,235,155,255), '649.292')) </strong>
<strong class="calibre2">i.append(qri(942.25, QColor(100,246,174,255), '942.25')) </strong>
<strong class="calibre2">i.append(qri(1235.21, QColor(248,251,155,255), '1235.21'))</strong>
<strong class="calibre2">i.append(qri(1528.17, QColor(246,190,39,255), '1528.17')) </strong>
<strong class="calibre2">i.append(qri(1821.13, QColor(242,155,39,255), '1821.13'))</strong>
<strong class="calibre2">i.append(qri(2114.08, QColor(165,84,26,255), '2114.08'))</strong>
<strong class="calibre2">i.append(qri(2300, QColor(236,119,83,255), '2300'))</strong>
<strong class="calibre2">i.append(qri(2700, QColor(203,203,203,255), '2700'))</strong>
<strong class="calibre2">c.setColorRampItemList(i) </strong>
<strong class="calibre2">s.setRasterShaderFunction(c) </strong>
<strong class="calibre2">ps = QgsSingleBandPseudoColorRenderer(dem.dataProvider(), 1,  s)</strong>
<strong class="calibre2">ps.setOpacity(0.5) </strong>
<strong class="calibre2">dem.setRenderer(ps) </strong>
</pre></div></li><li class="listitem" value="5">Now, we're ready to add the raster layers to the map:<div><pre class="programlisting"><strong class="calibre2">QgsMapLayerRegistry.instance().addMapLayers([dem, hillshade])</strong>
</pre></div></li><li class="listitem" value="6">To create the <a id="id756" class="calibre1"/>WebGL interface, we need to take control of the plugin's GUI dialog, but we will keep it hidden:<div><pre class="programlisting"><strong class="calibre2">d = q23js.qgis2threejsdialog.Qgis2threejsDialog(iface)</strong>
</pre></div></li><li class="listitem" value="7">Next, we <a id="id757" class="calibre1"/>must create a dictionary of the properties required by the plugin. The most important is the layer ID of the DEM layer:<div><pre class="programlisting"><strong class="calibre2">props = [None,</strong>
<strong class="calibre2"> None,</strong>
<strong class="calibre2"> {u'spinBox_Roughening': 4,</strong>
<strong class="calibre2">u'checkBox_Surroundings': False,</strong>
<strong class="calibre2">u'horizontalSlider_Resolution': 2,</strong>
<strong class="calibre2">u'lineEdit_Color': u'',</strong>
<strong class="calibre2"> 'visible': False,</strong>
<strong class="calibre2"> 'dem_Height': 163,</strong>
<strong class="calibre2">u'checkBox_Frame': False,</strong>
<strong class="calibre2">u'lineEdit_ImageFile': u'',</strong>
<strong class="calibre2">u'spinBox_Size': 5,</strong>
<strong class="calibre2">u'spinBox_sidetransp': 0,</strong>
<strong class="calibre2">u'lineEdit_xmax': u'',</strong>
<strong class="calibre2">u'radioButton_MapCanvas': True,</strong>
<strong class="calibre2"> 'dem_Width': 173,</strong>
<strong class="calibre2">u'radioButton_Simple': True,</strong>
<strong class="calibre2">u'lineEdit_xmin': u'',</strong>
<strong class="calibre2">u'checkBox_Sides': True,</strong>
<strong class="calibre2">u'comboBox_DEMLayer': dem.id(),</strong>
<strong class="calibre2">u'spinBox_demtransp': 0,</strong>
<strong class="calibre2">u'checkBox_Shading': False,</strong>
<strong class="calibre2">u'lineEdit_ymax': u'',</strong>
<strong class="calibre2">u'lineEdit_ymin': u'',</strong>
<strong class="calibre2">u'spinBox_Height': {5},{},{},{},{}]}</strong>
</pre></div></li><li class="listitem" value="8">Now, we will apply these properties to the plugin:<div><pre class="programlisting"><strong class="calibre2">d.properties = props</strong>
</pre></div></li><li class="listitem" value="9">We must set the output file for the HTML page:<div><pre class="programlisting"><strong class="calibre2">d.ui.lineEdit_OutputFilename.setText('/qgis_data/3D/3d.html')</strong>
</pre></div></li><li class="listitem" value="10">In the <a id="id758" class="calibre1"/>next step, we must override the method that saves the properties, otherwise it overwrites the properties we set:<div><pre class="programlisting"><strong class="calibre2">def sp(a,b):</strong>
<strong class="calibre2">return</strong>
<strong class="calibre2">d.saveProperties = sp</strong>
</pre></div></li><li class="listitem" value="11">Now, we are ready to run the plugin:<div><pre class="programlisting"><strong class="calibre2">d.run()</strong>
</pre></div></li><li class="listitem" value="12">On your filesystem, navigate to the HTML output page and open it in a browser.</li><li class="listitem" value="13">Follow the help instructions to move the 3D elevation display around.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec490" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">This plugin<a id="id759" class="calibre1"/> is absolutely not designed for script-level access. However, Python is so flexible that we can even script the plugin at the GUI level and avoid displaying the GUI, so it is seamless to the user. The only glitch in this approach is that the save method overwrites the properties we set, so we must insert a dummy function that prevents this overwrite.</p><p class="calibre9">The following image shows the WebGL viewer in action:</p><div><img src="img/00070.jpeg" alt="How it works..." class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec167" class="calibre1"/>Visualizing data on a globe</h1></div></div></div><p class="calibre9">Ever <a id="id760" class="calibre1"/>since the<a id="id761" class="calibre1"/> release of Google Earth, <em class="calibre10">spinning globe</em> applications have become a useful and popular method of geographic exploration. QGIS has an experimental plugin called <a id="id762" class="calibre1"/>
<strong class="calibre2">QGIS Globe</strong>, which is similar to Google Earth; however, it is extremely unstable. In this recipe, we'll display a layer in Google Earth.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec491" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre9">You will need to use the QGIS <strong class="calibre2">Plugin Manager</strong> to install the <strong class="calibre2">MMQGIS</strong> plugin.</p><p class="calibre9">Make sure you have Google Earth installed from <a class="calibre1" href="https://www.google.com/earth/">https://www.google.com/earth/</a>.</p><p class="calibre9">You will also need the following dataset from a previous recipe. It is a zipped directory called <code class="literal">ufo</code> which you should uncompress to your <code class="literal">qgis_data</code> directory:</p><p class="calibre9">
<a class="calibre1" href="https://geospatialpython.googlecode.com/svn/ufo.zip">https://geospatialpython.googlecode.com/svn/ufo.zip</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec492" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre9">We will load our layer and set up the attribute we want to use for the Google Earth KML output as the descriptor. We'll use the MMQIGS plugin to output our layer to KML. Finally, we'll use a cross-platform technique to open the file, which will trigger it to open in Google Earth. To do this, we need to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, we will import the relevant Python libraries including the plugin. We will use the Python <code class="literal">webbrowser</code> module to launch Google Earth:<div><pre class="programlisting"><strong class="calibre2">from mmqgis import mmqgis_library as mmqgis</strong>
<strong class="calibre2">import webbrowser</strong>
<strong class="calibre2">import os</strong>
</pre></div></li><li class="listitem" value="2">Now, we'll load the layer:<div><pre class="programlisting"><strong class="calibre2">pth = "/Users/joellawhead/qgis_data/continental-us"</strong>
<strong class="calibre2">lyrName = "continental-us"</strong>
<strong class="calibre2">lyr = QgsVectorLayer(pth, lyrName, "ogr")</strong>
</pre></div></li><li class="listitem" value="3">Next, we'll set the output path for the KML:<div><pre class="programlisting"><strong class="calibre2">output = "/Users/joellawhead/qgis_data/us.kml"</strong>
</pre></div></li><li class="listitem" value="4">Then, we'll set up the variables needed by the plugin for the KML output which make up the layer identifier:<div><pre class="programlisting"><strong class="calibre2">nameAttr = "FIPS_CNTRY"</strong>
<strong class="calibre2">desc = ["CNTRY_NAME",]</strong>
<strong class="calibre2">sep = "Paragraph"</strong>
</pre></div></li><li class="listitem" value="5">Now, we can use the plugin to create the KML:<div><pre class="programlisting"><strong class="calibre2">mmqgis.mmqgis_kml_export(iface, lyrName, nameAttr, desc, \</strong>
<strong class="calibre2">sep, output, False)</strong>
</pre></div></li><li class="listitem" value="6">Finally, we'll <a id="id763" class="calibre1"/>use the <code class="literal">webbrowser</code> module to open<a id="id764" class="calibre1"/> the KML file, which will default to opening in Google Earth. We need to add the <code class="literal">file</code> protocol at the beginning of our output for the <code class="literal">webbrowser</code> module to work:<div><pre class="programlisting"><strong class="calibre2">webbrowser.open("file://" + output)</strong>
</pre></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec493" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre9">The MMQGIS plugin does a good job with custom scripts and has easy-to-use functions. While our method for automatically launching Google Earth may not work in every possible case, it is almost perfect.</p></div></div></body></html>