<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Container Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Container Types</h1></div></div></div><p>Container types are used to group objects together. The main difference between the different container types is the way individual elements are accessed and how operations are defined.</p><div class="section" title="Lists"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Lists</h1></div></div></div><p>A list is, as the name hints, a list of objects of any kind:</p><pre class="programlisting">L = ['a' 20.0, 5]&#13;
M = [3,['a', -3.0, 5]]</pre><p>The individual objects are enumerated by assigning each element an index. The first element in the list gets index 0. This zero-based indexing is frequently used in mathematical notation. Consider the usual indexing of coefficients of a polynomial.</p><p>The index allows us to access the following objects:</p><pre class="programlisting">L[1] # returns 20.0&#13;
L[0] # returns 'a'&#13;
M[1] # returns ['a',-3.0,5]&#13;
M[1][2] # returns 5</pre><p>The bracket notation here corresponds to the use of subscripts in mathematical formulas. <code class="literal">L</code> is a simple list, while <code class="literal">M</code> itself contains a list so that one needs two indexes to access an element of the inner list.</p><p>A list containing subsequent integers can easily be generated by the command <code class="literal">range</code>:</p><pre class="programlisting">L=list(range(4)) # generates a list with four elements: [0, 1, 2 ,3]</pre><p>A more general use is to provide this command with start, stop, and step parameters:</p><pre class="programlisting">L=list(range(17,29,4)) # generates [17, 21, 25]</pre><p>The command <code class="literal">len</code> returns the length of the list:</p><pre class="programlisting">len(L) # returns 3</pre><div class="section" title="Slicing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Slicing</h2></div></div></div><p>Slicing a list between <code class="literal">i</code> and <code class="literal">j</code> creates a new list containing the elements starting at <code class="literal">index i</code> and ending just before <code class="literal">j</code>.</p><p>For slicing, a range of indexes has to be given. <code class="literal">L[i:j]</code> means create a list by taking all elements from <code class="literal">L</code> starting at <code class="literal">L[i]</code> until <code class="literal">L[j-1]</code>. In other words, the new list is obtained by removing the first <code class="literal">i</code> elements from <code class="literal">L</code> and taking the next <code class="literal">j-i</code> elements (for <span class="emphasis"><em>j</em></span> &gt; <span class="emphasis"><em>i</em></span> ≥ 0). See the following figure (<span class="emphasis"><em>Figure 3.1</em></span>) for more examples:</p><p>
</p><div class="mediaobject"><img src="graphics/slicing.jpg" alt="Slicing"/></div><p>
</p><p>Figure 3.1: Some typical slicing situations</p><p>Here, <code class="literal">L[i:]</code> means remove the <span class="emphasis"><em>i</em></span> first elements, <code class="literal">L[:i]</code> means take only the first <span class="emphasis"><em>i</em></span> elements, and similarly, <code class="literal">L[:-i]</code> means remove the last <span class="emphasis"><em>i</em></span> elements, and <code class="literal">L[-i:]</code> means take only the last <span class="emphasis"><em>i</em></span> elements. This may be combined in <code class="literal">L[i:-j]</code> to remove the first <span class="emphasis"><em>i</em></span> and the last <span class="emphasis"><em>j</em></span> elements:</p><pre class="programlisting">L = ['C', 'l', 'o', 'u', 'd', 's']&#13;
L[1:5] # remove one element and take four from there:&#13;
# returns ['l', 'o', 'u', 'd']</pre><p>One may omit the first or last bound of the slicing:</p><pre class="programlisting">L = ['C', 'l', 'o', 'u','d', 's']&#13;
L[1:] # ['l', 'o', 'u', 'd','s']&#13;
L[:5] # ['C', 'l', 'o','u','d']&#13;
L[:] # the entire list</pre><p>Python allows the use of negative indexes for counting from the right. In particular, the element <code class="literal">L[-1]</code> is the last element in the list <code class="literal">L</code>.</p><p>Some list indexing descriptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">L[i:]</code> amounts to taking all elements except the <span class="emphasis"><em>i</em></span> first ones</li><li class="listitem" style="list-style-type: disc"><code class="literal">L[:i]</code> amounts to taking the first <span class="emphasis"><em>i</em></span> elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">L[-i:]</code> amounts to taking the last <span class="emphasis"><em>i</em></span> elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">L[:-i]</code> amounts to taking all elements except the <span class="emphasis"><em>i</em></span> last ones</li></ul></div><p>Here is an example:</p><pre class="programlisting">L = ['C', 'l', 'o', 'u', 'd', 's']&#13;
L[-2:] # ['d', 's']&#13;
L[:-2] # ['C', 'l', 'o','u']</pre><p>Omitting one index in the range corresponds to half-open intervals in ℝ. The half-open interval (∞, <span class="emphasis"><em>a</em></span>) means, take all numbers strictly lower than <span class="emphasis"><em>a</em></span>; this is similar to the syntax <code class="literal">L[:j]</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note9"/>Note</h3><p><span class="strong"><strong>Out of-bound slices</strong></span></p><p>Notice that you never get index errors with out-of-bound slices. Possibly, you may obtain empty lists.</p></div></div><p>Here is an example:</p><pre class="programlisting">L = list(range(4)) # [0, 1, 2, 3]&#13;
L[4] # IndexError: list index out of range&#13;
L[1:100] # same as L[1:]&#13;
L[-100:-1] # same as L[:-1]&#13;
L[-100:100] # same as L[:]&#13;
L[5:0] # empty list []&#13;
L[-2:2] # empty list []</pre><p>Be careful when using variables in indexing that may become negative, since it changes the slice completely. This might lead to unexpected results:</p><pre class="programlisting">a = [1,2,3]&#13;
 for iteration in range(4): &#13;
     print(sum(a[0:iteration-1]))</pre><p>The result is <code class="literal">3</code>, <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">3</code> while one expects <code class="literal">0</code>, <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">3</code>.</p></div><div class="section" title="Strides"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Strides</h2></div></div></div><p>When computing slices, one may also specify a stride, which is the length of the step from one index to the other. The default stride is one. Here is an example:</p><pre class="programlisting">L = list(range(100))&#13;
L[:10:2] # [0, 2, 4, 6, 8]&#13;
L[::20] # [0, 20, 40, 60, 80]&#13;
L[10:20:3] # [10, 13, 16, 19]</pre><p>Note that the stride may also be negative:</p><pre class="programlisting">L[20:10:-3] # [20, 17, 14, 11]</pre><p>It is also possible to create a new list that is reversed, using a negative stride (find about reverse method in section <span class="emphasis"><em>In-place operations</em></span>):</p><pre class="programlisting">L = [1, 2, 3]&#13;
R = L[::-1] # L is not modified&#13;
R # [3, 2, 1]</pre></div><div class="section" title="Altering lists"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Altering lists</h2></div></div></div><p>Typical operations on lists are insertion and deletion of elements and list concatenation. With the slicing notation, list insertion and deletion become obvious; deletion is just replacing a part of a list by an empty list <code class="literal">[]</code>:</p><pre class="programlisting">L = ['a', 1, 2, 3, 4]&#13;
L[2:3] = [] # ['a', 1, 3, 4]&#13;
L[3:] = [] # ['a', 1, 3]</pre><p>Insertion means replacing an empty slice with the list to be inserted:</p><pre class="programlisting">L[1:1] = [1000, 2000] # ['a', 1000, 2000, 1, 3]</pre><p>Two lists are concatenated by the plus operator <code class="literal">+</code> :</p><pre class="programlisting">L = [1, -17]&#13;
M = [-23.5, 18.3, 5.0]&#13;
L + M # gives [1, -17, 23.5, 18.3, 5.0]</pre><p>Concatenating a list <code class="literal">n</code> times with itself motivates the use of the multiplication operator  <code class="literal">*</code>:</p><pre class="programlisting">n = 3&#13;
n * [1.,17,3] # gives [1., 17, 3, 1., 17, 3, 1., 17, 3]&#13;
[0] * 5 # gives [0,0,0,0,0]</pre><p>There is no arithmetic operations on list, such as elementwise summation or division. For such operations we use arrays (refer to section <span class="emphasis"><em>Array</em></span>).</p></div><div class="section" title="Belonging to a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Belonging to a list</h2></div></div></div><p>One may use the keywords <code class="literal">in</code> and <code class="literal">not in</code> to determine whether an element belongs to a list or not which is similar to <span class="inlinemediaobject"><img src="graphics/in.jpg" alt="Belonging to a list"/></span> and <span class="inlinemediaobject"><img src="graphics/notin.jpg" alt="Belonging to a list"/></span> in mathematics:</p><pre class="programlisting">L = ['a', 1, 'b', 2]&#13;
'a' in L # True&#13;
3 in L # False&#13;
4 not in L # True</pre></div><div class="section" title="List methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>List methods</h2></div></div></div><p>Some useful methods of the <code class="literal">list</code> type are collected in the following T<span class="emphasis"><em>able 3.1</em></span>:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p>
<span class="strong"><strong>Command</strong></span>
</p>
</td><td>
<p>
<span class="strong"><strong>Action</strong></span>
</p>
</td></tr><tr><td>
<p>
<code class="literal">list.append(x)</code>
</p>
</td><td>
<p>Add <code class="literal">x</code> to the end of the list.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.expand(L)</code>
</p>
</td><td>
<p>Expand the list by the elements of the list <code class="literal">L</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.insert(i,x)</code>
</p>
</td><td>
<p>Insert <code class="literal">x</code> at position <code class="literal">i</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.remove(x)</code>
</p>
</td><td>
<p>Remove the first item from the list whose value is <code class="literal">x</code>.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.count(x)</code>
</p>
</td><td>
<p>The number of times <code class="literal">x</code> appears in the list.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.sort()</code>
</p>
</td><td>
<p>Sort the items of the list, in place.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.reverse()</code>
</p>
</td><td>
<p>Reverse the elements of the list, in place.</p>
</td></tr><tr><td>
<p>
<code class="literal">list.pop()</code>
</p>
</td><td>
<p>Remove the last element of the list, in place.</p>
</td></tr></tbody></table></div><p>Table 3.1: Methods of the datatype list</p><p>There are two ways list methods can act:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They can directly alter the list, that is, in-place operations.</li><li class="listitem" style="list-style-type: disc">They produce a new object.</li></ul></div></div><div class="section" title="In–place operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>In–place operations</h2></div></div></div><p>All methods that result in a list are in-place operating methods, for example, <code class="literal">reverse</code>:</p><pre class="programlisting">L = [1, 2, 3]&#13;
L.reverse() # the list&#13;
L is now reversed&#13;
L # [3, 2, 1]</pre><p>Be aware of in-place operations. One might be tempted to write:</p><pre class="programlisting">L=[3, 4, 4, 5]&#13;
newL = L.sort()</pre><p>This is correct Python. But it results in a possibly unintended alternation of <code class="literal">L</code> in a variable <code class="literal">newL</code> having the value <code class="literal">None</code>. The reason is that <code class="literal">sort</code> operates in-place.</p><p>Here we demonstrate in-place operating methods:</p><pre class="programlisting">L = [0, 1, 2, 3, 4]&#13;
L.append(5) # [0, 1, 2, 3, 4, 5]&#13;
L.reverse() # [5, 4, 3, 2, 1, 0]&#13;
L.sort() # [0, 1, 2, 3, 4, 5]&#13;
L.remove(0) # [1, 2, 3, 4, 5]&#13;
L.pop() # [1, 2, 3, 4]&#13;
L.pop() # [1, 2, 3]&#13;
L.extend(['a','b','c']) # [1, 2, 3, 'a', 'b', 'c']</pre><p>
<code class="literal">L</code> is altered. The <code class="literal">count</code> method is an example of a method that generates a new object:</p><pre class="programlisting">L.count(2) # returns 1</pre></div><div class="section" title="Merging lists – zip"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Merging lists – zip</h2></div></div></div><p>A particularly useful function for lists is <code class="literal">zip</code>. It can be used to merge two given lists into a new list by pairing the elements of the original lists. The result is a list of tuples (refer section <span class="emphasis"><em>Tuples</em></span> for more information):</p><pre class="programlisting">ind = [0,1,2,3,4]&#13;
color = ["red", "green", "blue", "alpha"]&#13;
list(zip(color,ind)) # gives [('red', 0), ('green', 1), &#13;
                                          ('blue', 2), ('alpha', 3)]</pre><p>This example also demonstrates what happens if the lists have different lengths. The length of the zipped list is the shorter of the two input lists.
<code class="literal">zip</code> creates a special iterable object that can be turned into a list by applying the <code class="literal">list</code> function, as in the preceding example. Refer to section <span class="emphasis"><em>Iterators </em></span>in <a class="link" href="ch09.html" title="Chapter 9. Iterating">Chapter 9</a>, <span class="emphasis"><em>Iterating</em></span>, for more details on iterable objects.</p></div><div class="section" title="List comprehension"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>List comprehension</h2></div></div></div><p>A convenient way to build up lists is by using the list comprehension construct, possibly with a condition inside. The syntax of a list comprehension is:</p><pre class="programlisting">[&lt;expr&gt; for &lt;variable&gt; in &lt;list&gt;]</pre><p>or more generally:</p><pre class="programlisting">[&lt;expr&gt; for &lt;variable&gt; in &lt;list&gt; if &lt;condition&gt;]</pre><p>Here is an example:</p><pre class="programlisting">L = [2, 3, 10, 1, 5]&#13;
L2 = [x*2 for x in L] # [4, 6, 20, 2, 10]&#13;
L3 = [x*2 for x in L if 4 &lt; x &lt;= 10] # [20, 10]</pre><p>It is possible to have several <code class="literal">for</code> loops inside a list comprehension:</p><pre class="programlisting">M = [[1,2,3],[4,5,6]]&#13;
flat = [M[i][j] for i in range(2) for j in range(3)] &#13;
# returns [1, 2, 3, 4, 5, 6]</pre><p>This is of particular interest when dealing with arrays.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p><span class="strong"><strong>Set notation</strong></span></p><p>List comprehension is closely related to the mathematical notation for sets.
Compare:  <span class="inlinemediaobject"><img src="graphics/set_notation.jpg" alt="List comprehension"/></span>  and <code class="literal">L2 = [2*x for x in L]</code>.</p><p>One big difference though, is that lists are ordered while sets aren't (Refer, section <span class="emphasis"><em>Sets </em></span>for more information).</p></div></div></div></div></div>
<div class="section" title="Arrays"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Arrays</h1></div></div></div><p>The NumPy package offers arrays, which are container structures for manipulating vectors, matrices, or even higher order tensors in mathematics. In this section, we point out the similarities between arrays and lists. But arrays deserve a broader presentation, which will be given in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra –  Arrays</em></span>, and <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <span class="emphasis"><em>Advanced Array Concepts</em></span>.</p><p>Arrays are constructed from lists by the function <code class="literal">array</code> :</p><pre class="programlisting">v = array([1.,2.,3.])&#13;
A = array([[1.,2.,3.],[4.,5.,6.]])</pre><p>To access an element of a vector, we need one index, while an element of a matrix is addressed by two indexes:</p><pre class="programlisting">v[2]     # returns 3.0&#13;
A[1,2]   # returns 6.0</pre><p>At first glance, arrays are similar to lists, but be aware that they are different in a fundamental way, which can be explained by the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Access to array data corresponds to that of lists, using square brackets and slices. They may also be used to alter the array:
<pre class="programlisting">        M = array([[1.,2.],[3.,4.]])&#13;
        v = array([1., 2., 3.])&#13;
        v[0] # 1&#13;
        v[:2] # array([1.,2.])&#13;
        M[0,1] # 2&#13;
        v[:2] = [10, 20] # v is now array([10., 20., 3.])</pre></li><li class="listitem" style="list-style-type: disc">The number of elements in a vector, or the number of rows of a matrix, is obtained by the function <code class="literal">len</code> :
<pre class="programlisting">        len(v) # 3</pre></li><li class="listitem" style="list-style-type: disc">Arrays store only elements of the same numeric type (usually <code class="literal">float</code> or <code class="literal">complex</code> but also <code class="literal">int</code>). Refer to section <span class="emphasis"><em>Array properties</em></span> in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Liner Algebra – Arrays</em></span>, for more information.</li><li class="listitem" style="list-style-type: disc">The operations <code class="literal">+</code>, <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">-</code> are all elementwise. The <code class="literal">dot</code> function and, in Python versions ≥ 3.5, the infix operator <code class="literal">@</code> are used for the scalar product and the corresponding matrix operations.</li><li class="listitem" style="list-style-type: disc">Unlike lists, there is no <code class="literal">append</code> method for arrays. Nevertheless, there are special methods to construct arrays by stacking smaller size arrays (Refer to section <span class="emphasis"><em>Stacking</em></span> in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra - Arrays</em></span>, for more information.). A related point is that arrays are not elastic as lists; one cannot use slices to change their length.</li><li class="listitem" style="list-style-type: disc">Vector slices are views; that is, they may be used to modify the original array. Refer to section <span class="emphasis"><em>Array views and copies</em></span> in <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <span class="emphasis"><em>Advanced Array Concepts</em></span>, for more information.</li></ul></div></div>
<div class="section" title="Tuples"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Tuples</h1></div></div></div><p>A tuple is an immutable list. Immutable means that it cannot be modified. A tuple is just a comma-separated sequence of objects (a list without brackets). To increase readability, one often encloses a tuple in a pair of parentheses:</p><pre class="programlisting">my_tuple = 1, 2, 3     # our first tuple&#13;
my_tuple = (1, 2, 3)   # the same&#13;
my_tuple = 1, 2, 3,    # again the same&#13;
len(my_tuple) # 3, same as for lists&#13;
my_tuple[0] = 'a'   # error! tuples are immutable</pre><p>The comma indicates that the object is a tuple:</p><pre class="programlisting">singleton = 1,   # note the comma&#13;
len(singleton)   # 1</pre><p>Tuples are useful when a group of values goes together; for example, they are used to return multiple values from functions (refer to section <span class="emphasis"><em>Returns Values</em></span> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>. One may assign several variables at once by unpacking a list or tuple:</p><pre class="programlisting">a, b = 0, 1 # a gets 0 and b gets 1&#13;
a, b = [0, 1] # exactly the same effect&#13;
(a, b) = 0, 1 # same&#13;
[a,b] = [0,1] # same thing</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p><span class="strong"><strong>The swapping trick</strong></span></p><p>Use packing and unpacking to swap the contents of two variables: <code class="literal">a, b = b, a</code></p></div></div><p>To summarize:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tuples are nothing other than immutable lists with a notation without brackets.</li><li class="listitem" style="list-style-type: disc">In most cases, lists may be used instead of tuples.</li><li class="listitem" style="list-style-type: disc">The notation without parentheses is convenient but dangerous. You should use parentheses when you are not sure:</li></ul></div><pre class="programlisting">      a, b = b, a # the swap trick; equivalent to:&#13;
      (a, b) = (b, a)&#13;
      # but&#13;
      1, 2 == 3, 4 # returns (1, False, 4) &#13;
      (1, 2) == (3, 4) # returns False</pre></div>
<div class="section" title="Dictionaries"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Dictionaries</h1></div></div></div><p>Lists, tuples, and arrays are ordered sets of objects. The individual objects are inserted, accessed, and processed according to their place in the list. On the other hand, dictionaries are unordered sets of pairs. One accesses dictionary data by keys.</p><div class="section" title="Creating and altering dictionaries"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Creating and altering dictionaries</h2></div></div></div><p>For example, we may create a dictionary containing the data of a rigid body in mechanics, as follows:</p><pre class="programlisting">truck_wheel = {'name':'wheel','mass':5.7,&#13;
               'Ix':20.0,'Iy':1.,'Iz':17.,&#13;
               'center of mass':[0.,0.,0.]}</pre><p>A key/data pair is indicated by a colon, <code class="literal">:</code>. These pairs are comma separated and listed inside a pair of curly brackets, <code class="literal">{}</code>.</p><p>Individual elements are accessed by their keys:</p><pre class="programlisting">truck_wheel['name']   # returns 'wheel'&#13;
truck_wheel['mass']   # returns 5.7</pre><p>New objects are added to the dictionary by creating a new key:</p><pre class="programlisting">truck_wheel['Ixy'] = 0.0</pre><p>Dictionaries are also used to provide parameters to a function (refer to section <span class="emphasis"><em>Parameters and arguments </em></span>in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <span class="emphasis"><em>Functions</em></span>, for further information). Keys in a dictionary can be, among others, strings, functions, tuples with immutable elements, and classes. Keys cannot be lists or arrays. The command <code class="literal">dict</code>  generates a dictionary from a list with key/value pairs:</p><pre class="programlisting">truck_wheel = dict([('name','wheel'),('mass',5.7),('Ix',20.0), &#13;
                    ('Iy',1.), ('Iz',17.), &#13;
                    ('center of mass',[0.,0.,0.])])</pre><p>The <code class="literal">zip</code> function may come in handy in this context (refer to section <span class="emphasis"><em>Merging List</em></span>).</p></div><div class="section" title="Looping over dictionaries"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Looping over dictionaries</h2></div></div></div><p>There are mainly three ways to loop over dictionaries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By keys:</li></ul></div><pre class="programlisting">        for key in truck_wheel.keys():&#13;
            print(key) # prints (in any order) 'Ix', 'Iy', 'name',...</pre><p>or equivalently:</p><pre class="programlisting">        for key in truck_wheel:&#13;
            print(key) # prints (in any order) 'Ix', 'Iy', 'name',...</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By value:</li></ul></div><pre class="programlisting">        for value in truck_wheel.value():&#13;
            print(value) &#13;
               # prints (in any order) 1.0, 20.0, 17.0, 'wheel', ...</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By item, that is, key/value pairs:</li></ul></div><pre class="programlisting">        for item in truck_wheel.items():&#13;
            print(item) &#13;
               # prints (in any order) ('Iy', 1.0), ('Ix, 20.0),...</pre><p>Please, refer to section <span class="emphasis"><em>Shelves</em></span> in <a class="link" href="ch12.html" title="Chapter 12. Input and Output">Chapter 12</a>, <span class="emphasis"><em>Input and Output</em></span>, for a special dictionary object for file access.</p></div></div>
<div class="section" title="Sets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Sets</h1></div></div></div><p>Sets are containers that share properties and operations with sets in mathematics. A mathematical set is a collection of distinct objects. Here are some mathematical set expressions:</p><p>
</p><div class="mediaobject"><img src="graphics/set_operations.jpg" alt="Sets"/></div><p>
</p><p>And their Python counterparts:</p><pre class="programlisting">A = {1,2,3,4}&#13;
B = {5}&#13;
C = A.union(B)   # returns set([1,2,3,4,5])&#13;
D = A.intersection(C)   # returns set([1,2,3,4])&#13;
E = C.difference(A)   # returns set([5])&#13;
5 in C   # returns True</pre><p>Sets contain an element only once, corresponding to the aforementioned definition:</p><pre class="programlisting">A = {1,2,3,3,3}&#13;
B = {1,2,3}&#13;
A == B # returns True</pre><p>And a set is unordered; that is, the order of the elements in the set is not defined:</p><pre class="programlisting">A = {1,2,3}&#13;
B = {1,3,2}&#13;
A == B # returns True</pre><p>Sets in Python can contain all kinds of hashable objects, that is, numeric objects, strings, and Booleans.</p><p>There are <code class="literal">union</code> and <code class="literal">intersection</code> methods:</p><pre class="programlisting">A={1,2,3,4}&#13;
A.union({5})&#13;
A.intersection({2,4,6}) # returns set([2, 4])</pre><p>Also, sets can be compared using the methods <code class="literal">issubset</code> and <code class="literal">issuperset</code> :</p><pre class="programlisting">{2,4}.issubset({1,2,3,4,5}) # returns True&#13;
{1,2,3,4,5}.issuperset({2,4}) # returns True</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p><span class="strong"><strong>Empty set</strong></span></p><p>An empty set is defined in Python by <code class="literal">empty_set=set([])</code> and not by <code class="literal">{}</code>, which would define an empty dictionary!</p></div></div></div>
<div class="section" title="Container conversions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Container conversions</h1></div></div></div><p>We summarize in the following <span class="emphasis"><em>Table 3.2</em></span> the most important properties of the container types presented so far. Arrays will be treated in <a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a>, <span class="emphasis"><em>Linear Algebra – Arrays</em></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/Table-3.2.jpg" alt="Container conversions"/></div><p>
</p><p>Table 3.2 : Container Types</p><p>As you can see in the previous table, there is a difference in accessing container elements, and sets and dictionaries are not ordered.</p><p>Due to the different properties of the various container types, we frequently convert one type to another:</p><p>
</p><div class="mediaobject"><img src="graphics/Table-3.4.jpg" alt="Container conversions"/></div><p>
</p></div>
<div class="section" title="Type checking"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Type checking</h1></div></div></div><p>The direct way to see the type of a variable is to use the <code class="literal">type</code> command:</p><pre class="programlisting">label = 'local error'&#13;
type(label) # returns str&#13;
x = [1, 2] # list&#13;
type(x) # returns list</pre><p>However, if you want to test for a variable to be of a certain type, you should use <code class="literal">isinstance</code> (instead of comparing the types with <code class="literal">type</code>):</p><pre class="programlisting">isinstance(x, list) # True</pre><p>The reason for using <code class="literal">isinstance</code> becomes apparent after having read <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes,</em></span> and in particular the concept of subclassing and inheritance in section <span class="emphasis"><em>Subclassing and Inheritance</em></span> in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>. In short, often different types share some common properties with some basic type. The classical example is the type <code class="literal">bool</code>, which is derived by subclassing from the more general type <code class="literal">int</code>. In this situation, we see how the command <code class="literal">isinstance</code>  can be used in a more general way:</p><pre class="programlisting">test = True&#13;
isinstance(test, bool) # True&#13;
isinstance(test, int) # True&#13;
type(test) == int # False&#13;
type(test) == bool # True</pre><p>So, in order to make sure that the variable <code class="literal">test</code> is as good as an integer (the particular type may be irrelevant), you should check that it is an instance of <code class="literal">integer</code>:</p><pre class="programlisting">if isinstance(test, int):&#13;
    print("The variable is an integer")</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p><span class="strong"><strong>Type checking</strong></span></p><p>Python is not a typed language. What that means is that objects are identified by what they can do rather than what they are. For instance, if you have a string manipulating function that acts on an object by using the <code class="literal">len</code> method, then your function will probably be useful for any objects implementing that method.</p></div></div><p>So far, we have come across different types: <code class="literal">float</code>, <code class="literal">int</code>, <code class="literal">bool</code>, <code class="literal">complex</code>, <code class="literal">list</code>, <code class="literal">tuple</code>, <code class="literal">module</code>, <code class="literal">function</code>, <code class="literal">str</code>, <code class="literal">dict</code>, and <code class="literal">array</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, you learned to work with container types, mainly lists. It is important to know how to fill these containers and how to access their content. We saw that there is access by position or by keyword.</p><p>We will meet the important concept of slicing again in the next chapter on arrays. These are containers specially designed for mathematical operations.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Exercises</h1></div></div></div><p>
<span class="strong"><strong>Ex. 1 </strong></span>→ Execute the following statements:</p><pre class="programlisting">    L = [1, 2]&#13;
    L3 = 3*L</pre><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">What is the content of <code class="literal">L3</code>?</li><li class="listitem">Try to predict the outcome of the following commands:
<pre class="programlisting">      L3[0]&#13;
      L3[-1]&#13;
      L3[10]</pre></li><li class="listitem">What does the following command do?
<pre class="programlisting">       L4 = [k**2 for k in L3]</pre></li><li class="listitem">Concatenate <code class="literal">L3</code> and <code class="literal">L4</code> to a new list <code class="literal">L5</code>.</li></ol></div><p>
<span class="strong"><strong>Ex. 2</strong></span> → Use the <code class="literal">range</code> command and a list comprehension to generate a list with 100 equidistantly spaced values between 0 and 1.</p><p>
<span class="strong"><strong>Ex. 3</strong></span> → Assume that the following signal is stored in a list:</p><pre class="programlisting">    L = [0,1,2,1,0,-1,-2,-1,0]</pre><p>What is the outcome of:</p><pre class="programlisting">L[0]&#13;
L[-1]&#13;
L[:-1]&#13;
L + L[1:-1] + L&#13;
L[2:2] = [-3]&#13;
L[3:4] = []&#13;
L[2:5] = [-5]</pre><p>Do this exercise by inspection only, that is, without using your Python Shell.</p><p>
<span class="strong"><strong>Ex. 4</strong></span> → Consider the Python statements:</p><pre class="programlisting">L = [n-m/2 for n in range(m)]&#13;
ans = 1 + L[0] + L[-1]</pre><p>and assume that the variable <code class="literal">m</code> has been previously assigned an integer value. What is the value of <code class="literal">ans</code>? Answer this question without executing the statements in Python.</p><p>
<span class="strong"><strong>Ex. 5</strong></span> → Consider the recursion formula:</p><p>
</p><div class="mediaobject"><img src="graphics/main_F.jpg" alt="Exercises"/></div><p>
</p><p>with <span class="emphasis"><em>n </em></span>= 0,..., 1000, <span class="emphasis"><em>h</em></span>= 1/1000, and <span class="emphasis"><em>a</em></span> = -0.5.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a list <code class="literal">u</code>. Store in its first three elements <span class="emphasis"><em>e<sup>0</sup></em></span>, <span class="emphasis"><em>e<sup>ha</sup></em></span>, and <span class="emphasis"><em>e<sup>2ha</sup></em></span>. These represent the starting values <span class="emphasis"><em>u</em></span><sub>0</sub>, <span class="emphasis"><em>u</em></span><sub>1</sub>, and <span class="emphasis"><em>u</em></span><sub>2</sub> in the given formula. Build up the complete list from the recursion formula.</li><li class="listitem">Construct a second list, <code class="literal">td</code>, in which you store the values <span class="emphasis"><em>nh</em></span>, with <span class="emphasis"><em>n</em></span> = 0, ..., 1000. Plot <code class="literal">td</code> versus <code class="literal">u</code> (refer section <span class="emphasis"><em>Basic plotting</em></span> in <a class="link" href="ch06.html" title="Chapter 6. Plotting">Chapter 6</a>, <span class="emphasis"><em>Plotting</em></span>, for more information). Make a second plot in which you plot the difference, that is, <span class="emphasis"><em>|e<sup>at<sub>n</sub></sup> - u<sub>n</sub>|</em></span>, where <span class="emphasis"><em>t<sub>n</sub></em></span> represents the values inside the vector <code class="literal">td</code> . Set axis labels and a title.</li></ol></div><p>The recursion is a multistep formula to solve the differential equation <span class="emphasis"><em>u' = au</em></span> with the initial value <span class="emphasis"><em>u(0) = u<sub>0</sub> = 1</em></span>. <span class="emphasis"><em>u<sub>n</sub></em></span> approximates <span class="emphasis"><em>u(nh) = e<sup>anh</sup>u</em></span><sub>0</sub>.</p><p>
<span class="strong"><strong>Ex. 6</strong></span> → Let <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> be sets. The set (A \ B) ∪ (B \ A) is called the symmetric difference of the two sets. Write a function that performs this operation. Compare your results to the result of the command:</p><pre class="programlisting">A.symmetric_difference(B).</pre><p>
<span class="strong"><strong>Ex. 7</strong></span> → Verify in Python the statement that the empty set is a subset of any set.</p><p>
<span class="strong"><strong>Ex. 8</strong></span> → Study other operations on sets. You find a complete list of those by using the command completion feature of <code class="literal">IPython</code>. In particular, study the <code class="literal">update</code> and <code class="literal">intersection_update</code> methods. What is the difference between <code class="literal">intersection</code> and <code class="literal">intersection_update</code>?</p></div></body></html>