- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Programming with Qiskit
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qiskit进行编程
- en: '**Qiskit** has various libraries that link between the core hardware of a quantum
    system and the tools necessary to create quantum circuits, both transcend upward
    through the code stack. It is, therefore, the foundation used to create quantum
    circuits, as well as generating and scheduling pulses from the circuits onto the
    hardware devices. Other features, such as optimizers and transpilers, are used
    to ensure the circuits are optimal to reduce decoherence and improve performance.
    In this chapter, we will explore all the key features available in Qiskit to help
    you create your own circuits, optimizers, and pulse schedules.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qiskit** 拥有多种库，这些库将量子系统的核心硬件与创建量子电路所需的工具连接起来，这些工具通过代码堆栈向上扩展。因此，它是创建量子电路以及从电路到硬件设备生成和调度脉冲的基础。其他功能，如优化器和转换器，用于确保电路优化以减少退相干并提高性能。在本章中，我们将探讨Qiskit中所有关键功能，以帮助您创建自己的电路、优化器和脉冲时序。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding quantum circuits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解量子电路
- en: Generating pulse schedules on hardware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在硬件上生成脉冲时序
- en: Understanding the Job component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解作业组件
- en: Qiskit has so many features and enhancements that it would take an entire book
    to write about them all. To cover as many of them as possible, we will create
    a quantum circuit and walk you through the various features. After reading this
    chapter, you will be able to understand how to create quantum circuits from basic
    to customized circuits with user-defined labels to help contextualize your circuit.
    You’ll also get an understanding of the Job component, which is used to run your
    circuit on a quantum system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit具有许多功能和增强功能，要描述它们需要整本书。为了涵盖尽可能多的功能，我们将创建一个量子电路，并带您了解各种功能。阅读本章后，您将能够理解如何从基本电路到自定义电路，包括用户定义的标签以帮助您理解电路。您还将了解作业组件，该组件用于在量子系统上运行您的电路。
- en: We’ll even delve into the hardware to schedule a pulse operation on a qubit
    to better understand how the circuit is translated from digital to analog signals
    to perform an operation on a qubit(s), followed by reading the information from
    the qubit and converting the signal back from analog to digital.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至将深入硬件以在量子比特上调度脉冲操作，以便更好地理解电路是如何从数字信号转换为模拟信号以在量子比特上执行操作，然后从量子比特读取信息并将信号从模拟转换为数字。
- en: Sound exciting? Great! Let’s get to it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很激动人心？太好了！让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, it is expected that you are familiar with the basics of quantum
    circuits described in previous chapters, such as creating and executing quantum
    circuits, visualizing circuit diagrams, and knowledge of qubit logic gates.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设您熟悉前面章节中描述的量子电路基础知识，例如创建和执行量子电路、可视化电路图以及了解量子比特逻辑门。
- en: 'Here is the source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的源代码如下：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition)。
- en: Customizing and optimizing quantum circuits
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制和优化量子电路
- en: In previous chapters, you had some exposure to quantum circuit operations to
    understand some of the basic quantum components. These basic operations included
    creating a quantum circuit, applying quantum gates to the circuit, and executing
    the circuit on a simulator.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经接触了一些量子电路操作，以了解一些基本量子组件。这些基本操作包括创建量子电路、将量子门应用于电路以及在模拟器上执行电路。
- en: We will now take a deeper look into quantum circuits to better understand what
    properties and functionalities are available to us to not just execute these circuits
    on a real device but to do so as optimally as possible. In this section, we will
    learn how to extract circuit properties, such as circuit depth, width, and size,
    and obtain the number of actual operators. Let’s first start by reviewing the
    various forms of creating a quantum circuit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更深入地研究量子电路，以更好地了解我们可用的属性和功能，不仅要在实际设备上执行这些电路，而且要尽可能优化地执行。在本节中，我们将学习如何提取电路属性，例如电路深度、宽度和大小，以及获取实际操作器的数量。让我们首先回顾创建量子电路的各种形式。
- en: Components of a quantum circuit
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量子电路的组件
- en: 'Qiskit provides various ways to create a quantum circuit, each depending on
    how much information you need throughout your circuit. Up to this point, we have
    been creating circuits using a single constructor that automatically creates the
    circuit registers needed. In this form, the arguments indicate the number of qubits
    and bits of both the quantum and classical registers, respectively:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit提供了多种创建量子电路的方法，每种方法都取决于你在电路中需要多少信息。到目前为止，我们一直在使用单个构造函数创建电路，该构造函数会自动创建所需的电路寄存器。在这种形式中，参数表示量子寄存器和经典寄存器的量子比特和比特数量，分别：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this section, we will describe other ways to create a circuit and discuss
    the advantage of using one form or the other.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述创建电路的其他方法，并讨论使用某种形式或另一种形式的优点。
- en: 'Another way to construct a `QuantumCircuit` class is to create the quantum
    and classical registers independently of the quantum circuit constructor. Here,
    we will first create the quantum and classical registers, each with two qubits
    and two bits, respectively, and then draw the circuit. The constructor allows
    us to customize the label of our registers, which we were not able to do in the
    previous form:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建量子电路类（`QuantumCircuit`）的另一种方法是独立于量子电路构造函数创建量子寄存器和经典寄存器。在这里，我们将首先创建量子寄存器和经典寄存器，每个寄存器分别包含两个量子比特和两个比特，然后绘制电路。构造函数允许我们自定义寄存器的标签，这在之前的形式中是无法做到的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From the preceding code, note that the second argument: that is, the `name`
    attribute: of the register constructors allows us to add a label to each register,
    as in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，注意第二个参数：即寄存器构造函数的`name`属性：允许我们为每个寄存器添加标签，如下面的截图所示：
- en: '![Diagram  Description automatically generated with medium confidence](img/B18420_07_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成，置信度中等](img/B18420_07_01.png)'
- en: 'Figure 7.1: Customized quantum and classical register labels'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：自定义量子寄存器和经典寄存器标签
- en: Customizing the labels of our registers simplifies reading our circuits, particularly
    as the circuits become more complex when having multiple registers performing
    different processes. You may want to have one register created with a fixed number
    of qubits and another dynamic register where defining the number of qubits would
    vary based on some preprocessed step. You’ll see the value of this when we create
    composites later in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义寄存器的标签简化了电路的阅读，尤其是在电路变得复杂时，多个寄存器执行不同的过程。你可能希望有一个固定数量的量子比特的寄存器，另一个动态寄存器，其中定义量子比特的数量将基于某些预处理步骤。你将在本章后面创建复合体时看到这一点的重要性。
- en: 'Of course, you can also combine creating the registers and the circuit constructor
    all in one line if needed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，你也可以在一行中将创建寄存器和电路构造函数合并：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s assume now that you have two quantum circuits and you want to concatenate
    them together. The following example will illustrate how to concatenate two circuits
    into one without having to explicitly recreate one based on the two existing quantum
    circuits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在你有两个量子电路，并且你想将它们连接在一起。以下示例将说明如何将两个电路连接成一个，而无需基于两个现有的量子电路显式地重新创建一个：
- en: 'In the following code, we will create the first circuit and include labels
    on both the quantum and classical registers so that we can monitor that they are,
    in fact, combined:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将创建第一个电路，并在量子寄存器和经典寄存器上包含标签，以便我们可以监控它们实际上是否已合并：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows what should be displayed after running the previous
    code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行上一段代码后应显示的内容：
- en: '![Calendar  Description automatically generated with low confidence](img/B18420_07_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![日历 描述自动生成，置信度低](img/B18420_07_02.png)'
- en: 'Figure 7.2: The first of the two quantum circuits we will join'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：我们将加入的两个量子电路中的第一个
- en: 'Next, we will create a second circuit, which is very similar to the first one,
    only we will update the labels to identify it as the second:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建第二个电路，它与第一个非常相似，只是我们将更新标签以识别它是第二个：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The results of the code should be no surprise: that it is the same as the first
    one only with the labels updated as expected:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的结果应该不会令人惊讶：它与第一个相同，只是标签按预期更新：
- en: '![Figure 8.4 – The second of the two quantum circuits we will join ](img/B18420_07_03.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 我们将加入的两个量子电路中的第二个](img/B18420_07_03.png)'
- en: 'Figure 7.3: The second of the two quantum circuits we will join'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：我们将加入的两个量子电路中的第二个
- en: 'Now, let’s finish up by combining one circuit with the other, which is to say
    we will widen the circuit from 2 to 4 qubits. To do this, we will use the `add_register`
    function, which combines the quantum and classical registers into a single circuit.
    Here, we will combine circuits `qc2` and `qc1` into a new circuit titled `qc_combined`,
    and then draw the results:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过将一个电路与另一个电路结合来完成，也就是说，我们将电路宽度从 2 扩展到 4 个量子比特。为此，我们将使用 `add_register`
    函数，该函数将量子寄存器和经典寄存器组合成一个单独的电路。在这里，我们将电路 `qc2` 和 `qc1` 组合成一个新的电路，标题为 `qc_combined`，然后绘制结果：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the following screenshot, the results are now a combination
    of the two previous quantum circuits into a new circuit, by combining the registers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，结果现在是两个先前量子电路通过组合寄存器合并成一个新的电路：
- en: '![Figure 8.5 – Concatenation of two quantum circuits ](img/B18420_07_04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 两个量子电路的连接](img/B18420_07_04.png)'
- en: 'Figure 7.4: Concatenation of two quantum circuits'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：两个量子电路的连接
- en: We originally created two individual quantum circuits, each with two quantum
    registers and two classical registers. We then concatenated them to create a quantum
    circuit with four quantum and classical circuits. The order of the quantum circuits
    is based on the order in which they were concatenated. As an extra exercise, repeat
    the previous concatenation code and switch the order to confirm or create more
    quantum circuits and add more circuits together.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初创建了两个单独的量子电路，每个电路有两个量子寄存器和两个经典寄存器。然后我们将它们连接起来，创建了一个包含四个量子寄存器和四个经典寄存器的量子电路。量子电路的顺序是基于它们连接的顺序。作为额外的练习，重复之前的连接代码，并切换顺序以确认或创建更多的量子电路并将它们组合在一起。
- en: 'One last circuit creation object I would like to share is the random circuit
    generator, which, as the name suggests, will generate a random circuit for you.
    Having the ability to create a random circuit could help you to create test circuits
    or examples given a set of parameters, such as circuit width and depth. As the
    following code block indicates, the `random_circuit` object requires two parameters.
    They are the number of qubits you want the random circuit to contain and the depth
    of the circuit, respectively: where depth indicates the number of standard gates,
    selected from the Qiskit circuit extensions listed in the API documentation, to
    add randomly per qubit. You can also indicate whether you want the circuit to
    include measurement operators:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我想分享的最后一个电路创建对象是随机电路生成器，正如其名所示，它将为你生成一个随机电路。拥有创建随机电路的能力可以帮助你根据一组参数（如电路宽度和深度）创建测试电路或示例。如下面的代码块所示，`random_circuit`
    对象需要两个参数。它们是你想要随机电路包含的量子比特数量和电路的深度，分别：其中深度表示每个量子比特随机添加的标准门数量，这些门来自 Qiskit 电路扩展列表，如
    API 文档中所述。你也可以指示你是否想要电路包含测量操作符：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The results from the random circuit will vary, of course, each time you execute
    it, as it should. What will not vary are the parameter options, particularly the
    number of qubits and the depth count. In this case, your results should have a
    circuit that contains three qubits and a depth of two operators. The following
    random circuit is the result of running the preceding code. Note that the measurement
    operator is not included in the depth count:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随机电路的结果当然会因每次执行而变化，这是应该的。不会变化的是参数选项，尤其是量子比特的数量和深度计数。在这种情况下，你的结果应该包含三个量子比特和两个操作符的深度。以下随机电路是运行前面代码的结果。请注意，测量操作符不包括在深度计数中：
- en: '![Figure 8.6 – Random circuit generated with number of qubits = 3 and depth
    = 2  ](img/B18420_07_05.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 使用 3 个量子比特和深度 2 生成的随机电路](img/B18420_07_05.png)'
- en: 'Figure 7.5: Random circuit generated with number of qubits = 3 and depth =
    2'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：使用 3 个量子比特和深度 2 生成的随机电路
- en: Now that you are familiar with the various ways to generate quantum circuits,
    we will continue and see what properties we can extract from the circuits created.
    These properties could be used to analyze the generated circuit and ensure it
    is optimized by leveraging some optimization features available to us in Qiskit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了生成量子电路的各种方法，我们将继续并看看我们可以从创建的电路中提取哪些属性。这些属性可以用来分析生成的电路，并确保通过利用 Qiskit
    中可用的某些优化功能来优化它。
- en: Obtaining circuit properties and analysis
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取电路属性和分析
- en: Constructing circuits could get very complex once you start building them out,
    particularly if you create composites of gates and combine them to form larger
    gates. You’re going to want to get some information about your circuit along the
    way should you need to analyze your results.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始构建电路，构建电路可能会变得非常复杂，尤其是如果你创建门和组合它们以形成更大的门。如果你需要分析结果，你将想要在过程中获取有关你的电路的一些信息。
- en: The good thing for us is that Qiskit has taken care of some of this by making
    a lot of these properties available to us. Let’s start with some basic properties.
    Let’s say we want to know how many qubits we have in our circuit. As we learned
    in the previous section, we know that we can concatenate two or more circuits
    together. As we add more circuits together, it becomes difficult, or tedious,
    to determine the number of qubits and gates that our concatenated circuit will
    have. It’s here that the width, depth, and operator count functions come in handy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，好事是Qiskit已经为我们处理了一些这方面的工作，通过使我们能够访问许多这些属性。让我们从一些基本属性开始。假设我们想知道我们的电路中有多少量子比特。正如我们在上一节中学到的，我们知道我们可以将两个或多个电路连接在一起。当我们添加更多的电路时，确定我们连接的电路将具有多少量子比特和门变得困难或繁琐。正是在这里，宽度、深度和算子计数函数变得非常有用。
- en: 'In the following code, we will create two two-qubit random circuits, each with
    different gate counts. We will then append one circuit to another and use our
    circuit property functions to help us get the total width, depth, and operator
    count. All circuits that we append will need to have the same number of qubits
    using this method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将创建两个双量子比特随机电路，每个电路具有不同的门计数。然后我们将一个电路附加到另一个电路上，并使用我们的电路属性函数来帮助我们获取总宽度、深度和算子计数。所有附加的电路都需要使用此方法具有相同数量的量子比特：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result should be a two-qubit circuit with a random set of gate operators
    with a total depth of 6\. We know this because we created them and can see the
    values from the `random_circuit` constructor:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个具有随机门算子集的双量子比特电路，总深度为6。我们知道这一点，因为我们创建了它们，并且可以从`random_circuit`构造函数中看到这些值：
- en: '![](img/B18420_07_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_07_06.png)'
- en: 'Figure 7.6: Randomly generated two-qubit circuits with a depth of 6'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：深度为6的随机生成的双量子比特电路
- en: 'Now, let’s use our circuit property functions to get the width, depth, size,
    and operator count of our circuit. To simplify this, we will create a helper function
    that will print out the circuit properties of the quantum circuit we will pass
    in as an argument:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的电路属性函数来获取电路的宽度、深度、大小和算子计数。为了简化这一点，我们将创建一个辅助函数，该函数将打印出我们将作为参数传递的量子电路的电路属性：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can run our circuit through our helper function, which will print out
    all the properties we need:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过我们的辅助函数运行我们的电路，该函数将打印出我们需要的所有属性：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our results should have the same value for `Width` and `Depth`. However, since
    we are using random circuits, our circuit size and the number of operators will
    be different as they are based on the randomly chosen gates. However, by observing
    the circuit, you will see that the result values of `size()` and `count_ops()`
    are the same. The difference between the two is that the circuit size returns
    the total number of gates in the circuit, while the operator count lists the name
    of each gate type and the total number of each gate type in the circuit:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果应该对于`Width`和`Depth`具有相同的值。然而，由于我们正在使用随机电路，我们的电路大小和算子数量将不同，因为它们基于随机选择的门。然而，通过观察电路，你会看到`size()`和`count_ops()`的结果值是相同的。这两者之间的区别在于，电路大小返回电路中的总门数，而算子计数列出每种门类型的名称以及电路中每种门类型的总数：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s try adding some classic registers, measurements, and barriers to
    see what we get back. We can use a shortcut to include measurement operators by
    using `measure_all()`, which will append a barrier, a measurement for each qubit,
    and the classical registers to match the number of qubits in the quantum register
    of our circuit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试添加一些经典寄存器、测量和障碍，看看我们会得到什么。我们可以使用`measure_all()`快捷方式来包含测量算子，这将附加一个障碍、每个量子比特的测量以及与我们的电路量子寄存器中量子比特数量相匹配的经典寄存器：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result now includes the classical components needed to measure and read
    out our qubits. These include the two-bit classical registers labeled as `measure`,
    a barrier separating the quantum gates from the measurement operators, and the
    measurement operators, as illustrated in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的结果包括了测量和读取我们的量子比特所需的所有经典组件。这些包括标记为`measure`的两个位经典寄存器、一个将量子门与测量操作符分开的屏障以及测量操作符，如下面的屏幕截图所示：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_07.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B18420_07_07.png)'
- en: 'Figure 7.7: Random circuit with classical components added'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：添加经典组件的随机电路
- en: 'Let’s now print our circuit property functions to see an updated count:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印我们的电路属性函数，以查看更新的计数：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results show what we generally would expect. The `W``idth` count increased
    by 2, due to the addition of the two-bit classical register. The `Depth` count
    increased by 1 due to the addition of the barrier. Note that the measurement operator
    is not included in the size or operator count, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了我们一般会预期的内容。由于添加了两个位的经典寄存器，`Width`计数增加了2。由于添加了屏障，`Depth`计数增加了1。请注意，测量操作符不包括在大小或操作符计数中，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Before moving on to the next section, let’s look at an interesting caveat to
    our circuit property functions. Most gates are created from basis gates that are
    specific to the quantum computers used. For most quantum systems, there are a
    set of basis gates used to create other gates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一节之前，让我们看看我们电路属性函数的一个有趣的注意事项。大多数门是由特定于所使用量子计算机的基门创建的。对于大多数量子系统，有一组基门用于创建其他门。
- en: 'However, some gates, such as the **Toffoli** and **Swap** gates, not only require
    more than a single qubit but are also composed of several basis gates. Let’s look
    at the Toffoli gate as an example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些门，如**Toffoli**和**Swap**门，不仅需要多个量子比特，而且由多个基门组成。让我们以Toffoli门为例：
- en: 'We will create a quantum circuit with 3 qubits and add only a Toffoli gate
    to it, as shown here:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含3个量子比特的量子电路，并向其中添加一个Toffoli门，如图所示：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we see the Toffoli gate as expected, with the 0 and 1 source qubits entangled,
    with qubit 2 as the target:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到了预期的Toffoli门，0和1源量子比特纠缠，量子比特2为目标：
- en: '![Figure 8.9 – The Toffoli gate on a quantum circuit ](img/B18420_07_08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 量子电路上的Toffoli门](img/B18420_07_08.png)'
- en: 'Figure 7.8: The Toffoli gate on a quantum circuit'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：量子电路上的Toffoli门
- en: 'We print out our circuit properties of the quantum circuit with the Toffoli
    gate:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印出带有Toffoli门的量子电路的电路属性：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see, the results are not surprising in that the values are not surprising
    either: a three-qubit gate with a width of `3` and a depth of `1`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结果并不令人惊讶，因为这些值也不令人惊讶：一个宽度为`3`、深度为`1`的三量子比特门：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s print our circuit property, only this time, let’s decompose our
    quantum circuit to see the results. As you will recall, when we invoke the `decompose()`
    function on our quantum circuit, we are requesting the circuit to be decomposed
    down to its basis gates used to create the gates in our circuit. In this case,
    we are referring to the basis gates that are used to create a Toffoli gate:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打印我们的电路属性，但这次，让我们分解我们的量子电路以查看结果。如您所回忆的，当我们对量子电路调用`decompose()`函数时，我们请求电路分解为其基门，这些基门用于创建我们电路中的门。在这种情况下，我们指的是用于创建Toffoli门的基门：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Notice the difference?* Quite surprising indeed! By observing the results,
    we see that the Toffoli gate requires 15 operators, which are made up of various
    gates, such as T, ![](img/B18420_07_001.png), H, and CNOT:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意区别吗？* 确实令人惊讶！通过观察结果，我们看到Toffoli门需要15个操作符，这些操作符由各种门组成，例如T、![img/B18420_07_001.png]、H和CNOT：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason why I wanted to mention this was to make you aware that some of the
    gates used are not basis gates but are rather composites of basis gates used to
    generate the functionality of the desired gate. This is good to know when analyzing
    your circuit with respect to qubit noise or decoherence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以想提到这一点，是为了让你意识到所使用的某些门不是基门，而是用于生成所需门功能的基门的组合。在分析你的电路与量子比特噪声或退相干相关时，了解这一点是很有用的。
- en: Try the same exercise, only this time try creating a two-qubit circuit with
    a Swap gate and see what results you get back.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试同样的练习，但这次尝试创建一个具有Swap门的二量子比特电路，看看你得到什么结果。
- en: Now that you are familiar with the various forms of creating quantum circuits,
    let’s look at how we can reuse these circuits in a modular way that makes it easy
    to combine and comprehend them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了创建量子电路的各种形式，让我们看看我们如何以模块化的方式重复使用这些电路，使其易于组合和理解。
- en: Customizing and parameterizing circuit libraries
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制和参数化电路库
- en: There are times when you are going to want to reuse a circuit on multiple occasions.
    To simplify this, you can create a composite of operators and reuse them throughout
    your circuit. This not only simplifies creating the circuit from modules but also
    makes it very easy for others to understand what your circuit is doing in those
    composites. Qiskit creates these compositions based on the instruction sets or
    quantum circuits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能需要在多个场合重复使用一个电路。为了简化这个过程，你可以创建操作符的复合体并在整个电路中重复使用它们。这不仅简化了从模块创建电路的过程，而且使其他人很容易理解这些复合体中电路的功能。Qiskit根据指令集或量子电路创建这些复合体。
- en: 'In the following steps, we are going to create a composite gate that is made
    up of multiple qubits and gates:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将创建一个由多个量子位和门组成的复合门：
- en: 'First, we create a two-qubit quantum circuit, give it a name, and convert it
    into a generic quantum instruction:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个两量子位的量子电路，给它起个名字，并将其转换为通用量子指令：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will create the following two-qubit circuit, which we will
    use as our composite gate:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建以下两个量子位的电路，我们将将其用作复合门：
- en: '![](img/B18420_07_09.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_07_09.png)'
- en: 'Figure 7.9: The quantum circuit that will represent the composite gate'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：将表示复合门的量子电路
- en: 'Now, let’s create a quantum circuit that will append the composite gate onto
    the circuit we created:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个量子电路，将复合门附加到我们创建的电路上：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding code will create the circuit, which we prepopulated with some
    gates before including our composite gate:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建电路，我们在包含复合门之前预先填充了一些门：
- en: '![Figure 8.11 – The quantum circuit that we will append to the composite gate
    ](img/B18420_07_10.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 我们将附加到复合门上的量子电路](img/B18420_07_10.png)'
- en: 'Figure 7.10: The quantum circuit that we will append to the composite gate'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：我们将附加到复合门上的量子电路
- en: 'Since our composite gate is made up of two qubits, we will need to indicate
    which of the three qubits to append our two-qubit composite gate to. For this
    example, we will append it to the first two qubits:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的复合门由两个量子位组成，我们需要指明将我们的二量子位复合门附加到哪三个量子位上。对于这个例子，我们将它附加到前两个量子位上：
- en: '[PRE21]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see from the results, our composite gate was successfully appended
    to the first and second qubits. It also includes the name of the composite gate,
    which makes it simple for anyone, including yourself, to read the circuit and
    understand what the composite gate is doing within the circuit:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看到，我们的复合门已成功附加到第一和第二个量子位上。它还包括复合门的名字，这使得任何人，包括你自己，都能轻松阅读电路并理解复合门在电路中的功能：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_11.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B18420_07_11.png)'
- en: 'Figure 7.11: The quantum circuit with a composite gate representation of a
    predefined circuit'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：具有预定义电路复合门表示的量子电路
- en: This makes reading your circuit much easier compared to how it would be if you
    were to just concatenate the two quantum circuits together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与将两个量子电路简单连接起来相比，这使得阅读你的电路变得更加容易。
- en: Of course, this is ideal if you have a circuit that would run as is. However,
    there may be times when you wish to perhaps control the amount of rotation of
    some of the gates in the composite gate you generated. This is where the parameterization
    of composite gates comes in handy. We will now create another composite gate,
    only this one will include the ability to add parameters to your composite gate
    so that it is more dynamic. This is commonly referred to as a **Parameterized
    Quantum Circuit** (**PQC**).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你有一个可以立即运行的电路，这是理想的。然而，有时你可能希望控制你生成的复合门中某些门的旋转量。这就是复合门参数化的作用所在。我们现在将创建另一个复合门，但这一次它将包括向你的复合门添加参数的能力，使其更加动态。这通常被称为**参数化量子电路**（**PQC**）。
- en: 'To parameterize a gate, we will need to create a `Parameter` class and set
    it to a rotation gate; in this example, we will apply the parameter to an R[Z]
    gate:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了参数化一个门，我们需要创建一个`Parameter`类并将其设置为旋转门；在这个例子中，我们将参数应用到R[Z]门上：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the parameter value is defined as ![](img/B18420_06_162.png), but
    is not set as an explicit value. It just reserves the `Parameter` value to later
    include a rotation value of ![](img/B18420_06_162.png):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数值定义为![](img/B18420_06_162.png)，但不是设置为显式值。它只是预留了`Parameter`值，以便稍后包含一个旋转值![](img/B18420_06_162.png)：
- en: '![Figure 8.13 – Set the parameter of the Rz gate to  ](img/B18420_07_12.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 将Rz门的参数设置为  ](img/B18420_07_12.png)'
- en: 'Figure 7.12: Set the parameter of the R[z] gate to θ'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：将R[z]门的参数设置为θ
- en: 'Let’s bind the `Parameter` value of our gates to ![](img/B18420_07_004.png)
    and draw the circuit:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们门的`Parameter`值绑定到![](img/B18420_07_004.png)并绘制电路：
- en: '[PRE23]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that our rotation gate has its theta value set to ![](img/B18420_07_004.png)
    as expected:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的旋转门其theta值被设置为![](img/B18420_07_004.png)，正如预期的那样：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_13.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由低置信度自动生成](img/B18420_07_13.png)'
- en: 'Figure 7.13: Rotation gates R[z] now have the Parameter value θ set to 2π'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：旋转门R[z]现在将参数值θ设置为2π
- en: Our circuit is now ready to run with the bound parameter values. By having this
    feature, we can iterate it over a loop and bind multiple values if need be, so
    that we can iterate over all of them without having to manually update the bound
    values. This greatly optimizes our ability to run and analyze the results of our
    circuit for each iteration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电路现在已准备好运行，并绑定了参数值。通过这个特性，我们可以在循环中迭代它，并在需要时绑定多个值，这样我们就可以迭代所有这些值，而无需手动更新绑定的值。这极大地优化了我们运行和分析电路每个迭代的运行结果的能力。
- en: In this section, we learned about various forms and ways to create quantum circuits
    using the classes and functions provided in Qiskit to help us analyze our circuit
    properties and construction. We also learned how to reuse the created circuits.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了使用Qiskit提供的类和函数创建量子电路的各种形式和方法，以帮助我们分析电路属性和结构。我们还学习了如何重用创建的电路。
- en: In the next section, we will dig even deeper into manipulating qubits, only
    this time not from basis gates, but to directly manipulate the qubits using the
    hardware itself!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨操纵量子比特，但这次不是从基本门开始，而是直接使用硬件本身来操纵量子比特！
- en: Generating pulse schedules on hardware
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在硬件上生成脉冲计划
- en: So far, you have learned how to create quantum circuits, add gates that manipulate
    the qubits of the circuit, and execute the circuits. In this section, we’ll go
    a little deeper to see how a quantum circuit is converted from digital instructions
    to pulse instructions that physically manipulate the qubits using microwave pulses
    as instructed by the quantum circuit. Microwave pulses are what manipulate the
    qubits on quantum devices. A signal is generated and tuned to a specific frequency
    of each qubit so that the signal only affects the qubit that the pulse is tuned
    to.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了如何创建量子电路，添加操纵电路中量子比特的门，并执行电路。在本节中，我们将进一步探讨量子电路是如何从数字指令转换为脉冲指令的，这些脉冲指令根据量子电路的指令，通过微波脉冲物理地操纵量子比特。微波脉冲是操纵量子设备上量子比特的元素。一个信号被生成并调整到每个量子比特的特定频率，以确保信号只影响脉冲调整到的量子比特。
- en: Much of this section will assume that you have some knowledge of signal processing,
    particularly that of transmon-like superconducting qubits and microwave pulses.
    For reference, this is a fantastic paper that goes into the details, [https://arxiv.org/pdf/1904.06560.pdf](https://arxiv.org/pdf/1904.06560.pdf),
    where sections *4.C* and *4.D* cover a basic overview of how microwave signals
    are used to manipulate qubits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的大部分内容将假设您对信号处理有一定的了解，特别是关于类似transmon的超导量子比特和微波脉冲。为了参考，这是一篇非常棒的论文，详细介绍了相关内容，[https://arxiv.org/pdf/1904.06560.pdf](https://arxiv.org/pdf/1904.06560.pdf)，其中第*4.C*和*4.D*部分概述了如何使用微波信号来操纵量子比特。
- en: One thing you might be wondering by now is why you should have pulse access
    to manipulate the qubits. First, it is good to understand that superconducting
    qubits are manipulated by microwave pulses. These pulses send signals down to
    each qubit using the qubit’s carrier frequency to ensure that the pulse operation
    will affect only the qubit that is tuned to that specific frequency. This way,
    if you are a kernel developer, for example, the ability to configure the pulses
    provides you with the ability to fine-tune the gate operations yourself rather
    than the default pulse shapes that are set up. These fine-tunings could be applied
    to not only single-gate operations but also two-qubit operations such as a CNOT
    gate.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能想知道为什么您应该有脉冲访问来操作量子比特。首先，了解超导量子比特是通过微波脉冲来操作的这一点很重要。这些脉冲使用量子比特的载波频率将信号发送到每个量子比特，以确保脉冲操作只会影响调谐到该特定频率的量子比特。这样，如果您是内核开发者，例如，配置脉冲的能力让您能够自行微调门操作，而不是默认的脉冲形状。这些微调不仅可以应用于单门操作，还可以应用于像CNOT门这样的双量子比特操作。
- en: We’ll begin by illustrating how the hardware components are connected to the
    various pulse channels. IBM Quantum provides you with access to the machines in
    a way that is unique from most other quantum systems available on the cloud. Qiskit
    includes a `Pulse` library that allows you to control the pulses sent to the hardware
    that controls the device. Based on the `OpenPulse` documentation ([https://arxiv.org/abs/1809.03452](https://arxiv.org/abs/1809.03452)),
    it is tailored to provide the functionality to generate pulse signals used to
    control the qubits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先说明硬件组件是如何连接到各种脉冲通道的。IBM Quantum以与其他大多数云上可用的量子系统不同的方式为您提供对机器的访问。Qiskit包括一个`Pulse`库，允许您控制发送到控制设备的脉冲。根据`OpenPulse`文档([https://arxiv.org/abs/1809.03452](https://arxiv.org/abs/1809.03452))，它专门提供生成用于控制量子比特的脉冲信号的功能。
- en: 'To understand how the pulse functionality works, we’ll start by describing
    the four main components you will be using:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解脉冲功能的工作原理，我们将首先描述您将使用的四个主要组件：
- en: Instructions
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令
- en: Pulse libraries
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脉冲库
- en: Channels
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Schedules
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间表
- en: In the following sections, we will learn about the preceding components.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习关于前面组件的内容。
- en: 'Before we proceed to the next section, we will use the following code, which
    will import everything we need to create, schedule, and trigger a pulse on a quantum
    device directly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，我们将使用以下代码，该代码将导入我们直接创建、安排和触发量子设备上的脉冲所需的所有内容：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have imported the files needed, we will move on to the next section,
    about instructions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了所需的文件，我们将进入下一节，关于指令。
- en: Learning about instructions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解指令
- en: '**Pulse programs**, or, as described in the Qiskit API documentation, **Schedules**,
    are a set of instructions used to describe the control of the electronic components
    of the quantum system. There are various instruction objects included within the
    `qiskit.pulse` library that have capabilities such as modulation of the frequency
    and phase of the pulse signal.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**脉冲程序**，或者，如Qiskit API文档所述，**时间表**，是一组用于描述量子系统电子组件控制的指令。`qiskit.pulse`库中包含各种指令对象，它们具有调制脉冲信号频率和相位的特性。'
- en: '`pulse`, in essence, provides you with the ability to specify the dynamics
    of each operation in a quantum circuit, so you can fine-tune each in a way to
    minimize as much noise as possible. `pulse` has various functionalities to give
    you access to the channels that send and receive information to and from each
    qubit, and includes libraries of pulses that you can use as a base and you can
    then modify each one accordingly.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pulse`本质上为您提供指定量子电路中每个操作动态的能力，这样您就可以以尽可能减少噪声的方式对每个操作进行微调。`pulse`具有各种功能，让您能够访问发送和接收每个量子比特信息的通道，并包括您可以用作基础并相应修改的脉冲库。'
- en: You can also delay an instruction from triggering, similar to a `sleep()` function
    in most programming languages. Finally, it gives you the ability to trigger an
    operation and enable the acquire channel by playing and capturing the microwave
    pulse signals, respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以延迟指令的触发，类似于大多数编程语言中的`sleep()`函数。最后，它还赋予您通过播放和捕获微波脉冲信号来触发操作和启用获取通道的能力。
- en: 'Understanding each of the following is dependent on understanding *why* you
    would want to use these functions. For example, setting the frequency is important
    as each qubit is tuned to a specific frequency, so any pulse operation should
    be sent at the carrier frequency of the specified qubit; otherwise, the operation
    will not work, or, worse, it might operate on a qubit that you do not want to
    update. Now, let’s describe each instruction and its parameters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理解以下每个指令都取决于理解*为什么*你想使用这些函数。例如，设置频率很重要，因为每个量子比特都调谐到特定的频率，因此任何脉冲操作都应该在指定量子比特的载波频率上发送；否则，操作将不会工作，或者更糟，它可能会对您不想更新的量子比特进行操作。现在，让我们描述每个指令及其参数：
- en: '`SetFrequency(frequency, channel, name)`, where `frequency` is in Hz, `channel`
    indicates which channel the frequency will be applied to, and `name` is the name
    you can set for the instruction. The default *duration* of the `SetFrequency`
    instruction is `0`. This very simply sets the frequency of the channel so that
    the pulses applied to the channel are tuned accordingly. If you do not specify
    a frequency when creating a pulse for a specific qubit, the default frequency
    for the qubit on the drive channel will be used.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetFrequency(frequency, channel, name)`，其中`frequency`以Hz为单位，`channel`表示频率将应用到的通道，`name`是你可以为指令设置的名称。`SetFrequency`指令的默认*持续时间*为`0`。这非常简单地设置了通道的频率，以便应用于通道的脉冲相应地调谐。如果你在创建特定量子比特的脉冲时没有指定频率，将使用驱动通道上量子比特的默认频率。'
- en: '`ShiftPhase(phase, channel, name)`, where `phase` is the rotation angle in
    radians, `channel` indicates the channel that the frequency will be applied to,
    and the `name` parameter is the name you can set for the instruction. This instruction
    shifts the phase of the pulse by increasing its rotation angle by the provided
    amount in radians.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShiftPhase(phase, channel, name)`，其中`phase`是旋转角度（以弧度为单位），`channel`表示频率将应用到的通道，`name`参数是你可以为指令设置的名称。此指令通过增加提供的弧度数来增加旋转角度，从而移动脉冲的相位。'
- en: '`Delay(duration, channel, name)`, where `duration` is the length of time in
    the delay (in the documentation, this is also referred to as *time step*, or `dt`),
    `channel` indicates which channel the delay will be applied to, and `name` indicates
    the name that you can set for the instruction. The `Delay` instruction is generally
    used to align pulses with respect to other pulse instructions. For example, if
    you wish to send two pulses and include a time gap between the pulses, you can
    specify the time gap by adding a `Delay` instruction with the desired time gap
    amount.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delay(duration, channel, name)`，其中`duration`是延迟的长度（在文档中，这也被称为*时间步长*或`dt`），`channel`表示将应用延迟的通道，`name`表示你可以为指令设置的名称。`Delay`指令通常用于将脉冲与其他脉冲指令对齐。例如，如果您希望发送两个脉冲并在脉冲之间包含一个时间间隔，您可以通过添加一个具有所需时间间隔的`Delay`指令来指定时间间隔。'
- en: '`Play(pulse, channel, name)`, where `pulse` is the pulse waveform you wish
    to apply, `channel` indicates which channel the pulse will be applied to, and
    `name` is the name you can set for the instruction. The `Play` instruction will
    apply the pulse output to the channel specified, where the pulse output was previously
    modulated using both the `SetFrequency` and `SetPhase` instructions.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Play(pulse, channel, name)`，其中`pulse`是你希望应用的脉冲波形，`channel`表示脉冲将应用到的通道，`name`是你可以为指令设置的名称。`Play`指令将脉冲输出应用于指定的通道，其中脉冲输出之前已使用`SetFrequency`和`SetPhase`指令进行调制。'
- en: '`Acquire(duration, channel, mem_slot, reg_slot, kernel, discriminator, name)`,
    where `duration` is the number of time steps (dt) to acquire the data information,
    `channel` indicates which channel to acquire the data from, `mem_slot` is the
    classical memory slot in which to store each of the returned results, and `reg_slot`
    is the register slot used to store the classified and readout results. The `kernel`
    parameter is used to integrate the raw data for each slot, `discriminator` is
    used to classify kernelled IQ data into a `0` or `1` result, and `name` indicates
    the name you can set for the instruction.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Acquire(duration, channel, mem_slot, reg_slot, kernel, discriminator, name)`，其中`duration`是获取数据信息的时间步数（dt），`channel`表示从哪个通道获取数据，`mem_slot`是存储每个返回结果的经典内存槽，`reg_slot`是用于存储分类和读出结果的寄存器槽。`kernel`参数用于对每个槽的原始数据进行积分，`discriminator`用于将核化的IQ数据分类为`0`或`1`结果，`name`表示你可以为指令设置的名称。'
- en: Each instruction includes an operator that will be applied to the specified
    channels stated. The operators include pulse modulators, delays, and readouts
    from channels. Before we get into discussing channels, let’s create some pulses
    using the Qiskit Pulse library.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令都包含一个将应用于指定通道的操作符。操作符包括脉冲调制器、延迟和从通道读取。在我们讨论通道之前，让我们使用Qiskit Pulse库创建一些脉冲。
- en: Understanding pulses and Pulse libraries
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解脉冲和Pulse库
- en: Each microwave pulse is created by an **arbitrary waveform generator** (**AWG**),
    which specifies the frequency and phase of the pulse signal output. The frequency
    and phase are set by the `SetFrequency` and `ShiftPhase` instructions we learned
    about earlier, respectively.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微波脉冲都是由一个**任意波形发生器**（**AWG**）生成的，它指定了脉冲信号的频率和相位。频率和相位分别由我们之前学过的`SetFrequency`和`ShiftPhase`指令设置。
- en: '**Important Note**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: 'Qiskit Pulse provides a nice library of waveforms, which can simplify creating
    the pulses we need to operate on a qubit. The following are the types of available
    waveforms at the time of writing this chapter: `Constant`, `Drag`, `Discrete`,
    `Gaussian`, `GaussianSquare`, and `Waveform`. Each of these waveforms has a specific
    feature, for example, `Drag` is used to reduce leakage to the ![](img/B18420_07_006.png)
    state of the qubit and keeps it confined to the ![](img/B18420_07_007.png) and
    ![](img/B18420_07_008.png) states.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Pulse提供了一个很好的波形库，可以简化创建我们需要在量子比特上操作的脉冲。以下是在编写本章时可用波形的类型：`Constant`、`Drag`、`Discrete`、`Gaussian`、`GaussianSquare`和`Waveform`。这些波形中的每一个都有其特定的功能，例如，`Drag`用于减少量子比特到![](img/B18420_07_006.png)状态的泄漏，并使其保持在![](img/B18420_07_007.png)和![](img/B18420_07_008.png)状态。
- en: Each of the waveforms provided in the Pulse library has a specific feature.
    We’ll cover a few of them below, but I would encourage you to read more in the
    Qiskit documentation, [https://docs.quantum.ibm.com/api/qiskit/pulse](https://docs.quantum.ibm.com/api/qiskit/pulse),
    which includes a detailed description of each.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Pulse库中提供的每个波形都有其特定的功能。以下我们将介绍其中的一些，但我鼓励你阅读Qiskit文档[https://docs.quantum.ibm.com/api/qiskit/pulse](https://docs.quantum.ibm.com/api/qiskit/pulse)，其中包含了每个波形的详细描述。
- en: '`Waveform` allows you to define your own pulse by providing an array of complex
    value samples as an argument. These samples each have a predefined time step,
    `dt`, which is the time period played for each and varies based on the specified
    backend. The following code is an example of a sample pulse for a simple sine
    waveform of 128 samples:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Waveform`允许你通过提供一个复数值样本数组作为参数来自定义脉冲。这些样本每个都有一个预定义的时间步长，`dt`，这是每个样本播放的时间周期，它根据指定的后端而变化。以下代码是一个简单正弦波形的128个样本脉冲的示例：'
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following screenshot is the result of creating our sample pulse of a sine
    waveform:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是我们创建的正弦波形样本脉冲的结果：
- en: '![Chart  Description automatically generated](img/B18420_07_14.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图表  自动生成的描述](img/B18420_07_14.png)'
- en: 'Figure 7.14: Sample pulse of a sine waveform'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：正弦波形的样本脉冲
- en: Let’s now try generating one of the waveforms from the Pulse library.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试从Pulse库中生成一个波形。
- en: The Pulse library has an array of different waveforms, such as `Gaussian`, `GaussianSquare`,
    `Constant`, and `Drag` (just to name a few). Each has its own distinct shape that
    we can leverage to fine-tune any pulse we wish.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Pulse库提供了一系列不同的波形，例如`Gaussian`、`GaussianSquare`、`Constant`和`Drag`（仅举几个例子）。每个都有其独特的形状，我们可以利用这些形状来微调我们想要的任何脉冲。
- en: 'Let’s create a `GaussianSquare` pulse, which is simply a square pulse with
    Gaussian edges on both ends, rather than squared-off edges:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`GaussianSquare`脉冲，它是一种两端带有高斯边缘的方形脉冲，而不是截断边缘的方形脉冲：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code will result in the following pulse, where the duration (`dt`)
    is `128`, the amplification max is at `1`, sigma is set to `2`, and the width
    of the pulse peak is `112` (`dt`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下脉冲，其中脉冲持续时间(`dt`)为`128`，放大最大值为`1`，sigma设置为`2`，脉冲峰值的宽度为`112`(`dt`)：
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18420_07_15.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，表格  自动生成的描述](img/B18420_07_15.png)'
- en: 'Figure 7.15: Gaussian square pulse'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：高斯平方脉冲
- en: As you can see, the parameters available to us allow adjustments to the waveform
    in multiple ways. In the `Gaussian Square` waveform sample, we were able to adjust
    the amplitude, width, and its sigma, which therefore provides us with more control
    over the creation of the pulse, which could potentially reduce noise or any other
    affects that could come from a standard pulse that is created based on the quantum
    circuit instructions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可用的参数允许以多种方式调整波形。在`高斯平方`波形样本中，我们能够调整幅度、宽度和其sigma，这因此为我们提供了更多控制脉冲创建的能力，这可能会减少噪声或任何其他可能来自基于量子电路指令创建的标准脉冲的影响。
- en: Now that we can create pulses, let’s learn about the channels that we will transmit
    these pulses through.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建脉冲，让我们了解一下我们将通过这些通道传输脉冲的通道。
- en: Leveraging channels to transmit and receive instructions
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用通道传输和接收指令
- en: 'There are two types of channels in Qiskit Pulse:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Pulse中有两种类型的通道：
- en: The first type is the **Pulse channel**, which transmits the generated pulses
    to the quantum device. These include the **Drive channel**, **Control channel**,
    and the **Measure channel**.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种类型是**脉冲通道**，它将生成的脉冲传输到量子设备。这些包括**驱动通道**、**控制通道**和**测量通道**。
- en: The other type of channel is the **Acquisition channel**. Currently, this type
    only includes the **Acquire channel**, which is the channel that receives pulses
    from the quantum device.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种类型的通道是**采集通道**。目前，这种类型仅包括**采集通道**，这是接收来自量子设备脉冲的通道。
- en: 'All channels only have one parameter, the index, which is used to assign the
    channel. The following list describes all the channels:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通道只有一个参数，即索引，用于分配通道。以下列表描述了所有通道：
- en: The Drive channel is the channel used to transmit the pulse signal down to the
    qubit to execute the gate operation. When displayed, it has the prefix **D**.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驱动通道**是用于将脉冲信号传输到量子比特以执行门操作的通道。当显示时，它具有前缀**D**。'
- en: The Control channel is commonly used on multi-qubit gate operations such as
    `Control-Not`, `Control-Phase`, and more. They generally provide auxiliary control
    over the qubit via the drive channel. When displayed, it has the prefix **U**.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制通道**通常用于多量子比特门操作，如`Control-Not`、`Control-Phase`等。它们通常通过驱动通道提供对量子比特的辅助控制。当显示时，它具有前缀**U**。'
- en: The Measure channel transmits a measurement stimulus pulse to the qubit for
    a readout from the qubit. When displayed, it has the prefix **M**.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测量通道**向量子比特传输测量刺激脉冲，以从量子比特进行读出。当显示时，它具有前缀**M**。'
- en: The Acquire channel is the only channel that is used to receive information
    from the device. It is used to collect data from the quantum device. When displayed,
    it has the prefix **A**.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采集通道**是唯一用于从设备接收信息的通道。它用于收集量子设备的数据。当显示时，它具有前缀**A**。'
- en: So far, we have learned that pulse programs are instructions that are made up
    of waveform pulses that are constructed to perform gate operations on quantum
    devices. We also covered the different channels available to transmit and receive
    information to and from quantum devices. With this information, we can now look
    at how to schedule these instructions to be executed on a real device.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到脉冲程序是由用于在量子设备上执行门操作的波形脉冲组成的指令。我们还介绍了可用于在量子设备之间传输和接收信息的不同通道。有了这些信息，我们现在可以看看如何安排这些指令在真实设备上执行。
- en: Generating and executing schedules
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成和执行调度
- en: Pulse schedules are a set of instructions sent through specified channels to
    be executed on a quantum device. The `Schedule` class can be made up of instructions
    or a combination of other schedules. That means you can create a schedule with
    one of the instructions we learned about earlier, or you can combine or append
    schedules to existing schedules. We will do all this in this section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 脉冲调度是一组通过指定通道发送到量子设备上执行的指令。`Schedule`类可以由指令或其他调度的组合组成。这意味着您可以使用我们之前学到的其中一个指令创建一个调度，或者将调度组合或附加到现有调度中。我们将在本节中完成所有这些操作。
- en: 'We will use what we have learned so far in this chapter to build a schedule.
    First, we will construct a schedule and insert a pulse from the Pulse library
    into it that will be triggered at `time = 0`. Then, we will create another schedule
    and insert a different pulse from the Pulse library into it. The second one will
    be appended to the first schedule and then shifted, so it is triggered at some
    time after the first pulse has completed. We’ll then execute the schedule on a
    quantum device and get back its result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用本章迄今为止学到的知识来构建一个时间表。首先，我们将构建一个时间表，并将脉冲库中的一个脉冲插入其中，该脉冲将在`time = 0`时触发。然后，我们将创建另一个时间表，并将脉冲库中的不同脉冲插入其中。第二个时间表将被附加到第一个时间表上，然后进行平移，以便在第一个脉冲完成后在某个时间触发。然后，我们将在量子设备上执行时间表并获取其结果：
- en: 'Let’s continue using the notebook we have been using so far to create our first
    schedule, and name it `schedule_1`. We’ll also use the `Play` instruction to insert
    the Gaussian square pulse we generated earlier and assign the schedule to drive
    channel `0`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续使用我们迄今为止一直在使用的笔记本来创建我们的第一个时间表，并将其命名为`schedule_1`。我们还将使用`Play`指令插入我们之前生成的高斯方波脉冲，并将时间表分配给驱动通道`0`：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result we see is that our Gaussian square pulse was added to the schedule
    starting at `time = 0`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的结果是我们的高斯方波脉冲被添加到从`time = 0`开始的时间表中，如下所示：
- en: '![Table  Description automatically generated](img/B18420_07_16.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![表格  自动生成的描述](img/B18420_07_16.png)'
- en: 'Figure 7.16: Schedule 1: Gaussian square pulse'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：时间表1：高斯方波脉冲
- en: 'Now, let’s continue and create the second schedule, `schedule_2`, with the
    sample pulse we generated earlier:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建第二个时间表，`schedule_2`，我们将使用我们之前生成的样本脉冲：
- en: '[PRE28]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This results in the following schedule: note the duration of our sample pulse
    is 64, whereas the Gaussian square pulse has a duration of 128:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下时间表：注意我们的样本脉冲的持续时间为64，而高斯方波脉冲的持续时间为128：
- en: '![Chart, histogram  Description automatically generated](img/B18420_07_17.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图表，直方图  自动生成的描述](img/B18420_07_17.png)'
- en: 'Figure 7.17: Schedule 2: sample (sine waveform) pulse'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：时间表2：样本（正弦波形）脉冲
- en: 'Next, we will create a third schedule, `schedule_3`, and we will construct
    it by inserting both `schedule_1` and `schedule_2` together with a gap of 5 time
    steps (`dt`) in between the two:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建第三个时间表，`schedule_3`，我们将通过插入`schedule_1`和`schedule_2`，并在两者之间留出5个时间步长（`dt`）的间隔来构建它：
- en: '[PRE29]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is a combination of `schedule_1` starting at `time = 0` and then
    we insert `schedule_2` starting at 5 time units after the first schedule. Note
    the use of the `duration` variable to ensure that the pulse does not overlap with
    the first. Schedule 3, therefore, has a total time of the two pulses plus the
    5 time units in between the two, totaling 197, as the following figure illustrates:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`schedule_1`从`time = 0`开始，然后我们在第一个时间表之后5个时间单位插入`schedule_2`。注意使用`duration`变量确保脉冲不会与第一个重叠。因此，时间表3的总时间为两个脉冲加上两者之间的5个时间单位，总计197，如下图所示：
- en: '![Chart  Description automatically generated](img/B18420_07_18.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图表  自动生成的描述](img/B18420_07_18.png)'
- en: 'Figure 7.18: Schedule 3, combining schedules 1 and 2 with a 5 time unit difference
    in between'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：时间表3，在两者之间有5个时间单位差异地组合时间表1和时间表2
- en: 'Of course, there are other ways to combine pulses. If you want to combine the
    two schedules without a gap in between, then you can simply use the `append` function
    to combine them:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，还有其他方法可以组合脉冲。如果您想在两者之间没有间隔的情况下组合两个时间表，那么您只需简单地使用`append`函数将它们组合即可：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code results in the following output. Note how the total time
    units are equal to the total time units of both pulses, without the additional
    5 time units in between the two pulses:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下输出。注意，总时间单位等于两个脉冲的总时间单位，两个脉冲之间没有额外的5个时间单位：
- en: '![A picture containing chart  Description automatically generated](img/B18420_07_19.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片  自动生成的描述](img/B18420_07_19.png)'
- en: 'Figure 7.19: Schedule 3, appending two schedules without a time gap in between'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：时间表3，在两者之间没有时间间隔地附加两个时间表
- en: Up to this point, we were able to generate a pulse, apply it to an instruction,
    and schedule it to run on a specified channel to manipulate the qubit. Generating
    a set of pulses allows you to get an understanding of how we can schedule two
    separate gate operations to a single qubit sequentially on the specified channel.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够生成脉冲，将其应用于指令，并安排在指定的通道上运行以操纵量子位。生成一组脉冲可以让你了解我们如何将两个不同的门操作顺序地安排在指定的通道上的单个量子位。
- en: In the next section, we’ll see how we can find the status of our quantum circuits
    once they have been submitted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到我们如何在提交量子电路后找到其状态。
- en: Understanding the Job component
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解作业组件
- en: 'The last component we will cover is the `Job` component. The `Job` component
    is basically an instance of the circuit that has been executed on the backend
    and contains information from the executed circuit(s), such as results, which
    backend, duration, etc. What that means is that once you send the circuit to the
    backend to get executed, the backend will generate the `Job` instance and append
    information about the job: information such as status, result, job identifier,
    and so on. The following is a list of the available `Job` functions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个组件是`Job`组件。`Job`组件基本上是在后端上执行过的电路的实例，并包含有关执行电路（如结果、后端、持续时间等）的信息。这意味着一旦你将电路发送到后端以执行，后端将生成`Job`实例并附加有关作业的信息：如状态、结果、作业标识符等信息。以下是一个可用的`Job`函数列表：
- en: '`backend()` provides the backend that the job is running on.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend()`提供了作业正在运行的后端。'
- en: '`status()` provides the status of the job.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status()`提供作业的状态。'
- en: '`result()` provides the job result after execution is completed on the backend.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result()`在后台执行完成后提供作业结果。'
- en: '`cancel()` provides the ability to cancel the job.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cancel()`提供了取消作业的能力。'
- en: '`job_id()` provides the alphanumeric job identifier.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`job_id()`提供了字母数字作业标识符。'
- en: 'We’ll reuse the circuit we created earlier, `transpiled_qc`, for simplicity
    so we can review the `Job` object and its functions. Let’s start by importing
    the `job_monitor` class and launching the Qiskit job watcher, followed by running
    the circuit on a backend and running the job monitor to see the status of the
    job in the output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将重用我们之前创建的电路`transpiled_qc`，这样我们就可以查看`Job`对象及其函数。让我们首先导入`job_monitor`类并启动Qiskit作业监视器，然后在一个后端上运行电路并运行作业监视器以查看作业的输出状态：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code will execute a circuit and the following will display the
    details of the `Job` object; for example, it will indicate whether the job is
    in a queue, running, or completed successfully. In this case, the result of the
    status is that the job has successfully run:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将执行一个电路，以下将显示`Job`对象的详细信息；例如，它将指示作业是否在队列中、正在运行或成功完成。在这种情况下，状态的结果表明作业已成功运行：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Other information can also be pulled from the `Job` object. The **Job ID**
    is the unique identifier of the job that is being run. This ID can be very useful
    for various reasons, such as tracking the results, and should you have an issue
    with a job running on the backend, you can reference the job ID when speaking
    to the support team, which will help the team find the job. The status and results
    can be called explicitly using the functions `status()` and `result()`, respectively.
    The `result` object provides all the information resulting from running the job
    on the backend. Let’s run these functions to review the results of the job we
    just ran:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从`Job`对象中提取其他信息。**作业ID**是正在运行的作业的唯一标识符。这个ID在多种情况下非常有用，例如跟踪结果，如果你在后台运行的作业遇到问题，你可以向支持团队提及作业ID，这将帮助团队找到该作业。可以使用`status()`和`result()`函数分别显式调用状态和结果。`result`对象提供了在后台运行作业的所有信息。让我们运行这些函数来查看我们刚刚运行的作业的结果：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The results of each of the functions in the code snippet are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段中每个函数的结果如下：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is where we can pull specific result information that we can use to visualize
    the status of the Job. For example, the following code will extract the counts
    from the results and display the counts in a histogram:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以提取特定的结果信息，我们可以使用这些信息来可视化作业的状态。例如，以下代码将从结果中提取计数并显示在直方图中：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The results will produce the following histogram which pertains to the results
    from each shot as a total of probabilities. (quasi-probabilities) as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将生成以下直方图，该直方图涉及每个射击的结果，作为一个总概率（准概率）如下：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The histogram will then display as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图将显示如下：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_07_20.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图表，条形图  自动生成的描述](img/B18420_07_20.png)'
- en: 'Figure 7.20: The probability results as a histogram'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20：概率结果作为直方图
- en: The `job` object helps us get details regarding the circuit that we have sent
    to run on a quantum system. This information can be used to provide the results
    back to our application and visualize the results accordingly. It also provides
    the status and other information that we can use to keep track of the job and
    share details about the results with others, such as support teams, so they can
    easily identify jobs on the backend.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`job` 对象帮助我们获取有关我们已发送到量子系统上运行的电路的详细信息。这些信息可用于将结果返回到我们的应用程序，并相应地可视化结果。它还提供了状态和其他信息，我们可以使用这些信息来跟踪作业，并与他人分享有关结果的其他详细信息，例如支持团队，这样他们可以轻松地在后端识别作业。'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered just some of the many features included in the Qiskit
    library. We reviewed creating quantum circuits, as well as executing them on the
    simulator and real quantum devices. We also reviewed how to concatenate circuits
    so as to enable you to combine and create composite circuits, which included binding
    parameters to enable adjustments to various gates.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅介绍了 Qiskit 库中包含的许多功能之一。我们回顾了创建量子电路，以及如何在模拟器和真实量子设备上执行它们。我们还回顾了如何连接电路，以便您可以将它们组合并创建复合电路，这包括绑定参数以允许调整各种门。
- en: We covered how the circuits are converted into pulses using Qiskit’s Pulse library
    and created schedules, which are programs that send pulse information via various
    channels down to the hardware, and looked at how to obtain the details of the
    job that was running on the backend.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了如何使用 Qiskit 的 Pulse 库将电路转换为脉冲，并创建了计划，这些计划是发送脉冲信息通过各种通道到底层硬件的程序，并查看如何获取后端上运行的作业的详细信息。
- en: In the next chapter, we will cover techniques to optimize your quantum circuits
    by reviewing the features available via pass managers and optimizers. We’ll also
    learn various ways to visualize your quantum circuits and monitor your jobs as
    they are executed on the quantum backend systems.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过回顾通过传递管理器和优化器提供的功能来介绍优化您的量子电路的技术。我们还将学习各种可视化您的量子电路和监控您在量子后端系统上执行作业的方法。
- en: Questions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Construct a random quantum circuit with a width of 4 and a depth of 9.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个宽度为 4 且深度为 9 的随机量子电路。
- en: Create another random quantum circuit with the same width as the circuit you
    created in *Question 1* and concatenate it so that it is added before the random
    quantum circuit you created.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个与你在 *问题 1* 中创建的电路宽度相同的随机量子电路，并将其连接起来，以便在你在前面创建的随机量子电路之前添加。
- en: Print the circuit properties of the concatenated quantum circuit from *Question
    3* and specify the total number of operators, not including any measurement operators.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 *问题 3* 中连接的量子电路的电路属性，并指定操作符的总数，不包括任何测量操作符。
- en: Create a circuit with a parameterized R[Y] gate that would rotate by an angle
    of ![](img/B18420_07_009.png).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有参数化 R[Y] 门的电路，该门将旋转一个角度为 ![](img/B18420_07_009.png)。
- en: Join us on Discord
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_7.xhtml)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_7.xhtml)'
- en: '![](img/QR_Code2617625996838265932.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2617625996838265932.png)'
