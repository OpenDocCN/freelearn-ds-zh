- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming with Qiskit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qiskit** has various libraries that link between the core hardware of a quantum
    system and the tools necessary to create quantum circuits, both transcend upward
    through the code stack. It is, therefore, the foundation used to create quantum
    circuits, as well as generating and scheduling pulses from the circuits onto the
    hardware devices. Other features, such as optimizers and transpilers, are used
    to ensure the circuits are optimal to reduce decoherence and improve performance.
    In this chapter, we will explore all the key features available in Qiskit to help
    you create your own circuits, optimizers, and pulse schedules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding quantum circuits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pulse schedules on hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Job component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit has so many features and enhancements that it would take an entire book
    to write about them all. To cover as many of them as possible, we will create
    a quantum circuit and walk you through the various features. After reading this
    chapter, you will be able to understand how to create quantum circuits from basic
    to customized circuits with user-defined labels to help contextualize your circuit.
    You’ll also get an understanding of the Job component, which is used to run your
    circuit on a quantum system.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll even delve into the hardware to schedule a pulse operation on a qubit
    to better understand how the circuit is translated from digital to analog signals
    to perform an operation on a qubit(s), followed by reading the information from
    the qubit and converting the signal back from analog to digital.
  prefs: []
  type: TYPE_NORMAL
- en: Sound exciting? Great! Let’s get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, it is expected that you are familiar with the basics of quantum
    circuits described in previous chapters, such as creating and executing quantum
    circuits, visualizing circuit diagrams, and knowledge of qubit logic gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing and optimizing quantum circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you had some exposure to quantum circuit operations to
    understand some of the basic quantum components. These basic operations included
    creating a quantum circuit, applying quantum gates to the circuit, and executing
    the circuit on a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a deeper look into quantum circuits to better understand what
    properties and functionalities are available to us to not just execute these circuits
    on a real device but to do so as optimally as possible. In this section, we will
    learn how to extract circuit properties, such as circuit depth, width, and size,
    and obtain the number of actual operators. Let’s first start by reviewing the
    various forms of creating a quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Components of a quantum circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qiskit provides various ways to create a quantum circuit, each depending on
    how much information you need throughout your circuit. Up to this point, we have
    been creating circuits using a single constructor that automatically creates the
    circuit registers needed. In this form, the arguments indicate the number of qubits
    and bits of both the quantum and classical registers, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we will describe other ways to create a circuit and discuss
    the advantage of using one form or the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to construct a `QuantumCircuit` class is to create the quantum
    and classical registers independently of the quantum circuit constructor. Here,
    we will first create the quantum and classical registers, each with two qubits
    and two bits, respectively, and then draw the circuit. The constructor allows
    us to customize the label of our registers, which we were not able to do in the
    previous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, note that the second argument: that is, the `name`
    attribute: of the register constructors allows us to add a label to each register,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B18420_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Customized quantum and classical register labels'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the labels of our registers simplifies reading our circuits, particularly
    as the circuits become more complex when having multiple registers performing
    different processes. You may want to have one register created with a fixed number
    of qubits and another dynamic register where defining the number of qubits would
    vary based on some preprocessed step. You’ll see the value of this when we create
    composites later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can also combine creating the registers and the circuit constructor
    all in one line if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume now that you have two quantum circuits and you want to concatenate
    them together. The following example will illustrate how to concatenate two circuits
    into one without having to explicitly recreate one based on the two existing quantum
    circuits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will create the first circuit and include labels
    on both the quantum and classical registers so that we can monitor that they are,
    in fact, combined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows what should be displayed after running the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calendar  Description automatically generated with low confidence](img/B18420_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The first of the two quantum circuits we will join'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a second circuit, which is very similar to the first one,
    only we will update the labels to identify it as the second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results of the code should be no surprise: that it is the same as the first
    one only with the labels updated as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The second of the two quantum circuits we will join ](img/B18420_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The second of the two quantum circuits we will join'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s finish up by combining one circuit with the other, which is to say
    we will widen the circuit from 2 to 4 qubits. To do this, we will use the `add_register`
    function, which combines the quantum and classical registers into a single circuit.
    Here, we will combine circuits `qc2` and `qc1` into a new circuit titled `qc_combined`,
    and then draw the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, the results are now a combination
    of the two previous quantum circuits into a new circuit, by combining the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Concatenation of two quantum circuits ](img/B18420_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Concatenation of two quantum circuits'
  prefs: []
  type: TYPE_NORMAL
- en: We originally created two individual quantum circuits, each with two quantum
    registers and two classical registers. We then concatenated them to create a quantum
    circuit with four quantum and classical circuits. The order of the quantum circuits
    is based on the order in which they were concatenated. As an extra exercise, repeat
    the previous concatenation code and switch the order to confirm or create more
    quantum circuits and add more circuits together.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last circuit creation object I would like to share is the random circuit
    generator, which, as the name suggests, will generate a random circuit for you.
    Having the ability to create a random circuit could help you to create test circuits
    or examples given a set of parameters, such as circuit width and depth. As the
    following code block indicates, the `random_circuit` object requires two parameters.
    They are the number of qubits you want the random circuit to contain and the depth
    of the circuit, respectively: where depth indicates the number of standard gates,
    selected from the Qiskit circuit extensions listed in the API documentation, to
    add randomly per qubit. You can also indicate whether you want the circuit to
    include measurement operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from the random circuit will vary, of course, each time you execute
    it, as it should. What will not vary are the parameter options, particularly the
    number of qubits and the depth count. In this case, your results should have a
    circuit that contains three qubits and a depth of two operators. The following
    random circuit is the result of running the preceding code. Note that the measurement
    operator is not included in the depth count:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Random circuit generated with number of qubits = 3 and depth
    = 2  ](img/B18420_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Random circuit generated with number of qubits = 3 and depth =
    2'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the various ways to generate quantum circuits,
    we will continue and see what properties we can extract from the circuits created.
    These properties could be used to analyze the generated circuit and ensure it
    is optimized by leveraging some optimization features available to us in Qiskit.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining circuit properties and analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructing circuits could get very complex once you start building them out,
    particularly if you create composites of gates and combine them to form larger
    gates. You’re going to want to get some information about your circuit along the
    way should you need to analyze your results.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing for us is that Qiskit has taken care of some of this by making
    a lot of these properties available to us. Let’s start with some basic properties.
    Let’s say we want to know how many qubits we have in our circuit. As we learned
    in the previous section, we know that we can concatenate two or more circuits
    together. As we add more circuits together, it becomes difficult, or tedious,
    to determine the number of qubits and gates that our concatenated circuit will
    have. It’s here that the width, depth, and operator count functions come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will create two two-qubit random circuits, each with
    different gate counts. We will then append one circuit to another and use our
    circuit property functions to help us get the total width, depth, and operator
    count. All circuits that we append will need to have the same number of qubits
    using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be a two-qubit circuit with a random set of gate operators
    with a total depth of 6\. We know this because we created them and can see the
    values from the `random_circuit` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Randomly generated two-qubit circuits with a depth of 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use our circuit property functions to get the width, depth, size,
    and operator count of our circuit. To simplify this, we will create a helper function
    that will print out the circuit properties of the quantum circuit we will pass
    in as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our circuit through our helper function, which will print out
    all the properties we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our results should have the same value for `Width` and `Depth`. However, since
    we are using random circuits, our circuit size and the number of operators will
    be different as they are based on the randomly chosen gates. However, by observing
    the circuit, you will see that the result values of `size()` and `count_ops()`
    are the same. The difference between the two is that the circuit size returns
    the total number of gates in the circuit, while the operator count lists the name
    of each gate type and the total number of each gate type in the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try adding some classic registers, measurements, and barriers to
    see what we get back. We can use a shortcut to include measurement operators by
    using `measure_all()`, which will append a barrier, a measurement for each qubit,
    and the classical registers to match the number of qubits in the quantum register
    of our circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result now includes the classical components needed to measure and read
    out our qubits. These include the two-bit classical registers labeled as `measure`,
    a barrier separating the quantum gates from the measurement operators, and the
    measurement operators, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Random circuit with classical components added'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now print our circuit property functions to see an updated count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show what we generally would expect. The `W``idth` count increased
    by 2, due to the addition of the two-bit classical register. The `Depth` count
    increased by 1 due to the addition of the barrier. Note that the measurement operator
    is not included in the size or operator count, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on to the next section, let’s look at an interesting caveat to
    our circuit property functions. Most gates are created from basis gates that are
    specific to the quantum computers used. For most quantum systems, there are a
    set of basis gates used to create other gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, some gates, such as the **Toffoli** and **Swap** gates, not only require
    more than a single qubit but are also composed of several basis gates. Let’s look
    at the Toffoli gate as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a quantum circuit with 3 qubits and add only a Toffoli gate
    to it, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we see the Toffoli gate as expected, with the 0 and 1 source qubits entangled,
    with qubit 2 as the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – The Toffoli gate on a quantum circuit ](img/B18420_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: The Toffoli gate on a quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: 'We print out our circuit properties of the quantum circuit with the Toffoli
    gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see, the results are not surprising in that the values are not surprising
    either: a three-qubit gate with a width of `3` and a depth of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s print our circuit property, only this time, let’s decompose our
    quantum circuit to see the results. As you will recall, when we invoke the `decompose()`
    function on our quantum circuit, we are requesting the circuit to be decomposed
    down to its basis gates used to create the gates in our circuit. In this case,
    we are referring to the basis gates that are used to create a Toffoli gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Notice the difference?* Quite surprising indeed! By observing the results,
    we see that the Toffoli gate requires 15 operators, which are made up of various
    gates, such as T, ![](img/B18420_07_001.png), H, and CNOT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reason why I wanted to mention this was to make you aware that some of the
    gates used are not basis gates but are rather composites of basis gates used to
    generate the functionality of the desired gate. This is good to know when analyzing
    your circuit with respect to qubit noise or decoherence.
  prefs: []
  type: TYPE_NORMAL
- en: Try the same exercise, only this time try creating a two-qubit circuit with
    a Swap gate and see what results you get back.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the various forms of creating quantum circuits,
    let’s look at how we can reuse these circuits in a modular way that makes it easy
    to combine and comprehend them.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing and parameterizing circuit libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you are going to want to reuse a circuit on multiple occasions.
    To simplify this, you can create a composite of operators and reuse them throughout
    your circuit. This not only simplifies creating the circuit from modules but also
    makes it very easy for others to understand what your circuit is doing in those
    composites. Qiskit creates these compositions based on the instruction sets or
    quantum circuits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we are going to create a composite gate that is made
    up of multiple qubits and gates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a two-qubit quantum circuit, give it a name, and convert it
    into a generic quantum instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will create the following two-qubit circuit, which we will
    use as our composite gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The quantum circuit that will represent the composite gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a quantum circuit that will append the composite gate onto
    the circuit we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will create the circuit, which we prepopulated with some
    gates before including our composite gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – The quantum circuit that we will append to the composite gate
    ](img/B18420_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The quantum circuit that we will append to the composite gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our composite gate is made up of two qubits, we will need to indicate
    which of the three qubits to append our two-qubit composite gate to. For this
    example, we will append it to the first two qubits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see from the results, our composite gate was successfully appended
    to the first and second qubits. It also includes the name of the composite gate,
    which makes it simple for anyone, including yourself, to read the circuit and
    understand what the composite gate is doing within the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The quantum circuit with a composite gate representation of a
    predefined circuit'
  prefs: []
  type: TYPE_NORMAL
- en: This makes reading your circuit much easier compared to how it would be if you
    were to just concatenate the two quantum circuits together.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is ideal if you have a circuit that would run as is. However,
    there may be times when you wish to perhaps control the amount of rotation of
    some of the gates in the composite gate you generated. This is where the parameterization
    of composite gates comes in handy. We will now create another composite gate,
    only this one will include the ability to add parameters to your composite gate
    so that it is more dynamic. This is commonly referred to as a **Parameterized
    Quantum Circuit** (**PQC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To parameterize a gate, we will need to create a `Parameter` class and set
    it to a rotation gate; in this example, we will apply the parameter to an R[Z]
    gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that the parameter value is defined as ![](img/B18420_06_162.png), but
    is not set as an explicit value. It just reserves the `Parameter` value to later
    include a rotation value of ![](img/B18420_06_162.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Set the parameter of the Rz gate to  ](img/B18420_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Set the parameter of the R[z] gate to θ'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s bind the `Parameter` value of our gates to ![](img/B18420_07_004.png)
    and draw the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that our rotation gate has its theta value set to ![](img/B18420_07_004.png)
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B18420_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Rotation gates R[z] now have the Parameter value θ set to 2π'
  prefs: []
  type: TYPE_NORMAL
- en: Our circuit is now ready to run with the bound parameter values. By having this
    feature, we can iterate it over a loop and bind multiple values if need be, so
    that we can iterate over all of them without having to manually update the bound
    values. This greatly optimizes our ability to run and analyze the results of our
    circuit for each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about various forms and ways to create quantum circuits
    using the classes and functions provided in Qiskit to help us analyze our circuit
    properties and construction. We also learned how to reuse the created circuits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dig even deeper into manipulating qubits, only
    this time not from basis gates, but to directly manipulate the qubits using the
    hardware itself!
  prefs: []
  type: TYPE_NORMAL
- en: Generating pulse schedules on hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have learned how to create quantum circuits, add gates that manipulate
    the qubits of the circuit, and execute the circuits. In this section, we’ll go
    a little deeper to see how a quantum circuit is converted from digital instructions
    to pulse instructions that physically manipulate the qubits using microwave pulses
    as instructed by the quantum circuit. Microwave pulses are what manipulate the
    qubits on quantum devices. A signal is generated and tuned to a specific frequency
    of each qubit so that the signal only affects the qubit that the pulse is tuned
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Much of this section will assume that you have some knowledge of signal processing,
    particularly that of transmon-like superconducting qubits and microwave pulses.
    For reference, this is a fantastic paper that goes into the details, [https://arxiv.org/pdf/1904.06560.pdf](https://arxiv.org/pdf/1904.06560.pdf),
    where sections *4.C* and *4.D* cover a basic overview of how microwave signals
    are used to manipulate qubits.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might be wondering by now is why you should have pulse access
    to manipulate the qubits. First, it is good to understand that superconducting
    qubits are manipulated by microwave pulses. These pulses send signals down to
    each qubit using the qubit’s carrier frequency to ensure that the pulse operation
    will affect only the qubit that is tuned to that specific frequency. This way,
    if you are a kernel developer, for example, the ability to configure the pulses
    provides you with the ability to fine-tune the gate operations yourself rather
    than the default pulse shapes that are set up. These fine-tunings could be applied
    to not only single-gate operations but also two-qubit operations such as a CNOT
    gate.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin by illustrating how the hardware components are connected to the
    various pulse channels. IBM Quantum provides you with access to the machines in
    a way that is unique from most other quantum systems available on the cloud. Qiskit
    includes a `Pulse` library that allows you to control the pulses sent to the hardware
    that controls the device. Based on the `OpenPulse` documentation ([https://arxiv.org/abs/1809.03452](https://arxiv.org/abs/1809.03452)),
    it is tailored to provide the functionality to generate pulse signals used to
    control the qubits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the pulse functionality works, we’ll start by describing
    the four main components you will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: Instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulse libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will learn about the preceding components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed to the next section, we will use the following code, which
    will import everything we need to create, schedule, and trigger a pulse on a quantum
    device directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have imported the files needed, we will move on to the next section,
    about instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pulse programs**, or, as described in the Qiskit API documentation, **Schedules**,
    are a set of instructions used to describe the control of the electronic components
    of the quantum system. There are various instruction objects included within the
    `qiskit.pulse` library that have capabilities such as modulation of the frequency
    and phase of the pulse signal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`pulse`, in essence, provides you with the ability to specify the dynamics
    of each operation in a quantum circuit, so you can fine-tune each in a way to
    minimize as much noise as possible. `pulse` has various functionalities to give
    you access to the channels that send and receive information to and from each
    qubit, and includes libraries of pulses that you can use as a base and you can
    then modify each one accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also delay an instruction from triggering, similar to a `sleep()` function
    in most programming languages. Finally, it gives you the ability to trigger an
    operation and enable the acquire channel by playing and capturing the microwave
    pulse signals, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding each of the following is dependent on understanding *why* you
    would want to use these functions. For example, setting the frequency is important
    as each qubit is tuned to a specific frequency, so any pulse operation should
    be sent at the carrier frequency of the specified qubit; otherwise, the operation
    will not work, or, worse, it might operate on a qubit that you do not want to
    update. Now, let’s describe each instruction and its parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetFrequency(frequency, channel, name)`, where `frequency` is in Hz, `channel`
    indicates which channel the frequency will be applied to, and `name` is the name
    you can set for the instruction. The default *duration* of the `SetFrequency`
    instruction is `0`. This very simply sets the frequency of the channel so that
    the pulses applied to the channel are tuned accordingly. If you do not specify
    a frequency when creating a pulse for a specific qubit, the default frequency
    for the qubit on the drive channel will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShiftPhase(phase, channel, name)`, where `phase` is the rotation angle in
    radians, `channel` indicates the channel that the frequency will be applied to,
    and the `name` parameter is the name you can set for the instruction. This instruction
    shifts the phase of the pulse by increasing its rotation angle by the provided
    amount in radians.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delay(duration, channel, name)`, where `duration` is the length of time in
    the delay (in the documentation, this is also referred to as *time step*, or `dt`),
    `channel` indicates which channel the delay will be applied to, and `name` indicates
    the name that you can set for the instruction. The `Delay` instruction is generally
    used to align pulses with respect to other pulse instructions. For example, if
    you wish to send two pulses and include a time gap between the pulses, you can
    specify the time gap by adding a `Delay` instruction with the desired time gap
    amount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Play(pulse, channel, name)`, where `pulse` is the pulse waveform you wish
    to apply, `channel` indicates which channel the pulse will be applied to, and
    `name` is the name you can set for the instruction. The `Play` instruction will
    apply the pulse output to the channel specified, where the pulse output was previously
    modulated using both the `SetFrequency` and `SetPhase` instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Acquire(duration, channel, mem_slot, reg_slot, kernel, discriminator, name)`,
    where `duration` is the number of time steps (dt) to acquire the data information,
    `channel` indicates which channel to acquire the data from, `mem_slot` is the
    classical memory slot in which to store each of the returned results, and `reg_slot`
    is the register slot used to store the classified and readout results. The `kernel`
    parameter is used to integrate the raw data for each slot, `discriminator` is
    used to classify kernelled IQ data into a `0` or `1` result, and `name` indicates
    the name you can set for the instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each instruction includes an operator that will be applied to the specified
    channels stated. The operators include pulse modulators, delays, and readouts
    from channels. Before we get into discussing channels, let’s create some pulses
    using the Qiskit Pulse library.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pulses and Pulse libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each microwave pulse is created by an **arbitrary waveform generator** (**AWG**),
    which specifies the frequency and phase of the pulse signal output. The frequency
    and phase are set by the `SetFrequency` and `ShiftPhase` instructions we learned
    about earlier, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qiskit Pulse provides a nice library of waveforms, which can simplify creating
    the pulses we need to operate on a qubit. The following are the types of available
    waveforms at the time of writing this chapter: `Constant`, `Drag`, `Discrete`,
    `Gaussian`, `GaussianSquare`, and `Waveform`. Each of these waveforms has a specific
    feature, for example, `Drag` is used to reduce leakage to the ![](img/B18420_07_006.png)
    state of the qubit and keeps it confined to the ![](img/B18420_07_007.png) and
    ![](img/B18420_07_008.png) states.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the waveforms provided in the Pulse library has a specific feature.
    We’ll cover a few of them below, but I would encourage you to read more in the
    Qiskit documentation, [https://docs.quantum.ibm.com/api/qiskit/pulse](https://docs.quantum.ibm.com/api/qiskit/pulse),
    which includes a detailed description of each.
  prefs: []
  type: TYPE_NORMAL
- en: '`Waveform` allows you to define your own pulse by providing an array of complex
    value samples as an argument. These samples each have a predefined time step,
    `dt`, which is the time period played for each and varies based on the specified
    backend. The following code is an example of a sample pulse for a simple sine
    waveform of 128 samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is the result of creating our sample pulse of a sine
    waveform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Sample pulse of a sine waveform'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now try generating one of the waveforms from the Pulse library.
  prefs: []
  type: TYPE_NORMAL
- en: The Pulse library has an array of different waveforms, such as `Gaussian`, `GaussianSquare`,
    `Constant`, and `Drag` (just to name a few). Each has its own distinct shape that
    we can leverage to fine-tune any pulse we wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `GaussianSquare` pulse, which is simply a square pulse with
    Gaussian edges on both ends, rather than squared-off edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following pulse, where the duration (`dt`)
    is `128`, the amplification max is at `1`, sigma is set to `2`, and the width
    of the pulse peak is `112` (`dt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B18420_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Gaussian square pulse'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the parameters available to us allow adjustments to the waveform
    in multiple ways. In the `Gaussian Square` waveform sample, we were able to adjust
    the amplitude, width, and its sigma, which therefore provides us with more control
    over the creation of the pulse, which could potentially reduce noise or any other
    affects that could come from a standard pulse that is created based on the quantum
    circuit instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can create pulses, let’s learn about the channels that we will transmit
    these pulses through.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging channels to transmit and receive instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of channels in Qiskit Pulse:'
  prefs: []
  type: TYPE_NORMAL
- en: The first type is the **Pulse channel**, which transmits the generated pulses
    to the quantum device. These include the **Drive channel**, **Control channel**,
    and the **Measure channel**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other type of channel is the **Acquisition channel**. Currently, this type
    only includes the **Acquire channel**, which is the channel that receives pulses
    from the quantum device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All channels only have one parameter, the index, which is used to assign the
    channel. The following list describes all the channels:'
  prefs: []
  type: TYPE_NORMAL
- en: The Drive channel is the channel used to transmit the pulse signal down to the
    qubit to execute the gate operation. When displayed, it has the prefix **D**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Control channel is commonly used on multi-qubit gate operations such as
    `Control-Not`, `Control-Phase`, and more. They generally provide auxiliary control
    over the qubit via the drive channel. When displayed, it has the prefix **U**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Measure channel transmits a measurement stimulus pulse to the qubit for
    a readout from the qubit. When displayed, it has the prefix **M**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Acquire channel is the only channel that is used to receive information
    from the device. It is used to collect data from the quantum device. When displayed,
    it has the prefix **A**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have learned that pulse programs are instructions that are made up
    of waveform pulses that are constructed to perform gate operations on quantum
    devices. We also covered the different channels available to transmit and receive
    information to and from quantum devices. With this information, we can now look
    at how to schedule these instructions to be executed on a real device.
  prefs: []
  type: TYPE_NORMAL
- en: Generating and executing schedules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pulse schedules are a set of instructions sent through specified channels to
    be executed on a quantum device. The `Schedule` class can be made up of instructions
    or a combination of other schedules. That means you can create a schedule with
    one of the instructions we learned about earlier, or you can combine or append
    schedules to existing schedules. We will do all this in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use what we have learned so far in this chapter to build a schedule.
    First, we will construct a schedule and insert a pulse from the Pulse library
    into it that will be triggered at `time = 0`. Then, we will create another schedule
    and insert a different pulse from the Pulse library into it. The second one will
    be appended to the first schedule and then shifted, so it is triggered at some
    time after the first pulse has completed. We’ll then execute the schedule on a
    quantum device and get back its result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue using the notebook we have been using so far to create our first
    schedule, and name it `schedule_1`. We’ll also use the `Play` instruction to insert
    the Gaussian square pulse we generated earlier and assign the schedule to drive
    channel `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result we see is that our Gaussian square pulse was added to the schedule
    starting at `time = 0`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18420_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Schedule 1: Gaussian square pulse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s continue and create the second schedule, `schedule_2`, with the
    sample pulse we generated earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following schedule: note the duration of our sample pulse
    is 64, whereas the Gaussian square pulse has a duration of 128:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, histogram  Description automatically generated](img/B18420_07_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Schedule 2: sample (sine waveform) pulse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a third schedule, `schedule_3`, and we will construct
    it by inserting both `schedule_1` and `schedule_2` together with a gap of 5 time
    steps (`dt`) in between the two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is a combination of `schedule_1` starting at `time = 0` and then
    we insert `schedule_2` starting at 5 time units after the first schedule. Note
    the use of the `duration` variable to ensure that the pulse does not overlap with
    the first. Schedule 3, therefore, has a total time of the two pulses plus the
    5 time units in between the two, totaling 197, as the following figure illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_07_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Schedule 3, combining schedules 1 and 2 with a 5 time unit difference
    in between'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are other ways to combine pulses. If you want to combine the
    two schedules without a gap in between, then you can simply use the `append` function
    to combine them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code results in the following output. Note how the total time
    units are equal to the total time units of both pulses, without the additional
    5 time units in between the two pulses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing chart  Description automatically generated](img/B18420_07_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Schedule 3, appending two schedules without a time gap in between'
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we were able to generate a pulse, apply it to an instruction,
    and schedule it to run on a specified channel to manipulate the qubit. Generating
    a set of pulses allows you to get an understanding of how we can schedule two
    separate gate operations to a single qubit sequentially on the specified channel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see how we can find the status of our quantum circuits
    once they have been submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Job component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last component we will cover is the `Job` component. The `Job` component
    is basically an instance of the circuit that has been executed on the backend
    and contains information from the executed circuit(s), such as results, which
    backend, duration, etc. What that means is that once you send the circuit to the
    backend to get executed, the backend will generate the `Job` instance and append
    information about the job: information such as status, result, job identifier,
    and so on. The following is a list of the available `Job` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backend()` provides the backend that the job is running on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status()` provides the status of the job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result()` provides the job result after execution is completed on the backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cancel()` provides the ability to cancel the job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`job_id()` provides the alphanumeric job identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll reuse the circuit we created earlier, `transpiled_qc`, for simplicity
    so we can review the `Job` object and its functions. Let’s start by importing
    the `job_monitor` class and launching the Qiskit job watcher, followed by running
    the circuit on a backend and running the job monitor to see the status of the
    job in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will execute a circuit and the following will display the
    details of the `Job` object; for example, it will indicate whether the job is
    in a queue, running, or completed successfully. In this case, the result of the
    status is that the job has successfully run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Other information can also be pulled from the `Job` object. The **Job ID**
    is the unique identifier of the job that is being run. This ID can be very useful
    for various reasons, such as tracking the results, and should you have an issue
    with a job running on the backend, you can reference the job ID when speaking
    to the support team, which will help the team find the job. The status and results
    can be called explicitly using the functions `status()` and `result()`, respectively.
    The `result` object provides all the information resulting from running the job
    on the backend. Let’s run these functions to review the results of the job we
    just ran:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of each of the functions in the code snippet are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where we can pull specific result information that we can use to visualize
    the status of the Job. For example, the following code will extract the counts
    from the results and display the counts in a histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will produce the following histogram which pertains to the results
    from each shot as a total of probabilities. (quasi-probabilities) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The histogram will then display as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_07_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: The probability results as a histogram'
  prefs: []
  type: TYPE_NORMAL
- en: The `job` object helps us get details regarding the circuit that we have sent
    to run on a quantum system. This information can be used to provide the results
    back to our application and visualize the results accordingly. It also provides
    the status and other information that we can use to keep track of the job and
    share details about the results with others, such as support teams, so they can
    easily identify jobs on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered just some of the many features included in the Qiskit
    library. We reviewed creating quantum circuits, as well as executing them on the
    simulator and real quantum devices. We also reviewed how to concatenate circuits
    so as to enable you to combine and create composite circuits, which included binding
    parameters to enable adjustments to various gates.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how the circuits are converted into pulses using Qiskit’s Pulse library
    and created schedules, which are programs that send pulse information via various
    channels down to the hardware, and looked at how to obtain the details of the
    job that was running on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover techniques to optimize your quantum circuits
    by reviewing the features available via pass managers and optimizers. We’ll also
    learn various ways to visualize your quantum circuits and monitor your jobs as
    they are executed on the quantum backend systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Construct a random quantum circuit with a width of 4 and a depth of 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another random quantum circuit with the same width as the circuit you
    created in *Question 1* and concatenate it so that it is added before the random
    quantum circuit you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the circuit properties of the concatenated quantum circuit from *Question
    3* and specify the total number of operators, not including any measurement operators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a circuit with a parameterized R[Y] gate that would rotate by an angle
    of ![](img/B18420_07_009.png).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_7.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265932.png)'
  prefs: []
  type: TYPE_IMG
