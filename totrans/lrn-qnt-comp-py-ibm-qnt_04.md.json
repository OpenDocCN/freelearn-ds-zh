["```py\n# Load helper file\n%run helper_file_1.0.ipynb\n# Create a simple circuit\nqc = QuantumCircuit(1,1)\n# Get the state vector of the circuit\nstateVectorResult = Statevector(qc)\n# Display the state vector results onto a Bloch sphere\nplot_bloch_multivector(stateVectorResult) \n```", "```py\n    # Place the qubit in a superposition state\n    # by adding a Hadamard (H) gate\n    qc.h(0)\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Get the state vector of the circuit\n    stateVectorResult = Statevector(qc)\n    # Display the Bloch sphere\n    plot_bloch_multivector(stateVectorResult) \n    ```", "```py\n    #Reset our quantum circuit\n    qc = QuantumCircuit(1)\n    #Rotate the qubit from 0 to 1 using the X (NOT) gate\n    qc.x(0)\n    #Add a Hadamard gate\n    qc.h(0)\n    #Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Recreate the circuit with a single qubit and classical bit\n    qc = QuantumCircuit(1,1)\n    # Add a Hadamard gate\n    qc.h(0) \n    ```", "```py\n    # Create a measurement circuit with 1 qubit and 1 bit\n    measurement_circuit = create_circuit(1,True)\n    # Concatenate the circuits together\n    full_circuit = qc.compose(measurement_circuit)\n    # Draw the full circuit\n    full_circuit.draw(output='mpl') \n    ```", "```py\n    # Run the quantum circuit and obtain results\n    transpiled_QC, result, stateVectorResult = simulate_on_sampler(full_circuit, None, None)\n    counts = result[0].data.c.get_counts()\n    print(counts) \n    ```", "```py\n{'1': 478, '0': 546} \n```", "```py\n    #Create a circuit with 2 qubits and 2 classical bits\n    qc = QuantumCircuit(2,2)\n    #Add an H gate to each\n    qc.h(0)\n    qc.h(1)\n    #Measure the qubits to the classical bit\n    qc.measure([0,1],[0,1])\n    #Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Run the quantum circuit\n    transpiledQC, result, stateVectorResult = simulate_on_sampler(qc, None, None)\n    #Obtain the results and display on a histogram\n    counts = result[0].data.c.get_counts()\n    plot_histogram(counts) \n    ```", "```py\n# Create a circuit with 2 qubits and 2 classic bits\nqc = QuantumCircuit(2,2)\n# Add an H gate to just the first qubit\nqc.h(0)\n# Add the CNOT gate to entangle the two qubits,\n# where the first qubit is the control, and the\n# second qubit is the target.\nqc.cx(0,1)\n# Measure the qubits to the classical bit\nqc.measure([0,1],[0,1])\n# Draw the circuit\nqc.draw(output='mpl') \n```", "```py\n    # Run the quantum circuit\n    transpiledQC, result = run_qasm_circuit(qc, None, None)\n    counts = result.get_counts(qc)\n    plot_distribution(counts) \n    ```", "```py\n    # State 1: |/+>\n    state1 = QuantumCircuit(2)\n    # Initialize input to |0,0>\n    state1.barrier() \n    ```", "```py\n    # Prepare the Bell state\n    state1.h(0) \n    ```", "```py\n    state1.cx(0,1) \n    ```", "```py\n    state1.measure_all()\n    state1.draw(output='mpl') \n    ```", "```py\n    # Execute the Bell state |/+>\n    transpiledQC, result, stateVectorResult = simulate_on_sampler(state1, None, None)\n    # Obtain the results and display on a histogram\n    counts = result[0].data.meas.get_counts()\n    plot_histogram(counts) \n    ```", "```py\n# State 2: |/+>\nstate2 = QuantumCircuit(2)\n# Initialize input state to |1,0>\nstate2.x(1)\nstate2.barrier()\n# Prepare the Bell state\nstate2.h(0)\nstate2.cx(0,1)\nstate2.measure_all()\nstate2.draw(output='mpl') \n```", "```py\n    # Execute the Bell state |/+>\n    transpiledQC, result, stateVectorResult = simulate_on_sampler(state1, None, None)\n    # Obtain the results and display on a histogram\n    counts = result[0].data.meas.get_counts()\n    plot_histogram(counts) \n    ```"]