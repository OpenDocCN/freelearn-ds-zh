- en: Chapter 14. Comprehensive Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we present some comprehensive and longer examples together
    with a brief introduction to the theoretical background and their complete implementation.
    By this, we want to show you how the concepts defined in this book are used in
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Polynomials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will demonstrate the power of the Python constructs presented so far
    by designing a class for polynomials. We will give some theoretical background,
    which leads us to a list of requirements, and then we will give the code, with
    some comments.
  prefs: []
  type: TYPE_NORMAL
- en: Note, this class differs conceptually from the class `numpy.poly1d`.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretical background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A polynomial: *p*(*x*) *= a[n] x ^n + a[n-1] x^(n-1)*+…+ *a*[1]*x + a*[0 ]is
    defined by its degree, its representation, and its coefficients. The polynomial
    representation shown in the preceding equation is called a monomial representation.
    In this representation, the polynomial is written as a linear combination of monomials, *x^i*.
    Alternatively, the polynomial can be written in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton representation with the coefficients *c[i]* and *n* points, *x[0]*,
    …, *x[n-1]*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p*(*x*) *= c*[0] + *c*[1] (*x - x*[0]) *+ c*[2] (*x - x*[0])(*x-x*[1]) + ...
    + *c[n]*(*x - x[0]*) … (*x - x[n]*[-1])'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lagrange representation with the coefficients *y[i]*and *n*+1 points, *x*[0],
    … , *x[n]*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p*(*x*) = *y*[0] *l*[0](*x*) + *y*[1] *l*[1](*x*) + … + *y[n] l[n]*(*x*)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with the cardinal functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Theoretical background](img/B05511_14_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: There are infinitely many representations, but we restrict ourselves here to
    these three typical ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polynomial can be determined from interpolation conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*(*x[i]*) = *y*[i] *i* = 0, … , *n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'with the given distinct values *x[i]* and arbitrary values *y[i]* as input.
    In the Lagrange formulation, the interpolation polynomial is directly available,
    as its coefficients are the interpolation data. The coefficients for the interpolation
    polynomial in Newton representation can be obtained by a recursion formula, called
    the divided differences formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c[i]*[,0] = *y[i,]*and'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theoretical background](img/B05511_14.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one sets ![Theoretical background](img/cic0.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'The coefficients of the interpolation polynomial in monomial representation
    are obtained by solving a linear system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theoretical background](img/B05511_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A matrix that has a given polynomial *p* (or a multiple of it) as its characteristic
    polynomial is called a companion matrix. The eigenvalues of the companion matrix
    are the zeros (roots) of the polynomial. An algorithm for computing the zeros
    of *p* can be constructed by first setting up its companion matrix and then computing
    the eigenvalues with `eig`. The companion matrix for a polynomial in Newton representation
    reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theoretical background](img/B05511_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now formulate some programming tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a class called `PolyNomial` with the `points`, `degree`, `coeff`, and
    `basis` attributes, where:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`points` is a list of tuples (*x[i], y[i]*)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`degree` is the degree of the corresponding interpolation polynomial'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coeff` contains the polynomial coefficients'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`basis` is a string stating which representation is used'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the class with a method for evaluating the polynomial at a given point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the class with a method called `plot` that plots the polynomial over
    a given interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method called `__add__` that returns a polynomial that is the sum of
    two polynomials. Be aware that only in the monomial case the sum can be computed
    by just summing up the coefficients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the coefficients of the polynomial represented
    in a monomial form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the polynomial's companion matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the zeros of the polynomial by computing the eigenvalues
    of the companion matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that computes the polynomial that is the *i*^(th) derivative
    of the given polynomial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method that checks whether two polynomials are equal. Equality can be
    checked by comparing all coefficients (zero leading coefficients should not matter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The polynomial class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now design a polynomial base class based on a monomial formulation of
    the polynomial. The polynomial can be initialized either by giving its coefficients
    with respect to the monomial basis or by giving a list of interpolation points,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__` method of the new class uses the `**args` construction as discussed
    in section *Parameters and arguments* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions*. If no arguments are given, a zero polynomial is assumed. If the polynomial
    is given by interpolation points the method used to compute the coefficients by
    solving a Vandermonde system is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If *k* coefficients are given also *k* interpolation points are constructed
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `self(x)` command does a polynomial evaluation, which is done by providing
    a  method, `__call__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '(Refer example in section *Special methods* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes.*) Here, this method uses the command `polyval`. As a next step, we just
    add for convenience two methods, which we decorate with the `property` decorator
    (refer section *Functions as decorators* in [Chapter 7](ch07.html "Chapter 7. Functions"),
    *Functions)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain what is going on here. We define a method to extract the *x*-values
    of the data, which were used to define the polynomial. Similarly, a method to
    extract the *y*-values of the data is defined. With the `property` decorator,
    the result of calling the method is presented as if it were just an attribute
    of the polynomial. There are two coding alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a method call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives access to the *x*-values by the call: `p.x()`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use the `property` decorator. It us to access the *x*-values simply by this
    statement:  `p.x`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We choose the second variant. It is always a good practice to define a `__repr__`
    method (refer section *Attributes* in [Chapter 8](ch08.html "Chapter 8. Classes"),
    *Classes*). At least for a quick check of the results, this method is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We now provide a method for plotting the polynomial, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of the `vectorize` command (refer section *Functions acting on
    arrays* in [Chapter 4](ch04.html "Chapter 4. Linear Algebra – Arrays"), *Linear
    algebra - Arrays*. The `__call__` method is specific to the monomial representation
    and has to be changed if a polynomial is represented in another basis. This is
    also the case for the computation of the polynomial''s companion matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the companion matrix is available, the zeros of the polynomial are given
    by the eigenvalues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For this end the function `eigvals` has to be imported from `scipy.linalg` first.
    Let's give some usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a polynomial instance from the given interpolation points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The polynomial''s coefficients with respect to the monomial basis are available
    as an attribute of `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to the polynomial ![The polynomial class](img/B05511_14_1.jpg)
    . The default plot of the polynomial, obtained by `p.plot(-3.5,3.5)`, results
    in the following figure (*Figure 14.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The polynomial class](img/polyplot.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Result of the polynomial plot method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we compute the zeros of the polynomial, which in this case are two
    real numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be verified by evaluating the polynomial at these points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Newton polynomial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NewtonPolyNomial` class defines a polynomial described with respect to
    the Newton basis. We let it inherit some common methods from the polynomial base
    class, for example, `polynomial.plot`, `polynomial.zeros`, and even parts of the
    `__init__` method, by using the `super` command (refer to section *Subclassing
    and Inheritance* in [Chapter 8](ch08.html "Chapter 8. Classes"), *Classes*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the interpolation points are given, the computation of the coefficients
    is performed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we used divided differences for computing the Newton representation of
    the polynomial, which is programmed as a generator here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us briefly check how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` function executes the `__repr__` method of the base class and returns
    the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The polynomial evaluation is different from the corresponding method of the
    base class. The `Newton.PolyNomial.__call__` method needs to override `Polynomial.__call__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we give the code for the companion matrix, which overrides the corresponding
    method of the parent class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of Boolean arrays. The exercises will further build on this foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Spectral clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting application of eigenvectors is for clustering data. Using the
    eigenvectors of a matrix derived from a distance matrix, unlabelled data can be
    separated into groups. Spectral clustering methods get their name from the use
    of the spectrum of this matrix. A distance matrix for *n* elements (for example,
    the pairwise distance between data points) is an n × n symmetric matrix. Given
    such an n × n distance matrix *M* with distance values *m[ij]*, we can create
    the Laplacian matrix of the data points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spectral clustering](img/distance-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, I is the identity matrix and *D* is the diagonal matrix containing the
    row sums of *M*,
  prefs: []
  type: TYPE_NORMAL
- en: '![Spectral clustering](img/B05511_14_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data clusters are obtained from the eigenvectors of *L*. In the simplest
    case of data points with only two classes, the first eigenvector (that is, the
    one corresponding to the largest eigenvalue) is often enough to separate the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example for simple two-class clustering. The following code creates
    some 2D data points and clusters them based on the first eigenvector of the Laplacian
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The eigenvector corresponding to the largest eigenvalue gives the grouping
    (for example, by thresholding at *0*) and can be shown with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure (*Figure 14.2*) shows the result of spectral clustering
    of a simple two-class dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spectral clustering](img/cluster1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: shows result of simple two-class clustering'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more difficult datasets and more classes, one usually takes the *k* eigenvectors
    corresponding to the *k* largest eigenvalues and then clusters the data with some
    other method, but using the eigenvectors instead of the original data points.
    A common choice is the *k*-means clustering algorithm, which is the topic of the
    next example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The eigenvectors are used as input to *k*-means clustering, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we computed the eigenvectors here using the singular value decomposition, `sl.svd`.
    As *L* is symmetric, the result is the same as if we would have used `sl.eig`,
    but the eigenvectors come already ordered corresponding to the ordering of the
    eigenvalues. We also used throw-away variables. `svd` returns a list with three
    arrays, the left and right singular vectors `U`, `V`, and the singular values
    `S`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we do not need `U` and `S` here, we can throw them away when unpacking the
    return value of `svd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be plotted using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows the result of spectral clustering of a simple *multiclass
    dataset:*
  prefs: []
  type: TYPE_NORMAL
- en: '![Spectral clustering](img/spectral_4class.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: An example of spectral clustering of a simple four class dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving initial value problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will consider the mathematical task of numerically solving
    a system of ordinary equations for given initial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y''*(*t*) *= f*(*t, y*) *y*(*t*[0]) *= y*[0]∈ ℝ*^n*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution of this problem is a function *y*. A numerical method aims at
    computing good approximations, *y[i]*≈ *y*(*t[i]*) at discrete points, the communications
    points *t[i]*, within the interval of interest [*t[0], t*[e]]. We collect the
    data that describes the problem in a class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The differential equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving initial value problems](img/B05511_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: describes a mathematical pendulum; *y[1]* describes its angle with respect to
    the vertical axis, *g* is the gravitation constant, and *l* is its length. The
    initial angle is π/2 and the initial angular velocity is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pendulum problem becomes an instance of the problem class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There might be different views on the problem at hand, leading to a different
    design of the class. For example, one might want to consider the interval of independent
    variables as a part of a solution process instead of the problem definition. The
    same holds when considering initial values. They might, as we did here, be considered
    a part of the mathematical problem, while other authors might want to allow variation
    of initial values by putting them as a part of the solution process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution process is modeled as another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue by first defining two discretization schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit **Euler** method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Classical **Runge-Kutta four-stage** method (**RK4**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can create instances to obtain the corresponding discretized
    versions of the pendulum ODE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve the two discrete models and plot the solution and the angle difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![Solving initial value problems](img/ivp_example.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure14.4: Pendulum simulation with the explicit Euler method and comparison
    with the results of the more accurate Runge–Kutta 4 method'
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile discussing alternative class designs. What should be put in
    separate classes, what should be bundled into the same class?
  prefs: []
  type: TYPE_NORMAL
- en: We strictly separated the mathematical problem from the numerical method. Where
    should the initial values go? Should they be part of the problem or part of the
    solver? Or should they be left as input parameter for the solve method of the
    solver instance? One might even design the program so that it allows several possibilities.
    The decision to use one of these alternatives depends on the future use of this
    program. Looping over various initial values as in parameter identification would
    be eased by leaving the initial values as input parameters for the solve method.
    On the other hand, simulating different model variants with the same initial values
    would motivate to couple the initial values to the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We presented for simplicity only solvers with constant and given step size.
    Is the design of the `IVPsolver` class appropriate for a future extension of adaptive
    methods, where a tolerance rather than a step size is given?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We suggested earlier to use a generator construction for the stepping mechanism.
    Adaptive methods need to reject steps from time to time. Is this need conflicting
    with the design of the stepping mechanism in `IVPsolver.onestepper`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We encourage you to check the design of the two SciPy tools for solving initial
    values, namely `scipy.integrate.ode` and `scipy.integrate.odeint`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of what we explained in this book is bundled into the three longer examples
    of this chapter. They mimic code development and give prototypes, which you are
    encouraged to alter and confront with your own ideas.
  prefs: []
  type: TYPE_NORMAL
- en: You saw that code in scientific computing can have its own flavor due to its
    strong relation with mathematically defined algorithms and that it is often wise
    to keep the relationship between code and formula visible. Python has techniques
    for this, as you have seen.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1** → Implement a method `__add__`, which constructs a new polynomial
    *p+q* by adding two given polynomials *p* and *q*. In monomial form, polynomials
    are added by just adding the coefficients, whereas in Newton form, the coefficients
    depend on the abscissa *x[i]* of the interpolation points. Before adding the coefficients
    of both polynomials, the polynomial *q* has to get new interpolation points with
    the property that their abscissa *x[i]* coincides with those of *p* and the method `__changepoints__` has
    to be provided for that. It should change the interpolation points and return
    a new set of coefficients.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 2** → Write conversion methods to convert a polynomial from Newton form
    into monomial form and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 3** → Write a method called `add_point` that takes a polynomial *q* and
    a tuple *(x,y)* as parameters and returns a new polynomial that interpolates `self.points`
    and *(x,y)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Write a class called `LagrangePolynomial` that implements polynomials
    in Lagrange form and inherits as much as possible from the polynomial base class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5** → Write tests for the polynomial class.'
  prefs: []
  type: TYPE_NORMAL
