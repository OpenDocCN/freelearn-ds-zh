- en: Chapter 8. Polishing Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：数据精炼
- en: When working with data, you will usually find that it may not always be perfect
    or clean in the means of missing values, outliers and similar anomalies. Handling
    and cleaning imperfect or so-called dirty data is part of every data scientist's
    daily life, and even more, it can take up to 80 percent of the time we actually
    deal with the data!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理数据时，你通常会发现数据可能并不总是完美的或干净的，在缺失值、异常值和类似异常方面。处理和清理不完美或所谓的脏数据是每位数据科学家日常生活中的一个部分，甚至更多，这可能会占用我们实际处理数据时间的多达80%！
- en: 'Dataset errors are often due to the inadequate data acquisition methods, but
    instead of repeating and tweaking the data collection process, it is usually better
    (in the means of saving money, time and other resources) or unavoidable to polish
    the data by a few simple functions and algorithms. In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集错误通常是由于数据采集方法不充分，但与其重复和调整数据采集过程，通常更好（在节省金钱、时间和其他资源方面）或不可避免的是通过几个简单的函数和算法来精炼数据。在本章中，我们将涵盖：
- en: Different use cases of the `na.rm` argument of various functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同函数中`na.rm`参数的不同用法
- en: The `na.action` and related functions to get rid of missing data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于去除缺失数据的`na.action`和相关函数
- en: Several packages that offer a user-friendly way of data imputation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个提供用户友好数据插补方式的软件包
- en: The `outliers` package with several statistical tests for extreme values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含多个用于极端值统计测试的`outliers`软件包
- en: How to implement Lund's outlier test on our own as a brain teaser
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何作为脑筋急转弯自己实现Lund的异常值测试
- en: Referring to some robust methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考一些稳健的方法
- en: The types and origins of missing data
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺失数据的类型和来源
- en: First, we have to take a quick look at the possible different sources of missing
    data to identify why and how we usually get missing values. There are quite a
    few different reasons for data loss, which can be categorized into 3 different
    types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须快速查看可能的缺失数据的不同来源，以确定我们通常如何以及为什么得到缺失值。数据丢失的原因有很多，可以分为3种不同类型。
- en: 'For example, the main cause of missing data might be a malfunctioning device
    or the human factor of incorrectly entering data. **Missing Completely at Random**
    (**MCAR**) means that every value in the dataset has the same probability of being
    missed, so no systematic error or distortion is to be expected due to missing
    data, and nor can we explain the pattern of missing values. This is the best situation
    if we have `NA` (meaning: no answer, not applicable or not available) values in
    our data set.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，缺失数据的主要原因可能是设备故障或人为错误地输入数据。**完全随机缺失**（MCAR）意味着数据集中的每个值都有相同的概率被遗漏，因此我们不应该期望由于缺失数据而出现系统错误或扭曲，也无法解释缺失值的模式。如果我们数据集中有`NA`（意为：无回答、不适用或不可用）值，这是最好的情况。
- en: But a much more frequent and unfortunate type of missing data is **Missing at
    Random** (**MAR**) compared to MCAR. In the case of MAR, the pattern of missing
    values is known or at least can be identified, although it has nothing to do with
    the actual missing values. For example, one might think of a population where
    males are more loners or lazier compared to females, thus they prefer not to answer
    all the questions in a survey – regardless of the actual question. So it's not
    that the males are not giving away their salary due to the fact that they make
    more or less compared to females, but they tend to skip a few questions in the
    questionnaire at random.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但与完全随机缺失（MCAR）相比，更常见且不幸的一种缺失数据类型是**随机缺失**（MAR）。在MAR的情况下，缺失值的模式是已知的或至少可以识别的，尽管它与实际的缺失值无关。例如，可以想象一个男性比女性更孤独或更懒惰的群体，因此他们可能不愿意回答调查中的所有问题——无论实际问题是怎样的。所以并不是因为男性比女性赚得多或少，他们只是倾向于随机跳过问卷中的几个问题。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This classification and typology of missing data was first proposed by Donald
    B. Rubin in 1976 in his *Inference and Missing Data*, published in *Biometrika
    63(3): 581—592*, later reviewed and extended in a book jointly written by *Roderick
    J. A. Little* (2002): *Statistical Analysis with Missing Data*, *Wiley* – which
    is well worth of reading for further details.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '这种缺失数据的分类和类型学最初是由Donald B. Rubin在1976年提出的，他在《Biometrika 63(3): 581—592》上发表的《Inference
    and Missing Data》一文中进行了阐述，后来在Roderick J. A. Little（2002年）合著的书中进行了回顾和扩展：《Statistical
    Analysis with Missing Data》，Wiley – 这本书对于深入了解细节非常值得一读。'
- en: And the worst scenario would be **Missing Not at Random** (**MNAR**), where
    data is missing for a specific reason that is highly related to the actual question,
    which classifies missing values as nonignorable non-response.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最糟糕的情况是**缺失非随机**（**MNAR**），其中数据缺失是由于与实际问题高度相关的特定原因，将缺失值分类为不可忽视的非响应。
- en: This happens pretty often in surveys with sensitive questions or due to design
    flaws in the research preparation. In such cases, data is missing due to some
    latent process going on in the background, which is often the thing we wanted
    to come to know better with the help of the research – which can turn out to be
    a rather cumbersome situation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含敏感问题的调查或研究准备设计缺陷的情况下，这种情况相当常见。在这种情况下，数据缺失是由于背景中某些潜在过程导致的，这通常是我们在研究帮助下想要更好地了解的事情——这可能会变成一个相当麻烦的情况。
- en: 'So how can we resolve these problems? Sometimes it''s relatively easy. For
    example, if we have lot of observations, MCAR is not a real problem at all due
    to the law of large numbers, as the probability of having missing value(s) is
    the same for each observation. We basically have two options to deal with unknown
    or missing data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这些问题呢？有时这相对简单。例如，如果我们有很多观测值，由于大数定律，MCAR根本不是问题，因为每个观测值缺失值的概率是相同的。我们基本上有两个选项来处理未知或缺失的数据：
- en: Removing missing values and/or observations
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除缺失值和/或观测值
- en: Replacing missing values with some estimates
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一些估计值替换缺失值
- en: Identifying missing data
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别缺失数据
- en: The easiest way of dealing with missing values, especially with MCAR data, is
    simply removing all the observations with any missing values. If we want to exclude
    every row of a `matrix` or `data.frame` object which has at least one missing
    value, we can use the `complete.cases` function from the `stats` package to identify
    those.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缺失值的最简单方法，特别是对于MCAR数据，就是简单地删除任何有缺失值的观测值。如果我们想排除`matrix`或`data.frame`对象中至少有一个缺失值的每一行，我们可以使用`stats`包中的`complete.cases`函数来识别这些行。
- en: 'For a quick start, let''s see how many rows have at least one missing value:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速入门，让我们看看有多少行至少有一个缺失值：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is around 1.5 percent of the quarter million rows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约是25万行中的1.5%：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s see what the distribution of `NA` looks like within different columns:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`NA`在不同列中的分布情况：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By-passing missing values
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过缺失值
- en: 'So it seems that missing data relatively frequently occurs with the time-related
    variables, but we have no missing values among the flight identifiers and dates.
    On the other hand, if one value is missing for a flight, the chances are rather
    high that some other variables are missing as well – out of the overall number
    of 3,622 cases with at least one missing value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，似乎缺失数据相对频繁地出现在与时间相关的变量中，但在航班标识符和日期中我们没有缺失值。另一方面，如果一个航班的某个值缺失，那么其他一些变量也缺失的可能性相当高——在总共3,622个至少有一个缺失值的案例中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Okay, let's see what we have done here! First, we have called the `apply` function
    to transform the values of `data.frame` to `0` or `1`, where `0` stands for an
    observed, while `1` means a missing value. Then we computed the correlation coefficients
    of this newly created matrix, which of course returned a lot of missing values
    due to fact that some columns had only one unique value without any variability,
    as shown in the warning message. For this, we had to specify the `na.rm` parameter
    to be `TRUE`, so that the `mean` function would return a real value instead of
    an `NA`, by removing the missing values among the correlation coefficients returned
    by the `cor` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看我们在这里做了什么！首先，我们调用了`apply`函数将`data.frame`的值转换为`0`或`1`，其中`0`表示观测值，而`1`表示缺失值。然后我们计算了这个新创建矩阵的相关系数，由于一些列只有一个唯一值且没有任何变化，因此返回了大量的缺失值，正如警告信息所示。为此，我们必须将`na.rm`参数指定为`TRUE`，这样`mean`函数就会返回一个真实值而不是`NA`，通过删除`cor`函数返回的相关系数中的缺失值。
- en: 'So one option is the heavy use of the `na.rm` argument, which is supported
    by most functions that are sensitive to missing data—to name a few from the `base`
    and `stats` packages: `mean`, `median`, `sum`, `max` and `min`.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个选择是大量使用`na.rm`参数，这是大多数对缺失数据敏感的函数所支持的——以下是从`base`和`stats`包中的一些例子：`mean`、`median`、`sum`、`max`和`min`。
- en: To compile the complete list of functions that have the `na.rm` argument in
    the base package, we can follow the steps described in a very interesting SO answer
    located at [http://stackoverflow.com/a/17423072/564164](http://stackoverflow.com/a/17423072/564164).
    I found this answer motivating because I truly believe in the power of analyzing
    the tools we use for analysis, or in other words, spending some time on understanding
    how R works in the background.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译包含在基础包中具有 `na.rm` 参数的所有函数的完整列表，我们可以遵循位于 [http://stackoverflow.com/a/17423072/564164](http://stackoverflow.com/a/17423072/564164)
    的一个非常有趣的 SO 答案中描述的步骤。我发现这个答案很有启发性，因为我真正相信分析我们用于分析的工具的力量，换句话说，花些时间理解 R 在后台是如何工作的。
- en: 'First, let''s make a list of all the functions found in `baseenv` (the environment
    of the `base` package) along with the complete function arguments and body:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出 `baseenv`（`base` 包的环境）中找到的所有函数，以及完整的函数参数和主体：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then we can `Filter` all those functions from the returned list, which have
    `na.rm` among the formal arguments via the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过以下方式从返回的列表中 `Filter` 所有那些具有 `na.rm` 作为形式参数的函数：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be easily applied to any R package by changing the environment variable
    to for example `''package:stats''` in the case of the `stats` package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地应用于任何 R 包，只需更改环境变量，例如将 `stats` 包的情况更改为 `'package:stats'`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So these are the functions that have the `na.rm` argument in the `base` and
    the `stats` packages, where we have seen that the fastest and easiest way of ignoring
    missing values in single function calls (without actually removing the `NA` values
    from the dataset) is setting `na.rm` to `TRUE`. But why doesn't `na.rm` default
    to `TRUE`?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些是在 `base` 和 `stats` 包中具有 `na.rm` 参数的函数，我们已经看到，在单个函数调用中忽略缺失值（实际上并不从数据集中删除
    `NA` 值）最快和最简单的方法是将 `na.rm` 设置为 `TRUE`。但为什么 `na.rm` 默认不是 `TRUE`？
- en: Overriding the default arguments of a function
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖函数的默认参数
- en: 'If you are annoyed by the fact that most functions return `NA` if your R object
    includes missing values, then you can override those by using some custom wrapper
    functions, such as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你因为大多数函数在 R 对象包含缺失值时返回 `NA` 而感到烦恼，那么你可以通过使用一些自定义包装函数来覆盖这些函数，例如：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another option might be to write a custom package which would override the
    factory defaults of the `base` and `stats` function, like in the `rapportools`
    package, which includes miscellaneous helper functions with sane defaults for
    reporting:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择可能是编写一个自定义包，该包将覆盖 `base` 和 `stats` 函数的工厂默认设置，就像 `rapportools` 包一样，它包含了一些具有合理默认值的辅助函数，用于报告：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The problem with this approach is that you''ve just permanently overridden
    those functions listed, so you''ll need to restart your R session or detach the
    `rapportools` package to reset to the standard arguments, like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于你已永久覆盖了列出的那些函数，因此你需要重新启动你的 R 会话或断开 `rapportools` 包来重置为标准参数，例如：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A more general solution to override the default arguments of a function is
    to rely on some nifty features of the `Defaults` package, which is although not
    under active maintenance, but it does the job:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖函数的默认参数，一个更通用的解决方案是依赖 `Defaults` 包的一些巧妙特性，尽管它不再处于积极维护状态，但它确实完成了工作：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Please note that here we had to update the default argument value of `mean.default`
    instead of simply trying to tweak `mean`, as that latter would result in an error:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里我们必须更新 `mean.default` 的默认参数值，而不是简单地尝试调整 `mean`，因为后者会导致错误：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is due to the fact that `mean` is an `S3` method without any formal arguments:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `mean` 是一个没有任何形式参数的 `S3` 方法：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Either methods you prefer, you can automatically call those functions when R
    starts by adding a few lines of code in your `Rprofile` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你更喜欢哪种方法，你都可以通过在 `Rprofile` 文件中添加几行代码来自动在 R 启动时调用这些函数。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can customize the R environment via a global or user-specific `Rprofile`
    file. This is a normal R script which is usually placed in the user's home directory
    with a leading dot in the file name, which is run every time a new R session is
    started. There you can call any R functions wrapped in the `.First` or `.Last`
    functions to be run at the start or at the end of the R session. Such useful additions
    might be loading some R packages, printing custom greetings or KPI metrics from
    a database, or for example installing the most recent versions of all R packages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过全局或用户特定的`Rprofile`文件来定制R环境。这是一个普通的R脚本，通常放在用户的家目录中，文件名以点开头，每次启动新的R会话时都会运行。在那里，你可以调用在`.First`或`.Last`函数中包装的任何R函数，这些函数将在R会话的开始或结束时运行。这些有用的添加可能包括加载一些R包，从数据库中打印自定义问候语或KPI指标，或者例如安装所有R包的最新版本。
- en: But it's probably better not to tweak your R environment in such a non-standard
    way, as you might soon experience some esoteric and unexpected errors or silent
    malfunctions in your analysis.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能最好不要以这种方式非标准地调整你的R环境，因为你可能会很快在分析中遇到一些神秘和意外的错误或无声的故障。
- en: For example, I've got used to working in a temporary directory at all times
    by specifying `setwd('/tmp')` in my `Rprofile`, which is very useful if you start
    R sessions frequently for some quick jobs. On the other hand, it's really frustrating
    to spend 15 minutes of your life debugging why some random R function does not
    seem to do its job, and why it's returning some file not found error messages
    instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我已经习惯了在所有时候都在临时目录中工作，通过在`Rprofile`中指定`setwd('/tmp')`来实现，这对于频繁启动R会话进行一些快速工作非常有用。另一方面，当你花费15分钟的时间调试为什么某个随机的R函数似乎不起作用，以及为什么它返回一些文件未找到的错误消息时，这真的很令人沮丧。
- en: 'So please be warned: if you update the factory default arguments of R functions,
    do not ever think of ranting about some new bugs you have found in some major
    functions of base R on the R mailing lists, before trying to reproduce those errors
    in a vanilla R session with starting R with the --`vanilla` command line option.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所以请务必注意：如果你更新了R函数的工厂默认参数，在尝试在带有`--vanilla`命令行选项启动的纯R会话中重现这些错误之前，不要在R邮件列表上对你在base
    R的一些主要函数中发现的新错误进行抱怨。
- en: Getting rid of missing data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除缺失数据
- en: 'An alternative way of using the `na.rm` argument in R functions is removing
    `NA` from the dataset before passing that to the analysis functions. This means
    that we are removing the missing values from the dataset permanently, so that
    they won''t cause any problems at later stages in the analysis. For this, we could
    use either the `na.omit` or the `na.exclude` functions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在R函数中使用`na.rm`参数的另一种方法是，在将数据集传递给分析函数之前从数据集中删除`NA`。这意味着我们永久性地从数据集中删除缺失值，这样它们就不会在分析的后阶段引起任何问题。为此，我们可以使用`na.omit`或`na.exclude`函数：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The only difference between these two functions is the class of the `na.action`
    attribute of the returned R object, which are `omit` and `exclude` respectively.
    This minor difference is only important when modelling. The `na.exclude` function
    returns `NA` for residuals and predictions, while `na.omit` suppresses those elements
    of the vector:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的唯一区别是返回的R对象的`na.action`属性的类别，分别是`omit`和`exclude`。这个细微的区别仅在建模时很重要。`na.exclude`函数对于残差和预测返回`NA`，而`na.omit`抑制这些向量的元素：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Important thing to note in case of tabular data, like a `matrix` or `data.frame`,
    these functions remove the whole row if it contains at least one missing value.
    For a quick demo, let''s create a matrix with 3 columns and 3 rows with values
    incrementing from 1 to 9, but replacing all values divisible by 4 with `NA`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格数据的情况下，如`matrix`或`data.frame`，这些函数会删除包含至少一个缺失值的整个行。为了快速演示，让我们创建一个3列3行的矩阵，值从1递增到9，但将所有能被4整除的值替换为`NA`：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As seen here, we can find the row numbers of the removed cases in the `na.action`
    attribute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，我们可以在`na.action`属性中找到已删除案例的行号。
- en: Filtering missing data before or during the actual analysis
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实际分析之前或期间过滤缺失数据
- en: 'Let''s suppose we want to calculate the `mean` of the actual length of flights:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要计算实际飞行长度的`平均值`：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result is `NA` of course, because as identified previously, this variable
    contains missing values, and almost every R operation with `NA` results in `NA`.
    So let''s overcome this issue as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果当然是`NA`，因为如前所述，这个变量包含缺失值，并且几乎所有的R操作与`NA`结合都会得到`NA`。所以让我们这样解决这个问题：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Any performance issues there? Or other means of deciding which method to use?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有没有性能问题？或者有其他决定使用哪种方法的方式？
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first glance at the performance of these options computed with the help
    of the `microbenchmark` package (please see the *Loading text files of reasonable
    size* section in the [Chapter 1](ch01.html "Chapter 1. Hello, Data!"), *Hello
    Data* for more details) suggests that using `na.rm` is the better solution in
    case of a single function call.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项的性能，通过`microbenchmark`包的帮助计算（请参阅[第1章](ch01.html "第1章. 欢迎来到数据世界！")中的*加载合理大小的文本文件*部分，*欢迎数据*了解更多细节）表明，在单个函数调用的情况下，使用`na.rm`是更好的解决方案。
- en: On the other hand, if we want to reuse the data at some later phase in the analysis,
    it is more viable and effective to omit the missing values and observations only
    once from the dataset, instead of always specifying `na.rm` to be `TRUE`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想在分析的一些后续阶段重新使用数据，从数据集中一次性省略缺失值和观测值会更可行和有效，而不是总是指定`na.rm`为`TRUE`。
- en: Data imputation
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据插补
- en: 'And sometimes omitting missing values is not reasonable or possible at all,
    for example due to the low number of observations or if it seems that missing
    data is not random. Data imputation is a real alternative in such situations,
    and this method can replace `NA` with some real values based on various algorithms,
    such as filling empty cells with:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候省略缺失值可能不合理或根本不可能，例如由于观测值数量少或似乎缺失数据不是随机的。在这种情况下，数据插补是一个真正的替代方案，这种方法可以根据各种算法将`NA`替换为一些真实值，例如通过以下方式填充空单元格：
- en: A known scalar
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的标量
- en: The previous value appearing in the column (hot-deck)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在（hot-deck）列中出现的上一个值
- en: A random element from the same column
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一列中的随机元素
- en: The most frequent value in the column
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列中最频繁的值
- en: Different values from the same column with given probability
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一列中给定概率的不同值
- en: Predicted values based on regression or machine learning models
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于回归或机器学习模型的预测值
- en: The hot-deck method is often used while joining multiple datasets together.
    In such a situation, the `roll` argument of `data.table` can be very useful and
    efficient, otherwise be sure to check out the `hotdeck` function in the `VIM`
    package, which offers some really useful ways of visualizing missing data. But
    when dealing with an already given column of a dataset, we have some other simple
    options as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 热插补方法通常在合并多个数据集时使用。在这种情况下，`data.table`的`roll`参数可能非常有用和高效，否则请确保查看`VIM`包中的`hotdeck`函数，它提供了一些可视化缺失数据的有用方法。但当我们处理数据集的给定列时，我们还有一些其他简单的选项。
- en: For instance, imputing a known scalar is a pretty simple situation, where we
    know that all missing values are for example due to some research design patterns.
    Let's think of a database that stores the time you arrived to and left the office
    every weekday, and by computing the difference between those two, we can analyze
    the number of work hours spent in the office from day to day. If this variable
    returns `NA` for a time period, actually it means that we were outside of the
    office all day, so thus the computed value should be zero instead of `NA`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，插补一个已知的标量是一个相当简单的情况，其中我们知道所有缺失值都是由于某些研究设计模式。让我们考虑一个数据库，该数据库存储了每个工作日到达和离开办公室的时间，通过计算这两个时间之间的差异，我们可以分析每天在办公室花费的工作小时数。如果这个变量在某个时间段返回`NA`，实际上意味着我们整天都在办公室外，因此计算出的值应该是零而不是`NA`。
- en: 'And not just in theory, but this is pretty easy to implement in R as well (example
    is continued from the previous demo code where we defined `m` with two missing
    values):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 而且不仅是在理论上，在R中实现这一点也很简单（以下示例从之前的演示代码继续，其中我们用两个缺失值定义了`m`）：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, replacing missing values with a random number, a `sample` of other
    values or with the `mean` of a variable can be done relatively easily:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，用随机数、其他值的`sample`或变量的`mean`替换缺失值可以相对容易地完成：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Which can be even easier with the `impute` function from the `Hmisc` package:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Hmisc`包中的`impute`函数甚至可以更容易：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It seems that we have preserved the value of the arithmetic mean of course,
    but you should be aware of some very serious side-effects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们似乎保留了算术平均值的值，但你应该意识到一些非常严重的副作用：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When replacing missing values with the mean, the variance of the transformed
    variable will be naturally lower compared to the original distribution. This can
    be extremely problematic in some situations, where some more sophisticated methods
    are needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当用平均值替换缺失值时，转换变量的方差将自然低于原始分布。在某些情况下，这可能会非常成问题，需要更复杂的方法。
- en: Modeling missing values
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型缺失值
- en: Besides the previous mentioned univariate methods, you may also fit models on
    the complete cases in the dataset, rather than fitting those models on the remaining
    rows to estimate the missing values. Or in a nutshell, we are replacing the missing
    values with multivariate predictions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的单变量方法之外，你还可以在数据集中的完整案例上拟合模型，而不是在剩余的行上拟合这些模型来估计缺失值。或者简单地说，我们用多变量预测来替换缺失值。
- en: There are a plethora of related functions and packages, for example you might
    be interested in checking the `transcan` function in the `Hmisc` package, or the
    `imputeR` package, which includes a wide variety of models for imputing categorical
    and continuous variables as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多相关的函数和包，例如你可能对`Hmisc`包中的`transcan`函数感兴趣，或者`imputeR`包，它包括用于插补分类和连续变量的广泛模型。
- en: 'Most of the imputation methods and models are for one type of variable: either
    continuous or categorical. In case of mixed-type dataset, we typically use different
    algorithms to handle the different types of missing data. The problem with this
    approach is that some of the possible relations between different types of data
    might be ignored, resulting in some partial models.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的插补方法和模型都是针对一种类型的变量：要么是连续的，要么是分类的。在混合类型数据集的情况下，我们通常使用不同的算法来处理不同类型的缺失数据。这种方法的问题是一些可能存在于不同类型数据之间的关系可能会被忽略，从而导致一些部分模型。
- en: To overcome this issue, and to save a few pages in the book on the description
    of the traditional regression and other related methods for data imputation (although
    you can find some related methods in the [Chapter 5](ch05.html "Chapter 5. Building
    Models (authored by Renata Nemeth and Gergely Toth)"), *Buildings Models (authored
    by Renata Nemeth and Gergely Toth)* and the [Chapter 6](ch06.html "Chapter 6. Beyond
    the Linear Trend Line (authored by Renata Nemeth and Gergely Toth)"), *Beyond
    the Linear Trend Line (authored by Renata Nemeth and Gergely Toth)*), we will
    concentrate on a non-parametric method that can handle categorical and continuous
    variables at the same time via a very user-friendly interface in the `missForest`
    package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，并且为了在书中节省一些关于传统回归和其他相关数据插补方法的描述页面（尽管你可以在[第5章](ch05.html "第5章。构建模型（由Renata
    Nemeth和Gergely Toth编写)"), *构建模型（由Renata Nemeth和Gergely Toth编写)* 和[第6章](ch06.html
    "第6章。超越线性趋势线（由Renata Nemeth和Gergely Toth编写)"), *超越线性趋势线（由Renata Nemeth和Gergely
    Toth编写)* 中找到一些相关方法），我们将专注于一个非参数方法，该方法可以通过`missForest`包中非常用户友好的界面同时处理分类和连续变量。
- en: This iterative procedure fits a random forest model on the available data in
    order to predict the missing values. As our `hflights` data is relatively large
    for such a process and running the sample code would takes ages, we will rather
    use the standard `iris` dataset in the next examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代过程在可用数据上拟合随机森林模型，以预测缺失值。由于我们的`hflights`数据集对于这个过程来说相对较大，运行示例代码会花费很长时间，所以我们将在下一个示例中使用标准的`iris`数据集。
- en: 'First let''s see the original structure of the dataset, which does not include
    any missing values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看数据集的原始结构，它不包含任何缺失值：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s load the package and add some missing values (completely at random)
    to the dataset in the means of producing a reproducible minimal example for the
    forthcoming models:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们加载这个包，并在数据集中添加一些缺失值（完全随机地），以产生一个可重复的最小示例，用于后续模型的构建：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So now we have around 20 percent of missing values in each column, which is
    also stated in the bottom row of the preceding summary. The number of completely
    random missing values is between 28 and 33 cases per variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在每个列中大约有20%的缺失值，这也在前面的摘要的最后一行中提到。完全随机缺失值的数量在28到33个案例之间。
- en: 'The next step should be building the random forest models to replace the missing
    values with real numbers and factor levels. As we also have the original dataset,
    we can use that complete matrix to test the performance of the method via the
    `xtrue` argument, which computes and returns the error rate when we call the function
    with `verbose`. This is useful in such didactical examples to show how the model
    and predictions improves from iteration to iteration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步应该是构建随机森林模型，用实数和因子水平替换缺失值。因为我们也有原始数据集，我们可以使用这个完整的矩阵通过`xtrue`参数来测试方法的性能，该参数在调用函数时计算并返回错误率。这在这样的教学示例中很有用，可以展示模型和预测如何从迭代到迭代地改进：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The algorithm ran for 5 iterations before stopping, when it seemed that the
    error rate was not improving any further. The returned `missForest` object includes
    a few other values besides the imputed dataset:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 算法运行了5次迭代后停止，此时似乎错误率没有进一步改善。返回的`missForest`对象除了填充后的数据集外，还包括一些其他值：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Out of Box error is an estimate on how good our model was based on the **normalized
    root mean squared error computed** (**NRMSE**) for numeric values and the **proportion
    of falsely classified** (**PFC**) entries for factors. And as we also provided
    the complete dataset for the previously run model, we also get the true imputation
    error ratio – which is pretty close to the above estimates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 箱外误差是对我们的模型有多好的估计，基于数值的**归一化均方根误差计算**（**NRMSE**）和因子的**错误分类比例**（**PFC**）。而且，因为我们也为之前运行过的模型提供了完整的数据集，所以我们还得到了真实的填充误差比率——这非常接近上述估计。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please find more details on random forests and related machine learning topics
    in the [Chapter 10](ch10.html "Chapter 10. Classification and Clustering"), *Classification
    and Clustering*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请在[第10章](ch10.html "第10章。分类和聚类") *分类和聚类* 中查找有关随机森林和相关机器学习主题的更多详细信息。
- en: But how does this approach compare to a much simpler imputation method, like
    replacing missing values with the mean?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法和一个更简单的填充方法，比如用平均值替换缺失值，相比如何呢？
- en: Comparing different imputation methods
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较不同的填充方法
- en: 'In the comparison, only the first four columns of the `iris` dataset will be
    used, thus it is not dealing with the factor variable at the moment. Let''s prepare
    this demo dataset:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较中，我们只会使用`iris`数据集的前四列，因此目前并没有处理因子变量。让我们准备这个演示数据集：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `iris_mean`, we replace all the missing values to the mean of the actual
    columns:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iris_mean`中，我们将所有缺失值替换为实际列的平均值：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And in `iris_forest`, we predict the missing values by fitting random forest
    model:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iris_forest`中，我们通过拟合随机森林模型来预测缺失值：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s simply check the accuracy of the two models by comparing the correlations
    of `iris_mean` and `iris_forest` with the complete `iris` dataset. For `iris_forest`,
    we will extract the actual imputed dataset from the `ximp` attribute, and we will
    silently ignore the factor variable of the original `iris` table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简单地通过比较`iris_mean`和`iris_forest`与完整的`iris`数据集的相关性来检查两个模型的准确性。对于`iris_forest`，我们将从`ximp`属性中提取实际的填充数据集，并且我们将默默地忽略原始`iris`表中的因子变量：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These results suggest that the nonparametric random forest model did a lot better
    job compared to the simple univariate solution of replacing missing values with
    the mean.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，非参数随机森林模型与用平均值替换缺失值的简单单变量解决方案相比，做得更好。
- en: Not imputing missing values
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未填充缺失值
- en: Please note that these methods have their drawbacks likewise. Replacing the
    missing values with a predicted one often lacks any error term and residual variance
    with most models.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些方法同样有其缺点。用预测值替换缺失值通常缺乏任何误差项和残差方差，这在大多数模型中都是如此。
- en: This also means that we are lowering the variability, and overestimating some
    association in the dataset at the same time, which can seriously affect the results
    of our data analysis. For this, some simulation techniques were introduced in
    the past to overcome the problem of distorting the dataset and our hypothesis
    tests with some arbitrary models.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们在降低变异性，同时在数据集中高估了一些关联，这可能会严重影响我们的数据分析结果。为此，过去引入了一些模拟技术来克服由于一些任意模型而扭曲数据集和我们的假设检验的问题。
- en: Multiple imputation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多次填充
- en: The basic idea behind multiple imputation is to fit models several times in
    a row on the missing values. This Monte Carlo method usually creates some (like
    3 to 10) parallel versions of the simulated complete dataset, each of these is
    analyzed separately, and then we combine the results to produce the actual estimates
    and confidence intervals. See for example the `aregImpute` function from the `Hmisc`
    package for more details.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多重插补背后的基本思想是连续多次对缺失值进行模型拟合。这种蒙特卡洛方法通常创建一些（如3到10个）模拟完整数据集的并行版本，每个版本分别进行分析，然后我们将结果结合起来产生实际的估计值和置信区间。例如，查看
    `Hmisc` 包中的 `aregImpute` 函数以获取更多详细信息。
- en: On the other hand, do we really have to remove or impute missing values in all
    cases? For more details on this question, please see the last section of this
    chapter. But before that, let's get to know some other requirements for polishing
    data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们是否真的需要在所有情况下都删除或插补缺失值？关于这个问题的更多细节，请参阅本章的最后部分。但在那之前，让我们了解一下对数据进行润色的一些其他要求。
- en: Extreme values and outliers
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 极端值和异常值
- en: 'An outlier or extreme value is defined as a data point that deviates so far
    from the other observations, that it becomes suspicious to be generated by a totally
    different mechanism or simply by error. Identifying outliers is important because
    those extreme values can:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 异常值或极端值被定义为与其它观测值差异如此之大，以至于它变得可疑，可能是完全不同的机制或简单地由错误生成的。识别异常值很重要，因为这些极端值可以：
- en: Increase error variance
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加误差方差
- en: Influence estimates
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响估计
- en: Decrease normality
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低正态性
- en: Or in other words, let's say your raw dataset is a piece of rounded stone to
    be used as a perfect ball in some game, which has to be cleaned and polished before
    actually using it. The stone has some small holes on its surface, like missing
    values in the data, which should be filled – with data imputation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者换句话说，假设你的原始数据集是一块要用于某些游戏中完美球体的圆形石头，在使用之前必须进行清洁和抛光。石头表面有一些小孔，就像数据中的缺失值一样，应该用数据插补来填补。
- en: On the other hand, the stone does not only has holes on its surface, but some
    mud also covers some parts of the item, which is to be removed. But how can we
    distinguish mud from the real stone? In this section, we will focus on what the
    `outliers` package and some related methods have to offer for identifying extreme
    values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这块石头不仅在表面上有很多孔，而且还有一些泥土覆盖了物品的一些部分，这些部分需要被去除。但我们是怎样区分泥土和真正的石头的呢？在本节中，我们将关注
    `outliers` 包和一些相关方法在识别极端值方面能提供什么。
- en: 'As this package has some conflicting function names with the `randomForest`
    package (automatically loaded by the `missForest` package), it''s wise to detach
    the latter before heading to the following examples:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个包与 `randomForest` 包（由 `missForest` 包自动加载）有一些冲突的函数名，所以在进入以下示例之前，明智的做法是先卸载后者：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `outlier` function returns the value with the largest difference from the
    mean, which, contrary to its name, not necessarily have to be an outlier. Instead,
    the function can be used to give the analyst an idea about which values can be
    outliers:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`outlier` 函数返回与平均值差异最大的值，尽管其名称与之相反，这个值不一定是异常值。相反，该函数可以用来给分析师一个关于哪些值可能是异常值的想法：'
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So there was a flight with more than 16 hours of delay before actually taking
    off! This is impressive, isn''t it? Let''s see if it''s normal to be so late:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一架航班在起飞前延误了超过16小时！这很令人印象深刻，不是吗？让我们看看它是否正常这么晚起飞：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Well, `mean` is around 10 minutes, but as it''s even larger than the third
    quarter and the `median` is zero, it''s not that hard to guess that the relatively
    large mean is due to some extreme values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，平均值大约是10分钟，但由于它甚至比第三季度还要大，而中位数是零，所以不难猜测相对较大的平均值是由于一些极端值：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Extreme values and outliers](img/2028OS_08_01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![极端值和异常值](img/2028OS_08_01.jpg)'
- en: 'The preceding boxplot clearly shows that most flights were delayed by only
    a few minutes, and the interquartile range is around 10 minutes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的箱线图清楚地显示，大多数航班仅延误了几分钟，四分位距大约是10分钟：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All the blue circles in the preceding image are the whiskers are possible extreme
    values, as being higher than the 1.5 IQR of the upper quartile. But how can we
    (statistically) test a value?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像中所有的蓝色圆圈都是可能的极端值，因为它们高于上四分位数1.5的四分位距。但我们如何（从统计学的角度）测试一个值呢？
- en: Testing extreme values
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试极端值
- en: 'The `outliers` package comes with several bundled extreme value detection algorithms,
    like:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`outliers` 包含几个捆绑的极端值检测算法，例如：'
- en: Dixon's Q test (`dixon.test`)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dixon的Q测试（`dixon.test`）
- en: Grubb's test (`grubbs.test`)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grubb的测试（`grubbs.test`）
- en: Outlying and inlying variance (`cochran.test`)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常值和内嵌方差（`cochran.test`）
- en: Chi-squared test (`chisq.out.test`)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡方检验（`chisq.out.test`）
- en: 'These functions are extremely easy to use. Just pass a vector to the statistical
    tests and the returning p-value of the significance test will clearly indicate
    if the data has any outliers. For example, let''s test 10 random numbers between
    0 and 1 against a relatively large number to verify it''s an extreme value in
    this small sample:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数极其容易使用。只需将一个向量传递给统计测试，显著性测试返回的p值将清楚地表明数据中是否存在异常值。例如，让我们测试0到1之间的10个随机数与一个相对较大的数，以验证它在这个小样本中是否是极端值：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But unfortunately, we cannot use these convenient functions in our live dataset,
    as the methods assume normal distribution, which is definitely not true in our
    cases as we all know from experience: flights tend to be late more often than
    arriving a lot sooner to their destinations.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，我们无法在我们的实际数据集中使用这些方便的函数，因为这些方法假设正态分布，而我们都知道，在我们的情况下这绝对不是真的：航班往往比预定时间晚到，而不是提前到达目的地。
- en: 'For this, we should use some more robust methods, such as the `mvoutlier` package,
    or some very simple approaches like Lund suggested around 40 years ago. This test
    basically computes the distance of each value from the mean with the help of a
    very simple linear regression:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，我们应该使用一些更稳健的方法，比如 `mvoutlier` 包，或者像Lund在40年前建议的一些非常简单的方法。这个测试基本上是通过一个非常简单的线性回归来计算每个值与平均值的距离：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just to verify we are now indeed measuring the distance from the mean:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了验证我们现在确实是在测量与平均值之间的距离：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now let''s compute the critical value based on the F distribution and two helper
    variables (where `a` stands for the alpha value and `n` represents the number
    of cases):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据F分布和两个辅助变量（其中 `a` 代表alpha值，`n` 代表案例数）来计算临界值：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Which can be passed to Lund''s formula:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被传递到Lund的公式中：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s see how many values have a higher standardized residual than this
    computed critical value:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看有多少值的标准化残差高于这个计算出的临界值：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But do we really have to remove these outliers from our data? Aren't extreme
    values normal? Sometimes these artificial edits in the raw data, like imputing
    missing values or removing outliers, makes more trouble than it's worth.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的需要从我们的数据中移除这些异常值吗？极端值不是正常的吗？有时这些原始数据中的人为编辑，比如填补缺失值或移除异常值，带来的麻烦比它值得的还要多。
- en: Using robust methods
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用稳健的方法
- en: Fortunately, there are some robust methods for analyzing datasets, which are
    generally less sensitive to extreme values. These robust statistical methods have
    been developed since 1960, but there are some well-known related methods from
    even earlier, like using the median instead of the mean as a central tendency.
    Robust methods are often used when the underlying distribution of our data is
    not considered to follow the Gaussian curve, so most good old regression models
    do not work (see more details in the [Chapter 5](ch05.html "Chapter 5. Building
    Models (authored by Renata Nemeth and Gergely Toth)"), *Buildings Models (authored
    by Renata Nemeth and Gergely Toth)* and the [Chapter 6](ch06.html "Chapter 6. Beyond
    the Linear Trend Line (authored by Renata Nemeth and Gergely Toth)"), *Beyond
    the Linear Trend Line (authored by Renata Nemeth and Gergely Toth)*).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些稳健的方法可以分析数据集，这些方法通常对极端值不太敏感。这些稳健的统计方法自1960年以来就已经发展起来，但还有一些更早的知名相关方法，比如使用中位数而不是平均值作为中心趋势。当我们的数据的基本分布被认为不遵循高斯曲线时，通常会使用稳健的方法，因此大多数好的旧回归模型都不适用（更多细节请见第5章[Chapter
    5](ch05.html "Chapter 5. Building Models (authored by Renata Nemeth and Gergely
    Toth)"), *Buildings Models (authored by Renata Nemeth and Gergely Toth)* 和第6章[Chapter
    6](ch06.html "Chapter 6. Beyond the Linear Trend Line (authored by Renata Nemeth
    and Gergely Toth)"), *Beyond the Linear Trend Line (authored by Renata Nemeth
    and Gergely Toth)*）。
- en: 'Let''s take the traditional linear regression example of predicting the sepal
    length of iris flowers based on the petal length with some missing data. For this,
    we will use the previously defined `miris` dataset:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以传统的线性回归为例，预测鸢尾花的花瓣长度，基于花瓣长度并有一些缺失数据。为此，我们将使用之前定义的 `miris` 数据集：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So it seems that our estimate for the sepal and petal length ratio is around
    `0.42`, which is not too far from the real value by the way:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的花瓣与萼片长度比率的估计大约为 `0.42`，顺便说一句，这并不太远离真实值：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The difference between the estimated and real coefficients is due to the artificially
    introduced missing values in a previous section. Can we produce even better estimates?
    We might impute the missing data with any of the previously mentioned methods,
    or instead we should rather fit a robust linear regression from the `MASS` package
    predicting `Sepal.Length` with the `Petal.Length` variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 估计系数与实际系数之间的差异是由于前一个章节中人为引入的缺失值造成的。我们能否产生更好的估计值？我们可以用之前提到的任何一种方法来估计缺失数据，或者我们更应该拟合一个来自`MASS`包的稳健线性回归，预测`Sepal.Length`与`Petal.Length`变量：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let''s compare the coefficients of the models run against the original
    (full) and the simulated data (with missing values):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来比较针对原始（完整）数据和模拟数据（包含缺失值）运行的模型的系数：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To be honest, there''s not much difference between the standard linear regression
    and the robust version. Surprised? Well, the dataset included missing values completely
    at random, but what happens if the dataset includes other types of missing values
    or an outlier? Let''s verify this by simulating some dirtier data issues (with
    updating the sepal length of the first observation from `1.4` to `14` – let''s
    say due to a data input error) and rebuilding the models:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，标准线性回归和稳健版本之间没有太大的区别。惊讶吗？嗯，数据集包含的缺失值是完全随机出现的，但如果数据集包含其他类型的缺失值或异常值会怎样呢？让我们通过模拟一些更脏的数据问题（将第一个观察值的萼片长度从`1.4`更新到`14`——让我们假设是由于数据输入错误）并重新构建模型来验证这一点：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It seems that the `lm` model's performance decreased a lot, while the coefficients
    of the robust model are almost identical to the original model regardless of the
    outlier in the data. We can conclude that robust methods are pretty impressive
    and powerful tools when it comes to extreme values! For more information on the
    related methods already implemented in R, visit the related CRAN Task View at
    [http://cran.r-project.org/web/views/Robust.html](http://cran.r-project.org/web/views/Robust.html).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`lm`模型的性能下降了很多，而稳健模型的系数几乎与原始模型相同，无论数据中的异常值如何。我们可以得出结论，稳健方法在处理极端值时是非常令人印象深刻且强大的工具！有关R中已实现的有关方法的更多信息，请访问相关的CRAN任务视图[http://cran.r-project.org/web/views/Robust.html](http://cran.r-project.org/web/views/Robust.html)。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on some of the hardest challenges in data analysis in the
    means of cleansing data, and we covered the most important topics on missing and
    extreme values. Depending on your field of interest or industry you are working
    for, dirty data can be a rare or major issue (for example I've seen some projects
    in the past when regular expressions were applied to a `JSON` file to make that
    valid), but I am sure you will find the next chapter interesting and useful despite
    your background – where we will learn about multivariate statistical techniques.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了数据分析中的一些最具挑战性的问题，特别是在数据清洗方面，我们涵盖了关于缺失值和极端值的最重要主题。根据你的兴趣领域或你所在行业的不同，脏数据可能是一个罕见或主要问题（例如，我过去看到过一些项目，其中正则表达式被应用于`JSON`文件以使其有效），但我相信，无论你的背景如何，你都会发现下一章既有趣又有用——我们将学习多元统计分析技术。
