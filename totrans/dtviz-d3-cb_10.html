<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Interacting with your Visualization</h1></div></div></div><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interacting with the mouse</li><li class="listitem" style="list-style-type: disc">Interacting with a multi-touch device</li><li class="listitem" style="list-style-type: disc">Implementing zoom and pan behavior</li><li class="listitem" style="list-style-type: disc">Implementing the drag behavior</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Introduction</h1></div></div></div><div><blockquote class="blockquote"><p>The ultimate goal of visualization design is to optimize applications so that they help us perform cognitive work more efficiently.</p><p>Ware C. (2012)</p></blockquote></div><p>The goal of data visualization<a id="id533" class="indexterm"/> is to help the audience gain information from a large quantity of raw data quickly and efficiently through <a id="id534" class="indexterm"/>metaphor, <a id="id535" class="indexterm"/>mental model alignment, and <a id="id536" class="indexterm"/>cognitive magnification. So far in this book we have introduced various techniques to leverage D3 library implementing many types of visualization. However, we haven't touched a crucial aspect of visualization: human interaction. Various researches have concluded the unique value <a id="id537" class="indexterm"/>of human interaction in information visualization.</p><div><blockquote class="blockquote"><p>Visualization combined with computational steering allows faster analyses of more sophisticated scenarios...This case study adequately demonstrate that the interaction of a complex model with steering and interactive visualization can extend the applicability of the modelling beyond research </p><p>Barrass I. &amp; Leng J (2011)</p></blockquote></div><p>In this chapter we will focus on D3 human visualization interaction support, or as mentioned earlier learn how to add computational steering capability to your visualization.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Interacting with mouse events</h1></div></div></div><p>The <a id="id538" class="indexterm"/>mouse is the most common and popular human-computer interaction control found on most desktop and laptop computers. Even today, with multi-touch devices rising to dominance, touch events<a id="id539" class="indexterm"/> are typically still emulated into mouse events; therefore making application designed to interact via mouse usable through touches. In this recipe we will learn how to handle standard mouse events in D3.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec201"/>Getting ready</h2></div></div></div><p>Open your local copy of the <a id="id540" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/mouse.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/mouse.html</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec202"/>How to do it...</h2></div></div></div><p>In the following code example we will explore techniques of registering and handling mouse events in D3. Although, in this particular example we are only handling<a id="id541" class="indexterm"/> <code class="literal">click</code> and <code class="literal">mousemove</code>, the <a id="id542" class="indexterm"/>techniques utilized here can be applied easily to all other standard mouse events supported by modern browsers:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var r = 400;

    var svg = d3.select("body")
            .append("svg");

    var positionLabel = svg.append("text")
            .attr("x", 10)
            .attr("y", 30);

    svg.on("mousemove", function () { //&lt;-A
        printPosition();
    });
            
    function printPosition() { //&lt;-B
        var position = d3.mouse(svg.node()); //&lt;-C
        positionLabel.text(position);
    }  

    svg.on("click", function () { //&lt;-D
        for (var i = 1; i &lt; 5; ++i) {
            var position = d3.mouse(svg.node());

            var circle = svg.append("circle")
                    .attr("cx", position[0])
                    .attr("cy", position[1])
                    .attr("r", 0)
                    .style("stroke-width", 5 / (i))
                    .transition()
                        .delay(Math.pow(i, 2.5) * 50)
                        .duration(2000)
                        .ease('quad-in')
                    .attr("r", r)
                    .style("stroke-opacity", 0)
                    .each("end", function () {
                        d3.select(this).remove();
                    });
        }
    });
&lt;/script&gt;</pre></div><p>This recipe <a id="id543" class="indexterm"/>generates the following interactive visualization:</p><div><img src="img/2162OS_10_01.jpg" alt="How to do it..."/><div><p>Mouse Interaction</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec203"/>How it works...</h2></div></div></div><p>In D3, to<a id="id544" class="indexterm"/> register an event listener, we need to invoke the <code class="literal">on</code> function on a particular selection. The given event listener will be attached to all selected elements for the specified event (line A). The following code in this recipe attaches a<a id="id545" class="indexterm"/> <code class="literal">mousemove</code> event listener which displays the current mouse position (line B):</p><div><pre class="programlisting">svg.on("mousemove", function () { //&lt;-A
    printPosition();
});
            
function printPosition() { //&lt;-B
    var position = d3.mouse(svg.node()); //&lt;-C
    positionLabel.text(position);
}  </pre></div><p>On line C we used <code class="literal">d3.mouse</code> function to obtain the current mouse position relative to the given container element. This function returns a two-element array [x, y]. After this we also registered an <a id="id546" class="indexterm"/>event listener for mouse <code class="literal">click</code> event on line D using the same <code class="literal">on</code> function:</p><div><pre class="programlisting">svg.on("click", function () { //&lt;-D
        for (var i = 1; i &lt; 5; ++i) {
            var position = d3.mouse(svg.node());

        var circle = svg.append("circle")
                .attr("cx", position[0])
                .attr("cy", position[1])
                .attr("r", 0)
                .style("stroke-width", 5 / (i)) // &lt;-E
                .transition()
                    .delay(Math.pow(i, 2.5) * 50) // &lt;-F
                    .duration(2000)
                    .ease('quad-in')
                .attr("r", r)
                .style("stroke-opacity", 0)
                .each("end", function () {
                    d3.select(this).remove(); // &lt;-G
                });
        }
});</pre></div><p>Once again, we retrieved the current mouse position using <code class="literal">d3.mouse</code> function and then generated five concentric expanding circles to simulate the ripple effect. The ripple effect was simulated using geometrically increasing delay (line F) with decreasing <code class="literal">stroke-width</code> (line E). Finally when the transition effect is over, the circles were removed using transition <code class="literal">end</code> listener (line G). If you are not familiar with this type of transition control please review <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec204"/>There's more...</h2></div></div></div><p>Although, we have only demonstrated listening on the <code class="literal">click</code> and <code class="literal">mousemove</code> events in this recipe, you can listen on any event that your browser supports through the <code class="literal">on</code> function. The following is a list of mouse events that are useful to know when building your interactive visualization:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">click</code>: Dispatched<a id="id547" class="indexterm"/> when <a id="id548" class="indexterm"/>user clicks a mouse button</li><li class="listitem" style="list-style-type: disc"><code class="literal">dbclick</code>: Dispatched <a id="id549" class="indexterm"/>when a mouse button is clicked <a id="id550" class="indexterm"/>twice</li><li class="listitem" style="list-style-type: disc"><code class="literal">mousedown</code>: Dispatched <a id="id551" class="indexterm"/>when a mouse button is<a id="id552" class="indexterm"/> pressed</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseenter</code>: Dispatched <a id="id553" class="indexterm"/>when mouse is moved onto the <a id="id554" class="indexterm"/>boundaries of an element or one of its descendent elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseleave</code>: Dispatched <a id="id555" class="indexterm"/>when mouse is moved off of the <a id="id556" class="indexterm"/>boundaries of an element and all of its descendent elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">mousemove</code>: Dispatched <a id="id557" class="indexterm"/>when mouse is moved over an<a id="id558" class="indexterm"/> element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseout</code>: Dispatched <a id="id559" class="indexterm"/>when mouse is moved off of <a id="id560" class="indexterm"/>the boundaries of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseover</code>: Dispatched <a id="id561" class="indexterm"/>when mouse is moved onto the <a id="id562" class="indexterm"/>boundaries of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseup</code>: Dispatched <a id="id563" class="indexterm"/>when a mouse button is released over an <a id="id564" class="indexterm"/>element</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec205"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details on the ripple effect technique used in this recipe</li><li class="listitem" style="list-style-type: disc">W3C DOM Level 3 Events specification for a complete list of event types: <a class="ulink" href="http://www.w3.org/TR/DOM-Level-3-Events/">http://www.w3.org/TR/DOM-Level-3-Events/</a></li><li class="listitem" style="list-style-type: disc">d3.mouse API document for more details on mouse detection: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_mouse">https://github.com/mbostock/d3/wiki/Selections#wiki-d3_mouse</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Interacting with a multi-touch device</h1></div></div></div><p>Today, with the proliferation of multi-touch devices, any visualization targeting mass consumption needs to worry about its interactability not only through the traditional pointing device, but through multi-touches and gestures as well. In this recipe we will explore touch support offered by D3 to see how it can be leveraged to generate some pretty interesting interaction with multi-touch capable devices.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec206"/>Getting ready</h2></div></div></div><p>Open your local copy of the <a id="id565" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/touch.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/touch.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec207"/>How to do it...</h2></div></div></div><p>In this recipe we will generate a progress-circle around the user's touch and once the progress is completed then a subsequent ripple effect will be triggered around the circle. However, if the user prematurely ends his/her touch, then we shall stop the progress-circle without generating the ripples:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var initR = 100, 
        r = 400, 
        thickness = 20;

    var svg = d3.select("body")
            .append("svg");

    d3.select("body")
            .on("touchstart", touch)
            .on("touchend", touch);

    function touch() {
        d3.event.preventDefault();

        var arc = d3.svg.arc()
                .outerRadius(initR)
                .innerRadius(initR - thickness);
                
        var g = svg.selectAll("g.touch")
                .data(d3.touches(svg.node()), function (d) {
                    return d.identifier;
                });

        g.enter()
            .append("g")
            .attr("class", "touch")
            .attr("transform", function (d) {
                return "translate(" + d[0] + "," + d[1] + ")";
            })
            .append("path")
                .attr("class", "arc")
                .transition().duration(2000)
                .attrTween("d", function (d) {
                    var interpolate = d3.interpolate(
                            {startAngle: 0, endAngle: 0},
                            {startAngle: 0, endAngle: 2 * Math.PI}
                        );
                    return function (t) {
                        return arc(interpolate(t));
                    };
                })
                .each("end", function (d) {
                    if (complete(g))
                        ripples(d);
                    g.remove();
                });

        g.exit().remove().each(function () {
            this.__stopped__ = true;
        });
    }

    function complete(g) {
        return g.node().__stopped__ != true;
    }

    function ripples(position) {
        for (var i = 1; i &lt; 5; ++i) {
            var circle = svg.append("circle")
                    .attr("cx", position[0])
                    .attr("cy", position[1])
                    .attr("r", initR - (thickness / 2))
                    .style("stroke-width", thickness / (i))
                .transition().delay(Math.pow(i, 2.5) * 50).duration(2000).ease('quad-in')
                    .attr("r", r)
                    .style("stroke-opacity", 0)
                    .each("end", function () {
                        d3.select(this).remove();
                    });
        }
    }
&lt;/script&gt;</pre></div><p>This recipe generates the following interactive visualization on a touch enabled device:</p><div><img src="img/2162OS_10_02.jpg" alt="How to do it..."/><div><p>Touch Interaction</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec208"/>How it works...</h2></div></div></div><p>Event listener<a id="id566" class="indexterm"/> for touch events are registered through D3 selection's <code class="literal">on</code> function similar to what we have done with mouse events in the previous recipe:</p><div><pre class="programlisting">d3.select("body")
            .on("touchstart", touch)
            .on("touchend", touch);</pre></div><p>One crucial difference here is that we have registered our touch event listener on the <code class="literal">body</code> element instead of the <code class="literal">svg</code> element since with many OS and browsers there are default touch behaviors defined and we would like to override it with our custom implementation. This is done through the following function call:</p><div><pre class="programlisting">d3.event.preventDefault();</pre></div><p>Once the touch event is triggered we retrieve multiple touch point data using the <code class="literal">d3.touches</code> function as illustrated by the following code snippet:</p><div><pre class="programlisting">var g = svg.selectAll("g.touch")
    .data(d3.touches(svg.node()), function (d) {
        return d.identifier;
    }); </pre></div><p>Instead of returning a two-element array as what <code class="literal">d3.mouse</code> function does, <code class="literal">d3.touches</code> returns an array of two-element arrays since there could be multiple touch points for each touch event. Each touch position array has data structure that looks like the following:</p><div><img src="img/2162OS_10_03.jpg" alt="How it works..."/><div><p>Touch Position Array</p></div></div><p>Other than the [x, y] position <a id="id567" class="indexterm"/>of the touch point each position array also carries an identifier to help you differentiate each touch point. We used this identifier here in this recipe to establish object constancy. Once the touch data is bound to the selection the progress circle was generated for each touch around the user's finger:</p><div><pre class="programlisting">        g.enter()
            .append("g")
            .attr("class", "touch")
            .attr("transform", function (d) {
                return "translate(" + d[0] + "," + d[1] + ")";
            })
            .append("path")
                .attr("class", "arc")
                .transition().duration(2000).ease('linear')
                .attrTween("d", function (d) { // &lt;-A
                    var interpolate = d3.interpolate(
                            {startAngle: 0, endAngle: 0},
                            {startAngle: 0, endAngle: 2 * Math.PI}
                        );
                    return function (t) {
                        return arc(interpolate(t));
                    };
                })
                .each("end", function (d) { // &lt;-B
                    if (complete(g))
                        ripples(d);
                    g.remove();
                });</pre></div><p>This is done through a standard arc transition with attribute tweening (line A) as explained in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. Once the transition is over if the progress-circle has not yet been canceled by the user then a ripple effect similar to what we have done in the previous recipe was generated on line B. Since we have registered the same event listener <code class="literal">touch</code> function on both <code class="literal">touchstart</code> and <code class="literal">touchend</code> events, we can use the following lines to remove progress-circle and also set a flag to indicate that this progress circle has been stopped prematurely:</p><div><pre class="programlisting">        g.exit().remove().each(function () {
            this.__stopped__ = true;
        });</pre></div><p>We need to set this<a id="id568" class="indexterm"/> stateful flag since there is no way to cancel a transition once it is started; hence, even after removing the progress-circle element from the DOM tree the transition will still complete and trigger line B.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec209"/>There's more...</h2></div></div></div><p>We have demonstrated touch interaction through the <code class="literal">touchstart</code> and <code class="literal">touchend</code> events; however, you can use the same pattern to handle any other touch events supported by your browser. The following list contains the proposed touch event types<a id="id569" class="indexterm"/> recommended by W3C:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">touchstart</code>: Dispatched <a id="id570" class="indexterm"/>when <a id="id571" class="indexterm"/>the user places a touch point on the touch surface</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchend</code>: Dispatched<a id="id572" class="indexterm"/> when the user removes a touch point from<a id="id573" class="indexterm"/> the touch surface</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchmove</code>: Dispatched<a id="id574" class="indexterm"/> when the user moves a touch point along the <a id="id575" class="indexterm"/>touch surface</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchcancel</code>: Dispatched<a id="id576" class="indexterm"/> when a touch point has been disrupted in an <a id="id577" class="indexterm"/>implementation-specific manner</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec210"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details on object constancy and the ripple effect technique used in this recipe</li><li class="listitem" style="list-style-type: disc"><a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, for more details on the progress-circle attribute tween transition technique used in this recipe</li><li class="listitem" style="list-style-type: disc">W3C Touch Events proposed recommendation for a complete list of touch event types: <a class="ulink" href="http://www.w3.org/TR/touch-events/">http://www.w3.org/TR/touch-events/</a></li><li class="listitem" style="list-style-type: disc">d3.touch API document for more details on multi-touch detection: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_touches">https://github.com/mbostock/d3/wiki/Selections#wiki-d3_touches</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Implementing zoom and pan behavior</h1></div></div></div><p>Zooming <a id="id578" class="indexterm"/>and panning<a id="id579" class="indexterm"/> are common and useful techniques in data visualization, which work particularly well with SVG based visualization since vector graphic does not suffer from pixelation as its bitmap counterpart would. Zooming is especially useful when dealing with large data set when it is impractical or impossible to visualize the entire data set, thus a zoom and drill-down approach needs to be employed. In this recipe we will explore D3's built-in support for both zooming and panning.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec211"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/zoom.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/zoom.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec212"/>How to do it...</h2></div></div></div><p>In this recipe we will<a id="id580" class="indexterm"/> implement <a id="id581" class="indexterm"/>geometric zooming and panning using D3 zoom support. Let's see how this is done in code:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var width = 960, height = 500, r = 50;

    var data = [
        [width / 2 - r, height / 2 - r],
        [width / 2 - r, height / 2 + r],
        [width / 2 + r, height / 2 - r],
        [width / 2 + r, height / 2 + r]
    ];

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .call(
                d3.behavior.zoom()
                    .scaleExtent([1, 10])
                    .on("zoom", zoom)
            )
            .append("g");

    svg.selectAll("circle")
            .data(data)
            .enter().append("circle")
            .attr("r", r)
            .attr("transform", function (d) {
                return "translate(" + d + ")";
            });

    function zoom() {
        svg.attr("transform", "translate(" 
            + d3.event.translate 
+ ")scale(" + d3.event.scale + ")");
    }
&lt;/script&gt;</pre></div><p>This recipe <a id="id582" class="indexterm"/>generates the following zooming and panning <a id="id583" class="indexterm"/>effect:</p><div><img src="img/2162OS_10_04.jpg" alt="How to do it..."/><div><p>Original</p></div></div><div><img src="img/2162OS_10_05.jpg" alt="How to do it..."/><div><p>Zoom</p></div></div><div><img src="img/2162OS_10_06.jpg" alt="How to do it..."/><div><p>Pan</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How it works...</h2></div></div></div><p>At this <a id="id584" class="indexterm"/>point you might be surprised to see how little code is necessary to <a id="id585" class="indexterm"/>implement this fully-functional zoom and pan effect with D3. If you have this recipe open in your browser, you will also notice zooming and panning reacts perfectly well to both mouse wheel and multi-touch gesture. Most of the heavy lifting is done by D3 library. What we have to do here is to simply define what zoom behavior is. Let's see how this is done in the code. Firstly, we need to define zoom behavior on a SVG container:</p><div><pre class="programlisting">var svg = d3.select("body").append("svg")
            .attr("style", "1px solid black")
            .attr("width", width)
            .attr("height", height)
            .call( // &lt;-A
                d3.behavior.zoom() // &lt;-B
                    .scaleExtent([1, 10]) // &lt;-C
                    .on("zoom", zoom) // &lt;-D
            )
            .append("g");</pre></div><p>As we can see on line A, a <code class="literal">d3.behavior.zoom</code> function was created (line B) and invoked on the <code class="literal">svg</code> container. <code class="literal">d3.behavior.zoom</code> will automatically create event listeners to handle the low-level zooming and panning gesture on the associated SVG container (in our case the <code class="literal">svg</code> element itself). The low-level zoom gesture will then be translated to a high-level D3 zoom event. The default event listeners support both mouse and touch events. On line C we define <code class="literal">scaleExtent</code> with a 2-element array [1, 10] (a range). The scale extent defines how much zoom should be allowed (in our case we allow 10X zoom). Finally, on line D we register a custom zoom event handler to handle D3 zoom events. Now, let's take a look at what job this zoom event handler performs:</p><div><pre class="programlisting">function zoom() {
        svg.attr("transform", "translate(" 
            + d3.event.translate 
            + ")scale(" + d3.event.scale + ")");
}</pre></div><p>In the <code class="literal">zoom</code> function we simply delegate the actual zooming and panning to SVG transformation. To further simplify this task D3 zoom event has also calculated necessary translate and scale. So all we need to do is embed them into SVG transform attribute. Here are the properties contained in a zoom event:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">scale</code>: A number representing the current scale</li><li class="listitem" style="list-style-type: disc"><code class="literal">translate</code>: A two-element array representing the current translation vector</li></ul></div><p>At this point you might be asking what is the point of having this zoom function. Why can't D3 take care<a id="id586" class="indexterm"/> of this step for us? The reason is that D3 zoom behavior is not <a id="id587" class="indexterm"/>designed specifically for SVG, but rather designed as a general zoom behavior support mechanism. Therefore, this zoom function implements the translation of general zoom and pan events into SVG specific transformation.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec214"/>There's more...</h2></div></div></div><p>The zoom function is also capable of performing additional tasks other than simple coordinate system transformation. For example, a common technique is to load additional data when the user issues a zoom gesture, hence implementing the drill-down capability in zoom function. A well-known example is a digital map; as you increase zoom level on a map, more data and details then can be loaded and illustrated.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec215"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch02.html" title="Chapter 2. Be Selective">Chapter 2</a>, <em>Be Selective</em>, for more details on <code class="literal">d3.selection.call</code> function and selection manipulation</li><li class="listitem" style="list-style-type: disc">W3C SVG Coordinate system transformations specification for more information on how zoom and pan effect was achieved in SVG: <a class="ulink" href="http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace">http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace</a></li><li class="listitem" style="list-style-type: disc">d3.behavior.zoom API document for more details on D3 zoom support: <a class="ulink" href="https://github.com/mbostock/d3/wiki/Zoom-Behavior#wiki-zoom">https://github.com/mbostock/d3/wiki/Zoom-Behavior#wiki-zoom</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Implementing drag behavior</h1></div></div></div><p>Another common behavior in interactive visualization that we will cover in this chapter is <strong>drag</strong>. Drag <a id="id588" class="indexterm"/>is useful to provide capabilities in visualization allowing graphical rearrangement or even user input through force, which we will discuss in the next chapter. In this recipe we will explore how drag behavior is supported in D3.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec216"/>Getting ready</h2></div></div></div><p>Open your local copy of the <a id="id589" class="indexterm"/>following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/drag.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter10/drag.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec217"/>How to do it...</h2></div></div></div><p>Here, we will produce four <a id="id590" class="indexterm"/>circles that can be dragged using D3 drag behavior support and additionally with SVG boundary detection while dragging. Now, let's see how to implement this in code:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
    var width = 960, height = 500, r = 50;

    var data = [
        [width / 2 - r, height / 2 - r],
        [width / 2 - r, height / 2 + r],
        [width / 2 + r, height / 2 - r],
        [width / 2 + r, height / 2 + r]
    ];

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g");

    var drag = d3.behavior.drag()
            .on("drag", move);

    svg.selectAll("circle")
            .data(data)
            .enter().append("circle")
            .attr("r", r)
            .attr("transform", function (d) {
                return "translate(" + d + ")";
            })
            .call(drag);

    function move(d) {
        var x = d3.event.x, 
            y = d3.event.y;

        if(inBoundaries(x, y))
            d3.select(this) 
                .attr("transform", function (d) {
                    return "translate(" + x + ", " + y + ")";
                });
    }
    
    function inBoundaries(x, y){
        return (x &gt;= (0 + r) &amp;&amp; x &lt;= (width - r)) 
            &amp;&amp; (y &gt;= (0 + r) &amp;&amp; y &lt;= (height - r));
    }
&lt;/script&gt;</pre></div><p>This recipe generates<a id="id591" class="indexterm"/> drag behavior on the following four circles:</p><div><img src="img/2162OS_10_07.jpg" alt="How to do it..."/><div><p>Original</p></div></div><div><img src="img/2162OS_10_08.jpg" alt="How to do it..."/><div><p>Dragged</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec218"/>How it works...</h2></div></div></div><p>As we can see, similar <a id="id592" class="indexterm"/>to D3 zoom support, drag support follows a similar pattern. The main drag capability is provided by <code class="literal">d3.behavior.drag</code> function (line A). D3 drag behavior automatically creates appropriate low-level event listeners to handle drag gestures on the given element then translates low-level events to high-level D3 drag events. Both mouse and touch events are supported:</p><div><pre class="programlisting">var drag = d3.behavior.drag() // &lt;-A
            .on("drag", move);</pre></div><p>In this recipe we are interested in the <code class="literal">drag</code> event and it is handled by our <code class="literal">move</code> function. Similar to the zoom behavior, D3 drag behavior support is event driven, therefore, allowing maximum flexibility in implementation, supporting not only SVG but also the HTML5 canvas. Once defined, the behavior can be attached to any element by calling it on a given selection:</p><div><pre class="programlisting">svg.selectAll("circle")
            .data(data)
            .enter().append("circle")
            .attr("r", r)
            .attr("transform", function (d) {
                return "translate(" + d + ")";
            })
            .call(drag); // &lt;-B</pre></div><p>Next, in the <code class="literal">move</code> function we simply use SVG transformation to move the dragged element to proper location (line D) based on the information conveyed by the drag event (line C):</p><div><pre class="programlisting">   function move(d) {
        var x = d3.event.x, // &lt;-C
            y = d3.event.y;

        if(inBoundaries(x, y))
            d3.select(this) 
                .attr("transform", function (d) { // &lt;-D
                    return "translate(" + x + ", " + y + ")";
                });
}</pre></div><p>One additional <a id="id593" class="indexterm"/>condition we check here is to calculate the SVG boundaries constraint so the user cannot drag an element outside of the SVG. This is achieved by the following check:</p><div><pre class="programlisting">    function inBoundaries(x, y){
        return (x &gt;= (0 + r) &amp;&amp; x &lt;= (width - r)) 
            &amp;&amp; (y &gt;= (0 + r) &amp;&amp; y &lt;= (height - r));
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec219"/>There's more...</h2></div></div></div><p>Other than the drag event, D3 drag behavior also supports two other event types. The following list shows all supported drag event types and their attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dragstart</code>: Triggered <a id="id594" class="indexterm"/>when a <a id="id595" class="indexterm"/>drag gesture starts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">drag</code>: Fired when <a id="id596" class="indexterm"/>the element is dragged. <code class="literal">d3.event</code> will contain <em>x</em> and <em>y</em> properties <a id="id597" class="indexterm"/>representing the current absolute drag coordinates of the element. It will also contain <em>dx</em> and <em>dy</em> properties representing the element's coordinates relative to its position at the beginning of the gesture.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dragend</code>: Triggered <a id="id598" class="indexterm"/>when a<a id="id599" class="indexterm"/> drag gesture has finished.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec220"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="link" href="ch02.html" title="Chapter 2. Be Selective">Chapter 2</a>, <em>Be Selective</em>, for more details on <code class="literal">d3.selection.call</code> function and selection manipulation</li><li class="listitem" style="list-style-type: disc">d3.behavior.drag API document for more details on D3 drag support <a class="ulink" href="https://github.com/mbostock/d3/wiki/Drag-Behavior#wiki-drag">https://github.com/mbostock/d3/wiki/Drag-Behavior#wiki-drag</a></li></ul></div></div></div></body></html>