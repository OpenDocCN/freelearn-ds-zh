["```py\nfloat f = 1.0f;                  // In the OpenCL kernel\nchar c = 'a';                    // In the OpenCL kernel\nconst char* cs = \"hello world\\n\";\ncl_char c1 = 'b';                // in the host program\ncl_float f1 = 1.0f;              // in the host program\nconst cl_char* css = \"hello world\\n\";\n```", "```py\ncl_int x = 9;\ncl_float y = x; // y will get the value 9.0\n```", "```py\nint x = 9;\nfloat y = x;  // y will get the value 9.0\n```", "```py\nfloat f = 1.0f;\nint i = (int) f; // i would receive the value of 1\n```", "```py\nfloat f = 1.0f;\nfloat4 vf = (float4)f; // vf is a vector with elements (1.0, 1.0, 1.0, 1.0)\nuchar4 vtrue = (uchar4)true; // vtrue is a vector with elements(true, true, true, true)\n             // which is actually (0xff, 0xff, 0xff, 0xff)\n```", "```py\nfloat a = 1.0f;\nfloat b = 2.0f;\nfloat c = 3.0f;\nfloat d = 4.0f;\nfloat4 vf = (float4) (a, b, c, d);\n//vf will store (1.0f, 2.0f, 3.0f, 4.0f)\n```", "```py\nuint4 ui4 = (uint4)(9); // ui4 will store (9, 9, 9, 9)\n```", "```py\nfloat4 f = (float4) ((float2) (1.1f, 2.2f), \n                     (float2) (3.3f, 4.4f));\nfloat4 f2 = (float4) (1.1f, (float2) (2.2f, 3.3f), 4.4f);\n```", "```py\nfloat4 c;\nc.xyzw = (float4) (1.0f, 2.0f, 3.0f, 4.0f);\nfloat4 d;\nd.x = c.x;\nd.y = c.y;\nd.z = c.z;\nd.w = c.w; // d stores (1.0f, 2.0f, 3.0f, 4.0f)\n```", "```py\nfloat4 pos = (float4)(1.0f, 2.0f, 3.0f, 4.0f); \nfloat4 swiz= pos.wzyx; // swiz = (4.0f, 3.0f, 2.0f, 1.0f) \nfloat4 dup = pos.xxyy; // dup = (1.0f, 1.0f, 2.0f, 2.0f)\nfloat4 f, a, b;\nf.xyzw = a.s0123 + b.s0123;\n```", "```py\nfloat4 vf = (float4) (1.0f, 2.0f, 3.0f, 4.0f);\nfloat2 low = vf.lo; // returns vf.xy\nfloat2 high = vf.hi; // returns vf.zw\nfloat4 vf4 = (float4) (low, high);// returns (1.0f, 2.0f, 3.0f, 4.0f)\n```", "```py\nfloat4 vf4, wf4;\nint4 if4;\nwf4 = vf4; // illegal\nif4 = wf4; // illegal\n```", "```py\nfloat f = 4.4f;\nfloat4 va = (float4) (f); // va stores ( 4.4f, 4.4f, 4.4f, 4.4f)\n```", "```py\n#include <stdio.h>\ntypedef unsigned char* byte_pointer;\nvoid show_bytes(byte_pointer start, int len) {\n  int i;\n  for(i = 0; i < len; i++)\n    printf(\" %.2x\", start[i]);\n  printf(\"\\n\");\n}\nvoid show_int(int x) {\n  show_bytes((byte_pointer) &x, sizeof(int));\n}\nvoid show_float(float x) {\n  show_bytes((byte_pointer) &x, sizeof(float));\n}\nvoid show_pointer(void* x) {\n  show_bytes((byte_pointer) &x, sizeof(void*));\n}\nvoid test_show_bytes(int val ) {\n  int ival = val;\n  float fval = (float) ival;\n  int* pval = &ival;\n  show_int(ival);\n  show_float(fval);\n  show_pointer(pval);\n}\n```", "```py\n/* --- file: device_extensions.c --- */\ndisplayDeviceDetails( devices[i], CL_DEVICE_EXTENSIONS, \"CL_DEVICE_EXTENSIONS\");\nvoid displayDeviceDetails(cl_device_id id,\n                          cl_device_info param_name,\n                          const char* paramNameAsStr) {\n  cl_int error = 0;\n  size_t paramSize = 0;\n  error = clGetDeviceInfo( id, param_name, 0, NULL, &paramSize );\n  if (error != CL_SUCCESS ) {\n    perror(\"Unable to obtain device info for param\\n\");\n    return;\n  }\n  /* the cl_device_info are preprocessor directives defined in cl.h */\n  switch (param_name) {\n// code omitted\n    case CL_DEVICE_EXTENSIONS : {\n// beware of buffer overflow; alternatively use the OpenCL C++ //bindings\n      char* extension_info[4096];\n      error = clGetDeviceInfo( id, CL_DEVICE_EXTENSIONS, sizeof(extension_info), extension_info, NULL);\n      printf(\"\\tSupported extensions: %s\\n\", extension_info);\n    }break;\n  } //end of switch\n```", "```py\nfloat4 v, u;\nfloat f;\nv = u + f;\n// equivalent to \n// v.x = u.x + f\n// v.y = u.y + f\n// v.z = u.z + f\n// v.w = u.w + f\nfloat4 a, b, c;\nc = a + b\n// equivalent to \n// c.x = a.x + b.x\n// c.y = a.y + b.y\n// c.z = a.z + b.z\n// c.w = a.w + b.w\n```", "```py\n__kernel void copyNPaste(__global float* in, __global float8* out) {\n  size_t id = get_global_id(0);\n  size_t index = id*sizeof(float8);\n  float8 t = vload8(index, in);\n  out[index].s0 = t.s0;\n  out[index].s1 = t.s1;\n  out[index].s2 = t.s2;\n  out[index].s3 = t.s3;\n  out[index].s4 = t.s4;\n  out[index].s5 = t.s5;\n  out[index].s6 = t.s6;\n  out[index].s7 = t.s7;\n}\n```", "```py\n#ifdef __CL_FLOAT4__\nint valuesOK(cl_float8* to, cl_float8* from, size_t length) {\n#ifdef DEBUG\n  printf(\"Checking data of size: %lu\\n\", length);\n#endif\n  for(int i = 0; i < length; ++i) {\n#ifdef __SSE__\n    __cl_float4 __toFirstValue = to->v4[0];\n    __cl_float4 __toSecondValue = to->v4[1];\n    __cl_float4 __fromFirstValue = from->v4[0];\n    __cl_float4 __fromSecondValue = from->v4[1];\n    __m128i vcmp = (__m128i) _mm_cmpneq_ps(__toFirstValue, __fromFirstValue);\n    uint16_t test = _mm_movemask_epi8(vcmp);\n    __m128i vcmp_2 = (__m128i) _mm_cmpneq_ps(__toSecondValue, __fromSecondValue);\n    uint16_t test_2 = _mm_movemask_epi8(vcmp_2);\n    if( (test|test_2) != 0 ) return 0; // indicative that the result failed\n#else\n    #error \"SSE not supported, which is required for example code to work!\"\n#endif\n  }\nreturn 1;\n}\n#endif\n```", "```py\n$ gdb ./Vectorization \nGNU gdb (GDB) 7.5-ubuntu\nCopyright (C) 2012 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later sa<http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>...\nReading symbols from /home/tayboonl/PACKT_OpenCL_Book/src/Ch3/vectorization/Vectorization...done.\n(gdb) disassemble /m valuesOK \nDump of assembler code for function valuesOK:\nwarning: Source file is more recent than executable.\n31 int valuesOK(cl_float8* to, cl_float8* from, size_t length) {\n  0x000000000040117c <+0>: push  %rbp\n  0x000000000040117d <+1>: mov  %rsp,%rbp\n  0x0000000000401180 <+4>: sub  $0xf0,%rsp\n  0x0000000000401187 <+11>: mov  %rdi,-0xd8(%rbp)\n  0x000000000040118e <+18>: mov  %rsi,-0xe0(%rbp)\n  0x0000000000401195 <+25>: mov  %rdx,-0xe8(%rbp)\n32 #ifdef DEBUGf\n33 printf(\"Checking data of size: %lu\\n\", length);\n  0x000000000040119c <+32>: mov  -0xe8(%rbp),%rax\n  0x00000000004011a3 <+39>: mov  %rax,%rsi\n  0x00000000004011a6 <+42>: mov  $0x4020a8,%edi\n  0x00000000004011ab <+47>: mov  $0x0,%eax\n  0x00000000004011b0 <+52>: callq  0x400f20 <printf@plt>\n34 #endif\n35 for(int i = 0; i < length; ++i) {\n  0x00000000004011b5 <+57>: movl  $0x0,-0xc4(%rbp)\n  0x00000000004011bf <+67>: jmpq  0x4012a9 <valuesOK+301>\n  0x00000000004012a2 <+294>: addl  $0x1,-0xc4(%rbp)\n  0x00000000004012a9 <+301>: mov  -0xc4(%rbp),%eax\n  0x00000000004012af <+307>: cltq  \n  0x00000000004012b1 <+309>: cmp  -0xe8(%rbp),%rax\n  0x00000000004012b8 <+316>: jb  0x4011c4 <valuesOK+72>\n36 #ifdef __SSE__\n37    __cl_float4 __toFirstValue = to->v4[0];\n  0x00000000004011c4 <+72>: mov  -0xd8(%rbp),%rax\n  0x00000000004011cb <+79>: movaps (%rax),%xmm0\n  0x00000000004011ce <+82>: movaps %xmm0,-0xc0(%rbp)\n38    __cl_float4 __toSecondValue = to->v4[1];\n  0x00000000004011d5 <+89>: mov  -0xd8(%rbp),%rax\n  0x00000000004011dc <+96>: movaps 0x10(%rax),%xmm0\n  0x00000000004011e0 <+100>: movaps %xmm0,-0xb0(%rbp)\n\n39    __cl_float4 __fromFirstValue = from->v4[0];\n  0x00000000004011e7 <+107>: mov  -0xe0(%rbp),%rax\n  0x00000000004011ee <+114>: movaps (%rax),%xmm0\n  x00000000004011f1 <+117>: movaps %xmm0,-0xa0(%rbp)\n40    __cl_float4 __fromSecondValue = from->v4[1];\n  0x00000000004011f8 <+124>: mov  -0xe0(%rbp),%rax\n  0x00000000004011ff <+131>: movaps 0x10(%rax),%xmm0\n  0x0000000000401203 <+135>: movaps %xmm0,-0x90(%rbp)\n  0x000000000040120a <+142>: movaps -0xc0(%rbp),%xmm0\n  0x0000000000401211 <+149>: movaps %xmm0,-0x60(%rbp)\n---Type <return> to continue, or q <return> to quit---\n  0x0000000000401215 <+153>: movaps -0xa0(%rbp),%xmm0\n  0x000000000040121c <+160>: movaps %xmm0,-0x50(%rbp)\n41    __m128i vcmp = (__m128i) _mm_cmpneq_ps(__toFirstValue, __fromFirstValue);\n  0x0000000000401229 <+173>: movdqa %xmm0,-0x80(%rbp)\n  0x000000000040122e <+178>: movdqa -0x80(%rbp),%xmm0\n  0x0000000000401233 <+183>: movdqa %xmm0,-0x40(%rbp)\n42    uint16_t test = _mm_movemask_epi8(vcmp);\n  0x0000000000401241 <+197>: mov  %ax,-0xc8(%rbp)\n  0x0000000000401248 <+204>: movaps -0xb0(%rbp),%xmm0\n  0x000000000040124f <+211>: movaps %xmm0,-0x30(%rbp)\n  0x0000000000401253 <+215>: movaps -0x90(%rbp),%xmm0\n  0x000000000040125a <+222>: movaps %xmm0,-0x20(%rbp)\n43    __m128i vcmp_2 = (__m128i) _mm_cmpneq_ps(__toSecondValue, __fromSecondValue);\n  0x0000000000401267 <+235>: movdqa %xmm0,-0x70(%rbp)\n  0x000000000040126c <+240>: movdqa -0x70(%rbp),%xmm0\n  0x0000000000401271 <+245>: movdqa %xmm0,-0x10(%rbp)\n44    uint16_t test_2 = _mm_movemask_epi8(vcmp_2);\n  0x000000000040127f <+259>: mov  %ax,-0xc6(%rbp)\n45    if( (test|test_2) != 0 ) return 0; // indicative that the result failed\n  0x0000000000401286 <+266>: movzwl -0xc6(%rbp),%eax\n  0x000000000040128d <+273>: movzwl -0xc8(%rbp),%edx\n  0x0000000000401294 <+280>: or  %edx,%eax\n  0x0000000000401296 <+282>: test  %ax,%ax\n  0x0000000000401299 <+285>: je  0x4012a2 <valuesOK+294>\n  0x000000000040129b <+287>: mov  $0x0,%eax\n  0x00000000004012a0 <+292>: jmp  0x4012c3 <valuesOK+327>\n46 #else\n47    #error \"SSE not supported, which is required for example code to work!\"  \n48 #endif\n49  }\n50 return 1;\n  0x00000000004012be <+322>: mov  $0x1,%eax\n51  }\n  0x00000000004012c3 <+327>: leaveq\n  0x00000000004012c4 <+328>: retq\nEnd of assembler dump\n(gdb)\n```", "```py\nfloat4 a,b;\nfloat4 c = a + b;\n```", "```py\n__m128 a, b;\n__m128 c = __mm_add_ps(a, b);\n```", "```py\nint valuesOK(cl_float8* to, cl_float8* from, size_t length) {\n// code omitted\nfor(int i = 0; i < length; ++i) {\n```", "```py\n    __cl_float4 __hostFirstValue = to->v4[0];\n    __cl_float4 __hostSecondValue = to->v4[1];\n```", "```py\n    __cl_float4 __deviceFirstValue = from->v4[0];\n    __cl_float4 __deviceSecondValue = from->v4[1];\n```", "```py\n    __m128i vcmp = (__m128i) _mm_cmpneq_ps(__hostFirstValue, __deviceFirstValue);\n    uint16_t test = _mm_movemask_epi8(vcmp);\n    __m128i vcmp_2 = (__m128i) _mm_cmpneq_ps(__hostSecondValue, __deviceSecondValue);\n    uint16_t test_2 = _mm_movemask_epi8(vcmp_2);\n```", "```py\n    if( (test|test_2) != 0 ) return 0; // indicative that the result failed\n#else\n```", "```py\n// autovectoize assuming float4 as computation width\n__kernel __attribute__((vec_type_hint(float4)))\nvoid computeThis(__global float4*p ) {…}\n// autovectorize assuming double as computation width\n__kernel __attribute__((vec_type_hint(double)))\nvoid computeThis(__global float4*p ) {…}\n// autovectorize assuming int (default) as computation width\n__kernel __attribute__((vec_type_hint(int)))\nvoid computeThis(__global float4*p ) {…}\n```", "```py\n#if defined(__SSE__)\n#if defined(__MINGW64__)\n#include <intrin.h>\n#else\n#include <xmmintrin.h> \n#endif\n#if defined(__GNUC__)\ntypedef float __cl_float4 __attribute__((vector_size(16)));\n#else\ntypedef __m128 __cl_float4;// statement 1\n#endif\n#define __CL_FLOAT4__ 1// statement 2\n#endif\n```", "```py\ndisplayDeviceDetails( devices[i], CL_DEVICE_GLOBAL_MEM_SIZE, \"CL_DEVICE_GLOBAL_MEM_SIZE\");\nvoid displayDeviceDetails(cl_device_id id,\n                          cl_device_info param_name,\n                          const char* paramNameAsStr) {\n  cl_int error = 0;\n  size_t paramSize = 0;\n  error = clGetDeviceInfo( id, param_name, 0, NULL, &paramSize );\n  if (error != CL_SUCCESS ) {\n    perror(\"Unable to obtain device info for param\\n\");\n    return;\n  }\n  /* the cl_device_info are preprocessor directives defined in cl.h */\n  switch (param_name) { \n    case CL_DEVICE_GLOBAL_MEM_SIZE:\n    case CL_DEVICE_MAX_MEM_ALLOC_SIZE: {\n      cl_ulong* size = (cl_ulong*) alloca(sizeof(cl_ulong) * paramSize);\n      error = clGetDeviceInfo( id, param_name, paramSize, size, NULL );\n      if (error != CL_SUCCESS ) {\n        perror(\"Unable to obtain device name/vendor info for param\\n\");\n        return;\n      }\n```", "```py\n__kernel void copyNPaste(__global float* in, __global float8* out) {\n    size_t id = get_global_id(0);\n    size_t index = id*sizeof(float8);\n    float8 t = vload8(index, in);\n    out[index].s0 = t.s0;\n  //code omitted\n  out[index].s7 = t.s7;\n}\n```", "```py\n#ifdef fp64\n#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n#endif\n__kernel void add3(__global float* a, __global float* b, __global float* out) {\n  int id = get_global_id(0);\n#ifdef fp64\n  double d = (double)a[id] + (double)b[id];\n  out[id] = d;\n#else\n  out[id] = a[id] + b[id];\n#endif\n}\n```", "```py\n// memobj1 & memobj2 refers to float arrays for consumption\n// outObj refers to the output float array\nerror = clSetKernelArg(kernels[j], 0, sizeof(cl_mem), &memobj1);\nerror = clSetKernelArg(kernels[j], 1, sizeof(cl_mem), &memobj2);\nerror = clSetKernelArg(kernels[j], 2, sizeof(cl_mem), &outObj);\nif (error != CL_SUCCESS) { \n  perror(\"Unable to set buffer object in kernel arguments\");\n  exit(1);\n}\n/* Enqueue the kernel to the command queue */\nsize_t local[1] = {1};\nsize_t global[1] = {64};\nerror = clEnqueueNDRangeKernel(cQ, kernels[j], 1, NULL, global, local, 0, NULL, NULL);\nif (error != CL_SUCCESS) {\n  perror(\"Unable to enqueue task to command-queue\");\n  exit(1);}\n```", "```py\nNumber of OpenCL platforms found: 1\nNumber of detected OpenCL devices: 2\nKernel name: add3 with arity: 3\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nChecking data of size: 64\nCheck passed!\nKernel name: add3 with arity: 3\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\nChecking data of size: 64\nCheck passed!\n\n```", "```py\ncl_device_fp_config config;\nclGetDeviceInfo( deviceId, CL_DEVICE_DOUBLE_FP_CONFIG, sizeof(config), &config, NULL);\nif (config & CL_FP_ROUND_TO_NEAREST) printf(\"Round to nearest is supported on the device!\");\n```", "```py\ncl_uint vectorWidth;\nsize_t returned_size;\nclGetDeviceInfo( deviceId, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE,sizeof(cl_uint), &vectorWidth, &returned_size);\nif(vectorWidth > 0) printf(\"Vectors of size %d for 'double' are:\", vectorWidth);\n```"]