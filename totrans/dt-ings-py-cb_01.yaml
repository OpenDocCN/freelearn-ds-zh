- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Data Ingestion
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据摄取简介
- en: Welcome to the fantastic world of data! Are you ready to embark on a thrilling
    journey into data ingestion? If so, this is the perfect book to start! Ingesting
    data is the first step into the big data world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到数据世界的奇妙世界！你准备好开始一段令人兴奋的数据摄取之旅了吗？如果是这样，这本书正是你开始的最佳选择！摄取数据是进入大数据世界的第一步。
- en: '**Data ingestion** is a process that involves gathering and importing data
    and also storing it properly so that the subsequent **extract, transform, and
    load** (**ETL**) pipeline can utilize the data. To make it happen, we must be
    cautious about the tools we will use and how to configure them properly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据摄取**是一个涉及收集和导入数据，并且还要妥善存储数据的过程，以便后续的 **提取、转换和加载**（**ETL**）管道可以利用这些数据。为了实现这一点，我们必须谨慎选择我们将使用的工具以及如何正确配置它们。'
- en: In our book journey, we will use **Python** and **PySpark** to retrieve data
    from different data sources and learn how to store them properly. To orchestrate
    all this, the basic concepts of **Airflow** will be implemented, along with efficient
    monitoring to guarantee that our pipelines are covered.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的书籍之旅中，我们将使用 **Python** 和 **PySpark** 从不同的数据源检索数据，并学习如何正确存储它们。为了协调所有这些，我们将实现
    **Airflow** 的基本概念，以及高效的监控，以确保我们的管道得到覆盖。
- en: This chapter will introduce some basic concepts about data ingestion and how
    to set up your environment to start the tasks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍有关数据摄取的一些基本概念以及如何设置你的环境以开始任务。
- en: 'In this chapter, you will build and learn the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建并学习以下食谱：
- en: Setting up Python and the environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Python 和环境
- en: Installing PySpark
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 PySpark
- en: Configuring Docker for MongoDB
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 MongoDB 配置 Docker
- en: Configuring Docker for Airflow
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Airflow 配置 Docker
- en: Logging libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志库
- en: Creating schemas
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模式
- en: Applying data governance in ingestion
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在摄取中应用数据治理
- en: Implementing data replication
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据复制
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The commands inside the recipes of this chapter use Linux syntax. If you don’t
    use a Linux-based system, you may need to adapt the commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的命令使用 Linux 语法。如果你不使用基于 Linux 的系统，你可能需要调整命令：
- en: Docker or Docker Desktop
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 或 Docker Desktop
- en: The SQL client of your choice (recommended); we recommend DBeaver, since it
    has a community-free version
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择你喜欢的 SQL 客户端（推荐）；我们推荐 DBeaver，因为它有一个社区免费版本
- en: 'You can find the code from this chapter in this GitHub repository: [https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个 GitHub 仓库中找到本章的代码：[https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook](https://github.com/PacktPublishing/Data-Ingestion-with-Python-Cookbook)。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Windows users might get an error message such as **Docker Desktop requires
    a newer WSL kernel version.** This can be fixed by following the steps here: [https://docs.docker.com/desktop/windows/wsl/](https://docs.docker.com/desktop/windows/wsl/).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可能会收到类似于 **Docker Desktop 需要更新的 WSL 内核版本**的错误消息。这可以通过遵循以下步骤来解决：[https://docs.docker.com/desktop/windows/wsl/](https://docs.docker.com/desktop/windows/wsl/)。
- en: Setting up Python and its environment
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Python 和其环境
- en: In the data world, languages such as **Java**, **Scala**, or **Python** are
    commonly used. The first two languages are used due to their compatibility with
    the big data tools environment, such as **Hadoop** and **Spark**, the central
    core of which runs on a **Java Virtual Machine** (**JVM**). However, in the past
    few years, the use of Python for data engineering and data science has increased
    significantly due to the language’s versatility, ease of understanding, and many
    open source libraries built by the community.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据领域，如 **Java**、**Scala** 或 **Python** 这样的语言被广泛使用。前两种语言因其与大数据工具环境（如 **Hadoop**
    和 **Spark**）的兼容性而被使用，其中核心部分运行在 **Java 虚拟机**（**JVM**）上。然而，在过去的几年里，由于语言的通用性、易于理解以及社区构建的许多开源库，Python
    在数据工程和数据科学领域的使用显著增加。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let’s create a folder for our project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的项目创建一个文件夹：
- en: First, open your system command line. Since I use the **Windows Subsystem for
    Linux** (**WSL**), I will open the WSL application.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开你的系统命令行。由于我使用的是 **Windows Subsystem for Linux**（**WSL**），我将打开 WSL 应用程序。
- en: 'Go to your home directory and create a folder as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你的主目录并创建一个文件夹，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go inside this folder:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入这个文件夹：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check your Python version on your operating system as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式检查你的操作系统上的 Python 版本：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Depending on your operational system, you might or might not have output here
    – for example, WSL 20.04 users might have the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，您可能在这里看到输出，例如，WSL 20.04 用户可能看到以下输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If your Python path is configured to use the `python` command, you will see
    output similar to this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Python 路径配置为使用 `python` 命令，您将看到类似以下输出的内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Sometimes, your Python path might be configured to be invoked using `python3`.
    You can try it using the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的 Python 路径可能配置为使用 `python3` 来调用。您可以使用以下命令尝试：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be similar to the `python` command, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与 `python` 命令类似，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s check our `pip` version. This check is essential, since some operating
    systems have more than one Python version installed:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的 `pip` 版本。这个检查是必要的，因为一些操作系统安装了多个 Python 版本：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see similar output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似的输出：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If your `3.8x` or doesn’t have the language installed, proceed to the *How to
    do it* steps; otherwise, you are ready to start the following *Installing* *PySpark*
    recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统没有安装 `3.8x` 或其他版本的语言，请继续执行 *如何操作* 步骤；否则，您就可以开始以下 *安装 PySpark* 菜谱了。
- en: How to do it…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We are going to use the official installer from Python.org. You can find the
    link for it here: [https://www.python.org/downloads/](https://www.python.org/downloads/):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用来自 Python.org 的官方安装程序。您可以在以下链接找到它：[https://www.python.org/downloads/](https://www.python.org/downloads/):'
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For Windows users, it is important to check your OS version, since Python 3.10
    may not be yet compatible with Windows 7, or your processor type (32-bits or 64-bits).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 用户，检查您的操作系统版本很重要，因为 Python 3.10 可能还不兼容 Windows 7，或者您的处理器类型（32 位或
    64 位）。
- en: Download one of the stable versions.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载其中一个稳定版本。
- en: 'At the time of writing, the stable recommended versions compatible with the
    tools and resources presented here are `3.8`, `3.9`, and `3.10`. I will use the
    `3.9` version and download it using the following link: [https://www.python.org/downloads/release/python-390/](https://www.python.org/downloads/release/python-390/).
    Scrolling down the page, you will find a list of links to Python installers according
    to OS, as shown in the following screenshot.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，与这里展示的工具和资源兼容的稳定推荐版本是 `3.8`、`3.9` 和 `3.10`。我将使用 `3.9` 版本，并使用以下链接下载它：[https://www.python.org/downloads/release/python-390/](https://www.python.org/downloads/release/python-390/)。向下滚动页面，您将找到根据操作系统列出的
    Python 安装程序的链接，如下面的截图所示。
- en: '![Figure 1.1 – Python.org download files for version 3.9](img/Figure_1.1_B19453.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Python.org 3.9 版本下载文件](img/Figure_1.1_B19453.jpg)'
- en: Figure 1.1 – Python.org download files for version 3.9
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Python.org 3.9 版本下载文件
- en: After downloading the installation file, double-click it and follow the instructions
    in the wizard window. To avoid complexity, choose the recommended settings displayed.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载安装文件后，双击它，并按照向导窗口中的说明操作。为了避免复杂性，请选择显示的推荐设置。
- en: 'The following screenshot shows how it looks on Windows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Windows 上的样子：
- en: '![Figure 1.2 – The Python Installer for Windows](img/Figure_1.2_B19453.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Windows 的 Python 安装程序](img/Figure_1.2_B19453.jpg)'
- en: Figure 1.2 – The Python Installer for Windows
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Windows 的 Python 安装程序
- en: 'If you are a Linux user, you can install it from the source using the following
    commands:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您是 Linux 用户，您可以使用以下命令从源安装它：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After installing Python, you should be able to execute the `pip` command. If
    not, refer to the `pip` official documentation page here: [https://pip.pypa.io/en/stable/installation/](https://pip.pypa.io/en/stable/installation/).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Python 后，您应该能够执行 `pip` 命令。如果不能，请参考此处提供的 `pip` 官方文档页面：[https://pip.pypa.io/en/stable/installation/](https://pip.pypa.io/en/stable/installation/).
- en: How it works…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Python is an **interpreted language**, and its interpreter extends several functions
    made with **C** or **C++**. The language package also comes with several built-in
    libraries and, of course, the interpreter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种 **解释型语言**，其解释器扩展了用 **C** 或 **C++** 制成的几个功能。语言包还附带了一些内置库，当然，还有解释器。
- en: 'The interpreter works like a Unix shell and can be found in the `usr/local/bin`
    directory: [https://docs.python.org/3/tutorial/interpreter.xhtml](https://docs.python.org/3/tutorial/interpreter.xhtml).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的工作方式类似于 Unix shell，可以在 `usr/local/bin` 目录中找到：[https://docs.python.org/3/tutorial/interpreter.xhtml](https://docs.python.org/3/tutorial/interpreter.xhtml).
- en: Lastly, note that many Python third-party packages in this book require the
    `pip` command to be installed. This is because `pip` (an acronym for **Pip Installs
    Packages**) is the default package manager for Python; therefore, it is used to
    install, upgrade, and manage the Python packages and dependencies from the **Python
    Package** **Index** (**PyPI**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，本书中许多 Python 第三方包需要安装 `pip` 命令。这是因为 `pip`（即 **Pip Installs Packages**
    的缩写）是 Python 的默认包管理器；因此，它用于安装、升级和管理来自 **Python 包索引**（**PyPI**）的 Python 包及其依赖项。
- en: There’s more…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Even if you don’t have any Python versions on your machine, you can still install
    them using the command line or **HomeBrew** (for **macOS** users). Windows users
    can also download them from the MS Windows Store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的机器上没有 Python 版本，你仍然可以使用命令行或 **HomeBrew**（适用于 **macOS** 用户）来安装它们。Windows
    用户也可以从 MS Windows Store 下载它们。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you choose to download Python from the Windows Store, ensure you use an application
    made by the Python Software Foundation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择从 Windows Store 下载 Python，请确保使用由 Python 软件基金会制作的应用程序。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can use `pip` to install convenient third-party applications, such as Jupyter.
    This is an open source, web-based, interactive (and user-friendly) computing platform,
    often used by data scientists and data engineers. You can install it from the
    official website here: [https://jupyter.org/install](https://jupyter.org/install).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pip` 安装方便的第三方应用程序，例如 Jupyter。这是一个开源的、基于网络的、交互式（且用户友好）的计算平台，常被数据科学家和数据工程师使用。你可以从这里安装它：[https://jupyter.org/install](https://jupyter.org/install)。
- en: Installing PySpark
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PySpark
- en: To process, clean, and transform vast amounts of data, we need a tool that provides
    resilience and distributed processing, and that’s why **PySpark** is a good fit.
    It gets an API over the Spark library that lets you use its applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理、清理和转换大量数据，我们需要一个提供弹性和分布式处理的工具，这就是为什么 **PySpark** 是一个好的选择。它通过 Spark 库提供了一个
    API，让你可以使用其应用程序。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before starting the PySpark installation, we need to check our Java version
    in our operational system:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始 PySpark 安装之前，我们需要在我们的操作系统中检查我们的 Java 版本：
- en: 'Here, we check the Java version:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们检查 Java 版本：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see output similar to this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似的输出：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If everything is correct, you should see the preceding message as the output
    of the command and the **OpenJDK 18** version or higher. However, some systems
    don’t have any Java version installed by default, and to cover this, we need to
    proceed to *step 2*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到命令的输出中显示上述消息，以及 **OpenJDK 18** 版本或更高。然而，某些系统默认没有安装任何 Java 版本，为了覆盖这种情况，我们需要进行到
    *步骤 2*。
- en: Now, we download the **Java Development** **Kit** (**JDK**).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们下载**Java 开发工具包**（**JDK**）。
- en: Go to [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/),
    select your **OS**, and download the most recent version of JDK. At the time of
    writing, it is JDK 19.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/)，选择你的
    **操作系统**，下载 JDK 的最新版本。在撰写本文时，是 JDK 19。
- en: 'The download page of the JDK will look as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 的下载页面看起来如下：
- en: '![Figure 1.3 – The JDK 19 downloads official web page](img/Figure_1.3_B19453.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – JDK 19 下载官方网页](img/Figure_1.3_B19453.jpg)'
- en: Figure 1.3 – The JDK 19 downloads official web page
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – JDK 19 下载官方网页
- en: 'Execute the downloaded application. Click on the application to start the installation
    process. The following window will appear:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行下载的应用程序。点击应用程序以启动安装过程。以下窗口将出现：
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your OS, the installation window may appear slightly different.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统，安装窗口可能略有不同。
- en: '![Figure 1.4 – The Java installation wizard window](img/Figure_1.4_B19453.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Java 安装向导窗口](img/Figure_1.4_B19453.jpg)'
- en: Figure 1.4 – The Java installation wizard window
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Java 安装向导窗口
- en: Click **Next** for the following two questions, and the application will start
    the installation. You don’t need to worry about where the JDK will be installed.
    By default, the application is configured, as standard, to be compatible with
    other tools’ installations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **下一步**回答以下两个问题，应用程序将开始安装。你不需要担心 JDK 将安装在哪里。默认情况下，应用程序配置为与标准兼容，以便与其他工具的安装兼容。
- en: 'Next, we again check our Java version. When executing the command again, you
    should see the following version:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次检查我们的 Java 版本。再次执行命令时，你应该看到以下版本：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the steps to perform this recipe:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是执行此菜谱的步骤：
- en: 'Install PySpark from PyPi:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从PyPi安装PySpark：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the command runs successfully, the installation output’s last line will
    look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令运行成功，安装输出的最后一行将如下所示：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Execute the `pyspark` command to open the interactive shell. When executing
    the `pyspark` command in your command line, you should see this message:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`pyspark`命令以打开交互式shell。当你在命令行中执行`pyspark`命令时，你应该看到以下消息：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can observe some interesting messages here, such as the Spark version and
    the Python used from PySpark.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到一些有趣的消息，例如Spark的版本和PySpark使用的Python版本。
- en: 'Finally, we exit the interactive shell as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式退出交互式shell：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As seen at the beginning of this recipe, Spark is a robust framework that runs
    on top of the JVM. It is also an open source tool for creating resilient and distributed
    processing output from vast data. With the growth in popularity of the Python
    language in the past few years, it became necessary to have a solution that adapts
    Spark to run alongside Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如本食谱开头所见，Spark是一个运行在JVM之上的强大框架。它也是一个开源工具，可以从大量数据中创建健壮和分布式处理输出。随着Python语言在过去几年中的普及，需要一个解决方案来适配Spark以便与Python一起运行。
- en: PySpark is an interface that interacts with **Spark APIs via Py4J**, dynamically
    allowing Python code to interact with the JVM. We first need to have Java installed
    on our OS to use Spark. When we install PySpark, it already comes with Spark and
    Py4J components installed, making it easy to start the application and build the
    code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: PySpark是一个通过Py4J与Spark API交互的接口，它动态地允许Python代码与JVM交互。我们首先需要在我们的操作系统上安装Java才能使用Spark。当我们安装PySpark时，它已经包含了Spark和Py4J组件，这使得启动应用程序和构建代码变得容易。
- en: There’s more…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Anaconda is a convenient way to install PySpark and other data science tools.
    This tool encapsulates all manual processes and has a friendly interface for interacting
    with and installing Python components, such as **NumPy**, **pandas**, or **Jupyter**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Anaconda是安装PySpark和其他数据科学工具的便捷方式。这个工具封装了所有手动过程，并为与Python组件（如**NumPy**、**pandas**或**Jupyter**）交互和安装提供了一个友好的界面：
- en: 'To install Anaconda, go to the official website and select **Products** | **Anaconda**
    **Distribution**: [https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution).'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Anaconda，请访问官方网站并选择**产品** | **Anaconda发行版**：[https://www.anaconda.com/products/distribution](https://www.anaconda.com/products/distribution)。
- en: Download the distribution according to your OS.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的操作系统下载发行版。
- en: For more detailed information about how to install Anaconda and other powerful
    commands, refer to [https://docs.anaconda.com/](https://docs.anaconda.com/).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装Anaconda和其他强大命令的更详细信息，请参阅[https://docs.anaconda.com/](https://docs.anaconda.com/)。
- en: Using virtualenv with PySpark
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用virtualenv与PySpark
- en: It is possible to configure and use `virtualenv` with PySpark, and Anaconda
    does it automatically if you choose this type of installation. However, for the
    other installation methods, we need to make some additional steps to make our
    Spark cluster (locally or on the server) run it, which includes indicating the
    `virtualenv /bin/` folder and where your PySpark path is.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置并使用`virtualenv`与PySpark，如果你选择这种安装类型，Anaconda会自动完成。然而，对于其他安装方法，我们需要采取一些额外步骤来确保我们的Spark集群（本地或服务器上）能够运行它，这包括指定`virtualenv
    /bin/`文件夹和你的PySpark路径。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'There is a nice article about this topic, *Using VirtualEnv with PySpark*,
    by jzhang, here: [https://community.cloudera.com/t5/Community-Articles/Using-VirtualEnv-with-PySpark/ta-p/245932](https://community.cloudera.com/t5/Community-Articles/Using-VirtualEnv-with-PySpark/ta-p/245932).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题有一篇不错的文章，*使用VirtualEnv与PySpark*，作者是jzhang，可以在这里找到：[https://community.cloudera.com/t5/Community-Articles/Using-VirtualEnv-with-PySpark/ta-p/245932](https://community.cloudera.com/t5/Community-Articles/Using-VirtualEnv-with-PySpark/ta-p/245932)。
- en: Configuring Docker for MongoDB
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker用于MongoDB
- en: '**MongoDB** is a **Not Only SQL** (**NoSQL**) document-oriented database, widely
    used to store **Internet of Things** (**IoT**) data, application logs, and so
    on. A NoSQL database is a non-relational database that stores unstructured data
    differently from relational databases such as MySQL or PostgreSQL. Don’t worry
    too much about this now; we will cover it in more detail in [*Chapter 5*](B19453_05.xhtml#_idTextAnchor161).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB**是一个**非SQL**（**NoSQL**）文档型数据库，广泛用于存储**物联网**（**IoT**）数据、应用程序日志等。NoSQL数据库是一个非关系型数据库，它以不同于MySQL或PostgreSQL等关系型数据库的方式存储非结构化数据。现在不必过于担心这个问题；我们将在[*第五章*](B19453_05.xhtml#_idTextAnchor161)中更详细地介绍它。'
- en: Your cluster production environment can handle huge amounts of data and create
    resilient data storage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你的集群生产环境可以处理大量数据并创建具有弹性的数据存储。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Following the good practice of code organization, let’s start creating a folder
    inside our project to store the Docker image:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循代码组织的良好实践，让我们开始在项目内创建一个文件夹来存储 Docker 镜像：
- en: 'Create a folder inside our project directory to store the MongoDB Docker image
    and data as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目目录内创建一个文件夹以存储 MongoDB Docker 镜像和数据，如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Here are the steps to try out this recipe:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是尝试这个菜谱的步骤：
- en: 'First, we pull the Docker image from Docker Hub as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们按照以下方式从 Docker Hub 拉取 Docker 镜像：
- en: '[PRE18]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see the following message in your command line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在命令行中看到以下消息：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are a WSL user, an error might occur if you use the WSL 1 version instead
    of version 2\. You can easily fix this by following the steps here: [https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 WSL 1 版本而不是版本 2，可能会出现错误。你可以通过遵循以下步骤轻松修复此问题：[https://learn.microsoft.com/en-us/windows/wsl/install](https://learn.microsoft.com/en-us/windows/wsl/install)。
- en: 'Then, we run the MongoDB server as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式运行 MongoDB 服务器：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then check our server. To do this, we can use the command line to see which
    Docker images are running:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查我们的服务器。为此，我们可以使用命令行来查看哪些 Docker 镜像正在运行：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then see this on the screen:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在屏幕上看到以下内容：
- en: '![Figure 1.5 – MongoDB and Docker running container](img/Figure_1.5_B19453.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – MongoDB 和 Docker 运行容器](img/Figure_1.5_B19453.jpg)'
- en: Figure 1.5 – MongoDB and Docker running container
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – MongoDB 和 Docker 运行容器
- en: 'We can even check on the Docker Desktop application to see whether our container
    is running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在 Docker Desktop 应用程序中检查我们的容器是否正在运行：
- en: '![Figure 1.6 – The Docker Desktop vision of the MongoDB container running](img/Figure_1.6_B19453.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 运行中的 MongoDB 容器的 Docker Desktop 视图](img/Figure_1.6_B19453.jpg)'
- en: Figure 1.6 – The Docker Desktop vision of the MongoDB container running
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 运行中的 MongoDB 容器的 Docker Desktop 视图
- en: 'Finally, we need to stop our container. We need to use `Container ID` to stop
    the container, which we previously saw when checking the Docker running images.
    We will rerun it in [*Chapter 5*](B19453_05.xhtml#_idTextAnchor161):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要停止我们的容器。我们需要使用 `Container ID` 来停止容器，这是我们之前在检查正在运行的 Docker 镜像时看到的。我们将在
    [*第 5 章*](B19453_05.xhtml#_idTextAnchor161) 中重新运行它：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: MongoDB’s architecture uses the concept of `main` node interacts with clients’
    requests, such as queries and document manipulation. It distributes the requests
    automatically among its shards, which are a subset of a larger data collection
    here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的架构使用 `main` 节点与客户端请求交互的概念，例如查询和文档操作。它自动在其分片之间分配请求，分片是这里更大数据集合的子集。
- en: '![Figure 1.7 – MongoDB architecture](img/Figure_1.7_B19453.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – MongoDB 架构](img/Figure_1.7_B19453.jpg)'
- en: Figure 1.7 – MongoDB architecture
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – MongoDB 架构
- en: Since we may also have other running projects or software applications inside
    our machine, isolating any database or application server used in development
    is a good practice. In this way, we ensure nothing interferes with our local servers,
    and the debug process can be more manageable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能在机器内还有其他运行的项目或软件应用程序，因此隔离开发中使用的任何数据库或应用程序服务器是一种良好的做法。这样，我们确保没有任何东西干扰我们的本地服务器，调试过程可以更容易管理。
- en: This Docker image setting creates a MongoDB server locally and even allows us
    to make additional changes if we want to simulate any other scenario for testing
    or development.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Docker 镜像设置在本地创建了一个 MongoDB 服务器，甚至允许我们进行额外的更改，以便模拟任何其他测试或开发场景。
- en: 'The commands we used are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的命令如下：
- en: The `--name` command defines the name we give to our container.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name` 命令定义了我们给容器起的名字。'
- en: The `-p` command specifies the port our container will open so that we can access
    it via `localhost:27017`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p` 命令指定了容器将打开的端口，以便我们可以通过 `localhost:27017` 访问它。'
- en: '`-e` command defines the environment variables. In this case, we set the `root`
    username and password for our MongoDB container.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e` 命令定义了环境变量。在这种情况下，我们为 MongoDB 容器设置了 `root` 用户名和密码。'
- en: '`-d` is detached mode – that is, the Docker process will run in the background,
    and we will not see input or output. However, we can still use `docker ps` to
    check the container status.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d` 是分离模式——也就是说，Docker 进程将在后台运行，我们不会看到输入或输出。然而，我们仍然可以使用 `docker ps` 来检查容器状态。'
- en: '`mongo:latest` indicates Docker pulling this image’s latest version.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongo:latest`表示Docker正在拉取此镜像的最新版本。'
- en: There’s more…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: For frequent users, manually configuring other parameters for the MongoDB container,
    such as the version, image port, database name, and database credentials, is also
    possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于频繁用户，手动配置MongoDB容器的其他参数，例如版本、镜像端口、数据库名称和数据库凭证，也是可能的。
- en: 'A version of this image with example values is also available as a `docker-compose`
    file in the official documentation here: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此镜像的一个带有示例值的版本也作为`docker-compose`文件在官方文档中提供：[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。
- en: 'The `docker-compose` file for MongoDB looks similar to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的`docker-compose`文件看起来类似于以下内容：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can check out MongoDB at the complete Docker Hub documentation here: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在完整的Docker Hub文档中查看MongoDB：[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)。
- en: Configuring Docker for Airflow
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker用于Airflow
- en: In this book, we will use **Airflow** to orchestrate data ingests and provide
    logs to monitor our pipelines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用**Airflow**来编排数据摄取并提供日志以监控我们的管道。
- en: Airflow can be installed directly on your local machine and any server using
    PyPi([https://pypi.org/project/apache-airflow/](https://pypi.org/project/apache-airflow/))
    or a Docker container ([https://hub.docker.com/r/apache/airflow](https://hub.docker.com/r/apache/airflow)).
    An official and supported version of Airflow can be found on Docker Hub, and the
    **Apache Foundation** community maintains it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Airflow可以直接安装在您的本地机器和任何服务器上，使用PyPi([https://pypi.org/project/apache-airflow/](https://pypi.org/project/apache-airflow/))或Docker容器([https://hub.docker.com/r/apache/airflow](https://hub.docker.com/r/apache/airflow)).
    Docker Hub上可以找到Airflow的官方和受支持的版本，并且由**Apache基金会**社区维护。
- en: However, there are some additional steps to configure our Airflow. Thankfully,
    the Apache Foundation also has a `docker-compose` file that contains all other
    requirements to make Airflow work. We just need to complete a few more steps.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，配置我们的Airflow还有一些额外的步骤。幸运的是，Apache基金会也有一个包含使Airflow工作所需的所有其他要求的`docker-compose`文件。我们只需要完成几个额外的步骤。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let’s start by initializing our Docker application on our machine. You can use
    the desktop version or the CLI command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的机器上初始化Docker应用程序开始。您可以使用桌面版本或CLI命令。
- en: 'Make sure you are inside your project folder for this. Create a folder to store
    Airflow internal components and the `docker-compose.yaml` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您处于项目文件夹内。创建一个文件夹来存储Airflow内部组件和`docker-compose.yaml`文件：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, we fetch the `docker-compose.yaml` file directly from the Airflow official
    docs:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从Airflow官方文档中直接获取`docker-compose.yaml`文件：
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You should see output like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下输出：
- en: '![Figure 1.8 – Airflow container image download progress](img/Figure_1.8_B19453.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – Airflow容器镜像下载进度](img/Figure_1.8_B19453.jpg)'
- en: Figure 1.8 – Airflow container image download progress
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – Airflow容器镜像下载进度
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Check the most stable version of this `docker-compose` file when you download
    it, since new, more appropriate versions may be available after this book is published.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在您下载时检查此`docker-compose`文件的最稳定版本，因为在此书出版后可能会有更合适的新版本。
- en: 'Next, we create the `dags`, `logs`, and `plugins` folders as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`dags`、`logs`和`plugins`文件夹，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we create and set the Airflow user as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建并设置Airflow用户，如下所示：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have any error messages related to the `AIRFLOW_UID` variable, you can
    create a `.env` file in the same folder where your `docker-compose.yaml` file
    is and define the variable as `AIRFLOW_UID=50000`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有任何与`AIRFLOW_UID`变量相关的错误消息，您可以在与您的`docker-compose.yaml`文件相同的文件夹中创建一个`.env`文件，并将变量定义为`AIRFLOW_UID=50000`。
- en: 'Then, we initialize the database:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们初始化数据库：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After executing the command, you should see output similar to this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，您应该看到类似以下输出：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we start the Airflow service:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们启动Airflow服务：
- en: '[PRE30]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we need to check the Docker processes. Using the following CLI command,
    you will see the Docker images running:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要检查Docker进程。使用以下CLI命令，您将看到正在运行的Docker镜像：
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These are the images we see:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们看到的镜像：
- en: '![Figure 1.9 – The docker ps command output](img/Figure_1.9_B19453.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – docker ps命令输出](img/Figure_1.9_B19453.jpg)'
- en: Figure 1.9 – The docker ps command output
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – docker ps命令输出
- en: 'In the Docker Desktop application, you can also see the same containers running
    but with a more friendly interface:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 桌面应用程序中，您也可以看到相同的容器正在运行，但界面更加友好：
- en: '![Figure 1.10 – A Docker desktop view of the Airflow containers running](img/Figure_1.10_B19453.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 运行中的 Airflow 容器在 Docker 桌面上的视图](img/Figure_1.10_B19453.jpg)'
- en: Figure 1.10 – A Docker desktop view of the Airflow containers running
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 运行中的 Airflow 容器在 Docker 桌面上的视图
- en: 'Then, we access Airflow in a web browser:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过网页浏览器访问 Airflow：
- en: 'In your preferred browser, type `http://localhost:8080/home`. The following
    screen will appear:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您首选的浏览器中，输入 `http://localhost:8080/home`。将出现以下屏幕：
- en: '![Figure 1.11 – The Airflow UI login page](img/Figure_1.11_B19453.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – Airflow UI 登录页面](img/Figure_1.11_B19453.jpg)'
- en: Figure 1.11 – The Airflow UI login page
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – Airflow UI 登录页面
- en: Then, we log in to the Airflow platform. Since it’s a local application used
    for testing and learning, the default credentials (username and password) for
    administrative access in Airflow are `airflow`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们登录到 Airflow 平台。由于它是一个用于测试和学习的本地应用程序，Airflow 中用于管理访问的默认凭据（用户名和密码）是 `airflow`。
- en: 'When logged in, the following screen will appear:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，将出现以下屏幕：
- en: '![Figure 1.12 – The Airflow UI main page](img/Figure_1.12_B19453.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – Airflow UI 主页面](img/Figure_1.12_B19453.jpg)'
- en: Figure 1.12 – The Airflow UI main page
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – Airflow UI 主页面
- en: 'Then, we stop our containers. We can stop our containers until we reach [*Chapter
    9*](B19453_09.xhtml#_idTextAnchor319), when we will explore data ingest in Airflow:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们停止我们的容器。我们可以停止我们的容器，直到我们达到[*第 9 章*](B19453_09.xhtml#_idTextAnchor319)，届时我们将探索
    Airflow 中的数据摄取：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Airflow is an open source platform that allows batch data pipeline development,
    monitoring, and scheduling. However, it requires other components, such as an
    internal database, to store metadata to work correctly. In this example, we use
    PostgreSQL to store the metadata and **Redis** to cache information.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Airflow 是一个开源平台，允许批量数据处理管道的开发、监控和调度。然而，它需要其他组件，如内部数据库，以存储元数据才能正确工作。在这个例子中，我们使用
    PostgreSQL 存储元数据，并使用 **Redis** 缓存信息。
- en: All this can be installed directly in our machine environment one by one. Even
    though it seems quite simple, it may not be due to compatibility issues with OS,
    other software versions, and so on.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以直接在我们的机器环境中逐一安装。尽管看起来很简单，但由于与操作系统、其他软件版本等问题可能存在兼容性问题，可能并不总是如此。
- en: Docker can create an isolated environment and provide all the requirements to
    make it work. With `docker-compose`, it becomes even simpler, since we can create
    dependencies between the components that can only be created if the others are
    healthy.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 可以创建一个隔离的环境，并提供所有使其工作的要求。使用 `docker-compose`，它变得更加简单，因为我们可以在其他组件健康的情况下创建只能创建的组件之间的依赖关系。
- en: You can also open the `docker-compose.yaml` file we downloaded for this recipe
    and take a look to explore it better. We will also cover it in detail in [*Chapter
    9*](B19453_09.xhtml#_idTextAnchor319).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以打开我们为这个配方下载的 `docker-compose.yaml` 文件，并查看它以更好地探索它。我们还会在第 [*第 9 章*](B19453_09.xhtml#_idTextAnchor319)
    中详细讨论它。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you want to learn more about how this `docker-compose` file works, you can
    look at the Apache Airflow official Docker documentation on the Apache Airflow
    documentation page: [https://airflow.apache.org/docs/apache-airflow/stable/howto/docker-compose/index.xhtml](https://airflow.apache.org/docs/apache-airflow/stable/howto/docker-compose/index.xhtml).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于此 `docker-compose` 文件的工作方式，您可以在 Apache Airflow 官方 Docker 文档的 Apache
    Airflow 文档页面上查看：[https://airflow.apache.org/docs/apache-airflow/stable/howto/docker-compose/index.xhtml](https://airflow.apache.org/docs/apache-airflow/stable/howto/docker-compose/index.xhtml)。
- en: Creating schemas
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模式
- en: '**Schemas** are considered blueprints of a database or table. While some databases
    strictly require schema definition, others can work without it. However, in some
    cases, it is advantageous to work with data schemas to ensure that the application
    data architecture is maintained and can receive the desired data input.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式**被认为是数据库或表的蓝图。虽然一些数据库严格要求模式定义，但其他数据库可以在没有它的情况下工作。然而，在某些情况下，与数据模式一起工作可能是有益的，以确保应用程序数据架构得到维护，并且可以接收所需的数据输入。'
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let’s imagine we need to create a database for a school to store information
    about the students, the courses, and the instructors. With this information, we
    know we have at least three tables so far.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们需要为学校创建一个数据库来存储有关学生、课程和讲师的信息。有了这些信息，我们知道我们至少有到目前为止的三个表。
- en: '![Figure 1.13 – A table diagram for three entities](img/Figure_1.13_B19453.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13 – 三个实体的表图](img/Figure_1.13_B19453.jpg)'
- en: Figure 1.13 – A table diagram for three entities
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 三个实体的表图
- en: In this recipe, we will cover how schemas work using the **Entity Relationship
    Diagram** (**ERD**), a visual representation of relationships between entities
    in a database, to exemplify how schemas are connected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过使用**实体关系图**（**ERD**），即数据库中实体之间关系的视觉表示，来展示模式是如何连接的。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here are the steps to try this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是尝试这一步骤的步骤：
- en: 'We define the type of schema. The following figure helps us understand how
    to go about this:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了模式类型。以下图示帮助我们了解如何进行这一步骤：
- en: '![Figure 1.14 – A diagram to help you decide which schema to use](img/Figure_1.14_B19453.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 帮助你决定使用哪个模式的图示](img/Figure_1.14_B19453.jpg)'
- en: Figure 1.14 – A diagram to help you decide which schema to use
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 帮助你决定使用哪个模式的图示
- en: 'Then, we define the fields and the data type for each table column:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义每个表列的字段和数据类型：
- en: '![Figure 1.15 – A definition of the columns of each table](img/Figure_1.15_B19453.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图1.15 – 每个表的列的定义](img/Figure_1.15_B19453.jpg)'
- en: Figure 1.15 – A definition of the columns of each table
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – 每个表的列的定义
- en: 'Next, we define which fields can be empty or `NULL`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义哪些字段可以是空的或`NULL`：
- en: '![Figure 1.16 – A definition of which columns can be NULL](img/Figure_1.16_B19453.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16 – 定义哪些列可以是NULL的图示](img/Figure_1.16_B19453.jpg)'
- en: Figure 1.16 – A definition of which columns can be NULL
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 定义哪些列可以是NULL的图示
- en: 'Then, we create the relationship between the tables:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建表之间的关系：
- en: '![Figure 1.17 – A relationship diagram of the tables](img/Figure_1.17_B19453.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图1.17 – 表的关系图](img/Figure_1.17_B19453.jpg)'
- en: Figure 1.17 – A relationship diagram of the tables
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17 – 表的关系图
- en: How it works…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When designing data schemas, the first thing we need to do is define their type.
    As we can see in the diagram in *step 1*, applying the schema architecture depends
    on the data’s purpose.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计数据模式时，我们首先需要做的是定义它们的类型。正如我们在*步骤1*中的图示中可以看到，应用模式架构取决于数据的目的。
- en: After that, the tables are designed. Deciding how to define data types can vary,
    depending project or purpose, but deciding what values a column can receive is
    important. For instance, the `officeRoom` on `Teacher` table can be an `Integer`
    type if we know the room’s identification is always numeric, or a `String` type
    if it is unsure how identifications are made (for example, `Room 3-D`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，设计表。决定如何定义数据类型可能因项目或目的而异，但决定列可以接收哪些值是很重要的。例如，如果我们知道房间的识别号总是数字，`Teacher`表上的`officeRoom`可以是`Integer`类型，或者如果对识别方式不确定（例如，`Room
    3-D`），则可以是`String`类型。
- en: Another important topic covered in *step 3* is how to define which of the columns
    can accept `NULL` fields. Can a field for a student’s name be empty? If not, we
    need to create a constraint to forbid this type of insert.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中涵盖的另一个重要主题是如何定义哪些列可以接受`NULL`字段。学生的姓名字段可以空着吗？如果不能，我们需要创建一个约束来禁止这种类型的插入。
- en: Finally, based on the type of schema, a definition of the relationship between
    the tables is made.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据模式类型，制定表之间的关系定义。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'If you want to know more about database schema designs and their application,
    read this article by Mark Smallcombe: [https://www.integrate.io/blog/database-schema-examples/](https://www.integrate.io/blog/database-schema-examples/).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于数据库模式设计和它们的应用的文章，请阅读Mark Smallcombe的这篇文章：[https://www.integrate.io/blog/database-schema-examples/](https://www.integrate.io/blog/database-schema-examples/)。
- en: Applying data governance in ingestion
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在摄取中应用数据治理
- en: '**Data governance** is a set of methodologies that ensure that data is secure,
    available, well-stored, documented, private, and accurate.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据治理**是一套确保数据安全、可用、妥善存储、文档化、隐私和准确的方法论。'
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '**Data ingestion** is the beginning of the data pipeline process, but it doesn’t
    mean data governance is not heavily applied. The governance status in the final
    data pipeline output depends on how it was implemented during the ingestion.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据摄取**是数据管道过程的开始，但这并不意味着数据治理没有得到广泛应用。最终数据管道输出中的治理状态取决于它在摄取过程中的实施情况。'
- en: 'The following diagram shows how data ingestion is commonly conducted:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了数据摄取通常是如何进行的：
- en: '![Figure 1.18 – The data ingestion process](img/Figure_1.18_B19453.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图1.18 – 数据摄取过程](img/Figure_1.18_B19453.jpg)'
- en: Figure 1.18 – The data ingestion process
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18 – 数据摄取过程
- en: 'Let’s analyze the steps in the diagram:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析图中的步骤：
- en: '**Getting data from the source**: The first step is to define the type of data,
    its periodicity, where we will gather it, and why we need it.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从源获取数据**：第一步是定义数据的类型、其周期性、我们将从哪里收集它以及为什么我们需要它。'
- en: '**Writing the scripts to ingest data**: Based on the answers to the previous
    step, we can begin planning how our code will behave and some basic steps.'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写数据摄取的脚本**：基于上一步的答案，我们可以开始规划我们的代码将如何表现以及一些基本步骤。'
- en: '**Storing data in a temporary database or other types of storage**: Between
    the ingest and the transformation phase, data is typically stored in a temporary
    database or repository.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在临时数据库或其他类型的存储中存储数据**：在摄取和转换阶段之间，数据通常存储在临时数据库或存储库中。'
- en: '![Figure 1.19 – Data governance pillars](img/Figure_1.19_B19453.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19 – 数据治理支柱](img/Figure_1.19_B19453.jpg)'
- en: Figure 1.19 – Data governance pillars
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 数据治理支柱
- en: How to do it…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Step by step, let’s attribute the pillars in *Figure 1**.19* to the ingestion
    phase:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步，让我们将图 *1.19* 中的支柱归因于摄取阶段：
- en: A concern for accessibility needs to be applied at the data source level, defining
    the individuals that are allowed to see or retrieve data.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据源级别应用对可访问性的关注，定义允许查看或检索数据的人员。
- en: Next, it is necessary to catalog our data to understand it better. Since data
    ingestion is only covered here, it is more relevant to cover the data sources.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，有必要对数据进行编目以更好地理解它。由于数据摄取在这里仅作介绍，因此更相关的是涵盖数据源。
- en: The quality pillar will be applied to the ingestion and staging area, where
    we control the data and keep its quality aligned with the source.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 质量支柱将应用于摄取和暂存区域，在那里我们控制数据并保持其质量与源保持一致。
- en: Then, let’s define ownership. We know the data source *belongs* to a business
    area or a company. However, when we ingested the data and put it in temporary
    or staging storage, it becomes our responsibility to maintain it.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们定义所有权。我们知道数据源 *属于* 一个业务领域或公司。然而，当我们摄取数据并将其放入临时或暂存存储时，它就变成了我们的责任来维护它。
- en: The last pillar involves keeping data secure for the whole pipeline. Security
    is vital in all steps, since we may be handling private or sensitive information.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个支柱涉及在整个管道中保持数据的安全。在所有步骤中，安全性都是至关重要的，因为我们可能正在处理私人或敏感信息。
- en: '![Figure 1.20 – Adding to data ingestion](img/Figure_1.20_B19453.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 增加数据摄取](img/Figure_1.20_B19453.jpg)'
- en: Figure 1.20 – Adding to data ingestion
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 增加数据摄取
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'While some articles define “pillars” to create governance good practices, the
    best way to understand how to apply them is to understand how they are composed.
    As you saw in the previous *How to do it…* section, we attributed some items to
    our pipeline, and now we can understand how they are connected to the following
    topics:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些文章定义了“支柱”来创建良好的治理实践，但了解如何应用它们最好的方式是理解它们的组成。正如你在上一节“如何做…*”中看到的，我们将一些项目分配给了我们的管道，现在我们可以理解它们是如何与以下主题相连的：
- en: '**Data accessibility**: Data accessibility is how people from a group, organization,
    or project can see and use data. The information needs to be readily available
    for use. At the same time, it needs to be available for the people involved in
    the process. For example, sensitive data accessibility should be restricted to
    some people or programs. In the diagram we built, we applied it to our data sources,
    since we need to understand and retrieve data. For the same reason, it can be
    applied for temporary storage needs as well.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据可访问性**：数据可访问性是指一个群体、组织或项目中的成员如何查看和使用数据。信息需要易于使用。同时，它需要对参与过程的人员可用。例如，敏感数据可访问性应限制在某些人或程序。在我们构建的图中，我们将其应用于我们的数据源，因为我们需要理解和检索数据。同样地，它也可以应用于临时存储需求。'
- en: '**Data catalog**: Cataloging and documenting data are essential for business
    and engineering teams. When we know what types of information rely on our databases
    or data lakes and have quick access to these documents, the action time to solve
    a problem becomes short.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据编目**：编目和记录数据对于业务和工程团队至关重要。当我们知道哪些类型的信息依赖于我们的数据库或数据湖，并且可以快速访问这些文档时，解决问题的行动时间就会缩短。'
- en: Again, documenting our data sources can make the ingest process quicker, since
    we need to make a discovery every time we need to ingest data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，记录我们的数据源可以使摄取过程更快，因为我们每次需要摄取数据时都需要进行发现。
- en: '**Data quality**: Quality is constantly preoccupied with ingesting, processing,
    and loading data. Tracking and monitoring data’s expected income and outcome by
    its periodicity is essential. For example, if we expect to ingest 300 GB of data
    per day and suddenly it drops to 1 GB, something is very wrong and will affect
    the quality of our final output. Other quality parameters can be the number of
    columns, partitioning, and so on, which we will explore later in this book.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据质量**：质量始终与数据摄入、处理和加载相关。通过其周期性跟踪和监控数据的预期收入和结果至关重要。例如，如果我们预计每天摄入300 GB的数据，突然降至1
    GB，那么肯定出了大问题，这将影响我们最终输出的质量。其他质量参数可以是列数、分区等，我们将在本书的后面部分探讨。'
- en: '**Ownership**: Who is responsible for the data? This definition is crucial
    to make contact with the owner if there are problems or attribute responsibility
    to keep and maintain data.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权**：谁负责数据？这个定义对于在出现问题时与所有者取得联系或分配责任以保持和维护数据至关重要。'
- en: '**Security**: A concerning topic nowadays is data security. With so many regulations
    about data privacy, it became an obligation of data engineers and scientists to
    know, at least, the basics of encryption, sensitive data, and how to avoid data
    leaks. Even languages and libraries that are used for work need to be evaluated.
    That’s why this item is attributed to the three steps in *Figure 1**.19*.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：如今，数据安全是一个令人担忧的话题。随着关于数据隐私的许多法规的出现，数据工程师和科学家至少需要了解加密、敏感数据以及如何避免数据泄露的基础知识。甚至用于工作的语言和库也需要评估。这就是为什么这个条目被归入*图1*的三个步骤中。19。'
- en: In addition to the topics we explored, a global data governance project has
    a vital role called a **data steward**, which is responsible for managing an organization’s
    data assets and ensuring that data is accurate, consistent, and secure. In summary,
    data stewardship is managing and overseeing an organization’s data assets.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们探讨的主题外，全球数据治理项目有一个至关重要的角色，称为**数据管理员**，负责管理组织的资产数据，并确保数据准确、一致和安全。总之，数据管理是管理和监督组织的资产数据。
- en: See also
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'You can read more about a recent vulnerability found in one of the most used
    tools for data engineering here: [https://www.ncsc.gov.uk/information/log4j-vulnerability-what-everyone-needs-to-know](https://www.ncsc.gov.uk/information/log4j-vulnerability-what-everyone-needs-to-know).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于最近发现的数据工程中最常用工具之一的一个漏洞：[https://www.ncsc.gov.uk/information/log4j-vulnerability-what-everyone-needs-to-know](https://www.ncsc.gov.uk/information/log4j-vulnerability-what-everyone-needs-to-know)。
- en: Implementing data replication
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施数据复制
- en: '**Data replication** is a process applied in data environments to create multiple
    copies of data and store them on different locations, servers, or sites. This
    technique is commonly implemented to create better availability and avoid data
    loss if there is downtime, or even a natural disaster that affects a data center.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据复制**是在数据环境中应用的一个过程，用于创建数据的多个副本并将它们存储在不同的位置、服务器或站点。这种技术通常用于创建更好的可用性，以避免在停机或自然灾害影响数据中心时数据丢失。'
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will find across papers and articles different types (or even names) on
    the best way for **data replication** decision. In this recipe, you will learn
    how to decide which kind of replication better suits your application or software.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在论文和文章中找到关于**数据复制**决策的不同类型（甚至名称）。在这个菜谱中，你将学习如何决定哪种复制更适合你的应用程序或软件。
- en: How to do it…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let’s begin to build our fundamental pillars to implement data replication:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建实施数据复制的基本支柱：
- en: First, we need to decide the size of our replication, and it can be done using
    a portion or all the stored data.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要决定复制的规模，这可以通过存储数据的一部分或全部来完成。
- en: The next step is to consider when replication will take place. It can be done
    synchronously when new data arrives in storage or within a specific timeframe.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是考虑复制何时进行。它可以在新数据到达存储时同步进行，或在特定时间段内进行。
- en: The last fundamental pillar is whether the data is incremented or in a bulk
    form.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个基本支柱是数据是增量形式还是批量形式。
- en: 'In the end, we will have a diagram that looks like the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将得到一个如下所示的图表：
- en: '![Figure 1.21 – A data replication model decision diagram](img/Figure_1.21_B19453.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图1.21 – 数据复制模型决策图](img/Figure_1.21_B19453.jpg)'
- en: Figure 1.21 – A data replication model decision diagram
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21 – 数据复制模型决策图
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Analyzing the preceding figure, we have three main questions to answer, regarding
    the extension, the frequency, and whether our replication will be incremental
    or bulk.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 分析前面的图示，我们有三个主要问题需要回答，关于扩展、频率以及我们的复制将是增量还是批量。
- en: For the first question, we decide whether the replication will be complete or
    partial. In other words, either the data will consistently be replicated no matter
    what type of transaction or change was made, or just a portion of the data will
    be replicated. A real example of this would be keeping track of all store sales
    or just the most expensive ones.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题，我们决定复制将是完全的还是有选择的。换句话说，数据将始终被复制，无论进行了何种类型的交易或更改，或者只是部分数据将被复制。一个真实的例子是跟踪所有商店销售或仅跟踪最昂贵的销售。
- en: The second question, related to the frequency, is to decide when a replication
    needs to be done. This question also needs to take into consideration related
    costs. Real-time replication is often more expensive, but the synchronicity guarantees
    almost no data inconsistency.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题，与频率相关，是决定何时进行复制。这个问题也需要考虑相关成本。实时复制通常更昂贵，但同步性保证了几乎没有任何数据不一致性。
- en: Lastly, it is relevant to consider how data will be transported to the replication
    site. In most cases, a scheduler with a script can replicate small data batches
    and reduce transportation costs. However, a bulk replication can be used in the
    data ingestion process, such as copying all the current batch’s raw data from
    a source to cold storage.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑数据将如何传输到复制站点也是相关的。在大多数情况下，一个带有脚本的调度器可以复制小批量数据并降低运输成本。然而，在数据摄取过程中，可以使用大量复制，例如将当前批次的原始数据从源复制到冷存储。
- en: There’s more…
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One method of data replication that has seen an increase in use in the past
    few years is **cold storage**, which is used to retain data used infrequently
    or is even inactive. The costs related to this type of replication are meager
    and guarantee data longevity. You can find cold storage solutions in all cloud
    providers, such as **Amazon Glacier**, **Azure Cool Blob**, and **Google Cloud**
    **Storage Nearline**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，数据复制的一种使用增加的方法是**冷存储**，用于保留不常使用或甚至不活跃的数据。与此类复制相关的成本微乎其微，并保证了数据的长期性。你可以在所有云服务提供商中找到冷存储解决方案，例如**Amazon
    Glacier**、**Azure Cool Blob**和**Google Cloud Storage Nearline**。
- en: Besides replication, regulatory compliance such as **General Data Protection
    Regulation** (**GDPR**) laws benefit from this type of storage, since, for some
    case scenarios, users’ data need to be kept for some years.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复制之外，像**通用数据保护条例**（**GDPR**）这样的监管合规法律也得益于这种存储方式，因为对于某些案例场景，用户数据需要保留数年。
- en: In this chapter, we explored the basic concepts and laid the foundation for
    the following chapters and recipes in this book. We started with a Python installation,
    prepared our Docker containers, and saw data governance and replication concepts.
    You will observe over the upcoming chapters that almost all topics interconnect,
    and you will understand the relevance of understanding them at the beginning of
    the ETL process.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了基本概念，并为本书后续章节和食谱奠定了基础。我们从Python安装开始，准备我们的Docker容器，并了解了数据治理和复制概念。在接下来的章节中，你将观察到几乎所有主题都是相互关联的，你将理解在ETL过程开始时理解它们的相关性。
- en: Further reading
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.manageengine.com/device-control/data-replication.xhtml](https://www.manageengine.com/device-control/data-replication.xhtml)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.manageengine.com/device-control/data-replication.xhtml](https://www.manageengine.com/device-control/data-replication.xhtml)'
