- en: Level of Detail Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered table calculations, which are extremely
    useful when we want to aggregate information using exactly the data that is in
    the view, but sometimes we want to use more (or less) than the information that
    can be seen on the screen. For instance, if you want to show the average spend
    by customer, you don't want to show all customers and their value to compute an
    average. This is where **Level of Detail** **(LOD)** calculations, which we will
    introduce in this chapter, can be used, because they help us change the level
    of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Tableau's order of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FIXED` LOD calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INCLUDE` LOD calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXCLUDE` LOD calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data source constraints for LOD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the Global Superstore dataset, which can be found at [http://www.tableau.com/sites/default/files/training/global_superstore.zip](http://www.tableau.com/sites/default/files/training/global_superstore.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Tableau's order of operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving deeper into LOD calculations, it is first important to understand
    Tableau's order of operations, as this will guide our conversation, seeing where
    this new topic fits in.
  prefs: []
  type: TYPE_NORMAL
- en: Surprising results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Especially when coming to Tableau from Excel or other BI tools, one is sometimes
    at a loss when dealing with Tableau's order of operations. What can seem intuitive
    is not always what is reflected. Applying the wrong type of filter, or not using
    the proper calculation, will result in meaningless results.
  prefs: []
  type: TYPE_NORMAL
- en: The following is one such scenario. In the Global Superstore dataset, we create
    a data source filter for `Country` to show United Kingdom orders only, a dimension
    filter for `State` Wales and a **Top 10 Customer Names by Sales** filter.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, you can set up a **Top** filter by using the Top option of the
    Filter window, and in this case selecting By Field, Top 10, Sales, and Sum.
  prefs: []
  type: TYPE_NORMAL
- en: Why should there be only one customer in the results when we have set a filter
    for the top 10?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efaf9963-a6ad-4416-a791-42bd79ca7e13.png)'
  prefs: []
  type: TYPE_IMG
- en: We will determine why we're not seeing the desired top 10 customers using the
    order of operations in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to interpret this, let''s look at the infamous order of operations
    with the elements that we are already familiar with at this point in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data source filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets, conditional, and top N filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dimension filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data blending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Totals
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Table calculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations in Tableau are performed in this order, starting from the top and
    making their way down.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have **data source** or **extract** filters (depending on the type
    of connection used, whether Live or Extract), as described in Chapter 1, *Building
    Your Data Model*. These affect the entirety of your dataset at workbook level,
    before any specific filters that can be applied at worksheet level. As far as
    Tableau computation is concerned in the workbook, the filtered-out data doesn't
    even exist.
  prefs: []
  type: TYPE_NORMAL
- en: '*Context* filters are similar to data source or extract filters, but are view-specific.
    They are generally used to speed up processing, because they can further reduce
    the scope of data, as if creating a temporary subset of it before generating the
    view. These are mainly useful to improve the performance of a view that will be
    category-specific (for example, sales of Copiers only), within a very large dataset
    that can''t be filtered at workbook level.'
  prefs: []
  type: TYPE_NORMAL
- en: Context filters can be created by selecting an existing dimension filter in
    the filters pane, and clicking the Add to context option. The blue pill will turn
    gray to signify that the filter is now a context filter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sets*, *dimension*, and *measure* filters (including *conditional* and *top
    N* filters) have been described at length in Chapter 1, *Building Your Data Model*,
    and [Chapter 2](6ebf2184-6a4e-42de-8741-4c9f71f652d3.xhtml), *Working with Worksheets*,
    as is the case for *data blending* in [Chapter 1](786fd5d5-eb79-4216-bd9a-96d0a59374ea.xhtml),
    *Building Your Data Model*. Please refer to these chapters to clear up any remaining
    doubts on these subjects.'
  prefs: []
  type: TYPE_NORMAL
- en: With the order of operations as it currently stands, it's worth realizing that
    table calculations (as described in the previous chapter) come last in the order,
    after totals (which represent the usual calculations used in Tableau). For example,
    if we are using a rank table calculation on **Customer Name** in a given **State**,
    the rank will include orders in that state and that state only, as table calculations
    come after dimension filters. The biggest customer in the dataset might just be
    the 10th customer in a particular region.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the order, let's go back to our previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the surprising results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now hold the tools to understand why only one customer shows up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d069bfb3-4bf5-44f2-8831-7cbeb38f4e2a.png)'
  prefs: []
  type: TYPE_IMG
- en: If we take a look at the order of operations, the top N filter comes before
    the dimension filter (in this case, for `State` Wales), but after the data Source
    filters (here, `Country` United Kingdom).
  prefs: []
  type: TYPE_NORMAL
- en: The sales shown in the results are therefore sales in Wales for customers that
    are in the top 10 *UK-wide*, not just in Wales. Nine of those customers have no
    sales in Wales, just in the other parts of the UK, and don't appear in our results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one wanted to see the top 10 customers in Wales for sales occurring there
    only, it is possible to promote the filter on `State` to be a context filter,
    moving it back up in the order of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c936ff6e-faa0-4b31-93bd-692953d44b09.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've covered the order of operations, let's dive into LOD functions,
    which are going to allow us to change levels of aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: FIXED LOD calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FIXED` is the first of three LOD calculations we will study in this chapter.
    It is used to make a calculation regardless of any dimension or measure filters
    that are applied in the workbook. The syntax of `FIXED` is the following: `{FIXED
    [dim1[, dim2]…] : aggregate-expression}`, with `[dim1[, dim2]…]` a list of dimensions
    along which the aggregation is to be calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note the use of curly brackets. The syntax will be the same for all three
    LOD expressions we describe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s look at the date of first order for a given customer.
    While a `MIN([Date])` calculation will give the first date *in the filtered dataset*
    with **Customer Name** used as a row or column, `{FIXED [Customer ID] :MIN([Date])}`
    will give the first date for a customer *in the entire dataset*, filters notwithstanding,
    for each `Customer ID`. As a result, if we look at orders in 2013 in the Global
    Superstore dataset, we notice that the `First Order Date` can be in 2011:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10c22e96-0244-42e5-8b47-39ca89ec2437.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now take a look at how this will be affected by the order of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The place of this calculation in the order of operations is therefore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract/data source filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets, conditional, and top N Filters, `FIXED` LOD calculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dimension filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data blending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Totals
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Table calculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's consider three examples to understand how to use this calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – lifetime sales value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, we want to represent the lifetime sales
    value of our low-profit subcategories in 2013.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a new calculated field, `Lifetime Sales Value`, as `{FIXED [Subcategories]
    : SUM([Sales])}`. This will calculate the total sales by subcategory, regardless
    of any dimension filters set. Therefore, if we filter for orders placed in 2013
    as a dimension filter, and compute `Profit Ratio` (defined as `SUM([Profit]) /
    SUM([Sales])`), `Sales`, and `Lifetime Sales Value`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/154b0b59-5bac-46d8-8b5d-89054162cd48.png)'
  prefs: []
  type: TYPE_IMG
- en: While the Tables subcategory is not profitable in 2013, with sales of $202,364,
    it generated $757,042 in sales across the whole dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – contributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, we want to see the contribution of units
    ordered by country in the LATAM market, against both that region only and the
    whole company.
  prefs: []
  type: TYPE_NORMAL
- en: The list of dimensions in the `FIXED` syntax is optional. We can therefore define
    `Total Quantity` as `{FIXED:SUM([Quantity])}`. This will be the equivalent of
    having a quantity that is equal to the total units for each calculation. This
    will be a value that will never change regardless of the level of aggregation
    of our view.
  prefs: []
  type: TYPE_NORMAL
- en: We can then define `Worldwide Qty Contribution` as `SUM([Quantity]) / ATTR([Total
    Quantity])` (as `Total Quantity` needs no aggregation).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `ATTR`, because otherwise we would get an error due to mixing aggregates
    and non-aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Showing `Quantity`, a window calculation for Percent of Total for `Quantity` that
    we can call `Region Qty Contribution` (along Table (down)) and the newly defined
    `Worldwide Qty Contribution`, and filtering for market LATAM, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a2f90c0-5ad7-454a-92d0-405707b176e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The results are different between the last two columns here because the table
    calculation only considers data in LATAM (because it comes after dimension filters
    in the order of operations), while the LOD calculation considers the entire dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to go a level further, we can make this a map view: remove the first
    two measures to keep only `Worldwide Qty Contribution`, click on Show Me > Maps, and
    finally choose the Analysis > Show Mark Labels options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d7aebde-4933-44fa-940f-2b978ec83bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: If we further filter the countries, we will still see their contribution to
    the worldwide market, contrary to a table calculation, which will consider only
    the filtered dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3 – cohorts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, we want to see how many sales were generated
    in 2012 for customers (`Customer ID`) making their first purchase (`Order Date`)
    in that year. This is what is usually called a **cohort analysis**, and is often
    seen in the exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each customer, we first have to define their earliest date of purchase.
    To do so, we create a calculated `First Order Date` field as `{FIXED [Customer
    ID] : MIN([Order Date])}`. This will take the earliest `Order Date` in the entire
    dataset for each `Customer ID`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a visualization with `Year([Order Date])` as columns, `Year([First
    Order Date])` as rows, and `SUM([Sales])` as measures. This gives the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72c7aad7-b21c-4e55-b893-19c75da124c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Customers making their first order in 2012 have therefore spent $128,828 in
    that year.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we use the `FIXED` LOD to make a calculation regardless of any
    dimension or measure filters that are applied in the workbook, which is helpful
    for contributions, cohorts, or any calculation that has to take the entire dataset
    into account. Let's carry on with the second LOD calculation.
  prefs: []
  type: TYPE_NORMAL
- en: INCLUDE LOD calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `INCLUDE` LOD calculation is used to add a layer of aggregation that will
    not be used as part of the dimensions. For instance, you might want to see the
    average customer's lifetime value in different markets. Under normal circumstances,
    you would need to first aggregate at customer level, and then use the results
    of that aggregation to compute an average. In the SQL world, we would use a subquery.
    Simply averaging all sales will not yield the same results, as it will be computed
    at the line item level and will therefore give the average value of a line item.
  prefs: []
  type: TYPE_NORMAL
- en: We can understand this by saying that we want to aggregate at a level that includes
    both the dimensions already in the view and another set of additional dimensions.
    This means that we have data that is more granular than what will be shown in
    the view, and therefore that we will need to further aggregate the results of
    that calculation to show them in the view. While the results of a `FIXED` calculation
    don't need to be aggregated, the results of an `INCLUDE` statement do.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax is similar to `FIXED` statements: `{INCLUDE [dim1[,
    dim 2]…] : aggregate-expression}`. While the dimensions are technically optional
    parameters, there is no gain in using an `INCLUDE` function in that case, it is
    just computing the usual aggregation with no added granularity.'
  prefs: []
  type: TYPE_NORMAL
- en: As for `FIXED`, it's important to see where this sits in the order of operations
    to optimize its use, before we carry on with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Order of operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This particular LOD function, as well as the `EXCLUDE` LOD calculation that
    will shortly follow, comes between data blending and measure filters. They are
    thus computed later than the `FIXED` calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract/data source filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets, conditional, and top N filters, `FIXED` LOD calculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dimension filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data blending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`INCLUDE` and`EXCLUDE` LOD calculations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure filters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Totals
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Table calculations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example 1 – average customer lifetime value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, for the Technology category, we want to
    see the average lifetime sales value of customers, split by `Segment` and `Market`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just calculate a straight `AVG([Sales])`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/872d070a-456b-4720-8baf-1140ad17d7ed.png)'
  prefs: []
  type: TYPE_IMG
- en: However, that is representing the average sales to customers *at the line item
    level*, not the lifetime value. If customer A has two orders for $100 and $200
    and customer B has a sale for $300, the average sale is $200, but the average
    lifetime sales value is $300, as both customers have a lifetime value of $300\.
    Here, we need to first compute the sales at customer level, and then average the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dimension we''re missing in the view is `Customer Name`. We will therefore
    create an `INCLUDE` statement as `{INCLUDE [Customer Name]:SUM([Sales])}`, which
    will create an intermediary calculation at customer level. The results of that
    calculation can then be aggregated using an `AVG` to yield the correct results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a8a4b55-dbc1-4a6a-b9a7-3fdc930aefd8.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth noting that if we are always going to average the lifetime sales
    value of a customer, we can enclose the `INCLUDE` statement in an `AVG` inside
    the **Calculated field**, and Tableau will recognize how to aggregate this without
    needing to specify it every time: `AVG({INCLUDE [Customer Name]:SUM([Sales])})`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – median of average days to ship by customer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Global Superstore company is worried that some orders are being shipped
    late, and about the impact it might have on its customers. Let's look at `Average
    Days to Ship` by `Customer Name` for late orders.
  prefs: []
  type: TYPE_NORMAL
- en: If not already defined in the workbook, `Average Days to Ship` is calculated
    as `DATEDIFF('day',[Order Date],[Ship Date])`, and `Ship Status` as `IF [Days
    to Ship (Actual)] > [Days to Ship (Scheduled)] THEN "Shipped Late"`
  prefs: []
  type: TYPE_NORMAL
- en: '`ELSEIF [Days to Ship (Actual)] = [Days to Ship (Scheduled)] THEN "Shipped
    On Time"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ELSE "Shipped Early" END`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in previous chapters, we can create a quick distribution plot by `Segment`
    and `Market`, using `Customer Name` as a Detail mark to see each individual customer,
    filtering for orders where `Ship Status` is Shipped Late:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e35f5ab8-6e3d-4002-b648-87b9faf55ecf.png)'
  prefs: []
  type: TYPE_IMG
- en: While it is sometimes worthwhile to see each customer, a top-line number for
    each quadrant can be a good indicator of performance. Let's choose the median
    as one such indicator. We now need to remove `Customer Name` as a dimension, but
    still keep it in the calculation to find the median.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can define `MEDIAN({INCLUDE [Customer Name] : AVG([Days to Ship (Actual)])})`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s deconstruct this, starting from the right. Look at average days to ship.
    The view includes **Segment** and **Region**, so the aggregation would normally
    be performed at that level. However, we want to calculate this at customer level,
    so we create the `INCLUDE` statement, specifying that we want to add `Customer
    Name` to the list of dimensions even though it is not part of our view. Having
    results that are now too granular to be shown in the view, we choose to finally
    aggregate by taking the median of those results. If we create a quick view of
    that measure by `Segment` and `Market`, using the Measure Values as Color and
    the Analysis > Show Mark Labels option, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65b4f7db-4d7d-440b-9fdf-168abced73be.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, we can use the `INCLUDE` LOD to first aggregate a level that is
    higher than the view, including some dimensions that are not present in it, that
    we can then aggregate back to the view level. This is useful when trying to extract
    and summarize order-level data from a dataset of item-level data. Let's study
    one last LOD calculation before closing off this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: EXCLUDE LOD calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `INCLUDE` LOD calculations enabled us to calculate along the view dimensions
    and the further dimensions specified, `EXCLUDE` LOD calculations enable users
    to make calculations omitting one of the dimensions that have been used in the
    view. For instance, we can use `EXCLUDE` to calculate the total sum of profits
    for one category across regions, even if `Region` is used as a row. This is especially
    useful when dealing with contributions to a total.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – contribution to total
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, we want to show contributions to total
    profit for the South region of the EU market, slicing by country, category, and
    subcategory. What is the contribution of the **Fasteners** subcategory in **Italy**
    to the overall Fasteners business in the South?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can first plot profit by `Country` and `Sub-category` in the South, adding
    totals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6d928b5-cfb4-4dd5-8dd8-5a06c88c2132.png)'
  prefs: []
  type: TYPE_IMG
- en: In the case of **Fasteners** in Italy, we want to see that it represents $578/$898
    = 64% of the profit.
  prefs: []
  type: TYPE_NORMAL
- en: We have two ways of calculating that contribution. We can add a quick table
    calculation for Percent of Total for `SUM(Profit)`, with computation along Table
    (across).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use an LOD, calculating the overall profit for a subcategory as
    `{EXCLUDE [Country]: Sum([Profit])}`, which will remove the dependency on `Country`,
    but not on `Sub-category`. As a result, we can further define `SUM([Profit]) /
    ATTR({EXCLUDE [Country]: Sum([Profit])})` as the contribution of one country to
    the overall region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/991a2016-c825-4728-80e8-2f624602d43f.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, both calculations yield the same results. We can also roll up to
    category or drill down to product name without having to redefine the field. Regardless
    of how we slice the data, we will always show contributions to the overall region.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between those two calculations resides in the order of operations.
    While `EXCLUDE` LOD calculations come before measure filters, table calculations
    come after. As a result, if we filter on measures, the table calculations will
    reflect only the values in the table, while the `EXCLUDE` LOD calculation will
    continue to show the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we filter on `SUM(Profit)` to show only profitable quadrants
    (that is, `SUM(Profit) > 0`), we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57d97620-ce5a-4045-a37e-7357c394573c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the `EXCLUDE` LOD calculations have not changed, while `Table
    Calc` now reflects only the data shown on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – difference in average profit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Global Superstore dataset, for profitable orders, we want to know
    the difference between the average profit per line by category and market, compared
    to the average for the entire category. For example, what is the difference between
    the average profit for Office Supplies orders in Africa and the average profit
    for any order in Africa?
  prefs: []
  type: TYPE_NORMAL
- en: We can first define `Order Profitable?` as `IF {FIXED [Order ID]:SUM([Profit])}
    > 0 THEN 'Profitable' ELSE 'Not Profitable' END`, which will calculate the overall
    profit for each Order ID and make for a quick filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then plot the average `Profit`, slicing by `Category` and `Market`,
    filtering for profitable orders, turning on Grand Total for rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdc7f423-6cfb-48fb-a89a-24d072aeb8dd.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we want to compare the $25 average profit in Office Supplies to
    the $50 average profit for orders in Africa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we can define `{Exclude [Category]: AVG([Profit])}` as the average profit
    omitting the `Category` dimension (which is equal in this view to the **Grand
    Total** for a given market), and a further calculation for `AVG([Profit]) - ATTR({EXCLUDE
    [Category]: AVG([Profit])})` will show us the required difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80fdf08e-eea3-4829-9f64-b2e8524a7193.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we can see that orders for Office Supplies in Africa are $25
    less profitable than the average order line in this market. Again, we can change
    the dimensions without having to change the definition of our field, for instance
    by `Segment`, as long as we keep slicing by `Category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97b876a7-ee7e-4a47-ba10-6ddcb62143c5.png)'
  prefs: []
  type: TYPE_IMG
- en: However, if we were to remove **Category** altogether, this calculation would
    be no different to a simple `AVG([Profit])`, and would lose its value.
  prefs: []
  type: TYPE_NORMAL
- en: Data source constraints for LOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While LOD calculations are in general supported in Tableau, there are a few
    constraints on certain data source types. At the time of writing, here are the
    most notable exceptions to the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data source** | **Support** |'
  prefs: []
  type: TYPE_TB
- en: '| Google Big Query | Supported for standard SQL, not supported for legacy SQL
    |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Access | Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft Jet-based connections (legacy connectors for Microsoft Excel, Microsoft
    Access, and text) | Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft SQL Server | SQL Server 2005 and later |'
  prefs: []
  type: TYPE_TB
- en: '| Mongo DB | Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle | Supported version 9i and later |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | Supported version 7 and later |'
  prefs: []
  type: TYPE_TB
- en: A complete and up-to-date version of this list can be found at [https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_lod_constraints.htm](https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_lod_constraints.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the three types of LOD expressions available in
    Tableau (`FIXED`, `INCLUDE`, and `EXCLUDE`) and studied how we can use them to
    aggregate data at a level that is either more granular (in the case of `INCLUDE`)
    or less granular than the dimensions already in the view. We also looked at the
    order of operations to explain the differences between these calculations and
    the ones seen previously (such as table calculations). For instance, we now hold
    the tools to calculate contributions to a total, create cohorts based on first
    order date, and aggregate customer-level information starting from item-level
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **FIXED** | **INCLUDE** | **EXCLUDE** |'
  prefs: []
  type: TYPE_TB
- en: '| Order of operations | Before dimension filters | After dimension filters
    | After dimension filters |'
  prefs: []
  type: TYPE_TB
- en: '| Purpose | Calculate across the dataset along selected dimensions | Calculate
    results using a dimension that is not part of the view | Calculate results excluding
    one of the dimensions that is part of the view |'
  prefs: []
  type: TYPE_TB
- en: This chapter closes a three-chapter journey into the different calculations
    that we can use in Tableau, and we are now ready to use some of the analytical
    tools to add some insights to our worksheets.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Answer the following questions to test your knowledge of the information in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: If I''m not using any dimension filters, is there a difference between using
    a Percent of Total table calculation and using `FIXED`/`EXCLUDE` calculations?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: While they will, in general, yield the same results, there a few exceptions
    that we have discussed in this chapter, and the main reason for the differences
    is the order of operations. `FIXED` calculations will remain unchanged by dimension
    and measure filters, `EXCLUDE` calculations will remain unchanged by measure filters
    (but not by dimension filters), and table calculations will be affected by both
    dimension and measure filters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: Do LOD calculations have to use fields that are already included in the
    view? Can LOD calculations aggregate at a different level than the one determined
    by the fields chosen in the view?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: As seen in the example of `INCLUDE` calculations, LOD calculations can be
    used to aggregate on fields that are not present in the view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: Do LOD calculations always yield measures?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Not necessarily. In the example of cohorts in the second part of this chapter,
    we can use a `FIXED` LOD calculation to create a first purchase date, which will
    be treated as a dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check out the following links for more information about the topics
    that were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Top 15 Tableau LOD Expressions*: [https://www.tableau.com/about/blog/LOD-expressions](https://www.tableau.com/about/blog/LOD-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data Source Constraints for Level of Detail Expressions*: [https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_lod_constraints.htm](https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_lod_constraints.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Which calculation is right for your analysis: simple, table, or LOD?* [https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_understand_which.htm](https://help.tableau.com/current/pro/desktop/en-us/calculations_calculatedfields_understand_which.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
