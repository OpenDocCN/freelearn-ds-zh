<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Fundamentals of the Python Language for ArcGIS</h1></div></div></div><p>Python supports many of the programming constructs found in other languages. In this chapter, we'll cover many of the basic language constructs found in Python. Initially, we'll cover how to create new Python scripts and edit existing scripts. From there, we'll delve into language features, such as adding comments to your code, creating and assigning data to variables, and built-in variable typing with Python, which makes coding with Python easy and compact.</p><p>Next, we'll look at the various built-in data types that Python offers, such as strings, numbers, lists, and dictionaries. Classes and objects are a fundamental concept in object-oriented programming and in the Python language. We'll introduce you to these complex data structures, which you'll use extensively when you write geoprocessing scripts with ArcGIS.</p><p>In addition to this, we'll cover statements, including decision support and looping structures to make decisions in your code, and/or looping through a code block multiple times along with the <code class="literal">with</code> statement, which is used extensively with the <code class="literal">cursor</code> objects from the ArcPy data access module that are used to insert, search, and update data. Finally, you'll learn how to access modules that provide additional functionality to the Python language. By the end of this chapter, you will have learned the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create and edit new Python scripts in IDLE</li><li class="listitem" style="list-style-type: disc">How to create and edit scripts in the ArcGIS Python window</li><li class="listitem" style="list-style-type: disc">The language features of Python</li><li class="listitem" style="list-style-type: disc">Comments and data variables</li><li class="listitem" style="list-style-type: disc">Built-in data types (strings, numbers, lists, and dictionaries)</li><li class="listitem" style="list-style-type: disc">Complex data structures</li><li class="listitem" style="list-style-type: disc">Looping structures</li><li class="listitem" style="list-style-type: disc">Additional Python functionalities</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Using IDLE for Python script development</h1></div></div></div><p>As mentioned in the preface, when you install ArcGIS for Desktop, Python is also installed along with a tool called <strong>IDLE</strong> that allows you to write your own code. IDLE stands for <strong>Integrated DeveLopment Environment</strong>. Since<a id="id0" class="indexterm"/> it is available with every ArcGIS for Desktop installation, we'll use IDLE for many of the scripts that we write in this book along with the Python window embedded in ArcGIS for Desktop. As you progress as a programmer, you<a id="id1" class="indexterm"/> may find other development tools that you prefer over IDLE. There are many other development environments that you may want to consider, including PyScripter, Wingware, Komodo, and others. The development environment you choose is really a matter of preference. You can write your code in any of these tools.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The Python shell window</h2></div></div></div><p>To start<a id="id2" class="indexterm"/> the IDLE development environment for Python, you can navigate to <strong>Start</strong> | <strong>All Programs</strong> | <strong>ArcGIS</strong> | <strong>Python 2.7</strong> | <strong>IDLE</strong>. Please note that the version of Python installed with ArcGIS will differ depending upon the ArcGIS version that you have installed. For example, ArcGIS 10.3 uses Python 2.7, whereas ArcGIS 10.0 uses version 2.6 of Python.</p><p>A Python shell window similar to this screenshot will be displayed:</p><div><img src="img/B04314_01_1.jpg" alt="The Python shell window"/></div><p>The Python shell window is used for output and error messages generated by scripts. A common mistake for beginners is to assume that the geoprocessing scripts will be written in this shell window. This is not the case. You will need to create a separate code window to hold your scripts.</p><p>Although the shell window isn't used to write entire scripts, it can be used to interactively write code and get immediate feedback. ArcGIS has a built-in Python shell window that you can use in a similar way. We'll examine the ArcGIS Python window in the next chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>The Python script window</h2></div></div></div><p>Your scripts<a id="id3" class="indexterm"/> will be written in IDLE inside a separate window known as the <strong>Python script window</strong>. To create a new code window, navigate to <strong>File</strong> | <strong>New Window</strong> from the IDLE shell window. A window similar to this will be displayed:</p><div><img src="img/B04314_01_2.jpg" alt="The Python script window"/></div><p>Your Python scripts will be written inside this new code window. Each script will need to be saved to a local or network drive. By default, scripts are saved with a <code class="literal">.py</code> file extension to signify that it is a Python script.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Editing existing Python scripts</h2></div></div></div><p>Existing<a id="id4" class="indexterm"/> Python script files can be opened by selecting <strong>File</strong> | <strong>Open</strong> from the IDLE shell window. Additionally, a Python script can be opened from Windows Explorer by right-clicking on the file and selecting <strong>Edit with IDLE</strong>, which brings up a new shell window along with the script loaded in the Python script editor. You can see an example of this in the following screenshot:</p><div><img src="img/B04314_01_3.jpg" alt="Editing existing Python scripts"/></div><p>In this instance, we <a id="id5" class="indexterm"/>have loaded the <code class="literal">ListFeatureClasses.py</code> script with IDLE. The code is loaded inside the script window:</p><div><img src="img/B04314_01_4.jpg" alt="Editing existing Python scripts"/></div><p>Now that the code window is open, you can begin writing or editing code. You can also perform some basic script debugging with the IDLE interface. Debugging is the process of identifying and<a id="id6" class="indexterm"/> fixing errors in your code.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Executing scripts from IDLE</h2></div></div></div><p>Once you've<a id="id7" class="indexterm"/> written a geoprocessing script in the IDLE code window or opened an existing script, you can execute the code from the interface. IDLE does provide functionality that allows you to check the syntax of your code before running the script. In the code window, navigate to <strong>Run</strong> | <strong>Check Module</strong> to perform a syntax check of your code.</p><p>Any syntax errors will be displayed in the shell window. If there aren't any syntax errors, you should just see the prompt in the shell window. While the IDLE interface can be used to check for syntax errors, it doesn't provide a way to check for logical errors in your code nor does it provide more advanced debugging tools found in other development environments, such as PyScripter or Wingware.</p><p>Once you're satisfied that no syntax errors exist in your code, you can run the script. Navigate to <strong>Run</strong> | <strong>Run Module</strong> to execute the script:</p><div><img src="img/B04314_01_7.jpg" alt="Executing scripts from IDLE"/></div><p>Any error messages will be written to the shell window along with the output from the <code class="literal">print</code> statements and system-generated messages. The <code class="literal">print</code> statement simply outputs text to the shell window. It is often used to update the status of a running script or to debug the code.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Using the ArcGIS Python window</h1></div></div></div><p>In this recipe, you'll <a id="id8" class="indexterm"/>learn how to use the ArcGIS Python window. In the last section, you learned how to use the IDLE development environment for Python, so this section will give you an alternative to write your geoprocessing scripts. Either <a id="id9" class="indexterm"/>development environment can be used, but it is common for people to start writing scripts with the ArcGIS for Desktop Python window and then move on to IDLE or another development environment when scripts become more complex.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>The ArcGIS Python window</h2></div></div></div><p>The ArcGIS Python window <a id="id10" class="indexterm"/>is an embedded, interactive Python window in ArcGIS for Desktop 10.x. It is newer and ideal for testing small blocks of code, learning Python basics, building quick and easy workflows, and executing geoprocessing tools. For new programmers, the ArcGIS Python window is a great place to start!</p><p>The ArcGIS Python window has a number of capabilities in addition to being the location to write your code. You can save the content of the window to a Python script file on a disk or load an existing Python script into the window. The window can be either pinned or floating. While floating, the window can be expanded or contracted as you wish. The window can also be pinned to various parts of the ArcGIS display. You can also format the font and text colors displayed in the window by right-clicking on the window and selecting <strong>Format</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Displaying the ArcGIS Python window</h2></div></div></div><p>The Python window can be <a id="id11" class="indexterm"/>opened by clicking on the Python window button on the Standard ArcGIS for Desktop toolbar, as seen in the screenshot. This is a floating window, so you can resize as needed and also dock it at various places on the <strong>ArcMap</strong> interface:</p><div><img src="img/B04314_01_8.jpg" alt="Displaying the ArcGIS Python window"/></div><p>The Python window<a id="id12" class="indexterm"/> is essentially a shell window that allows you to type in statements one line at a time, just after the <code class="literal">&gt;&gt;&gt;</code> line input characters. On the right-hand side of the divider, you will find a help window.</p><p>You can load an existing script by right-clicking inside the Python window and selecting <strong>Load…</strong> from the menu. You can also format the font and text colors displayed in the window by right-clicking on the window and selecting <strong>Format</strong>. You will be provided with White and Black themes; you can select fonts and colors individually:</p><div><img src="img/B04314_01_09.jpg" alt="Displaying the ArcGIS Python window"/></div><p>Click on the <strong>Set Black Theme</strong> button<a id="id13" class="indexterm"/> to see an example. If you spend a lot of time writing code, you may find that darker themes are easier on your eyes:</p><div><img src="img/B04314_01_10.jpg" alt="Displaying the ArcGIS Python window"/></div><p>The ArcGIS Python window also provides code-completion functionalities that make your life as a programmer much easier. You can try this functionality by opening the ArcGIS Python Window and typing <code class="literal">arcpy</code> followed by a dot on the first line. ArcPy is a module-oriented package, which means that you access the properties and methods of an object using a dot notation. Notice that a drop-down list of available items is provided. These are the tools, functions, classes, and extensions that are available for this particular object. All objects have their own associated items, so the list of items presented will differ depending on the object that you have currently selected:</p><div><img src="img/B04314_01_11.jpg" alt="Displaying the ArcGIS Python window"/></div><p>This is an <a id="id14" class="indexterm"/>auto-filtering list, so as you begin typing the name of the tool, function, class, or extension, the list will be filtered according to what you have typed:</p><div><img src="img/B04314_01_12.jpg" alt="Displaying the ArcGIS Python window"/></div><p>You can choose to have the Python window auto-complete the text for you by selecting an item from the list using your mouse or by using the arrow keys to highlight your choice, and then using the <em>Tab</em> key to enter the command. This autocompletion feature makes you a faster, more efficient programmer. Not only is it easy to use, but it also dramatically cuts down the number of typos in your code.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Python language fundamentals</h1></div></div></div><p>To effectively write <a id="id15" class="indexterm"/>geoprocessing scripts for ArcGIS, you are going to need to understand at least the basic constructs of the Python language. Python is easier to learn than most other programming languages, but it does take some time to learn and effectively use it. This section will teach you how to create variables, assign various data types to variables, understand the different types of data that can be assigned to variables, use different types of statements, use objects, read and write files, and import third-party Python modules.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Commenting code</h2></div></div></div><p>Python scripts should follow <a id="id16" class="indexterm"/>a common structure. It is a commonly accepted practice that the beginning of each script should serve as documentation, detailing the script name, author, and a general description of the processing provided by the script. This introductory documentation will help you and other programmers in the future to quickly scan the details and purpose of a script. This documentation is accomplished in Python through the use of comments. Comments are lines of code that you add to your script that serve as a documentation of what functionality the script provides. These lines of code begin with a single pound sign (<code class="literal">#</code>) or a double pound sign (<code class="literal">##</code>), and are followed by whatever text you need to document the code. The Python interpreter does not execute these lines of code. They are simply used to document your code. In the next screenshot, the commented lines of code are displayed with a single pound sign that prefixes the line of code. You should also strive to include comments throughout your script to describe important sections of your script. This will be useful to you (or another programmer) when the time comes to update your scripts:</p><div><img src="img/B04314_01_13.jpg" alt="Commenting code"/></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you have purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Importing modules</h2></div></div></div><p>Although Python<a id="id17" class="indexterm"/> includes many built-in functions, you will frequently need to access specific bundles of functionality, which are stored in external modules. For instance, the <code class="literal">Math</code> module stores specific functions related to processing numeric values and the <code class="literal">R</code> module provides statistical analysis functions. We haven't discussed the topic of functions yet, but basically functions are a named block of code that execute when called. Modules are imported through the use of the <code class="literal">import</code> statement. When writing geoprocessing scripts with ArcGIS, you will always need to import the <code class="literal">arcpy</code> module, which is the Python package that is used to access GIS tools and functions provided by ArcGIS. The <code class="literal">import</code> statements will be the first lines of code (not including comments) in your scripts. The following line of code imports the <code class="literal">arcpy</code> and <code class="literal">os</code> modules. The Python <code class="literal">os</code> module provides a way of interfacing with the underlying operating system:</p><div><pre class="programlisting">import arcpy
import os</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Variables</h2></div></div></div><p>At a high level, you <a id="id18" class="indexterm"/>can think of a variable as an area in your computer's memory that is reserved to store values while the script is running. Variables<a id="id19" class="indexterm"/> that you define in Python are given a name and a value. The values assigned to variables can then be accessed by different areas of your script as needed, simply by referring to the variable name. For example, you might create a variable that contains a feature class name, which is then used by the <strong>Buffer</strong> tool to create a new output dataset. To create a variable, simply give it a name followed by the assignment operator, which is just an equals sign (=), and then a value:</p><div><pre class="programlisting">fcParcels = "Parcels"
fcStreets = "Streets"</pre></div><p>The following table illustrates the variable name and value assigned to the variable using the preceding code example:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable name</p>
</th><th style="text-align: left" valign="bottom">
<p>Variable value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fcParcels</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Parcels</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fcStreets</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Streets</code>
</p>
</td></tr></tbody></table></div><p>There are certain naming rules<a id="id20" class="indexterm"/> that you must follow when creating variables, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It can contain letters, numbers, and underscores</li><li class="listitem" style="list-style-type: disc">The first character must be a letter</li><li class="listitem" style="list-style-type: disc">No special characters can be used in a variable name other an underscore</li><li class="listitem" style="list-style-type: disc">Python keywords and spaces are not permitted</li></ul></div><p>There are <a id="id21" class="indexterm"/>a few dozen Python keywords that must be avoided, including <code class="literal">class</code>, <code class="literal">if</code>, <code class="literal">for</code>, <code class="literal">while</code>, and others. These keywords are typically highlighted in a different font color from other Python statements.</p><p>Here are some examples of legal variable names<a id="id22" class="indexterm"/> in Python:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">featureClassParcel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">fieldPopulation</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">field2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ssn</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">my_name</code></li></ul></div><p>These are some examples of illegal variable names<a id="id23" class="indexterm"/> in Python:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">class</code> (Python keyword)</li><li class="listitem" style="list-style-type: disc"><code class="literal">return</code> (Python keyword)</li><li class="listitem" style="list-style-type: disc"><code class="literal">$featureClass</code> (illegal character, must start with a letter)</li><li class="listitem" style="list-style-type: disc"><code class="literal">2fields</code> (must start with a letter)</li><li class="listitem" style="list-style-type: disc"><code class="literal">parcels&amp;Streets</code> (illegal character)</li></ul></div><p>Python is a case-sensitive language, so pay particular attention to the capitalization and naming of variables in your scripts. Case-sensitivity issues are probably the most common source of errors for new Python programmers, so always consider this as a possibility when you encounter errors in your code. Let's look at an example. The following is a list of three variables; note that although each variable name is the same, the casing is different, resulting in three distinct variables:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mapsize = "22x34"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">MapSize = "8x11"</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Mapsize = "36x48"</code></li></ul></div><p>If you print these<a id="id24" class="indexterm"/> variables, you will get the following output:</p><div><pre class="programlisting">print(mapsize)
&gt;&gt;&gt; 22x34

print(MapSize)
&gt;&gt;&gt; 8x11  #output from print statement

print(Mapsize)
&gt;&gt;&gt;36x48  #output from print statement</pre></div><p>Python variable<a id="id25" class="indexterm"/> names need to be consistent throughout the script. The best practice is to use camel casing, wherein the first word of a variable name is all lowercase and then each successive word begins with an uppercase letter. This concept is illustrated in the following example with the <code class="literal">fieldOwnerName</code> variable name. The first word (<code class="literal">field</code>) is all lowercase followed by an uppercase letter for the second word (<code class="literal">Owner</code>) and third word (<code class="literal">Name</code>):</p><div><pre class="programlisting">fieldOwnerName</pre></div><p>In Python, variables are <a id="id26" class="indexterm"/>dynamically typed. <strong>Dynamic typing</strong> means <a id="id27" class="indexterm"/>that you can define a variable and assign data to it without specifically defining that a variable name will contain a specific type of data. Commonly used data types that can<a id="id28" class="indexterm"/> be assigned to variables include the following:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Data type</p>
</th><th style="text-align: left" valign="bottom">
<p>Example value</p>
</th><th style="text-align: left" valign="bottom">
<p>Code example</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"Streets"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">fcName = "Streets"</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Number</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">3.14</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">percChange = 3.14</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">True</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ftrChanged = True</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>List</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">"Streets", "Parcels", "Streams"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">lstFC = ["Streets", "Parcels", "Streams"]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Dictionary</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">'0':Streets,'1':Parcels</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">dictFC = {'0':Streets,'1':Parcels]</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Extent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">spatialExt = map.extent</code>
</p>
</td></tr></tbody></table></div><p>We will discuss each of these data types in greater detail in the coming sections.</p><p>For instance, in C#, you would need to define a variable's name and type before using it. This is not necessary in Python. To <a id="id29" class="indexterm"/>use a variable, simply give it a name and value, and you can begin using it right away. Python does the work behind the scenes to figure out what type of data is being held in the variable.</p><p>In the following C# code example, we've created a new variable called <code class="literal">aTouchdown</code>, which is defined as an integer variable, meaning that it can contain only integer data. We then assign the <code class="literal">6</code> value to the variable:</p><div><pre class="programlisting">int aTouchdown;
aTouchdown = 6;</pre></div><p>In Python, this variable<a id="id30" class="indexterm"/> can be created and assigned data through dynamic typing. The Python interpreter is tasked with dynamically figuring out what type of data is assigned to the variable:</p><div><pre class="programlisting">aTouchdown = 6</pre></div><p>There may be times when you know that your script will need a variable, but don't necessarily know ahead of time what data will be assigned to the variable. In these cases, you could simply define a variable without assigning data to it. Here, you will find a code example that depicts creating a variable without assigning data:</p><div><pre class="programlisting">aVariable = ''
aVariable = NULL</pre></div><p>Data that is assigned to the variable can also be changed while the script is running.</p><p>Variables can hold many different kinds of data, including primitive data types, such as strings and numbers, along with more complex data, such as lists, dictionaries, and even objects. We're going to examine the different types of data that can be assigned to a variable along with various functions that are provided by Python to manipulate the data.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Built-in data types</h2></div></div></div><p>Python has a number of <a id="id31" class="indexterm"/>built-in data types. The <a id="id32" class="indexterm"/>first built-in type that we will discuss is the <code class="literal">string</code> data type. We've already seen several examples of <code class="literal">string</code> variables, but these types of variables can be manipulated in a lot of ways, so let's take a closer look at this data type.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Strings</h3></div></div></div><p>Strings are <a id="id33" class="indexterm"/>ordered collections of characters that store and represent <a id="id34" class="indexterm"/>text-based information. This is a rather dry way of saying that string variables hold text. String variables are surrounded by single or double quotes when being assigned to a variable. Examples could include a name, feature class name, a <code class="literal">Where</code> clause, or anything else that can be encoded as text.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec01"/>String manipulation</h4></div></div></div><p>Strings can <a id="id35" class="indexterm"/>be manipulated in a number of ways in Python. String concatenation is one of the more commonly used functions and is simple to accomplish. The <code class="literal">+</code> operator is used with <code class="literal">string</code> variables on either side of the operator to produce a new <code class="literal">string</code> variable that ties the two string variables together:</p><div><pre class="programlisting">shpStreets = "c:\\GISData\\Streets" + ".shp"
print(shpStreets)</pre></div><p>Running this code example produces the following result:</p><div><pre class="programlisting">&gt;&gt;&gt;c:\GISData\Streets.shp</pre></div><p>String equality can be tested using Python's <code class="literal">==</code> operator, which is simply two equals signs placed together. Don't confuse the equality operator with the assignment operator, which is a single equals sign. The equality operator tests two variables for equality, while the assignment operator assigns a value to a variable:</p><div><pre class="programlisting">firstName = "Eric"
lastName = "Pimpler"
firstName == lastName</pre></div><p>Running this code example produces the following result because the <code class="literal">firstName</code> and <code class="literal">lastName</code> variables are not equal:</p><div><pre class="programlisting">&gt;&gt;&gt;False</pre></div><p>Strings can be tested for containment using the <code class="literal">in</code> operator, which returns <code class="literal">True</code> if the first operand is contained in the second:</p><div><pre class="programlisting">fcName = "Floodplain.shp"
print(".shp" in fcName)
&gt;&gt;&gt;True</pre></div><p>I have briefly mentioned that strings are an ordered collection of characters. What does this mean? It simply means that we can access individual characters or a series of characters from the string and that the order of the characters will remain the same until we change them. Some collections, such as a dictionary, do not maintain a set order. In Python, this is referred to as <strong>indexing</strong>
<a id="id36" class="indexterm"/> in the case of accessing an individual character, and <strong>slicing</strong>
<a id="id37" class="indexterm"/> in the case of accessing a series of characters.</p><p>Characters in a string are obtained by providing the numeric offset contained within square brackets after a string. For example, you could obtain the first string character in the <code class="literal">fc</code> variable by using the <code class="literal">fc[0]</code> syntax. Python is a zero-based language, meaning the first item in a list is <code class="literal">0</code>. Negative offsets can be used to search backwards from the end of a string. In this case, the last character in a string is stored at the <code class="literal">-1</code> index. Indexing always creates a new variable to hold the character:</p><div><pre class="programlisting">fc = "Floodplain.shp"
print(fc[0])
&gt;&gt;&gt;'F'
print(fc[10])
&gt;&gt;&gt;'.'
print(fc[13])
&gt;&gt;&gt;'p'</pre></div><p>The following image illustrates how strings are an ordered collection of characters with the first character occupying the <strong>0</strong> position, the second character occupying the <strong>1</strong> position, and each successive character occupying the next index number:</p><div><img src="img/B04314_01_14.jpg" alt="String manipulation"/></div><p>While string <a id="id38" class="indexterm"/>indexing allows you to obtain a single character from a <code class="literal">string</code> variable, string slicing enables you to extract a contiguous sequence of strings. The format and syntax is similar to indexing, but with the addition of a second offset, which is used to tell Python which characters to return.</p><p>The following code example provides an example of string slicing. The <code class="literal">theString</code> variable has been assigned a value of <code class="literal">Floodplain.shp</code>. To obtain a sliced variable with the contents of Flood, you would use the <code class="literal">theString[0:5]</code> syntax:</p><div><pre class="programlisting">theString = "Floodplain.shp"
print(theString[0:5])
&gt;&gt;&gt;Flood</pre></div><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Python slicing returns the characters beginning with the first offset up to, but not including, the second offset. This can be particularly confusing for new Python programmers and is a common source of errors. In our example, the returned variable will contain the <code class="literal">Flood</code> characters. The first character, which occupies the <code class="literal">0</code> position, is <code class="literal">F</code>. The last character returned is the <code class="literal">4</code> index, which corresponds to the <code class="literal">d</code> character. Notice the <code class="literal">5</code> index number is not included since Python slicing only returns characters up to, but not including, the second offset</p></div></div><p>Either of the offsets can be left off. This, in effect, creates a wild card. In the case of <code class="literal">theString[1:]</code>, you are telling Python to return all characters starting from the second character to the end of the string. In the second case, <code class="literal">theString[:-1]</code>, you are telling Python to start at character zero and return all characters except the last.</p><p>Python is an excellent language to manipulate strings and there are many additional functions that you can use to process this type of data. Most of these are beyond the scope of this text, but in general, all the following string manipulation functions are available:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">String length</li><li class="listitem" style="list-style-type: disc">Casing functions for conversion to upper and lowercase</li><li class="listitem" style="list-style-type: disc">The removal of leading and trailing whitespace</li><li class="listitem" style="list-style-type: disc">Finding a character within a string</li><li class="listitem" style="list-style-type: disc">The replacement of text</li><li class="listitem" style="list-style-type: disc">Splitting into a list of words based on a delimiter</li><li class="listitem" style="list-style-type: disc">Formatting</li></ul></div><p>Your Python <a id="id39" class="indexterm"/>geoprocessing scripts for ArcGIS will often need to reference the location of a dataset on your computer or, perhaps, a shared server. References to these datasets will often consist of paths stored in a variable. In Python, pathnames are a special case that deserve some extra mention. The backslash character in Python is a reserved escape character and a line continuation character, thus there is a need to define paths using two back slashes, a single forward slash, or a regular single backslash prefixed with <code class="literal">r</code>. These pathnames are always stored as strings in Python. You'll see an example of this in the following section.</p><p>The example for an illegal path reference is as follows:</p><div><pre class="programlisting">fcParcels = "c:\Data\Parcels.shp"</pre></div><p>The example for legal path references are as follows:</p><div><pre class="programlisting">fcParcels = "c:/Data/Parcels.shp"
fcParcels = "c:\\Data\\Parcels.shp"
fcParcels = r"c:\Data\Parcels.shp"</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Numbers</h3></div></div></div><p>Python also has<a id="id40" class="indexterm"/> built-in support for numeric data, including <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and <code class="literal">complex</code> values. Numbers are assigned to variables in much the same way as strings, with the exception that you do not enclose the value in quotes and obviously, it must be a numeric value.</p><p>Python <a id="id41" class="indexterm"/>supports all the commonly used numeric operators, including addition, subtraction, multiplication, division, and modulus or remainder. In addition to this, functions used to return the absolute value, conversion of strings to numeric data types, and rounding are also available.</p><p>Although Python provides a few built-in mathematical functions, the math module can be used to access a wide variety of more advanced <code class="literal">math</code> functions. To use these functions, you must specifically import the <code class="literal">math</code> module as follows:</p><div><pre class="programlisting">import math</pre></div><p>Functions<a id="id42" class="indexterm"/> provided by the <code class="literal">math</code> module include those that return the ceiling and floor of a number, the absolute value, trigonometric functions, logarithmic functions, angular conversion, and hyperbolic functions. It is worth noting that there is no simple function to calculate mean or average and these will have to be coded to be calculated. More<a id="id43" class="indexterm"/> details about the <code class="literal">math</code> module <a id="id44" class="indexterm"/>can be found by navigating to <strong>All Programs</strong> | <strong>ArcGIS</strong> | <strong>Python 2.7</strong> | <strong>Python Manuals</strong>. After opening the python manual, navigate to <strong>Python Standard Library</strong> | <strong>Numeric and Mathematical Modules</strong>. You can also reference this for any data types, syntax, built-in functions, and other things that you wish to understand in more detail, of which there are too many to be covered here.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Lists</h3></div></div></div><p>A third<a id="id45" class="indexterm"/> built-in data<a id="id46" class="indexterm"/> type provided by Python is lists. A list is an ordered collection of elements that can hold any type of data supported by Python as well as being able to hold multiple data types at the same time. This could be numbers, strings, other lists, dictionaries, or objects. So, for instance, a list variable could hold numeric and string data at the same time. Lists are zero-based, with the first element in the list occupying the <strong>0</strong> position. This is illustrated here:</p><div><img src="img/B04314_01_15.jpg" alt="Lists"/></div><p>Each successive object in the list is incremented by one. Additionally, lists have the special capability of dynamically growing and shrinking.</p><p>Lists are created by assigning a series of values enclosed by brackets. To pull a value from a list, simply use an integer value in brackets along with the variable name. The following code example provides an illustration of this:</p><div><pre class="programlisting">fcList = ["Hydrants", "Water Mains", "Valves", "Wells"]
fc = fcList[0] ##first item in the list - Hydrants
print(fc)
&gt;&gt;&gt;Hydrants
fc = fcList[3]  ##fourth item in the list - Wells
print(fc)
&gt;&gt;&gt;Wells</pre></div><p>You can add a new item to an existing list by using the <code class="literal">append()</code> method, as seen in this code example:</p><div><pre class="programlisting">fcList.append("Sewer Pipes")
print(fcList)
&gt;&gt; Hydrants, Water Mains, Valves, Wells, Sewer Pipes</pre></div><p>You can also use slicing with lists to return multiple values. To slice a list, you can provide two offset<a id="id47" class="indexterm"/> values separated by a colon, as seen in the following code example. The first offset indicates the starting index number and the second indicates the stopping point. The second index number will not be returned. <strong>Slicing</strong> <a id="id48" class="indexterm"/>a list always returns a new list:</p><div><pre class="programlisting">fcList = ["Hydrants", "Water Mains", "Valves", "Wells"]
fc = fcList[0:2] ##get the first two items – Hydrants, Water Mains</pre></div><p>Lists are <a id="id49" class="indexterm"/>dynamic in nature, meaning that you can add and remove items from an existing list as well as change the existing contents. This is all done without the need to create a new copy of the list. Changing values in a list can be accomplished either through indexing or slicing. Indexing allows you to change a single value, while slicing allows you to change multiple list items.</p><p>Lists have a number of methods that allow you to manipulate the values that are part of the list. You can sort the contents of the list in either an ascending or descending order through the use of the <code class="literal">sort()</code> method. Items can be added to a list with the <code class="literal">append()</code> method, which adds an object to the end of the list, and with the <code class="literal">insert()</code> method, which inserts an object at a position within the list. Items can be removed from a list with the <code class="literal">remove()</code> method, which removes the first occurrence of a value from the list, or the <code class="literal">pop()</code> method, which removes and returns the object at the end of the list. The contents of the list can also be reversed with the <code class="literal">reverse()</code> method.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Tuples</h3></div></div></div><p>Tuples are<a id="id50" class="indexterm"/> similar to lists but with some important differences. Just like lists, tuples <a id="id51" class="indexterm"/>contain a sequence of values. The contents of a tuple can include any type of data just like lists. However, unlike lists, the contents of a tuple are static. After a tuple has been created, you can't make any changes to the sequence of the values nor can you add or remove values. This can be a good thing for situations where you want data to always occupy a specific position. Creating a tuple is as simple as placing a number of comma-separated values inside parentheses, as shown in the following code example:</p><div><pre class="programlisting">fcTuples = ("Hydrants", "Water Mains", "Valves", "Wells")</pre></div><p>You've probably noticed that creating a tuple is very similar to creating a list. The only difference is the use of parentheses instead of square braces around the values.</p><p>Similar to lists, tuple indices start with an index value of <code class="literal">0</code>. Access to values stored in a tuple occurs in the same way as lists. This is illustrated in the following code example:</p><div><pre class="programlisting">fcTuples = ("Hydrants", "Water Mains", "Valves", "Wells")
print(fcTuples[1])
&gt;&gt;&gt;Water Mains</pre></div><p>Tuples are typically used in place of a list when it is important for the contents of the structure to be static. You can't ensure this with a list, but you can with a tuple.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Dictionaries</h3></div></div></div><p>Dictionaries are a <a id="id52" class="indexterm"/>second type of collection object in Python. They are similar to<a id="id53" class="indexterm"/> lists, except that dictionaries are an unordered collection of objects. Instead of fetching objects from the collection through the use of an offset, items in a dictionary are stored and fetched by a key. Each key in a dictionary has an associated value, as seen here:</p><div><img src="img/B04314_01_16.jpg" alt="Dictionaries"/></div><p>Similar to lists, dictionaries can grow and shrink in place through the use of methods on <code class="literal">dictionary.</code> In the following code example, you will learn to create and populate a dictionary and see how values can be accessed through the use of a key. Dictionaries are created with the use of curly braces. Inside these braces, each key is followed by a colon and then a value is associated with the key. These key/value pairs are separated by commas:</p><div><pre class="programlisting">##create the dictionary
dictLayers = {'Roads': 0, 'Airports': 1, 'Rail': 2}

##access the dictionary by key
print(dictLayers['Airports'])
&gt;&gt;&gt;1
print(dictLayers['Rail'])
&gt;&gt;&gt;2</pre></div><p>Basic <code class="literal">dictionary</code> operations include getting the number of items in a dictionary, acquiring a value using a key, determining if the key exists, converting the keys to a list, and getting a list of values. The <code class="literal">dictionary</code> objects can be changed, expanded, and shrunk in place. What this means is that Python does not have to create a new <code class="literal">dictionary</code> object to hold the altered version of the dictionary. Assigning values to a <code class="literal">dictionary</code> key can be accomplished by stating the key value in brackets and setting it equal to some value.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Unlike lists, dictionaries can't be sliced due to the fact that their contents are unordered. Should you have the need to iterate over all the values in a dictionary, simply use the <code class="literal">keys()</code> method, which returns a collection of all the keys in the dictionary and can then be used individually to set or get their value.</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Classes and objects</h2></div></div></div><p>Classes and<a id="id54" class="indexterm"/> objects are a fundamental concept in object-oriented programming. While Python is more of a procedural language, it also supports object-oriented programming. In object-oriented programming, classes are used to create object<a id="id55" class="indexterm"/> instances. You can think of classes as blueprints for the creation of one or more objects. Each object instance has the same properties and methods, but the data contained in an object can and usually will differ. Objects are complex data types in Python composed of properties and methods, and can be assigned to variables just like any other data type. Properties contain data associated with an object, while methods are actions that an object can perform.</p><p>These concepts are best illustrated with an example. In ArcPy, the <code class="literal">extent</code> class is a rectangle specified by providing the coordinate of the lower-left corner and the coordinate of the upper-right corner in map units. The <code class="literal">extent</code> class contains a number of properties and methods. Properties include <code class="literal">XMin</code>, <code class="literal">XMax</code>, <code class="literal">YMin</code>, <code class="literal">YMax</code>, <code class="literal">spatialReference</code>, and others. The minimum and maximum of <code class="literal">x</code> and <code class="literal">y</code> properties provide the coordinates for the extent rectangle. The <code class="literal">spatialReference</code> property holds a reference to a <code class="literal">spatialReference</code> object for <code class="literal">extent</code>. Object instances of the <code class="literal">extent</code> class can be used both to set and get the values of these properties through dot notation. An example of this is seen in the following code example:</p><div><pre class="programlisting"># get the extent of the county boundary
ext = row[0].extent
# print out the bounding coordinates and spatial reference
print("XMin: " + str(ext.XMin))
print("XMax: " + str(ext.XMax))
print("YMin: " + str(ext.YMin))
print("YMax: " + str(ext.YMax))
print("Spatial Reference: " + ext.spatialReference.name)</pre></div><p>Running this script yields the following output:</p><div><pre class="programlisting">XMin: 2977896.74002
XMax: 3230651.20622
YMin: 9981999.27708
YMax:10200100.7854
Spatial Reference: NAD_1983_StatePlane_Texas_Central_FIPS_4203_Feet</pre></div><p>The <code class="literal">extent</code> class also has a number of methods, which are actions that an object can perform. In the case of this particular object, most of the methods are related to performing some sort of geometric test between the <code class="literal">extent</code> object and another geometry. Examples include <code class="literal">contains()</code>, <code class="literal">crosses()</code>, <code class="literal">disjoint()</code>, <code class="literal">equals()</code>, <code class="literal">overlaps()</code>, <code class="literal">touches()</code>, and <code class="literal">within()</code>.</p><p>One additional object-oriented concept that you need to understand is <strong>dot notation</strong>. Dot notation provides a way of accessing the properties and methods of an object. It is used to indicate that a property or method belongs to a particular class.</p><p>The syntax for using <a id="id56" class="indexterm"/>dot notation includes an object instance followed by a dot and then the property or method. The syntax is the same regardless<a id="id57" class="indexterm"/> of whether you're accessing a property or a method. A parenthesis and zero or more parameters at the end of the word following the dot indicates that a method is being accessed. Here are a couple of examples to better illustrate this concept:</p><div><pre class="programlisting">Property: extent.XMin
Method: extent.touches()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Statements</h2></div></div></div><p>Each line <a id="id58" class="indexterm"/>of code that you write with Python is known as a <strong>statement</strong>. There <a id="id59" class="indexterm"/>are many different kinds of statements, including those that create and assign data to variables, decision support statements that branch your code based on a test, looping statements that execute a code block multiple times, and others. There are various rules that your code will need to follow as you create the statements that are part of your script. You've already encountered one type of statement: variable creation and assignment.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Decision support statements</h3></div></div></div><p>The <a id="id60" class="indexterm"/>
<code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code> statement<a id="id61" class="indexterm"/> is the primary decision-making statement in Python and tests for a <code class="literal">True</code>/<code class="literal">False</code> condition. Decision statements enable you to control the flow of your programs. Here are some example decisions that you<a id="id62" class="indexterm"/> can make in your code: if the variable holds a point feature class, get the <code class="literal">X</code>, <code class="literal">Y</code> coordinates; if the feature class name equals <code class="literal">Roads</code>, then get the <code class="literal">Name</code> field.</p><p>Decision statements, such as <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code>, test for a <code class="literal">True</code>/<code class="literal">False</code> condition. In Python, a <code class="literal">True</code> value means any nonzero number or nonempty object. A <code class="literal">False</code> value indicates <em>not true</em> and is represented in Python with a zero number or empty object. Comparison tests return values of one or zero (true or false). Boolean and/or operators return a true or false operand value:</p><div><pre class="programlisting">if fcName == 'Roads':
  arcpy.Buffer_analysis(fc, "c:\\temp\\roads.shp", 100)
elif fcName == 'Rail':
  arcpy.Buffer_analysis(fc, "c:\\temp\\rail.shp", 50)
else:
  print("Can't buffer this layer")</pre></div><p>The Python code must follow certain syntax rules. Statements execute one after another until your code branches. Branching typically occurs through the use of <code class="literal">if</code>/<code class="literal">elif</code>/<code class="literal">else</code>. In addition to this, the use of looping structures, such as <code class="literal">for</code> and <code class="literal">while</code>, can alter the statement flow. Python automatically detects statement and block boundaries, so there is no need for braces or delimiters around your blocks of code. Instead, indentation is used to group statements in a block. Many languages terminate statements with the use of a semicolon, but <a id="id63" class="indexterm"/>Python simply uses the end of line character to mark the end of a statement. Compound statements include a "<code class="literal">:</code>" character. Compound statements <a id="id64" class="indexterm"/>follow this pattern, that is, header terminated by a colon. Blocks of code are then written as individual statements and are indented underneath the header.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Looping statements</h3></div></div></div><p>Looping statements <a id="id65" class="indexterm"/>allow your program to repeat lines of code over and<a id="id66" class="indexterm"/> over as necessary. <code class="literal">The while</code> loops repeatedly execute a block of statements as long as the test at the top of the loop evaluates to <code class="literal">True</code>. When the condition test evaluates to <code class="literal">False</code>, Python begins interpreting code immediately after the <code class="literal">while</code> loop. In the next code example, a value of <code class="literal">10</code> has been assigned to the <code class="literal">x</code> variable. The test for the <code class="literal">while</code> loop then checks to see if <code class="literal">x</code> is less than <code class="literal">100</code>. If <code class="literal">x</code> is less than <code class="literal">100</code>, the current value of <code class="literal">x</code> is printed to the screen and the value of x is incremented by <code class="literal">10</code>. Processing then continues with the <code class="literal">while</code> loop test. The second time, the value of <code class="literal">x</code> will be <code class="literal">20</code>; so the test evaluates to <code class="literal">True</code> once again. This process continues until <code class="literal">x</code> is equal to or greater than <code class="literal">100</code>. At this time, the test will evaluate to <code class="literal">False</code> and processing will stop. It is very important that <code class="literal">the while</code> statements have some way of breaking out of the loop. Otherwise, you will wind up in an infinite loop. An infinite loop is a sequence of instructions in a computer program that loops endlessly, either due to the loop having no terminating condition, having one that can never be met, or one that causes the loop to start over:</p><div><pre class="programlisting">x = 10
while x &lt; 100:
     print(x)
     x = x + 10</pre></div><p>The <code class="literal">for</code> loops <a id="id67" class="indexterm"/>execute a block of statements a predetermined number of times. They come in two varieties—a <a id="id68" class="indexterm"/>counted loop to run a block of code a set number of times, and a list loop that enables you to loop through all the objects in a list. The list loop in the following example executes once for each value in the dictionary and then stops looping:</p><div><pre class="programlisting">dictLayers = {"Roads":"Line","Rail":"Line","Parks":"Polygon"}
for key in dictLayers:
  print(dictLayers[key])</pre></div><p>There are times <a id="id69" class="indexterm"/>when it will be necessary for you to break out of the execution of a loop. The <code class="literal">break</code> and <code class="literal">continue</code> statements can be used to do this. The <code class="literal">break</code> jumps out of the closest enclosing loop, while <code class="literal">continue</code> jumps back to the top of the closest enclosing loop. These statements can appear anywhere inside the block of code.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Try statements</h3></div></div></div><p>A <a id="id70" class="indexterm"/>
<code class="literal">try</code> statement is <a id="id71" class="indexterm"/>a complete, compound statement that is used to handle exceptions. Exceptions are a high-level control device used primarily for error interception or triggering. Exceptions in Python can either be intercepted or triggered. When an error condition occurs in your code, Python automatically triggers an exception, which may or may not be handled by your code. It is up to you as a programmer to catch an automatically triggered exception. Exceptions can also be triggered manually by your code. In this case, you would also need to provide an exception handling routine to catch these manually triggered exceptions.</p><p>There are two basic types of <a id="id72" class="indexterm"/>
<code class="literal">try</code> statements: <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code> and <code class="literal">try</code>/<code class="literal">finally</code>. The basic <a id="id73" class="indexterm"/>
<code class="literal">try</code> statement starts with a <code class="literal">try</code> header line followed by a block of indented statements. Then, this is followed by one or more optional <code class="literal">except</code> clauses that name the exceptions that are to be caught. After this, you will find an optional <code class="literal">else</code> clause at the end:</p><div><pre class="programlisting">import arcpy
import sys

inFeatureClass = arcpy.GetParameterAsText(0)
outFeatureClass = arcpy.GetParameterAsText(1)

try:
  # If the output feature class exists, raise an error
  
  if arcpy.Exists(inFeatureClass):
    raise overwriteError(outFeatureClass)
  else:
    # Additional processing steps
    print("Additional processing steps")

except overwriteError as e:
  # Use message ID 12, and provide the output feature class
  #  to complete the message.
  
  arcpy.AddIDMessage("Error", 12, str(e))</pre></div><p>The <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code> statement works as follows. Once inside a <code class="literal">try</code> statement, Python marks the fact that you are in a <code class="literal">try</code> block and knows that any exception condition that occurs at this point<a id="id74" class="indexterm"/> will be sent to the various <code class="literal">except</code> statements for handling. If a matching exception is found, the code block inside the <code class="literal">except</code> block is executed. The code then picks up the full <code class="literal">try</code> statement, which will be mentioned shortly. The <code class="literal">else</code> statements are not executed in this case. Each statement inside the <code class="literal">try</code> block is executed. Assuming that no exception conditions occur, the code pointer will then jump to the <code class="literal">else</code> statement and execute the code block contained by the <code class="literal">else</code> statement before moving to the next line of code that follows the try block.</p><p>The other type of <code class="literal">try</code> statement is the <code class="literal">try</code>/<code class="literal">finally</code> statement, which allows for finalization actions. When a <code class="literal">finally</code> clause is used in a <code class="literal">try</code> statement, its block of statements always run at the very end, whether an error condition occurs or not.</p><p>Here is how the <code class="literal">try</code>/<code class="literal">finally</code> statement works: if an exception occurs, Python runs the <code class="literal">try</code> block, then the <code class="literal">except</code> block, followed by the <code class="literal">finally</code> block, and then execution continues past the entire <code class="literal">try</code> statement. If an exception does not occur during execution, Python runs the <code class="literal">try</code> block, then the <code class="literal">finally</code> block. This is useful when you want to make sure an action happens after a code block runs, regardless of whether an error condition occurs. Cleanup operations, such as closing a file or a connection to a database, are commonly placed inside a <code class="literal">finally</code> block to ensure that they are executed regardless of whether an exception occurs in your code:</p><div><pre class="programlisting">import arcpy

try:
  if arcpy.CheckExtension("3D") == "Available":
    arcpy.CheckOutExtension("3D")
  else:
    # Raise a custom exception
    raise LicenseError
  
  arcpy.env.workspace = "D:/GrosMorne"
  arcpy.HillShade_3d("WesternBrook", "westbrook_hill", 300)
  arcpy.Aspect_3d("WesternBrook", "westbrook_aspect")

except LicenseError:
  print("3D Analyst license is unavailable")
except:
  print(arcpy.GetMessages(2))
finally:
  # Check in the 3D Analyst extension
  arcpy.CheckInExtension("3D")</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec09"/>With statements</h3></div></div></div><p>The <a id="id75" class="indexterm"/>
<code class="literal">with</code> statement <a id="id76" class="indexterm"/>is handy when you have two related operations that need to be executed as a pair with a block of code in between. A common scenario to use the <code class="literal">with</code> statements is opening, reading, and closing a file. Opening and closing a file are the related operations, and reading a file and doing something with the contents is the block of code in between. When writing geoprocessing scripts with ArcGIS, the new <code class="literal">cursor</code> objects introduced with version 10.1 of ArcGIS are ideal when using the <code class="literal">with</code> statements. We'll discuss the <code class="literal">cursor</code> objects in great detail in a later chapter, but I'll briefly describe these objects now. Cursors are an in-memory copy of records from the attribute table of a feature class or table. There are various types of cursors. Insert cursors allow you to insert new records, search cursors are a read-only copy of records, and update cursors allow you to edit or delete records. Cursor objects are opened, processed in some way, and closed automatically using a <code class="literal">with</code> statement.</p><p>The closure of a file or cursor object is handled automatically by the <code class="literal">with</code> statement, resulting in cleaner, more efficient coding. It's basically like using a <code class="literal">try</code>/<code class="literal">finally</code> block, but with fewer lines of code. In the following code example, the <code class="literal">with</code> block is used to create a new search cursor, read information from the cursor, and implicitly close the cursor:</p><div><pre class="programlisting">import arcpy

fc = "c:/data/city.gdb/streets"

# For each row print the Object ID field, and use the SHAPE@AREA
# token to access geometry properties

with arcpy.da.SearchCursor(fc, ("OID@", "SHAPE@AREA")) as cursor:
  for row in cursor:
    print("Feature {0} has an area of {1}".format(row[0], row[1]))</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Statement indentation</h3></div></div></div><p>Statement indentation<a id="id77" class="indexterm"/> deserves a special mention as it is critical to the way Python interprets code. Compound statements in Python use indentation to create a group of statements. This includes the <code class="literal">if</code>/<code class="literal">then</code>, <code class="literal">for</code>, <code class="literal">while</code>, <code class="literal">try</code>, and <code class="literal">with</code> statements. The Python interpreter uses indentation to detect these code blocks. The beginning of a compound statement is defined through the use of a colon. All lines following the beginning of the compound statement should be indented the same distance. You can use any number of spaces to define the indentation, but you should use the same indentation level for each statement. A common practice is to define indentation through the use of a tab. When the Python interpreter encounters a line that is less indented, it will assume that the code block has ended. The following code illustrates this concept through the use of a <code class="literal">try</code> statement. Notice that there is a colon after the <code class="literal">try</code> statement. This<a id="id78" class="indexterm"/> indicates that the statements that follow are part of a compound statement and should be indented. These statements will form a code block.</p><p>Also, an <code class="literal">if</code> statement is inside the <code class="literal">try</code> statement. This too is a compound statement as defined by the colon at the end of the statement. Therefore, any statements that are part of the <code class="literal">if</code> statement should be further indented. You should also notice that there is a statement that is not indented inside the <code class="literal">if</code> statement, but is rather at the same level. This <code class="literal">statement4</code> is part of the <code class="literal">try</code> code block but not part of the <code class="literal">if</code> code block:</p><div><pre class="programlisting">try:
  if &lt;statement1&gt;:
    &lt;statement2&gt;
    &lt;statement3&gt;
  &lt;statement4&gt; &lt;………..&gt;
except:
  &lt;statement&gt;
  &lt;………..&gt;
except:
  &lt;statement&gt;
  &lt;…………&gt;</pre></div><p>Many languages, including JavaScript, Java, and .NET, use curly braces to indicate a group of statements. Python uses indentation instead of curly braces in an attempt to cut down on the amount of code you have to write and to make code more readable. Anyone who has ever used these other languages can attest to the difficulty in reading code that contains many curly braces. However, indentation does take some getting used to and is critical to the way that Python executes lines of code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>File I/O</h2></div></div></div><p>You will often<a id="id79" class="indexterm"/> find it necessary to retrieve or write information to files on your computer. Python has a built-in object type that provides a way to access files for many tasks. We're only going to cover a small subset of the file manipulation functionality provided, but we'll touch on the most commonly used functions, including opening and closing files, and reading and writing data to a file.</p><p>Python's <code class="literal">open()</code> function <a id="id80" class="indexterm"/>creates a file object, which serves as a link to a file residing on your computer. You must call the <code class="literal">open()</code> function on a file before reading and/or writing data to a file. The first parameter for the <code class="literal">open()</code> function is a path to the file you'd like to open. The second parameter corresponds to a mode, which is typically read (<code class="literal">r</code>), write (<code class="literal">w</code>), or append (<code class="literal">a</code>). A value of <code class="literal">r</code> indicates that you'd like to open the file for read-only operations, while a value of <code class="literal">w</code> indicates you'd like to open the file for write operations. In the event that you open a file that already exists for write operations, this will overwrite any data currently in the file, so you must be careful with the write mode. The append mode (<code class="literal">a</code>) will open a file for write operations, but instead of overwriting any existing data, it will append the new data to the end of the file. The following code example shows the use of the <code class="literal">open()</code> function to open a text file in a read-only mode:</p><div><pre class="programlisting">with open('Wildfires.txt','r') as f:</pre></div><p>Notice that we have also used the <code class="literal">with</code> keyword to open the file, ensuring that the file resource will be <em>cleaned up</em> after the code that uses it has finished executing.</p><p>After a file has<a id="id81" class="indexterm"/> been opened, data can be read from it in a number of ways and using various methods. The most typical scenario would be to read data one line at a time from a file through the <code class="literal">readline()</code> method. The <code class="literal">readline()</code> function can be used to read the file one line at a time into a string variable. You would need to create a looping mechanism in your Python code to read the entire file line by line. If you would prefer to read the entire file into a variable, you can use the <code class="literal">read()</code> method, which will read the file up to the <a id="id82" class="indexterm"/>
<strong>End Of File</strong> (<strong>EOF</strong>) marker. You can also use the <code class="literal">readlines()</code> method to read the entire contents of a file, separating each line into individual strings, until the EOF is found.</p><p>In the following code example, we have opened a text file called <code class="literal">Wildfires.txt</code> in the read-only mode and used the <code class="literal">readlines()</code> method on the file to read its entire contents into a variable called <code class="literal">lstFires</code>, which is a Python list containing each line of the file as a separate string value in the list. In this case, the <code class="literal">Wildfire.txt</code> file is a comma-delimited text file containing the latitude and longitude of the fire along with the confidence values for each fire. We then loop through each line of text in <code class="literal">lstFires</code> and use the <code class="literal">split()</code> function to extract the values based on a comma as the delimiter, including the latitude, longitude, and confidence values. The latitude and longitude values are used to create a new <code class="literal">Point</code> object, which is then inserted into the feature class using an insert cursor:</p><div><pre class="programlisting">import arcpy, os
try:
 
  arcpy.env.workspace = "C:/data/WildlandFires.mdb"
  # open the file to read
  with open('Wildfires.txt','r') as f:   #open the file

    lstFires = f.readlines() #read the file into a list
    cur = arcpy.InsertCursor("FireIncidents")
  
    for fire in lstFires: #loop through each line
      if 'Latitude' in fire: #skip the header
        continue
      vals = fire.split(",") #split the values based on comma
      latitude = float(vals[0]) #get latitude
      longitude = float(vals[1]) #get longitude
      confid = int(vals[2]) #get confidence value
      #create new Point and set values
      pnt = arcpy.Point(longitude,latitude) 
      feat = cur.newRow()
      feat.shape = pnt
      feat.setValue("CONFIDENCEVALUE", confid)
      cur.insertRow(feat) #insert the row into featureclass
except:
    print(arcpy.GetMessages()) #print out any errors
finally:
  del cur
  f.close()</pre></div><p>Just as is the <a id="id83" class="indexterm"/>case with reading files, there are a number of methods that you can use to write data to a file. The <code class="literal">write()</code> function is probably the easiest to use and takes a single string argument and writes it to a file. The <code class="literal">writelines()</code> function can be used to write the contents of a list structure to a file. In the following code example, we have created a list structure called <code class="literal">fcList</code>, which contains a list of feature classes. We can write this list to a file using the <code class="literal">writelines()</code> method:</p><div><pre class="programlisting">outfile = open('c:\\temp\\data.txt','w')
fcList = ["Streams", "Roads", "Counties"]
outfile.writelines(fcList)</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>In this chapter, we covered some of the fundamental Python programming concepts that you'll need to understand before you can write effective geoprocessing scripts. We began the chapter with an overview of the IDLE development environment to write and debug Python scripts. You learned how to create a new script, edit existing scripts, check for syntax errors, and execute scripts. We also covered the basic language constructs, including importing modules, creating and assigning variables, if/else statements, looping statements, and the various data-types including strings, numbers, Booleans, lists, dictionaries, and objects. You also learned how to read and write text files.</p></div></div>
</body></html>