- en: PostGIS and the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with MapServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with GeoServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WMS Time service with MapServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WMS services with OpenLayers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WMS services with Leaflet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WFS-T services with OpenLayers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a web GPX viewer with Mapbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to give you an overview of how you can use PostGIS
    to develop powerful GIS web applications, using **Open Geospatial Consortium**
    (**OGC**) web standards such as **Web Map Service** (**WMS**) and **Web Feature
    Service** (**WFS**).
  prefs: []
  type: TYPE_NORMAL
- en: In the first two recipes, you will get an overview of two very popular open
    source web-mapping engines, **MapServer** and **GeoServer**. In both these recipes,
    you will see how to implement WMS and WFS services using PostGIS layers.
  prefs: []
  type: TYPE_NORMAL
- en: In the third recipe, you will implement a **WMS Time** service using MapServer
    to expose time-series data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two recipes, you will learn how to consume these web services to
    create web map viewers with two very popular JavaScript clients. In the fourth
    recipe, you will use a WMS service with **OpenLayers**, while in the fifth recipe,
    you will do the same thing using **Leaflet**.
  prefs: []
  type: TYPE_NORMAL
- en: In the sixth recipe, you will explore the power of transactional WFS to create
    web-mapping applications to enable editing data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two recipes, you will unleash the power of the popular **Django**
    web framework, which is based on Python, and its nice **GeoDjango** library, and
    see how it is possible to implement a powerful **CRUD** GIS web application. In
    the seventh recipe, you will create the back office for this application using
    the Django Admin site, and in the last recipe of the chapter, you will develop
    a frontend for users to display data from the application in a web map based on
    Leaflet.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last recipe, you will learn how to import your PostGIS data
    into Mapbox using **OGR** to create a custom web GPX viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with MapServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will see how to create a WMS and WFS from a PostGIS layer,
    using the popular MapServer open source web-mapping engine.
  prefs: []
  type: TYPE_NORMAL
- en: You will then use the services, testing their exposed requests, using first
    a browser and then a desktop tool such as QGIS (you could do this using other
    software, such as uDig, gvSIG, and OpenJUMP GIS).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps before getting ready:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a schema for this chapter within the `postgis_cookbook` database using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to have Apache HTTP installed (MapServer will run on it as a CGI) and
    check whether it is working by visiting its home page at `http://localhost` (typically,
    an `It works!` message will be displayed if you still have not customized any
    features).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install MapServer as per its installation guide ([http://mapserver.org/installation/index.html](http://mapserver.org/installation/index.html)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A handy way to have MapServer up and running in Apache for Windows is to install
    the OSGeo4W ([http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/))
    or MS4W ([http://www.maptools.org/ms4w/](http://www.maptools.org/ms4w/)) packages.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux, there are packages for almost any kind of distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, you can use again the CMake app to build the installation or use
    Homebrew with the following command (note the flags needed to compile it with
    Postgres support):'
  prefs: []
  type: TYPE_NORMAL
- en: '`brew install mapserver --with-postgresql --with-geos`'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether MapServer has been installed correctly and has `POSTGIS`, `WMS_SERVER`,
    and `WFS_SERVER` support enabled, by running it as a command-line tool with the
    `-v` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Linux, run the `$ /usr/lib/cgi-bin/mapserv -v` command and check for the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, use the `$ mapserv -v` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9605c5be-1509-4b2b-814f-cbaa205e7f41.png)'
  prefs: []
  type: TYPE_IMG
- en: Now check whether MapServer is working from within HTTPD, using `http://localhost/cgi-bin/mapserv`
    (`http://localhost/cgi-bin/mapserv.exe` for Windows). If you get a `No query information
    to decode. QUERY_STRING is set, but empty` response message, MapServer is correctly
    working as a CGI script in Apache and is ready to accept HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the world countries shapefile from [http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip](http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip).
    A copy of this shapefile is included in the book dataset for [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data In and Out of PostGIS*. Extract the shapefile to the `working/chp09`
    directory and import it in PostGIS using the **shp2pgsql** tool (be sure to specify
    the spatial reference system, *EPSG:4326*, with the `-s` option), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'MapServer exposes its map services using `mapfile`, a text file format, with
    which it is possible to define the PostGIS layers on the web, enable any vector
    and raster format supported by GDAL, and specify which services (WMS/WFS/WCS)
    to expose per layer. Create a new text file named `countries.map` and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save the file we just created in a location that is accessible to the Apache
    user. For example, in Debian, it is `/var/www/data`, while in Windows, it can
    be `C:\ms4w\Apache\htdocs`; for macOS, you should use `/Library/WebServer/Documents`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure that both the file and the directory containing it are accessible to
    the Apache user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `template.html` in the same location as the `mapfile` and
    enter the following code in it (this file is used by the `GetFeatureInfo` WMS
    request to output an HTML response to the client):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `mapfile` you just created, you exposed the `countries` PostGIS layer,
    both as a WMS and WFS service. Both of these services expose to the user a series
    of requests and you will now test them using a browser. First, without invoking
    any services, test whether the `mapfile` is working correctly by typing the following
    URL in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&layer=countries&mode=map`
    (for Linux)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdocs\countries.map&layer=countries&mode=map`
    (for Windows)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&layer=countries&mode=map`
    [(for macOS)](http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&layer=countries&mode=map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should see the `countries` layer rendered with the three symbology classes
    defined in the `mapfile`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3f45c7a-ea25-4f2e-8ebd-c67a78a640d4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a small difference between the URLs used in Windows,
    Linux, and macOS. We will refer to Linux from now on, but you can easily adapt
    the URLs to Windows or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will start testing the WMS service; you will try running the `GetCapabilities`,
    `GetMap`, and `GetFeatureInfo` requests. To test the `GetCapabilities` request,
    type the URL in the browser: `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities`.
    You should receive a long XML response (as follows) from the server, where the
    more important fragments are the WMS service definitions in the `<Service>` section,
    the requests are enabled in the `<Capability>` section, and the layers exposed
    and their main details (for example, name, abstract, projection, and extent) are
    in the `<Layer>` section of each of the layers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now test the WMS service with its typical `GetMap` WMS request, used on many
    clients to display a map to the user. Type the URL `http://localhost//cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-26,-111,36,-38&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=countries&STYLES=&FORMAT=image/png`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Into the browser and check the image that is sent back in response by the MapServer
    `GetMap` request, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45ee2c30-3a5b-4464-b702-215b62607c43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another typical WMS request is `GetFeatureInfo`, used by clients to query the
    map layer at the given coordinates (points). Type the following URL and you should
    see the field values for a given feature as the output (the output is built using
    the `template.html` file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bf9f74b-7418-4290-9160-1652f97e6b55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you will use QGIS to use the WMS service. Launch QGIS, click on the Add
    WMS layer button (alternatively, navigate to Layer | Add WMS Layer or use the
    QGIS browser), and create a new WMS connection, as shown in the following screenshot.
    Type something such as `MapServer on localhost` in the Name field and `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities`
    in the URL field, and click on the OK button (remember to adjust the Apache URL
    according to the configuration of your OS; check step 4):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/641af38a-fedf-49ae-b089-371abd584fe3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Connect button, as shown in the following screenshot. Then,
    select the countries layer and add it to the QGIS map window using the Add button,
    making sure to select the coordinate system EPSG:4326:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06b1e728-cc8e-45e9-8820-3bb239f38d5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now browse to your WMS countries layer and try to perform some identification
    operations. QGIS will raise the needed `GetMap` and `GetFeatureInfo` WMS requests
    for you behind the scenes to give the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33ad34f9-2943-40dc-8188-b3e8ab039c41.png)'
  prefs: []
  type: TYPE_IMG
- en: Having seen how the WMS service works, you will now start using WFS. Like WMS,
    WFS offers the user a `GetCapabilities` request as well, resulting in a similar
    output to the `GetCapabilities` request of WMS. Type the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=GetCapabilities`
    into the browser window to inspect the XML response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main WFS request is `GetFeature`. It lets you query the map layer using
    several criteria, returning a collection of features in response as **Geography
    Markup Language** (**GML**) output. Test the request by typing this URL in the
    browser: `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=getfeature&TYPENAME=countries&MAXFEATURES=5`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get an XML (GML) response from the browser, as shown in the following
    code, with a `<wfs:FeatureCollection>` element composed of five `<gml:featureMember>`
    elements (as indicated in the `MAXFEATURES` parameter of the request), each representing
    one country. For each feature, the WFS returns the geometry and all of the field
    values (this behavior was specified by setting the `gml_include_items` variable
    in the `METADATA` layer directive in the `mapfile`). You will see a geometry as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As a result of the WFS `GetFeature` request executed in the previous step, MapServer
    has returned only the first five features of the `countries` layers. Now, use
    the `GetFeature` request to make a query to the layer using a filter and get back
    the corresponding features. By typing the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=getfeature&TYPENAME=countries&MAXFEATURES=5&Filter=<Filter>
    <PropertyIsEqualTo><PropertyName>name</PropertyName> <Literal>Italy</Literal></PropertyIsEqualTo></Filter>`,
    you will get the feature in the database that has the `name` field set to `Italy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After testing the WFS requests in a browser, try to open the WFS service in
    QGIS using the Add WFS Layer button (alternatively, navigate to Layer | Add WFS
    Layer or use the QGIS browser). You should see the same MapServer on Localhost
    connection you created a few steps earlier. Click on the Connect button and select
    the countries layer, add it to the QGIS project, and browse through it by zooming,
    panning, and identifying some features. The biggest difference when compared to
    WMS is that, with WFS, you receive the feature geometries from the server and
    not just an image, so you can even export the layer to a different format, such
    as a shapefile or spatialite! The Add WFS layer from a Server window is as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b33d2e02-85a1-4451-9fed-b784d1b40722.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should now be able to see the vector map in QGIS and inspect the features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1a28131-5c43-4291-8664-9b3c5a6019b3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented WMS and WFS services for a PostGIS layer using
    the MapServer open source web-mapping engine. WMS and WFS are the two core concepts
    to consider when you want to develop a web GIS that is interoperable across many
    organizations. **Open Geospatial Consortium** (**OGC**) defined these two standards
    (and many others) to make web-mapping services exposed in an open, standard way.
    This way these services can be used by different applications; for example, you
    have seen in this recipe that a GIS Desktop tool such as QGIS can browse and query
    those services because it understands these OGC standards (you can get exactly
    the same results with other tools, such as gvSIG, uDig, OpenJUMP, and ArcGIS Desktop,
    among others). In the same way, Javascript API libraries, most notably OpenLayers
    and Leaflet (you will be using these in the other recipes in this chapter), can
    use these services in a standard way to provide web-mapping features to web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'WMS is a service that is used to generate the maps to be displayed by clients.
    Those maps are generated using image formats, such as PNG, JPEG, and many others.
    Some of the most typical WMS requests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCapabilities`: This offers an overview of the services offered by WMS,
    particularly a list of the available layers and some of the details of each layer
    (layer extent, coordinate reference systems, URI of the data, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMap`: This returns a map image representing one or more layers for a specified
    extent and spatial reference, in a specified image file format and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFeatureInfo`: This is an optional request by WMS that returns, in different
    formats, the attribute values for the features of a given point in the map. You
    have seen how to customize the response by introducing a template file that must
    be set in the `mapfile`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WFS provides a convenient, standard way to access the features of a vector layer
    with a web request. The service response streams to the client the requested features
    using GML (an XML markup defined by OGC to define geographical features).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some WFS requests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCapabilities`: This gives a description of the services and layers offered
    by the WFS service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFeature`: This allows the client to get a set of features of a given layer,
    corresponding to a given criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These WMS and WFS requests can be consumed by the client using the HTTP protocol.
    You have seen how to query and get a response from the client by typing a URL
    in a browser with several parameters appended to it. As an example, the following
    WMS `GetMap` request will return a map image of the layers (using the `LAYERS`
    parameter) in a specified format (using the `FORMAT` parameter), size (using the
    `WIDTH` and `HEIGHT` parameters), extent (using the `BBOX` parameter), and spatial
    reference system (using `CRS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In MapServer, you can create WMS and WFS services in the `mapfile` using its
    directives. The `mapfile` is a text file that is composed of several sections
    and is the heart of MapServer. In the beginning of the `mapfile`, it is necessary
    to define general properties for the map, such as its title, extent, spatial reference,
    output-image formats, and dimensions to be returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is possible to define which OWS (OGC web services such as WMS, WFS,
    and WCS) requests to expose.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the main section of the `mapfile`, where the layers are defined
    (every layer is defined in the `LAYER` directive). You have seen how to define
    a PostGIS layer. It is necessary to define its connection information (database,
    user, password, and so on), the SQL definition in the database (it is possible
    to use just a PostGIS table name, but you could eventually use a query to define
    the set of features and attributes defining the layer), the geometric type, and
    the projection.
  prefs: []
  type: TYPE_NORMAL
- en: A whole directive (`CLASS`) is used to define how the layer features will be
    rendered. You may use different classes, as you did in this recipe, to render
    features differently, based on an attribute defined with the `CLASSITEM` setting.
    In this recipe, you defined three different classes, each representing a population
    class, using different colors.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more information about using MapServer by using its extensive documentation
    at its project home page ([http://mapserver.org/it/index.html](http://mapserver.org/it/index.html)).
    You will find the mapfile documentation at [http://www.mapserver.org/mapfile/](http://www.mapserver.org/mapfile/)
    very useful to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good tutorial to understand how to generate mapfiles can be found at [http://mapserver.org/tutorial/example1-1.html](http://mapserver.org/tutorial/example1-1.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you want to gain a better understanding of the WMS and WFS standards,
    check their specifications at the OGC website. For the WMS service, go to [http://www.opengeospatial.org/standards/wms](http://www.opengeospatial.org/standards/wms),
    whereas for WFS, go to [http://www.opengeospatial.org/standards/wfs](http://www.opengeospatial.org/standards/wfs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with GeoServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you created WMS and WFS from a PostGIS layer using MapServer.
    In this recipe, you will do it using another popular open source web-mapping engine-GeoServer.
    You will then use the created services as you did with MapServer, testing their
    exposed requests, first using a browser and then the QGIS desktop tool (you can
    do this with other software, such as uDig, gvSIG, OpenJUMP GIS, and ArcGIS Desktop).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While MapServer is written in the C language and uses Apache as its web server,
    GeoServer is written in Java and you therefore need to install the **Java Virtual
    Machine** (**JVM**) in your system; it must be used from a servlet container,
    such as *Jetty* and *Tomcat*. After installing the servlet container, you will
    be able to deploy the GeoServer application to it. For example, in Tomcat, you
    can deploy GeoServer by copying the GeoServer **WAR** (**web archive**) file to
    Tomcat''s `webapps` directory. For this recipe, we will suppose that you have
    a working GeoServer in your system; if this is not the case, follow the detailed
    GeoServer installation steps for your OS at the GeoServer website ([http://docs.geoserver.org/stable/en/user/installation/](http://docs.geoserver.org/stable/en/user/installation/))
    and then return to this recipe. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the USA counties shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz)
    (this archive is included in the book''s code bundle). Extract the archive from
    `working/chp09` and import it to PostGIS using the `ogr2ogr` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the GeoServer administrative interface, which is typically located at
    `http://localhost:8080/geoserver`, in your favorite browser and log in using your
    credentials (`admin` as the username and `geoserver` as the password) if you are
    just using the GeoServer default installation and have not customized things.
    After starting GeoServer, you should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c14f51e-d987-4f22-b69d-1007285368fc.png)'
  prefs: []
  type: TYPE_IMG
- en: GeoServer welcome screen viewed in a browser
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully logging in, create a workspace by clicking on the Workspace
    link under Work (in the left-hand-side panel of the GeoServer application''s main
    menu) and then click on the Add new workspace link. In the text boxes of the form
    that appears, specify the following values and then click on the Submit button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Name field
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the URL [https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook) in
    the Namespace URI field
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to create a PostGIS store, click on the Stores link under Data (in the
    left-hand-side panel of the GeoServer application''s main menu). Now, click on
    the Add new store link, and then on the PostGIS link under Vector Data Sources,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9d4876a-99c6-4371-bf25-bd379f7640fc.png)'
  prefs: []
  type: TYPE_IMG
- en: GeoServer screen to configure new data sources
  prefs: []
  type: TYPE_NORMAL
- en: 'In the New Vector Data Source page, complete the form''s fields, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select postgis_cookbook from the Workspace drop-down list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Data Source Name field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `localhost` in the host field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `5432` in the port field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the database field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `chp09` in the schema field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `me` in the user field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mypassword` in the passwd field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The New Vector Data Source page is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86b686de-bf22-4356-86fb-84a3b231b629.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Save button to successfully create your PostGIS store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you are ready to publish the PostGIS `counties` layer as WMS and WFS. On
    the Layers page, click on the Add a new resource link. Now, select postgis_cookbook
    from the Add layer from drop-down list. Click on the Publish link to the right
    of the `counties` layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Edit Layer page, shown in the following screenshot, click on the links
    Compute from data and Compute from native bounds, and then click on the Save button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1bc14616-fcaf-4d05-a931-8d36b0609e04.png)'
  prefs: []
  type: TYPE_IMG
- en: GeoServer screen to edit the countries layer for publishing
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to define the style used to display the layer to the user. Unlike
    MapServer, GeoServer uses the OGC-standard **Styled Layer Descriptor** (**SLD**)
    notation. Click on the Styles link under Data and then on the Add new style link.
    Fill the text fields in the form, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Counties classified per size` in the Name field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Workspace field
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text area for the SLD, add the following XML code defining the style
    for the `counties` layer. Then, click on the Validate button to check whether
    your SLD definition is correct and then click on the Submit button to save the
    new style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the new style looks on the New style GeoServer
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ebe49df-a1fc-495d-8c51-ba5b77fa79dc.png)'
  prefs: []
  type: TYPE_IMG
- en: GeoServer screen for creating a new style as an SLD document
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to associate the created style with the `counties` layer. Go back
    to the layer page (Data | Layers), click on the `counties` layer link, and then,
    on the Edit Layer page, click on the Publishing section. Select Counties classified
    per size in the Default style drop-down list and then click on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that your WMS and WFS services for the PostGIS `counties` layer are ready,
    it is time to start using them! First, test the `GetCapabilities` WMS request.
    To do this, you can click on one of the links on the right-hand-side panel on
    the GeoServer web application home page. You can click on the link for either
    WMS version 1.1.1 or WMS version 1.3.0\. Click on one of the links or type the
    `GetCapabilities` request directly in the browser as `http://localhost:8080/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will investigate the `GetCapabilities` response, shown as follows.
    You will find a lot of information about WMS is available on your GeoServer instance,
    such as the WMS-supported requests, projections, and a lot of other information
    about each published layer. In the case of the `counties` layer, the following
    code is an extract from the `GetCapabilities` document. Note the main layer information,
    such as the name, title, abstract (you could redefine all of these using the GeoServer
    web application), the supported **Coordinate Reference Systems** (**CRS**), the
    geographic extent, and the associated style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To test the `GetMap` and `GetFeatureInfo` WMS requests, the GeoServer web application
    offers you a very handy way with the Layer Preview page. Navigate to Data | Layer
    Preview and then click on the OpenLayers link next to the `counties` layer. The
    Layer Preview page is based on the OpenLayers JavaScript library and lets you
    experiment with the `GetMap` and `GetFeatureInfo` requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to navigate the map; at each zoom and pan action, GeoServer will stream
    out a new image provided by the response output to a `GetMap` request. By clicking
    on the map, you can perform a `GetFeatureInfo` request and the user interface
    will display the feature''s attributes corresponding to the point on the map on
    which you clicked. A very effective way to check how the requests are sent to
    GeoServer as you navigate the map is by using the Firefox Firebug plugin or the
    Chrome (or Chromium if you are using Linux) Developer Tools. With these tools,
    you will be able to identify the `GetMap` and `GetFeatureInfo` requests that are
    being sent behind the scenes from the OpenLayers viewer to GeoServer. One such
    map is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5af96157-29eb-4046-b8ba-ca8c21ea9618.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is what you get when inspecting the requests with any in-browser developer
    tool, check the request URL, and verify the parameters sent to geoserver; this
    is how it looks with Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216a52c9-ba61-47a8-8eb9-4d553da53aac.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, try a WMS `GetMap` request by typing the URL `http://localhost:8080/geoserver/postgis_cookbook/wms?LAYERS=postgis_cookbook%3Acounties&STYLES=&FORMAT=image%2Fpng&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&SRS=EPSG%3A4326&BBOX=-200.50286594033,7.6152902245522,-43.196688503029,81.457450330258&WIDTH=703&HEIGHT=330`
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try a WMS `GetFeatureInfo` request, as well, by typing the URL `http://localhost:8080/geoserver/postgis_cookbook/wms?REQUEST=GetFeatureInfo&EXCEPTIONS=application%2Fvnd.ogc.se_xml&BBOX=-126.094303%2C37.16812%2C-116.262667%2C41.783255&SERVICE=WMS&INFO_FORMAT=text%2Fhtml&QUERY_LAYERS=postgis_cookbook%3Acounties&FEATURE_COUNT=50&Layers=postgis_cookbook%3Acounties&WIDTH=703&HEIGHT=330&format=image%2Fpng&styles=&srs=EPSG%3A4326&version=1.1.1&x=330&y=158.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will be displayed by prompting the previous URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f347c04-adad-4a07-acf2-794521794387.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, as you did for the MapService WMS, test the GeoServer WMS in QGIS. Create
    a WMS connection named `GeoServer on localhost`, pointing to the GeoServer `GetCapabilities`
    document (`http://localhost:8080/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities`).
    Then, connect to the WMS server (for example, from the QGIS browser), select `counties`
    from the Layers list, and add it to the map, as shown in the following screenshot;
    then navigate the layer and try to identify some of the features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f2dcd78-4399-4edf-ad1c-8e72aa855614.png)'
  prefs: []
  type: TYPE_IMG
- en: Having used WMS, try to test a couple of WFS requests. A typical WFS `GetCapability`
    request can be executed by typing the URL `http://localhost:8080/geoserver/wfs?service=wfs&version=1.1.0&request=GetCapabilities`.
    You could also click on one of the WFS links on the home page of the GeoServer
    web interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Investigate the XML `GetCapabilities` response and try to identify the information
    about your layer. You should have a `<FeatureType>` element, such as the following,
    corresponding to the `counties` layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the previous recipe, a typical WFS request is `GetFeature`, which
    will result in a GML response. Try it by typing the URL `http://localhost:8080/geoserver/wfs?service=wfs&version=1.0.0&request=GetFeature&typeName=postgis_cookbook:counties&maxFeatures=5`
    in your browser. You will receive a GML output composed of a `<wfs:FeatureCollection>`
    element and a collection of `<gml:featureMember>` elements (possibly five elements,
    as specified in the `maxFeatures` request''s parameter). You will get an output
    that is similar to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you did with WMS, try the counties WFS in QGIS (or in your favorite
    desktop GIS client). Create a new WFS connection by using either the QGIS browser
    or the Add WFS Layer button and then clicking on the New Connection button. In
    the Create a new WFS connection dialog box, type `GeoServer on localhost` in the
    Name field and add the WFS `GetCapabilities` URL (`http://localhost:8080/geoserver/wfs?service=wfs&version=1.1.0&request=GetCapabilities`)
    in the URL field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the WFS `counties` layer from the previous dialog box and, as a test, select
    some of the counties and export them to a new shapefile using the Save As command
    from the layer''s context menu, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/febf1b0e-d10c-4b74-83b0-f53424461ea6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you were introduced to the basic concepts of the OGC
    WMS and WFS standards using MapServer. In this recipe, you have done the same
    using another popular open source web-mapping engine, GeoServer.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike MapServer, which is written in C and can be used from web servers such
    as Apache HTTP (HTTPD) or Microsoft **Internet Information Server** (**IIS**)
    as a CGI program, GeoServer is written in Java and needs a servlet container such
    as Apache Tomcat or Eclipse Jetty to work.
  prefs: []
  type: TYPE_NORMAL
- en: GeoServer not only offers the user a highly scalable and standard web-mapping
    engine implementation, but does so with a nice user interface, the Web Administration
    interface. Therefore, it is generally easier for a beginner to create WMS and
    WFS services compared to MapServer, where it is necessary to master the mapfile
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The GeoServer workflow to create WMS and WFS services for a PostGIS layer is
    to first create a PostGIS store, where you need to associate the main PostGIS
    connection parameters (server name, schema, user, and so on). After the store
    is correctly created, you can publish the layers that are available for that PostGIS
    store. You have seen in this recipe how easy the whole process is using the GeoServer
    Web Administration interface.
  prefs: []
  type: TYPE_NORMAL
- en: To define the layer style to render features, GeoServer uses the SLD schema,
    an OGC standard based on XML. We have written two distinct rules in this recipe
    to render the counties that have an area greater than 5,000 square miles an area
    greater than 5,000 square miles in a different way from the others. For the purpose
    of rendering the counties in a different way, we have used two `<ogc:Rule>` SLD
    elements in which you have defined an `<ogc:Filter>` element. For each of these
    elements, you have defined the criteria to filter the layer features, using the
    `<ogc:PropertyIsGreaterThanOrEqualTo>` and `<ogc:PropertyIsLessThan>` elements.
    A very handy way to generate an SLD for a layer is using desktop GIS tools that
    are able to export an SLD file for a layer (QGIS can do this). After exporting
    the file, you can upload it to GeoServer by copying the SLD file content to the
    Add a new style page.
  prefs: []
  type: TYPE_NORMAL
- en: Having created the WMS and WFS services for the counties layer, you have been
    testing them by generating the requests using the handy Layer Preview GeoServer
    interface (based on OpenLayers) and then typing the requests directly in a browser.
    You can modify each service request's parameters from the Layer Preview interface
    or just by changing them in the URL query string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you tested the services using QGIS and have seen how it is possible
    to export some of the layer's features using the WFS service.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want more information about GeoServer, you can check out its excellent
    documentation at [http://docs.geoserver.org/](http://docs.geoserver.org/) or get
    the wonderful *GeoServer Beginner's Guide* book by Packt Publishing ([http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book](http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WMS Time service with MapServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will implement a WMS Time with MapServer. For time-series
    data, and whenever you have geographic data that is updated continuously and you
    need to expose it as a WMS in a Web GIS, WMS Time is the way to go. This is possible
    by providing the `TIME` parameter a time value in the WMS requests, typically
    in the `GetMap` request.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will implement a WMS Time service for the hotspots, representing possible
    fire data acquired by NASA's **Earth Observing System Data and Information System**
    (**EOSDIS**). This excellent system provides data derived from MODIS images from
    the last 24 hours, 48 hours, and 7 days, which can be downloaded in shapefile,
    KML, WMS, or text file formats. You will load a bunch of this data to PostGIS,
    create a WMS Time service with MapServer, and test the WMS `GetCapabilities` and
    `GetMap` requests using a common browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to the WMS standard, please check the previous two recipes to
    get more information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, download one week's worth of active fire data (hotspots) from the EOSDIS
    website. For example, Firedata from EOSDIS can be found in this link: [https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data](https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data).
    A copy of this shapefile is included in the book code bundle. Use that if you
    want to use the SQL and WMS parameters that have been used in the following steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the shapefile from the `Global_7d.zip` archive to the `working/chp09`
    directory and import this shapefile in PostGIS using the `shp2pgsql` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the import is completed, check the point fire data (hotspots) you just
    imported in PostGIS. Each hotspot contains a bunch of useful information, most
    notably the geometry and the acquisition date and time stored in the `acq_date`
    and `acq_time` fields. You can easily see that the features loaded from the shapefile
    span eight consecutive days using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4076998-8aa8-4191-a0e4-d675f64a9e67.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create a WMS for the PostGIS hotspot layer. Create a `mapfile`
    named `hotspots.map` in a directory accessible to the HTTPD (or IIS) user (for
    example, `/var/www/data` in Linux, `/Library/WebServer/Documents/` for macOS,
    and `C:\ms4w\Apache\htdocs` in Windows), by executing the following code after
    adjusting the database connection settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the WMS GetCapabilities request for this mapfile is working well
    by typing the following URLs in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities`
    (in Linux)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map&SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities`
    (in Windows)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotspots.map&
    SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities` (in macOS)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following steps, we will be referring to Linux. If you are using Windows,
    you just need to replace `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map`
    with `http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map`;
    or if using macOS, replace it with `http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotsposts.map`
    in every request:'
  prefs: []
  type: TYPE_NORMAL
- en: Now query the WMS service with a `GetMap` request. Type the following URL in
    the browser. If everything is correct, MapServer should return an image with some
    hotspots as a response. The URL is `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The map displayed on your browser will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e87157b9-e037-468c-96d7-d43bf066454b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Until now, you have implemented a simple WMS service. Now, to make the `TIME`
    parameter available for WMS Time requests, add the `wms_timeextent`, `wms_timeitem`
    and `wms_timedefault` variables in the `LAYER METADATA` section, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added these parameters in the `LAYER METADATA` mapfile section, the
    WMS `GetCapabilities` response should change. Now, the hotspots layer definition
    includes the time dimension, defined by the `<Dimension>` and `<Extent>` elements.
    You will get a response, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e238ef42-eef4-4b4e-b1ab-9d837b6dadb7.png)'
  prefs: []
  type: TYPE_IMG
- en: You can finally test the WMS service with time support. You only need to remember
    to add the `TIME` parameter in the `GetMap` request (otherwise, `GetMap` will
    filter out the data using the default date, which is `2017-12-12` in this example)
    using the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play for a while with the `TIME` parameter in the preceding URL and try to see
    how the GetMap image response changes day by day. Remember that, for the dataset
    we imported, the `acq_date` range is from `2017-12-07` to `2017-12-14`; but in
    your case, if you didn't use the hostpots shapefile included in the book dataset,
    the time range will be different!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are different outputs for the mentioned dates and the full URLs
    used to query the service:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-14`.
    The output is as follows (2017-12-14):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/04511f88-e1af-4723-82cf-036066eea89f.png)'
  prefs: []
  type: TYPE_IMG
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-07`.
    The output is as follows (2017-12-07):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d25c2dbd-3f54-4402-8524-366b585e7519.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how to create a WMS Time service using the MapServer
    open source web-mapping engine. A WMS Time service is useful for whenever you
    have temporal series and geographic data varying in the time. WMS Time lets the
    user filter the requested data by providing a `TIME` parameter with a time value
    in the WMS requests.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, you first created a plain WMS; if you are new to the WMS standard,
    mapfile, and MapServer, you can check out the first recipe in this chapter. You
    have imported in PostGIS a points shapefile with one week's worth of hotspots
    derived from the MODIS satellite and created a simple WMS for this layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that this WMS works well by testing the WMS `GetCapabilities`
    and `GetMap` requests, you have time enabled the WMS by adding three parameters
    in the `LAYER METADATA` mapfile section: `wms_timeextent`, `wms_timeitem`, and
    `wms_timedefault`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `wms_timeextent` parameter is the duration of time in which the service
    will give a response. It defines the PostGIS `table` field to be used to filter
    the `TIME` parameter (the `acq_date` field in this case). The `wms_timedefault`
    parameter specifies a default time value to be used when the request to the WMS
    service does not provide the `TIME` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the WMS is time enabled; this means that the WMS GetCapabilities
    request now includes the time-dimension definition for the PostGIS hotspots layer
    and, more importantly, the GetMap WMS request lets the user add the `TIME` parameter
    to query the layer for a specific date.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WMS services with OpenLayers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will use the MapServer and Geoserver WMS you created in
    the first two recipes of this chapter using the OpenLayers open source JavaScript
    API.
  prefs: []
  type: TYPE_NORMAL
- en: This excellent library helps developers quickly assemble web pages using mapping
    viewers and features. In this recipe, you will create an HTML page, add an OpenLayers
    map in it and a bunch of controls in that map for navigation, switch the layers,
    and identify features of the layers. We will also look at two WMS layers pointing
    to the PostGIS tables, implemented with MapServer and GeoServer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MapServer uses *PROJ.4* ([https://trac.osgeo.org/proj/)](https://trac.osgeo.org/proj/))
    for projection management. This library does not exist by default with the *Spherical
    Mercator* projection (*EPSG:900913*) defined. Such a projection is commonly used
    by commercial map API providers, such as GoogleMaps, Yahoo! Maps, and Microsoft
    Bing, and can provide excellent base layers for your maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we need to have under consideration the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Due to security restrictions in JavaScript, it is not possible to retrieve information
    from remote domains using `XMLHttpRequest`. You will encounter this issue in the
    recipe when you send a WMS `GetFeatureInfo` request to a GeoServer that is typically
    running on Tomcat at port 8080 and also send a request from an HTML page running
    on Apache or ISS at port 80\. Therefore, unless you run your GeoServer instance
    using HTTPD URL rewriting, the solution is to create a proxy script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the proxy script included in the book dataset to the web `cgi` directory
    of your computer (in Linux, at `/usr/lib/cgi-bin`/, in macOS, at `/Library/WebServer/CGI-Executables,`
    and in Windows, at `C:\ms4w\Apache\cgi-bin`), open the proxy.`cgi` file, and add
    `localhost:8080` to the `allowedHosts` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `openlayers.html` file and add the `<head>` and `<body>` tags. In
    the `<head>` tag, import the OpenLayers JavaScript library by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, add a `<div>` element in the `<body>` tag that will contain the OpenLayers
    map. The map should be given a width of 900 pixels and a height of 500 pixels,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the map is placed in `<div>`, add a JavaScript script and create
    an OpenLayers `map` object. In the map constructor parameters, you will add an
    empty `controls` array and declare that the map has a Spherical Mercator''s projection,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after the `map` variable is declared, add some OpenLayers controls to
    the map. For the web GIS viewer you are creating, you will add the `Navigation`
    control (which handles map browsing with mouse events, such as dragging, double-clicking,
    and scrolling the wheel), the `PanZoomBar` control (a four-direction navigation
    using the arrows present above the zooming vertical slider), the `LayerSwitcher`
    control (which handles the switching on and off of layers added to the map), and
    the `MousePosition` control (which displays the map coordinates as they change
    while the user is moving the mouse), using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create an OSM base layer, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Set two variables for the WMS GeoServer and the MapServer URL that you will
    use (they are the URLs of the services you created in the first two recipes of
    this chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Linux, add the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, add the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS, add the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a WMS GeoServer layer to display the OpenLayers map the counties
    from the PostGIS layer. You will set an opacity for this layer, so that it is
    possible to see the other layer (counties) behind it. The `isBaseLayer` property
    is set to `false`, since you want to have this layer over the Google Maps base
    layers and not as an alternative to them (by default, all of the WMS layers in
    OpenLayers are considered to be base layers). Create the WMS GeoServer layer,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a WMS MapServer layer to display the countries from the PostGIS
    layer in the OpenLayers map, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the OSM and WMS layers, you need to add all of them to the map,
    using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to provide the user the possibility to identify features of the counties
    WMS. Add the `WMSGetFeatureInfo` OpenLayers control (which will send `GetFeatureInfo`
    requests to the WMS behind the scenes) that points to the counties PostGIS layer
    served by the GeoServer WMS, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set the center of the map and its initial zoom level, using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Your HTML file should now look like the `openlayers.html` file contained in
    `data/chp09`. You can finally deploy this file to your web server (Apache HTTPD
    or IIS). If you are using Apache HTTPD in Linux, you could copy the file to the
    `data` directory under `/var/www`, and if you are using Windows, you could copy
    it to the data directory under `C:\ms4w\Apache\htdocs` (create the `data` directory
    if it does not already exist). Then, access it using the URL `http://localhost/data/openlayers.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, access the `openlayers` web page using your favorite browser. Start browsing
    the map: zoom, pan, try to switch the base and overlays layers on and off using
    the layer switcher control, and try to click on a point to identify one feature
    from the counties PostGIS layer. A map is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85867693-84b9-4bb5-a267-ea322c71b098.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to create a web map viewer with the *OpenLayers* JavaScript
    library. This library lets the developer define the various map components, using
    JavaScript in an HTML page. The core object is a map that is composed of *controls*
    and *layers*.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers comes with a great number of controls ([http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html](http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html)),
    and it is even possible to create custom ones.
  prefs: []
  type: TYPE_NORMAL
- en: Another great OpenLayers feature is the ability to add a good number of geographic
    data sources as layers in the map (you added just a couple of its types to the
    map, such as OpenStreetMap and WMS) and you could add sources, such as WFS, GML,
    KML, GeoRSS, OSM data, ArcGIS Rest, TMS, WMTS, and WorldWind, just to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WMS services with Leaflet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you have seen how to create a webGIS using the OpenLayers
    JavaScript API and then added the WMS PostGIS layers served from MapServer and
    GeoServer .
  prefs: []
  type: TYPE_NORMAL
- en: A lighter alternative to the widespread OpenLayers JavaScript API was created,
    named **Leaflet**. In this recipe, you will see how to use this JavaScript API
    to create a webGIS, add a WMS layer from PostGIS to this map, and implement an
    *identify tool,* sending a `GetFeatureInfo` request to the MapServer WMS. However,
    unlike OpenLayers, Leaflet does not come with a `WMSGetFeatureInfo` control, so
    we will see in this recipe how to create this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new HTML file and name it `leaflet.html` (available in the book source
    code package). Open it and add the `<head>` and `<body>` tags. In the `<head>`
    section, import the Leaflet CSS and JavaScript libraries and the jQuery JavaScript
    library (you will use jQuery to send an AJAX request to the `GetFeatureInfo` from
    the MapServer WMS):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start adding a `<div>` tag in the `<body>` element to include the Leaflet map
    in your file, as shown in the following code; the map will have a width of 800
    pixels and a height of 500 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `<div>` element containing the map, add the following JavaScript
    code. Create a Leaflet `tileLayer` object using the `tile.osm.org` service based
    on `OpenStreetMap` data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a second layer that will use the MapServer WMS you created a few recipes
    ago in this chapter. You will need to set the `ms_url` variable differently if
    you''re using Linux, Windows, or macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Linux, use the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, use the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS, use the following code:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Leaflet `map` and add layers to it, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, associate the mouse-click event with a function that will perform the
    `GetFeatureInfo` WMS request on the `countries` layer, by executing the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Your HTML file should now look like the `leaflet.html` file contained in `data/chp09`.
    You can now deploy this file to your web server (that is, Apache HTTPD or IIS).
    If you are using Apache HTTPD in Linux, you could copy the file to the `/var/www/data
    directory`; if you are running macOS, copy it to `/Library/WebServer/Documents/data` ;and
    if you are using Windows, you could copy it to `C:\ms4w\Apache\htdocs\data` (create
    the data directory if it does not already exist). Then, access it with the URL
    `http://localhost/data/leaflet.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web page using your favorite browser, and start navigating the map;
    zoom, pan, and try to click on a point to identify one feature from the `countries`
    PostGIS layer, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8a53d0f-03f9-4596-a63c-8a45d3ed0927.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how to use the Leaflet JavaScript API library
    to add a map in an HTML page. First, you created one layer from an external server
    to use as the base map. Then, you created another layer using the MapServer WMS
    you implemented in a previous recipe to expose a PostGIS layer to the web. Then,
    you created a new map object and added it to these two layers. Finally, using
    jQuery, you implemented an AJAX call to the `GetFeatureInfo` WMS request and displayed
    the results in a Leaflet `Popup` object.
  prefs: []
  type: TYPE_NORMAL
- en: Leaflet is a very nice and compact alternative to the OpenLayers library and
    gives very good results when your webGIS service needs to be used from mobile
    devices, such as tablets and smart phones. Additionally, it has a plethora of
    plugins and can be easily integrated with JavaScript libraries, such as Raphael
    and JS3D.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WFS-T services with OpenLayers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will create the **Transactional Web Feature Service** (**WFS-T**)
    from a PostGIS layer with the GeoServer open source web-mapping engine and then
    an OpenLayers basic application that will be able to use this service.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the user of the application will be able to manage transactions on
    the remote PostGIS layer. WFS-T allows for the creation, deletion, and updating
    of features. In this recipe, you will allow the user to only to add features,
    but this recipe should put you on your way to creating more composite use cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to GeoServer and OpenLayers, you should first read the *Creating
    WMS and WFS services with GeoServer* and *Consuming WMS services with OpenLayers*
    recipes and then return to this one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create the proxy script and deploy it to your web server (that is, HTTPD or
    IIS), as indicated in the *Getting ready* section of the *Consuming WMS services
    with OpenLayers* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following PostGIS points layer named `sites`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now create a PostGIS layer in GeoServer for the `chp09.sites` table. For more
    information on this, refer to the *Creating WMS and WFS services with GeoServer*
    recipe in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `wfst.html`. Open it and add the `<head>` and `<body>`
    tags. In the `<head>` tag, import the following `OpenLayers` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `<div>` tag in the `<body>` tag to contain the OpenLayers map, as shown
    in the following code; the map will have a width of 700 pixels and a height of
    400 pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just after the `<div>` tag is made to contain the map, add a JavaScript script.
    Inside the script, start setting `ProxyHost` to the web location where you deployed
    your proxy script. Then create a new OpenLayers map, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the script, after creating the map, create an `OpenStreetMap` layer
    that you will use in the map as the base layer, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the WFS-T layer''s `OpenLayers` object using the `StyleMap` object
    to render the PostGIS layer features with red points, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the WFS layer to the map, center align the map, and set the initial zoom.
    You can use the `geometry` transform method to convert a point from `EPSG:4326`,
    in which the layer is stored, to `ESPG:900913`, which is used by the viewer, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will create a panel with a *Draw Point* tool (to add new features)
    and a *Save Features* tool (to save the features to the underlying WFS-T). We
    first create the panel, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the *Draw Point* tool, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will create the *Save Features* tool, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the tools to the panel, including a navigation control, and the
    panel as a control to the map, using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Your HTML file should now look like the `wfst.html` file contained in the `chp09`
    directory. Deploy this file to your web server (that is, Apache HTTPD or IIS).
    If you are using Apache HTTPD in Linux, you could copy the file to the `data`
    directory under `/var/www`, whereas if you are using Windows, you could copy it
    to the data directory under `C:\ms4w\Apache\htdocs` (create the `data` directory
    if it does not already exist). Then, access it using `http://localhost/data/wfst.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web page using your favorite browser and start adding some points
    to the map. Now, click on the Save button and reload the page; the previously
    added points should still be there, as they had been stored in the underlying
    `PostGIS` table by WFS-T, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abea301e-c5df-4a8b-8187-b7265c629b58.png)'
  prefs: []
  type: TYPE_IMG
- en: Added points using OpenLayers controls viewed on a browser
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you first created a point `PostGIS` table and then published
    it as WFS-T, using GeoServer. You then created a basic OpenLayers application,
    using the WFS-T layer, allowing the user to add features to the underlying PostGIS
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenLayers, the core object needed to implement such a service is the vector
    layer by defining a WFS protocol. When defining the WFS protocol, you have to
    provide the WFS version that is using the spatial reference system of the dataset,
    the URI of the service, the name of the layer (for GeoServer, the name is a combination
    of the layer workspace, `FeaturePrefix`, and the layer name, `FeatureType`), and
    the name of the `geometry` field that will be modified. You also can pass to the
    Vector layer constructor a `StyleMap` value to define the layer's rendering behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You then tested the application by adding some points to the OpenLayers map
    and checked that those points were effectively stored in PostGIS. When adding
    the points using the WFS-T layer, with the help of tools such as Firefox Firebug
    or Chrome (Chromium) Developer Tools, you could dig in detail into the requests
    that you are making to the WFS-T and its responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when adding a point, you will see that an `Insert` request is
    sent to WFS-T. The following XML is sent to the service (note how the point geometry
    is inserted in the body of the `<wfs:Insert>` element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<wfs:TransactionResponse>` response, as shown in the following code, will
    be sent from WFS-T if the process has transpired smoothly and the features have
    been stored (note that the `<wfs:totalInserted>` element value in this case is
    set to `1`, as only one feature was stored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Developing web applications with GeoDjango – part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe and the next, you will use the **Django** web framework to create
    a web application to manage wildlife sightings using a PostGIS data store. In
    this recipe, you will build the back office of the web application, based on the
    Django admin site.
  prefs: []
  type: TYPE_NORMAL
- en: Upon accessing the back office, an administrative user will be able to, after
    authentication, manage (insert, update, and delete) the main entities (animals
    and sightings) of the database. In the next part of the recipe, you will build
    a front office that displays the sightings on a map based on the **Leaflet** JavaScript
    library.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a copy of the whole project that you are going to build in the
    code bundle under `chp09/wildlife`. Refer to it if a concept is not clear or if
    you want to copy and paste the code as you go through the steps of the recipe,
    rather than typing code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Django, check out the official Django tutorial at [https://docs.djangoproject.com/en/dev/intro/tutorial01/](https://docs.djangoproject.com/en/dev/intro/tutorial01/)
    and then return to this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Python *virtualenv* ([http://www.virtualenv.org/en/latest/](http://www.virtualenv.org/en/latest/))
    to create an isolated Python environment to use with the web application you will
    build in this recipe and the next. Then, activate the environment as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following commands in Linux:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Type the following commands in Windows (for steps to install `virtualenv` on
    Windows, refer to [https://zignar.net/2012/06/17/install-python-on-windows/](https://zignar.net/2012/06/17/install-python-on-windows/)):'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Once activated, you can install the Python packages that you will use for this
    recipe as well as the next, using the `pip` tool ([http://www.pip-installer.org/en/latest/](http://www.pip-installer.org/en/latest/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Linux, the command would be as follows:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, the command would be as follows:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't done it so far, download the world countries shapefile from [http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip](http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip).
    A copy of this shapefile is included in the code bundle of this book. Extract
    the shapefile to the `working/chp09` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Django project using the `django-admin` command with the `startproject`
    option. Name the project `wildlife`. The command for creating the project will
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Django application using the `django-admin` command with the `startapp`
    option. Name the application `sightings`. The command will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should have the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13f78c11-6d72-4453-8a85-771f9cb472cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will need to edit some files. Open your favorite editor (**Sublime Text**
    does the job) and go to the settings in the `settings.py` file in the code bundle
    under `chp09/wildlife/wildlife`. First, the `DATABASES` settings should be as
    shown in the following code, in order to use the `postgis_cookbook` PostGIS database
    for your application data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following two lines of code at the top of the `wildlife/settings.py`
    file (`PROJECT_PATH` is the variable in which you will enter the project''s path
    in the settings menu):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that in the `settings.py` file under `chp09/wildlife/wildlife`, `MEDIA_ROOT`,
    and `MEDIA_URL` are correctly set, as shown the following code (this is to set
    the media files'' path and URLs for the images that the administrative user will
    upload):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the `INSTALLED_APPS` setting looks as shown in the following
    code in the `settings.py` file. You will use the Django admin site (`django.contrib.admin`),
    the GeoDjango core library (`django.contrib.gis`), and the sightings application
    you are creating in this recipe and the next. For this purpose, add the last three
    lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, synchronize the database using the Django `migrations` management commands.
    When prompted to create a *superuser*, answer `yes` and choose a preferred administrative
    username and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you will add the models needed by the application. Edit the `models.py`
    file under `chp09/wildlife/sightings` and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Each model will become a table in the database with the corresponding fields
    defined using the `models` and `gismodels` class. Note that the `geometry` variable
    in the `county` and `sighting` layers will become the `MultiPolygon` and `Point`
    PostGIS geometry columns, thanks to the GeoDjango library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `admin.py` file under `chp09/wildlife/sightings` and add the following
    code to it. The classes in this file will define and customize the behavior of
    the Django admin site when browsing the application models or tables (fields to
    display, fields to be used to filter records, and fields to order records). Create
    the file by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to synchronize the database, execute the following commands in the Django
    project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6bc8f8-9be1-40b2-b90f-4a246c4bda3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, for each model in `models.py`, a PostgreSQL table should have been created.
    Check whether your PostgreSQL database effectively contains the three tables created
    in the preceding commands using your favorite client (that is, `psql` or `pgAdmin`)
    and whether or not the `sightings_sighting` and `sightings_country` tables contain
    PostGIS geometric fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any web application needs the definition of URLs where the pages can be accessed.
    Therefore, edit your `urls.py` file under `chp09/wildlife/wildlife` by adding
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `urls.py` file, you basically defined the location of the back office
    (which was built using the Django admin application) and the media (images) files''
    location uploaded by the Django administrator when adding new animal entities
    in the database. Now run the Django development server, using the following `runserver`
    management command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Access the Django admin site at `http://localhost:8000/admin/` and log in with
    the superuser credentials you furnished in an earlier step in this recipe (*step
    7*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, navigate to `http://localhost:8000/admin/sightings/animal/` and add some
    animals using the Add animal button. For each animal, define a name and an image
    that will be used by the frontend that you will build in the next recipe. You
    created this page with almost no code, thanks to the Django admin! The following
    screenshot shows what the Animals list page will look like after adding some entities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57846f01-681a-4a75-b4f7-d3d22e44efab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to `http://localhost:8000/admin/sightings/sighting/` and add some
    sightings using the Add sighting button. For each sighting, define the Date, Time,
    the name of the animal that was spotted, Rate, and the location. GeoDjango has
    added the map widget to the Django Admin site for you, based on the OpenLayers
    JavaScript library, to add or modify geometric features. The Sightings page is
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8f11d04-1b65-4d87-a88d-9474a4ab206c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Sightings list page, thanks to the Django admin''s efficiency, will provide
    the administrative user with useful features to sort, filter, and navigate the
    date hierarchy of all of the sightings in the system, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/faf66318-a650-40a0-9434-b1a6bb618a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you will import the `countries` shapefile to its model. In the next recipe,
    you will use this model to find the country where each sighting occurred. Before
    going ahead in this recipe, investigate the shapefile structure; you will need
    to import just the `NAME` and `ISO2` attributes to the model as the `name` and
    `isocode` attributes, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '****![](img/9f3be64f-4aa1-4522-9dee-479df76c3b7f.png)****'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `load_countries.py` file under `chp09/wildlife/sightings` and import
    the shapefile to PostGIS, using the `LayerMapping` GeoDjango utility, using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have the `TM_WORLD_BORDERS-0.3.shp` file placed under `chp09/wildlife`
    for this code to work. Enter the Python Django shell and run the `utils.py` script.
    Then, check whether the countries have been correctly inserted in the `sightings_country`
    table in your PostgreSQL database, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the countries in the administrative interface at `http://localhost:8000/admin/sightings/country/`,
    while running the Django server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**![](img/be44025b-b8a3-48cc-aec5-d67ba8ff1dbe.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how quick and efficient it is to assemble a back
    office application using **Django**, one of the most popular Python web frameworks;
    this is thanks to its object-relational mapper, which automatically created the
    database tables needed by your application and an automatic API to manage (insert,
    update, and delete) and query the entities without using SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the **GeoDjango** library, two of the application models, County and
    Sighting, have been geo-enabled with their introduction in the database tables
    of `geometric` PostGIS fields.
  prefs: []
  type: TYPE_NORMAL
- en: You have customized the powerful **automatic administrative interface** to quickly
    assemble the back-office pages of your application. Using the **Django URL Dispatcher**,
    you have defined the URL routes for your application in a concise manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, what is extremely nice about the Django abstraction
    is the automatic implementation of the data-access layer API using the models.
    You can now add, update, delete, and query records using Python code, without
    having any knowledge of SQL. Try this yourself, using the Django Python shell;
    you will select an animal from the database, add a new sighting for that animal,
    and then finally delete the sighting. You can investigate the SQL generated by
    Django, behind the scenes, any time, using the `django.db`.connection class with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Do you like Django as much as we do? In the next recipe, you will create the
    frontend of the application. The user will be able to browse the sightings in
    a map, implemented with the Leaflet JavaScript library. So keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will create the front office for the web application you
    created using **Django** in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML and the **Django template language**, you will create a web page
    displaying a map, implemented with Leaflet, and a list for the user containing
    all of the sightings available in the system. The user will be able to navigate
    the map and identify the sightings to get more information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have gone through every single step of the previous recipe and
    have kept the back office of the web application working and its database populated
    with some entities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activate the `virtualenv` you created in the *Developing web applications with
    GeoDjango –Part 1)* recipe, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Linux:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command for Windows:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the libraries that you will use in this recipe; you will need the `simplejson`
    and `vectorformats` Python libraries to produce a GeoJSON ([http://www.geojson.org/](http://www.geojson.org/))
    response that will feed the sighting layer in Leaflet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Linux:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command for Windows:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will now create the front page of your web application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the directory containing the Django wildlife web application and add
    the following lines to the `urls.py` file under `chp09/wildlife/wildlife`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `views.py` file under `chp09/wildlife/sightings` and add the following
    code. The `home` view will return the home page of your application, with the
    list of sightings and the Leaflet map. The `sighting` layer in the map will display
    the GeoJSON response given by the `get_geojson` view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `@property` definitions to the `Sighting` class in the `models.py`
    file under `chp09/wildlife/sightings`. The `get_geojson` view will need to use
    these properties to compose the GeoJSON view needed from the Leaflet map and the
    information popup. Note how in the `country_name` property, you are using GeoDjango,
    which contains a spatial lookup `QuerySet` operator to detect the country where
    the sighting happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `home.html` file, containing the following code, under `sightings/templates/sightings`.
    Using the Django template language, you will display the number of sightings in
    the system, a list of these sightings with the main information for each of them,
    and the Leaflet map. Using the Leaflet JavaScript API, you add a base OpenStreetMap
    layer to the map. Then, you make an asynchronous call, using jQuery, to the `get_geojson`
    view (accessed by adding `/geojson` to the request URL). If the query is successful,
    it will feed a Leaflet GeoJSON layer with the features from the sighting PostGIS
    layer and associate with each feature an informative popup. This popup will open
    any time the user clicks on a point on the map representing a sighting, displaying
    the main information for that entity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that your frontend page is completed, you can finally access it at `http://localhost:8000/`.
    Navigate the map and try to identify some of the displayed sightings to check
    whether the popup opens, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29b9fe1f-aa0b-47a1-82ce-ddc3da0b476c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created an HTML front page for the web application you developed in the
    previous recipe. The HTML is dynamically created using the Django template language
    ([https://docs.djangoproject.com/en/dev/topics/templates/](https://docs.djangoproject.com/en/dev/topics/templates/))
    and the map was implemented with the Leaflet JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: The Django template language uses the response from the home view to generate
    a list of all of the sightings in the system.
  prefs: []
  type: TYPE_NORMAL
- en: The map was created using Leaflet. First, an OpenStreetMap layer was used as
    a base map. Then, using jQuery, you fed a GeoJSON layer that displays all of the
    features generated by the `get_geojson` view. You associated a popup with the
    layer that opens every time the user clicks on a sighting entity. The popup displays
    the main information for that sighting, including a picture of the sighted animal.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a web GPX viewer with Mapbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the way points dataset from [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml),
    *Working with Vector Data – The Basics*. Refer to the script in the recipe named
    *Working with GPS data* to learn how to import `.gpx` files tracks into PostGIS.
    You will also need a Mapbox token; for this, go to their site ([https://www.mapbox.com](https://www.mapbox.com))
    and sign up for one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare the data for Mapbox''s GeoJSON format, export the table tracks from
    [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml), *Working with Vector
    Data – The Basics* using `ogr2ogr` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `crs` definition line on the new `.json` with your favorite editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44c050ce-b50e-4725-96c5-cea5247a64c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to your Mapbox account and upload in the Datasets menu the `tracks.json`
    file. After a successful upload, you will see the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93df2e72-9f49-495c-a719-308c9219b476.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the dataset and export it to a tileset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f8d5f46a-768a-439a-97f6-a552775ec5aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, create a new style with the outdoors template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/50901ea0-7a5d-492c-8229-dc9cf0a9ca66.png)'
  prefs: []
  type: TYPE_IMG
- en: Add the tracks layer and publish it. Note the style URL that you can use to
    share or further develop your map; copy it to use it in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we are ready to create a mapbox.html file; add the following in the head
    section to use Mapbox JS and CSS libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a `map` with your token and the style we''ve just created in the body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, you can double-click and open the HTML with your favorite browser
    and the Mapbox API will serve your map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b21495be-2867-4e35-87f6-48be916877f6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To quickly publish and visualize data in a webGIS, you can use the Mapbox API
    to create beautiful maps with your own data; you will have to keep a GeoJSON format
    and not exceed the offered bandwidth capacity. In this recipe, you've learned
    how to export your PostGIS data to publish it in Mapbox as a JS.
  prefs: []
  type: TYPE_NORMAL
