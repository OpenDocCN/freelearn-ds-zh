- en: PostGIS and the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with MapServer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with GeoServer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WMS Time service with MapServer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WMS services with OpenLayers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WMS services with Leaflet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming WFS-T services with OpenLayers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 1
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 2
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a web GPX viewer with Mapbox
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to give you an overview of how you can use PostGIS
    to develop powerful GIS web applications, using **Open Geospatial Consortium**
    (**OGC**) web standards such as **Web Map Service** (**WMS**) and **Web Feature
    Service** (**WFS**).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In the first two recipes, you will get an overview of two very popular open
    source web-mapping engines, **MapServer** and **GeoServer**. In both these recipes,
    you will see how to implement WMS and WFS services using PostGIS layers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In the third recipe, you will implement a **WMS Time** service using MapServer
    to expose time-series data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In the next two recipes, you will learn how to consume these web services to
    create web map viewers with two very popular JavaScript clients. In the fourth
    recipe, you will use a WMS service with **OpenLayers**, while in the fifth recipe,
    you will do the same thing using **Leaflet**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In the sixth recipe, you will explore the power of transactional WFS to create
    web-mapping applications to enable editing data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In the next two recipes, you will unleash the power of the popular **Django**
    web framework, which is based on Python, and its nice **GeoDjango** library, and
    see how it is possible to implement a powerful **CRUD** GIS web application. In
    the seventh recipe, you will create the back office for this application using
    the Django Admin site, and in the last recipe of the chapter, you will develop
    a frontend for users to display data from the application in a web map based on
    Leaflet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the last recipe, you will learn how to import your PostGIS data
    into Mapbox using **OGR** to create a custom web GPX viewer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with MapServer
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will see how to create a WMS and WFS from a PostGIS layer,
    using the popular MapServer open source web-mapping engine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: You will then use the services, testing their exposed requests, using first
    a browser and then a desktop tool such as QGIS (you could do this using other
    software, such as uDig, gvSIG, and OpenJUMP GIS).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps before getting ready:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a schema for this chapter within the `postgis_cookbook` database using
    the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be sure to have Apache HTTP installed (MapServer will run on it as a CGI) and
    check whether it is working by visiting its home page at `http://localhost` (typically,
    an `It works!` message will be displayed if you still have not customized any
    features).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install MapServer as per its installation guide ([http://mapserver.org/installation/index.html](http://mapserver.org/installation/index.html)).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A handy way to have MapServer up and running in Apache for Windows is to install
    the OSGeo4W ([http://trac.osgeo.org/osgeo4w/](http://trac.osgeo.org/osgeo4w/))
    or MS4W ([http://www.maptools.org/ms4w/](http://www.maptools.org/ms4w/)) packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For Linux, there are packages for almost any kind of distribution.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, you can use again the CMake app to build the installation or use
    Homebrew with the following command (note the flags needed to compile it with
    Postgres support):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`brew install mapserver --with-postgresql --with-geos`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Check whether MapServer has been installed correctly and has `POSTGIS`, `WMS_SERVER`,
    and `WFS_SERVER` support enabled, by running it as a command-line tool with the
    `-v` option.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On Linux, run the `$ /usr/lib/cgi-bin/mapserv -v` command and check for the
    following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Windows, run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On macOS, use the `$ mapserv -v` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9605c5be-1509-4b2b-814f-cbaa205e7f41.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Now check whether MapServer is working from within HTTPD, using `http://localhost/cgi-bin/mapserv`
    (`http://localhost/cgi-bin/mapserv.exe` for Windows). If you get a `No query information
    to decode. QUERY_STRING is set, but empty` response message, MapServer is correctly
    working as a CGI script in Apache and is ready to accept HTTP requests.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the world countries shapefile from [http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip](http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip).
    A copy of this shapefile is included in the book dataset for [Chapter 1](38f20dd1-ca55-47e8-80cd-21670bcb32b2.xhtml),
    *Moving Data In and Out of PostGIS*. Extract the shapefile to the `working/chp09`
    directory and import it in PostGIS using the **shp2pgsql** tool (be sure to specify
    the spatial reference system, *EPSG:4326*, with the `-s` option), as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'MapServer exposes its map services using `mapfile`, a text file format, with
    which it is possible to define the PostGIS layers on the web, enable any vector
    and raster format supported by GDAL, and specify which services (WMS/WFS/WCS)
    to expose per layer. Create a new text file named `countries.map` and add the
    following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save the file we just created in a location that is accessible to the Apache
    user. For example, in Debian, it is `/var/www/data`, while in Windows, it can
    be `C:\ms4w\Apache\htdocs`; for macOS, you should use `/Library/WebServer/Documents`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure that both the file and the directory containing it are accessible to
    the Apache user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `template.html` in the same location as the `mapfile` and
    enter the following code in it (this file is used by the `GetFeatureInfo` WMS
    request to output an HTML response to the client):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the `mapfile` you just created, you exposed the `countries` PostGIS layer,
    both as a WMS and WFS service. Both of these services expose to the user a series
    of requests and you will now test them using a browser. First, without invoking
    any services, test whether the `mapfile` is working correctly by typing the following
    URL in the browser:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&layer=countries&mode=map`
    (for Linux)'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdocs\countries.map&layer=countries&mode=map`
    (for Windows)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&layer=countries&mode=map`
    [(for macOS)](http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/countries.map&layer=countries&mode=map)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should see the `countries` layer rendered with the three symbology classes
    defined in the `mapfile`, as shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3f45c7a-ea25-4f2e-8ebd-c67a78a640d4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a small difference between the URLs used in Windows,
    Linux, and macOS. We will refer to Linux from now on, but you can easily adapt
    the URLs to Windows or macOS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you will start testing the WMS service; you will try running the `GetCapabilities`,
    `GetMap`, and `GetFeatureInfo` requests. To test the `GetCapabilities` request,
    type the URL in the browser: `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities`.
    You should receive a long XML response (as follows) from the server, where the
    more important fragments are the WMS service definitions in the `<Service>` section,
    the requests are enabled in the `<Capability>` section, and the layers exposed
    and their main details (for example, name, abstract, projection, and extent) are
    in the `<Layer>` section of each of the layers:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now test the WMS service with its typical `GetMap` WMS request, used on many
    clients to display a map to the user. Type the URL `http://localhost//cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-26,-111,36,-38&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=countries&STYLES=&FORMAT=image/png`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Into the browser and check the image that is sent back in response by the MapServer
    `GetMap` request, as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45ee2c30-3a5b-4464-b702-215b62607c43.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Another typical WMS request is `GetFeatureInfo`, used by clients to query the
    map layer at the given coordinates (points). Type the following URL and you should
    see the field values for a given feature as the output (the output is built using
    the `template.html` file):'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should be as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bf9f74b-7418-4290-9160-1652f97e6b55.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Now, you will use QGIS to use the WMS service. Launch QGIS, click on the Add
    WMS layer button (alternatively, navigate to Layer | Add WMS Layer or use the
    QGIS browser), and create a new WMS connection, as shown in the following screenshot.
    Type something such as `MapServer on localhost` in the Name field and `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetCapabilities`
    in the URL field, and click on the OK button (remember to adjust the Apache URL
    according to the configuration of your OS; check step 4):'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/641af38a-fedf-49ae-b089-371abd584fe3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'Now click on the Connect button, as shown in the following screenshot. Then,
    select the countries layer and add it to the QGIS map window using the Add button,
    making sure to select the coordinate system EPSG:4326:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06b1e728-cc8e-45e9-8820-3bb239f38d5a.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Now browse to your WMS countries layer and try to perform some identification
    operations. QGIS will raise the needed `GetMap` and `GetFeatureInfo` WMS requests
    for you behind the scenes to give the following output:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33ad34f9-2943-40dc-8188-b3e8ab039c41.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Having seen how the WMS service works, you will now start using WFS. Like WMS,
    WFS offers the user a `GetCapabilities` request as well, resulting in a similar
    output to the `GetCapabilities` request of WMS. Type the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=GetCapabilities`
    into the browser window to inspect the XML response.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main WFS request is `GetFeature`. It lets you query the map layer using
    several criteria, returning a collection of features in response as **Geography
    Markup Language** (**GML**) output. Test the request by typing this URL in the
    browser: `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=getfeature&TYPENAME=countries&MAXFEATURES=5`.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get an XML (GML) response from the browser, as shown in the following
    code, with a `<wfs:FeatureCollection>` element composed of five `<gml:featureMember>`
    elements (as indicated in the `MAXFEATURES` parameter of the request), each representing
    one country. For each feature, the WFS returns the geometry and all of the field
    values (this behavior was specified by setting the `gml_include_items` variable
    in the `METADATA` layer directive in the `mapfile`). You will see a geometry as
    follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a result of the WFS `GetFeature` request executed in the previous step, MapServer
    has returned only the first five features of the `countries` layers. Now, use
    the `GetFeature` request to make a query to the layer using a filter and get back
    the corresponding features. By typing the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/countries.map&SERVICE=WFS&VERSION=1.0.0&REQUEST=getfeature&TYPENAME=countries&MAXFEATURES=5&Filter=<Filter>
    <PropertyIsEqualTo><PropertyName>name</PropertyName> <Literal>Italy</Literal></PropertyIsEqualTo></Filter>`,
    you will get the feature in the database that has the `name` field set to `Italy`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After testing the WFS requests in a browser, try to open the WFS service in
    QGIS using the Add WFS Layer button (alternatively, navigate to Layer | Add WFS
    Layer or use the QGIS browser). You should see the same MapServer on Localhost
    connection you created a few steps earlier. Click on the Connect button and select
    the countries layer, add it to the QGIS project, and browse through it by zooming,
    panning, and identifying some features. The biggest difference when compared to
    WMS is that, with WFS, you receive the feature geometries from the server and
    not just an image, so you can even export the layer to a different format, such
    as a shapefile or spatialite! The Add WFS layer from a Server window is as shown
    in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b33d2e02-85a1-4451-9fed-b784d1b40722.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'You should now be able to see the vector map in QGIS and inspect the features:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1a28131-5c43-4291-8664-9b3c5a6019b3.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you implemented WMS and WFS services for a PostGIS layer using
    the MapServer open source web-mapping engine. WMS and WFS are the two core concepts
    to consider when you want to develop a web GIS that is interoperable across many
    organizations. **Open Geospatial Consortium** (**OGC**) defined these two standards
    (and many others) to make web-mapping services exposed in an open, standard way.
    This way these services can be used by different applications; for example, you
    have seen in this recipe that a GIS Desktop tool such as QGIS can browse and query
    those services because it understands these OGC standards (you can get exactly
    the same results with other tools, such as gvSIG, uDig, OpenJUMP, and ArcGIS Desktop,
    among others). In the same way, Javascript API libraries, most notably OpenLayers
    and Leaflet (you will be using these in the other recipes in this chapter), can
    use these services in a standard way to provide web-mapping features to web applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'WMS is a service that is used to generate the maps to be displayed by clients.
    Those maps are generated using image formats, such as PNG, JPEG, and many others.
    Some of the most typical WMS requests are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCapabilities`: This offers an overview of the services offered by WMS,
    particularly a list of the available layers and some of the details of each layer
    (layer extent, coordinate reference systems, URI of the data, and so on).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMap`: This returns a map image representing one or more layers for a specified
    extent and spatial reference, in a specified image file format and size.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFeatureInfo`: This is an optional request by WMS that returns, in different
    formats, the attribute values for the features of a given point in the map. You
    have seen how to customize the response by introducing a template file that must
    be set in the `mapfile`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WFS provides a convenient, standard way to access the features of a vector layer
    with a web request. The service response streams to the client the requested features
    using GML (an XML markup defined by OGC to define geographical features).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Some WFS requests are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`GetCapabilities`: This gives a description of the services and layers offered
    by the WFS service'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetFeature`: This allows the client to get a set of features of a given layer,
    corresponding to a given criteria'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These WMS and WFS requests can be consumed by the client using the HTTP protocol.
    You have seen how to query and get a response from the client by typing a URL
    in a browser with several parameters appended to it. As an example, the following
    WMS `GetMap` request will return a map image of the layers (using the `LAYERS`
    parameter) in a specified format (using the `FORMAT` parameter), size (using the
    `WIDTH` and `HEIGHT` parameters), extent (using the `BBOX` parameter), and spatial
    reference system (using `CRS`):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In MapServer, you can create WMS and WFS services in the `mapfile` using its
    directives. The `mapfile` is a text file that is composed of several sections
    and is the heart of MapServer. In the beginning of the `mapfile`, it is necessary
    to define general properties for the map, such as its title, extent, spatial reference,
    output-image formats, and dimensions to be returned to the user.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is possible to define which OWS (OGC web services such as WMS, WFS,
    and WCS) requests to expose.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the main section of the `mapfile`, where the layers are defined
    (every layer is defined in the `LAYER` directive). You have seen how to define
    a PostGIS layer. It is necessary to define its connection information (database,
    user, password, and so on), the SQL definition in the database (it is possible
    to use just a PostGIS table name, but you could eventually use a query to define
    the set of features and attributes defining the layer), the geometric type, and
    the projection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A whole directive (`CLASS`) is used to define how the layer features will be
    rendered. You may use different classes, as you did in this recipe, to render
    features differently, based on an attribute defined with the `CLASSITEM` setting.
    In this recipe, you defined three different classes, each representing a population
    class, using different colors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more information about using MapServer by using its extensive documentation
    at its project home page ([http://mapserver.org/it/index.html](http://mapserver.org/it/index.html)).
    You will find the mapfile documentation at [http://www.mapserver.org/mapfile/](http://www.mapserver.org/mapfile/)
    very useful to read.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good tutorial to understand how to generate mapfiles can be found at [http://mapserver.org/tutorial/example1-1.html](http://mapserver.org/tutorial/example1-1.html).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you want to gain a better understanding of the WMS and WFS standards,
    check their specifications at the OGC website. For the WMS service, go to [http://www.opengeospatial.org/standards/wms](http://www.opengeospatial.org/standards/wms),
    whereas for WFS, go to [http://www.opengeospatial.org/standards/wfs](http://www.opengeospatial.org/standards/wfs).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating WMS and WFS services with GeoServer
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you created WMS and WFS from a PostGIS layer using MapServer.
    In this recipe, you will do it using another popular open source web-mapping engine-GeoServer.
    You will then use the created services as you did with MapServer, testing their
    exposed requests, first using a browser and then the QGIS desktop tool (you can
    do this with other software, such as uDig, gvSIG, OpenJUMP GIS, and ArcGIS Desktop).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While MapServer is written in the C language and uses Apache as its web server,
    GeoServer is written in Java and you therefore need to install the **Java Virtual
    Machine** (**JVM**) in your system; it must be used from a servlet container,
    such as *Jetty* and *Tomcat*. After installing the servlet container, you will
    be able to deploy the GeoServer application to it. For example, in Tomcat, you
    can deploy GeoServer by copying the GeoServer **WAR** (**web archive**) file to
    Tomcat''s `webapps` directory. For this recipe, we will suppose that you have
    a working GeoServer in your system; if this is not the case, follow the detailed
    GeoServer installation steps for your OS at the GeoServer website ([http://docs.geoserver.org/stable/en/user/installation/](http://docs.geoserver.org/stable/en/user/installation/))
    and then return to this recipe. Follow these steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the USA counties shapefile from the [https://nationalmap.gov/](https://nationalmap.gov/)
    website at [http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz](http://dds.cr.usgs.gov/pub/data/nationalatlas/countyp020_nt00009.tar.gz)
    (this archive is included in the book''s code bundle). Extract the archive from
    `working/chp09` and import it to PostGIS using the `ogr2ogr` command, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the GeoServer administrative interface, which is typically located at
    `http://localhost:8080/geoserver`, in your favorite browser and log in using your
    credentials (`admin` as the username and `geoserver` as the password) if you are
    just using the GeoServer default installation and have not customized things.
    After starting GeoServer, you should see the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0c14f51e-d987-4f22-b69d-1007285368fc.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: GeoServer welcome screen viewed in a browser
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully logging in, create a workspace by clicking on the Workspace
    link under Work (in the left-hand-side panel of the GeoServer application''s main
    menu) and then click on the Add new workspace link. In the text boxes of the form
    that appears, specify the following values and then click on the Submit button:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Name field
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter the URL [https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook](https://www.packtpub.com/big-data-and-business-intelligence/postgis-cookbook) in
    the Namespace URI field
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to create a PostGIS store, click on the Stores link under Data (in the
    left-hand-side panel of the GeoServer application''s main menu). Now, click on
    the Add new store link, and then on the PostGIS link under Vector Data Sources,
    as shown in the following screenshot:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d9d4876a-99c6-4371-bf25-bd379f7640fc.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: GeoServer screen to configure new data sources
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In the New Vector Data Source page, complete the form''s fields, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select postgis_cookbook from the Workspace drop-down list.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Data Source Name field.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `localhost` in the host field.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `5432` in the port field.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the database field.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `chp09` in the schema field.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `me` in the user field.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `mypassword` in the passwd field.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The New Vector Data Source page is shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86b686de-bf22-4356-86fb-84a3b231b629.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Save button to successfully create your PostGIS store.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you are ready to publish the PostGIS `counties` layer as WMS and WFS. On
    the Layers page, click on the Add a new resource link. Now, select postgis_cookbook
    from the Add layer from drop-down list. Click on the Publish link to the right
    of the `counties` layer.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Edit Layer page, shown in the following screenshot, click on the links
    Compute from data and Compute from native bounds, and then click on the Save button:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1bc14616-fcaf-4d05-a931-8d36b0609e04.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: GeoServer screen to edit the countries layer for publishing
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to define the style used to display the layer to the user. Unlike
    MapServer, GeoServer uses the OGC-standard **Styled Layer Descriptor** (**SLD**)
    notation. Click on the Styles link under Data and then on the Add new style link.
    Fill the text fields in the form, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Counties classified per size` in the Name field.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter `postgis_cookbook` in the Workspace field
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the text area for the SLD, add the following XML code defining the style
    for the `counties` layer. Then, click on the Validate button to check whether
    your SLD definition is correct and then click on the Submit button to save the
    new style:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SLD 的文本区域中，添加以下定义 `counties` 层样式的 XML 代码。然后，点击验证按钮检查您的 SLD 定义是否正确，然后点击提交按钮保存新的样式：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot shows how the new style looks on the New style GeoServer
    page:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了新样式在“新样式 GeoServer”页面上的外观：
- en: '![](img/8ebe49df-a1fc-495d-8c51-ba5b77fa79dc.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ebe49df-a1fc-495d-8c51-ba5b77fa79dc.png)'
- en: GeoServer screen for creating a new style as an SLD document
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GeoServer 创建新样式作为 SLD 文档的屏幕截图
- en: Now you need to associate the created style with the `counties` layer. Go back
    to the layer page (Data | Layers), click on the `counties` layer link, and then,
    on the Edit Layer page, click on the Publishing section. Select Counties classified
    per size in the Default style drop-down list and then click on the Save button.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将创建的样式与 `counties` 层关联起来。返回到层页面（数据 | 层），点击 `counties` 层链接，然后在编辑层页面，点击发布部分。在默认样式下拉列表中选择按大小分类的县，然后点击保存按钮。
- en: Now that your WMS and WFS services for the PostGIS `counties` layer are ready,
    it is time to start using them! First, test the `GetCapabilities` WMS request.
    To do this, you can click on one of the links on the right-hand-side panel on
    the GeoServer web application home page. You can click on the link for either
    WMS version 1.1.1 or WMS version 1.3.0\. Click on one of the links or type the
    `GetCapabilities` request directly in the browser as `http://localhost:8080/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的 PostGIS `counties` 层的 WMS 和 WFS 服务已经准备好了，是时候开始使用它们了！首先，测试 `GetCapabilities`
    WMS 请求。为此，您可以在 GeoServer 网页应用程序主页的右侧面板上点击其中一个链接。您可以点击 WMS 版本 1.1.1 或 WMS 版本 1.3.0
    的链接。点击其中一个链接或直接在浏览器中输入 `GetCapabilities` 请求，格式为 `http://localhost:8080/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities`。
- en: 'Now, we will investigate the `GetCapabilities` response, shown as follows.
    You will find a lot of information about WMS is available on your GeoServer instance,
    such as the WMS-supported requests, projections, and a lot of other information
    about each published layer. In the case of the `counties` layer, the following
    code is an extract from the `GetCapabilities` document. Note the main layer information,
    such as the name, title, abstract (you could redefine all of these using the GeoServer
    web application), the supported **Coordinate Reference Systems** (**CRS**), the
    geographic extent, and the associated style:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将调查以下所示的 `GetCapabilities` 响应。您将发现有关 WMS 的许多信息都可在您的 GeoServer 实例上找到，例如
    WMS 支持的请求、投影以及每个发布的层的大量其他信息。在 `counties` 层的情况下，以下代码是从 `GetCapabilities` 文档中提取的。注意主要层信息，如名称、标题、摘要（您可以使用
    GeoServer 网页应用程序重新定义所有这些），支持的**坐标参考系统**（**CRS**）、地理范围以及关联的样式：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To test the `GetMap` and `GetFeatureInfo` WMS requests, the GeoServer web application
    offers you a very handy way with the Layer Preview page. Navigate to Data | Layer
    Preview and then click on the OpenLayers link next to the `counties` layer. The
    Layer Preview page is based on the OpenLayers JavaScript library and lets you
    experiment with the `GetMap` and `GetFeatureInfo` requests.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试 `GetMap` 和 `GetFeatureInfo` WMS 请求，GeoServer 网页应用程序提供了一个非常方便的方法，即层预览页面。导航到数据
    | 层预览，然后点击 `counties` 层旁边的 OpenLayers 链接。层预览页面基于 OpenLayers JavaScript 库，并允许您对
    `GetMap` 和 `GetFeatureInfo` 请求进行实验。
- en: 'Try to navigate the map; at each zoom and pan action, GeoServer will stream
    out a new image provided by the response output to a `GetMap` request. By clicking
    on the map, you can perform a `GetFeatureInfo` request and the user interface
    will display the feature''s attributes corresponding to the point on the map on
    which you clicked. A very effective way to check how the requests are sent to
    GeoServer as you navigate the map is by using the Firefox Firebug plugin or the
    Chrome (or Chromium if you are using Linux) Developer Tools. With these tools,
    you will be able to identify the `GetMap` and `GetFeatureInfo` requests that are
    being sent behind the scenes from the OpenLayers viewer to GeoServer. One such
    map is shown in the following screenshot:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5af96157-29eb-4046-b8ba-ca8c21ea9618.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Here is what you get when inspecting the requests with any in-browser developer
    tool, check the request URL, and verify the parameters sent to geoserver; this
    is how it looks with Firefox:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/216a52c9-ba61-47a8-8eb9-4d553da53aac.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Now, try a WMS `GetMap` request by typing the URL `http://localhost:8080/geoserver/postgis_cookbook/wms?LAYERS=postgis_cookbook%3Acounties&STYLES=&FORMAT=image%2Fpng&SERVICE=WMS&VERSION=1.1.1&REQUEST=GetMap&SRS=EPSG%3A4326&BBOX=-200.50286594033,7.6152902245522,-43.196688503029,81.457450330258&WIDTH=703&HEIGHT=330`
    in your browser.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try a WMS `GetFeatureInfo` request, as well, by typing the URL `http://localhost:8080/geoserver/postgis_cookbook/wms?REQUEST=GetFeatureInfo&EXCEPTIONS=application%2Fvnd.ogc.se_xml&BBOX=-126.094303%2C37.16812%2C-116.262667%2C41.783255&SERVICE=WMS&INFO_FORMAT=text%2Fhtml&QUERY_LAYERS=postgis_cookbook%3Acounties&FEATURE_COUNT=50&Layers=postgis_cookbook%3Acounties&WIDTH=703&HEIGHT=330&format=image%2Fpng&styles=&srs=EPSG%3A4326&version=1.1.1&x=330&y=158.`
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will be displayed by prompting the previous URL:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f347c04-adad-4a07-acf2-794521794387.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: 'Now, as you did for the MapService WMS, test the GeoServer WMS in QGIS. Create
    a WMS connection named `GeoServer on localhost`, pointing to the GeoServer `GetCapabilities`
    document (`http://localhost:8080/geoserver/ows?service=wms&version=1.3.0&request=GetCapabilities`).
    Then, connect to the WMS server (for example, from the QGIS browser), select `counties`
    from the Layers list, and add it to the map, as shown in the following screenshot;
    then navigate the layer and try to identify some of the features:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9f2dcd78-4399-4edf-ad1c-8e72aa855614.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Having used WMS, try to test a couple of WFS requests. A typical WFS `GetCapability`
    request can be executed by typing the URL `http://localhost:8080/geoserver/wfs?service=wfs&version=1.1.0&request=GetCapabilities`.
    You could also click on one of the WFS links on the home page of the GeoServer
    web interface.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Investigate the XML `GetCapabilities` response and try to identify the information
    about your layer. You should have a `<FeatureType>` element, such as the following,
    corresponding to the `counties` layer:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As shown in the previous recipe, a typical WFS request is `GetFeature`, which
    will result in a GML response. Try it by typing the URL `http://localhost:8080/geoserver/wfs?service=wfs&version=1.0.0&request=GetFeature&typeName=postgis_cookbook:counties&maxFeatures=5`
    in your browser. You will receive a GML output composed of a `<wfs:FeatureCollection>`
    element and a collection of `<gml:featureMember>` elements (possibly five elements,
    as specified in the `maxFeatures` request''s parameter). You will get an output
    that is similar to the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, as you did with WMS, try the counties WFS in QGIS (or in your favorite
    desktop GIS client). Create a new WFS connection by using either the QGIS browser
    or the Add WFS Layer button and then clicking on the New Connection button. In
    the Create a new WFS connection dialog box, type `GeoServer on localhost` in the
    Name field and add the WFS `GetCapabilities` URL (`http://localhost:8080/geoserver/wfs?service=wfs&version=1.1.0&request=GetCapabilities`)
    in the URL field.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the WFS `counties` layer from the previous dialog box and, as a test, select
    some of the counties and export them to a new shapefile using the Save As command
    from the layer''s context menu, as shown in the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/febf1b0e-d10c-4b74-83b0-f53424461ea6.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you were introduced to the basic concepts of the OGC
    WMS and WFS standards using MapServer. In this recipe, you have done the same
    using another popular open source web-mapping engine, GeoServer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Unlike MapServer, which is written in C and can be used from web servers such
    as Apache HTTP (HTTPD) or Microsoft **Internet Information Server** (**IIS**)
    as a CGI program, GeoServer is written in Java and needs a servlet container such
    as Apache Tomcat or Eclipse Jetty to work.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: GeoServer not only offers the user a highly scalable and standard web-mapping
    engine implementation, but does so with a nice user interface, the Web Administration
    interface. Therefore, it is generally easier for a beginner to create WMS and
    WFS services compared to MapServer, where it is necessary to master the mapfile
    syntax.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The GeoServer workflow to create WMS and WFS services for a PostGIS layer is
    to first create a PostGIS store, where you need to associate the main PostGIS
    connection parameters (server name, schema, user, and so on). After the store
    is correctly created, you can publish the layers that are available for that PostGIS
    store. You have seen in this recipe how easy the whole process is using the GeoServer
    Web Administration interface.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: To define the layer style to render features, GeoServer uses the SLD schema,
    an OGC standard based on XML. We have written two distinct rules in this recipe
    to render the counties that have an area greater than 5,000 square miles an area
    greater than 5,000 square miles in a different way from the others. For the purpose
    of rendering the counties in a different way, we have used two `<ogc:Rule>` SLD
    elements in which you have defined an `<ogc:Filter>` element. For each of these
    elements, you have defined the criteria to filter the layer features, using the
    `<ogc:PropertyIsGreaterThanOrEqualTo>` and `<ogc:PropertyIsLessThan>` elements.
    A very handy way to generate an SLD for a layer is using desktop GIS tools that
    are able to export an SLD file for a layer (QGIS can do this). After exporting
    the file, you can upload it to GeoServer by copying the SLD file content to the
    Add a new style page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Having created the WMS and WFS services for the counties layer, you have been
    testing them by generating the requests using the handy Layer Preview GeoServer
    interface (based on OpenLayers) and then typing the requests directly in a browser.
    You can modify each service request's parameters from the Layer Preview interface
    or just by changing them in the URL query string.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you tested the services using QGIS and have seen how it is possible
    to export some of the layer's features using the WFS service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want more information about GeoServer, you can check out its excellent
    documentation at [http://docs.geoserver.org/](http://docs.geoserver.org/) or get
    the wonderful *GeoServer Beginner's Guide* book by Packt Publishing ([http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book](http://www.packtpub.com/geoserver-share-edit-geospatial-data-beginners-guide/book)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Creating a WMS Time service with MapServer
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will implement a WMS Time with MapServer. For time-series
    data, and whenever you have geographic data that is updated continuously and you
    need to expose it as a WMS in a Web GIS, WMS Time is the way to go. This is possible
    by providing the `TIME` parameter a time value in the WMS requests, typically
    in the `GetMap` request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will implement a WMS Time service for the hotspots, representing possible
    fire data acquired by NASA's **Earth Observing System Data and Information System**
    (**EOSDIS**). This excellent system provides data derived from MODIS images from
    the last 24 hours, 48 hours, and 7 days, which can be downloaded in shapefile,
    KML, WMS, or text file formats. You will load a bunch of this data to PostGIS,
    create a WMS Time service with MapServer, and test the WMS `GetCapabilities` and
    `GetMap` requests using a common browser.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to the WMS standard, please check the previous two recipes to
    get more information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, download one week's worth of active fire data (hotspots) from the EOSDIS
    website. For example, Firedata from EOSDIS can be found in this link: [https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data](https://earthdata.nasa.gov/earth-observation-data/near-real-time/firms/active-fire-data).
    A copy of this shapefile is included in the book code bundle. Use that if you
    want to use the SQL and WMS parameters that have been used in the following steps.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the shapefile from the `Global_7d.zip` archive to the `working/chp09`
    directory and import this shapefile in PostGIS using the `shp2pgsql` command,
    as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the import is completed, check the point fire data (hotspots) you just
    imported in PostGIS. Each hotspot contains a bunch of useful information, most
    notably the geometry and the acquisition date and time stored in the `acq_date`
    and `acq_time` fields. You can easily see that the features loaded from the shapefile
    span eight consecutive days using the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous command will produce the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4076998-8aa8-4191-a0e4-d675f64a9e67.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create a WMS for the PostGIS hotspot layer. Create a `mapfile`
    named `hotspots.map` in a directory accessible to the HTTPD (or IIS) user (for
    example, `/var/www/data` in Linux, `/Library/WebServer/Documents/` for macOS,
    and `C:\ms4w\Apache\htdocs` in Windows), by executing the following code after
    adjusting the database connection settings:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check whether the WMS GetCapabilities request for this mapfile is working well
    by typing the following URLs in the browser:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities`
    (in Linux)'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map&SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities`
    (in Windows)'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotspots.map&
    SERVICE=WMS&VERSION=1.0.0&REQUEST=GetCapabilities` (in macOS)'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following steps, we will be referring to Linux. If you are using Windows,
    you just need to replace `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map`
    with `http://localhost/cgi-bin/mapserv.exe?map=C:\ms4w\Apache\htdoc\shotspots.map`;
    or if using macOS, replace it with `http://localhost/cgi-bin/mapserv?map=/Library/WebServer/Documents/hotsposts.map`
    in every request:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Now query the WMS service with a `GetMap` request. Type the following URL in
    the browser. If everything is correct, MapServer should return an image with some
    hotspots as a response. The URL is `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The map displayed on your browser will look as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e87157b9-e037-468c-96d7-d43bf066454b.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: 'Until now, you have implemented a simple WMS service. Now, to make the `TIME`
    parameter available for WMS Time requests, add the `wms_timeextent`, `wms_timeitem`
    and `wms_timedefault` variables in the `LAYER METADATA` section, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having added these parameters in the `LAYER METADATA` mapfile section, the
    WMS `GetCapabilities` response should change. Now, the hotspots layer definition
    includes the time dimension, defined by the `<Dimension>` and `<Extent>` elements.
    You will get a response, as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e238ef42-eef4-4b4e-b1ab-9d837b6dadb7.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: You can finally test the WMS service with time support. You only need to remember
    to add the `TIME` parameter in the `GetMap` request (otherwise, `GetMap` will
    filter out the data using the default date, which is `2017-12-12` in this example)
    using the URL `http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-10`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play for a while with the `TIME` parameter in the preceding URL and try to see
    how the GetMap image response changes day by day. Remember that, for the dataset
    we imported, the `acq_date` range is from `2017-12-07` to `2017-12-14`; but in
    your case, if you didn't use the hostpots shapefile included in the book dataset,
    the time range will be different!
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are different outputs for the mentioned dates and the full URLs
    used to query the service:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-14`.
    The output is as follows (2017-12-14):'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/04511f88-e1af-4723-82cf-036066eea89f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: '`http://localhost/cgi-bin/mapserv?map=/var/www/data/hotspots.map&&SERVICE=WMS&VERSION=1.3.0&REQUEST=GetMap&BBOX=-25,-100,35,-35&CRS=EPSG:4326&WIDTH=1000&HEIGHT=800&LAYERS=hotspots&STYLES=&FORMAT=image/png&TIME=2017-12-07`.
    The output is as follows (2017-12-07):'
  id: totrans-208
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d25c2dbd-3f54-4402-8524-366b585e7519.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how to create a WMS Time service using the MapServer
    open source web-mapping engine. A WMS Time service is useful for whenever you
    have temporal series and geographic data varying in the time. WMS Time lets the
    user filter the requested data by providing a `TIME` parameter with a time value
    in the WMS requests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, you first created a plain WMS; if you are new to the WMS standard,
    mapfile, and MapServer, you can check out the first recipe in this chapter. You
    have imported in PostGIS a points shapefile with one week's worth of hotspots
    derived from the MODIS satellite and created a simple WMS for this layer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that this WMS works well by testing the WMS `GetCapabilities`
    and `GetMap` requests, you have time enabled the WMS by adding three parameters
    in the `LAYER METADATA` mapfile section: `wms_timeextent`, `wms_timeitem`, and
    `wms_timedefault`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `wms_timeextent` parameter is the duration of time in which the service
    will give a response. It defines the PostGIS `table` field to be used to filter
    the `TIME` parameter (the `acq_date` field in this case). The `wms_timedefault`
    parameter specifies a default time value to be used when the request to the WMS
    service does not provide the `TIME` parameter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the WMS is time enabled; this means that the WMS GetCapabilities
    request now includes the time-dimension definition for the PostGIS hotspots layer
    and, more importantly, the GetMap WMS request lets the user add the `TIME` parameter
    to query the layer for a specific date.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WMS services with OpenLayers
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will use the MapServer and Geoserver WMS you created in
    the first two recipes of this chapter using the OpenLayers open source JavaScript
    API.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: This excellent library helps developers quickly assemble web pages using mapping
    viewers and features. In this recipe, you will create an HTML page, add an OpenLayers
    map in it and a bunch of controls in that map for navigation, switch the layers,
    and identify features of the layers. We will also look at two WMS layers pointing
    to the PostGIS tables, implemented with MapServer and GeoServer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MapServer uses *PROJ.4* ([https://trac.osgeo.org/proj/)](https://trac.osgeo.org/proj/))
    for projection management. This library does not exist by default with the *Spherical
    Mercator* projection (*EPSG:900913*) defined. Such a projection is commonly used
    by commercial map API providers, such as GoogleMaps, Yahoo! Maps, and Microsoft
    Bing, and can provide excellent base layers for your maps.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we need to have under consideration the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Due to security restrictions in JavaScript, it is not possible to retrieve information
    from remote domains using `XMLHttpRequest`. You will encounter this issue in the
    recipe when you send a WMS `GetFeatureInfo` request to a GeoServer that is typically
    running on Tomcat at port 8080 and also send a request from an HTML page running
    on Apache or ISS at port 80\. Therefore, unless you run your GeoServer instance
    using HTTPD URL rewriting, the solution is to create a proxy script.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the proxy script included in the book dataset to the web `cgi` directory
    of your computer (in Linux, at `/usr/lib/cgi-bin`/, in macOS, at `/Library/WebServer/CGI-Executables,`
    and in Windows, at `C:\ms4w\Apache\cgi-bin`), open the proxy.`cgi` file, and add
    `localhost:8080` to the `allowedHosts` list.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `openlayers.html` file and add the `<head>` and `<body>` tags. In
    the `<head>` tag, import the OpenLayers JavaScript library by executing the following
    code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, add a `<div>` element in the `<body>` tag that will contain the OpenLayers
    map. The map should be given a width of 900 pixels and a height of 500 pixels,
    using the following code:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`<body>`标签中添加一个`<div>`元素，该元素将包含OpenLayers地图。地图应设置为900像素宽和500像素高，使用以下代码：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Just after the map is placed in `<div>`, add a JavaScript script and create
    an OpenLayers `map` object. In the map constructor parameters, you will add an
    empty `controls` array and declare that the map has a Spherical Mercator''s projection,
    as shown in the following code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图放置在`<div>`之后，添加一个JavaScript脚本并创建一个OpenLayers `map`对象。在地图构造函数参数中，您将添加一个空的`controls`数组并声明地图具有球面墨卡托投影，如下所示：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Right after the `map` variable is declared, add some OpenLayers controls to
    the map. For the web GIS viewer you are creating, you will add the `Navigation`
    control (which handles map browsing with mouse events, such as dragging, double-clicking,
    and scrolling the wheel), the `PanZoomBar` control (a four-direction navigation
    using the arrows present above the zooming vertical slider), the `LayerSwitcher`
    control (which handles the switching on and off of layers added to the map), and
    the `MousePosition` control (which displays the map coordinates as they change
    while the user is moving the mouse), using the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`map`变量声明后立即，向地图添加一些OpenLayers控件。对于您正在创建的Web GIS查看器，您将添加`Navigation`控件（它通过鼠标事件处理地图浏览，例如拖动、双击和滚动鼠标滚轮）、`PanZoomBar`控件（使用位于缩放垂直滑块上方的箭头进行四个方向的导航）、`LayerSwitcher`控件（它处理添加到地图的图层的开关）和`MousePosition`控件（它显示地图坐标，当用户移动鼠标时坐标会变化），使用以下代码：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now create an OSM base layer, using the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个OSM基础图层，使用以下代码：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set two variables for the WMS GeoServer and the MapServer URL that you will
    use (they are the URLs of the services you created in the first two recipes of
    this chapter):'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为WMS GeoServer和MapServer URL设置两个变量，您将使用这些URL（它们是您在本章前两个菜谱中创建的服务URL）：
- en: 'For Linux, add the following code:'
  id: totrans-237
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Linux，添加以下代码：
- en: '[PRE24]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For Windows, add the following code:'
  id: totrans-239
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows，添加以下代码：
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For macOS, add the following code:'
  id: totrans-241
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于macOS，添加以下代码：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, create a WMS GeoServer layer to display the OpenLayers map the counties
    from the PostGIS layer. You will set an opacity for this layer, so that it is
    possible to see the other layer (counties) behind it. The `isBaseLayer` property
    is set to `false`, since you want to have this layer over the Google Maps base
    layers and not as an alternative to them (by default, all of the WMS layers in
    OpenLayers are considered to be base layers). Create the WMS GeoServer layer,
    using the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个WMS GeoServer图层以显示OpenLayers地图中的PostGIS图层县。您将为该图层设置不透明度，以便可以看到其后面的其他图层（县）。`isBaseLayer`属性设置为`false`，因为您希望这个图层位于Google
    Maps基础图层之上，而不是作为它们的替代品（默认情况下，OpenLayers中的所有WMS图层都被视为基础图层）。使用以下代码创建WMS GeoServer图层：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, create a WMS MapServer layer to display the countries from the PostGIS
    layer in the OpenLayers map, using the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个WMS MapServer图层以在OpenLayers地图中显示来自PostGIS图层的国家，使用以下代码：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After creating the OSM and WMS layers, you need to add all of them to the map,
    using the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建OSM和WMS图层后，您需要使用以下代码将所有这些图层添加到地图中：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You want to provide the user the possibility to identify features of the counties
    WMS. Add the `WMSGetFeatureInfo` OpenLayers control (which will send `GetFeatureInfo`
    requests to the WMS behind the scenes) that points to the counties PostGIS layer
    served by the GeoServer WMS, using the following code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您希望为用户提供识别县WMS中特征的可能性。添加`WMSGetFeatureInfo` OpenLayers控件（它将在幕后发送`GetFeatureInfo`请求到GeoServer
    WMS），指向由GeoServer WMS提供的县PostGIS图层，使用以下代码：
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, set the center of the map and its initial zoom level, using the following
    code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置地图的中心和其初始缩放级别，使用以下代码：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Your HTML file should now look like the `openlayers.html` file contained in
    `data/chp09`. You can finally deploy this file to your web server (Apache HTTPD
    or IIS). If you are using Apache HTTPD in Linux, you could copy the file to the
    `data` directory under `/var/www`, and if you are using Windows, you could copy
    it to the data directory under `C:\ms4w\Apache\htdocs` (create the `data` directory
    if it does not already exist). Then, access it using the URL `http://localhost/data/openlayers.html`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, access the `openlayers` web page using your favorite browser. Start browsing
    the map: zoom, pan, try to switch the base and overlays layers on and off using
    the layer switcher control, and try to click on a point to identify one feature
    from the counties PostGIS layer. A map is shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85867693-84b9-4bb5-a267-ea322c71b098.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: How it works..
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to create a web map viewer with the *OpenLayers* JavaScript
    library. This library lets the developer define the various map components, using
    JavaScript in an HTML page. The core object is a map that is composed of *controls*
    and *layers*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: OpenLayers comes with a great number of controls ([http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html](http://dev.openlayers.org/docs/files/OpenLayers/Control-js.html)),
    and it is even possible to create custom ones.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Another great OpenLayers feature is the ability to add a good number of geographic
    data sources as layers in the map (you added just a couple of its types to the
    map, such as OpenStreetMap and WMS) and you could add sources, such as WFS, GML,
    KML, GeoRSS, OSM data, ArcGIS Rest, TMS, WMTS, and WorldWind, just to name a few.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WMS services with Leaflet
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you have seen how to create a webGIS using the OpenLayers
    JavaScript API and then added the WMS PostGIS layers served from MapServer and
    GeoServer .
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: A lighter alternative to the widespread OpenLayers JavaScript API was created,
    named **Leaflet**. In this recipe, you will see how to use this JavaScript API
    to create a webGIS, add a WMS layer from PostGIS to this map, and implement an
    *identify tool,* sending a `GetFeatureInfo` request to the MapServer WMS. However,
    unlike OpenLayers, Leaflet does not come with a `WMSGetFeatureInfo` control, so
    we will see in this recipe how to create this functionality.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new HTML file and name it `leaflet.html` (available in the book source
    code package). Open it and add the `<head>` and `<body>` tags. In the `<head>`
    section, import the Leaflet CSS and JavaScript libraries and the jQuery JavaScript
    library (you will use jQuery to send an AJAX request to the `GetFeatureInfo` from
    the MapServer WMS):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start adding a `<div>` tag in the `<body>` element to include the Leaflet map
    in your file, as shown in the following code; the map will have a width of 800
    pixels and a height of 500 pixels:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Just after the `<div>` element containing the map, add the following JavaScript
    code. Create a Leaflet `tileLayer` object using the `tile.osm.org` service based
    on `OpenStreetMap` data:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a second layer that will use the MapServer WMS you created a few recipes
    ago in this chapter. You will need to set the `ms_url` variable differently if
    you''re using Linux, Windows, or macOS:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Linux, use the following code:'
  id: totrans-272
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For Windows, use the following code:'
  id: totrans-274
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For macOS, use the following code:'
  id: totrans-276
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the Leaflet `map` and add layers to it, as shown in the following code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, associate the mouse-click event with a function that will perform the
    `GetFeatureInfo` WMS request on the `countries` layer, by executing the following
    code:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Your HTML file should now look like the `leaflet.html` file contained in `data/chp09`.
    You can now deploy this file to your web server (that is, Apache HTTPD or IIS).
    If you are using Apache HTTPD in Linux, you could copy the file to the `/var/www/data
    directory`; if you are running macOS, copy it to `/Library/WebServer/Documents/data` ;and
    if you are using Windows, you could copy it to `C:\ms4w\Apache\htdocs\data` (create
    the data directory if it does not already exist). Then, access it with the URL
    `http://localhost/data/leaflet.html`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web page using your favorite browser, and start navigating the map;
    zoom, pan, and try to click on a point to identify one feature from the `countries`
    PostGIS layer, as shown in the following screenshot:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8a53d0f-03f9-4596-a63c-8a45d3ed0927.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how to use the Leaflet JavaScript API library
    to add a map in an HTML page. First, you created one layer from an external server
    to use as the base map. Then, you created another layer using the MapServer WMS
    you implemented in a previous recipe to expose a PostGIS layer to the web. Then,
    you created a new map object and added it to these two layers. Finally, using
    jQuery, you implemented an AJAX call to the `GetFeatureInfo` WMS request and displayed
    the results in a Leaflet `Popup` object.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Leaflet is a very nice and compact alternative to the OpenLayers library and
    gives very good results when your webGIS service needs to be used from mobile
    devices, such as tablets and smart phones. Additionally, it has a plethora of
    plugins and can be easily integrated with JavaScript libraries, such as Raphael
    and JS3D.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Consuming WFS-T services with OpenLayers
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will create the **Transactional Web Feature Service** (**WFS-T**)
    from a PostGIS layer with the GeoServer open source web-mapping engine and then
    an OpenLayers basic application that will be able to use this service.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: This way, the user of the application will be able to manage transactions on
    the remote PostGIS layer. WFS-T allows for the creation, deletion, and updating
    of features. In this recipe, you will allow the user to only to add features,
    but this recipe should put you on your way to creating more composite use cases.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to GeoServer and OpenLayers, you should first read the *Creating
    WMS and WFS services with GeoServer* and *Consuming WMS services with OpenLayers*
    recipes and then return to this one.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create the proxy script and deploy it to your web server (that is, HTTPD or
    IIS), as indicated in the *Getting ready* section of the *Consuming WMS services
    with OpenLayers* recipe.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following PostGIS points layer named `sites`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now create a PostGIS layer in GeoServer for the `chp09.sites` table. For more
    information on this, refer to the *Creating WMS and WFS services with GeoServer*
    recipe in this chapter.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `wfst.html`. Open it and add the `<head>` and `<body>`
    tags. In the `<head>` tag, import the following `OpenLayers` library:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a `<div>` tag in the `<body>` tag to contain the OpenLayers map, as shown
    in the following code; the map will have a width of 700 pixels and a height of
    400 pixels:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just after the `<div>` tag is made to contain the map, add a JavaScript script.
    Inside the script, start setting `ProxyHost` to the web location where you deployed
    your proxy script. Then create a new OpenLayers map, as shown in the following
    code:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, in the script, after creating the map, create an `OpenStreetMap` layer
    that you will use in the map as the base layer, using the following code:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, create the WFS-T layer''s `OpenLayers` object using the `StyleMap` object
    to render the PostGIS layer features with red points, as shown in the following
    screenshot:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the WFS layer to the map, center align the map, and set the initial zoom.
    You can use the `geometry` transform method to convert a point from `EPSG:4326`,
    in which the layer is stored, to `ESPG:900913`, which is used by the viewer, as
    shown in the following code:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you will create a panel with a *Draw Point* tool (to add new features)
    and a *Save Features* tool (to save the features to the underlying WFS-T). We
    first create the panel, as shown in the following code:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we will create the *Draw Point* tool, as shown in the following code:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we will create the *Save Features* tool, using the following code:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, add the tools to the panel, including a navigation control, and the
    panel as a control to the map, using the following code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your HTML file should now look like the `wfst.html` file contained in the `chp09`
    directory. Deploy this file to your web server (that is, Apache HTTPD or IIS).
    If you are using Apache HTTPD in Linux, you could copy the file to the `data`
    directory under `/var/www`, whereas if you are using Windows, you could copy it
    to the data directory under `C:\ms4w\Apache\htdocs` (create the `data` directory
    if it does not already exist). Then, access it using `http://localhost/data/wfst.html`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the web page using your favorite browser and start adding some points
    to the map. Now, click on the Save button and reload the page; the previously
    added points should still be there, as they had been stored in the underlying
    `PostGIS` table by WFS-T, as shown in the following screenshot:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abea301e-c5df-4a8b-8187-b7265c629b58.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Added points using OpenLayers controls viewed on a browser
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you first created a point `PostGIS` table and then published
    it as WFS-T, using GeoServer. You then created a basic OpenLayers application,
    using the WFS-T layer, allowing the user to add features to the underlying PostGIS
    layer.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In OpenLayers, the core object needed to implement such a service is the vector
    layer by defining a WFS protocol. When defining the WFS protocol, you have to
    provide the WFS version that is using the spatial reference system of the dataset,
    the URI of the service, the name of the layer (for GeoServer, the name is a combination
    of the layer workspace, `FeaturePrefix`, and the layer name, `FeatureType`), and
    the name of the `geometry` field that will be modified. You also can pass to the
    Vector layer constructor a `StyleMap` value to define the layer's rendering behavior.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: You then tested the application by adding some points to the OpenLayers map
    and checked that those points were effectively stored in PostGIS. When adding
    the points using the WFS-T layer, with the help of tools such as Firefox Firebug
    or Chrome (Chromium) Developer Tools, you could dig in detail into the requests
    that you are making to the WFS-T and its responses.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when adding a point, you will see that an `Insert` request is
    sent to WFS-T. The following XML is sent to the service (note how the point geometry
    is inserted in the body of the `<wfs:Insert>` element):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `<wfs:TransactionResponse>` response, as shown in the following code, will
    be sent from WFS-T if the process has transpired smoothly and the features have
    been stored (note that the `<wfs:totalInserted>` element value in this case is
    set to `1`, as only one feature was stored):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Developing web applications with GeoDjango – part 1
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe and the next, you will use the **Django** web framework to create
    a web application to manage wildlife sightings using a PostGIS data store. In
    this recipe, you will build the back office of the web application, based on the
    Django admin site.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Upon accessing the back office, an administrative user will be able to, after
    authentication, manage (insert, update, and delete) the main entities (animals
    and sightings) of the database. In the next part of the recipe, you will build
    a front office that displays the sightings on a map based on the **Leaflet** JavaScript
    library.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: You can find a copy of the whole project that you are going to build in the
    code bundle under `chp09/wildlife`. Refer to it if a concept is not clear or if
    you want to copy and paste the code as you go through the steps of the recipe,
    rather than typing code from scratch.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are new to Django, check out the official Django tutorial at [https://docs.djangoproject.com/en/dev/intro/tutorial01/](https://docs.djangoproject.com/en/dev/intro/tutorial01/)
    and then return to this recipe.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Python *virtualenv* ([http://www.virtualenv.org/en/latest/](http://www.virtualenv.org/en/latest/))
    to create an isolated Python environment to use with the web application you will
    build in this recipe and the next. Then, activate the environment as follows:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following commands in Linux:'
  id: totrans-338
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Type the following commands in Windows (for steps to install `virtualenv` on
    Windows, refer to [https://zignar.net/2012/06/17/install-python-on-windows/](https://zignar.net/2012/06/17/install-python-on-windows/)):'
  id: totrans-340
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once activated, you can install the Python packages that you will use for this
    recipe as well as the next, using the `pip` tool ([http://www.pip-installer.org/en/latest/](http://www.pip-installer.org/en/latest/)).
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Linux, the command would be as follows:'
  id: totrans-343
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In Windows, the command would be as follows:'
  id: totrans-345
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you haven't done it so far, download the world countries shapefile from [http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip](http://thematicmapping.org/downloads/TM_WORLD_BORDERS-0.3.zip).
    A copy of this shapefile is included in the code bundle of this book. Extract
    the shapefile to the `working/chp09` directory.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Django project using the `django-admin` command with the `startproject`
    option. Name the project `wildlife`. The command for creating the project will
    be as follows:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a Django application using the `django-admin` command with the `startapp`
    option. Name the application `sightings`. The command will be as follows:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now you should have the following directory structure:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13f78c11-6d72-4453-8a85-771f9cb472cb.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: 'You will need to edit some files. Open your favorite editor (**Sublime Text**
    does the job) and go to the settings in the `settings.py` file in the code bundle
    under `chp09/wildlife/wildlife`. First, the `DATABASES` settings should be as
    shown in the following code, in order to use the `postgis_cookbook` PostGIS database
    for your application data:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add the following two lines of code at the top of the `wildlife/settings.py`
    file (`PROJECT_PATH` is the variable in which you will enter the project''s path
    in the settings menu):'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Make sure that in the `settings.py` file under `chp09/wildlife/wildlife`, `MEDIA_ROOT`,
    and `MEDIA_URL` are correctly set, as shown the following code (this is to set
    the media files'' path and URLs for the images that the administrative user will
    upload):'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Make sure that the `INSTALLED_APPS` setting looks as shown in the following
    code in the `settings.py` file. You will use the Django admin site (`django.contrib.admin`),
    the GeoDjango core library (`django.contrib.gis`), and the sightings application
    you are creating in this recipe and the next. For this purpose, add the last three
    lines:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, synchronize the database using the Django `migrations` management commands.
    When prompted to create a *superuser*, answer `yes` and choose a preferred administrative
    username and password:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now you will add the models needed by the application. Edit the `models.py`
    file under `chp09/wildlife/sightings` and add the following code:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Each model will become a table in the database with the corresponding fields
    defined using the `models` and `gismodels` class. Note that the `geometry` variable
    in the `county` and `sighting` layers will become the `MultiPolygon` and `Point`
    PostGIS geometry columns, thanks to the GeoDjango library.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `admin.py` file under `chp09/wildlife/sightings` and add the following
    code to it. The classes in this file will define and customize the behavior of
    the Django admin site when browsing the application models or tables (fields to
    display, fields to be used to filter records, and fields to order records). Create
    the file by executing the following code:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, to synchronize the database, execute the following commands in the Django
    project folder:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output should be as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6bc8f8-9be1-40b2-b90f-4a246c4bda3b.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Now, for each model in `models.py`, a PostgreSQL table should have been created.
    Check whether your PostgreSQL database effectively contains the three tables created
    in the preceding commands using your favorite client (that is, `psql` or `pgAdmin`)
    and whether or not the `sightings_sighting` and `sightings_country` tables contain
    PostGIS geometric fields.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any web application needs the definition of URLs where the pages can be accessed.
    Therefore, edit your `urls.py` file under `chp09/wildlife/wildlife` by adding
    the following code:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `urls.py` file, you basically defined the location of the back office
    (which was built using the Django admin application) and the media (images) files''
    location uploaded by the Django administrator when adding new animal entities
    in the database. Now run the Django development server, using the following `runserver`
    management command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Access the Django admin site at `http://localhost:8000/admin/` and log in with
    the superuser credentials you furnished in an earlier step in this recipe (*step
    7*).
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, navigate to `http://localhost:8000/admin/sightings/animal/` and add some
    animals using the Add animal button. For each animal, define a name and an image
    that will be used by the frontend that you will build in the next recipe. You
    created this page with almost no code, thanks to the Django admin! The following
    screenshot shows what the Animals list page will look like after adding some entities:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57846f01-681a-4a75-b4f7-d3d22e44efab.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: 'Navigate to `http://localhost:8000/admin/sightings/sighting/` and add some
    sightings using the Add sighting button. For each sighting, define the Date, Time,
    the name of the animal that was spotted, Rate, and the location. GeoDjango has
    added the map widget to the Django Admin site for you, based on the OpenLayers
    JavaScript library, to add or modify geometric features. The Sightings page is
    shown in the following screenshot:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d8f11d04-1b65-4d87-a88d-9474a4ab206c.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
- en: 'The Sightings list page, thanks to the Django admin''s efficiency, will provide
    the administrative user with useful features to sort, filter, and navigate the
    date hierarchy of all of the sightings in the system, as shown in the following
    screenshot:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/faf66318-a650-40a0-9434-b1a6bb618a5f.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: 'Now, you will import the `countries` shapefile to its model. In the next recipe,
    you will use this model to find the country where each sighting occurred. Before
    going ahead in this recipe, investigate the shapefile structure; you will need
    to import just the `NAME` and `ISO2` attributes to the model as the `name` and
    `isocode` attributes, using the following command:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '****![](img/9f3be64f-4aa1-4522-9dee-479df76c3b7f.png)****'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `load_countries.py` file under `chp09/wildlife/sightings` and import
    the shapefile to PostGIS, using the `LayerMapping` GeoDjango utility, using the
    following code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You should have the `TM_WORLD_BORDERS-0.3.shp` file placed under `chp09/wildlife`
    for this code to work. Enter the Python Django shell and run the `utils.py` script.
    Then, check whether the countries have been correctly inserted in the `sightings_country`
    table in your PostgreSQL database, using the following command:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, you should see the countries in the administrative interface at `http://localhost:8000/admin/sightings/country/`,
    while running the Django server with:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '**![](img/be44025b-b8a3-48cc-aec5-d67ba8ff1dbe.png)**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you have seen how quick and efficient it is to assemble a back
    office application using **Django**, one of the most popular Python web frameworks;
    this is thanks to its object-relational mapper, which automatically created the
    database tables needed by your application and an automatic API to manage (insert,
    update, and delete) and query the entities without using SQL.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the **GeoDjango** library, two of the application models, County and
    Sighting, have been geo-enabled with their introduction in the database tables
    of `geometric` PostGIS fields.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: You have customized the powerful **automatic administrative interface** to quickly
    assemble the back-office pages of your application. Using the **Django URL Dispatcher**,
    you have defined the URL routes for your application in a concise manner.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, what is extremely nice about the Django abstraction
    is the automatic implementation of the data-access layer API using the models.
    You can now add, update, delete, and query records using Python code, without
    having any knowledge of SQL. Try this yourself, using the Django Python shell;
    you will select an animal from the database, add a new sighting for that animal,
    and then finally delete the sighting. You can investigate the SQL generated by
    Django, behind the scenes, any time, using the `django.db`.connection class with
    the following command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Do you like Django as much as we do? In the next recipe, you will create the
    frontend of the application. The user will be able to browse the sightings in
    a map, implemented with the Leaflet JavaScript library. So keep reading!
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Developing web applications with GeoDjango – part 2
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will create the front office for the web application you
    created using **Django** in the previous recipe.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Using HTML and the **Django template language**, you will create a web page
    displaying a map, implemented with Leaflet, and a list for the user containing
    all of the sightings available in the system. The user will be able to navigate
    the map and identify the sightings to get more information.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have gone through every single step of the previous recipe and
    have kept the back office of the web application working and its database populated
    with some entities.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Activate the `virtualenv` you created in the *Developing web applications with
    GeoDjango –Part 1)* recipe, as follows:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Linux:'
  id: totrans-410
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use the following command for Windows:'
  id: totrans-412
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Install the libraries that you will use in this recipe; you will need the `simplejson`
    and `vectorformats` Python libraries to produce a GeoJSON ([http://www.geojson.org/](http://www.geojson.org/))
    response that will feed the sighting layer in Leaflet:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the following command for Linux:'
  id: totrans-415
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use the following command for Windows:'
  id: totrans-417
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: How to do it...
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will now create the front page of your web application, as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the directory containing the Django wildlife web application and add
    the following lines to the `urls.py` file under `chp09/wildlife/wildlife`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Open the `views.py` file under `chp09/wildlife/sightings` and add the following
    code. The `home` view will return the home page of your application, with the
    list of sightings and the Leaflet map. The `sighting` layer in the map will display
    the GeoJSON response given by the `get_geojson` view:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Add the following `@property` definitions to the `Sighting` class in the `models.py`
    file under `chp09/wildlife/sightings`. The `get_geojson` view will need to use
    these properties to compose the GeoJSON view needed from the Leaflet map and the
    information popup. Note how in the `country_name` property, you are using GeoDjango,
    which contains a spatial lookup `QuerySet` operator to detect the country where
    the sighting happened:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add a `home.html` file, containing the following code, under `sightings/templates/sightings`.
    Using the Django template language, you will display the number of sightings in
    the system, a list of these sightings with the main information for each of them,
    and the Leaflet map. Using the Leaflet JavaScript API, you add a base OpenStreetMap
    layer to the map. Then, you make an asynchronous call, using jQuery, to the `get_geojson`
    view (accessed by adding `/geojson` to the request URL). If the query is successful,
    it will feed a Leaflet GeoJSON layer with the features from the sighting PostGIS
    layer and associate with each feature an informative popup. This popup will open
    any time the user clicks on a point on the map representing a sighting, displaying
    the main information for that entity:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now that your frontend page is completed, you can finally access it at `http://localhost:8000/`.
    Navigate the map and try to identify some of the displayed sightings to check
    whether the popup opens, as shown in the following screenshot:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29b9fe1f-aa0b-47a1-82ce-ddc3da0b476c.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created an HTML front page for the web application you developed in the
    previous recipe. The HTML is dynamically created using the Django template language
    ([https://docs.djangoproject.com/en/dev/topics/templates/](https://docs.djangoproject.com/en/dev/topics/templates/))
    and the map was implemented with the Leaflet JavaScript library.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The Django template language uses the response from the home view to generate
    a list of all of the sightings in the system.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: The map was created using Leaflet. First, an OpenStreetMap layer was used as
    a base map. Then, using jQuery, you fed a GeoJSON layer that displays all of the
    features generated by the `get_geojson` view. You associated a popup with the
    layer that opens every time the user clicks on a sighting entity. The popup displays
    the main information for that sighting, including a picture of the sighted animal.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Developing a web GPX viewer with Mapbox
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will use the way points dataset from [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml),
    *Working with Vector Data – The Basics*. Refer to the script in the recipe named
    *Working with GPS data* to learn how to import `.gpx` files tracks into PostGIS.
    You will also need a Mapbox token; for this, go to their site ([https://www.mapbox.com](https://www.mapbox.com))
    and sign up for one.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare the data for Mapbox''s GeoJSON format, export the table tracks from
    [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml), *Working with Vector
    Data – The Basics* using `ogr2ogr` with the following code:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Remove the `crs` definition line on the new `.json` with your favorite editor:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44c050ce-b50e-4725-96c5-cea5247a64c5.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'Go to your Mapbox account and upload in the Datasets menu the `tracks.json`
    file. After a successful upload, you will see the following message:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/93df2e72-9f49-495c-a719-308c9219b476.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Create the dataset and export it to a tileset:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据集并将其导出为瓦片集：
- en: '![](img/f8d5f46a-768a-439a-97f6-a552775ec5aa.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8d5f46a-768a-439a-97f6-a552775ec5aa.png)'
- en: 'Now, create a new style with the outdoors template:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用户外模板创建一个新的样式：
- en: '![](img/50901ea0-7a5d-492c-8229-dc9cf0a9ca66.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50901ea0-7a5d-492c-8229-dc9cf0a9ca66.png)'
- en: Add the tracks layer and publish it. Note the style URL that you can use to
    share or further develop your map; copy it to use it in your code.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加轨道层并发布它。注意你可以使用的样式URL，你可以用它来分享或进一步开发你的地图；复制它以便在代码中使用。
- en: 'Now we are ready to create a mapbox.html file; add the following in the head
    section to use Mapbox JS and CSS libraries:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个mapbox.html文件；在head部分添加以下内容以使用Mapbox JS和CSS库：
- en: '[PRE83]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Insert a `map` with your token and the style we''ve just created in the body:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正文插入一个`map`，使用你的令牌和我们刚刚创建的样式：
- en: '[PRE84]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'That''s it, you can double-click and open the HTML with your favorite browser
    and the Mapbox API will serve your map:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样，你可以双击并使用你喜欢的浏览器打开HTML文件，Mapbox API将为你提供地图：
- en: '![](img/b21495be-2867-4e35-87f6-48be916877f6.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b21495be-2867-4e35-87f6-48be916877f6.png)'
- en: How it works...
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To quickly publish and visualize data in a webGIS, you can use the Mapbox API
    to create beautiful maps with your own data; you will have to keep a GeoJSON format
    and not exceed the offered bandwidth capacity. In this recipe, you've learned
    how to export your PostGIS data to publish it in Mapbox as a JS.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速发布和可视化webGIS中的数据，你可以使用Mapbox API使用你自己的数据创建美丽的地图；你将需要保持GeoJSON格式，并且不要超过提供的带宽容量。在这个菜谱中，你学习了如何将你的PostGIS数据导出，以便在Mapbox中以JS的形式发布。
