["```py\npip install numpy\n```", "```py\npip install qiskit\n```", "```py\npip install 'qiskit[visualization]'\n```", "```py\npip install qutip\n```", "```py\nimport numpy as np\n```", "```py\nfrom qiskit.visualization import array_to_latex, plot_bloch_vector, plot_bloch_multivector, plot_state_qsphere, plot_state_city\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile\nfrom qiskit import execute, Aer\nimport qiskit.quantum_info as qi\nfrom qiskit.extensions import Initialize\nfrom qiskit.providers.aer import extensions  # import aer snapshot instructions\n```", "```py\nimport cmath\nimport math\n```", "```py\nimport qutip\n```", "```py\n_EPS = 1e-10 # Global variable used to chop small numbers to zero\ndef check(s):\n  num_qubits = math.log2(len(s))\n  # Check if param is a power of 2\n  if num_qubits == 0 or not num_qubits.is_integer():\n      raise Exception(\"Input complex vector length is not a positive power of 2.\")\n  num_qubits = int(num_qubits)\n  if num_qubits > 1:\n      raise Exception(\"Only one complex vector is allowed as input.\")\n  # Check if probabilities (amplitudes squared) sum to 1\n  if not math.isclose(sum(np.absolute(s) ** 2), 1.0, abs_tol=_EPS):\n      raise Exception(\"Norm of complex vector does not equal one.\")\n  return\n```", "```py\ndef ToBloch(s, show=True):\n  check(s)\n  phi = cmath.phase(s[1]) - cmath.phase(s[0])\n  theta = 2*math.acos(abs(s[0]))\n  r1 = math.sin(theta)*math.cos(phi)\n  r2 = math.sin(theta)*math.sin(phi)\n  r3 = math.cos(theta)\n  r = (r1,r2,r3)\n  if show:\n    display(array_to_latex(s, prefix=\"\\\\text{s} = \", precision = 2))\n    display(array_to_latex([theta, phi], prefix=\"\\\\text{theta, phi} = \", precision = 2))\n    display(array_to_latex(r, prefix=\"\\\\text{r} = \", precision = 2))\n    b = qutip.Bloch()\n    b.add_vectors(r)\n    display(b.render())\n  return theta, phi, r\n```", "```py\ns = [1/math.sqrt(2),complex(0.5, 0.5)]\n(theta, phi, r) = ToBloch(s)\n```", "```py\ndef ToS(theta, phi, show=True):\n  s = [math.cos(theta/2), complex(math.cos(phi) * math.sin(theta/2), math.sin(phi) * math.sin(theta/2))]\n  if show:\n    display(array_to_latex([theta, phi], prefix=\"\\\\text{theta, phi} = \", precision = 2))\n    display(array_to_latex(s, prefix=\"\\\\text{s} = \", precision = 1))\n  return s\n```", "```py\ns = ToS(np.pi/2, np.pi/4)\n```", "```py\nq = QuantumRegister(2)\nqc = QuantumCircuit(q)\nqc.h(q[0])\nqc.cx(q[0], q[1])\nqc.draw(output='mpl')\n```", "```py\ns = qi.Statevector.from_instruction(qc)\ns.draw('latex', prefix='|s \\\\rangle = ')\n```", "```py\nrho = qi.DensityMatrix.from_instruction(qc)\nrho.draw('latex', prefix='\\\\rho = ')\n```", "```py\nfrom qiskit.visualization import plot_state_city\nplot_state_city(rho.data, title='Density Matrix')\n```", "```py\ndef create_parallel_H(n):\n    q = QuantumRegister(n, 'q')\n    qc = QuantumCircuit(q)\n    for k in range(n):\n        qc.h(k)\n    return qc\n```", "```py\ndef run_parallel_H(n):\n  qc = create_parallel_H(n)\n  s = qi.Statevector.from_instruction(qc)\n  display(s.draw('latex'))\n  display(qc.draw(output='mpl'))\n  return\n```", "```py\nrun_parallel_H(1)\n```", "```py\nrun_parallel_H(2)\n```", "```py\nrun_parallel_H(3)\n```", "```py\nfrom qiskit.extensions import UnitaryGate\ni = complex(0.0, 1.0)\nBS = 1/np.sqrt(2) * np.array([[1,i],[i,1]])\nBS = UnitaryGate(BS,'Beam Splitter')\n```", "```py\nPBS = np.array([[1,0,0,0],[0,0,0,1],[0,0,1,0],[0,1,0,0]])\nPBS = UnitaryGate(PBS,'PBS')\n```", "```py\ndef show(qc):\n  display(qc.draw(output='mpl'))\n  s = qi.Statevector.from_instruction(qc)\n  display(array_to_latex(s, prefix=\"\\\\text{state vector} = \", precision = 2))\n  return\n```", "```py\nq = QuantumRegister(2, 'q') # register of 2 qubits\n# q[0] handedness qubit,|0⟩ left-handed,|1⟩ right-handed\n# q[1] direction of propagation qubit,|0⟩ horizontal,|1⟩ vertical\nqc = QuantumCircuit(q)\nqc.x([0]) # Right-handed\nshow(qc)\nqc.append(PBS, q)\nshow(qc)\n```", "```py\nq = QuantumRegister(2, 'q') # register of 2 qubits\n# q[0] handedness qubit,|0⟩ left-handed, |1⟩ right-handed\n# q[1] direction of propagation qubit, |0⟩ horizontal, |1⟩ vertical\nqc = QuantumCircuit(q)\nqc.h(q[0]) # Put enantiomer in a superposition of left- and right-handed states\nshow(qc)\nqc.append(PBS, q)\nshow(qc)\n```", "```py\ndef init_random():\n  # Create random 1-qubit state s1\n  s1 = qi.random_statevector(2)\n  display(array_to_latex(s1, prefix=\"\\\\text{State 1} =\", precision=2))\n  # Create random 1-qubit state s2\n  s2 = qi.random_statevector(2)\n  display(array_to_latex(s2, prefix=\"\\\\text{State 2} =\", precision =2))\n\n  return s1, s2\n```", "```py\ndef setup_qc(s1, s2, draw=False):\n  init_q1 = Initialize(s1)\n  init_q1.label = \"init_q1\"\n  init_q2 = Initialize(s2)\n  init_q2.label = \"init_q2\"\n  q = QuantumRegister(3, 'q') # register of 3 qubits\n  c = ClassicalRegister(1, name=\"c\") # and 1 classical register\n  qc = QuantumCircuit(q,c)\n  qc.append(init_q1, [1])\n  qc.append(init_q2, [2])\n  qc.barrier()\n  if draw:\n    display(qc.draw(output='mpl'))\n  return qc, q, c\n```", "```py\ndef swapper(draw=False):\n  q = QuantumRegister(3, 'q') # register of 3 qubits\n  qc = QuantumCircuit(q, name='Swapper')\n  qc.h(q[0])\n  qc.cswap(q[0], q[1], q[2])\n  qc.h(q[0])\n  if draw:\n    print(\"Swapper circuit\")\n    display(qc.draw(output='mpl'))\n  return qc\n```", "```py\nq = QuantumRegister(3, 'q') # register of 3 qubits\nqc = QuantumCircuit(q)\nqc.append(swapper(draw=True), qargs=q)\n# Selecting the unitary_simulator\nbackend = Aer.get_backend('unitary_simulator')\n# Executing the job and getting the result as an object\njob = execute(qc, backend)\nresult = job.result()\n# Getting the unitary matrix from the result object\nU = result.get_unitary(qc, decimals=2)\narray_to_latex(U, prefix=\"\\\\text{swapper unitary} = \", precision = 2)\n```", "```py\ndef post_select(qc, q, c, symm=True, simulator='statevector_simulator', shots=1, max_iter=20, swap_test=False):\n  backend = Aer.get_backend(simulator)\n  s = qi.Statevector.from_instruction(qc)\n  display(array_to_latex(s, prefix=\"\\\\text{Initial state} = \", precision = 2))\n  done = False\n  iter = 0\n  while not done and iter < max_iter:\n    qc.append(swapper(draw=(iter==0)), qargs=q)\n    qc.measure(q[0], c[0]) # Measure control qubit q[0]\n    qc.save_statevector(label=str(iter)) # Save the current simulator state vector\n    job = execute(qc, backend, shots=shots) # Execute the Simulator\n    result = job.result()\n    counts = result.get_counts(qc)\n    for k, v in counts.items():\n      if symm and k == '0' and v > shots/2:\n        done = True\n      elif not symm and k == '1' and v > shots/2:\n        done = True\n    if not done:\n      qc.reset(q[0])\n      iter += 1\n  success = proc_result(result, iter, counts, max_iter=max_iter, symm=symm, simulator=simulator, swap_test=swap_test)\n  return result, success\n```", "```py\ndef proc_result(result, iter, counts, max_iter=20, symm=True, simulator='statevector_simulator', swap_test=False):\n  if symm:\n    print(\"Preparing a permutation symmetric state\")\n  else:\n    print(\"Preparing a permutation antisymmetric state\")\n  print(\"simulator:\", simulator)\n  print(\"counts: \", counts)\n  if iter >= max_iter:\n    print(\"Post selection unsuccessful iteration {}\".format(iter))\n    success = False\n  else:\n    print(\"Post selection successful iteration {}\".format(iter))\n    success = True\n    s = result.data()[str(iter)]\n    factor(s, symm) # Call factor()\n    if swap_test:\n      swap_check(qc, q, iter, symm, s, simulator=simulator)\n    print(\" \") # Display Density matrix of the final state\n    display(array_to_latex(qi.DensityMatrix(s), prefix=\"\\\\text{Density matrix of the final state: }\", precision = 2))\n    display(plot_state_city(s, title='Cityscape plot of the final state')) # Display Cityscape plot of the final state\n  return success\n```", "```py\ndef sym_test(s, symm, i0, i1):\n  if symm:\n    b = np.isclose(np.abs(s[i0]-s[i1]), 0, rtol=_EPS) and np.isclose(np.abs(s[i0]**2 + s[i1]**2), 1, rtol=1e-4)\n  else:\n    b = np.isclose(np.abs(s[i0]+s[i1]), 0, rtol=_EPS) and np.isclose(np.abs(s[i0]**2 + s[i1]**2), 1, rtol=1e-4)\n  return b\n```", "```py\ndef factor(s, symm):\n  b0 = np.allclose(s, [1, 0, 0, 0, 0, 0, 0, 0], rtol=_EPS)\n  b1 = np.allclose(s, [0, 0, 0, 0, 0, 0, 1, 0], rtol=_EPS)\n  b2 = sym_test(s, symm, 2, 4)\n  b3 = sym_test(s, symm, 3, 5)\n  b4 = sym_test(s, symm, 0, 6)\n  b5 = sym_test(s, symm, 1, 7)\n  df = {b0: \"|00\", b1: \"|11\", b2: \"|\\\\Psi_+\", b3: \"|\\\\Psi_-\", b4: \"|\\\\Phi_+\", b5: \"|\\\\Phi_-\"}\n  found = False\n  for k, v in df.items():\n    if not found and symm and k:\n      display(array_to_latex([s], prefix = \"\\\\text{Symmetrized state: }\" + v + \"\\\\rangle, \\\\text{  Final state: }\" + v + \" \\\\rangle |0 \\\\rangle =\", precision = 2))\n      found = True\n    elif not found and not symm and k:\n      display(array_to_latex([s], prefix = \"\\\\text{Antisymmetrized state: }\" + v + \"\\\\rangle, \\\\text{  Final state: }\" + v + \" \\\\rangle |1 \\\\rangle =\", precision = 2))\n      found = True\n  if not found:\n    display(array_to_latex(s, prefix=\"\\\\text{Final state} = \", precision = 2))\n  return\n```", "```py\ndef swap_check(qc, q, iter, symm, s, simulator='statevector_simulator'):\n  s21 = swap(qc, q, iter, simulator=simulator)\n  if symm:\n    if np.allclose(s-s21, 0, rtol=_EPS):\n      print(\"Swap test confirms that final state is permutation symmetric\")\n  else:\n    if np.allclose(s+s21, 0, rtol=_EPS):\n      print(\"Swap test confirms that final state is permutation asymmetric\")\n  return\n```", "```py\ndef swap(qc, q, iter, simulator='statevector_simulator'):\n  backend = Aer.get_backend(simulator)\n  qc.swap(q[1], q[2])\n  qc.measure(q[0], c[0]) # Measure control qubit q[0]\n  qc.save_statevector(label=str(iter+1)) # Save the current simulator state vector\n  job = execute(qc, backend, shots=1) # Execute the Simulator\n  result = job.result()\n  s21 = result.data()[str(iter+1)]\n  return s21\n```", "```py\ns1 = qi.Statevector([0, 1])\ns2 = qi.Statevector([1, 0])\nqc, q, c = setup_qc(s1, s2)\nresult, success = post_select(qc, q, c, symm=True)\n```", "```py\nqc.draw(output='mpl', plot_barriers=False)\n```", "```py\ns1 = qi.Statevector([0, 1])\ns2 = qi.Statevector([1, 0])\nqc, q, c = setup_qc(s1, s2)\nresult, success = post_select(qc, q, c, symm=False)\n```", "```py\ns1, s2 = init_random()\nqc, q, c = setup_qc(s1, s2)\nresult, success = post_select(qc, q, c, symm=True, swap_test=True)\n```", "```py\ns1, s2 = init_random()\nqc, q, c = setup_qc(s1, s2)\nresult, success = post_select(qc, q, c, symm=False)\n```", "```py\ndef setup1_qc(draw=False):\n  q = QuantumRegister(3, 'q') # register of 3 qubits\n  c = ClassicalRegister(1, name=\"c\") # and 1 classical register\n  qc = QuantumCircuit(q,c)\n  qc.h(q[1])\n  qc.cx(q[1], q[2])\n  qc.barrier()\n  if draw:\n    display(qc.draw(output='mpl'))\n  return qc, q, c\n```", "```py\nqc, q, c = setup1_qc()\nresult, success = post_select(qc, q, c, symm=True)\n```"]