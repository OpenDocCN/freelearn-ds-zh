- en: Chapter 4. Complex ArcPy Scripts and Generalizing Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will move from creating simple scripts based on autogenerated
    scripts from ModelBuilder to complex scripts that incorporate advanced Python
    and ArcPy concepts, such as functions. Functions can improve code and save time
    when writing scripts. They are also useful when creating modules or other reusable
    code, allowing for standard programming operations to be scripted and ready for
    future use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating functions to avoid repeating code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating helper functions to work with ArcPy limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing functions to make them reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python functions–Avoid repeating code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programming languages share a concept that has aided programmers for decades:
    functions. The idea of a function, loosely speaking, is to create blocks of code
    that will perform an action on a piece of data, transforming it as required by
    the programmer and returning the transformed data back to the main body of code.
    We''ve already been introduced to some of Python''s built-in functions in the
    last few chapters, the `int` function, for instance, will convert a string or
    a floating number into an integer; now it''s time to write our own.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are used because they solve many different needs within programming.
    Functions reduce the need to write repetitive code, which in turn reduces the
    time needed to create a script. They can be used to create ranges of numbers (the
    `range()` function), or to determine the maximum value of a list (the `max` function),
    or to create a SQL statement to select a set of rows from a feature class. They
    can even be copied and used in another script or included as part of a module
    that can be imported into scripts. Function reuse has the added bonus of making
    programming more useful and less of a chore. When a scripter starts writing functions,
    it is a major step towards making programming part of a GIS workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Technical definition of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions, also called subroutines or procedures in other programming languages,
    are blocks of code that have been designed to either accept input data and transform
    it, or provide data to the main program when called without any input required.
    In theory, functions will only transform data that has been provided to the function
    as a parameter; it should not change any other part of the script that has not
    been included in the function. To make this possible, the concept of namespaces
    is invoked. As discussed in [Chapter 1](ch01.html "Chapter 1. Introduction to
    Python for ArcGIS"), *Introduction to Python for ArcGIS*, namespaces are used
    to isolate variables within a script; variables are either global, and available
    to be used in the main body of a script as well as in a function, or are local
    and only available within a function.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces make it possible to use a variable name within a function, and allow
    it to represent a value, while also using the same variable name in another part
    of the script. This becomes especially important when importing modules from other
    programmers; within that module and its functions, the variables that it contains
    might have a variable name that is the same as a variable name within the main
    script.
  prefs: []
  type: TYPE_NORMAL
- en: In a high-level programming language such as Python, there is built-in support
    for functions, including the ability to define function names and the data inputs
    (also known as parameters). Functions are created using the keyword `def` plus
    a function name, along with parentheses that may or may not contain parameters.
    Parameters can also be defined with default values, so parameters only need to
    be passed to the function when they differ from the default. The values that are
    returned from the function are also easily defined.
  prefs: []
  type: TYPE_NORMAL
- en: A first function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a function to get a feel for what is possible when writing functions.
    First, we need to invoke the function by providing the `def` keyword and providing
    a name along with the parentheses. The `firstFunction()` will return a string
    when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this function has a documentation string or doc string (a simple
    function returning a string) that describes what the function does; this string
    can be called later to find out what the function does, using the `__doc__` internal
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function is defined and given a name, and then the parentheses are added
    followed by a colon. The following lines must then be indented (a good IDE will
    add the indention automatically). The function does not have any parameters, so
    the parentheses are empty. The function then uses the keyword `return` to return
    a value, in this case a string, from the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the function is called by adding parentheses to the function name. When
    it is called, it will do what it has been instructed to do: return the string.'
  prefs: []
  type: TYPE_NORMAL
- en: Functions with parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s create a function that accepts parameters and transforms them as
    needed. This function will accept a number and multiply it by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function has one flaw, however; there is no assurance that the value passed
    to the function is a number. We need to add a conditional to the function to make
    sure it does not throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function now accepts a parameter, checks what type of data it is, and returns
    a multiple of the parameter whether it is an integer or a function. If it is a
    string or some other data type, as shown in the last example, no value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more adjustment to the simple function that we should discuss:
    parameter defaults. By including default values in the definition of the function,
    we avoid having to provide parameters that rarely change. If, for instance, we
    wanted a different multiplier than 3 in the simple function, we would define it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function will work when only the number to be multiplied is supplied, as
    the multiplier has a default value of 3\. However, if we need another multiplier,
    the value can be adjusted by adding another value when calling the function. Note
    that the second value doesn't have to be a number as there is no type checking
    on it. Also, the default value(s) in a function must follow the parameters with
    no defaults (or all parameters can have a default value and the parameters can
    be supplied to the function in order or by name).
  prefs: []
  type: TYPE_NORMAL
- en: These simple functions combine many of the concepts that we discussed in earlier
    chapters, including built-in functions such as `type`, `conditionals`, `parameters`,
    `parameter defaults`, and `function returns`. We can now move on to creating functions
    with ArcPy.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions to replace repetitive code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main uses of functions is to ensure that the same code does not have
    to be written over and over. Let's return to our example from the last chapter
    and make a function from the script to make it possible to perform the same analysis
    for any bus line in San Francisco.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first portion of the script that we could convert into a function is the
    three ArcPy functions. Doing so will allow the script to be applicable to any
    of the stops in the Bus Stop feature class and have an adjustable buffer distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function demonstrates how the analysis can be adjusted to accept the input
    and output feature class variables as parameters, along with some new variables.
  prefs: []
  type: TYPE_NORMAL
- en: The function adds a variable to replace the SQL statement and variables to adjust
    the bus stop, and also tweaks the buffer distance statement so that both the distance
    and the unit can be adjusted. The feature class name variables, defined earlier
    in the script, have all been replaced with local variable names; while the global
    variable names could have been retained, it reduces the portability of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function will accept the result of the `selectBufferIntersect()` function
    and search it using the Search Cursor, passing the results into a dictionary.
    The dictionary will then be returned from the function for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function only requires one parameter: the feature class returned from
    the `searchBufferIntersect()` function. The results holding dictionary is first
    created, then populated by the search cursor, with the `busStopid` attribute used
    as a key, and the census block population attribute added to a list assigned to
    the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary, having been populated with sorted data, is returned from the
    function for use in the final function, `createCSV()`. This function accepts the
    dictionary and the name of the output CSV file as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The final function creates the CSV using the `csv` module. The name of the file,
    a string, is now a customizable parameter (meaning the script name can be any
    valid file path and text file with the extension `.csv`). The `csvfile` parameter
    is passed to the CSV module's writer method and assigned to the variable `csvwriter`,
    and the dictionary is accessed and processed, and passed as a list to `csvwriter`
    to be written to the `CSV` file. The `csv.writer()` method processes each item
    in the list into the CSV format and saves the final result. Open the `CSV` file
    with Excel or a text editor such as Notepad.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the functions, we will call them in the script following the function
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the script has been divided into three functions, which replace the code
    of the first modified script. The modified script looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Further generalization of the functions, while we have created functions from
    the original script that can be used to extract more data about bus stops in San
    Francisco, our new functions are still very specific to the dataset and analysis
    for which they were created. This can be very useful for long and laborious analysis
    for which creating reusable functions is not necessary. The first use of functions
    is to get rid of the need to repeat code. The next goal is to then make that code
    reusable. Let's discuss some ways in which we can convert the functions from one-offs
    into reusable functions or even modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s examine the first function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function appears to be pretty specific to the bus stop analysis. It's so
    specific, in fact, that while there are a few ways in which we can tweak it to
    make it more general (that is, useful in other scripts that might not have the
    same steps involved), we should not convert it into a separate function. When
    we create a separate function, we introduce too many variables into the script
    in an effort to simplify it, which is a counterproductive effort. Instead, let's
    focus on ways to generalize the ArcPy tools themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The first step will be to split the three ArcPy tools and examine what can be
    adjusted with each of them. The Select tool should be adjusted to accept a string
    as the SQL select statement. The SQL statement can then be generated by another
    function or by parameters accepted at runtime (for example, passed to the script
    by a Script tool, which will be discussed in a later chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we wanted to make the script accept multiple bus stops for
    each run of the script (for example, the inbound and outbound stops for each line),
    we could create a function that would accept a list of the desired stops and a
    SQL template, and would return a SQL statement to plug into the Select tool. Here
    is an example of how it would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This new function, `formatSQL()`, is a very useful function. Let''s review
    what it does by comparing the function to the results following it. The function
    is defined to accept two parameters: a list of values and a SQL template. The
    first local variable is the empty string `sql,` which will be added to using string
    addition. The function is designed to insert the values into the variable `sql`,
    creating a SQL statement by taking the SQL template and using string formatting
    to add them to the template, which in turn is added to the SQL statement string
    (note that `sql +=` is equivelent to `sql = sql +`). Also, an operator (`OR`)
    is used to make the SQL statement inclusive of all data rows that match the pattern.
    This function uses the built-in enumerate function to count the iterations of
    the list; once it has reached the last value in the list, the operator is not
    added to the SQL statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we could also add one more parameter to the function to make it possible
    to use an `AND` operator instead of `OR`, while still keeping `OR` as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'While it would make no sense to use an `AND` operator on ObjectIDs, there are
    other cases where it would make sense, hence leaving `OR` as the default while
    allowing for `AND`. Either way, this function can now be used to generate our
    bus stop SQL statement for multiple stops (ignoring, for now, the bus signage
    field):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can''t ignore the Bus Signage field for the inbound line, as there
    are two starting points for the line, so we will need to adjust the function to
    accept multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The slight difference in this function, the asterisk before the data variable,
    allows the values inside the data variable to be correctly formatted into the
    SQL template by exploding the values within the tuple. Notice that the SQL template
    has been created to segregate each conditional by using parentheses. The function(s)
    are now ready for reuse, and the SQL statement is now ready for insertion into
    the Select tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next up is the Buffer tool. We have already taken steps towards making it generalized
    by adding a variable for the distance. In this case, we will only add one more
    variable to it, a unit variable that will make it possible to adjust the buffer
    unit from feet to meter or any other allowed unit. We will leave the other defaults
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an adjusted version of the Buffer tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, both the buffer distance and buffer unit are controlled by a variable defined
    in the previous script, and this will make it easily adjustable if it is decided
    that the distance was not sufficient and the variables might need to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step towards adjusting the ArcPy tools is to write a function, which
    will allow for any number of feature classes to be intersected together using
    the Intersect tool. This new function will be similar to the `formatSQL` functions
    as previous, as they will use string formatting and addition to allow for a list
    of feature classes to be processed into the correct string format for the Intersect
    tool to accept them. However, as this function will be built to be as general
    as possible, it must be designed to accept any number of feature classes to be
    intersected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have written the `formatIntersect()` function, all that needs to
    be created is a list of the feature classes to be passed to the function. The
    string returned by the function can then be passed to the Intersect tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because we avoided creating a function that only fits this script or analysis,
    we now have two (or more) useful functions that can be applied in later analyses,
    and we know how to manipulate the ArcPy tools to accept the data that we want
    to supply to them.
  prefs: []
  type: TYPE_NORMAL
- en: More generalization of the functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other functions that we initially created to search the results, and generate
    the spreadsheet of results, can also be manipulated into being more generalized
    with a few tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to generate more information about each census block within a distance
    to a bus stop (for example, if we had a census block dataset with income data
    as well as population data), we would pass to the function a list of attributes
    to be extracted from the final feature class. To make this possible, it would
    be necessary to adjust the `createResultDic()` function to accept this list of
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This new version of the `createResultDic()` function will generate a list of
    lists (that is, the values from each row are contained within a list and are added
    to a master list) for each bus stop, which can then be parsed later by knowing
    the position of each value in the list. This solution is useful when needing to
    sort data into a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is an unsatisfactory way to sort the results. What if the list
    of fields is not passed on to the dictionary and there is no way of knowing the
    order of the data in the lists? Instead, we want to be able to use the functionality
    of Python dictionaries to sort the data by field name. In this case, we will use
    nested dictionaries to create lists of results accessible by the type of data
    they contain (that is, population, income, or another field):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the function is passed as parameters to a feature class, the
    `STOPID`, and the fields to be conglomerated. The `fields` variable is created
    to pass the required fields on to the Search Cursor. The cursor returns each row
    as a tuple; the first member of the tuple is `busStopID`, and the rest of the
    tuple is the data associated with that bus stop. The function then uses a condition
    to assess whether the bus stop has been previously analyzed; if not, it is added
    to the dictionary and assigned a second internal dictionary, which will be used
    to store the results associated with that stop. By using a dictionary, we can
    then sort through the results and assign them to the correct field to which they
    belong.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example shows the results of requesting data for one particular
    bus stop (`1122023`). As there are two fields passed here, the data has been organized
    into two sets, and the field names are now keys for the internal dictionary. Because
    of this organization, we can now create averages for each field instead of just
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of averages, we left the job of averaging the results of the search
    cursor analysis to the `createCSV()` function. This should also be avoided, as
    it reduces the usefulness of the `createCSV()` function by adding additional data
    manipulation duties that should be the responsibility of another function. Let''s
    address this issue by adjusting the `createCSV()` function first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a stripped down version of the function, but it is infinitely more
    useful. By adjusting the function like this, we are limiting it to only doing
    two things: opening the CSV file and adding a row of data to it. Because we used
    the `ab` mode, if the CSV file exists, we will only be adding data to it instead
    of writing over it (if it doesn''t exist, it will be created). This adding mode
    can be overridden by passing `wb` as the mode, which will generate a new script
    each time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can sort through the results of the analysis, average them, and pass
    them to our new `createCSV` script. To do this, we will iterate through the dictionary
    created by the `createResultDic()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This last step shows how the CSV file is created: by iterating through the
    data contained in the dictionary and then averaging the values for each bus stop.
    Then, these averages are added to a list that contains the name of each bus stop
    (and the line it belongs to in this instance) and passed to the `createCSV()`
    function to be written into the `CSV` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final code. Note that I have converted many of the autogenerated
    comments into print statements to give some feedback on the state of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to take autogenerated code and make it generalized,
    while adding functions that can be reused in other scripts and will make the generation
    of the necessary code components, such as SQL statements, much easier. We also
    addressed when it is best not to go too far with the creation of functions to
    avoid making them too specific.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will investigate the powerful Data Access module and
    its Search Cursors, Update Cursors, and Insert Cursors.
  prefs: []
  type: TYPE_NORMAL
