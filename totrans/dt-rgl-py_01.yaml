- en: '*Chapter 1*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*'
- en: Introduction to Data Wrangling with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数据整理简介
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下几件事情：
- en: Define the importance of data wrangling in data science
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据整理在数据科学中的重要性
- en: Manipulate the data structures that are available in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作Python中可用的数据结构
- en: Compare the different implementations of the inbuilt Python data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较内置Python数据结构的不同实现
- en: This chapter describes the importance of data wrangling, identifies the important
    tasks to be performed in data wrangling, and introduces basic Python data structures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了数据整理的重要性，确定了数据整理中要执行的重要任务，并介绍了基本的Python数据结构。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: Data science and analytics are taking over the whole world and the job of a
    data scientist is routinely being called the coolest job of the 21st century.
    But for all the emphasis on data, it is the science that makes you – the practitioner
    – truly valuable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学和分析正在接管整个世界，数据科学家的职位通常被称为21世纪最酷的工作。但尽管对数据的强调，是科学使你——实践者——真正有价值。
- en: 'To practice high-quality science with data, you need to make sure it is properly
    sourced, cleaned, formatted, and pre-processed. This book teaches you the most
    essential basics of this invaluable component of the data science pipeline: data
    wrangling. In short, data wrangling is the process that ensures that the data
    is in a format that is clean, accurate, formatted, and ready to be used for data
    analysis.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要用高质量的科学数据进行实践，你需要确保数据来源正确、清洗、格式化和预处理。这本书教你这个数据科学流程中无价组件的最基本基础知识：数据整理。简而言之，数据整理是确保数据以干净、准确、格式化且准备好用于数据分析的格式的流程。
- en: A prominent example of data wrangling with a large amount of data is the one
    conducted at the Supercomputer Center of University of California San Diego (UCSD).
    The problem in California is that wildfires are very common, mainly because of
    the dry weather and extreme heat, especially during the summers. Data scientists
    at the UCSD Supercomputer Center gather data to predict the nature and spread
    direction of the fire. The data that comes from diverse sources such as weather
    stations, sensors in the forest, fire stations, satellite imagery, and Twitter
    feeds might still be incomplete or missing. This data needs to be cleaned and
    formatted so that it can be used to predict future occurrences of wildfires.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理的一个显著例子是在加州大学圣地亚哥分校（UCSD）超级计算中心进行的。在加利福尼亚，野火非常常见，主要是因为干旱的天气和极端的高温，尤其是在夏季。UCSD超级计算中心的数据科学家收集数据来预测火灾的性质和蔓延方向。来自气象站、森林中的传感器、消防站、卫星图像和Twitter流的数据可能仍然是不完整或缺失的。这些数据需要被清洗和格式化，以便用于预测未来野火的发生。
- en: This is an example of how data wrangling and data science can prove to be helpful
    and relevant.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个数据整理和数据科学如何证明是有帮助和相关的例子。
- en: Importance of Data Wrangling
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据整理的重要性
- en: Oil does not come in its final form from the rig; it has to be refined. Similarly,
    data must be curated, massaged, and refined to be used in intelligent algorithms
    and consumer products. This is known as wrangling. Most data scientists spend
    the majority of their time data wrangling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 石油不是从钻井平台直接以最终形式出现的；它必须经过提炼。同样，数据必须经过整理、按摩和提炼，才能用于智能算法和消费产品。这被称为整理。大多数数据科学家将大部分时间花在数据整理上。
- en: Data wrangling is generally done at the very first stage of a data science/analytics
    pipeline. After the data scientists identify useful data sources for solving the
    business problem (for instance, in-house database storage or internet or streaming
    sensor data), they then proceed to extract, clean, and format the necessary data
    from those sources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理通常是在数据科学/分析流程的第一个阶段进行的。在数据科学家确定了用于解决业务问题的有用数据源（例如，内部数据库存储或互联网或流式传感器数据）之后，他们接着从这些来源提取、清洗和格式化必要的数据。
- en: 'Generally, the task of data wrangling involves the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据整理的任务包括以下步骤：
- en: Scraping raw data from multiple sources (including web and database tables)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个来源（包括网页和数据库表）抓取原始数据
- en: Imputing, formatting, and transforming – basically making it ready to be used
    in the modeling process (such as advanced machine learning)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充、格式化和转换——基本上是使其准备好用于建模过程（如高级机器学习）
- en: Handling read/write errors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理读写错误
- en: Detecting outliers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测异常值
- en: Performing quick visualizations (plotting) and basic statistical analysis to
    judge the quality of your formatted data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行快速的可视化（绘图）和基本统计分析，以判断您整理后的数据质量
- en: 'This is an illustrative representation of the positioning and essential functional
    role of data wrangling in a typical data science pipeline:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对数据整理在典型数据科学流程中的定位和基本功能角色的说明性表示：
- en: '![Figure 1.1: Process of data wrangling](img/Figure_1.1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：数据整理过程](img/Figure_1.1.jpg)'
- en: 'Figure 1.1: Process of data wrangling'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.1：数据整理过程
- en: The process of data wrangling includes first finding the appropriate data that's
    necessary for the analysis. This data can be from one or multiple sources, such
    as tweets, bank transaction statements in a relational database, sensor data,
    and so on. This data needs to be cleaned. If there is missing data, we will either
    delete or substitute it, with the help of several techniques. If there are outliers,
    we need to first detect them and then handle them appropriately. If data is from
    multiple sources, we will have to perform join operations to combine it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据整理的过程首先是要找到分析所需的数据。这些数据可能来自一个或多个来源，例如推文、关系型数据库中的银行交易报表、传感器数据等等。这些数据需要被清理。如果有缺失数据，我们将使用几种技术中的任何一种来删除或替换它。如果有异常值，我们首先需要检测它们，然后适当地处理它们。如果数据来自多个来源，我们将不得不执行连接操作来合并它们。
- en: In an extremely rare situation, data wrangling may not be needed. For example,
    if the data that's necessary for a machine learning task is already stored in
    an acceptable format in an in-house database, then a simple SQL query may be enough
    to extract the data into a table, ready to be passed on to the modeling stage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其罕见的情况下，可能不需要进行数据整理。例如，如果机器学习任务所需的数据已经以可接受格式存储在内部数据库中，那么一个简单的 SQL 查询可能就足够将数据提取到表格中，以便传递到建模阶段。
- en: Python for Data Wrangling
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于数据整理的 Python
- en: 'There is always a debate on whether to perform the wrangling process using
    an enterprise tool or by using a programming language and associated frameworks.
    There are many commercial, enterprise-level tools for data formatting and pre-processing
    that do not involve much coding on the part of the user. These examples include
    the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有人争论是否应该使用企业工具还是使用编程语言及其相关框架来进行数据整理过程。有许多商业级的企业工具用于数据格式化和预处理，用户不需要编写太多代码。以下是一些例子：
- en: General purpose data analysis platforms such as Microsoft Excel (with add-ins)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用数据分析平台，如 Microsoft Excel（带插件）
- en: Statistical discovery package such as **JMP** (from SAS)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计发现包，如 **JMP**（来自 SAS）
- en: Modeling platforms such as **RapidMiner**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模平台，如 **RapidMiner**
- en: Analytics platforms from niche players focusing on data wrangling, such as **Trifacta**,
    **Paxata**, and **Alteryx**
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于数据整理的利基玩家提供的分析平台，如 **Trifacta**、**Paxata** 和 **Alteryx**
- en: However, programming languages such as Python provide more flexibility, control,
    and power compared to these off-the-shelf tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与这些现成的工具相比，像 Python 这样的编程语言提供了更多的灵活性、控制和功能。
- en: 'As the volume, velocity, and variety (the three Vs of **big data**) of data
    undergo rapid changes, it is always a good idea to develop and nurture a significant
    amount of in-house expertise in data wrangling using fundamental programming frameworks
    so that an organization is not beholden to the whims and fancies of any enterprise
    platform for as basic a task as data wrangling:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据量、速度和多样性（大数据的三个 V）的快速变化，始终发展并培养大量内部数据整理专业知识，使用基本的编程框架，这样组织就不会对任何企业平台的基本任务——数据整理——产生依赖，这是一个很好的主意：
- en: '![Figure 1.2: Google trend worldwide over the last 5 years](img/Figure_1.2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：过去 5 年全球 Google 趋势](img/Figure_1.2.jpg)'
- en: 'Figure 1.2: Google trend worldwide over the last Five years'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.2：过去五年全球 Google 趋势
- en: 'A few of the obvious advantages of using an open source, free programming paradigm
    such as Python for data wrangling are the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开源、免费编程范式（如 Python）进行数据整理的一些明显优势如下：
- en: General purpose open source paradigm putting no restriction on any of the methods
    you can develop for the specific problem at hand
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用开源范式不对您为特定问题开发的方法施加任何限制
- en: Great ecosystem of fast, optimized, open source libraries, focused on data analytics
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速、优化、开源库的卓越生态系统，专注于数据分析
- en: Growing support to connect Python to every conceivable data source type
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越来越多的支持将 Python 连接到所有可能的数据源类型
- en: Easy interface to basic statistical testing and quick visualization libraries
    to check data quality
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用的基本统计测试和快速可视化库来检查数据质量
- en: Seamless interface of the data wrangling output with advanced machine learning
    models
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据处理输出与高级机器学习模型的无缝接口
- en: Python is the most popular language of choice of machine learning and artificial
    intelligence these days.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python是目前机器学习和人工智能最受欢迎的选择语言。
- en: Lists, Sets, Strings, Tuples, and Dictionaries
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表、集合、字符串、元组和字典
- en: Now that we have learned the importance of Python, we will start by exploring
    various basic data structures in Python. We will learn techniques to handle data.
    This is invaluable for a data practitioner.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了Python的重要性，我们将从探索Python中的各种基本数据结构开始。我们将学习处理数据的技术。这对数据从业者来说是无价的。
- en: 'We can issue the following command to start a new Jupyter server by typing
    the following in to the Command Prompt window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在命令提示符窗口中输入以下命令来启动一个新的Jupyter服务器：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will start a jupyter server and you can visit it at [`http://localhost:8888`](http://localhost:8888)
    and use the passcode `dw_4_all` to access the main interface.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个jupyter服务器，您可以在`[`http://localhost:8888](http://localhost:8888)`访问它，并使用密码`dw_4_all`访问主界面。
- en: Lists
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are fundamental Python data structures that have continuous memory locations,
    can host different data types, and can be accessed by the index.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是具有连续内存位置的Python基本数据结构，可以容纳不同的数据类型，并且可以通过索引进行访问。
- en: We will start with a list and list comprehension. We will generate a list of
    numbers, and then examine which ones among them are even. We will sort, reverse,
    and check for duplicates. We will also see how many different ways we can access
    the list elements, iterating over them and checking the membership of an element.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从列表和列表推导式开始。我们将生成一个数字列表，然后检查其中哪些是偶数。我们将进行排序、反转和检查重复项。我们还将看到我们可以以多少种不同的方式访问列表元素，遍历它们并检查元素的成员资格。
- en: 'The following is an example of a simple list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单列表的例子：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is also an example of a list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也是一个列表的例子：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, a list can contain any number of the allowed datatype, such
    as `int`, `float`, `string`, and `Boolean`, and a list can also be a mix of different
    data types (including nested lists).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表可以包含任何数量的允许的数据类型，如`int`、`float`、`string`和`Boolean`，列表也可以是不同数据类型的混合（包括嵌套列表）。
- en: If you are coming from a strongly typed language, such as C, C++, or Java, then
    this will probably be strange as you are not allowed to mix different kinds of
    data types in a single array in those languages. Lists are somewhat like arrays,
    in the sense that they are both based on continuous memory locations and can be
    accessed using indexes. But the power of Python lists come from the fact that
    they can host different data types and you are allowed to manipulate the data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自强类型语言，如C、C++或Java，那么这可能会让你感到奇怪，因为在那些语言中不允许在单个数组中混合不同的数据类型。列表在某种程度上类似于数组，因为它们都是基于连续内存位置的，并且可以使用索引进行访问。但Python列表的力量在于它们可以容纳不同的数据类型，并且允许你操作数据。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful, though, as the very power of lists, and the fact that you can mix
    different data types in a single list, can actually create subtle bugs that can
    be very difficult to track.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，但列表的强大功能和你可以混合不同数据类型的事实，实际上可能会创建微妙的错误，这些错误可能非常难以追踪。
- en: 'Exercise 1: Accessing the List Members'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：访问列表成员
- en: 'In the following exercise, we will be creating a list and then observing the
    different ways of accessing the elements:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将创建一个列表，然后观察访问元素的不同方式：
- en: 'Define a list called `list_1` with four integer members, using the following
    command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令定义一个名为`list_1`的列表，包含四个整数成员：
- en: '[PRE3]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The indices will be automatically assigned, as follows:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 索引将自动分配，如下所示：
- en: '![Figure 1.3: List showing the forward and backward indices](img/Figure_1.3.jpg)'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图1.3：显示正向和反向索引的列表](img/Figure_1.3.jpg)'
- en: 'Figure 1.3: List showing the forward and backward indices'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：显示正向和反向索引的列表
- en: 'Access the first element from `list_1` using its forward index:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引从`list_1`中访问第一个元素：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Access the last element from `list_1` using its forward index:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引从`list_1`中访问最后一个元素：
- en: '[PRE5]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Access the last element from `list_1` using the `len` function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`len`函数从`list_1`中访问最后一个元素：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `len` function in Python returns the length of the specified list.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python中的`len`函数返回指定列表的长度。
- en: 'Access the last element from `list_1` using its backward index:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其反向索引从`list_1`中访问最后一个元素：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Access the first three elements from `list_1` using forward indices:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正向索引从`list_1`中访问前三个元素：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is also called list slicing, as it returns a smaller list from the original
    list by extracting only, a part of it. To slice a list, we need two integers.
    The first integer will denote the start of the slice and the second integer will
    denote the end-1 element.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也被称为列表切片，因为它通过仅提取列表的一部分来从原始列表中返回一个较小的列表。要切片一个列表，我们需要两个整数。第一个整数将表示切片的开始，第二个整数将表示结束-1的元素。
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that slicing did not include the third index or the end element. This
    is how list slicing works.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意切片没有包括第三个索引或结束元素。这就是列表切片的工作方式。
- en: 'Access the last two elements from `list_1` by slicing:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过切片从`list_1`中访问最后两个元素：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Access the first two elements using backward indices:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用反向索引访问前两个元素：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When we leave one side of the colon (`:`) blank, we are basically telling Python
    either to go until the end or start from the beginning of the list. It will automatically
    apply the rule of list slices that we just learned.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在冒号（`:`）的一侧留空时，我们基本上是在告诉Python要么走到列表的末尾，要么从列表的开始处开始。它将自动应用我们刚刚学到的列表切片规则。
- en: 'Reverse the elements in the string:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转字符串中的元素：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The last bit of code is not very readable, meaning it is not obvious just by
    looking at it what it is doing. It is against Python's philosophy. So, although
    this kind of code may look clever, we should resist the temptation to write code
    like this.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一行代码的可读性不是很好，这意味着仅通过查看它并不能明显知道它在做什么。这与Python的哲学相悖。因此，尽管这种代码可能看起来很聪明，但我们应该抵制写这种代码的诱惑。
- en: 'Exercise 2: Generating a List'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：生成列表
- en: 'We are going to examine various ways of generating a list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查生成列表的各种方法：
- en: 'Create a list using the `append` method:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`append`方法创建一个列表：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we started by declaring an empty list and then we used a `for` loop to
    append values to it. The `append` method is a method that's given to us by the
    Python list data type.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明了一个空列表，然后使用一个`for`循环向其中添加值。`append`方法是由Python列表数据类型提供给我们的一种方法。
- en: 'Generate a list using the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成一个列表：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The partial output is as follows:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分输出如下：
- en: '![Figure 1.4: List comprehension](img/Figure_1.4.jpg)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图1.4：列表推导式](img/Figure_1.4.jpg)'
- en: 'Figure 1.4: List comprehension'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：列表推导式
- en: This is list comprehension, which is a very powerful tool that we need to master.
    The power of list comprehension comes from the fact that we can use conditionals
    inside the comprehension itself.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是列表推导式，这是一种非常强大的工具，我们需要掌握。列表推导式的强大之处在于我们可以在推导式内部使用条件语句。
- en: 'Use a `while` loop to iterate over a list to understand the difference between
    a `while` loop and a `for` loop:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`while`循环遍历一个列表以理解`while`循环和`for`循环之间的区别：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The partial output will be as follows:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分输出将如下所示：
- en: '![Figure 1.5: Output showing the contents of list_1 using a while loop](img/Figure_1.5.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图1.5：使用`while`循环显示`list_1`内容的输出](img/Figure_1.5.jpg)'
- en: 'Figure 1.5: Output showing the contents of list_1 using a while loop'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.5：使用`while`循环显示`list_1`内容的输出
- en: 'Create `list_3` with numbers that are divisible by `5`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含能被`5`整除的数字的`list_3`：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output will be a list of numbers up to 100 in increments of 5:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将是一个包含从1到100，增量为5的数字的列表：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Generate a list by adding the two lists:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加两个列表来生成一个列表：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Extend a string using the extend keyword:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`extend`关键字扩展字符串：
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The partial output is as follows:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分输出如下所示：
- en: '![](img/C11065_01_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11065_01_06.jpg)'
- en: 'Figure 1.6: Contents of list_1'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：`list_1`的内容
- en: The second operation changes the original list (list_1) and appends all the
    elements of list_2 to it. So, be careful when using it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个操作会改变原始列表（`list_1`），并将`list_2`的所有元素追加到它上面。所以使用时要小心。
- en: 'Exercise 3: Iterating over a List and Checking Membership'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：遍历列表并检查成员资格
- en: 'We are going to iterate over a list and test whether a certain value exists
    in it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遍历一个列表并测试某个值是否存在于其中：
- en: 'Iterate over a list:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历一个列表：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 1.7: Section of list_1](img/Figure_1.7.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图1.7：`list_1`的部分](img/Figure_1.7.jpg)'
- en: 'Figure 1.7: Section of list_1'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：`list_1`的部分
- en: 'However, it is not very Pythonic. Being Pythonic is to follow and conform to
    a set of best practices and conventions that have been created over the years
    by thousands of very able developers, which in this case means to use the `in`
    keyword, because Python does not have index initialization, bounds checking, or
    index incrementing, unlike traditional languages. The Pythonic way of iterating
    over a list is as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这并不太符合 Python 风格。符合 Python 风格意味着遵循和遵守多年来由数千名非常能干的开发者创建的一系列最佳实践和约定，在这种情况下意味着使用
    `in` 关键字，因为 Python 没有索引初始化、边界检查或索引递增，这与传统语言不同。在 Python 中遍历列表的方式如下：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.8: Section of the list list_1](img/Figure_1.8.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 1.8：list_1 的部分](img/Figure_1.8.jpg)'
- en: 'Figure 1.8: A section of list_1'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.8：list_1 的一个部分
- en: Notice that, in the second method, we do not need a counter anymore to access
    the list index; instead, Python's `in` operator gives us the element at the *i*
    th position directly.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在第二种方法中，我们不再需要计数器来访问列表索引；相反，Python 的 `in` 操作符直接给出第 *i* 个位置的元素。
- en: 'Check whether the integers 25 and -45 are in the list using the `in` operator:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符检查整数 25 和 -45 是否在列表中：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output is **True.**
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出为 **True**。
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is **False.**
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出为 **False**。
- en: 'Exercise 4: Sorting a List'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：排序列表
- en: 'We generated a list called `list_1` in the previous exercise. We are going
    to sort it now:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们生成了一个名为 `list_1` 的列表。我们现在将对其进行排序：
- en: 'As the list was originally a list of numbers from `0` to `99`, we will sort
    it in the reverse direction. To do that, we will use the `sort` method with `reverse=True`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于原始列表是一个从 `0` 到 `99` 的数字列表，我们将按相反方向对其进行排序。为此，我们将使用带有 `reverse=True` 的 `sort`
    方法：
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The partial output is as follows:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分输出如下：
- en: '![](img/Figure_1.9.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 1.9.jpg](img/Figure_1.9.jpg)'
- en: 'Figure 1.9: Section of output showing the reversed list'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.9：显示反转列表的输出部分
- en: 'We can use the `reverse` method directly to achieve this result:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接使用 `reverse` 方法来达到这个结果：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 1.10: Section of output after reversing the string](img/Figure_1.91.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10：反转字符串后的输出部分](img/Figure_1.91.jpg)'
- en: 'Figure 1.10: Section of output after reversing the string'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.10：反转字符串后的输出部分
- en: Note
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between the sort function and the reverse function is the fact
    that we can use sort with custom sorting functions to do custom sorting, whereas
    we can only use reverse to reverse a list. Here also, both the functions work
    in-place, so be aware of this while using them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 函数和 `reverse` 函数之间的区别在于，我们可以使用 `sort` 与自定义排序函数一起进行自定义排序，而 `reverse`
    只能用来反转列表。在这里，这两个函数都是在原地工作的，所以使用时请注意这一点。'
- en: 'Exercise 5: Generating a Random List'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 5：生成随机列表
- en: 'In this exercise, we will be generating a `list` with random numbers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将生成一个包含随机数字的 `list`：
- en: 'Import the `random` library:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `random` 库：
- en: '[PRE27]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the `randint` function to generate random integers and add them to a list:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `randint` 函数生成随机整数并将它们添加到列表中：
- en: '[PRE28]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Print the list using `print(list_1)`. Note that there will be duplicate values
    in `list_1`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `print(list_1)` 打印列表。注意，`list_1` 中将有重复的值：
- en: '[PRE29]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The sample output is as follows:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 样本输出如下：
- en: '![](img/Figure_1.11.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11.jpg](img/Figure_1.11.jpg)'
- en: 'Figure 1.11: Section of the sample output for list_1'
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.11：样本输出中 list_1 的部分
- en: There are many ways to get a list of unique numbers, and while you may be able
    to write a few lines of code using a for loop and another list (you should actually
    try doing it!), let's see how we can do this without a for loop and with a single
    line of code. This will bring us to the next data structure, sets.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 获取唯一数字列表的方法有很多，虽然你可能能够通过使用循环和另一个列表写几行代码来实现（你应该实际尝试一下！），但让我们看看如何在不使用循环和单行代码的情况下完成这个任务。这将带我们到下一个数据结构，集合。
- en: 'Activity 1: Handling Lists'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 1：处理列表
- en: In this activity, we will generate a `list` of random numbers and then generate
    another `list` from the first one, which only contains numbers that are divisible
    by three. Repeat the experiment three times. Then, we will calculate the average
    difference of length between the two lists.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将生成一个随机数字的 `list`，然后从这个 `list` 中生成另一个 `list`，它只包含能被三整除的数字。重复实验三次。然后，我们将计算两个列表长度平均差异。
- en: 'These are the steps for completing this activity:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Create a `list` of 100 random numbers.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 100 个随机数字的 `list`。
- en: Create a new `list` from this random `list`, with numbers that are divisible
    by *3*.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个随机 `list` 中创建一个新的 `list`，包含能被 *3* 整除的数字。
- en: Calculate the length of these two lists and store the difference in a new variable.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这两个列表的长度，并将差值存储在一个新变量中。
- en: Using a loop, perform steps 2 and 3 and find the difference variable three times.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环，执行步骤 2 和 3，并找到差值变量三次。
- en: Find the arithmetic mean of these three difference values.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这三个差值的算术平均值。
- en: Note
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 282.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 282 页找到。
- en: Sets
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: A set, mathematically speaking, is just a collection of well-defined distinct
    objects. Python gives us a straightforward way to deal with them using its `set`
    datatype.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，集合仅仅是一组定义明确的、不同的对象集合。Python 通过其 `set` 数据类型为我们提供了一种直接处理它们的方法。
- en: Introduction to Sets
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合简介
- en: 'With the last list that we generated, we are going to revisit the problem of
    getting rid of duplicates from it. We can achieve that with the following line
    of code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们生成的最后一个列表，我们将重新审视从其中去除重复元素的问题。我们可以通过以下代码行来实现：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we print this, we will see that it only contains unique numbers. We used
    the `set` data type to turn the first list into a set, thus getting rid of all
    duplicate elements, and then we used the `list` function on it to turn it into
    a list from a set once more:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出来，我们会看到它只包含唯一的数字。我们使用了 `set` 数据类型将第一个列表转换成集合，从而去除所有重复的元素，然后我们再次使用 `list`
    函数将其从集合转换回列表：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output will be as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '![Figure 1.12: Section of output for list_21](img/Figure_1.12.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12：list_21 输出的部分](img/Figure_1.12.jpg)'
- en: 'Figure 1.12: Section of output for list_21'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.12：list_21 输出的部分
- en: Union and Intersection of Sets
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合的并集和交集
- en: 'This is what a union between two sets looks like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是两个集合之间的并集看起来：
- en: '![Figure 1.13: Venn diagram showing union of two sets](img/Figure_1.13.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13：展示两个集合并集的维恩图](img/Figure_1.13.jpg)'
- en: 'Figure 1.13: Venn diagram showing the union of two sets'
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.13：展示两个集合并集的维恩图
- en: This simply means take everything from both sets but take the common elements
    only once.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅意味着从两个集合中取出所有元素，但只取共有元素一次。
- en: 'We can create this using the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码创建它：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To find the union of the two sets, the following instructions should be used:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到两个集合的并集，应使用以下指令：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output would be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that the common element, Banana, appears only once in the resulting
    set. The common elements between two sets can be identified by obtaining the intersection
    of the two sets, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果集中共有的元素，香蕉，只出现一次。两个集合之间的共有元素可以通过获取两个集合的交集来识别，如下所示：
- en: '![Figure 1.14: Venn diagram showing intersection of two sets](img/Figure_1.14.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14：展示两个集合交集的维恩图](img/Figure_1.14.jpg)'
- en: 'Figure 1.14: Venn diagram showing the intersection of two sets'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.14：展示两个集合交集的维恩图
- en: 'We get the intersection of two sets in Python as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们通过以下方式获取两个集合的交集：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will give us a set with only one element. The output is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个只包含一个元素的集合。输出如下：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also calculate the difference between sets (also known as complements).
    To find out more, refer to this link: [https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以计算集合之间的差（也称为补集）。要了解更多信息，请参阅此链接：[https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets)。
- en: Creating Null Sets
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建空集
- en: 'You can create a null set by creating a set containing no elements. You can
    do this by using the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个不包含任何元素的集合来创建一个空集。你可以通过以下代码来完成：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, to create a dictionary, use the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要创建字典，请使用以下命令：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We are going to learn about this in detail in the next topic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个主题中详细介绍这一点。
- en: Dictionary
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: A dictionary is like a list, which means it is a collection of several elements.
    However, with the dictionary, it is a collection of key-value pairs, where the
    key can be anything that can be hashed. Generally, we use numbers or strings as
    keys.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 字典就像一个列表，这意味着它是一个包含几个元素的集合。然而，在字典中，它是一个包含键值对的集合，其中键可以是任何可以散列的东西。通常，我们使用数字或字符串作为键。
- en: 'To create a dictionary, use the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建字典，请使用以下代码：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is also a valid dictionary:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个有效的字典：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The keys must be unique in a dictionary.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的键必须是唯一的。
- en: 'Exercise 6: Accessing and Setting Values in a Dictionary'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 6：在字典中访问和设置值
- en: 'In this exercise, we are going to access and set values in a dictionary:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将访问和设置字典中的值：
- en: 'Access a particular key in a dictionary:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字典中的特定键：
- en: '[PRE45]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will return the value associated with it as follows:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回与之关联的值，如下所示：
- en: '[PRE46]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Assign a new value to the key:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为键分配新值：
- en: '[PRE47]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a blank dictionary and then use the key notation to assign values to
    it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个空字典，然后使用键记法向它赋值：
- en: '[PRE48]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Exercise 7: Iterating Over a Dictionary'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 7：遍历字典
- en: 'In this exercise, we are going to iterate over a dictionary:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将遍历一个字典：
- en: 'Create `dict_1`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `dict_1`：
- en: '[PRE50]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the looping variables `k` and `v`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环变量 `k` 和 `v`：
- en: '[PRE51]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the difference between how we did the iteration on the list and how we
    are doing it here.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们在列表上迭代的方式和这里的方式之间的区别。
- en: 'Exercise 8: Revisiting the Unique Valued List Problem'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 8：重新审视唯一值列表问题
- en: 'We will use the fact that dictionary keys cannot be duplicated to generate
    the unique valued list:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用字典键不能重复的事实来生成具有唯一值的列表：
- en: 'First, generate a random list with duplicate values:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，生成一个具有重复值的随机列表：
- en: '[PRE53]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a unique valued list from `list_1`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `list_1` 创建一个具有唯一值的列表：
- en: '[PRE54]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The sample output is as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 样本输出如下：
- en: '![](img/Image51881.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Image51881.jpg)'
- en: 'Figure 1.15: Output showing the unique valued list'
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1.15：显示唯一值列表的输出
- en: Here, we have used two useful functions on the dict data type in Python, `fromkeys`
    and `keys`. `fromkeys` creates a dict where the keys come from the `iterable`
    (in this case, which is a list), values default to None, and `keys` give us the
    keys of a dict.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Python 中 dict 数据类型的两个有用函数，`fromkeys` 和 `keys`。`fromkeys` 创建一个字典，其中键来自
    `iterable`（在这种情况下，是一个列表），值默认为 None，而 `keys` 给我们字典的键。
- en: 'Exercise 9: Deleting Value from Dict'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 9：从字典中删除值
- en: 'In this exercise, we are going to delete a value from a `dict`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从一个 `dict` 中删除一个值：
- en: 'Create `list_1` with five elements:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含五个元素的 `list_1`：
- en: '[PRE55]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE56]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We will use the `del` function and specify the element:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `del` 函数并指定元素：
- en: '[PRE57]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE58]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `del` operator can be used to delete a specific index from a list as well.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`del` 操作符也可以用来从列表中删除特定索引。'
- en: 'Exercise 10: Dictionary Comprehension'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 10：字典理解
- en: 'In this final exercise on `dict`, we will go over a less used comprehension
    than the list one: dictionary comprehension. We will also examine two other ways
    to create a `dict`, which will be useful in the future.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个关于 `dict` 的最后练习中，我们将回顾比列表理解更少使用的理解方式：字典理解。我们还将检查创建 `dict` 的两种其他方法，这些方法在将来会很有用。
- en: 'A dictionary comprehension works exactly the same way as the list one, but
    we need to specify both the keys and values:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 字典理解与列表理解的工作方式完全相同，但我们需要指定键和值：
- en: 'Generate a dict that has `0` to `9` as the keys and the square of the key as
    the values:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个字典，其中 `0` 到 `9` 作为键，键的平方作为值：
- en: '[PRE59]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output is as follows:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE60]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Can you generate a `dict` using `dict` comprehension where the keys are from
    `0` to `9` and the values are the square root of the keys? This time, we won't
    use a list.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你能否使用 `dict` 理解生成一个 `dict`，其中键从 `0` 到 `9`，值是键的平方根？这次，我们不会使用列表。
- en: 'Generate a `dictionary` using the `dict` function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dict` 函数生成 `dictionary`：
- en: '[PRE61]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE62]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can also generate `dictionary` using the `dict` function, as follows:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以使用 `dict` 函数生成 `dictionary`，如下所示：
- en: '[PRE63]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is pretty versatile. So, both the preceding commands will generate valid
    dictionaries.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它非常灵活。因此，前面的两个命令都将生成有效的字典。
- en: The strange looking pair of values that we had just noticed ('Harry', 300) is
    called a `tuple`. This is another important fundamental data type in Python. We
    will learn about tuples in the next topic.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚才注意到的看起来奇怪的值对 ('Harry', 300) 被称为 `tuple`。这是 Python 中的另一个重要基本数据类型。我们将在下一个主题中学习元组。
- en: Tuples
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is another data type in Python. It is sequential in nature and similar
    to lists.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是 Python 中的另一种数据类型。它具有顺序性，类似于列表。
- en: 'A tuple consists of values separated by commas, as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 元组由逗号分隔的值组成，如下所示：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that, unlike lists, we did not open and close square brackets here.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与列表不同，这里我们没有打开和关闭方括号。
- en: Creating a Tuple with Different Cardinalities
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有不同基数（cardinalities）的元组
- en: 'This is how we create an empty tuple:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们创建空元组的方式：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And this is how we create a tuple with only one value:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这就是我们创建只有一个值的元组的方式：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice the trailing comma here.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的尾随逗号。
- en: 'We can nest tuples, similar to list and dicts, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以嵌套元组，类似于列表和字典，如下所示：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'One special thing about tuples is the fact that they are an immutable data
    type. So, once created, we cannot change their values. We can just access them,
    as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个特殊之处在于它们是一个不可变的数据类型。因此，一旦创建，我们无法更改它们的值。我们只能访问它们，如下所示：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The last line of code will result in a `TypeError` as a tuple does not allow
    modification.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码将导致`TypeError`，因为元组不允许修改。
- en: This makes the use case for tuples a bit different than lists, although they
    look and behave very similarly in a few aspects.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得元组的使用案例在某种程度上与列表不同，尽管它们在几个方面看起来和行为非常相似。
- en: Unpacking a Tuple
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解包元组
- en: 'The term unpacking a tuple simply means to get the values contained in the
    tuple in different variables:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 解包元组的术语简单地说就是获取元组中包含的值，并将它们放入不同的变量中：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Of course, as soon as we do that, we can modify the values contained in those
    variables.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们这样做，我们就可以修改这些变量中包含的值。
- en: 'Exercise 11: Handling Tuples'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 11：处理元组
- en: 'Create a tuple to demonstrate how tuples are immutable. Unpack it to read all
    elements, as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元组来演示元组是不可变的。解包它以读取所有元素，如下所示：
- en: '[PRE72]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE73]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Try to override a variable from the `tupleE` tuple:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从`tupleE`元组中覆盖一个变量：
- en: '[PRE74]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This step will result in `TypeError` as the tuple does not allow modification.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步将导致`TypeError`，因为元组不允许修改。
- en: 'Try to assign a series to the `tupleE` tuple:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将一个序列赋值给`tupleE`元组：
- en: '[PRE75]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Print the output:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印输出：
- en: '[PRE76]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output is as follows:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE77]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We have mainly seen two different types of data so far. One is represented by
    numbers; another is represented by textual data. Whereas numbers have their own
    tricks, which we will see later, it is time to look into textual data in a bit
    more detail.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要看到了两种不同的数据类型。一种由数字表示；另一种由文本数据表示。虽然数字有其自己的技巧，我们将在后面看到，现在是时候更详细地研究文本数据了。
- en: Strings
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: In the final section of this section, we will learn about strings. Strings in
    Python are similar to any other programming language.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将学习字符串。Python 中的字符串与其他编程语言中的字符串类似。
- en: 'This is a string:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字符串：
- en: '[PRE78]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A string can also be declared in this manner:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串也可以用这种方式声明：
- en: '[PRE79]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can use single quotes and double quotes to define a string.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用单引号和双引号来定义字符串。
- en: 'Exercise 12: Accessing Strings'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 12：访问字符串
- en: 'Strings in Python behave similar to lists, apart from one big caveat. Strings
    are immutable, whereas lists are mutable data structures:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的字符串行为类似于列表，除了一个大的注意事项。字符串是不可变的，而列表是可变的数据结构：
- en: 'Create a string called `str_1`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`str_1`的字符串：
- en: '[PRE80]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Access the elements of the string by specifying the location of the element,
    like we did in lists.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过指定元素的位置来访问字符串的元素，就像我们在列表中做的那样。
- en: 'Access the first member of the string:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的第一个成员：
- en: '[PRE81]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output is as follows:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE82]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Access the fourth member of the string:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的第四个成员：
- en: '[PRE83]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is as follows:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE84]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Access the last member of the string:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的最后一个成员：
- en: '[PRE85]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output is as follows:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Access the last member of the string:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字符串的最后一个成员：
- en: '[PRE87]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE88]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Each of the preceding operations will give you the character at the specific
    index.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述每个操作都会给你特定索引处的字符。
- en: Note
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The method for accessing the elements of a string is like accessing a list.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 访问字符串元素的方法类似于访问列表。
- en: 'Exercise 13: String Slices'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 13：字符串切片
- en: 'Just like lists, we can slice strings:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 就像列表一样，我们可以切片字符串：
- en: 'Create a string, `str_1`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串，`str_1`：
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Specify the slicing values and slice the string:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定切片值并切片字符串：
- en: '[PRE90]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output is this:'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE91]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Slice a string by skipping a slice value:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过跳过切片值来切片字符串：
- en: '[PRE92]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output is as follows:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE93]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Use negative numbers to slice the string:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用负数来切片字符串：
- en: '[PRE94]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output is as follows:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE95]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: String Functions
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串函数
- en: 'To find out the length of a string, we simply use the `len` function:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出字符串的长度，我们只需使用`len`函数：
- en: '[PRE96]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The length of the string is 41\. To convert a string''s case, we can use the
    `lower` and `upper` methods:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度是 41。要转换字符串的大小写，我们可以使用`lower`和`upper`方法：
- en: '[PRE97]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To search for a string within a string, we can use the `find` method:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符串中搜索字符串，我们可以使用`find`方法：
- en: '[PRE99]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The output is -1\. Can you figure out whether the find method is case-sensitive
    or not? Also, what do you think the find method returns when it actually finds
    the string?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是-1。你能弄清楚`find`方法是否区分大小写吗？你认为`find`方法在找到字符串时返回什么？
- en: 'To replace one string with another, we have the `replace` method. Since we
    know that a string is an immutable data structure, replace actually returns a
    new string instead of replacing and returning the actual one:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要用一个字符串替换另一个字符串，我们可以使用`replace`方法。由于我们知道字符串是一个不可变的数据结构，`replace`实际上返回一个新的字符串，而不是替换并返回实际的字符串：
- en: '[PRE100]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The output is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE101]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You should look up string methods in the standard documentation of Python 3
    to discover more about these methods.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在Python 3的标准文档中查找字符串方法，以了解更多关于这些方法的信息。
- en: 'Exercise 14: Split and Join'
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14：分割和连接
- en: 'These two string methods need separate introductions, as they enable you to
    convert a string into a list and vice versa:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字符串方法需要分别介绍，因为它们允许你将字符串转换为列表，反之亦然：
- en: 'Create a string and convert it to a list using the `split` method:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字符串，并使用`split`方法将其转换为列表：
- en: '[PRE102]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The preceding code will give you a list similar to the following:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将给出一个类似以下列表：
- en: '[PRE103]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Combine this list into another string using the `join` method:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join`方法将这个列表组合成另一个字符串：
- en: '[PRE104]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This code will give you a string like this:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将给你一个类似这样的字符串：
- en: '[PRE105]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: With these, we are at the end of our second topic of this chapter. We now have
    the motivation to learn data wrangling and have a solid introduction to the fundamentals
    of data structures using Python. There is more to this topic, which will be covered
    in a future chapters.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们结束了本章的第二个主题。我们现在有了学习数据整理的动力，并使用Python对数据结构的基本原理有了坚实的介绍。这个主题还有更多内容，将在未来的章节中介绍。
- en: We have designed an activity for you so that you can practice all the skills
    you just learned. This small activity should take around 30 to 45 minutes to finish.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为你设计了一个活动，让你可以练习你刚刚学到的所有技能。这个小活动应该需要大约30到45分钟来完成。
- en: 'Activity 2: Analyze a Multiline String and Generate the Unique Word Count'
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动二：分析多行字符串并生成唯一单词计数
- en: This section will ensure that you have understood the various basic data structures
    and their manipulation. We will do that by going through an activity that has
    been designed specifically for this purpose.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将确保你已经理解了各种基本数据结构和它们的操作。我们将通过一个专门为此目的设计的活动来实现这一点。
- en: 'In this activity, we will do the following:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将做以下事情：
- en: Get multiline text and save it in a Python variable
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取多行文本并将其保存到Python变量中
- en: Get rid of all new lines in it using string methods
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串方法去除其中的所有换行符
- en: Get all the unique words and their occurrences from the string
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中获取所有唯一的单词及其出现次数。
- en: Repeat the step to find all unique words and occurrences, without considering
    case sensitivity
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复步骤以找到所有唯一的单词和出现次数，不考虑大小写。
- en: Note
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity for this activity, the original text (which can be
    found at [https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm))
    has been pre-processed a bit.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了简化这个活动，原始文本（可以在[https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm)找到）已经进行了一些预处理。
- en: 'These are the steps to guide you through solving this activity:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将指导你完成这个活动的解决过程：
- en: Create a `mutliline_text` variable by copying the text from the first chapter
    of *Pride and Prejudice*.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制《傲慢与偏见》的第一章文本来创建一个`mutliline_text`变量。
- en: Note
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The first chapter of Pride and Prejudice by Jane Austen has been made available
    on the GitHub repository at [https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter01/Activity02/](https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson01/Activity02/).
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简·奥斯汀的《傲慢与偏见》的第一章已经在GitHub仓库[https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter01/Activity02/](https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson01/Activity02/)上提供。
- en: Find the type and length of the `multiline_text` string using the commands `type`
    and `len`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`type`和`len`命令获取`multiline_text`字符串的类型和长度。
- en: Remove all new lines and symbols using the `replace` function.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`replace`函数移除所有换行符和符号。
- en: Find all of the words in `multiline_text` using the `split` function.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`split`函数在`multiline_text`中找到所有的单词。
- en: Create a list from this list that will contain only the unique words.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个列表中创建一个只包含唯一单词的列表。
- en: Count the number of times the unique word has appeared in the list using the
    `key` and `value` in `dict`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dict`中的`key`和`value`计算列表中唯一单词出现的次数。
- en: Find the top 25 words from the unique words that you have found using the `slice`
    function.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`slice`函数从你找到的唯一单词中找出前25个单词。
- en: You just created, step by step, a unique word counter using all the neat tricks
    that you learned about in this chapter.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经逐步创建了一个使用本章所学到的所有巧妙技巧的唯一单词计数器。
- en: Note
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 285.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第285页找到。
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what the term data wrangling means. We also got
    examples from various real-life data science situations where data wrangling is
    very useful and is used in industry. We moved on to learn about the different
    built-in data structures that Python has to offer. We got our hands dirty by exploring
    lists, sets, dictionaries, tuples, and strings. They are the fundamental building
    blocks in Python data structures, and we need them all the time while working
    and manipulating data in Python. We did several small hands-on exercises to learn
    more about them. We finished this chapter with a carefully designed activity,
    which let us combine a lot of different tricks from all the different data structures
    into a real-life situation and let us observe the interplay between all of them.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了数据清洗（data wrangling）这个术语的含义。我们还从各种实际的数据科学场景中获得了例子，在这些场景中，数据清洗非常有用，并且在工业界中得到应用。我们继续学习Python提供的不同内置数据结构。我们通过探索列表（lists）、集合（sets）、字典（dictionaries）、元组（tuples）和字符串（strings）来亲自动手实践。它们是Python数据结构的基本构建块，我们在使用Python处理和操作数据时需要它们。我们进行了几个小型的动手练习，以了解更多关于它们的信息。我们以一个精心设计的活动结束本章，这个活动让我们将所有不同数据结构中的许多不同技巧结合到实际场景中，并让我们观察它们之间的相互作用。
- en: In the next chapter, we will learn about the data structures in Python and utilize
    them to solve real-world problems.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Python中的数据结构，并利用它们来解决现实世界的问题。
