- en: '*Chapter 1*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Data Wrangling with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the importance of data wrangling in data science
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate the data structures that are available in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the different implementations of the inbuilt Python data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter describes the importance of data wrangling, identifies the important
    tasks to be performed in data wrangling, and introduces basic Python data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data science and analytics are taking over the whole world and the job of a
    data scientist is routinely being called the coolest job of the 21st century.
    But for all the emphasis on data, it is the science that makes you – the practitioner
    – truly valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice high-quality science with data, you need to make sure it is properly
    sourced, cleaned, formatted, and pre-processed. This book teaches you the most
    essential basics of this invaluable component of the data science pipeline: data
    wrangling. In short, data wrangling is the process that ensures that the data
    is in a format that is clean, accurate, formatted, and ready to be used for data
    analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: A prominent example of data wrangling with a large amount of data is the one
    conducted at the Supercomputer Center of University of California San Diego (UCSD).
    The problem in California is that wildfires are very common, mainly because of
    the dry weather and extreme heat, especially during the summers. Data scientists
    at the UCSD Supercomputer Center gather data to predict the nature and spread
    direction of the fire. The data that comes from diverse sources such as weather
    stations, sensors in the forest, fire stations, satellite imagery, and Twitter
    feeds might still be incomplete or missing. This data needs to be cleaned and
    formatted so that it can be used to predict future occurrences of wildfires.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of how data wrangling and data science can prove to be helpful
    and relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of Data Wrangling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Oil does not come in its final form from the rig; it has to be refined. Similarly,
    data must be curated, massaged, and refined to be used in intelligent algorithms
    and consumer products. This is known as wrangling. Most data scientists spend
    the majority of their time data wrangling.
  prefs: []
  type: TYPE_NORMAL
- en: Data wrangling is generally done at the very first stage of a data science/analytics
    pipeline. After the data scientists identify useful data sources for solving the
    business problem (for instance, in-house database storage or internet or streaming
    sensor data), they then proceed to extract, clean, and format the necessary data
    from those sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the task of data wrangling involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Scraping raw data from multiple sources (including web and database tables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imputing, formatting, and transforming – basically making it ready to be used
    in the modeling process (such as advanced machine learning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling read/write errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting outliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing quick visualizations (plotting) and basic statistical analysis to
    judge the quality of your formatted data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is an illustrative representation of the positioning and essential functional
    role of data wrangling in a typical data science pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Process of data wrangling](img/Figure_1.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Process of data wrangling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The process of data wrangling includes first finding the appropriate data that's
    necessary for the analysis. This data can be from one or multiple sources, such
    as tweets, bank transaction statements in a relational database, sensor data,
    and so on. This data needs to be cleaned. If there is missing data, we will either
    delete or substitute it, with the help of several techniques. If there are outliers,
    we need to first detect them and then handle them appropriately. If data is from
    multiple sources, we will have to perform join operations to combine it.
  prefs: []
  type: TYPE_NORMAL
- en: In an extremely rare situation, data wrangling may not be needed. For example,
    if the data that's necessary for a machine learning task is already stored in
    an acceptable format in an in-house database, then a simple SQL query may be enough
    to extract the data into a table, ready to be passed on to the modeling stage.
  prefs: []
  type: TYPE_NORMAL
- en: Python for Data Wrangling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is always a debate on whether to perform the wrangling process using
    an enterprise tool or by using a programming language and associated frameworks.
    There are many commercial, enterprise-level tools for data formatting and pre-processing
    that do not involve much coding on the part of the user. These examples include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General purpose data analysis platforms such as Microsoft Excel (with add-ins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistical discovery package such as **JMP** (from SAS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling platforms such as **RapidMiner**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analytics platforms from niche players focusing on data wrangling, such as **Trifacta**,
    **Paxata**, and **Alteryx**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, programming languages such as Python provide more flexibility, control,
    and power compared to these off-the-shelf tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the volume, velocity, and variety (the three Vs of **big data**) of data
    undergo rapid changes, it is always a good idea to develop and nurture a significant
    amount of in-house expertise in data wrangling using fundamental programming frameworks
    so that an organization is not beholden to the whims and fancies of any enterprise
    platform for as basic a task as data wrangling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Google trend worldwide over the last 5 years](img/Figure_1.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Google trend worldwide over the last Five years'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A few of the obvious advantages of using an open source, free programming paradigm
    such as Python for data wrangling are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: General purpose open source paradigm putting no restriction on any of the methods
    you can develop for the specific problem at hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great ecosystem of fast, optimized, open source libraries, focused on data analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Growing support to connect Python to every conceivable data source type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy interface to basic statistical testing and quick visualization libraries
    to check data quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seamless interface of the data wrangling output with advanced machine learning
    models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is the most popular language of choice of machine learning and artificial
    intelligence these days.
  prefs: []
  type: TYPE_NORMAL
- en: Lists, Sets, Strings, Tuples, and Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned the importance of Python, we will start by exploring
    various basic data structures in Python. We will learn techniques to handle data.
    This is invaluable for a data practitioner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can issue the following command to start a new Jupyter server by typing
    the following in to the Command Prompt window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will start a jupyter server and you can visit it at [`http://localhost:8888`](http://localhost:8888)
    and use the passcode `dw_4_all` to access the main interface.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are fundamental Python data structures that have continuous memory locations,
    can host different data types, and can be accessed by the index.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a list and list comprehension. We will generate a list of
    numbers, and then examine which ones among them are even. We will sort, reverse,
    and check for duplicates. We will also see how many different ways we can access
    the list elements, iterating over them and checking the membership of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a simple list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is also an example of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a list can contain any number of the allowed datatype, such
    as `int`, `float`, `string`, and `Boolean`, and a list can also be a mix of different
    data types (including nested lists).
  prefs: []
  type: TYPE_NORMAL
- en: If you are coming from a strongly typed language, such as C, C++, or Java, then
    this will probably be strange as you are not allowed to mix different kinds of
    data types in a single array in those languages. Lists are somewhat like arrays,
    in the sense that they are both based on continuous memory locations and can be
    accessed using indexes. But the power of Python lists come from the fact that
    they can host different data types and you are allowed to manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be careful, though, as the very power of lists, and the fact that you can mix
    different data types in a single list, can actually create subtle bugs that can
    be very difficult to track.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Accessing the List Members'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following exercise, we will be creating a list and then observing the
    different ways of accessing the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a list called `list_1` with four integer members, using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The indices will be automatically assigned, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.3: List showing the forward and backward indices](img/Figure_1.3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.3: List showing the forward and backward indices'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Access the first element from `list_1` using its forward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last element from `list_1` using its forward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last element from `list_1` using the `len` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `len` function in Python returns the length of the specified list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the last element from `list_1` using its backward index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the first three elements from `list_1` using forward indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is also called list slicing, as it returns a smaller list from the original
    list by extracting only, a part of it. To slice a list, we need two integers.
    The first integer will denote the start of the slice and the second integer will
    denote the end-1 element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that slicing did not include the third index or the end element. This
    is how list slicing works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the last two elements from `list_1` by slicing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the first two elements using backward indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we leave one side of the colon (`:`) blank, we are basically telling Python
    either to go until the end or start from the beginning of the list. It will automatically
    apply the rule of list slices that we just learned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reverse the elements in the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The last bit of code is not very readable, meaning it is not obvious just by
    looking at it what it is doing. It is against Python's philosophy. So, although
    this kind of code may look clever, we should resist the temptation to write code
    like this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 2: Generating a List'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to examine various ways of generating a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list using the `append` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we started by declaring an empty list and then we used a `for` loop to
    append values to it. The `append` method is a method that's given to us by the
    Python list data type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a list using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The partial output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.4: List comprehension](img/Figure_1.4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.4: List comprehension'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: This is list comprehension, which is a very powerful tool that we need to master.
    The power of list comprehension comes from the fact that we can use conditionals
    inside the comprehension itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use a `while` loop to iterate over a list to understand the difference between
    a `while` loop and a `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The partial output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.5: Output showing the contents of list_1 using a while loop](img/Figure_1.5.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.5: Output showing the contents of list_1 using a while loop'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create `list_3` with numbers that are divisible by `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be a list of numbers up to 100 in increments of 5:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list by adding the two lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extend a string using the extend keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The partial output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/C11065_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Contents of list_1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The second operation changes the original list (list_1) and appends all the
    elements of list_2 to it. So, be careful when using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Iterating over a List and Checking Membership'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to iterate over a list and test whether a certain value exists
    in it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterate over a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.7: Section of list_1](img/Figure_1.7.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.7: Section of list_1'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, it is not very Pythonic. Being Pythonic is to follow and conform to
    a set of best practices and conventions that have been created over the years
    by thousands of very able developers, which in this case means to use the `in`
    keyword, because Python does not have index initialization, bounds checking, or
    index incrementing, unlike traditional languages. The Pythonic way of iterating
    over a list is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.8: Section of the list list_1](img/Figure_1.8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.8: A section of list_1'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that, in the second method, we do not need a counter anymore to access
    the list index; instead, Python's `in` operator gives us the element at the *i*
    th position directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the integers 25 and -45 are in the list using the `in` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is **True.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is **False.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 4: Sorting a List'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We generated a list called `list_1` in the previous exercise. We are going
    to sort it now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the list was originally a list of numbers from `0` to `99`, we will sort
    it in the reverse direction. To do that, we will use the `sort` method with `reverse=True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The partial output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Figure_1.9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 1.9: Section of output showing the reversed list'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can use the `reverse` method directly to achieve this result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.10: Section of output after reversing the string](img/Figure_1.91.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Section of output after reversing the string'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The difference between the sort function and the reverse function is the fact
    that we can use sort with custom sorting functions to do custom sorting, whereas
    we can only use reverse to reverse a list. Here also, both the functions work
    in-place, so be aware of this while using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Generating a Random List'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will be generating a `list` with random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `random` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `randint` function to generate random integers and add them to a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the list using `print(list_1)`. Note that there will be duplicate values
    in `list_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Figure_1.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Section of the sample output for list_1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are many ways to get a list of unique numbers, and while you may be able
    to write a few lines of code using a for loop and another list (you should actually
    try doing it!), let's see how we can do this without a for loop and with a single
    line of code. This will bring us to the next data structure, sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Handling Lists'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, we will generate a `list` of random numbers and then generate
    another `list` from the first one, which only contains numbers that are divisible
    by three. Repeat the experiment three times. Then, we will calculate the average
    difference of length between the two lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps for completing this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `list` of 100 random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `list` from this random `list`, with numbers that are divisible
    by *3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length of these two lists and store the difference in a new variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a loop, perform steps 2 and 3 and find the difference variable three times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the arithmetic mean of these three difference values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 282.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A set, mathematically speaking, is just a collection of well-defined distinct
    objects. Python gives us a straightforward way to deal with them using its `set`
    datatype.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the last list that we generated, we are going to revisit the problem of
    getting rid of duplicates from it. We can achieve that with the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we print this, we will see that it only contains unique numbers. We used
    the `set` data type to turn the first list into a set, thus getting rid of all
    duplicate elements, and then we used the `list` function on it to turn it into
    a list from a set once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Section of output for list_21](img/Figure_1.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Section of output for list_21'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Union and Intersection of Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is what a union between two sets looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Venn diagram showing union of two sets](img/Figure_1.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Venn diagram showing the union of two sets'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This simply means take everything from both sets but take the common elements
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the union of the two sets, the following instructions should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the common element, Banana, appears only once in the resulting
    set. The common elements between two sets can be identified by obtaining the intersection
    of the two sets, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Venn diagram showing intersection of two sets](img/Figure_1.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Venn diagram showing the intersection of two sets'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We get the intersection of two sets in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a set with only one element. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also calculate the difference between sets (also known as complements).
    To find out more, refer to this link: [https://docs.python.org/3/tutorial/datastructures.html#sets](https://docs.python.org/3/tutorial/datastructures.html#sets).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Null Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create a null set by creating a set containing no elements. You can
    do this by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to create a dictionary, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We are going to learn about this in detail in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dictionary is like a list, which means it is a collection of several elements.
    However, with the dictionary, it is a collection of key-value pairs, where the
    key can be anything that can be hashed. Generally, we use numbers or strings as
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a dictionary, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also a valid dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The keys must be unique in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Accessing and Setting Values in a Dictionary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to access and set values in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access a particular key in a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the value associated with it as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign a new value to the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a blank dictionary and then use the key notation to assign values to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 7: Iterating Over a Dictionary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to iterate over a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `dict_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the looping variables `k` and `v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the difference between how we did the iteration on the list and how we
    are doing it here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 8: Revisiting the Unique Valued List Problem'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the fact that dictionary keys cannot be duplicated to generate
    the unique valued list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, generate a random list with duplicate values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a unique valued list from `list_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sample output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/Image51881.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Output showing the unique valued list'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we have used two useful functions on the dict data type in Python, `fromkeys`
    and `keys`. `fromkeys` creates a dict where the keys come from the `iterable`
    (in this case, which is a list), values default to None, and `keys` give us the
    keys of a dict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Deleting Value from Dict'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to delete a value from a `dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `list_1` with five elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the `del` function and specify the element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The `del` operator can be used to delete a specific index from a list as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 10: Dictionary Comprehension'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this final exercise on `dict`, we will go over a less used comprehension
    than the list one: dictionary comprehension. We will also examine two other ways
    to create a `dict`, which will be useful in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dictionary comprehension works exactly the same way as the list one, but
    we need to specify both the keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a dict that has `0` to `9` as the keys and the square of the key as
    the values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can you generate a `dict` using `dict` comprehension where the keys are from
    `0` to `9` and the values are the square root of the keys? This time, we won't
    use a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a `dictionary` using the `dict` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also generate `dictionary` using the `dict` function, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is pretty versatile. So, both the preceding commands will generate valid
    dictionaries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The strange looking pair of values that we had just noticed ('Harry', 300) is
    called a `tuple`. This is another important fundamental data type in Python. We
    will learn about tuples in the next topic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tuple is another data type in Python. It is sequential in nature and similar
    to lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple consists of values separated by commas, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike lists, we did not open and close square brackets here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Tuple with Different Cardinalities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is how we create an empty tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how we create a tuple with only one value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Notice the trailing comma here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can nest tuples, similar to list and dicts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'One special thing about tuples is the fact that they are an immutable data
    type. So, once created, we cannot change their values. We can just access them,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The last line of code will result in a `TypeError` as a tuple does not allow
    modification.
  prefs: []
  type: TYPE_NORMAL
- en: This makes the use case for tuples a bit different than lists, although they
    look and behave very similarly in a few aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking a Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term unpacking a tuple simply means to get the values contained in the
    tuple in different variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as soon as we do that, we can modify the values contained in those
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11: Handling Tuples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a tuple to demonstrate how tuples are immutable. Unpack it to read all
    elements, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to override a variable from the `tupleE` tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step will result in `TypeError` as the tuple does not allow modification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to assign a series to the `tupleE` tuple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have mainly seen two different types of data so far. One is represented by
    numbers; another is represented by textual data. Whereas numbers have their own
    tricks, which we will see later, it is time to look into textual data in a bit
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the final section of this section, we will learn about strings. Strings in
    Python are similar to any other programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'A string can also be declared in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can use single quotes and double quotes to define a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12: Accessing Strings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings in Python behave similar to lists, apart from one big caveat. Strings
    are immutable, whereas lists are mutable data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string called `str_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Access the elements of the string by specifying the location of the element,
    like we did in lists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Access the first member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the fourth member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the last member of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of the preceding operations will give you the character at the specific
    index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The method for accessing the elements of a string is like accessing a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 13: String Slices'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like lists, we can slice strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string, `str_1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the slicing values and slice the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Slice a string by skipping a slice value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use negative numbers to slice the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out the length of a string, we simply use the `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of the string is 41\. To convert a string''s case, we can use the
    `lower` and `upper` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To search for a string within a string, we can use the `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The output is -1\. Can you figure out whether the find method is case-sensitive
    or not? Also, what do you think the find method returns when it actually finds
    the string?
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace one string with another, we have the `replace` method. Since we
    know that a string is an immutable data structure, replace actually returns a
    new string instead of replacing and returning the actual one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You should look up string methods in the standard documentation of Python 3
    to discover more about these methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14: Split and Join'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These two string methods need separate introductions, as they enable you to
    convert a string into a list and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a string and convert it to a list using the `split` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding code will give you a list similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine this list into another string using the `join` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code will give you a string like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these, we are at the end of our second topic of this chapter. We now have
    the motivation to learn data wrangling and have a solid introduction to the fundamentals
    of data structures using Python. There is more to this topic, which will be covered
    in a future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We have designed an activity for you so that you can practice all the skills
    you just learned. This small activity should take around 30 to 45 minutes to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Analyze a Multiline String and Generate the Unique Word Count'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will ensure that you have understood the various basic data structures
    and their manipulation. We will do that by going through an activity that has
    been designed specifically for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this activity, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get multiline text and save it in a Python variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get rid of all new lines in it using string methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get all the unique words and their occurrences from the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the step to find all unique words and occurrences, without considering
    case sensitivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: For the sake of simplicity for this activity, the original text (which can be
    found at [https://www.gutenberg.org/files/1342/1342-h/1342-h.htm](https://www.gutenberg.org/files/1342/1342-h/1342-h.htm))
    has been pre-processed a bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These are the steps to guide you through solving this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mutliline_text` variable by copying the text from the first chapter
    of *Pride and Prejudice*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The first chapter of Pride and Prejudice by Jane Austen has been made available
    on the GitHub repository at [https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Chapter01/Activity02/](https://github.com/TrainingByPackt/Data-Wrangling-with-Python/blob/master/Lesson01/Activity02/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find the type and length of the `multiline_text` string using the commands `type`
    and `len`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove all new lines and symbols using the `replace` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the words in `multiline_text` using the `split` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a list from this list that will contain only the unique words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count the number of times the unique word has appeared in the list using the
    `key` and `value` in `dict`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the top 25 words from the unique words that you have found using the `slice`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You just created, step by step, a unique word counter using all the neat tricks
    that you learned about in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 285.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned what the term data wrangling means. We also got
    examples from various real-life data science situations where data wrangling is
    very useful and is used in industry. We moved on to learn about the different
    built-in data structures that Python has to offer. We got our hands dirty by exploring
    lists, sets, dictionaries, tuples, and strings. They are the fundamental building
    blocks in Python data structures, and we need them all the time while working
    and manipulating data in Python. We did several small hands-on exercises to learn
    more about them. We finished this chapter with a carefully designed activity,
    which let us combine a lot of different tricks from all the different data structures
    into a real-life situation and let us observe the interplay between all of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the data structures in Python and utilize
    them to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
