- en: '*Chapter 10*: Getting to Know Algorithms with Aqua'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：通过Aqua了解算法'
- en: So, we have finally come to the part where we will slow down a bit on coding
    our own circuits and instead take a look at what is arguably the most interesting
    part of Qiskit®—Qiskit Aqua.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们终于来到了这部分，我们将稍微放慢自己编写电路的速度，转而看看Qiskit®中最有趣的部分——Qiskit Aqua。
- en: As we were building the various Grover implementations in the last chapter,
    we saw how that seemingly simple algorithm turned into an unwieldy beast of coding
    when you implemented it in Qiskit Terra. If you are building a hybrid classical/quantum
    program (where you just want to use the Grover search function), it would be vastly
    simpler if you could just import and run a Qiskit® implementation of it, or other
    quantum algorithms, and not have to code from scratch.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一章构建各种Grover实现时，我们看到了这个看似简单的算法在用Qiskit Terra实现时如何变成一个难以驾驭的编码怪物。如果你正在构建一个混合经典/量子程序（你只是想使用Grover搜索功能），如果你能直接导入并运行Qiskit®的实现，或者其他量子算法，而不必从头编写代码，那将会简单得多。
- en: So, with a fanfare and a drum roll, we now take an initial look at a couple
    of Qiskit Aqua algorithms (Grover and Shor) that you can use out of the box.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，伴随着一阵欢呼和鼓声，我们现在初步了解一下几个Qiskit Aqua算法（Grover和Shor），你可以直接使用它们。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下菜谱：
- en: Running Grover's algorithm as an Aqua function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Grover算法作为Aqua函数运行
- en: Running Shor's algorithm as an Aqua function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Shor算法作为Aqua函数运行
- en: Exploring more Aqua algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索更多Aqua算法
- en: When we are done here, you will have looked at how to incorporate Qiskit Aqua
    algorithms into your own code and will know where to find more algorithms to test
    with, and how to start exploring how the algorithms are actually built using Python
    inside Qiskit® code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这里的工作后，你将了解到如何将Qiskit Aqua算法集成到自己的代码中，并将知道在哪里找到更多算法进行测试，以及如何开始探索算法实际上是如何在Qiskit®代码中使用Python构建的。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的量子程序可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10).
- en: Running Grover's algorithm as an Aqua function
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Grover算法作为Aqua函数运行
- en: At the end of [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*, we promised that there was an easier way to include
    Grover's search algorithm in your quantum circuits. In this recipe, we will achieve
    the same results, but without having to build the circuit from scratch; Qiskit
    Aqua will set up the oracle, build the Grover circuit, and run it for us.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)的结尾，我们承诺将有一个更简单的方法将Grover搜索算法包含到你的量子电路中。在这个菜谱中，我们将达到相同的结果，但无需从头开始构建电路；Qiskit
    Aqua将设置预言机，构建Grover电路，并为我们运行它。
- en: Just like importing and calling Python classes and methods for various things,
    such as `from math import pi` to get access to a numerical representation of ![](img/Formula_10_015.png),
    you can do the same with Qiskit® components. Why reinvent the wheel and build
    your implementation of the Grover search algorithm when it is already included
    with Qiskit®?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像导入和调用Python类和方法来处理各种事情一样，例如使用`from math import pi`来获取 ![](img/Formula_10_015.png)
    的数值表示，你还可以使用Qiskit®组件。为什么还要重新发明轮子，构建自己的Grover搜索算法实现，当它已经包含在Qiskit®中时？
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的示例代码可以在这里找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py).
- en: 'Before we jump in, let''s take a look at the two forms of input that the Grover
    Aqua algorithm accepts to define the oracle:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，让我们看看Grover Aqua算法接受以定义预言机的两种输入形式：
- en: '`LogicalExpressionOracle` input type'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogicalExpressionOracle` 输入类型'
- en: '`TruthTableOracle` input type'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TruthTableOracle` 输入类型'
- en: Logical strings
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑字符串
- en: 'Here''s an example of a logical expression oracle for the ![](img/Formula_10_001.png)
    oracle that we used in the *The two-bit Grover* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover''s Search Algorithm*, with the least significant bit (LSB) to the left
    in the logic:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)“*Grover搜索算法*”中，我们使用了针对
    ![](img/Formula_10_001.png) 的逻辑表达式查询器示例，该查询器在 *The two-bit Grover* 菜谱中使用，其中最低有效位（LSB）位于逻辑的左侧：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This literally translated into: NOT A and B, which then can be translated into
    our Dirac ket notation as first qubit (A) = 0 and second qubit (B) =1, or ![](img/Formula_10_001.png).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上翻译成：非A和 B，然后可以翻译成我们的Dirac矢量表示法，即第一个量子比特（A）= 0 和第二个量子比特（B）=1，或 ![](img/Formula_10_001.png)。
- en: Bit strings
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位字符串
- en: 'When you use truth-table oracle input, you create a bit-string that represents
    the expected output for the oracle. For the ![](img/Formula_10_001.png) example,
    the bit string is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用真值表查询器输入时，您创建一个表示查询器预期输出的位字符串。对于 ![](img/Formula_10_001.png) 的示例，位字符串如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We walked through this notation briefly for 1- and 2-qubit systems in the *A
    quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. Take a look at that if you need a
    refresher.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045)“*使用Python进行量子计算和量子比特的快速入门*”的菜谱中简要介绍了这种表示法。如果您需要复习，请查看该内容。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To handle the creation and running of the Grover algorithm, we create four
    functions in the `ch10_r1_grover_aqua.py` script. Let''s check out those first
    before we move on to test it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理Grover算法的创建和运行，我们在 `ch10_r1_grover_aqua.py` 脚本中创建了四个函数。在我们继续测试之前，让我们先看看这些函数：
- en: The sample code
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例代码
- en: 'First, we import the classes and methods that we need, and set some global
    variables:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法，并设置一些全局变量：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `log_length(oracle_input,oracle_method)` function takes as input the oracle
    input (log or bin) and the oracle method (logical expression or bit string) and
    returns the ideal number of iterations the Grover circuit needs to include. If
    the oracle input is a logical string, we first calculate the number of qubits
    by counting the number of letters in the string, excluding tilde (~), ampersand
    (&), and space:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log_length(oracle_input,oracle_method)` 函数接受查询器输入（逻辑或二进制）和查询器方法（逻辑表达式或位字符串）作为输入，并返回Grover电路需要包含的理想迭代次数。如果查询器输入是逻辑字符串，我们首先通过计算字符串中的字母数量来计算量子比特的数量，不包括波浪号
    (~)、和号 (&) 和空格：'
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `create_oracle(oracle_method)` function takes the oracle method as input
    and prompts for the oracle logical expression or bit string. From the input, it
    calls the `log_length(oracle_input,oracle_method)` function that calculates the
    required number of iterations based on the ![](img/Formula_10_003.png)  formula.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_oracle(oracle_method)` 函数接受查询器方法作为输入，并提示输入查询器逻辑表达式或位字符串。从输入中，它调用 `log_length(oracle_input,oracle_method)`
    函数，该函数根据 ![](img/Formula_10_003.png) 公式计算所需的迭代次数。'
- en: 'This is how it looks in Python:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Python中，它看起来是这样的：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `create_grover(oracle_type)` function takes the `oracle_type` string, for
    example, `~A&B` as input, and uses the `Grover(LogicalExpressionOracle (oracle_type),num_iterations=num_iterations)`
    function to create the algorithm with the appropriate number of iterations.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_grover(oracle_type)` 函数接受 `oracle_type` 字符串作为输入，例如，`~A&B`，并使用 `Grover(LogicalExpressionOracle
    (oracle_type),num_iterations=num_iterations)` 函数创建具有适当迭代次数的算法。'
- en: 'In Python, it will look as follows:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Python中，它将如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `run_grover(algorithm,oracle_type)` function takes the algorithm that we
    just created as input and runs it first on a local Aer simulator, and then on
    the least busy IBM Quantum® backend with five qubits.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run_grover(algorithm,oracle_type)` 函数接受我们刚刚创建的算法作为输入，首先在本地Aer模拟器上运行，然后在最不繁忙的具有五个量子比特的IBM
    Quantum®后端上运行。'
- en: 'This is how we build that in Python:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们如何在Python中构建它的方法：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `main()` function prompts for the oracle method, then creates the oracle
    and runs the Grover algorithm:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数提示输入查询器方法，然后创建查询器并运行Grover算法：'
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the code
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'To create and run an Aqua-generated Grover circuit using a logical expression
    as input, do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和运行一个使用逻辑表达式作为输入的Aqua生成的Grover电路，请按照以下步骤操作：
- en: In your Python environment, run `ch10_r1_grover_aqua.py`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Python环境中，运行 `ch10_r1_grover_aqua.py`。
- en: When prompted, select the logical expression oracle method by entering `log`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，通过输入 `log` 选择逻辑表达式查询器方法。
- en: Feel free to test the same oracle with the bit string input by entering `bit`.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以自由地通过输入 `bit` 来测试使用比特串输入相同的逻辑门。
- en: 'Now enter a logical expression like in the previous example:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入一个与上一个例子类似的逻辑表达式：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you read out the logical expression, you get `NOT A AND B`, which corresponds
    to ![](img/Formula_10_004.png). Remember, A is the least significant bit, and
    in Qiskit® corresponds to the rightmost digit in the key notation.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你读出逻辑表达式，你会得到 `NOT A AND B`，这对应于 ![公式](img/Formula_10_004.png)。记住，A 是最低有效位，在
    Qiskit® 中对应于密钥表示法中的最右边数字。
- en: For a bit string oracle, the input would be `0010`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于比特串逻辑门，输入将是 `0010`。
- en: The oracle input and optimal number of iterations are displayed, together with
    the Aqua-created oracle circuit:![Figure 10.1 – The Aqua-created oracle circuit
    for ](img/Figure_10.1_B14436.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑门输入和最佳迭代次数会显示出来，同时还有 Aqua 创建的逻辑门电路：![图 10.1 – 为 ![公式](img/Formula_10_001.png)
    创建的 Aqua 逻辑门电路](img/Figure_10.1_B14436.jpg)
- en: Figure 10.1 – The Aqua-created oracle circuit for ![](img/Formula_10_001.png)
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.1 – 为 ![公式](img/Formula_10_001.png) 创建的 Aqua 逻辑门电路
- en: The oracle is now run on a local Aer simulator, and the results are displayed
    as follows:![Figure 10.2 – Results of running the  oracle on your local Aer simulator
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在逻辑门运行在本地 Aer 模拟器上，结果如下所示：![图 10.2 – 在你的本地 Aer 模拟器上运行 ![公式](img/Formula_10_001.png)
    逻辑门的结果
- en: '](img/Figure_10.2_B14436.jpg)'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.2_B14436.jpg)'
- en: Figure 10.2 – Results of running the ![](img/Formula_10_001.png) oracle on your
    local Aer simulator
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2 – 在你的本地 Aer 模拟器上运行 ![公式](img/Formula_10_001.png) 逻辑门的结果
- en: 'The oracle is now run on the least busy IBM Quantum® backend and the results
    are displayed as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逻辑门现在运行在最不繁忙的 IBM Quantum® 后端，结果如下所示：
- en: '![Figure 10.3 – Results of running the  oracle on an IBM Quantum® backend'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 在 IBM Quantum® 后端运行 ![公式](img/Formula_10_001.png) 逻辑门的结果'
- en: '](img/Figure_10.3_B14436.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.3_B14436.jpg)'
- en: Figure 10.3 – Results of running the ![](img/Formula_10_007.png) oracle on an
    IBM Quantum® backend
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 在 IBM Quantum® 后端运行 ![公式](img/Formula_10_007.png) 逻辑门的结果
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you look over the `ch10_r1_grover_aqua.py` program, then you will find in
    the order of 100 lines of code. Most of this is not needed to run the Grover algorithm.
    Assuming that you get the logical expression or bit string oracle input from somewhere,
    you can run this in just four lines of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `ch10_r1_grover_aqua.py` 程序，你会找到大约 100 行代码。其中大部分不是运行 Grover 算法所必需的。假设你从某处获得了逻辑表达式或比特串逻辑门输入，你只需四行代码就可以运行它：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first three lines of code import the required classes. This fourth line
    of code creates and runs the Grover circuit with a logical expression oracle as
    input – in this case, `~A&B`, to code for ![](img/Formula_10_008.png), and pulls
    out the top measurement, the winner coded by the oracle.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行代码导入所需的类。这第四行代码创建并运行了 Grover 电路，以逻辑表达式逻辑门作为输入 – 在这种情况下，`~A&B`，来表示 ![公式](img/Formula_10_008.png)，并提取出逻辑门编码的顶部测量结果，即获胜者。
- en: There's more…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Again, just like with your Terra-built circuits, things happen when you go
    from two qubits to three qubits. Let''s take a look. To see what the final transpiled
    circuit (run on the IBM Quantum® backend) looks like, you can log in to IBM Quantum
    Experience® to see the fully detailed results of your run:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，就像使用 Terra 构建的电路一样，当你从两个量子位增加到三个量子位时，事情就会发生。让我们看看。要查看最终编译后的电路（在 IBM Quantum®
    后端运行）的外观，你可以登录到 IBM Quantum Experience® 来查看你运行的全详细结果：
- en: 'Go to the following URL, and then log in with your IBM Quantum Experience®
    account: [https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/).'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往以下 URL，然后使用你的 IBM Quantum Experience® 账户登录：[https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/)。
- en: In the **Welcome** panel, scroll down to **Latest results**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **欢迎** 面板中，向下滚动到 **最新结果**。
- en: Locate the job that you just ran and click it:![Figure 10.4 – The job results
    for the  oracle on an IBM Quantum® backend in IBM Quantum Experience®
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位你刚刚运行的工作，并点击它：![图 10.4 – 在 IBM Quantum Experience® 中 IBM Quantum® 后端运行 ![公式](img/Formula_10_001.png)
    逻辑门的工作结果
- en: '](img/Figure_10.4_B14436.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_10.4_B14436.jpg)'
- en: Figure 10.4 – The job results for the ![](img/Formula_10_001.png) oracle on
    an IBM Quantum® backend in IBM Quantum Experience®
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.4 – 在 IBM Quantum Experience® 中 IBM Quantum® 后端运行 ![公式](img/Formula_10_001.png)
    逻辑门的工作结果
- en: Compare the circuits.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较电路。
- en: 'By taking a look at your jobs here, you can compare the size of the circuits
    that you ran as a part of *Building Grover''s search algorithm* recipe in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover''s Search Algorithm*,
    and your new Aqua-created circuit:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过查看这里的作业，你可以比较你在 [*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)
    的 *Building Grover's search algorithm* 菜单中运行的电路大小，以及你的新 Aqua 创建的电路：
- en: '![Figure 10.5 – 2-qubit Aqua Grover for  versus your Terra-built 2-qubit  Grover'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 10.5 – 对于 ![](img/Formula_10_001.png) 的 2 量子比特 Aqua Grover 与你的 Terra
    构建的 2 量子比特 Grover]'
- en: '](img/Figure_10.5_B14436.jpg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B14436.jpg)'
- en: Figure 10.5 – 2-qubit Aqua Grover for ![](img/Formula_10_001.png) versus your
    Terra-built 2-qubit ![](img/Formula_10_001.png) Grover
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 10.5 – 对于 ![](img/Formula_10_001.png) 的 2 量子比特 Aqua Grover 与你的 Terra
    构建的 2 量子比特 ![](img/Formula_10_001.png) Grover
- en: For the 2-qubit circuit, the size is corresponding to what you saw with your
    Terra-built circuit. What you can see from the difference is that the Aqua-built
    circuit uses an **ancillary** qubit to handle the phase-shifting mechanism. This
    makes the circuit a little bit larger, with a depth of 15 for the Qiskit Aqua
    Grover versus 9 for the Qiskit Terra Grover. The size also grows to 24 from 15\.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于双量子比特电路，其大小与你在 Terra 构建的电路中看到的大小相对应。从差异中你可以看到，Aqua 构建的电路使用一个**辅助**量子比特来处理相移机制。这使得电路稍微大一些，Qiskit
    Aqua Grover 的深度为 15，而 Qiskit Terra Grover 的深度为 9。大小也从 15 增长到 24。
- en: Now, run a 3-qubit Qiskit Aqua-created Grover and take a look at the results.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行一个 3 量子比特的 Qiskit Aqua 创建的 Grover 并查看结果。
- en: 'Run the `ch10_r1_grover_aqua.py` program again, select the log oracle type,
    and use the following logical string to code for ![](img/Formula_10_012.png) :
    `~A & ~B & C`.'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次运行 `ch10_r1_grover_aqua.py` 程序，选择日志预言机类型，并使用以下逻辑字符串为 ![](img/Formula_10_012.png)
    编码：`~A & ~B & C`。
- en: 'The results of the Qiskit Aer-run Grover should look like the following:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qiskit Aer 运行的 Grover 的结果应该看起来像以下这样：
- en: '![Figure 10.6 – Aer result for the Aqua-created  Grover'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.6 – Aer 对 Aqua 创建的 Grover 的结果]'
- en: '](img/Figure_10.6_B14436.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B14436.jpg)'
- en: Figure 10.6 – Aer result for the Aqua-created ![](img/Formula_10_013.png) Grover
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.6 – Aer 对 Aqua 创建的 ![](img/Formula_10_013.png) Grover 的结果
- en: 'And the result of the Grover run on an IBM Quantum® backend should look something
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IBM Quantum® 后端上运行的 Grover 的结果应该看起来像这样：
- en: '![Figure 10.7 – IBM Quantum® result for the Aqua-created  Grover'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.7 – IBM Quantum® 对 Aqua 创建的 Grover 的结果]'
- en: '](img/Figure_10.7_B14436.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B14436.jpg)'
- en: Figure 10.7 – IBM Quantum® result for the Aqua-created ![](img/Formula_10_013.png)
    Grover
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.7 – IBM Quantum® 对 Aqua 创建的 ![](img/Formula_10_013.png) Grover 的结果
- en: Look at these results. They do not look like the 3-qubit results we got in *The
    three-qubit Grover* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*, but more like the messy 4+ qubit results we saw in
    the *Adding more qubits to the Grover search* recipe. As we discussed in that
    recipe, we have clearly exceeded the circuit depth for a NISQ machine, getting
    more noise than the signal from our experiment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些结果。它们看起来不像我们在 [*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)
    的 *Grover's Search Algorithm* 中的 *The three-qubit Grover* 菜单中得到的 3 量子比特结果，而更像我们在
    *Adding more qubits to the Grover search* 菜单中看到的杂乱的 4+ 量子比特结果。正如我们在那个菜谱中讨论的，我们已经明显超出了
    NISQ 机器的电路深度，从实验中得到的噪声比信号多。
- en: So, how was that for some fun? We have seen how Qiskit Aqua codes the same algorithm
    that we spent so much time putting together in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*. But Qiskit Aqua contains so much more.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这算是有趣的吗？我们看到了 Qiskit Aqua 如何编码我们在 [*第 9 章*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246)
    的 *Grover's Search Algorithm* 中花费了大量时间构建的相同算法。但 Qiskit Aqua 包含了更多内容。
- en: We have barely scratched the surface. If you have spent some time looking over
    quantum information history, you might have a few favorite algorithms picked out;
    one of these is likely Grover's algorithm, but the most famous one is probably
    Shor's algorithm, and that's what's next. Read on!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了表面。如果你花了一些时间回顾量子信息的历史，你可能已经挑选出了一些喜欢的算法；其中之一很可能是 Grover 算法，但最著名的一个可能是
    Shor 算法，这就是下一个要讨论的内容。继续阅读！
- en: Running Shor's algorithm as an Aqua function
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Shor 算法作为 Aqua 函数运行
- en: Another one of the real luminaries of quantum computing algorithms is Peter
    Shor's algorithm dating back to 1984, in which he proved that with a sufficiently
    powerful quantum computer, you can prime factorize really large integers. This
    is important not only from an academic point of view but also because, for example,
    factorizing really large (thousands of digits) numbers into constituent prime
    numbers is the core behind today's RSA encryption that is used to secure online
    transactions, from banking and social media to the computers built into your car.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算算法中的另一位真正的光辉人物是彼得·肖尔（Peter Shor）的算法，该算法可以追溯到1984年，其中他证明了在足够强大的量子计算机的帮助下，你可以对非常大的整数进行质因数分解。这不仅从学术角度来看很重要，而且例如，将非常大的（数千位）数字分解为其构成质数是今天用于确保在线交易（从银行和社交媒体到你车中的计算机）的RSA加密的核心。
- en: At the point when these sufficiently large quantum computers enter the stage,
    crypto keys that would take weeks, months, years, and longer to break can theoretically
    be broken in a matter of minutes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些足够大的量子计算机进入舞台时，理论上可以在几分钟内破解那些需要数周、数月、数年甚至更长时间才能破解的加密密钥。
- en: To level-set our expectations here, running Shor's algorithm on today's NISQ
    machines is more of an academic interest. As you will notice, the Shor circuits
    tend to grow pretty large even for relatively small factorization exercises, and
    as you have seen in the previous chapters, as circuits grow, so do the errors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整我们的期望，在今天的NISQ机器上运行肖尔算法更多的是一种学术兴趣。正如你将注意到的，肖尔电路即使在相对较小的分解练习中也会变得相当大，正如你在前面的章节中看到的，随着电路的增长，错误也会增加。
- en: Through IBM Quantum Experience®, you have access to quantum computers up to
    15 qubits in size and simulators up to 32\. As you will see, the qubit count limits
    us regarding the size of the number to factorize.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IBM Quantum Experience®，你可以访问到15个量子比特大小的量子计算机和32个模拟器。正如你将看到的，量子比特的数量限制了我们可以分解的数字的大小。
- en: And a final issue to take into account is the sheer size of the simulation.
    The great theoretical advantage of using quantum computers is that they have the
    potential for exponential speedup for certain problems. On the flip side of this
    is the fact that simulating quantum computers gets exponentially harder for each
    added qubit.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的一个问题是模拟的规模。使用量子计算机的巨大理论优势是它们有可能在某些问题上有指数级的加速。另一方面，随着每个额外量子比特的增加，模拟量子计算机会变得指数级困难。
- en: When we run Shor's algorithm for bigger numbers, and by bigger, here I mean
    once we pass 63 going upward, your local simulator will start complaining and
    it is time to switch to the IBM Quantum® simulator provided.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行用于更大数字的肖尔算法时，这里所说的“更大”是指一旦我们超过63并向上，你的本地模拟器将开始抱怨，是时候切换到IBM Quantum®提供的模拟器了。
- en: 'Take a look at this table for some suggested numbers to test with:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下表格，以获取一些建议的测试数字：
- en: '![Table 10.1 – Prime factorization of numbers smaller than 40'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![表10.1 – 小于40的数的质因数分解'
- en: '](img/Table_10.1_B14436.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_10.1_B14436.jpg)'
- en: Table 10.1 – Prime factorization of numbers smaller than 40
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 小于40的数的质因数分解
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more factorization fun, see [https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html](https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html)
    and [https://www.mathsisfun.com/prime-factorization.html](https://www.mathsisfun.com/prime-factorization.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于分解的乐趣，请参阅[https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html](https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html)和[https://www.mathsisfun.com/prime-factorization.html](https://www.mathsisfun.com/prime-factorization.html)。
- en: The Qiskit Aqua Shor algorithm accepts odd numbers larger than 1 as input, so
    the table only lists those. The numbers listed as primes themselves cannot be
    factorized, but the rest are fair game. Test a few of these.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'Qiskit Aqua肖尔算法接受大于1的奇数作为输入，因此表格只列出了这些数字。列出的作为质数的数字本身不能被分解，但其余的都可以测试。测试其中的一些。 '
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该菜谱的示例代码可以在以下链接找到：[https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py)。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: To handle the creation and running of the Grover algorithm, we will build three
    functions in the `ch10_r2_shor_aqua.py` script. First, let's check the code and
    then run it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理 Grover 算法的创建和运行，我们将在 `ch10_r2_shor_aqua.py` 脚本中构建三个函数。首先，让我们检查代码，然后运行它。
- en: The sample code
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样本代码
- en: 'First, we import the classes and methods that we need:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的类和方法：
- en: '[PRE10]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `display_shor(N)` function takes an integer as input and uses the `Shor()`
    method to construct and display the short circuit and the circuit data:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`display_shor(N)` 函数接收一个整数作为输入，并使用 `Shor()` 方法构建和显示短路以及电路数据：'
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `run_shor(N)` function takes an integer as input, creates the Shor circuit,
    and runs it on a local simulator. The function then displays the results of the
    run:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run_shor(N)` 函数接收一个整数作为输入，创建 Shor 电路，并在本地模拟器上运行它。函数随后显示运行结果：'
- en: '[PRE12]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `main()` function process prompts and verifies an odd input larger than
    1, and then runs the preceding functions. Start and stop times are used to measure
    the time it takes to construct the circuit and to run it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数处理提示并验证一个大于 1 的奇数输入，然后运行前面的函数。使用开始和结束时间来测量构建电路和运行它所需的时间：'
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running the code
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行代码
- en: In your environment, run `ch10_r2_shor_aqua.py`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的环境中运行 `ch10_r2_shor_aqua.py`。
- en: When prompted, enter N, an odd number larger than 1\.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，输入 N，一个大于 1 的奇数。
- en: 'This is the number that we want to prime factorize. For starters, try the three
    following numbers: **5**, **9**, **15**'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们要进行素数因子分解的数字。首先，尝试以下三个数字：**5**、**9**、**15**
- en: 'The algorithm returns one of three results:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法返回三种结果之一：
- en: '**No prime factors**: If the number that you entered is a prime number that
    cannot be factorized, for example:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**没有素数因子**：如果你输入的数字是一个不能分解的素数，例如：'
- en: '![Figure 10.8 – The result of Shor''s algorithm with an input of 5'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.8 – 使用 5 作为输入的 Shor 算法的结果'
- en: '](img/Figure_10.8_B14436.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B14436.jpg)'
- en: Figure 10.8 – The result of Shor's algorithm with an input of 5
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.8 – 使用 5 作为输入的 Shor 算法的结果
- en: '**Factorized square**: If the number can be expressed as a factorization of
    a prime multiplied by itself:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**平方因子分解**：如果数字可以表示为素数乘以自身的因子分解：'
- en: '![Figure 10.9 – The result of Shor''s algorithm with an input of 9'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.9 – 使用 9 作为输入的 Shor 算法的结果'
- en: '](img/Figure_10.9_B14436.jpg)'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B14436.jpg)'
- en: Figure 10.9 – The result of Shor's algorithm with an input of 9
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.9 – 使用 9 作为输入的 Shor 算法的结果
- en: '**Two prime factorization**: If the number can be expressed as a factorization
    of two different prime numbers. This is the result that we are after:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**两个素数因子分解**：如果数字可以表示为两个不同素数的因子分解。这是我们想要的结果：'
- en: '![Figure 10.10 – The result of Shor''s algorithm with an input of 15'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 10.10 – 使用 15 作为输入的 Shor 算法的结果'
- en: '](img/Figure_10.10_B14436.jpg)'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B14436.jpg)'
- en: Figure 10.10 – The result of Shor's algorithm with an input of 15
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.10 – 使用 15 作为输入的 Shor 算法的结果
- en: Now try the algorithm with bigger numbers and watch how the elapsed time to
    build and execute the circuit increases.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试使用更大的数字运行算法，并观察构建和执行电路所需的时间如何增加。
- en: You will notice that your local simulator finds it harder and harder to keep
    up as the numbers get bigger. On my workstation (Apple iMac, 16 GB RAM), I run
    out of memory to build the circuits beyond the number 63\. The `run_shor(N)` function
    code has a built-in breakpoint where it switches over to the IBM Quantum® simulator
    backend at 64.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到，随着数字的增大，你的本地模拟器越来越难以跟上。在我的工作站（Apple iMac，16 GB RAM）上，当数字超过 63 时，我就没有足够的内存来构建电路了。`run_shor(N)`
    函数代码内置了一个断点，在 64 时切换到 IBM Quantum® 模拟器后端。
- en: Feel free to move the local/IBM Quantum® breakpoint if you feel like testing
    the performance of your local machine. Remember that the IBM Quantum® simulator
    backend runs on an IBM POWER9™ server, with quite a bit of horsepower!
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想测试本地机器的性能，可以随意移动本地/IBM Quantum® 断点。记住，IBM Quantum® 模拟器后端运行在 IBM POWER9™
    服务器上，拥有相当大的计算能力！
- en: There's more…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Just like for the Grover algorithm that we discussed in the *Running Grover''s
    algorithm as an Aqua function* recipe, you can run the Shor function with just
    a few lines of code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 *将 Grover 算法作为 Aqua 函数运行* 菜单中讨论的那样，你只需几行代码就可以运行 Shor 函数：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, we run the Shor algorithm for the number `15`. Running this
    code sample should result in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为数字 `15` 运行 Shor 算法。运行此代码示例应产生以下输出：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What we have done so far is just run the Shor algorithm with one input parameter,
    `N` – the integer that you want to factorize. By default, if your run `Shor()`,
    with no input, it will default to 15, the smallest non-trivial integer that can
    be factorized. Verify this from the preceding table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的工作只是运行了Shor算法，使用一个输入参数`N`——你想要分解的整数。默认情况下，如果你运行`Shor()`而没有输入，它将默认为15，这是可以分解的最小的非平凡整数。请从前面的表中验证这一点。
- en: 'The Shor function optionally takes another input parameter, `a`, a co-prime
    smaller than `N` and with a greatest common divisor of 1:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Shor函数可以选择性地接受另一个输入参数`a`，它是一个小于`N`的互质数，并且最大公约数为1：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By default, `a` is set to `2`, and for the smallish size integers that we are
    playing with here, it will likely make no difference, but feel free to experiment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`a`被设置为`2`，对于我们在这里玩的小型整数，这可能不会有太大影响，但请随意实验。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Scott Aaronson has a delightful blog entry on Shor''s algorithm: *Shor. I''ll
    do it*, at [https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scott Aaronson在他的博客上有一篇关于Shor算法的精彩文章：*Shor. I'll do it*，链接为[https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208)。
- en: For a nice, detailed overview of Shor's algorithm on Python and Qiskit®, see
    *Chapter 12*, *Shor's Algorithm* in *Mastering Quantum Computing with IBM QX,*
    by Dr Christine Corbett Moran, Packt Publishing.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解Shor算法在Python和Qiskit®上的详细概述，请参阅Dr Christine Corbett Moran所著的《Mastering Quantum
    Computing with IBM QX》的第12章，标题为“Shor算法”。
- en: 'And directly from the Qiskit® textbook, here is Shor''s aglorithm broken down
    in Python and Qiskit®: [https://qiskit.org/textbook/ch-algorithms/shor.html](https://qiskit.org/textbook/ch-algorithms/shor.html).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从Qiskit®教科书中，以下是Shor算法在Python和Qiskit®中的分解：[https://qiskit.org/textbook/ch-algorithms/shor.html](https://qiskit.org/textbook/ch-algorithms/shor.html)。
- en: Exploring more Aqua algorithms
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索更多Aqua算法
- en: We have now reached the end of our book, and with that, the end of our trip
    through Qiskit® together. On our trip, we have looked at some basic quantum programming
    and explored the IBM Quantum® backends – the actual quantum computers! We have
    run our programs on these and gotten quantum results back.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了本书的结尾，也是我们共同探索Qiskit®之旅的结束。在我们的旅途中，我们查看了一些基本的量子编程，并探索了IBM Quantum®后端——实际的量子计算机！我们在这些计算机上运行了我们的程序，并得到了量子结果。
- en: We started poking at the real meat of quantum computing, the algorithms. This
    book, however, is not about algorithms; we have just scratched the surface with
    some very basic ideas of how quantum algorithms differ from their classical counterparts
    and how it might feel to write them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始深入研究量子计算的核心，即算法。然而，这本书并不是关于算法的；我们只是用一些非常基本的概念来探讨量子算法与它们的经典对应物之间的差异，以及编写它们可能的感觉。
- en: 'And after touching on how to write algorithms and the sometimes-counterintuitive
    approach to getting the answer compared to classical algorithms, we also looked
    into prefabricated algorithms that are included with Qiskit Aqua: Grover''s algorithm
    and Shor''s algorithm. I like to think of this part of Qiskit® as an appstore
    of quantum computing.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了如何编写算法以及与经典算法相比有时反直觉的求解方法之后，我们还研究了Qiskit Aqua中包含的预制算法：Grover算法和Shor算法。我喜欢将Qiskit®的这一部分视为量子计算的应用商店。
- en: This is where you go when you have a problem that might require a quantum computing
    solution, but you do not necessarily want to sit down and code the algorithm yourself.
    Just like most people do not write their own programs just to get a weather forecast;
    they just use a readily available weather app.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到可能需要量子计算解决方案的问题，但你并不一定想自己编写算法时，你会去这里。就像大多数人不会自己编写程序来获取天气预报一样；他们只是使用现成的天气应用程序。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Qiskit Aqua has more algorithms than just Grover's and Shor's. The IBM Quantum®
    team, and collaborators all around the world, are filling it out with implementations
    and pure algorithms that target promising fields for near future as well as preparing
    for slightly further off implementations as quantum computers grow in strength
    and capabilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Aqua不仅包含Grover算法和Shor算法，IBM Quantum®团队以及全球的合作伙伴们正在通过实现和纯算法来填充它，这些算法针对的是近期有潜力的领域，同时也为量子计算机在强度和能力增强后更远的实现做准备。
- en: Firstly, the Qiskit Aqua components include a set of `qiskit.aqua.algorithms`
    package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Qiskit Aqua组件包括一个`qiskit.aqua.algorithms`包。
- en: 'Among these are the Grover and Shor algorithms that we have tested, but also
    other specific algorithms such as QSVM (Quantum Support Vector Machine), VQE (the
    Variational Quantum Eigensolver algorithm), and more. Explore this library to
    learn how to explore various algorithms on the backends that are available today,
    and to understand how to expand them for use on the universal quantum computers
    of the future:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中包括我们测试过的 Grover 和 Shor 算法，但还有其他特定的算法，如 QSVM（量子支持向量机）、VQE（变分量子本征值求解器算法）等。探索这个库，了解如何在今天可用的后端上探索各种算法，以及如何为未来通用的量子计算机扩展它们：
- en: '`qiskit.chemistry`) lets you experiment with energy calculations on molecules
    using your favorite modeling tool.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qiskit.chemistry`) 允许你使用你喜欢的建模工具在分子上进行能量计算实验。'
- en: '`qiskit.finance`), which includes a set of functions that are structured in
    the form of Ising Hamiltonians applied to financial models.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qiskit.finance`) 包含一系列以伊辛哈密顿量形式结构化的函数，应用于金融模型。'
- en: '`qiskit.ml`), which contains sample sets. You can use these Aqua classifiers
    and SVM algorithms.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qiskit.ml`) 包含样本集。你可以使用这些 Aqua 分类器和 SVM 算法。'
- en: '`qiskit.optimization`). This module contains several submodules with specific
    algorithms, applications, problems, and more.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qiskit.optimization)`。此模块包含具有特定算法、应用、问题等几个子模块。'
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We won''t go any deeper into these specific Qiskit Aqua modules, but to start
    exploring the algorithms, you can follow this path example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这些特定的 Qiskit Aqua 模块，但为了开始探索算法，你可以遵循这个路径示例：
- en: 'Import the package that you are interested in, for example, if you want to
    explore chemistry, this one:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你感兴趣的包，例如，如果你想探索化学，这个：
- en: '[PRE17]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then take a look at the built-in docs.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后查看内置文档。
- en: 'Qiskit® provides excellent Python help where you can start your exploration;
    for example:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qiskit® 提供了卓越的 Python 帮助，你可以从这里开始你的探索；例如：
- en: '[PRE18]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Explore the general Qiskit® resources to further explore the field that you
    are interested in.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索 Qiskit® 的一般资源，以进一步探索你感兴趣的研究领域。
- en: 'For example, the Qiskit® tutorials here: [https://qiskit.org/documentation/tutorials/chemistry/index.html](https://qiskit.org/documentation/tutorials/chemistry/index.html).'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，这里 Qiskit® 的教程：[https://qiskit.org/documentation/tutorials/chemistry/index.html](https://qiskit.org/documentation/tutorials/chemistry/index.html)。
- en: 'And in the *Learn Quantum Computation Using Qiskit* textbook, for example:
    [https://qiskit.org/textbook/ch-applications/vqe-molecules.html](https://qiskit.org/textbook/ch-applications/vqe-molecules.html).'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在 *使用 Qiskit 学习量子计算* 教科书中：[https://qiskit.org/textbook/ch-applications/vqe-molecules.html](https://qiskit.org/textbook/ch-applications/vqe-molecules.html)。
- en: And finally, experiment!
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，进行实验！
- en: Pick up on the various algorithms and integrate them into your own hybrid classical/quantum
    Python code to suit your purposes, much like we have done throughout the various
    recipes in this book.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学习各种算法，并将它们整合到你自己混合经典/量子 Python 代码中，以满足你的需求，就像我们在本书的各个食谱中做的那样。
- en: There are many Qiskit® features that we have not touched yet, such as mixing
    in Boolean logic with your circuits, programming qubits directly with **OpenPulse**,
    more advanced error simulation, and much more. All of these features, and many
    more, are available for your exploration. If you do not want to go it alone, take
    a look around and see whether you can find some quantum computing meetups or workshops
    in your neighborhood.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有许多尚未触及的 Qiskit® 功能，例如在你的电路中混合布尔逻辑，直接用 **OpenPulse** 编程量子比特，更高级的错误模拟等等。所有这些功能，以及更多，都可供你探索。如果你不想独自探索，四处看看，看看你能否在你所在的地区找到一些量子计算聚会或研讨会。
- en: 'The Qiskit Slack channel at [qiskit.slack.com](http://qiskit.slack.com) is
    an excellent starting point for your quantum social exploration. Sign up from
    the Support page on IBM Quantum Experience®: [https://quantum-computing.ibm.com/support](https://quantum-computing.ibm.com/support).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Slack 频道 [qiskit.slack.com](http://qiskit.slack.com) 是你量子社交探索的一个绝佳起点。从
    IBM Quantum Experience® 的支持页面注册：[https://quantum-computing.ibm.com/support](https://quantum-computing.ibm.com/support)。
- en: There's more
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多
- en: The Qiskit Aqua algorithms didn't spring out of thin air; someone wrote them
    and added them to the collection. Qiskit® is open source and is built by an ever-growing
    collection of open source contributors. How about you?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Qiskit Aqua 算法并非凭空出现；有人编写了它们，并将它们添加到集合中。Qiskit® 是开源的，由不断增长的开放源代码贡献者群体构建。你呢？
- en: 'Even if you are not planning to become a Qiskit® contributor, do go ahead and
    explore the source code. If you installed Qiskit® locally, you have the source
    right at your fingertips. If you installed it with the suggested Anaconda, your
    Qiskit® source might be in a location similar to this (example from macOS):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你并没有计划成为Qiskit®的贡献者，也请继续探索源代码。如果你在本地安装了Qiskit®，源代码就在你的指尖。如果你使用建议的Anaconda安装，你的Qiskit®源可能位于类似以下的位置（以下为macOS示例）：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Look around in the functions and classes that build the features and functions
    that we have used throughout the book. Who knows, perhaps you can come up with
    a better way to present qubit states, or come up with a brand-new algorithm, and
    then contribute that method back to Qiskit®.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了我们整本书中使用的特性和功能的函数和类中四处看看。谁知道呢，也许你能想出一个更好的方式来展示量子比特状态，或者提出一个全新的算法，然后将其贡献回Qiskit®。
- en: 'Information about how to contribute to Qiskit® is available here: [https://qiskit.org/documentation/contributing_to_qiskit.html](https://qiskit.org/documentation/contributing_to_qiskit.html).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何为Qiskit®做出贡献的信息，请在此处查看：[https://qiskit.org/documentation/contributing_to_qiskit.html](https://qiskit.org/documentation/contributing_to_qiskit.html)。
- en: See also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Today's algorithm development is largely theoretical as we can successfully
    run them on the available but currently limited NISQ machines and on quantum simulators,
    but we do not have access to backends with hundreds or thousands of qubits. Remember
    that simulators size up exponentially with the number of qubits; running simulators
    at those circuit sizes proves immensely challenging.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的算法开发在很大程度上仍然是理论性的，因为我们可以在目前有限的NISQ机器和量子模拟器上成功运行它们，但我们无法访问拥有数百或数千个量子比特的后端。记住，模拟器的大小会随着量子比特数量的指数增长；在这些电路大小上运行模拟器极具挑战性。
- en: This might change in the not unforeseeable future, at least if IBM Quantum®
    gets its way. In early September 2020, IBM Quantum's Jay Gambetta presented IBM's
    roadmap at the yearly IBM Quantum Summit. It is a bold plan, reaching 1,121 physical
    qubits by late 2023\. With this amount of physical qubits, it will be possible
    to start exploring in earnest error-corrected qubits as per the *Exploring your
    qubits to understand T1, T2, errors, and gates* recipe in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*. So watch this space.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来并非不可预见的时刻，这可能会发生变化，至少如果IBM Quantum®能够如愿以偿的话。2020年9月初，IBM Quantum的Jay Gambetta在年度IBM
    Quantum Summit上展示了IBM的路线图。这是一个大胆的计划，预计到2023年底将达到1,121个物理量子比特。有了这么多物理量子比特，将能够真正开始探索错误纠正量子比特，正如在[*第8章*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220)中“通过Exploring
    your qubits to understand T1, T2, errors, and gates”食谱所描述的，*用Ignis清理你的量子行为*。所以请密切关注这个领域。
- en: 'Here''s the roadmap document: *IBM''s Roadmap For Scaling Quantum Technology*,
    September 15, 2020, Jay Gambetta: [https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/](https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是路线图文档：*IBM的量子技术扩展路线图*，2020年9月15日，Jay Gambetta：[https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/](https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/)。
- en: Thank you!
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感谢！
- en: 'So, dear reader, you have followed me this far, or at least you have flipped
    to the last page of the last chapter to see how the story ends... Spoiler alert:
    It''s a cliffhanger!'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，亲爱的读者，你已经跟随我走到了这里，或者至少你已经翻到了最后一章的最后一页，看看故事是如何结束的...剧透警告：这是一个悬念！
- en: Quantum computing is still very much in its infancy, and the recipe building
    that you have taken part in in this book, while putting you on track for further
    exploration, are not enough to confidently establish your career as a quantum
    computing programmer; this takes time and effort.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算仍然处于初级阶段，你在本书中参与构建的食谱，虽然为你进一步探索指明了方向，但不足以让你自信地确立作为量子计算程序员的职业生涯；这需要时间和努力。
- en: Just like a basic course in C programming might lead you onto the path of making
    your fortune building the next social media phenomenon, this basic dipping-your-toes-in-the-water
    that you have now been exposed to might do the same. With what you now have, go
    ahead, take the plunge, become a Qiskit Advocate, check with your college or university
    for courses and programs to chart out your career path as a quantum computing
    developer or researcher, or why not just start the next big quantum start-up in
    your garage?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一门C编程基础课程可能会引导你走上通过构建下一个社交媒体现象来致富的道路一样，你现在所接触到的这种基础尝试也可能带来同样的效果。现在你已经拥有了这些，那就大胆地跳进去吧，成为Qiskit倡导者，咨询你的大学或学院提供的相关课程和项目，规划你作为量子计算开发人员或研究人员的职业道路，或者为什么不就在你的车库里开始下一个大型的量子初创公司呢？
- en: Have fun!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 玩得开心！
