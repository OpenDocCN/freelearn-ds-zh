- en: '*Chapter 10*: Getting to Know Algorithms with Aqua'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we have finally come to the part where we will slow down a bit on coding
    our own circuits and instead take a look at what is arguably the most interesting
    part of Qiskit®—Qiskit Aqua.
  prefs: []
  type: TYPE_NORMAL
- en: As we were building the various Grover implementations in the last chapter,
    we saw how that seemingly simple algorithm turned into an unwieldy beast of coding
    when you implemented it in Qiskit Terra. If you are building a hybrid classical/quantum
    program (where you just want to use the Grover search function), it would be vastly
    simpler if you could just import and run a Qiskit® implementation of it, or other
    quantum algorithms, and not have to code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: So, with a fanfare and a drum roll, we now take an initial look at a couple
    of Qiskit Aqua algorithms (Grover and Shor) that you can use out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Grover's algorithm as an Aqua function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Shor's algorithm as an Aqua function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more Aqua algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we are done here, you will have looked at how to incorporate Qiskit Aqua
    algorithms into your own code and will know where to find more algorithms to test
    with, and how to start exploring how the algorithms are actually built using Python
    inside Qiskit® code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The quantum programs that we discuss in this chapter can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Running Grover's algorithm as an Aqua function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*, we promised that there was an easier way to include
    Grover's search algorithm in your quantum circuits. In this recipe, we will achieve
    the same results, but without having to build the circuit from scratch; Qiskit
    Aqua will set up the oracle, build the Grover circuit, and run it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Just like importing and calling Python classes and methods for various things,
    such as `from math import pi` to get access to a numerical representation of ![](img/Formula_10_015.png),
    you can do the same with Qiskit® components. Why reinvent the wheel and build
    your implementation of the Grover search algorithm when it is already included
    with Qiskit®?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r1_grover_aqua.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we jump in, let''s take a look at the two forms of input that the Grover
    Aqua algorithm accepts to define the oracle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LogicalExpressionOracle` input type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TruthTableOracle` input type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of a logical expression oracle for the ![](img/Formula_10_001.png)
    oracle that we used in the *The two-bit Grover* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover''s Search Algorithm*, with the least significant bit (LSB) to the left
    in the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This literally translated into: NOT A and B, which then can be translated into
    our Dirac ket notation as first qubit (A) = 0 and second qubit (B) =1, or ![](img/Formula_10_001.png).'
  prefs: []
  type: TYPE_NORMAL
- en: Bit strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use truth-table oracle input, you create a bit-string that represents
    the expected output for the oracle. For the ![](img/Formula_10_001.png) example,
    the bit string is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We walked through this notation briefly for 1- and 2-qubit systems in the *A
    quick introduction to quantum gates* recipe in [*Chapter 2*](B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045),
    *Quantum Computing and Qubits with Python*. Take a look at that if you need a
    refresher.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle the creation and running of the Grover algorithm, we create four
    functions in the `ch10_r1_grover_aqua.py` script. Let''s check out those first
    before we move on to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need, and set some global
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `log_length(oracle_input,oracle_method)` function takes as input the oracle
    input (log or bin) and the oracle method (logical expression or bit string) and
    returns the ideal number of iterations the Grover circuit needs to include. If
    the oracle input is a logical string, we first calculate the number of qubits
    by counting the number of letters in the string, excluding tilde (~), ampersand
    (&), and space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `create_oracle(oracle_method)` function takes the oracle method as input
    and prompts for the oracle logical expression or bit string. From the input, it
    calls the `log_length(oracle_input,oracle_method)` function that calculates the
    required number of iterations based on the ![](img/Formula_10_003.png)  formula.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how it looks in Python:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `create_grover(oracle_type)` function takes the `oracle_type` string, for
    example, `~A&B` as input, and uses the `Grover(LogicalExpressionOracle (oracle_type),num_iterations=num_iterations)`
    function to create the algorithm with the appropriate number of iterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Python, it will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `run_grover(algorithm,oracle_type)` function takes the algorithm that we
    just created as input and runs it first on a local Aer simulator, and then on
    the least busy IBM Quantum® backend with five qubits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how we build that in Python:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function prompts for the oracle method, then creates the oracle
    and runs the Grover algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create and run an Aqua-generated Grover circuit using a logical expression
    as input, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Python environment, run `ch10_r1_grover_aqua.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, select the logical expression oracle method by entering `log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feel free to test the same oracle with the bit string input by entering `bit`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now enter a logical expression like in the previous example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you read out the logical expression, you get `NOT A AND B`, which corresponds
    to ![](img/Formula_10_004.png). Remember, A is the least significant bit, and
    in Qiskit® corresponds to the rightmost digit in the key notation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a bit string oracle, the input would be `0010`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The oracle input and optimal number of iterations are displayed, together with
    the Aqua-created oracle circuit:![Figure 10.1 – The Aqua-created oracle circuit
    for ](img/Figure_10.1_B14436.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10.1 – The Aqua-created oracle circuit for ![](img/Formula_10_001.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The oracle is now run on a local Aer simulator, and the results are displayed
    as follows:![Figure 10.2 – Results of running the  oracle on your local Aer simulator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.2 – Results of running the ![](img/Formula_10_001.png) oracle on your
    local Aer simulator
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The oracle is now run on the least busy IBM Quantum® backend and the results
    are displayed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Results of running the  oracle on an IBM Quantum® backend'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Results of running the ![](img/Formula_10_007.png) oracle on an
    IBM Quantum® backend
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you look over the `ch10_r1_grover_aqua.py` program, then you will find in
    the order of 100 lines of code. Most of this is not needed to run the Grover algorithm.
    Assuming that you get the logical expression or bit string oracle input from somewhere,
    you can run this in just four lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines of code import the required classes. This fourth line
    of code creates and runs the Grover circuit with a logical expression oracle as
    input – in this case, `~A&B`, to code for ![](img/Formula_10_008.png), and pulls
    out the top measurement, the winner coded by the oracle.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, just like with your Terra-built circuits, things happen when you go
    from two qubits to three qubits. Let''s take a look. To see what the final transpiled
    circuit (run on the IBM Quantum® backend) looks like, you can log in to IBM Quantum
    Experience® to see the fully detailed results of your run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following URL, and then log in with your IBM Quantum Experience®
    account: [https://quantum-computing.ibm.com/](https://quantum-computing.ibm.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Welcome** panel, scroll down to **Latest results**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the job that you just ran and click it:![Figure 10.4 – The job results
    for the  oracle on an IBM Quantum® backend in IBM Quantum Experience®
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.4 – The job results for the ![](img/Formula_10_001.png) oracle on
    an IBM Quantum® backend in IBM Quantum Experience®
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compare the circuits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By taking a look at your jobs here, you can compare the size of the circuits
    that you ran as a part of *Building Grover''s search algorithm* recipe in [*Chapter
    9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246), *Grover''s Search Algorithm*,
    and your new Aqua-created circuit:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.5 – 2-qubit Aqua Grover for  versus your Terra-built 2-qubit  Grover'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.5 – 2-qubit Aqua Grover for ![](img/Formula_10_001.png) versus your
    Terra-built 2-qubit ![](img/Formula_10_001.png) Grover
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the 2-qubit circuit, the size is corresponding to what you saw with your
    Terra-built circuit. What you can see from the difference is that the Aqua-built
    circuit uses an **ancillary** qubit to handle the phase-shifting mechanism. This
    makes the circuit a little bit larger, with a depth of 15 for the Qiskit Aqua
    Grover versus 9 for the Qiskit Terra Grover. The size also grows to 24 from 15\.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, run a 3-qubit Qiskit Aqua-created Grover and take a look at the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `ch10_r1_grover_aqua.py` program again, select the log oracle type,
    and use the following logical string to code for ![](img/Formula_10_012.png) :
    `~A & ~B & C`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The results of the Qiskit Aer-run Grover should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Aer result for the Aqua-created  Grover'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Aer result for the Aqua-created ![](img/Formula_10_013.png) Grover
  prefs: []
  type: TYPE_NORMAL
- en: 'And the result of the Grover run on an IBM Quantum® backend should look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – IBM Quantum® result for the Aqua-created  Grover'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – IBM Quantum® result for the Aqua-created ![](img/Formula_10_013.png)
    Grover
  prefs: []
  type: TYPE_NORMAL
- en: Look at these results. They do not look like the 3-qubit results we got in *The
    three-qubit Grover* recipe in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*, but more like the messy 4+ qubit results we saw in
    the *Adding more qubits to the Grover search* recipe. As we discussed in that
    recipe, we have clearly exceeded the circuit depth for a NISQ machine, getting
    more noise than the signal from our experiment.
  prefs: []
  type: TYPE_NORMAL
- en: So, how was that for some fun? We have seen how Qiskit Aqua codes the same algorithm
    that we spent so much time putting together in [*Chapter 9*](B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246),
    *Grover's Search Algorithm*. But Qiskit Aqua contains so much more.
  prefs: []
  type: TYPE_NORMAL
- en: We have barely scratched the surface. If you have spent some time looking over
    quantum information history, you might have a few favorite algorithms picked out;
    one of these is likely Grover's algorithm, but the most famous one is probably
    Shor's algorithm, and that's what's next. Read on!
  prefs: []
  type: TYPE_NORMAL
- en: Running Shor's algorithm as an Aqua function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another one of the real luminaries of quantum computing algorithms is Peter
    Shor's algorithm dating back to 1984, in which he proved that with a sufficiently
    powerful quantum computer, you can prime factorize really large integers. This
    is important not only from an academic point of view but also because, for example,
    factorizing really large (thousands of digits) numbers into constituent prime
    numbers is the core behind today's RSA encryption that is used to secure online
    transactions, from banking and social media to the computers built into your car.
  prefs: []
  type: TYPE_NORMAL
- en: At the point when these sufficiently large quantum computers enter the stage,
    crypto keys that would take weeks, months, years, and longer to break can theoretically
    be broken in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: To level-set our expectations here, running Shor's algorithm on today's NISQ
    machines is more of an academic interest. As you will notice, the Shor circuits
    tend to grow pretty large even for relatively small factorization exercises, and
    as you have seen in the previous chapters, as circuits grow, so do the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Through IBM Quantum Experience®, you have access to quantum computers up to
    15 qubits in size and simulators up to 32\. As you will see, the qubit count limits
    us regarding the size of the number to factorize.
  prefs: []
  type: TYPE_NORMAL
- en: And a final issue to take into account is the sheer size of the simulation.
    The great theoretical advantage of using quantum computers is that they have the
    potential for exponential speedup for certain problems. On the flip side of this
    is the fact that simulating quantum computers gets exponentially harder for each
    added qubit.
  prefs: []
  type: TYPE_NORMAL
- en: When we run Shor's algorithm for bigger numbers, and by bigger, here I mean
    once we pass 63 going upward, your local simulator will start complaining and
    it is time to switch to the IBM Quantum® simulator provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this table for some suggested numbers to test with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – Prime factorization of numbers smaller than 40'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_10.1_B14436.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – Prime factorization of numbers smaller than 40
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For more factorization fun, see [https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html](https://www.mymathtables.com/numbers/one-hundred-factor-and-prime-factor-table.html)
    and [https://www.mathsisfun.com/prime-factorization.html](https://www.mathsisfun.com/prime-factorization.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Qiskit Aqua Shor algorithm accepts odd numbers larger than 1 as input, so
    the table only lists those. The numbers listed as primes themselves cannot be
    factorized, but the rest are fair game. Test a few of these.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The sample code for this recipe can be found here: [https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py](https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/blob/master/Chapter10/ch10_r2_shor_aqua.py).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle the creation and running of the Grover algorithm, we will build three
    functions in the `ch10_r2_shor_aqua.py` script. First, let's check the code and
    then run it.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we import the classes and methods that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `display_shor(N)` function takes an integer as input and uses the `Shor()`
    method to construct and display the short circuit and the circuit data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run_shor(N)` function takes an integer as input, creates the Shor circuit,
    and runs it on a local simulator. The function then displays the results of the
    run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `main()` function process prompts and verifies an odd input larger than
    1, and then runs the preceding functions. Start and stop times are used to measure
    the time it takes to construct the circuit and to run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your environment, run `ch10_r2_shor_aqua.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted, enter N, an odd number larger than 1\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the number that we want to prime factorize. For starters, try the three
    following numbers: **5**, **9**, **15**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The algorithm returns one of three results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**No prime factors**: If the number that you entered is a prime number that
    cannot be factorized, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The result of Shor''s algorithm with an input of 5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.8 – The result of Shor's algorithm with an input of 5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Factorized square**: If the number can be expressed as a factorization of
    a prime multiplied by itself:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.9 – The result of Shor''s algorithm with an input of 9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.9 – The result of Shor's algorithm with an input of 9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Two prime factorization**: If the number can be expressed as a factorization
    of two different prime numbers. This is the result that we are after:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The result of Shor''s algorithm with an input of 15'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B14436.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.10 – The result of Shor's algorithm with an input of 15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now try the algorithm with bigger numbers and watch how the elapsed time to
    build and execute the circuit increases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will notice that your local simulator finds it harder and harder to keep
    up as the numbers get bigger. On my workstation (Apple iMac, 16 GB RAM), I run
    out of memory to build the circuits beyond the number 63\. The `run_shor(N)` function
    code has a built-in breakpoint where it switches over to the IBM Quantum® simulator
    backend at 64.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feel free to move the local/IBM Quantum® breakpoint if you feel like testing
    the performance of your local machine. Remember that the IBM Quantum® simulator
    backend runs on an IBM POWER9™ server, with quite a bit of horsepower!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like for the Grover algorithm that we discussed in the *Running Grover''s
    algorithm as an Aqua function* recipe, you can run the Shor function with just
    a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we run the Shor algorithm for the number `15`. Running this
    code sample should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: What we have done so far is just run the Shor algorithm with one input parameter,
    `N` – the integer that you want to factorize. By default, if your run `Shor()`,
    with no input, it will default to 15, the smallest non-trivial integer that can
    be factorized. Verify this from the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shor function optionally takes another input parameter, `a`, a co-prime
    smaller than `N` and with a greatest common divisor of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By default, `a` is set to `2`, and for the smallish size integers that we are
    playing with here, it will likely make no difference, but feel free to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scott Aaronson has a delightful blog entry on Shor''s algorithm: *Shor. I''ll
    do it*, at [https://www.scottaaronson.com/blog/?p=208](https://www.scottaaronson.com/blog/?p=208).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a nice, detailed overview of Shor's algorithm on Python and Qiskit®, see
    *Chapter 12*, *Shor's Algorithm* in *Mastering Quantum Computing with IBM QX,*
    by Dr Christine Corbett Moran, Packt Publishing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And directly from the Qiskit® textbook, here is Shor''s aglorithm broken down
    in Python and Qiskit®: [https://qiskit.org/textbook/ch-algorithms/shor.html](https://qiskit.org/textbook/ch-algorithms/shor.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring more Aqua algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now reached the end of our book, and with that, the end of our trip
    through Qiskit® together. On our trip, we have looked at some basic quantum programming
    and explored the IBM Quantum® backends – the actual quantum computers! We have
    run our programs on these and gotten quantum results back.
  prefs: []
  type: TYPE_NORMAL
- en: We started poking at the real meat of quantum computing, the algorithms. This
    book, however, is not about algorithms; we have just scratched the surface with
    some very basic ideas of how quantum algorithms differ from their classical counterparts
    and how it might feel to write them.
  prefs: []
  type: TYPE_NORMAL
- en: 'And after touching on how to write algorithms and the sometimes-counterintuitive
    approach to getting the answer compared to classical algorithms, we also looked
    into prefabricated algorithms that are included with Qiskit Aqua: Grover''s algorithm
    and Shor''s algorithm. I like to think of this part of Qiskit® as an appstore
    of quantum computing.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where you go when you have a problem that might require a quantum computing
    solution, but you do not necessarily want to sit down and code the algorithm yourself.
    Just like most people do not write their own programs just to get a weather forecast;
    they just use a readily available weather app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qiskit Aqua has more algorithms than just Grover's and Shor's. The IBM Quantum®
    team, and collaborators all around the world, are filling it out with implementations
    and pure algorithms that target promising fields for near future as well as preparing
    for slightly further off implementations as quantum computers grow in strength
    and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the Qiskit Aqua components include a set of `qiskit.aqua.algorithms`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among these are the Grover and Shor algorithms that we have tested, but also
    other specific algorithms such as QSVM (Quantum Support Vector Machine), VQE (the
    Variational Quantum Eigensolver algorithm), and more. Explore this library to
    learn how to explore various algorithms on the backends that are available today,
    and to understand how to expand them for use on the universal quantum computers
    of the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qiskit.chemistry`) lets you experiment with energy calculations on molecules
    using your favorite modeling tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qiskit.finance`), which includes a set of functions that are structured in
    the form of Ising Hamiltonians applied to financial models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qiskit.ml`), which contains sample sets. You can use these Aqua classifiers
    and SVM algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qiskit.optimization`). This module contains several submodules with specific
    algorithms, applications, problems, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We won''t go any deeper into these specific Qiskit Aqua modules, but to start
    exploring the algorithms, you can follow this path example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the package that you are interested in, for example, if you want to
    explore chemistry, this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then take a look at the built-in docs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Qiskit® provides excellent Python help where you can start your exploration;
    for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explore the general Qiskit® resources to further explore the field that you
    are interested in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the Qiskit® tutorials here: [https://qiskit.org/documentation/tutorials/chemistry/index.html](https://qiskit.org/documentation/tutorials/chemistry/index.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And in the *Learn Quantum Computation Using Qiskit* textbook, for example:
    [https://qiskit.org/textbook/ch-applications/vqe-molecules.html](https://qiskit.org/textbook/ch-applications/vqe-molecules.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And finally, experiment!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick up on the various algorithms and integrate them into your own hybrid classical/quantum
    Python code to suit your purposes, much like we have done throughout the various
    recipes in this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many Qiskit® features that we have not touched yet, such as mixing
    in Boolean logic with your circuits, programming qubits directly with **OpenPulse**,
    more advanced error simulation, and much more. All of these features, and many
    more, are available for your exploration. If you do not want to go it alone, take
    a look around and see whether you can find some quantum computing meetups or workshops
    in your neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Qiskit Slack channel at [qiskit.slack.com](http://qiskit.slack.com) is
    an excellent starting point for your quantum social exploration. Sign up from
    the Support page on IBM Quantum Experience®: [https://quantum-computing.ibm.com/support](https://quantum-computing.ibm.com/support).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Qiskit Aqua algorithms didn't spring out of thin air; someone wrote them
    and added them to the collection. Qiskit® is open source and is built by an ever-growing
    collection of open source contributors. How about you?
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you are not planning to become a Qiskit® contributor, do go ahead and
    explore the source code. If you installed Qiskit® locally, you have the source
    right at your fingertips. If you installed it with the suggested Anaconda, your
    Qiskit® source might be in a location similar to this (example from macOS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Look around in the functions and classes that build the features and functions
    that we have used throughout the book. Who knows, perhaps you can come up with
    a better way to present qubit states, or come up with a brand-new algorithm, and
    then contribute that method back to Qiskit®.
  prefs: []
  type: TYPE_NORMAL
- en: 'Information about how to contribute to Qiskit® is available here: [https://qiskit.org/documentation/contributing_to_qiskit.html](https://qiskit.org/documentation/contributing_to_qiskit.html).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today's algorithm development is largely theoretical as we can successfully
    run them on the available but currently limited NISQ machines and on quantum simulators,
    but we do not have access to backends with hundreds or thousands of qubits. Remember
    that simulators size up exponentially with the number of qubits; running simulators
    at those circuit sizes proves immensely challenging.
  prefs: []
  type: TYPE_NORMAL
- en: This might change in the not unforeseeable future, at least if IBM Quantum®
    gets its way. In early September 2020, IBM Quantum's Jay Gambetta presented IBM's
    roadmap at the yearly IBM Quantum Summit. It is a bold plan, reaching 1,121 physical
    qubits by late 2023\. With this amount of physical qubits, it will be possible
    to start exploring in earnest error-corrected qubits as per the *Exploring your
    qubits to understand T1, T2, errors, and gates* recipe in [*Chapter 8*](B14436_08_Final_PG_ePub.xhtml#_idTextAnchor220),
    *Cleaning Up Your Quantum Act with Ignis*. So watch this space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the roadmap document: *IBM''s Roadmap For Scaling Quantum Technology*,
    September 15, 2020, Jay Gambetta: [https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/](https://www.ibm.com/blogs/research/2020/09/ibm-quantum-roadmap/).'
  prefs: []
  type: TYPE_NORMAL
- en: Thank you!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, dear reader, you have followed me this far, or at least you have flipped
    to the last page of the last chapter to see how the story ends... Spoiler alert:
    It''s a cliffhanger!'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum computing is still very much in its infancy, and the recipe building
    that you have taken part in in this book, while putting you on track for further
    exploration, are not enough to confidently establish your career as a quantum
    computing programmer; this takes time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Just like a basic course in C programming might lead you onto the path of making
    your fortune building the next social media phenomenon, this basic dipping-your-toes-in-the-water
    that you have now been exposed to might do the same. With what you now have, go
    ahead, take the plunge, become a Qiskit Advocate, check with your college or university
    for courses and programs to chart out your career path as a quantum computing
    developer or researcher, or why not just start the next big quantum start-up in
    your garage?
  prefs: []
  type: TYPE_NORMAL
- en: Have fun!
  prefs: []
  type: TYPE_NORMAL
