<html><head></head><body><div><div><div><h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-40" class="chapterTitle">Introducing and Installing Qiskit</h1>
    <p class="normal">In this chapter, you will learn about the <strong class="keyWord">Quantum Information Science Kit</strong> (<strong class="keyWord">Qiskit</strong>) and its advanced features<a id="_idIndexMarker084"/> to develop and implement various quantum algorithms, quantum application modules, and noise models. Qiskit (pronounced kiss-kit) is comprised of various features that help you build quantum circuits, algorithms, and applications easily, and it allows you to run them on both classical simulators and real quantum systems and visualize the results. In this chapter, you’ll also see instructions on how to install Qiskit on your local machine to create quantum circuits and run them on a quantum computer.</p>
    <p class="normal">This chapter will also discuss how to contribute to the open-source community and the development of future quantum applications, as well as how to connect to other like-minded developers and enthusiasts via the <strong class="keyWord">Qiskit community</strong>.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding quantum and classical system interconnections</li>
      <li class="bulletList">Understanding Qiskit APIs</li>
      <li class="bulletList">Installing and configuring Qiskit on your local machine</li>
      <li class="bulletList">Getting support from the Qiskit community</li>
    </ul>
    <h1 id="_idParaDest-41" class="heading-1">Technical requirements</h1>
    <p class="normal">Knowledge of GitHub is recommended as we will review how to contribute to the Qiskit open-source project, which is hosted on GitHub. Having <strong class="keyWord">Agile</strong> and <strong class="keyWord">open-source development</strong> practices is also recommended, but not required. Here is the source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</a>.</p>
    <h1 id="_idParaDest-42" class="heading-1">Understanding quantum and classical system interconnections</h1>
    <p class="normal">In this section, we’ll review<a id="_idIndexMarker085"/> how quantum computational systems<a id="_idIndexMarker086"/> are integrated with classical systems. As quantum computers do not have ways to store the state of a qubit, there is a dependency on classical systems to provide persistent storage for information that is sent to or received from a quantum computer.</p>
    <p class="normal">Since most data originates from classical sources, whether they are from data repositories or remote sensors, there is a need to prepare the data to be used in a quantum system. Likewise, the results from the quantum systems need to be returned not in a quantum state but in binary form so that they can be read back to a classical system for any post-processing that’s required.</p>
    <p class="normal">This hybrid or interconnectivity between classical systems and quantum systems is what we will be reviewing in this section so that you understand how both systems work together to provide you with the most optimal results. Qiskit Runtime, which is a new feature that was introduced in early 2022, has some good examples you can try. There are lots of papers that describe other forms of integrating classical and quantum resources, such as this paper, <em class="italic">A Serverless Cloud Integration For Quantum Computing</em>: <a href="https://arxiv.org/abs/2107.02007">https://arxiv.org/abs/2107.02007</a>.</p>
    <h2 id="_idParaDest-43" class="heading-2">Reviewing the Qiskit library</h2>
    <p class="normal">If you worked on some of the previous<a id="_idIndexMarker087"/> chapters, then you would have noticed that we used Qiskit to create sample circuits, which we used to describe some quantum concepts. As Python developers, you would have also noticed that Qiskit is functionally no different from using any<a id="_idIndexMarker088"/> other Python<a id="_idIndexMarker089"/> libraries, such as <strong class="keyWord">NumPy</strong>, <strong class="keyWord">scikit-learn</strong>, and so on. How we use it within our Python notebooks is also the same as we would use any other package, where we can import the complete package or just a subset of classes and functions. By having the Qiskit modules available through Python, this allows us to integrate our classical algorithms and applications into a quantum system. Leveraging the libraries available in Qiskit to create quantum circuits that execute on quantum devices from a classical development environment such as Python makes integration with your existing classical applications very seamless and straightforward.</p>
    <p class="normal">Qiskit, much like most other open-source projects, is easy to set up, both as a package with Python or as a branch or a fork if you’re just acting as a contributor. It’s very compact and does not require much with respect to resources to run on local machines.</p>
    <p class="normal">Another advantage of creating it as a package for an existing platform such as Python is that there is no need to install a separate integrated development environment or set up complex build systems with confusing dependencies. For those of you who already have Python installed with the currently supported version, you can install Qiskit with a simple <code class="inlineCode">pip</code> command:</p>
    <pre class="programlisting con"><code class="hljs-con">pip install qiskit
</code></pre>
    <p class="normal">But let’s not get too ahead<a id="_idIndexMarker090"/> of ourselves. Now that we understand the purpose of Qiskit and its general functionality, we will work our way to installing Qiskit locally by first understanding how it is organized. Then, we’ll cover how it interacts with your classic systems such as your laptop, server, or cloud application.</p>
    <h2 id="_idParaDest-44" class="heading-2">Understanding how to organize and interact with Qiskit</h2>
    <p class="normal">If you use Python for most<a id="_idIndexMarker091"/> of your development, which I assume<a id="_idIndexMarker092"/> you do, based on the title of this book, then you will understand that most packages are created in some form of hierarchy. At the top level, there are the application modules, while the lower levels refer to the components within each module.</p>
    <p class="normal">Qiskit has components such as classes or objects, and under each of those components, you have functions and members. Qiskit is no different regarding how everything is organized from most other packages, which makes it very easy to find certain features.</p>
    <p class="normal">At the base level you have hardware connectors; these are what connects Qiskit to the various quantum providers. In addition to hardware connectors are the classical simulators; in this book, we will be using the Qiskit Runtime service to run our circuits, which includes some locally installed Qiskit simulators. Of course, as these simulators run on classical systems, they are limited to the number of resources to simulate quantum circuits. As the quantum circuits become more complex, the cost in resources grows rather fast. This has been highlighted in various publications where certain complex quantum circuits can be simulated on classical systems; however, there are discrepancies in the accuracy across the various classical results. This is why having the hardware connectors available to run complex circuits is important, as it allows you to offload complex circuits from classical simulators to real quantum systems that run at utility scale. You might be asking yourself, <em class="italic">what makes a circuit complex?</em> Well, I can say that it does not have to do with relationship status. It’s more about the width of the circuit, which correlates to the number of qubits, and the depth of the circuit, which correlates to the number of operations deep, particularly the number of multi-qubit gates that entangle two or more qubits together. We’ll cover details about each of these in more detail as you progress through the book.</p>
    <p class="normal">Above the connectors and simulators is the fundamental building block for researchers and developers, the Qiskit Runtime. We will go deeper into what the Qiskit Runtime is in later chapters, but for now just think of it as a runtime that provides you with a lot of features to create, run, and optimize your quantum circuits.</p>
    <p class="normal">In the previous versions<a id="_idIndexMarker093"/> of Qiskit, the modules<a id="_idIndexMarker094"/> were set up such that the domain of each algorithm was spread out: by that, I mean the modules covered error correction, simulators, gate and circuit components, and applications. In this case, an algorithm developer would have to learn how to incorporate multiple modules together, therefore causing the developer to have to understand the various components and modules at the base level to incorporate them into their application. This has since changed after the introduction of the latest code changes to Qiskit.</p>
    <p class="normal">First, we need to introduce the three development layers or segments, which allow developers to provide modules to each other to help create quantum applications. Having these three layers, which are not that much different from classical application development, allows classical developers to solely focus on their own layer, which eliminates the need to fully understand what is occurring at another layer. Let’s take a quick look at the three development layers.</p>
    <ul>
      <li class="bulletList">A <strong class="keyWord">kernel</strong> developer is one who develops<a id="_idIndexMarker095"/> code at the lowest level of the three layers. They work mostly on creating quantum circuits, the composition of gates, hardware pulse level controls, and other features that are close to the hardware. Qiskit Terra is the module that the kernel developer would work with, which includes the circuit library that allows them to create new or use existing circuits.</li>
      <li class="bulletList">An <strong class="keyWord">algorithm</strong> developer is one who leverages<a id="_idIndexMarker096"/> the circuits created by the kernel developer to create quantum algorithms. These algorithms can provide ways to encode classical data into a quantum state. For example, the information of a pixel can be represented as a quantum state where the qubits would represent the location and color value of each pixel of an image. They can also create a quantum algorithm that would not need to encode any classical data at all. The algorithm developer could also include some of the latest Qiskit features that provide infrastructure optimizations, such as the Qiskit Runtime, so that the integration of classical and quantum systems is robust.</li>
      <li class="bulletList">A <strong class="keyWord">model</strong> developer is one who applies<a id="_idIndexMarker097"/> algorithms to create applications that solve real-world problems. These model developers can be domain or industry experts that understand the problems that may be intractable for classical systems and determine how to apply quantum algorithms to these problems. By creating models for certain problems, the model developer could provide a quantum application that could, for example, integrate as part of a large workflow or as a service provider, which classical applications could call upon as needed.</li>
    </ul>
    <p class="normal">These three layers working together allow the developer to focus solely within their layer to develop components that could provide the others with the tools they need to enhance their applications. This also facilitates collaboration between each of the developers, as they can provide feedback to each other to further optimize their components.</p>
    <p class="normal">The following diagram illustrates the layers and what Qiskit libraries or components would generally apply to each developer type.</p>
    <p class="center"><img src="img/B18420_03_01.png" alt="A diagram of a software  Description automatically generated" width="719" height="453"/></p>
    <p class="packt_figref">Figure 3.1: Kernel, Algorithm, and Model developer layers</p>
    <p class="normal">Of course, the preceding<a id="_idIndexMarker098"/> information <a id="_idIndexMarker099"/>is based on the current<a id="_idIndexMarker100"/> version of Qiskit. In the future, like many projects, this may change. I highly recommend keeping<a id="_idIndexMarker101"/> up to date with the current <strong class="keyWord">Application Programming Interface</strong> (<strong class="keyWord">API</strong>) documentation to ensure that you are using the proper calls when writing your code. The API<a id="_idIndexMarker102"/> for this can be found on the Qiskit documentation page at <a href="https://www.qiskit.org/documentation/">https://www.qiskit.org/documentation/</a>.</p>
    <p class="normal">The documentation page provides the latest information on the four available modules, often referred to as elements due to their names, as explained at the beginning of this chapter.</p>
    <p class="normal">So far, we have defined the three different development layers that help simplify developers jumping into programming quantum applications without too much of a learning curve. For example, a model developer might only need to understand how the quantum algorithms work to create a model for a classical application rather than having to also learn which gates the circuits used to create the algorithm.</p>
    <p class="normal">The following section will describe the API references so that you understand how to leverage them in your code. The development specifics will be covered in future chapters, where we will talk about the functionality and operations that each can provide.</p>
    <h1 id="_idParaDest-45" class="heading-1">Understanding Qiskit APIs</h1>
    <p class="normal">Qiskit was built for anyone<a id="_idIndexMarker103"/> who wants to work with quantum computers at every level and domain. By this, we mean that if a quantum researcher wanted to work on how the pulses are scheduled on a quantum device, they could do so very easily. The same can be said about users who simply want to extend their applications to leverage a quantum computer to compute information.</p>
    <p class="normal">In this section, we will learn about the various APIs that are available in Qiskit today. As mentioned earlier, Qiskit has various layers that can be leveraged by any domain expert to start using quantum computing in their applications.</p>
    <p class="normal">Let’s take, for example, chemistry researchers who wish to compute the energy state of two molecules but don’t want to go through the hassle of learning about quantum gates and pulses. They just want to load their dataset, classically, to a quantum algorithm and obtain the results transparently. Qiskit was built as a full stack open-source software package to facilitate those and many more user-type scenarios using the application modules.</p>
    <p class="normal">Quantum physicists can experiment at the hardware level by researching ways to schedule pulses to single and multi-qubits. Quantum researchers can work on developing quantum circuits that could minimize noise, which would optimize the results of your quantum circuits.</p>
    <p class="normal">Algorithm researchers and developers usually work on creating quantum algorithms that can be used by various domains and industries either to solve problems faster or provide more accurate results.</p>
    <p class="normal">Finally, domain researchers such as chemists, data scientists, economists, and many others can integrate their classic applications into a quantum system to compute complex problems more optimally or accurately using various features such as the Qiskit Runtime.</p>
    <p class="normal">Qiskit, at the time of writing, has released its latest version, Qiskit 1.0. This new version provides you with a lot of great features that will take your development skills to the next level. Most particularly to the new era of quantum utility!</p>
    <p class="normal">Let’s start off by learning<a id="_idIndexMarker104"/> about the built-in simulators that are available in Qiskit. The simulators are great for getting started, but as your development skills and understanding of quantum increase, so to will your need to run more complex circuits where classical simulators, such as those described herein, could have some limitations.</p>
    <h2 id="_idParaDest-46" class="heading-2">Aer</h2>
    <p class="normal">Before getting into what Aer is, let’s first make<a id="_idIndexMarker105"/> sure we install it, as Aer has moved to its own separate component and as it makes sense to run some simulations when starting, do install it onto your system as it is now a requirement if you plan to run local simulations on your classical system. Simply run <code class="inlineCode">pip install qiskit-aer</code> from your command line, or Python environment, and that should be all you need. Aer provides a framework that can be used to develop debugging tools and create noise models. These tools help replicate a lot of the characteristics of a quantum system by simulating the noise that affects not just the qubit but also the environment and computations. There are generally five highly efficient compiled <em class="italic">simulator categories</em> available in Aer; they are:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">AerProvider</strong>, the main class that contains all the simulators</li>
      <li class="bulletList"><strong class="keyWord">QasmSimulator</strong>, a quantum simulator that allows for simulation methods and options</li>
      <li class="bulletList"><strong class="keyWord">StatevectorSimulator</strong>, an ideal quantum state vector simulator used to produce non-noisy results from your circuit</li>
      <li class="bulletList"><strong class="keyWord">UnitarySimulator</strong>, an ideal quantum unitary simulator</li>
      <li class="bulletList"><strong class="keyWord">Pulse</strong>, a simulator used to generate and schedule pulse operations</li>
    </ul>
    <div><p class="normal">Note, there is discussion over whether <strong class="keyWord">Pulse</strong> will be removed in the near future. It’s included here for the sake of completeness, but it may not always be available. For that reason, we will not explore Pulse further in this chapter.</p>
    </div>
    <p class="normal">We will look at the differences between each simulator category in the upcoming sections and in <em class="chapterRef">Chapter 9</em>, <em class="italic">Simulating Quantum Systems and Noise Models</em>, you will learn more about the specific simulators within each category, including those within Aer itself.</p>
    <h3 id="_idParaDest-47" class="heading-3">The Aer simulator</h3>
    <p class="normal">Aer itself is also a category<a id="_idIndexMarker106"/> that contains a list of its own types of simulators that are specific to obtaining specific information about the quantum circuit, such as the density matrix, matrix product state, and multiple stabilizer simulators. This simulator is the main simulator to reproduce how an actual backend system can behave and includes an <code class="inlineCode">options</code> object, which can be used to provide parameters such as density matrices to reproduce noise typically found in a quantum system.</p>
    <h3 id="_idParaDest-48" class="heading-3">The Qasm simulator</h3>
    <p class="normal">The <strong class="keyWord">Qasm</strong> simulator allows<a id="_idIndexMarker107"/> us to run our circuits<a id="_idIndexMarker108"/> in both clean and noisy simulated environments. The difference between the two is the amount of noise that you wish to apply to the simulator. On the one hand, it could run as an error-free ideal system that you can use to confirm the computational results of your circuit. On the other hand, you could run your circuit through a simulator that includes noise models so that you can replicate the noise and understand how it affects your computations. We will learn more about noise and noise models in <em class="chapterRef">Chapter 10</em>, <em class="italic">Understanding and Mitigating Quantum Noise</em>.</p>
    <p class="normal">The Qasm simulator also has multi-functional capabilities and methods to simulate circuits, such as <code class="inlineCode">statevector</code>, <code class="inlineCode">density_matrix</code>, <code class="inlineCode">stabilizer</code>, <code class="inlineCode">matrix_product_state</code>, and many more. By allowing you the flexibility to configure the Qasm simulator using any of these methods, you can expect an ideal outcome from the measured circuits, along with any models that you wish to incorporate.</p>
    <p class="normal">The Qasm simulator also provides a list of backend options you can use to execute your quantum circuit. These options include setting threshold values to truncate results or setting floating-point precision values and maximum value constraints for executing circuits. These features make Aer the ideal component for those who wish to develop an ideal or replicated noisy system. Typically, Aer is used by researchers who wish to develop noise mitigation or error correction techniques.</p>
    <h3 id="_idParaDest-49" class="heading-3">Statevector simulator</h3>
    <p class="normal">The <strong class="keyWord">Statevector</strong> simulator is, as its name<a id="_idIndexMarker109"/> suggests, a state<a id="_idIndexMarker110"/> vector simulator that provides the final state vector of the circuit without the measurement operation at the end.</p>
    <p class="normal">Results from the Statevector simulator can be visualized by leveraging the various visualization tools of quantum states, such as <strong class="keyWord">histograms</strong> and <strong class="keyWord">cityscape</strong>. The <strong class="keyWord">cityscape</strong> option provides a nice 3D view of both the real and imaginary components of the density matrix (<img src="img/Icon_1.png" alt="" width="15" height="15"/>). Other visualization plots include <strong class="keyWord">Hinton</strong> diagrams, <strong class="keyWord">Pauli vector</strong> plots, and <strong class="keyWord">Bloch spheres</strong>, to name a few. Some of these, such as the Bloch sphere and the qsphere and other visualization tools will be covered in future chapters, as they will help you visualize some of the effects that gates have on qubits.</p>
    <h3 id="_idParaDest-50" class="heading-3">The Unitary simulator</h3>
    <p class="normal">The <strong class="keyWord">Unitary</strong> simulator is quite<a id="_idIndexMarker111"/> simply just<a id="_idIndexMarker112"/> that — it provides the unitary matrix result of your circuit by computing the overall matrix of the circuit. The idea is that a circuit with only unitary operators/gates each operating on a subset of the qubits can be expressed as a single unitary operator. This can be accomplished by multiplying all the operator matrices in the circuit to arrive at a single overall matrix/operator.</p>
    <p class="normal">This is very helpful if you want to confirm that the operations you applied to the qubits match your expected calculations.</p>
    <p class="normal">You can imagine how helpful this will be when you start to work on multiple qubits with many operators. The Unitary simulator helps provide state information so that you can ensure that the results are what you expected.</p>
    <h1 id="_idParaDest-51" class="heading-1">Installing and configuring Qiskit on your local machine</h1>
    <p class="normal">In this section, we will walk<a id="_idIndexMarker113"/> you through the installation<a id="_idIndexMarker114"/> process of Qiskit. It is important to note that to complete the examples in this book, you will need to install Qiskit on your machine locally, as the IBM Quantum Platform no longer has a lab, nor does it have any simulators to run circuits on the cloud, only the actual quantum systems, which you will have limited access. The installation will include installing Anaconda, which is the tool used by many Qiskit developers to install Python, Jupyter Notebooks, Qiskit, and many other data science packages. It also serves as a simple way to manage packages and how they are installed on your local machine. In our case, it will help by installing the prepackaged dependencies we will need, such as Python, Jupyter Notebooks, <code class="inlineCode">pip</code>, and many others.</p>
    <p class="normal">Once installed, you can create an environment<a id="_idIndexMarker115"/> specific to quantum development<a id="_idIndexMarker116"/> with all the dependencies and features already installed. By having a local installation, you can run your circuits from the local system onto simulators on your local device.</p>
    <h2 id="_idParaDest-52" class="heading-2">Preparing the installation</h2>
    <p class="normal">Qiskit is an open-source project<a id="_idIndexMarker117"/> that is available for free to everyone. It is licensed<a id="_idIndexMarker118"/> under the <strong class="keyWord">Apache 2.0</strong> license (<a href="https://apache.org/licenses/LICENSE-2.0">https://apache.org/licenses/LICENSE-2.0</a>). A copy has also been included in each Qiskit module (for example, <a href="https://www.github.com/Qiskit/qiskit/blob/master/LICENSE.txt">https://www.github.com/Qiskit/qiskit/blob/master/LICENSE.txt</a>). This allows you to use the source code, along with all its rights and privileges, as defined in the license.</p>
    <p class="normal">The installation of Qiskit is quite simple, particularly if you are already familiar with the package<a id="_idIndexMarker119"/> management application known as <strong class="keyWord">pip</strong>. To review the Qiskit metadata package information, such as its current<a id="_idIndexMarker120"/> stable version, build status, and other details, go to <a href="https://pypi.org/project/qiskit">https://pypi.org/project/qiskit</a>.</p>
    <p class="normal">We have highlighted that you should install the full version as there have been issues with the mini version. You can, of course, try either, but if you get issues with the mini version, it is recommended that you install the full version.</p>
    <h2 id="_idParaDest-53" class="heading-2">Installing Anaconda</h2>
    <p class="normal">Anaconda (<a href="https://www.anaconda.com/distribution">https://www.anaconda.com/distribution</a>) is an open-source<a id="_idIndexMarker121"/> cross-platform<a id="_idIndexMarker122"/> distribution<a id="_idIndexMarker123"/> of Python. It allows the user to create separate environments so that they can install multiple versions of Python. This is very useful, particularly for those of you who are Python developers and already have a version of Python installed on your machine.</p>
    <p class="normal">By creating a separate environment using Anaconda, you can eliminate issues that may come up due to installing a different version of Python that may affect your existing Python projects or applications. Having separate environments also provides you with the ability to have multiple versions of Qiskit. You need to have a working version of Qiskit up and running while you install an update on a separate environment so that you can test if your quantum applications currently support the latest releases without worrying about dependency issues.</p>
    <p class="normal"><em class="italic">It is recommended to follow the installation instructions on the Anaconda site</em>. The installation steps of Anaconda also include versions of Jupyter Notebook, which comes in handy, as the Qiskit notebooks will not be available locally. However, since the Qiskit notebooks are built on Jupyter Notebooks, you shouldn’t expect to see much of a difference between the two.</p>
    <p class="normal">After installing Anaconda with the supported version of Python – at the time of this writing, the currently supported version is 3.9 – be sure to create an environment in your installation and switch to that environment before proceeding and installing Qiskit. Otherwise, it will install on your base environment. After successfully<a id="_idIndexMarker124"/> completing the installation and creating your Anaconda<a id="_idIndexMarker125"/> environment, you are now ready to install Qiskit!</p>
    <h2 id="_idParaDest-54" class="heading-2">Installing Qiskit</h2>
    <p class="normal">Before installing Qiskit, be sure<a id="_idIndexMarker126"/> to check the installation page (<a href="https://docs.quantum.ibm.com/start/install">https://docs.quantum.ibm.com/start/install</a>) for any updates on either the installation<a id="_idIndexMarker127"/> or configuration steps, as things might change. The following steps will lead you through the installation process:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by ensuring that you are in the environment you created. The best way to determine this is to launch your command line and enter the following:
        <pre class="programlisting con-one"><code class="hljs-con">conda info --envs
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will list all the environments on your system. You will see one titled <code class="inlineCode">base</code> and another with the name of the environment that you created. The current environment is identified by an asterisk, as illustrated in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B18420_03_02.png" alt="Graphical user interface, text  Description automatically generated" width="759" height="78"/></figure>
    <p class="packt_figref">Figure 3.2: Output of the current environment command</p>
    <p class="normal-one">As shown in the preceding<a id="_idIndexMarker128"/> screenshot, another way to identify the environment is to look at the far left of the command line before the machine name. There, in parentheses, is the current environment. In the preceding screenshot, I created an environment called <code class="inlineCode">QiskitEnv</code>. Now, let’s activate the environment by running the following in the command line so we can enable it and start the installation process:</p>
    <pre class="programlisting con-one"><code class="hljs-con">conda activate QiskitEnv
</code></pre>
    <p class="normal-one">This will now activate the environment on your machine.</p>
    <p class="normal-one">For details, I recommend reviewing<a id="_idIndexMarker129"/> the documentation on getting started with <code class="inlineCode">conda</code> here: <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html">https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html</a>.</p>
    <ol>
      <li class="numberedList" value="2">Once you are in the Qiskit environment after activating it in the previous step, you can now run the <code class="inlineCode">pip</code> command to install Qiskit:
        <pre class="programlisting con-one"><code class="hljs-con">&gt;pip install qiskit
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Based on your machine and network speed, this may take a few moments.</p>
    <ol>
      <li class="numberedList" value="3">Once completed, you can verify the installation by entering the following on the command line:
        <pre class="programlisting con-one"><code class="hljs-con">&gt;pip list | grep qiskit
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will list the installed Qiskit packages and their respective versions, which you should see includes all the various Qiskit libraries. To see the most current list of optional packages, just visit the Qiskit metadata package information page at <a href="https://pypi.org/project/qiskit">https://pypi.org/project/qiskit</a>.</p>
    <p class="normal">With that, you have installed and verified that Qiskit is installed on your local device. Now, you can launch a Jupyter Notebook and start using Qiskit!</p>
    <p class="normal"><em class="italic">Wait! Not so fast</em>. There are just a couple<a id="_idIndexMarker130"/> of steps we should cover before we start coding and running circuits. We want to make sure your local machine is configured. The first thing you need to ensure is that you have your <strong class="keyWord">token ID</strong> saved on your local device. This way, when you are ready to run an experiment on a real device or on the simulator on the cloud, you can do so very easily.</p>
    <h2 id="_idParaDest-55" class="heading-2">Configuring your local Qiskit environment</h2>
    <p class="normal">Next, we’ll need to install some new features<a id="_idIndexMarker131"/> to leverage the latest building blocks and visualization packages. The IBM Runtime package and optional visualization package will allow you to run circuits efficiently on a quantum system and visualize the results from your circuit, respectively. Subsequent steps include saving your account information onto your local machine, which will be used to connect and use the IBM Quantum systems.</p>
    <p class="normal">The steps needed to get yourselves up and running are as follows. Note for <strong class="keyWord">Mac</strong> users that the strings in the brackets, in this case, <code class="inlineCode">visualization</code>, need to be wrapped with single quotes (i.e., <code class="inlineCode">'visualization'</code>) – otherwise, you will get an error:</p>
    <ol>
      <li class="numberedList" value="1">Open your terminal and run each of the following:
        <pre class="programlisting con-one"><code class="hljs-con">pip install qiskit-ibm-runtime
pip install qiskit[visualization]
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Once the installations have been completed, you can move on to the next step, which is to set up your account information on your local machine by copying your account API token.</p>
    <ol>
      <li class="numberedList" value="2">There are two places where you can obtain your API token; the first is from your dashboard<a id="_idIndexMarker132"/> on the IBM Quantum Platform page (<a href="https://quantum.ibm.com">https://quantum.ibm.com</a>), as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18420_03_03.png" alt="" width="642" height="248"/></figure>
    <p class="packt_figref">Figure 3.3: API token on the dashboard</p>
    <ol>
      <li class="numberedList" value="3">The second way to obtain<a id="_idIndexMarker133"/> your API token is via the <strong class="screenText">Manage account </strong>page. To get to your account page, just click on your avatar at the top right of the page and select <strong class="screenText">Manage account</strong> from the drop-down list, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="img/B18420_03_04.png" alt="A screenshot of a computer  Description automatically generated" width="410" height="419"/></figure>
    <p class="packt_figref">Figure 3.4: API token on the Manage account page</p>
    <ol>
      <li class="numberedList" value="4">After the account page<a id="_idIndexMarker134"/> opens, click the <strong class="screenText">Copy token</strong> icon located to the right of the <strong class="screenText">API token</strong> field, as highlighted in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"> <img src="img/B18420_03_05.png" alt="Graphical user interface, application  Description automatically generated" width="757" height="277"/></figure>
    <p class="packt_figref">Figure 3.5: Copy your account API token</p>
    <p class="normal-one">Now that you have copied your <strong class="screenText">API token</strong>, let’s save it on your local machine.</p>
    <ol>
      <li class="numberedList" value="5">Launch <strong class="screenText">Jupyter Notebook</strong> by entering the following on the command line:
        <pre class="programlisting con-one"><code class="hljs-con">jupyter notebook
</code></pre>
      </li>
      <li class="numberedList">As we are launching this locally, we do not have the launcher here to create a new notebook, so we will have to create one ourselves. Let’s do that now by clicking <strong class="screenText">New</strong> | <strong class="screenText">Python 3</strong> at the top right of Jupyter Notebook, as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B18420_03_06.png" alt="Graphical user interface, application  Description automatically generated" width="403" height="311"/></figure>
    <p class="packt_figref">Figure 3.6: Creating a new Python 3 notebook</p>
    <p class="normal-one">This will create<a id="_idIndexMarker135"/> a new Python 3 notebook. Note this created a blank notebook, so we also do not have the nice boilerplate cell that imported a lot of the commonly used classes and functions. We will have to either import them, as we need them, or you can just copy/paste in the boilerplate code from a previously created notebook that contains the boilerplate cell. In the following, we will just add the classes and functions as needed.</p>
    <ol>
      <li class="numberedList" value="7">Once it has launched, enter the following into the first cell. You will also want to do this on the “<code class="inlineCode">setup_save_account.ipynb</code>" file that is included in the code samples you have access to. This file will be imported and used in the early chapters for convenience, so please be sure you update the API token information there as well; otherwise, you will see errors when running the sample code:
        <pre class="programlisting code-one"><code class="hljs-code">from qiskit_ibm_runtime import QiskitRuntimeService
# Save your IBM Quantum account to allow you to use systems:
QiskitRuntimeService.save_account(channel="ibm_quantum", token='PASTE-API-TOKEN-HERE', set_as_default=True)
</code></pre>
        <div><p class="normal">Be sure to include the single quotes (<code class="inlineCode">'</code> <code class="inlineCode">'</code>) around your API token in the argument; otherwise, you may get an error.</p>
        </div>
      </li>
    </ol>
    <p class="normal-one">Now that we have saved our API token locally, we won’t have to save it to our local system again unless we delete or change the API token value. Remember to copy your token, as indicated in the preceding command.</p>
    <div><p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Note that you only run this command once. If by chance, you forget and rerun the above function again, you may get a warning. You can find other account setting commands<a id="_idIndexMarker136"/> here in the Qiskit API documentation: <a href="https://docs.quantum-computing.ibm.com/start/setup-channel#select-and-set-up-an-ibm-quantum-channel">https://docs.quantum-computing.ibm.com/start/setup-channel#select-and-set-up-an-ibm-quantum-channel</a>.</p>
    </div>
    <p class="normal">Congratulations! You have successfully configured your local version of Qiskit!</p>
    <p class="normal">You are now ready to run circuits locally on your system. Creating and executing circuits can now be done locally on a simulator for those times when you are unable to obtain network access. Of course, once you are back online, you can use your local version to execute circuits on real devices. This also allows you the freedom to integrate with your own applications or systems with ease. By having the ability to run your code locally, you can integrate new code into your own local applications easily.</p>
    <p class="normal">In this section, you learned<a id="_idIndexMarker137"/> how to install Anaconda, which includes a lot of the dependencies necessary to install Qiskit; how to create a quantum circuit; how to execute the circuit on a simulator; and how to execute the circuit on a quantum computer. Now, we’ll learn how to contribute, collaborate, and get support from the Qiskit global community.</p>
    <h1 id="_idParaDest-56" class="heading-1">Getting support from the Qiskit community</h1>
    <p class="normal">The Qiskit community<a id="_idIndexMarker138"/> is a global group of developers, researchers, and pretty much anyone who is curious about quantum computing that comes together, collaborates, and supports each other to help build knowledge across all community members. It is also used to keep everyone up to speed on the latest in quantum research, education, events, and updates: <a href="https://www.ibm.com/quantum/events">https://www.ibm.com/quantum/events</a>. A recent add-on is the ability<a id="_idIndexMarker139"/> to get certified as a Qiskit developer via the <strong class="keyWord">Qiskit Developer Certification</strong> exam. There is currently an updated course based on the Qiskit 1.x version coming out in late 2024.</p>
    <p class="normal">In this section, you will learn about the community, its many programs, and how you can contribute<a id="_idIndexMarker140"/> and become a <strong class="keyWord">Qiskit advocate</strong> (<a href="https://www.ibm.com/quantum/community#advocates">https://www.ibm.com/quantum/community#advocates</a>). Qiskit advocates are members of the Qiskit community who have passed a rigorous exam, have made many contributions<a id="_idIndexMarker141"/> to the Qiskit community, and have helped many others along the way. Let’s start by introducing you to the community itself.</p>
    <h2 id="_idParaDest-57" class="heading-2">Introducing the Qiskit community</h2>
    <p class="normal">Ever since Qiskit was first deployed<a id="_idIndexMarker142"/> as an open-source project, the open-source community has contributed so many features and enhancements that it has only improved over time. The development ecosystem itself has flourished so much that it is being used in universities, industry, and governments around the world, even in Antarctica!</p>
    <p class="normal">Members of the<a id="_idIndexMarker143"/> Qiskit community, often referred to as <strong class="keyWord">Qiskitters</strong>, often work together as a solid diverse group to ensure everyone is supported. Whether they are newbies to quantum computing or veteran quantum researchers, they all share a passion for collaborating and connecting on various projects. The link to information on Qiskit and the community<a id="_idIndexMarker144"/> can be found at <a href="https://www.ibm.com/quantum/qiskit">https://www.ibm.com/quantum/qiskit</a>, where you will find various links at the top and bottom of the page to tutorials and where to join the Qiskit community and be a part of the largest quantum ecosystem in the world.</p>
    <p class="normal">One of the early projects was to create resources for those new to quantum computing. These resources vary from generating enablement materials to <strong class="keyWord">YouTube</strong> video series. The topics included both hardware and software that described what happened on the backend and software that described new research that others were working on. Along with the resources, there are also events that are planned all over the world at any given time. This includes events such as workshops, where communities join either in person or virtually to learn the latest in quantum computing.</p>
    <p class="normal">Other events also include <strong class="keyWord">hackathons</strong> and code camps, of which the largest is <strong class="keyWord">Qiskit Camp</strong>, which the IBM Quantum team hosts quarterly in different continents around the world. The 3-to-4-day camp usually includes accommodation in very exotic locations, meals, transportation to and from airports, and so on. Researchers from <strong class="keyWord">IBM Research</strong> also participate as lecturers, coaches, and judges. Teams are created and brainstorm ideas for projects that they work together on during the weekend, where they would compete and win prizes. This is very similar to hackathons.</p>
    <p class="normal">Recently, the Qiskit community<a id="_idIndexMarker145"/> initiated the <strong class="keyWord">Qiskit advocate program</strong>. This program was created to provide support to individuals who have actively been involved with the Qiskit community and have contributed over time. To become a Qiskit advocate, you will<a id="_idIndexMarker146"/> need to apply online (<a href="https://www.ibm.com/quantum/community#advocates">https://www.ibm.com/quantum/community#advocates</a>), where you will be given an exam to test your knowledge of Qiskit and specify at least three community contributions. These qualifications, of course, can change over time, so it is recommended that you check the site for any updates and application deadlines.</p>
    <p class="normal">Once accepted into the Qiskit advocate program, you<a id="_idIndexMarker147"/> will have the opportunity to network with other experts and access core members of the Qiskit development team. You will also gain support and recognition from IBM through the Qiskit community, as well as receive invitations to special events such as Qiskit Summer School, seminars, and other major events where you can not only collaborate with others but also lead or mentor as well.</p>
    <h2 id="_idParaDest-58" class="heading-2">Contributing to the Qiskit community</h2>
    <p class="normal">Support across members<a id="_idIndexMarker148"/> is key, not just for Qiskit advocates but for all members. The Qiskit community has set up various channels to offer support to all the members of the community. They<a id="_idIndexMarker149"/> have a <strong class="keyWord">Slack workspace</strong> (<a href="https://qisk.it/join-slack">https://qisk.it/join-slack</a>) that is very active<a id="_idIndexMarker150"/> and has various channels so that members can ask questions, post event updates, or just chat about the latest quantum research that had been recently published. There are also other collaborative sources that Qiskit connects through. The current list of collaboration tools can be found on the main quantum community page: <a href="https://www.ibm.com/quantum/community">https://www.ibm.com/quantum/community</a>.</p>
    <h3 id="_idParaDest-59" class="heading-3">Specializing your skill set in the Qiskit community</h3>
    <p class="normal">One of the most common questions<a id="_idIndexMarker151"/> asked about contributing to the Qiskit community, particularly those who are interested in becoming Qiskit advocates, is, <em class="italic">what are the various ways you can contribute?</em> There are many ways in which you can contribute to the Qiskit community. Ideally, you want to become familiar with the different forms of contributions, such as the following:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Code contributions</strong>: Adding a new feature, optimizing the performance of a function, and bug fixes are some of the good ways to start if you are a developer. If you are new to coding, there is a label that the Qiskit development team<a id="_idIndexMarker152"/> has created for this called <strong class="keyWord">good first issue</strong>. This is an umbrella term for the issues that are ideal for those who are new to the code base.</li>
      <li class="bulletList"><strong class="keyWord">Host a Qiskit event in your area or virtually</strong>: You can host an event and invite a Qiskit advocate to run a workshop or talk to a group about the latest updates in Qiskit.</li>
      <li class="bulletList"><strong class="keyWord">Help others</strong>: You can help others by answering questions asked by other community members, reporting bugs, identifying features that may enhance the development of circuits, and so on.</li>
    </ul>
    <p class="normal">Specializing in an area such as noise mitigation, error correction, or algorithm design is an advantage to the community. The <strong class="keyWord">Qiskit Slack community</strong> has several channels<a id="_idIndexMarker153"/> that focus on specific areas of quantum computing: quantum systems, the IBM Quantum Platform, Qiskit Runtime, quantum algorithms and applications, Qiskit on Raspberry Pi, and many more. If you specialize in any of these areas, you can join the Slack group and collaborate on many technologies<a id="_idIndexMarker154"/> and topics.</p>
    <p class="normal">In this section, you learned about the open-source contribution process and how to find tasks for both beginners and experts so that everyone can contribute.</p>
    <h1 id="_idParaDest-60" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned about the general features and capabilities provided by Qiskit so that you can create highly efficient quantum algorithms. You then learned how to install Qiskit locally, as well as how to contribute and find support from the Qiskit community.</p>
    <p class="normal">We’ve learned more about Qiskit and how it fits on the development stack, and we covered an overview of the application modules and simulators provided in the Qiskit libraries. This provided you with the general skills and functionality to create circuits, which you can then use to apply various operations to the qubits via gates and operators.</p>
    <p class="normal">Then, we learned about Aer, which allows us to create better simulators and how to execute them locally and on the IBM Quantum platform.</p>
    <p class="normal">You learned details on how you can install your own version of Qiskit on your platform using Anaconda. Finally, we learned about the Qiskit community and its advantages to all, particularly those who are new to quantum computing and need a little support to understand some of the challenging content or find someone to collaborate with and expand their horizons.</p>
    <p class="normal">With that, you now have the skills to install and configure Qiskit on your local machine to create and execute quantum circuits in offline mode.</p>
    <p class="normal">In the next chapter, we will start delving into understanding the fundamental basics of quantum computing so we can learn how to create and execute quantum circuits.</p>
    <h1 id="_idParaDest-61" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">In your own words, describe the difference between a kernel developer and an application developer.</li>
      <li class="numberedList">If you wanted to obtain the unitary matrix of a circuit, which simulator would provide the unitary matrix result?</li>
      <li class="numberedList">Can you name and describe in your own words each of the five simulator categories that are provided by Aer?</li>
      <li class="numberedList">Which module would you need to import to plot a histogram?</li>
    </ol>
    <h1 id="_idParaDest-62" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_3.xhtml">https://packt.link/3FyN1</a></p>
    <p class="normal"><img src="img/QR_Code2617625996838265932.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>