<html><head></head><body>
		<div id="_idContainer211">
			<h1 id="_idParaDest-64"><em class="italic"><a id="_idTextAnchor063"/>Chapter 3</em>: IBM Quantum Experience<span class="superscript">®</span> – Quantum Drag and Drop</h1>
			<p>Something pretty amazing happened in the cloud in early 2016; a new type of computer opened its arms to the world—a programmable quantum computer.</p>
			<p>In this chapter, we will talk briefly about the early history of IBM Quantum Experience®, how to get there, and how to open a user account. We will take a look at the drag-and-drop user interface for programming the IBM quantum computers (Circuit Composer).</p>
			<p>Also, we will take a quick peek at how you can move back and forth between IBM Quantum Experience® and Qiskit® by using the underlying OpenQASM coding.</p>
			<p>In this chapter, we will cover the following recipes:</p>
			<ul>
				<li>Introducing IBM Quantum Experience®</li>
				<li>Building quantum scores with Circuit Composer</li>
				<li>Tossing a quantum coin</li>
				<li>Moving between worlds</li>
			</ul>
			<p>We will not stay long here; just long enough to scratch the surface, present a quantum circuit we will play with later in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, and get a feel for the plethora of gates that are available to use.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>The quantum programs that we will discuss in this chapter can be found here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03</a>.</p>
			<p>If you haven't already, get yourself an IBM Quantum Experience® account. For information, see <em class="italic">Creating your IBM Quantum Experience® account</em> in <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Introducing IBM Quantum Experience<span class="superscript">®</span></h1>
			<p><strong class="bold">IBM Quantum Experience®</strong> is an open platform available for someone<a id="_idIndexMarker107"/> to start their quantum computing journey. In it, you have free access to a number of IBM quantum computers, ranging in size from a single qubit to 15 qubits (at the time of writing), as well as a 32-qubit simulator that runs on IBM POWER9™ hardware. That's a lot of power at your fingertips. </p>
			<p>IBM Quantum Experience® opened its doors in May 2016, in a world-first announcement that the public would now have access to actual quantum computing hardware in the cloud. Since then, several other companies have announced similar initiatives and opened up for cloud quantum computing, initially on <em class="italic">simulators</em>. Notable among this crowd are Google, Microsoft, Rigetti, Qutech, and more. As of this book's writing, IBM gives free access to both hardware and software quantum computing through its IBM Quantum Experience®, we will focus on that platform.</p>
			<p>From your web browser, go to the following URL, and log in with your IBM Quantum Experience® account: <a href="https://quantum-computing.ibm.com/">https://quantum-computing.ibm.com/</a>.</p>
			<p>You are now on the main IBM Quantum Experience® landing page from which you can access all the quantum experience tools.</p>
			<p>From here, you will see the following:</p>
			<ul>
				<li>In the right pane, we have backends that are available to you. Clicking on each brings up a data page with the access status, provider access, chip structure and error rate data, the number of qubits, a list of basis gates, and more.</li>
				<li>In the center area, you find your workbench. There's a list of recent circuits, currently running experiments, and your previous experiment results; when you first drop in here, it will be quite empty. From this area, you can also manage your user profile, configure notifications, get your API key, and more. </li>
				<li>To the left, we have the main tools and help resources. These are described in more detail in the next section's <em class="italic">How to do it…</em>.</li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer178">
					<img alt="Figure 3.1 – The IBM Quantum Experience® home page&#13;&#10;" src="image/Figure_3.1_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The IBM Quantum Experience® home page</p>
			<p>Now that we have <a id="_idIndexMarker108"/>successfully logged in and looked around, let's take a look at the quantum computing programming tools at our disposal. From the main menu on the right, you can access the following pages:</p>
			<ul>
				<li><strong class="bold">Results</strong></li>
				<li><strong class="bold">Circuit Composer</strong></li>
				<li><strong class="bold">Quantum Lab </strong></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer179">
					<img alt="Figure 3.2 – The IBM Quantum Experience® programming tools" src="image/Figure_3.2_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – The IBM Quantum Experience® programming tools</p>
			<p>Let's look at <a id="_idIndexMarker109"/>each of those pages now.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Results</h2>
			<p>The <strong class="bold">Results</strong> section <a id="_idIndexMarker110"/>of IBM Quantum Experience® is<a id="_idIndexMarker111"/> just a long list of your pending jobs and your previously run quantum computing programs. You can search, sort, and filter by variables such as execution time, services (backends), and more:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer180">
					<img alt="Figure 3.3 – The Results page" src="image/Figure_3.3_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – The Results page</p>
			<p>The <strong class="bold">Results</strong> pane in<a id="_idIndexMarker112"/> IBM Quantum Experience® includes not<a id="_idIndexMarker113"/> only the jobs that are run from the <strong class="bold">Circuit Composer</strong> but also all jobs that you run on IBM Quantum® backends from your local Qiskit® with the same ID.</p>
			<p>Each job includes not only the results of your job but also other data such as how long the job stayed in each stage of processing, how long it took to run, the status of the job, the <strong class="bold">transpiled</strong> circuit diagram, and the OpenQASM code for the circuit.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Circuit Composer</h2>
			<p>The Circuit<a id="_idIndexMarker114"/> Composer is the main tool for working with<a id="_idIndexMarker115"/> your quantum scores (which is what IBM Quantum Experience® calls quantum programs built using the Circuit Composer tool). We will go through it in detail in the recipes in this chapter, but I will provide you with a quick overview of its components here:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer181">
					<img alt="Figure 3.4 – The Circuit Composer files page" src="image/Figure_3.4_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The Circuit Composer files page</p>
			<p>Just like the <strong class="bold">Results</strong> pane<a id="_idIndexMarker116"/> has a list of jobs, the <strong class="bold">Circuit Composer files</strong> pane<a id="_idIndexMarker117"/> has a list of your <em class="italic">circuits</em>. From here, you can open and run all circuits that you have created using the Circuit Composer. </p>
			<p>You can also click <strong class="bold">New Circuit</strong> to start from scratch, which opens Circuit Composer on an untitled circuit:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer182">
					<img alt="Figure 3.5 – A blank circuit in Circuit Composer" src="image/Figure_3.5_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – A blank circuit in Circuit Composer</p>
			<p class="callout-heading">No Qiskit® overlap</p>
			<p class="callout">The Circuit Composer<a id="_idIndexMarker118"/> window does not (in contrast<a id="_idIndexMarker119"/> to the <strong class="bold">Results</strong> pane) contain any of the circuits that you have run from a local Qiskit® environment. Only the quantum scores that you have created in IBM Quantum Experience® are available here. If you want to see your Qiskit® circuits here, you must import them as OpenQASM code. See the <em class="italic">Moving between worlds</em> recipe at the end of this chapter.</p>
			<p>Once you have opened or created a circuit, a set of new tools open up to help you build your quantum score. These <a id="_idIndexMarker120"/>are covered in the <a id="_idIndexMarker121"/>next recipe, <em class="italic">Building quantum scores with Circuit Composer</em>.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/>Quantum Lab</h2>
			<p>The third toolkit is a <a id="_idIndexMarker122"/>collection of Jupyter Notebook tutorials put<a id="_idIndexMarker123"/> together by the Qiskit® team. You can access them all from the <strong class="bold">Qiskit tutorials</strong> tile. You can also create your Jupyter Notebooks from this pane, and these will show up in this window much like the circuits in the previous one:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer183">
					<img alt="Figure 3.6 – Quantum Lab" src="image/Figure_3.6_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Quantum Lab</p>
			<p class="callout-heading">Running Python programs in notebooks</p>
			<p class="callout">You can also use the Jupyter Notebook environment to run the quantum computing Python sample scripts that we include in this book. Take a look at the <em class="italic">Downloading the code samples</em> recipe in <a href="B14436_01_Final_PG_ePub.xhtml#_idTextAnchor021"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Environment</em>, for a quick reminder.</p>
			<p>In addition to the tools that you will use to code your quantum programs, IBM Quantum Experience® also includes some extended help in the form of two additional pages:</p>
			<ul>
				<li><strong class="bold">Docs</strong>: This page includes a collection of getting started tutorials, a more extensive set of instructions for Circuit Composer, algorithms, and more. This is a good starting point to<a id="_idIndexMarker124"/> explore IBM Quantum Experience® <a id="_idIndexMarker125"/>when you are done working your way through this book.</li>
				<li><strong class="bold">Support</strong>: As IBM Quantum Experience® is built on Qiskit®, the support resources are tailored directly for this type of experience via a Slack workspace and Stack Exchange tags for IBM Quantum Experience® (<strong class="source-inline">ibm-q-experience</strong>) and Qiskit® (<strong class="source-inline">qiskit</strong>). These social environments are vibrant and responsive, and you can bounce around questions, ideas, and more in a give-and-take manner. Questions are not long left unanswered by knowledgeable members and moderators!</li>
			</ul>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Building quantum scores with Circuit Composer</h1>
			<p>This recipe will <a id="_idIndexMarker126"/>walk you through the basic<a id="_idIndexMarker127"/> steps of creating a quantum score in IBM Quantum Experience®, to get a feel for how the composer works, how to build and modify a score, and finally how to analyze the score step by step using <a id="_idIndexMarker128"/>the <strong class="bold">Inspect</strong> feature.</p>
			<p class="callout-heading">Drag-and-drop programming</p>
			<p class="callout">The recipes in this chapter will be run in the IBM Quantum Experience® web environment, using the drag-and-drop interface, which nicely visualizes what you are doing in an intuitive way.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>How to do it...</h2>
			<p>Let's build ourselves a little quantum score:</p>
			<ol>
				<li>From your web browser (Chrome seems to work best), go to the following URL, and then log in with your IBM Quantum Experience® account: <a href="https://quantum-computing.ibm.com/">https://quantum-computing.ibm.com/</a>.</li>
				<li>In the left pane, select <strong class="bold">Circuit Composer</strong>.<p>This opens the composer to a blank <strong class="bold">Untitled circuit</strong>.</p></li>
				<li>Optional: Set the number of qubits to play with.<p>In the default <a id="_idIndexMarker129"/>setting, you will see <a id="_idIndexMarker130"/>three lines, much like a music score (hence the term quantum score). Each line represents one of your qubits, and the basic score is designed for a 5-qubit machine. As you will see in the <em class="italic">Comparing backends</em> recipe in <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®,</em> this is currently the most common setup for the free IBM quantum machines.</p><p>For this example, we want to use only 1 qubit for clarity. If we use all five, the results that will be displayed will also include the results of the four we won't be using, which can be confusing.</p><p>So, in the <strong class="bold">Untitled circuit</strong> tab that you just opened, hover over a qubit label (<strong class="bold">q</strong><strong class="bold">0</strong>). The label shifts to a trash can icon. Use this icon to remove qubits until you have one left. Your quantum score now has only one line. </p><p>Prepending that line is the label, <strong class="bold">q</strong><strong class="bold">0</strong>, which is the name of your qubit:</p><div class="IMG---Figure" id="_idContainer184"><img alt="Figure 3.7 – A blank 1-qubit quantum score" src="image/Figure_3.7_B14436.jpg"/></div><p class="figure-caption">Figure 3.7 – A blank 1-qubit quantum score</p></li>
				<li>Add a <img alt="" src="image/Formula_03_001.png"/> gate<a id="_idIndexMarker131"/> to <a id="_idIndexMarker132"/>the score.</li>
				<li>Now select and drag the <img alt="" src="image/Formula_03_001.png"/> gate to the <strong class="bold">q</strong><strong class="bold">0</strong> line of your score. <p class="callout-heading">Tip</p><p class="callout">As you will see further in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, in Qiskit®, the NOT gate is represented by an <strong class="bold">X</strong>. </p><p>You have now added an X, or NOT gate, which will flip the qubit from its initial set value 0 to 1:</p><div class="IMG---Figure" id="_idContainer187"><img alt="Figure 3.8 – NOT gate added" src="image/Figure_3.8_B14436.jpg"/></div><p class="figure-caption">Figure 3.8 – NOT gate added</p><p class="callout-heading">A glossary of operations</p><p class="callout">To get more information about the available instructions, click the (<strong class="bold">i</strong>) icon in the upper-right corner of Circuit Composer and select <strong class="bold">Operations glossary</strong> to open up an exhaustive guide to all instructions (gates, measurements, and more) that are available to you.</p></li>
				<li>Now, add a <a id="_idIndexMarker133"/>measurement <a id="_idIndexMarker134"/>instruction to finish off your circuit.<p>The measurement instruction is required if you want to run your score and get a result. It measures the state of the <strong class="bold">q</strong><strong class="bold">0</strong> qubit and writes the result (0 or 1) to the classical register (<strong class="bold">c1</strong>) so that you can see the outcome of your experiment.</p><p>In multi-qubit circuits, there is no need to display all the classical registers as lines. Instead, they are represented by one line labeled with the number of classical registers that it represents; for example, <strong class="bold">c5</strong> for five classical registers:</p><div class="IMG---Figure" id="_idContainer188"><img alt="Figure 3.9 – Measurement instruction added" src="image/Figure_3.9_B14436.jpg"/></div><p class="figure-caption">Figure 3.9 – Measurement instruction added</p></li>
				<li>You can <a id="_idIndexMarker135"/>now run your circuit. <p>Optionally, save<a id="_idIndexMarker136"/> the circuit by first selecting <strong class="bold">Untitled circuit</strong> and giving the experiment a good name.</p><p>Click the <strong class="bold">Run on ibmq_qasm_simulator</strong> button. </p></li>
				<li>Take a look at the results. <p>To see the results of your job, click the <strong class="bold">Jobs</strong> icon right beneath the <strong class="bold">Run</strong> button. The results of your job are displayed:</p><div class="IMG---Figure" id="_idContainer189"><img alt="Figure 3.10 – The job results box" src="image/Figure_3.10_B14436.jpg"/></div><p class="figure-caption">Figure 3.10 – The job results box</p><p>Clicking the job<a id="_idIndexMarker137"/> results box opens <a id="_idIndexMarker138"/>the <strong class="bold">Result</strong> page, and displays the final result of the job you just ran. In this case, we got a result of <strong class="bold">1</strong>, with <strong class="bold">100%</strong> certainty:</p><div class="IMG---Figure" id="_idContainer190"><img alt="Figure 3.11 – Job result: 1 with 100% certainty" src="image/Figure_3.11_B14436.jpg"/></div><p class="figure-caption">Figure 3.11 – Job result: 1 with 100% certainty</p></li>
				<li>Now, go ahead and play a little. <p>Drag some more quantum instructions into your score willy-nilly, and adjust the number of qubits up and down. You are now building complex quantum circuits, but not necessarily working quantum programs or algorithms. This would be like soldering on<a id="_idIndexMarker139"/> random gates to your <a id="_idIndexMarker140"/>classical computer or cooking by randomly adding ingredients to your pot. You would get some kind of result, but probably nothing useful or edible. But it is fun!</p><p>Here's an example – see if you can recreate it and then inspect it to see what it does (if anything): </p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer191">
					<img alt="Figure 3.12 – Randomly dragged and dropped circuit" src="image/Figure_3.12_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Randomly dragged and dropped circuit</p>
			<p>Just look at the complex results of that circuit. I wonder what it does? And also, note the two graphical boxes at the bottom of the page: <strong class="bold">Measurement Probabilities</strong> and <strong class="bold">Q-sphere</strong>. I have ignored them until now, but let's take a look and see what they are.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>There's more</h2>
			<p>The score is read, much like a music score, from left to right, in time. This means that the gates on the left side of the score execute before the ones more to the right. You can inspect how your circuit should <a id="_idIndexMarker141"/>behave by using the <strong class="bold">Inspect</strong> feature of the composer:</p>
			<ol>
				<li value="1">In IBM Quantum Experience®, open the circuit that you just created, with a single qubit, a single NOT gate, and a measurement instruction.</li>
				<li>From the top menu, select <strong class="bold">Inspect</strong>. <p>In the <strong class="bold">Inspector</strong> window that opens, you can now step your way through your score to see<a id="_idIndexMarker142"/> how the statevector that<a id="_idIndexMarker143"/> represents your qubit changes as you apply the gates by clicking <strong class="bold">&gt;</strong>. You will also see the so-called Q-sphere, which is a graphical representation of the possible outcomes of your circuit. We first encountered the state vector in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>. More about the Q-sphere can be found in <a href="B14436_06_Final_PG_ePub.xhtml#_idTextAnchor156"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding the Qiskit® Gate Library</em>.</p><p>In our case, with just a single X gate, as we set up our qubit to start as 0, we expect the statevector to start at <img alt="" src="image/Formula_03_003.png"/> and then become <img alt="" src="image/Formula_03_004.png"/> as we apply the first X gate:</p></li>
			</ol>
			<p class="figure-caption"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer194">
					<img alt="Figure 3.13 – Visualizing the X gate action on our qubit as a statevector and as a Q-sphere&#13;&#10;" src="image/Figure_3.13_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Visualizing the X gate action on our qubit as a statevector and as a Q-sphere</p>
			<p>The Q-sphere indicates<a id="_idIndexMarker144"/> that we will get only <a id="_idIndexMarker145"/>one outcome <a id="_idIndexMarker146"/>and that this outcome will be <img alt="" src="image/Formula_03_005.png"/>. If you switch the <strong class="bold">Statevector</strong> display to the <strong class="bold">Measurement Probabilities</strong> option instead, you can verify my statement that the circuit should, indeed, produce the result 100% of the time:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer196">
					<img alt="Figure 3.14 – The result 1 with 100% certainty" src="image/Figure_3.14_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 3.14 – The result 1 with 100% certainty</p>
			<p>The <strong class="bold">Inspect</strong> tool lets you test your circuit at any gate. This is not possible when running on an actual quantum computer, as testing a qubit would be the same as measuring it, and <a id="_idIndexMarker147"/>then the qubit<a id="_idIndexMarker148"/> loses its quantumness and<a id="_idIndexMarker149"/> behaves like a classical bit. What is done here is a quick run of the circuit up to that point using a statevector simulator.</p>
			<p>If you want to include the initial <img alt="" src="image/Formula_03_006.png"/> state in the inspection, then add a barrier instruction before the first gate of your circuit. The barrier doesn't manipulate the qubit but will let the <strong class="bold">Inspect</strong> tool register the initial state of the qubit: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer198">
					<img alt="Figure 3.15 – Adding a barrier gate before the first gate" src="image/Figure_3.15_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Adding a barrier gate before the first gate</p>
			<p>In the chapters that<a id="_idIndexMarker150"/> follow, we will create a<a id="_idIndexMarker151"/> variation of this <strong class="bold">Inspect</strong> feature to look <a id="_idIndexMarker152"/>through our circuits before we run them. For more information, see the <em class="italic">Visualizing circuits and results</em> recipe in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>Tossing a quantum coin </h1>
			<p>One of the examples<a id="_idIndexMarker153"/> I use is what is arguably the simplest useful quantum program that you can build: a simulated coin toss. </p>
			<p>We will go into more detail about the quantum coin toss in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>, but I will use that program as an example here. It is very small, and not too complicated to understand.</p>
			<p>As we discussed briefly in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, a quantum computer, in contrast to a classical computer, provides you with probabilistic, or randomized, computation. In this case, we set up our qubit as a superposition that results in probabilities to get an outcome of 0 or 1, or heads or tails in coin toss nomenclature, when we measure the qubit. </p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>How to do it...</h2>
			<p>Build the quantum circuit and then run it. This is the circuit we will come back to later in the book, on the Qiskit® side of things:</p>
			<ol>
				<li value="1">Log in to IBM Quantum Experience® at <a href="https://quantum-computing.ibm.com/composer">https://quantum-computing.ibm.com/composer</a>.</li>
				<li>From IBM Quantum Experience®, select <strong class="bold">Circuit Composer</strong> from the left pane.</li>
				<li>Create a new circuit.</li>
				<li>Find the gates that you need.<p>In this recipe, we will just use two quantum instructions, one of which we briefly discussed in <em class="italic">Chapter 2</em>, <em class="italic">Quantum Computing and Qubits with Python</em>, in the <em class="italic">Hadamard gate</em> recipe. Remember that the H gate takes the input qubit and creates a superposition.</p><p>We will also use a<a id="_idIndexMarker154"/> measurement instruction to measure the qubit and write the result to the classical bit line at the bottom of the score.</p></li>
				<li>Build the circuit by dragging the H gate from the <strong class="bold">Gates</strong> section of the composer to the first qubit line. And then drag the <strong class="bold">Measurement</strong> instruction to the same line, placing it to the right of the H gate. Your quantum score is now done. Your circuit should look something like this:<p class="figure-caption"> </p><div class="IMG---Figure" id="_idContainer199"><img alt="Figure 3.16 – Simple coin toss circuit" src="image/Figure_3.16_B14436.jpg"/></div><p class="figure-caption">Figure 3.16 – Simple coin toss circuit</p><p class="callout-heading">But why do I have so many qubits that I do not use?</p><p class="callout">The default number of qubits set by the composer is <strong class="bold">3</strong>. You can place your H gate on any qubit you want as long as you place the <strong class="bold">Measure</strong> instruction on the same qubit. </p><p class="callout">There is also nothing stopping you from placing an H gate on each of the qubits followed by a <strong class="bold">Measure</strong> gate. What you are then building is a set of five simultaneous coin tosses. </p><p class="callout">You can also change the number of qubits, by clicking on the <strong class="bold">+</strong> icon directly below the lowest qubit, or by hovering over a qubit and clicking the trashcan icon that appears. </p></li>
				<li>Save the circuit by<a id="_idIndexMarker155"/> first clicking <strong class="bold">Untitled circuit</strong> and giving the experiment a good name, then save it. Your circuit is now ready to run. </li>
				<li>Click the <strong class="bold">Run on ibmq_qasm_simulator</strong> button. </li>
				<li>Take a look at the results. <p>To see the results of your job, click the <strong class="bold">Jobs</strong> icon right beneath the <strong class="bold">Run</strong> button. Wait for the job to display the <strong class="bold">Completed</strong> result, then click the job results box to open the <strong class="bold">Result</strong> page. Your 1,024 runs of the same circuit have resulted in a statistical 50/50 spread of the two possible outcomes 0 and 1, as we expected in the <em class="italic">Quick introduction to quantum gates</em> recipe in <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>. The results will look something like the following:</p><p class="figure-caption"> </p><div class="IMG---Figure" id="_idContainer200"><img alt="Figure 3.17 – The 50/50 result of our quantum coin toss, half heads and half tails" src="image/Figure_3.17_B14436.jpg"/></div><p class="figure-caption">Figure 3.17 – The 50/50 result of our quantum coin toss, half heads and half tails</p><p>Here, the output is a roughly equal probability of getting a 0 or a 1, just like a physical coin, where the probability of heads or tails is roughly equal.</p></li>
				<li>Run your score<a id="_idIndexMarker156"/> on a real quantum computer. <p>But really, running your scores on a simulator is a little disappointing perhaps. That is not why you started down the quantum computing path. But fear not, we can do better. </p><p>We will run the score one more time but select a non-simulator backend. For this simple quantum score, the result will be the same for a 1-qubit coin toss unless the backend is really out of tune. For more complex quantum programs, however, the results will differ between the simulator and the real quantum computer.</p></li>
				<li>Click the <strong class="bold">Run settings</strong> button, and then select a <em class="italic">backend</em> other than <strong class="bold">ibmq_qasm_simulator</strong>. <p>To get a feel for how long your wait time might be for each backend, you can go to the main <strong class="bold">IBM Quantum Experience</strong> dashboard and look at the individual queues for the backends. </p></li>
				<li>Wait for the results. <p>To see the results of your job, click the <strong class="bold">Jobs</strong> icon right beneath the <strong class="bold">Run</strong> button. Wait for the job to display the <strong class="bold">Completed</strong> result, then click the job results box to open the <strong class="bold">Results</strong> page. </p><p class="callout-heading">Get in line</p><p class="callout">By default, your quantum score will run on the online IBM Quantum® simulator that simulates a universal 32-qubit quantum computer. The simulator is a great way to test and tweak your quantum scores to make sure they run the way that you expect them to. Running on the simulator is usually very quick. Running on an actual quantum computer can take longer though, as you will be sharing those with other users. </p></li>
				<li>The results might<a id="_idIndexMarker157"/> look something like the following:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer201">
					<img alt="Figure 3.18 – The quantum coin toss results on a real quantum computer" src="image/Figure_3.18_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – The quantum coin toss results on a real quantum computer</p>
			<p>Note how the result looks fairly similar to what you got on the simulator. This will generally be the case unless the physical quantum computer qubit on which you run your score is out of balance, and favors one outcome over the other. Remember, the actual qubits are physical things and not perfect mathematical abstracts. In <a href="B14436_05_Final_PG_ePub.xhtml#_idTextAnchor128"><em class="italic">Chapter 5</em></a>, <em class="italic">Touring the IBM Quantum® Hardware with Qiskit®,</em> we will, among other things, take a look at how individual qubits behave, and what to expect when running your circuits on them.  </p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>There's more</h2>
			<p>A non-simulator backend can only inherently run a set of basis gates, from which all other gates are <a id="_idIndexMarker158"/>constructed. When you run your quantum program, it gets interpreted by the software, and the fairly complex high-level gate architecture gets <strong class="bold">transpiled</strong> into a basic quantum program that consists of a set of basis gates only—<strong class="source-inline">u1</strong>, <strong class="source-inline">u2</strong>, <strong class="source-inline">u3</strong>, <strong class="source-inline">id</strong>, and <strong class="source-inline">cx</strong>. It turns out that all quantum programs that you write on Qiskit® can be expressed by using only these gates. </p>
			<p>You can see the basis gates used by the quantum backend from the <strong class="bold">Your backends</strong> part of the IBM Quantum Experience® web console, by clicking the backend that you are interested in: </p>
			<p class="figure-caption"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer202">
					<img alt="Figure 3.19 – The ibmq_santiago backend basis gates are u1, u2, u3, cx, and id&#13;&#10;" src="image/Figure_3.19_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – The ibmq_santiago backend basis gates are u1, u2, u3, cx, and id</p>
			<p>Why is this important? Well, the translation of the gates (in your score) to the basis gates that can be run on a<a id="_idIndexMarker159"/> backend is called <strong class="bold">transpiling</strong> and is done before you run the program. The transpiler takes your input score and converts it to the basis gates, which are then run on the backend. </p>
			<p>Now, it turns out that the regular gates that you are using are not always directly translatable to a single basis gate. Sometimes the transpiler has to do a bit of work, reworking your circuit by replacing your gates with clusters of other gates.</p>
			<p>For example, here are the original and transpiled versions of the simple quantum coin toss as run on one<a id="_idIndexMarker160"/> of IBM's 5-qubit machines:</p>
			<p class="figure-caption"> </p>
			<div>
				<div class="IMG---Figure" id="_idContainer203">
					<img alt="Figure 3.20 – Original and transpiled quantum coin toss&#13;&#10;" src="image/Figure_3.20_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Original and transpiled quantum coin toss</p>
			<p>As you can see, not many changes have occurred. The <strong class="bold">H</strong> gate is now a <strong class="bold">U2</strong> gate with 0 and <img alt="" src="image/Formula_03_007.png"/> as input, and our simplified 3-qubit score is replaced by the actual five qubits of the backend. But the depth of the circuit stays the same – two gates long.</p>
			<p>For more complicated circuits, things get more complex mainly because there are other gates in it. In the example that follows, which is from <a href="B14436_09_Final_PG_ePub.xhtml#_idTextAnchor246"><em class="italic">Chapter 9</em></a>, <em class="italic">Grover's Search Algorithm</em>, in addition to X and H gates, there are more elaborate gates, such as the <strong class="bold">controlled-controlled NOT</strong> (<strong class="bold">CCX</strong>) gate <a id="_idIndexMarker161"/>with two inputs and one output. The original score has a depth of 22 gates:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer205">
					<img alt="Figure 3.21 – Original Grover search algorithm for three qubits" src="image/Figure_3.21_B14436.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Original Grover search algorithm for three qubits</p>
			<p>Because the quantum computer backend cannot directly use the X, H, and CCX gates, these have to be transpiled <a id="_idIndexMarker162"/>into U and CX gates. The transpiled score is 49 gates deep:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer206">
					<img alt="Figure 3.22 – Transpiled Grover search algorithm for three qubits&#13;&#10;" src="image/Figure_3.22(a)_B14436-01.jpg"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 3.22 – Transpiled Grover search algorithm for three qubits</p>
			<p class="callout-heading">The importance of the barrier </p>
			<p class="callout">If you take a closer look at the original Grover circuit, you will notice that in some locations, you see two of the same kind of gate immediately following each other. Remember from <a href="B14436_02_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Quantum Computing and Qubits with Python</em>, that quantum gates are reversible, and that two identical gates following each other might simply cancel out. If we let the transpiler go to work, it would just remove the duplicated gates in order to simplify the circuit. This is usually not the best solution as the gates might be part of a bigger structure that needs to be kept intact.</p>
			<p class="callout">This is where the barrier component and the vertical gray bar in the score comes in. A <strong class="bold">barrier</strong> tells the<a id="_idIndexMarker163"/> transpiler to not simplify across it; if two identical gates are separated by a barrier, the transpiler will <a id="_idIndexMarker164"/>not remove them but transpile each of them into the correct gate type. Take a look at the transpiler version of the Grover score and you will see what I mean.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Moving between worlds</h1>
			<p>Now you have seen how to create your quantum scores in Circuit Composer, and how to run them on a <a id="_idIndexMarker165"/>simulator, and on a real IBM quantum computer. But the rest of the book will be about working in Qiskit® with your programs. Do we just say farewell to IBM Quantum Experience® then?</p>
			<p>Not so fast. IBM Quantum Experience® is a great environment for learning how to build quantum scores, and you do not have to troubleshoot Python code or worry about your environment being up to date (IBM takes care of that for you), and it is actually pretty easy to take what you create in IBM Quantum Experience® and just move it over to Qiskit®.</p>
			<p>You have two options: </p>
			<ul>
				<li><strong class="bold">Qiskit®</strong>: With Qiskit®<a id="_idIndexMarker166"/> code export, your quantum score is translated into Python code that you can paste directly into your Python interpreter and run. This is a one-way trip from IBM Quantum Experience® to Qiskit®.</li>
				<li><strong class="bold">QASM</strong>: Underneath<a id="_idIndexMarker167"/> the covers, IBM Quantum Experience® runs <strong class="bold">OpenQASM</strong> (<strong class="bold">Quantum Assembly Language</strong>) code to keep track of your scores. You can export your quantum scores as QASM from the <strong class="bold">Code Editor</strong>. You can then use the <strong class="source-inline">QuantumCircuit.from_qasm_str()</strong> method in Qiskit® to import that code. To go the other way, use <strong class="source-inline">&lt;circuit&gt;.qasm()</strong> to export your circuit from Qiskit® and then paste into <strong class="bold">Code Editor</strong> to go the other way. </li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Getting ready</h2>
			<p>The Python files for this recipe can be downloaded from here: <a href="https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03">https://github.com/PacktPublishing/Quantum-Computing-in-Practice-with-Qiskit-and-IBM-Quantum-Experience/tree/master/Chapter03</a>.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>How to do it...</h2>
			<p>Let's start by importing the QASM code from your coin toss experiment:</p>
			<ol>
				<li value="1">From your web <a id="_idIndexMarker168"/>browser, go to the following URL, and then log in with your IBM Quantum Experience® <a id="_idIndexMarker169"/>account: <a href="https://quantum-computing.ibm.com/">https://quantum-computing.ibm.com/</a>.</li>
				<li>Select <strong class="bold">Circuit Composer</strong>, and in the breadcrumb click <strong class="bold">Circuits</strong>. </li>
				<li>On the <strong class="bold">Circuit Composer</strong> file page, click your <strong class="bold">Coin toss</strong> circuit.</li>
				<li>In the <strong class="bold">Circuit Composer</strong> window, in the left pane, select the <strong class="bold">&lt;\&gt; Code</strong> editor.</li>
				<li>To export your quantum score as Qiskit® code, in the dropdown select <strong class="bold">Qiskit</strong>, then copy the <a id="_idIndexMarker170"/>Python code you see into your Python interpreter. This will create a quantum circuit called <strong class="bold">circuit</strong> in your environment, which you can then continue working with, for example, by adding a <strong class="source-inline">print(circuit)</strong> line and running the code. This will result in an output something like this:<div class="IMG---Figure" id="_idContainer207"><img alt="Figure 3.23 – The exported coin toss Python code and its output&#13;&#10;" src="image/Figure_3.23_B14436.jpg"/></div><p class="figure-caption">Figure 3.23 – The exported coin toss Python code and its output</p></li>
				<li>To export your quantum <a id="_idIndexMarker171"/>score as QASM code, in the dropdown, select <strong class="bold">QASM</strong>, then<a id="_idIndexMarker172"/> copy the QASM code you see. It should look something like this:<p class="source-code">OPENQASM 2.0;</p><p class="source-code">include "qelib1.inc";</p><p class="source-code">qreg q[1];</p><p class="source-code">creg c[1];</p><p class="source-code">h q[0];</p><p class="source-code">measure q[0] -&gt; c[0];</p><p>You can also click on <strong class="bold">Export</strong> to save the code as a <strong class="source-inline">.qasm</strong> file, and later import that file into Qiskit®.</p></li>
				<li>Now, move over to your Qiskit® environment and run the <strong class="source-inline">ch3_r1_import_qasm.py</strong> file. If you have forgotten how to get there, take a look at the <em class="italic">Open a recipe file</em> recipe in <em class="italic">Chapter 1</em>, <em class="italic">Preparing Your Environment</em>.</li>
				<li>For this simple recipe, we will only need the <strong class="source-inline">QuantumCircuit</strong> method, so we'll add that:<p class="source-code">from qiskit import QuantumCircuit</p></li>
				<li>First, we import the QASM string from IBM Quantum Experience®, either as a pasted string<a id="_idIndexMarker173"/> or <a id="_idIndexMarker174"/>as a saved file:<p class="source-code">qasm_string=input("Paste in a QASM string from IBM     Quantum Experience (or enter the full path and file     name of a .qasm file to import):\n")</p><p class="source-code">if qasm_string[-5:] == ".qasm":</p><p class="source-code">    circ=QuantumCircuit.from_qasm_file(qasm_string)</p><p class="source-code">else:</p><p class="source-code">    circ=QuantumCircuit.from_qasm_str(qasm_string)</p></li>
				<li>If you paste in the QASM code at the prompt, you will end up with something similar to the following example. If you enter a filename, the file will get imported, with much the same end result:<p class="source-code">Ch 3: Moving between worlds 1</p><p class="source-code">-----------------------------</p></li>
				<li>Paste in a QASM string from IBM Qx (or enter the full path and filename of a <strong class="source-inline">.qasm</strong> file to import):<p class="source-code">OPENQASM 2.0;</p><p class="source-code">include "qelib1.inc";</p><p class="source-code">qreg q[1];</p><p class="source-code">creg c[1];</p><p class="source-code">h q[0];</p><p class="source-code">measure q[0] -&gt; c[0];</p></li>
				<li>Hit <em class="italic">Enter</em> and the circuit is imported to Qiskit®, and can now be used for quantum computations. The added print(circuit) at the end should display something like the following:<div class="IMG---Figure" id="_idContainer208"><img alt="Figure 3.24 – The imported coin toss quantum circuit&#13;&#10;" src="image/Figure_3.24_B14436.jpg"/></div><p class="figure-caption">Figure 3.24 – The imported coin toss quantum circuit</p></li>
				<li>You have now <a id="_idIndexMarker175"/>imported your QASM code into Qiskit® and created a <a id="_idIndexMarker176"/>quantum circuit object named <strong class="source-inline">circ</strong>.</li>
			</ol>
			<p>Now let's try creating and exporting OpenQASM code from Qiskit®:</p>
			<p class="callout-heading">But I don't know how to code in Qiskit® yet</p>
			<p class="callout">Up until this point, you have not yet created any quantum circuits in Qiskit®. Not to worry, we will use the <strong class="source-inline">random_circuit()</strong> method to create random circuits that you can export and then import into IBM Quantum Experience® to take a look at.</p>
			<ol>
				<li value="1">In your Qiskit® environment, open the <strong class="source-inline">ch3_r2_export_qasm.py</strong> file.</li>
				<li>The random circuit method to import is this:<p class="source-code">from qiskit.circuit.random.utils import random_circuit</p></li>
				<li>First, we create and print a random quantum circuit:<p class="source-code">circ=random_circuit(2,2,measure=True)</p><p>The depth of the random circuit is set to <strong class="source-inline">2</strong> in this example, which means we will create a circuit with two gates maximum. The number of qubits is also set to <strong class="source-inline">2</strong>, with obvious results. You can tweak these numbers to see what shows up.</p><p>The <a id="_idIndexMarker177"/>circuit <a id="_idIndexMarker178"/>might look something like this:</p><div class="IMG---Figure" id="_idContainer209"><img alt="Figure 3.25 – A randomly created circuit&#13;&#10;" src="image/Figure_3.25_B14436.jpg"/></div><p class="figure-caption">Figure 3.25 – A randomly created circuit</p></li>
				<li>Next, we export the circuit as QASM code:<p class="source-code">circ.qasm(formatted=True, filename="Circuit.qasm")</p><p>The QASM code is displayed and is also saved to a file in your local environment with the filename specified:</p><p class="source-code">OPENQASM 2.0;</p><p class="source-code">include "qelib1.inc";</p><p class="source-code">qreg q[2];</p><p class="source-code">creg c[2];</p><p class="source-code">id q[0];</p><p class="source-code">u1(3.072089) q[1];</p><p class="source-code">rzz(0.7638327) q[1],q[0];measure q[0] -&gt; c[0];</p><p class="source-code">measure q[1] -&gt; c[1];</p></li>
				<li>Back in IBM <a id="_idIndexMarker179"/>Quantum Experience®, you can now go to the circuit <a id="_idIndexMarker180"/>editor in the <strong class="bold">Circuit Composer</strong> window. Click <strong class="bold">New</strong> to open an empty circuit composer, then select the <strong class="bold">&lt;\&gt; Code</strong> editor and paste in the randomly generated circuit QASM code. Or, click <strong class="bold">Import Code</strong> to import the <strong class="source-inline">Circuit.qasm</strong> file that you just created.</li>
				<li>Watch your circuit instantly appear in Circuit Composer:<div class="IMG---Figure" id="_idContainer210"><img alt="Figure 3.26 – Imported, randomly generated circuit&#13;&#10;" src="image/Figure_3.26_B14436.jpg"/></div><p class="figure-caption">Figure 3.26 – Imported, randomly generated circuit</p></li>
				<li>You can now run the circuit, drag and drop new gates into the circuit, or just move or tweak<a id="_idIndexMarker181"/> the existing gates to see how your changes cause the<a id="_idIndexMarker182"/> circuit to behave differently. Don't forget to use the <strong class="bold">Inspect</strong> feature, <strong class="bold">Measurement probabilities</strong>, and <strong class="bold">Q-sphere</strong> displays to step through your circuit and see what it does.</li>
			</ol>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>How it works...</h2>
			<p>When you use the <strong class="source-inline">circ=QuantumCircuit.from_qasm_file()</strong> method to import your quantum score, the <strong class="source-inline">circ</strong> object that you assign it to is now a <strong class="source-inline">QuantumCircuit()</strong> object, much in the same way that you will be creating quantum circuits in the chapters that follow. </p>
			<p>Using Qiskit®, you can display the circuit, append gates to the circuit, and more.</p>
			<p>We will not be doing anything elaborate with the circuit in this chapter, but put a bookmark here to return when you start creating your own circuits in <a href="B14436_04_Final_PG_ePub.xhtml#_idTextAnchor081"><em class="italic">Chapter 4</em></a>, <em class="italic">Starting at the Ground Level with Terra</em>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>There's more</h2>
			<p>As you work your way <a id="_idIndexMarker183"/>through this book, you will be running your experiments mainly in your Python Qiskit® environment. If you want to, you can pull the circuits that you build over from the IBM Quantum Experience® environment and run them here as well. Perhaps you like the graphical drag-and-drop environment better, and the option to edit your scores on the fly? </p>
			<p>In the Qiskit® Python examples that follow, we will be creating <strong class="source-inline">QuantumCircuit</strong> objects that we give names such as <strong class="source-inline">qc</strong>, <strong class="source-inline">circ</strong>, <strong class="source-inline">circuit</strong>, and so on. You can export these to QASM and then import them to IBM Quantum Experience® using the <strong class="source-inline">circ.qasm(formatted=True, filename="Circuit.qasm")</strong> command. </p>
			<p>If you want, you can use the <strong class="source-inline">print(circ)</strong> or <strong class="source-inline">circ.draw()</strong> functions to print out the circuit, and then manually recreate it in the composer. </p>
			<h3>Our sample code from building quantum scores with IBM Quantum Experience<span class="superscript">®</span></h3>
			<p>If you <a id="_idIndexMarker184"/>remember, we displayed a fairly <a id="_idIndexMarker185"/>complex but random circuit in the second recipe of this chapter. Here is the QASM code for that circuit. Go ahead and import it and see if you get the same results:</p>
			<p class="source-code">OPENQASM 2.0;</p>
			<p class="source-code">include "qelib1.inc";</p>
			<p class="source-code">qreg q[5];</p>
			<p class="source-code">creg c[5];</p>
			<p class="source-code">h q[0];</p>
			<p class="source-code">y q[1];</p>
			<p class="source-code">y q[2];</p>
			<p class="source-code">ch q[3],q[4];</p>
			<p class="source-code">ccx q[2],q[0],q[1];</p>
			<p class="source-code">u3(2.1128893,1.9882648,5.5897911) q[3];</p>
			<p class="source-code">tdg q[4];</p>
			<p class="source-code">cu1(3.0287577) q[1],q[4];</p>
			<p class="source-code">cu3(5.1184948,2.0719417,1.8609727) q[3],q[0];</p>
			<p class="source-code">s q[4];</p>
			<p class="source-code">z q[0];</p>
			<p class="source-code">ry(3.6419028) q[1];</p>
			<p class="source-code">rz(0.402055) q[2];</p>
			<p class="source-code">cu3(1.5290482,3.844241,4.4343541) q[2],q[3];</p>
			<p class="source-code">ccx q[4],q[0],q[2];</p>
			<p class="source-code">ch q[1],q[3];</p>
			<p class="source-code">measure q[0] -&gt; c[0];</p>
			<p class="source-code">measure q[1] -&gt; c[1];</p>
			<p class="source-code">measure q[2] -&gt; c[2];</p>
			<p class="source-code">measure q[3] -&gt; c[3];</p>
			<p class="source-code">measure q[4] -&gt; c[4];</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>See also</h2>
			<p>For much more <a id="_idIndexMarker186"/>information about <a id="_idIndexMarker187"/>OpenQASM, see the following publications:</p>
			<ul>
				<li><em class="italic">Open Quantum Assembly Language</em>, Andrew W. Cross, Lev S. Bishop, John A. Smolin, Jay M. Gambetta, <a href="https://arxiv.org/abs/1707.03429">https://arxiv.org/abs/1707.03429</a>.</li>
				<li><em class="italic">OpenQASM</em> GitHub project: <a href="https://github.com/Qiskit/openqasm">https://github.com/Qiskit/openqasm</a>.</li>
			</ul>
		</div>
	</body></html>