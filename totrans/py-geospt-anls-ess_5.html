<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 5. Analyzing Geospatial Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Analyzing Geospatial Data</h1></div></div></div><p>In this chapter, we will look at the process of analyzing geospatial data. Sometimes, the results of your geospatial analysis will be one or more numbers, for example, <span class="emphasis"><em>How many countries lie south of the Equator?</em></span> or <span class="emphasis"><em>What is the length of the Australian coastline?</em></span> At other times, the results of your analysis will be a geometry object, for example, <span class="emphasis"><em>Where is the northernmost point in Alaska?</em></span> or <span class="emphasis"><em>What part of Texas lies east of New Mexico?</em></span> And at other times, the results of your analysis will be a list, for example, <span class="emphasis"><em>Which countries are within 1,000 kilometers of New Guinea?</em></span> In all these cases, you will need to be familiar with the tools and techniques available for calculating your desired results.</p><p>To help you learn these tools and techniques, we will examine the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to install and use two powerful Python libraries for solving geospatial problems</li><li class="listitem" style="list-style-type: disc">How to calculate and work with locations</li><li class="listitem" style="list-style-type: disc">How to calculate the length of a LineString geometry in real-world units</li><li class="listitem" style="list-style-type: disc">How to calculate the area of a Polygon using real-world units</li><li class="listitem" style="list-style-type: disc">How to use a shapefile containing roads to build an abstract model of connected LineString geometries, and then use that model to calculate the shortest path between two points.</li></ul></div><p>Let's start by looking at some of the Python libraries you can use for geospatial analysis.</p><div class="section" title="Libraries for spatial analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Libraries for spatial analysis</h1></div></div></div><p>You already have a couple of libraries<a id="id346" class="indexterm"/> that are useful for analyzing geospatial data: the OGR <a id="id347" class="indexterm"/>library includes methods for comparing and manipulating geometries, and Shapely is a wonderful library for working with and analyzing geometry data. There are, however, two other libraries that you will want to become familiar with: <span class="strong"><strong>PyProj</strong></span>, which is a powerful library for <a id="id348" class="indexterm"/>calculating distances and locations on the Earth's surface, and <a id="id349" class="indexterm"/>
<span class="strong"><strong>NetworkX</strong></span>, which can build abstract mathematical models out of geospatial data and then analyze those models to solve various problems.</p><p>Let's take a closer look at these two libraries and install them both onto your computer.</p><div class="section" title="PyProj"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>PyProj</h2></div></div></div><p>PyProj (<a class="ulink" href="https://pypi.python.org/pypi/pyproj">https://pypi.python.org/pypi/pyproj</a>) is a powerful tool for working with spatial<a id="id350" class="indexterm"/> reference<a id="id351" class="indexterm"/> systems using Python. PyProj itself is simply a <a id="id352" class="indexterm"/>Python interface to the PROJ.4 cartographic projection library, which is written in C. So, to install PyProj, you typically need to install the PROJ.4 library, and then install or build PyProj itself.</p><p>Before we get into the details of installing PyProj (and PROJ.4), let's look at what this library does and how it can be useful. If you remember from <a class="link" href="ch02.html" title="Chapter 2. Geospatial Data">Chapter 2</a>, <span class="emphasis"><em>Geospatial Data</em></span>, a spatial reference system is a way of representing positions on the Earth's surface using coordinates. <span class="strong"><strong>Unprojected coordinates</strong></span>, such as <a id="id353" class="indexterm"/>latitude and longitude values, directly represent a location on the Earth's surface by tracing a line from the center of the earth out to the desired point and then measuring the angle of that line in the east-west and north-south directions:</p><div class="mediaobject"><img src="images/4102_05_01.jpg" alt="PyProj"/></div><p>
<span class="strong"><strong>Projected coordinates</strong></span>, on<a id="id354" class="indexterm"/> the other hand, represent locations as positions on a two-dimensional Cartesian plane:</p><div class="mediaobject"><img src="images/4102_05_02.jpg" alt="PyProj"/></div><p>A <a id="id355" class="indexterm"/>spatial reference system, also known as a cartographic projection, is a way <a id="id356" class="indexterm"/>of translating from points on the Earth's surface to points on a two-dimensional plane. PROJ.4 (and also PyProj) is a tool for working with these projections.</p><p>It is vital that you know which <a id="id357" class="indexterm"/>map projection was used to generate your geospatial data. Using the wrong projection will ruin all your calculations and map visualizations. Map projections are also important because it is all-but-impossible to do spatial calculations using data in unprojected coordinate systems such as EPSG 4326. For example, imagine that you want to calculate the area of the following polygon, which represents the outline of Loch Ness in Scotland:</p><div class="mediaobject"><img src="images/4102_05_03.jpg" alt="PyProj"/></div><p>The coordinates for this polygon are in EPSG 4326—that is, they are latitude and longitude values. If you wanted to, you could load this polygon into Shapely and ask it to calculate the area:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; wkt = "POLYGON ((-4.335556 57.373056,-4.676389 57.138611,-4.447778 57.324722,-4.349167 57.386944,-4.334444 57.379444,-4.335556 57.373056))"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; polygon = shapely.wkt.loads(wkt)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print polygon.area</strong></span>
<span class="strong"><strong>0.006077434151</strong></span>
</pre></div><p>The result, however, is<a id="id358" class="indexterm"/> an <span class="emphasis"><em>area in degrees</em></span>, which is a meaningless number. This is because Shapely doesn't know about spatial reference systems. It naively treats the latitude and longitude values as (x,y) coordinates, which means that spatial calculations like this cannot produce useful or accurate results.</p><p>What you actually want is the area measured in something meaningful, such as square meters or square miles. This is where PyProj comes in. PyProj allows you to perform calculations and conversions using any spatial reference system. PyProj does all the heavy mathematical lifting so you don't have to.</p><p>Now, let's install PyProj and see how it works. How you install PyProj (and the underlying PROJ.4 library), depends on which operating system you are using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For MS Windows, you can<a id="id359" class="indexterm"/> install a prebuilt copy of PyProj from <a class="ulink" href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj</a>. This installer includes PROJ.4, so you don't need to install it separately.</li><li class="listitem" style="list-style-type: disc">For Mac OS X, you <a id="id360" class="indexterm"/>will need to do the following:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download and install the PROJ.4 library. A Mac installer for PROJ.4<a id="id361" class="indexterm"/> can be downloaded from <a class="ulink" href="http://www.kyngchaos.com/software/frameworks">http://www.kyngchaos.com/software/frameworks</a>.</li><li class="listitem">If you don't already have XCode installed on your computer, go to the Mac App store and download the latest version. XCode is Apple's development system, and can be downloaded for free.</li><li class="listitem">If you are using a version of Mac OS X less than 10.9 (Yosemite), you will need to separately install the command-line tools. To do this, start up XCode and choose the <span class="strong"><strong>Preferences…</strong></span> command from the <span class="strong"><strong>XCode</strong></span> menu. In the <span class="strong"><strong>Downloads</strong></span> tab, there will be an option <a id="id362" class="indexterm"/>to install the command-line tools; enable this option and wait for the required tools to be installed.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>If you are using Mac OS X 10.9 (Yosemite) or later, you can skip this step.</p></div></div></li><li class="listitem">Download the source code to PyProj<a id="id363" class="indexterm"/> from <a class="ulink" href="https://pypi.python.org">https://pypi.python.org</a>.</li><li class="listitem">Using the terminal, <code class="literal">cd</code> into the PyProj directory you downloaded and type the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python setup.py build</strong></span>
<span class="strong"><strong>sudo python.setup.py install</strong></span>
</pre></div></li><li class="listitem">Finally, start up Python and try typing the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import pyproj</strong></span>
</pre></div><p>The Python prompt should reappear without any error message.</p></li></ol></div></li><li class="listitem" style="list-style-type: disc">For Linux, you can either use your favorite package manager to install PROJ.4 and then PyProj, or else you can build them both from source by following the instructions available at <a class="ulink" href="http://trac.osgeo.org/proj">http://trac.osgeo.org/proj</a> and <a class="ulink" href="https://github.com/jswhit/pyproj">https://github.com/jswhit/pyproj</a>.</li></ul></div><p>Now that you have installed PyProj, let's see how the library can be used. There are two main classes provided by PyProj:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proj</strong></span>: This <a id="id364" class="indexterm"/>class represents a spatial projection, and allows you to convert coordinates, either singly or en masse, between projections</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Geod</strong></span>: This is <a id="id365" class="indexterm"/>a <span class="emphasis"><em>geodetic</em></span> <span class="emphasis"><em>computation</em></span> class that allows you to perform various calculations based on coordinates that use a given spatial reference system</li></ul></div><p>Let's see how PyProj can be used to calculate the distance between two points. Open up a terminal window, start up your Python interpreter, and enter the following code:</p><div class="informalexample"><pre class="programlisting">import pyproj
geod = pyproj.Geod(ellps="WGS84")
lat1 = -38.137
long1 = 176.349
lat2 = -41.286
long2 = 174.776
heading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)
print int(distance)</pre></div><p>The two coordinates represent<a id="id366" class="indexterm"/> the locations of the cities of Rotorua and Wellington, in New Zealand:</p><div class="mediaobject"><img src="images/4102_05_05.jpg" alt="PyProj"/></div><p>All going well, you should see the number 374,729 printed out, which is the as-the-crow-flies (great circle) distance between these two cities, measured in meters.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Notice that we use <code class="literal">ellps="WGS84"</code> to set the spatial reference system for our Geod object. This value sets the mathematical model for the shape of the Earth to be used by the geodetic calculator—WGS84 is the name for the ellipsoid used by the EPSG 4326 spatial reference system, so we are effectively telling PyProj that the coordinates are measured in latitude and longitude.</p></div></div><p>PyProj can also be used to convert between coordinate systems. We will look at this shortly, when we see how it can be combined with Shapely to perform accurate spatial calculations.</p></div><div class="section" title="NetworkX"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>NetworkX</h2></div></div></div><p>NetworkX<a id="id367" class="indexterm"/> is a Python library for defining and analyzing mathematical <span class="strong"><strong>graphs</strong></span>. In mathematical terms, a <a id="id368" class="indexterm"/>graph is a collection of <span class="strong"><strong>vertices</strong></span><a id="id369" class="indexterm"/> joined together by<a id="id370" class="indexterm"/> <span class="strong"><strong>edges</strong></span>:</p><div class="mediaobject"><img src="images/4102_05_06.jpg" alt="NetworkX"/></div><p>Each edge is typically assigned a value, called a <a id="id371" class="indexterm"/>
<span class="strong"><strong>weight</strong></span>, which can be used to perform queries against the graph. Each edge can be<a id="id372" class="indexterm"/> <span class="strong"><strong>directed</strong></span>—that is, you can only follow the edge in one direction—or it can be undirected, allowing you to follow the edge in either direction.</p><p>While these graphs are an interesting mathematical concept, they are also useful for geospatial analysis because you can use a graph to represent locations and the ways of moving between them. For example, the vertices may represent towns, while the edges may represent roads that connect these various towns together. When used in this way, the edges are usually weighted by how long the road is, so that longer roads have a greater weight, and the entire graph can be used to calculate the shortest path between two points.</p><p>NetworkX is a very powerful library for working with mathematical graphs. Even better, it includes the ability to read a shapefile and convert it into a graph. This allows you to very simply convert geospatial data into an abstract graph representation, which you can then use to analyze the relationship between locations in various useful ways.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>In NetworkX, the vertices in a graph are called<a id="id373" class="indexterm"/> <span class="strong"><strong>nodes</strong></span>.</p></div></div><p>Let's go ahead and install the NetworkX<a id="id374" class="indexterm"/> library now. The main website for NetworkX can be found at <a class="ulink" href="https://networkx.github.io">https://networkx.github.io</a>, and you can download the library<a id="id375" class="indexterm"/> directly from <a class="ulink" href="https://pypi.python.org/pypi/networkx">https://pypi.python.org/pypi/networkx</a>.</p><p>Since NetworkX is written in pure Python, you can simply download the source code and then type <code class="literal">python setup.py install</code> to install it into your <code class="literal">site-packages</code> directory, or if you prefer you can install it using pip by typing <code class="literal">pip install networkx</code>.</p><p>For more details, refer to the NetworkX <a id="id376" class="indexterm"/>installation instructions, which can be found at <a class="ulink" href="http://networkx.github.io/documentation/latest/install.html">http://networkx.github.io/documentation/latest/install.html</a>.</p><p>Once you have installed NetworkX, check that it works by typing the following into the Python command prompt:</p><div class="informalexample"><pre class="programlisting">import networkx

graph = networkx.Graph()
graph.add_edge("New York", "San Francisco", weight=2908)
graph.add_edge("San Francisco", "Los Angeles", weight=382)
graph.add_edge("Los Angeles", "New York", weight=2776)
graph.add_edge("San Francisco", "Portland", weight=635)

print networkx.shortest_path(graph, "New York", "Portland")</pre></div><p>This simple program builds a NetworkX graph where the nodes represent cities and the edges represent roads connecting those cities. For each edge, the weight represents the driving distance in miles between those two cities. Using this simple graph, we then ask NetworkX to show us the shortest path between New York and Portland in Oregon.</p><p>All going well, running the preceding code will tell you that the shortest path is to go from New York to San Francisco, and from there to Portland:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>['New York', 'San Francisco', 'Portland']</strong></span>
</pre></div><p>Obviously, there is a lot more you can do with NetworkX, and we will be using this library later in this chapter. For the moment, however, it's enough to know that you can use NetworkX to build an abstract graph out of your spatial data, and then use the NetworkX analysis functions to calculate useful information based on your graph.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Spatial analysis recipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Spatial analysis recipes</h1></div></div></div><p>Now that we have a full set of<a id="id377" class="indexterm"/> geospatial analysis libraries available to us, let's see how we can use them to solve some real-world problems. We will look at how we can calculate and work with locations, lengths, and areas, as well as how we can use NetworkX to calculate the shortest available path between two points.</p><div class="section" title="Calculating and comparing coordinates"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Calculating and comparing coordinates</h2></div></div></div><p>As we saw earlier, PyProj <a id="id378" class="indexterm"/>can be used to calculate the real-world <a id="id379" class="indexterm"/>distance between two locations. It <a id="id380" class="indexterm"/>can also be used to measure the angle of a line going <a id="id381" class="indexterm"/>between two points, and calculate new points based on a starting point, a distance, and a heading.</p><p>Let's use PyProj to calculate the distance between two points. We will then use it to calculate a location at a certain distance and heading from a given point.</p><p>Start by creating a new Python program named <code class="literal">coord_analysis.py</code>. Enter the following code into the start of this program:</p><div class="informalexample"><pre class="programlisting">import pyproj
geod = pyproj.Geod(ellps="WGS84")</pre></div><p>So far, this is identical to the code we saw earlier: we simply import the PyProj library and create a geodetic calculation object based on the WGS84 ellipsoid. If you remember, this is the mathematical model of the Earth's surface that is used by the standard EPSG 4326 spatial reference system.</p><p>We are now going to add some code to prompt the user to enter the desired coordinates. This is all standard Python code, and should not require any further explanation:</p><div class="informalexample"><pre class="programlisting">def get_coord(prompt):
    while True:	
        s = raw_input(prompt + " (lat,long): ")
        if "," not in s: continue
        s1,s2 = s.split(",", 1)
        try:	
            latitude = float(s1.strip())
        except ValueError:
            continue
        try:
            longitude = float(s2.strip())
        except ValueError:
            continue
        return latitude,longitude
lat1,long1 = get_coord("Starting coordinate")
lat2,long2 = get_coord("Ending coordinate")</pre></div><p>Now that we have the two sets of latitude and longitude values, we can use PyProj to calculate the actual distance between these two points:</p><div class="informalexample"><pre class="programlisting">heading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)</pre></div><p>This is exactly the <a id="id382" class="indexterm"/>same code that we saw earlier. The<a id="id383" class="indexterm"/> <code class="literal">geod.inv()</code> method takes the<a id="id384" class="indexterm"/> two coordinates and returns the <span class="emphasis"><em>heading</em></span> (the angle in <a id="id385" class="indexterm"/>degrees of a line from the first point to the second point, measured clockwise from due north), the <span class="emphasis"><em>inverse heading</em></span> (the angle of a line from the second point back to the first point, again measured clockwise from due north), and the <span class="emphasis"><em>distance</em></span> (measured in meters) between the two points.</p><p>Notice that the call to <code class="literal">geod.inv()</code> requires us to supply the longitude value before the latitude value. This is because PyProj works with any coordinate system, and the longitude represents the x (left-to-right) value, while the latitude represents the y (bottom-to-top) value. The x value is always listed first when dealing with generic coordinates that could be in any spatial reference system.</p><p>Now that we have calculated these three numbers, let's display them so that the user can see the results of our calculation:</p><div class="informalexample"><pre class="programlisting">print "Heading = %0.2f degrees" % heading1
print "Inverse heading = %0.2f degrees" % heading2
print "Distance = %0.2f kilometers" % (distance/1000)</pre></div><p>To check it out, save your program and run it in a terminal window. Then enter the following coordinates into your program:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Starting coordinate: 37.774929, -122.419416</strong></span>
<span class="strong"><strong>Ending coordinate: 34.052234, -118.243685</strong></span>
</pre></div><p>These two coordinates represent the locations of San Francisco and Los Angeles. Assuming that you have entered the program correctly, the following results should be displayed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Heading = 136.38 degrees</strong></span>
<span class="strong"><strong>Inverse heading = -41.17 degrees</strong></span>
<span class="strong"><strong>Distance = 559.04 kilometers</strong></span>
</pre></div><p>This tells us that if we were in a plane directly above downtown San Francisco and flew 559 kilometers at a heading of 136.38 degrees (measured clockwise from due north), you would end up in downtown Los Angeles. Similarly, if you were in Los Angeles and headed 559 kilometers at a heading of -41.17 degrees (again measured clockwise from due north), you would end up in San Francisco:</p><div class="mediaobject"><img src="images/4102_05_07.jpg" alt="Calculating and comparing coordinates"/></div><p>Now, let's add <a id="id386" class="indexterm"/>some code to calculate the<a id="id387" class="indexterm"/> coordinates for a point a certain distance and <a id="id388" class="indexterm"/>heading from an existing location. Comment out everything <a id="id389" class="indexterm"/>you wrote after the end of the <code class="literal">get_coord()</code> function, and then add the following to the end of your program:</p><div class="informalexample"><pre class="programlisting">def get_num(prompt):
    while True:
        s = raw_input(prompt + ": ")
        try:
            value = float(s)
        except ValueError:
            continue
        return value</pre></div><p>This is a simple utility function to prompt the user to enter a numeric value. We will use this (along with the <code class="literal">get_coord()</code> function we wrote earlier) to prompt the user for the information we will need. Now add the following to the end of your program:</p><div class="informalexample"><pre class="programlisting">sLat,sLong = get_coord("Starting coordinate")
distance = get_num("Distance in kilometers") * 1000
heading = get_num("Heading")</pre></div><p>Notice that we convert the distance measured in kilometers into the distance in meters—PyProj always works in meters, so we have to provide the distance in meters.</p><p>We are now ready to calculate the ending coordinate. Using PyProj, this is easy:</p><div class="informalexample"><pre class="programlisting">eLong,eLat,iHeading = geod.fwd(sLong, sLat, heading, distance)</pre></div><p>The <code class="literal">geod.fwd()</code> method <a id="id390" class="indexterm"/>returns the desired coordinate (with the X value listed first), as well as the inverse <a id="id391" class="indexterm"/>heading. Our last task is to display <a id="id392" class="indexterm"/>these results to the <a id="id393" class="indexterm"/>user:</p><div class="informalexample"><pre class="programlisting">print "End point = (%0.4f,%0.4f)" % (eLat, eLong)
print "Inverse heading = %0.2f degrees" % iHeading</pre></div><p>If you run this program, you can try entering a starting point, heading and distance, and the program will display the ending point. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Starting coordinate (lat,long): 37.774929, -122.419416</strong></span>
<span class="strong"><strong>Distance in kilometers: 559.04</strong></span>
<span class="strong"><strong>Heading: 136.38</strong></span>
<span class="strong"><strong>End point = (34.0521,-118.2440)</strong></span>
<span class="strong"><strong>Inverse heading = -41.17 degrees</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>The calculated end point is not quite the same as the value we saw earlier. This is because the distance and heading are only specified to two decimal degrees of accuracy.</p></div></div><p>Of course, for our program, we commented out the first calculation so we could concentrate on the second. An obvious improvement would be to add a simple text prompt asking the user which calculation to perform. But you can see how PyProj can be used to calculate and compare points on the Earth's surface—something that cannot be done easily when you use latitude and longitude values.</p></div><div class="section" title="Calculating lengths"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Calculating lengths</h2></div></div></div><p>Now that we know how to <a id="id394" class="indexterm"/>calculate the distance (in meters) between<a id="id395" class="indexterm"/> two points, let's apply this technique to calculate the true length of any LineString geometry.</p><p>To calculate the total length of a LineString geometry, we need to split the LineString up into individual line segments, calculate the length of each line segment, and sum the result to get the total length of the entire LineString:</p><div class="mediaobject"><img src="images/4102_05_08.jpg" alt="Calculating lengths"/></div><p>To see this in action, we <a id="id396" class="indexterm"/>need some LineString geometries to work <a id="id397" class="indexterm"/>with. For this example, we will use LineStrings representing the primary and secondary roads in California. This data can be downloaded from the US Census Bureau's website at <a class="ulink" href="https://www.census.gov/geo/maps-data/data/tiger-line.html">https://www.census.gov/geo/maps-data/data/tiger-line.html</a>. Scroll down to the section labeled <span class="strong"><strong>2014 TIGER/Line Shapefiles</strong></span>, and click on the <span class="strong"><strong>Download</strong></span> option, then click on <span class="strong"><strong>Web interface</strong></span>. From the download page, choose <span class="strong"><strong>Roads</strong></span> from the <span class="strong"><strong>Select a layer type</strong></span> drop-down menu, and then click on the <span class="strong"><strong>Submit</strong></span> button. Finally, choose <span class="strong"><strong>California</strong></span> from the <span class="strong"><strong>Primary and Secondary Roads</strong></span> drop-down menu, and click on the <span class="strong"><strong>Download</strong></span> button to download the required data.</p><p>The resulting shapefile will be in a compressed ZIP archive named <code class="literal">tl_2014_06_prisecroads.zip</code>. Decompress this archive, and place the resulting shapefile somewhere convenient. Create a new file in the same directory as the shapefile with the name <code class="literal">calc_lengths.py</code>, and then enter the following code into this file:</p><div class="informalexample"><pre class="programlisting">import osgeo.ogr
import shapely.wkt
import pyproj

geod = pyproj.Geod(ellps="WGS84")

shapefile = osgeo.ogr.Open("tl_2014_06_prisecroads.shp")
layer = shapefile.GetLayer(0)

for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    geometry = shapely.wkt.loads(
        feature.GetGeometryRef().ExportToWkt())</pre></div><p>This should all be quite familiar to you—we just import the various libraries we will use, create a new <code class="literal">pyproj.Geod</code> object to use for our length calculations, and then iterate over the contents of the shapefile one feature at a time. As you can see, we use the <code class="literal">shapely.wkt.loads()</code> function to convert the feature into a Shapely geometry object.</p><p>Now that we have a Shapely geometry, our next task is to split that geometry into individual line segments and calculate the length of each segment. Let's do that:</p><div class="informalexample"><pre class="programlisting">    tot_length = 0
    prev_long,prev_lat = geometry.coords[0]
    for cur_long,cur_lat in geometry.coords[1:]:
        heading1,heading2,distance = geod.inv(
            prev_long, prev_lat, cur_long, cur_lat)
        tot_length = tot_length + distance
        prev_long,prev_lat = cur_long,cur_lat</pre></div><p>Because the Shapely <a id="id398" class="indexterm"/>geometry is a LineString, we can access the<a id="id399" class="indexterm"/> individual coordinates that make up the LineString using <code class="literal">geometry.coords</code>. We then process each pair of coordinates in turn, using the technique we learned earlier to calculate the distance in meters between the two coordinates. We keep track of the total calculated length across all the coordinate pairs, giving us the total length of the LineString geometry.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>If our road data had been in a projected coordinate system that preserved distances, we could have simply asked Shapely to calculate the total length of each LineString by accessing the <code class="literal">geometry.length</code> attribute. This won't work for EPSG 4326 data, however, because once again the results would be a length in degrees.</p></div></div><p>Our last task is to do something with the calculated length. Let's simply print it out, along with the name of the road:</p><div class="informalexample"><pre class="programlisting">    print feature.GetField("FULLNAME"), int(tot_length)</pre></div><p>In theory, our program should now work, so let's try running it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python calc_lengths.py</strong></span>
<span class="strong"><strong>N Wheeler Ridge Rd 1616</strong></span>
<span class="strong"><strong>N Main St 1595</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>So far so good; as you can see, the total length of each road, in meters, is being calculated. Unfortunately, if we wait a few more seconds, our program will raise a Python exception and stop:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  File "calc_lengths.py", line 23, in &lt;module&gt;</strong></span>
<span class="strong"><strong>    prev_long,prev_lat = geometry.coords[0]</strong></span>
<span class="strong"><strong>  File "/Library/Frameworks/GEOS.framework/Versions/3/Python/2.7/shapely/geometry/base.py", line 634, in coords</strong></span>
<span class="strong"><strong>    "Multi-part geometries do not provide a coordinate sequence")</strong></span>
<span class="strong"><strong>NotImplementedError: Multi-part geometries do not provide a coordinate sequence</strong></span>
</pre></div><p>What's going on here? It<a id="id400" class="indexterm"/> seems that <code class="literal">geometry.coords</code> is not <a id="id401" class="indexterm"/>available because the geometry is not an ordinary LineString. Indeed, if you remember from <a class="link" href="ch02.html" title="Chapter 2. Geospatial Data">Chapter 2</a>, <span class="emphasis"><em>Geospatial Data</em></span>, shapefiles make no distinction between simple geometries and collections of those geometries, so a LineString in the shapefile might actually be a collection of LineStrings. This is exactly what is happening in this case—if you were to load the affected feature into memory using the interactive Python command prompt, you could print out the geometry type to see what is wrong:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; geometry = shapely.wkt.loads(feature.GetGeometryRef().ExportToWkt())</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print geometry.geom_type</strong></span>
<span class="strong"><strong>MultiLineString</strong></span>
</pre></div><p>So we have a road represented by a MultiLineString geometry rather than a LineString geometry. Fortunately, it's easy to split apart a MultiLineString and process the individual LineStrings one at a time. Here is what our entire program looks like once we add this feature:</p><div class="informalexample"><pre class="programlisting">import osgeo.ogr
import shapely.wkt
import pyproj

geod = pyproj.Geod(ellps="WGS84")

shapefile = osgeo.ogr.Open("tl_2014_06_prisecroads.shp")
layer = shapefile.GetLayer(0)

for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    geometry = shapely.wkt.loads(
        feature.GetGeometryRef().ExportToWkt())

    lineStrings = []
    if geometry.geom_type == "LineString":
        lineStrings.append(geometry)
    elif geometry.geom_type == "MultiLineString":
        for lineString in geometry:
            lineStrings.append(lineString)

    tot_length = 0

    for lineString in lineStrings:
        prev_long,prev_lat = lineString.coords[0]
        for cur_long,cur_lat in lineString.coords[1:]:
            heading1,heading2,distance = geod.inv(
                prev_long, prev_lat, cur_long, cur_lat)
            tot_length = tot_length + distance
            prev_long,prev_lat = cur_long,cur_lat

    print feature.GetField("FULLNAME"), int(tot_length)</pre></div><p>Using this technique, we<a id="id402" class="indexterm"/> can calculate the exact length, in <a id="id403" class="indexterm"/>meters, for any linear geometry such as a LineString or MultiLineString. Indeed, we could even use the same technique to calculate the perimeter of a polygon geometry, by accessing the polygon's exterior linear ring and then processing it as if it were a LineString:</p><div class="informalexample"><pre class="programlisting">lineString = polygon.exterior</pre></div></div><div class="section" title="Calculating areas"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Calculating areas</h2></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Geospatial Data">Chapter 2</a>, <span class="emphasis"><em>Geospatial Data</em></span>, we saw how we can calculate the area of a polygon using OGR and the World<a id="id404" class="indexterm"/> Mollweide projection (EPSG 54009). World <a id="id405" class="indexterm"/>Mollweide is an equal-area map projection that is reasonably accurate worldwide, and so is useful for calculating areas in square meters.</p><p>Instead of using OGR, let's apply the same technique using Shapely. The advantage of doing this is that we'll have access to all of Shapely's functionality, allowing us to manipulate and measure geometries in all sorts of useful ways. To do this, we will make use of a handy Shapely function called <code class="literal">shapely.ops.transform()</code>. This lets you apply a transformation function to every coordinate within a geometry. The transformation can be anything you want (you can write your own transformation function in Python if you want), but most importantly, you can use PyProj to implement a transformation function that converts from EPSG 4326 to ESPG 54009 so that you can accurately calculate the area for any geometry.</p><p>Let's see how this works. Place a copy of the <code class="literal">TM_WORLD_BORDERS-0.3</code> shapefile you downloaded earlier into a convenient directory, and create a new file named <code class="literal">calc_areas.py</code> in the same directory. Then enter the following code into this new file:</p><div class="informalexample"><pre class="programlisting">import osgeo.ogr
import shapely.wkt
import shapely.ops
import pyproj

shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)

src_proj = pyproj.Proj(proj="longlat", ellps="WGS84", datum="WGS84")
dst_proj = pyproj.Proj(proj="moll", lon_0=0, x_0=0, y_0=0, ellps="WGS84", datum="WGS84", units="m")

def latlong_to_mollweide(longitude, latitude):
    return pyproj.transform(src_proj, dst_proj,
                            longitude, latitude)

for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    wkt = feature.getGeometryRef().ExportToWkt()
    geometry = shapely.wkt.loads(wkt)

    transformed = shapely.ops.transform(latlong_to_mollweide,
                                        geometry)
    area = int(transformed.area/1000000)
    
    print feature.GetField("NAME"), area</pre></div><p>As you can see, we have <a id="id406" class="indexterm"/>defined a transformation function, <code class="literal">latlong_to_mollweide()</code>, that converts a given latitude and longitude value <a id="id407" class="indexterm"/>into an (x,y) coordinate in the Mollweide coordinate reference system. Mollweide is based on meters, so Shapely can then perform calculations against that geometry and return a result in meters.</p><p>When you run the <code class="literal">calc_areas.py</code> program, you should see a list of countries and the area of the associated polygons in the World Borders Dataset, measured in square kilometers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python calc_areas.py</strong></span>
<span class="strong"><strong>Antigua and Barbuda 546</strong></span>
<span class="strong"><strong>Algeria 2326137</strong></span>
<span class="strong"><strong>Azerbaijan 86014</strong></span>
<span class="strong"><strong>Albania 28702</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>The great thing about using <code class="literal">shapely.ops.transform()</code> is that you can use all of Shapely's calculative and geometry-manipulation features on the resulting geometries. For example, New Zealand has an exclusive economic zone that extends 200 miles out from the coastline. Using the <code class="literal">buffer()</code> method, you could calculate the shape of this exclusive economic zone by expanding the outline of New Zealand to include all points within 200 miles of the<a id="id408" class="indexterm"/> coastline:</p><div class="mediaobject"><img src="images/4102_05_09.jpg" alt="Calculating areas"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Buffering<a id="id409" class="indexterm"/> is<a id="id410" class="indexterm"/> an extremely powerful operation. For example, you can use <code class="literal">buffer()</code> along with the <code class="literal">intersects()</code> method to identify all countries within a given distance of a starting geometry. For example:</p><div class="informalexample"><pre class="programlisting">buffered_area = test_country['geom'].buffer(1000000)
for country in countries:
    if country['geom'].intersects(buffered_area):
        print "%s is within 1000 km of %s" % (country['name'], test_country['name'])</pre></div></div></div></div><div class="section" title="Calculating shortest paths"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Calculating shortest paths</h2></div></div></div><p>For our final example, we<a id="id411" class="indexterm"/> will take a shapefile containing<a id="id412" class="indexterm"/> road data and use it to calculate the shortest path between two points. This is a fairly complex example employing various techniques for analyzing and manipulating geometry data. It also uses the NetworkX library to perform the shortest path calculation on an abstract representation of the road network.</p><p>Let's start by looking at how NetworkX converts a shapefile containing LineString geometries into an abstract network. If you were to look at a small part of the <code class="literal">tl_2014_06_prisecroads</code> shapefile, you would see what appears to be a connected series of roads, for example:</p><div class="mediaobject"><img src="images/4102_05_10.jpg" alt="Calculating shortest paths"/></div><p>However, the roads don't<a id="id413" class="indexterm"/> actually stop where they <a id="id414" class="indexterm"/>intersect—the road features simply continue on, overlapping other roads as necessary. On the map, these may look like intersections, but there is no real intersection point where two roads meet or cross:</p><div class="mediaobject"><img src="images/4102_05_11.jpg" alt="Calculating shortest paths"/></div><p>This is important because of the way NetworkX converts LineString geometries into an abstract graph—NetworkX will think that two LineStrings intersect if and only if they have identical starting or ending points; simply crossing over does not mean that the two roads intersect. In the preceding example, <span class="strong"><strong>Road 2</strong></span> and <span class="strong"><strong>Road 4</strong></span> will be the only roads that are considered to be connected—even though <span class="strong"><strong>Road 2</strong></span> appears to intersect with <span class="strong"><strong>Road 1</strong></span> and <span class="strong"><strong>Road 3</strong></span>, the<a id="id415" class="indexterm"/> lack of matching endpoints<a id="id416" class="indexterm"/> means that these roads will be excluded from the graph.</p><p>To allow NetworkX to convert the road shapefile into a network, we need to split the roads at the points where they intersect:</p><div class="mediaobject"><img src="images/4102_05_12.jpg" alt="Calculating shortest paths"/></div><p>Mathematically speaking, this is known as generating a <span class="strong"><strong>planar graph</strong></span><a id="id417" class="indexterm"/> out of the network of overlapping roads. This process is not perfect—it ignores places where bridges and viaducts, not to mention <span class="emphasis"><em>Do Not Enter</em></span> signs, prevent a traveler from taking a particular turnoff. However, converting the road shapefile into a planar graph is a good starting point, and you can always exclude particular intersections from the calculation if you have a list of bridges and other no-entry points.</p><p>Let's go ahead and convert our road shapefile into a planar graph. To do this, create a new Python program called <code class="literal">split_roads.py</code>, and enter the following code into this file:</p><div class="informalexample"><pre class="programlisting">import os
import os.path
import shutil
import osgeo.ogr
import osgeo.osr
import shapely.wkt

SRC_SHAPEFILE = "tl_2014_06_prisecroads.shp"

all_roads = []
shapefile = osgeo.ogr.Open(SRC_SHAPEFILE)
layer = shapefile.GetLayer(0)
for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    wkt = feature.GetGeometryRef().ExportToWkt()
    geometry = shapely.wkt.loads(wkt)
    all_roads.append(geometry)</pre></div><p>Apart from the<a id="id418" class="indexterm"/> extra <code class="literal">import</code> statements (which we <a id="id419" class="indexterm"/>will need shortly), this code should be fairly clear: we're simply loading the LineString geometries from our <code class="literal">tl_2014_06_prisecroads.shp</code> shapefile into the <code class="literal">all_roads</code> list.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>If your shapefile is in a different directory, edit the <code class="literal">SRC_SHAPEFILE</code> constant so that the program can find the shapefile.</p></div></div><p>Our next task is to split the roads up at the intersection points. Fortunately, Shapely makes this quite easy. Add the following to the end of your program:</p><div class="informalexample"><pre class="programlisting">split_roads = []

for i in range(len(all_roads)):
    cur_road = all_roads[i]
    crossroads = []
    for j in range(len(all_roads)):
        if i == j: continue
        other_road = all_roads[j]
        if cur_road.crosses(other_road):
            crossroads.append(other_road)
    if len(crossroads) &gt; 0:
        for other_road in crossroads:
            cur_road = cur_road.difference(other_road)
        if cur_road.geom_type == "MultiLineString":
            for split_road in cur_road.geoms:
                split_roads.append(split_road)
        elif cur_road.geom_type == "LineString":
            split_roads.append(cur_road)
    else:
        split_roads.append(cur_road)</pre></div><p>As you can see, we identify any roads that cross the current road by calling Shapely's <code class="literal">crosses()</code> method. We then use the <code class="literal">difference()</code> method to remove each crossroad from the current road; this has the effect of splitting the road up at the point where the other road crosses it:</p><div class="mediaobject"><img src="images/4102_05_13.jpg" alt="Calculating shortest paths"/></div><p>Finally, we want to <a id="id420" class="indexterm"/>save the split roads back <a id="id421" class="indexterm"/>into a shapefile. To do this, add the following code to the end of your program:</p><div class="informalexample"><pre class="programlisting">driver = osgeo.ogr.GetDriverByName("ESRI Shapefile")
if os.path.exists("split_roads"):
    shutil.rmtree("split_roads")
os.mkdir("split_roads")
dstFile = driver.CreateDataSource("split_roads/split_roads.shp")

spatialReference = osgeo.osr.SpatialReference()
spatialReference.SetWellKnownGeogCS("WGS84")

layer = dstFile.CreateLayer("Layer", spatialReference)

for road in split_roads:
    wkt = shapely.wkt.dumps(road)
    linestring = osgeo.ogr.CreateGeometryFromWkt(wkt)

    feature = osgeo.ogr.Feature(layer.GetLayerDefn())
    feature.SetGeometry(linestring)
    
    layer.CreateFeature(feature)
    feature.Destroy()

dstFile.Destroy()</pre></div><p>This code should be familiar to you, as we used the same technique in <a class="link" href="ch02.html" title="Chapter 2. Geospatial Data">Chapter 2</a>, <span class="emphasis"><em>Geospatial Data</em></span>, when we looked at how to write vector data into a shapefile. The only new thing here is the fact that we're using <code class="literal">shutil.rmtree()</code> followed by <code class="literal">os.mkdir()</code> to delete and then re-create the directory in which we store the shapefile; this allows us to run the program again without having to remember to delete the shapefile each time.</p><p>This completes our <code class="literal">split_roads.py</code> program. It will take a few minutes to split all 8,000 roads in the <code class="literal">tl_2014_06_prisecroads</code> shapefile, so just leave it running as you start working on the next program.</p><p>Once we have the set of split roads, we'll want to have another program which uses them to calculate the shortest path between two points. Let's start writing that program now. We'll call this <a id="id422" class="indexterm"/>program <code class="literal">calc_shortest_path.py</code>. Create <a id="id423" class="indexterm"/>this file, and enter the following code into it:</p><div class="informalexample"><pre class="programlisting">import shapely.wkt
import pyproj
import networkx</pre></div><p>We are now going to write some utility functions which we'll need to do the shortest-path calculation. First off, we'll use the technique we saw earlier to calculate the distance in meters between two points:</p><div class="informalexample"><pre class="programlisting">def calc_distance(lat1, long1, lat2, long2):
    geod = pyproj.Geod(ellps="WGS84")
    heading1,heading2,distance = geod.inv(long1, lat1, long2, lat2)
    return distance</pre></div><p>We will use this function to write another function that calculates the total length of a LineString geometry:</p><div class="informalexample"><pre class="programlisting">def calc_length(linestring):
    tot_length = 0
    prev_long,prev_lat = linestring.coords[0]
    for cur_long,cur_lat in linestring.coords[1:]:
        distance = calc_distance(prev_lat, prev_long,
                                 cur_lat, cur_long)
        tot_length = tot_length + distance
        prev_long,prev_lat = cur_long,cur_lat
    return int(tot_length)</pre></div><p>Next, we will need a copy of the <code class="literal">get_coord()</code> function we wrote earlier:</p><div class="informalexample"><pre class="programlisting">def get_coord(prompt):
    while True:
        s = raw_input(prompt + " (lat,long): ")
        if "," not in s: continue
        s1,s2 = s.split(",", 1)
        try:
            latitude = float(s1.strip())
        except ValueError:
            continue
        try:
            longitude = float(s2.strip())
        except ValueError:
            continue
        return latitude,longitude</pre></div><p>There is one more function that we need to write: <code class="literal">find_closest_node</code>. This will find the node within a NetworkX graph that is closest to a given latitude and longitude value. We will need this <a id="id424" class="indexterm"/>to identify the starting and ending <a id="id425" class="indexterm"/>nodes for the shortest-path calculation.</p><p>Here is the code for the <code class="literal">find_closest_node</code> function, which you should add to the end of your program:</p><div class="informalexample"><pre class="programlisting">def find_closest_node(graph, latitude, longitude):
    closest_node = None
    min_distance = None
    for node in graph.nodes():
        distance = calc_distance(node[1], node[0],
                                 latitude, longitude)
        if closest_node == None:
            closest_node = node
            min_distance = distance
        elif distance &lt; min_distance:
            closest_node = node
            min_distance = distance
    return closest_node</pre></div><p>To find the closest node, we simply go through all the nodes (vertices) in the graph and calculate the distance in meters between the node and the desired coordinate. We then select and return the node with the smallest distance.</p><p>We are now ready to start writing the main part of our program. The first step is to ask NetworkX to read the <code class="literal">split_roads</code> shapefile and create a graph out of the road data:</p><div class="informalexample"><pre class="programlisting">graph = networkx.read_shp("split_roads/split_roads.shp")</pre></div><p>This reads through the shapefile and generates a NetworkX graph, where each edge represents a road and each node represents the endpoint of a road. Because NetworkX has no way of knowing how a road or endpoint should be identified, it uses the latitude and longitude to identify each endpoint (that is, each node), and the starting and ending latitude and longitude to identify each road (that is, each edge). Thus, the resulting graph will consist of nodes and edges that look something like the following diagram:</p><div class="mediaobject"><img src="images/4102_05_14.jpg" alt="Calculating shortest paths"/></div><p>The resulting graph will be quite large, as there are almost 10,000 roads to be imported from our shapefile.</p><p>Our next task might <a id="id426" class="indexterm"/>seem a bit odd: because there is no<a id="id427" class="indexterm"/> guarantee that every road can be reached from every other road, we need to reduce the graph down to just the reachable set of roads. If we don't do this, our shortest-path calculation is likely to fail. To remove the unreachable roads, we use the <code class="literal">connected_component_subgraphs()</code> function to identify the portion of the graph which contains the largest number of connected roads, and use this subgraph for the shortest-path calculation. Here is the necessary code:</p><div class="informalexample"><pre class="programlisting">graph = networkx.connected_component_subgraphs(graph.to_undirected()).next()</pre></div><p>Note that, because the <code class="literal">connected_component_subgraphs()</code> function requires an undirected graph, while the <code class="literal">read_shp()</code> function returns a directed graph, we have to use the <code class="literal">to_undirected()</code> method to make the graph undirected.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>If you get a <code class="literal">'list' object has no attribute 'next'</code> error, you may be using a different version of NetworkX. In this case, replace this line with <code class="literal">graph = networkx.connected_component_subgraphs(graph.to_undirected())[0]</code>.</p></div></div><p>Now that we have the useable set of roads, our next task is to calculate the length of each of these roads. This length value will be used as the basis for the shortest-path calculation. Fortunately, the length calculation is quite straightforward:</p><div class="informalexample"><pre class="programlisting">for node1,node2 in graph.edges():
    wkt = graph[node1][node2]['Wkt']
    linestring = shapely.wkt.loads(wkt)
    length = calc_length(linestring)
    graph.edge[node1][node2]['length'] = length</pre></div><p>As you can see, we extract the original LineString geometry for each edge, in WKT format, and then use that to create a Shapely geometry object. We then use our <code class="literal">calc_length()</code> function to calculate the total length of the road and store the resulting value as a <code class="literal">length</code> attribute into the edge. Running this code will calculate and store the length for every road in the graph.</p><p>With this done, we are finally ready to calculate the shortest path. We start by asking the user to enter the latitude and longitude values for the desired start and end points:</p><div class="informalexample"><pre class="programlisting">start_lat, start_long = get_coord("Starting Coordinate")
end_lat, end_long = get_coord("Ending Coordinate")</pre></div><p>The values entered by the user define two coordinates; we need to use these to identify the starting and ending nodes. We can do this using the <code class="literal">find_closest_node()</code> function we wrote earlier:</p><div class="informalexample"><pre class="programlisting">start_node = find_closest_node(graph, start_lat, start_long)
end_node   = find_closest_node(graph, end_lat, end_long)</pre></div><p>Now we can get the shortest path between the two nodes, based on the length values we calculated earlier:</p><div class="informalexample"><pre class="programlisting">path = networkx.shortest_path(graph, start_node, end_node, "length")</pre></div><p>The returned <code class="literal">path</code> <a id="id428" class="indexterm"/>value is a list of the nodes that make up <a id="id429" class="indexterm"/>the shortest path. Let's finish our program by printing out the details of this path:</p><div class="informalexample"><pre class="programlisting">tot_length = 0
prev_node = path[0]
for cur_node in path[1:]:
    edge = graph.edge[prev_node][cur_node]
    print (str(prev_node) + " -&gt; " + str(cur_node) +
           ", length = " + str(edge['length']))
    tot_length = tot_length + edge['length']
    prev_node = cur_node
print "Total length = " + str(tot_length)</pre></div><p>Now that we've completed the program, let's test it out. Run the <code class="literal">calc_shortest_path.py</code> script. The program will start by loading the road network into memory and calculating the length for each road:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python calc_shortest_path.py </strong></span>
<span class="strong"><strong>Loading road network into memory...</strong></span>
<span class="strong"><strong>graph has 7976 nodes and 9709 edges</strong></span>
<span class="strong"><strong>Calculating road lengths...</strong></span>
</pre></div><p>After the lengths are calculated, the program will then prompt you for the desired starting and ending coordinates. Let's enter the coordinates for Oakland and San Louis Obespo, which are both cities within California:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Starting Coordinate (lat,long): 37.794189, -122.276469</strong></span>
<span class="strong"><strong>Ending Coordinate (lat,long): 35.281107, -120.661211</strong></span>
</pre></div><p>The program will then calculate the nearest matching nodes, and the shortest path between these two points:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>start node = (-122.272515, 37.797457)</strong></span>
<span class="strong"><strong>end node = (-120.66285, 35.285892)</strong></span>
<span class="strong"><strong>(-122.272515, 37.797457) -&gt; (-122.176834, 37.719054), length = 12528</strong></span>
<span class="strong"><strong>(-122.176834, 37.719054) -&gt; (-122.176734, 37.718964), length = 13</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>(-120.663604, 35.286751) -&gt; (-120.663466, 35.286594), length = 21</strong></span>
<span class="strong"><strong>(-120.663466, 35.286594) -&gt; (-120.66285, 35.285892), length = 95</strong></span>
<span class="strong"><strong>Total length = 358838</strong></span>
</pre></div><p>Of course, printing<a id="id430" class="indexterm"/> out the latitude and longitude of each<a id="id431" class="indexterm"/> endpoint like this isn't particularly useful—it would be much nicer for the user if we displayed the shortest path on a map. If you wanted to, you could save the calculated path into a shapefile and then use Mapnik to display the contents of that shapefile as part of a map. But you can see how the shortest path calculation works, and what's required to get road data into a format that NetworkX can work with.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you learned about two new useful libraries for analyzing geospatial data. We then looked at various techniques for manipulating and analyzing spatial data, including ways of accurately calculating distances, lengths, locations, and areas.</p><p>Next, we looked at how to convert intersecting roads into a planar graph, which we stored in a shapefile so that we could perform a shortest-path calculation based on the road data. Finally, we wrote a program to calculate the shortest path between any two points. As we worked through these various problems, we learned a number of techniques for manipulating and analyzing geospatial data—techniques which you will use regularly when you write your own programs for geospatial analysis.</p><p>In the next chapter, we will bring together everything you have learned to implement a complete geospatial analysis system using Python.</p></div></div>
</body></html>