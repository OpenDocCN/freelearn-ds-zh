- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Visualizing iSAX Indexes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化iSAX索引
- en: In the previous chapter, we learned about comparing and joining iSAX indexes.
    However, it is still difficult to imagine the structure and the height of an iSAX
    index without seeing it as an image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了比较和合并iSAX索引。然而，如果没有将其作为图像来查看，仍然很难想象iSAX索引的结构和高度。
- en: And although some people prefer text, some other people prefer log files, and
    some others prefer numbers, almost all people like good-looking and informative
    visualizations. Additionally, all people understand the importance of having a
    high-level view of their data. This includes iSAX indexes and tree structures
    in general, mainly because there is no other practical way to perform the same
    task, especially when working with big time series.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些人喜欢文本，有些人喜欢日志文件，还有些人喜欢数字，但几乎所有人都喜欢美观且信息丰富的可视化。此外，所有人都理解拥有数据的高级视图的重要性。这包括iSAX索引和树结构，主要是因为没有其他实际的方法来完成同样的任务，尤其是在处理大型时间序列时。
- en: In [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015), we saw how to visualize
    a time series. This chapter is all about visualizing iSAX indexes in order to
    get a better understanding of their size, shape, and structure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B14769_01.xhtml#_idTextAnchor015)中，我们学习了如何可视化时间序列。本章全部内容都是关于如何可视化iSAX索引，以便更好地理解它们的大小、形状和结构。
- en: Visualizing large structures and trees such as iSAX indexes is not a trivial
    process but of a trial-and-error one. As no single visualization can do the job,
    we are going to try different kinds of plots and see what they tell us about the
    iSAX index. Therefore, you should expect to see lots of visualizations in this
    chapter, and I expect that you are going to create many more visualizations on
    your own while reading this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化大型结构如iSAX索引并不是一个简单的过程，而是一个试错的过程。由于没有单一的视觉方式可以完成这项工作，我们将尝试不同的图表类型，看看它们能告诉我们关于iSAX索引的什么信息。因此，你可以在本章中看到很多可视化，我期望你在阅读本书的过程中将创建更多的可视化。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Storing an iSAX index in JSON format
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将iSAX索引以JSON格式存储
- en: Visualizing an iSAX index
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化iSAX索引
- en: Trying something radical
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一些激进的方法
- en: More iSAX index visualizations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多iSAX索引可视化
- en: Using icicle plots
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用瀑布图
- en: Visualizing iSAX as a Collapsible Tree
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将iSAX索引可视化为可折叠树
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The GitHub repository for the book is at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    6*](B14769_06.xhtml#_idTextAnchor145) can be found in the `ch06` folder. However,
    in this chapter, there exist many directories under the `ch06` folder that contain
    the code for the different visualizations that we are going to create – this is
    a good way to organize code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库位于[https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing)。每章的代码都存放在各自的目录中。因此，[*第六章*](B14769_06.xhtml#_idTextAnchor145)的代码可以在`ch06`文件夹中找到。然而，在本章中，`ch06`文件夹下存在许多包含我们将要创建的不同可视化的代码的目录——这是一种很好的代码组织方式。
- en: Storing an iSAX index in JSON format
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将iSAX索引以JSON格式存储
- en: For the visualizations of this chapter, we are going to use the low-level `D3.js`
    JavaScript library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的可视化，我们将使用低级的`D3.js` JavaScript库。
- en: Is D3.js the only way to create visualizations?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js是创建可视化的唯一方式吗？
- en: The powerful `D3.js` JavaScript library is not a panacea and therefore, it is
    not the only way to create visualizations. There exist many Python packages that
    are good at plotting data, as well as programming languages such as R or Julia.
    However, JavaScript can be used for presenting your plots in a web page environment,
    which is not usually the case with the other options.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的`D3.js` JavaScript库并非万能，因此，它不是创建可视化的唯一方式。存在许多擅长绘图的数据包，如Python包，以及编程语言如R或Julia。然而，JavaScript可以用于在网页环境中展示你的图表，而其他选项通常不是这种情况。
- en: For the JavaScript `D3.js` code to work, we need to represent an iSAX index
    in **JSON** format so that it can be understood by the JavaScript code – we mainly
    need to represent **the structure and the connections** between iSAX nodes in
    a way that can be understood by a computer and a programming language. Therefore,
    the first step we should take is to convert an iSAX index representation with
    its structures from Python code into a different structure made by JSON records.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 JavaScript `D3.js` 代码工作，我们需要以 **JSON** 格式表示一个 iSAX 索引，以便它能够被 JavaScript
    代码理解——我们主要需要以计算机和编程语言能够理解的方式表示 **iSAX 节点之间的结构和连接**。因此，我们应该采取的第一步是将 Python 代码中的
    iSAX 索引表示及其结构转换为由 JSON 记录构成的不同结构。
- en: Although this JSON format is not universal and might fail in some cases, it
    is going to be used throughout this chapter as all presented `D3.js` code works
    fine with it – all presented examples are tested and fully working.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种 JSON 格式并非通用，可能在某些情况下会失败，但在这个章节中我们将使用它，因为所有展示的 `D3.js` 代码都能很好地与它兼容——所有展示的例子都经过测试并且完全可用。
- en: First, we need to visit [https://d3js.org/](https://d3js.org/) and click on
    **Examples** at the top of the page, which is going to take us to [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery).
    The latter page is going to bring us to a page with professional, functional,
    and beautiful plots that look appropriate for the kind and amount of data that
    we want to plot in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要访问 [https://d3js.org/](https://d3js.org/) 并点击页面顶部的 **Examples**，这将带我们到
    [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery)。后者页面将带我们到一个页面，上面有专业、功能性强且美观的图表，看起来适合我们在本章中想要绘制的类型和数量的数据。
- en: From the long list of available visualizations, we need to pick the ones that
    we prefer and are a good match for our data and its structure – our first attempt
    might not be perfect. Do not forget that iSAX indexes can have a large number
    of nodes. Therefore, we should think rationally and pick something that is going
    to look good with lots of data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用的可视化长列表中，我们需要选择那些我们喜欢并且与我们的数据和其结构相匹配的——我们的第一次尝试可能并不完美。不要忘记 iSAX 索引可以有大量的节点。因此，我们应该理性思考，选择那些与大量数据看起来很好的东西。
- en: From that list, we pick `Tree, Tidy`. Behind the visualization, there is JavaScript
    code embedded into HTML that reads the JSON data, parses it, and creates the visualization.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个列表中，我们选择 `Tree, Tidy`。在可视化背后，有嵌入到 HTML 中的 JavaScript 代码，它读取 JSON 数据，解析它，并创建可视化。
- en: Now that we have found our visualization of preference ([https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)),
    we might begin looking at the JavaScript code to get a better idea of the data
    format that is expected from the JavaScript code. However, what is more important
    is the JSON record format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了我们偏好的可视化（[https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)），我们可以开始查看
    JavaScript 代码，以更好地了解从 JavaScript 代码期望的数据格式。然而，更重要的是 JSON 记录的格式。
- en: Where is the JavaScript code?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码在哪里？
- en: JavaScript is a powerful but low-level programming language. The good thing
    is that the presented visualizations do not need any JavaScript knowledge to work.
    You just need to put your own data in the right format, at the right place, and
    that is all!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种功能强大但低级的编程语言。好事是展示的视觉化不需要任何 JavaScript 知识就能工作。你只需要将你的数据放在正确的格式和位置，这就足够了！
- en: 'The JSON records that we are going to support should have the following format
    – this format was found by looking into the JSON file that the JavaScript code
    uses to get its data:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要支持的 JSON 记录应该具有以下格式——这个格式是通过查看 JavaScript 代码使用的 JSON 文件找到的：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The common idea behind the structure that we want to support is that we have
    a root node – the root of the tree – that has multiple children, those children
    have children of their own, and so on. The name of each node is a `name` field
    is given to the root node of the tree – in this case, that name will be `flare`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要支持的结构的常见想法是，我们有一个根节点——树的根节点——它有多个子节点，这些子节点有自己的子节点，以此类推。每个节点的名称由一个 `name`
    字段指定给树的根节点——在这种情况下，该名称将是 `flare`。
- en: There is an additional field that is going to be needed in some of the presented
    visualizations. Later on in this chapter, we are going to learn that terminal
    nodes have an additional field for storing the number of the subsequences that
    they hold – this is not used by every visualization. However, the thought remains
    the same.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些展示的可视化中需要额外的字段。在本章的后面部分，我们将了解到终端节点有一个额外的字段用于存储它们所包含的子序列的数量 – 这不是每个可视化都需要使用的。然而，思想是相同的。
- en: 'A sample tidy tree visualization with custom data can be seen in the following
    figure. We are going to present more complex visualizations in the sections that
    follow. This is a simple tree structure with a root node and 13 nodes as its children:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图将展示一个带有自定义数据的整洁树可视化示例。在接下来的章节中，我们将展示更复杂的可视化。这是一个简单的树结构，有一个根节点和13个子节点：
- en: '![Figure 6.1 – A tree visualization](img/Figure_6.1_B14769.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 一棵树的可视化](img/Figure_6.1_B14769.jpg)'
- en: Figure 6.1 – A tree visualization
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 一棵树的可视化
- en: With all that in mind, we can now begin working on our Python code. The Python
    script for representing an iSAX index as a JSON file is called `exportJSON.py`.
    The logic behind `exportJSON.py` is that after creating the iSAX index, we traverse
    it in order to generate the JSON output in the desired format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我们现在可以开始编写我们的Python代码。将iSAX索引表示为JSON文件的Python脚本名为`exportJSON.py`。`exportJSON.py`背后的逻辑是，在创建iSAX索引后，我们遍历它以生成所需格式的JSON输出。
- en: 'But first, here is the definition of the JSON record that is going to be used
    in the Python script:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，这是Python脚本中将要使用的JSON记录的定义：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the basic JSON record format – we can add more fields to this record
    depending on our needs for any customization requirements without breaking any
    JavaScript code, as JavaScript is going to read only the fields that it needs.
    Although the format is defined in the code, it is not used by the Python code,
    mainly because Python does not need a predefined structure for JSON data that
    is stored in dictionaries. However, it is good to have it defined as a point of
    reference. The `size` field stores the total number of subsequences stored under
    each terminal node. Inner nodes do not need such a field.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本的JSON记录格式 – 根据我们的定制需求，我们可以根据需要向此记录添加更多字段，而不会破坏任何JavaScript代码，因为JavaScript只会读取它需要的字段。尽管格式在代码中定义，但Python代码并不使用它，主要是因为Python不需要为存储在字典中的JSON数据预定义结构。然而，将其定义为参考点是很好的。
- en: 'The Python code within `exportJSON.py` that reads the existing iSAX index and
    prints the JSON output can be found at the end of the `main()` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`exportJSON.py`中读取现有iSAX索引并打印JSON输出的Python代码可以在`main()`函数的末尾找到：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name of the Python dictionary that holds the JSON records is `data`. By
    default, the root node has the name `0`, which is a string – this is analogous
    to `flare`. You can change that to anything you like.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 存储JSON记录的Python字典名为`data`。默认情况下，根节点的名称为`0`，这是一个字符串 – 这与`flare`类似。你可以将其更改为任何你喜欢的名称。
- en: The previous code visits and processes the children of the root node of the
    iSAX index only. The rest is handled by the `createJSON()` function. `createJSON()`
    is the function that actually generates the JSON output by adding data for the
    current subtree that is being examined. The `data` variable holds all JSON data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码仅访问和处理iSAX索引根节点的子节点。其余部分由`createJSON()`函数处理。`createJSON()`函数是实际通过为正在检查的当前子树添加数据来生成JSON输出的函数。`data`变量包含所有JSON数据。
- en: The last statement prints all JSON records on the screen using `json.dumps()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条语句使用`json.dumps()`在屏幕上打印所有JSON记录。
- en: 'The `createJSON()` function is implemented as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`createJSON()`函数的实现如下：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `createJSON()` function is called recursively in order to visit all the
    nodes of each subtree. This mainly happens because we need to process all inner
    nodes and all terminal nodes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`createJSON()`函数通过递归调用以访问每个子树的每个节点。这主要是因为我们需要处理所有内部节点和所有终端节点。'
- en: About the JSON output
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JSON输出
- en: This particular Python script generates JSON output based on a particular JSON
    record format. Once you get the idea right, it is going to be easy to make small
    changes to the script, add more fields to the JSON records, or create something
    totally different. All these depend on the format that the visualization script
    expects to work with.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 Python 脚本基于特定的 JSON 记录格式生成 JSON 输出。一旦你理解了这个概念，修改脚本、添加更多字段到 JSON 记录中，或者创建完全不同的东西都会变得容易。所有这些都取决于可视化脚本期望与之一起工作的格式。
- en: For terminal nodes, we keep the number of the subsequences they hold – this
    takes place in the `size` field, and the processing of each terminal node ends
    here. However, for inner nodes, we recursively call `createJSON()` in order to
    process the left and the right children or subtrees of each inner node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于终端节点，我们保留它们所包含的子序列数量——这发生在 `size` 字段中，每个终端节点的处理就到这里结束。然而，对于内部节点，我们递归调用 `createJSON()`
    来处理每个内部节点的左右子节点或子树。
- en: With all that in mind, let us see `exportJSON.py` in action. First, we are going
    to use it with a small iSAX index, using a time series named `ts.gz` that contains
    100 elements – due to its small size, `ts.gz` is going to be used for experimentation
    purposes. `ts.gz` was created by running `../ch01/synthetic_data.py 100 -10 10`,
    saving the output in a file named `ts` and compressing `ts` with `gzip(1)`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们看看 `exportJSON.py` 的实际应用。首先，我们将使用一个小 iSAX 索引，使用包含 100 个元素的时间序列 `ts.gz`——由于其体积小，`ts.gz`
    将用于实验目的。`ts.gz` 是通过运行 `../ch01/synthetic_data.py 100 -10 10` 创建的，输出保存到名为 `ts`
    的文件中，然后使用 `gzip(1)` 压缩 `ts`。
- en: 'Running `exportJSON.py` with `ts.gz` produces the following kind of output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `exportJSON.py` 并使用 `ts.gz` 会产生以下类型的输出：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Processing that data with the `jq(1)` utility, which beautifies JSON records,
    generates the next better-looking output – in this case, all the children of the
    root are terminal nodes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jq(1)` 工具处理这些数据，该工具会美化 JSON 记录，生成下一个更好的输出——在这种情况下，根的所有子节点都是终端节点：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Bear in mind that the output depends on the parameters of the iSAX index**.
    Different iSAX parameters generate different outputs and different tree structures.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，输出取决于 iSAX 索引的参数**。不同的 iSAX 参数会产生不同的输出和不同的树结构。'
- en: 'Now, let us try `exportJSON.py` with a bigger time series that is named `100k.gz`,
    which contains 100,000 elements and was created as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用名为 `100k.gz` 的更大时间序列来运行 `exportJSON.py`，它包含 100,000 个元素，创建方式如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We ran `exportJSON.py` with `100k.gz` as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `100k.gz` 运行了 `exportJSON.py`。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output file was saved as `100k.json`. The reason for using a threshold value
    of `2500` is to have a more compact tree. However, at the end of the day, what
    matters is your needs and the actual parameters of your iSAX indexes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件被保存为 `100k.json`。使用 `2500` 的阈值是为了得到一个更紧凑的树。然而，最终，重要的是你的需求和实际的 iSAX 索引参数。
- en: At this point, we processed `ts.gz` and `100k.gz` with `exportJSON.py`, and
    we end up having two JSON files named `ts.json` and `100k.json`, respectively.
    Although we might need `ts.json` for testing, all coming visualizations are going
    to use `100k.json`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 `exportJSON.py` 处理了 `ts.gz` 和 `100k.gz`，最终我们得到了两个名为 `ts.json` 和
    `100k.json` 的 JSON 文件。尽管我们可能需要 `ts.json` 进行测试，但所有即将到来的可视化都将使用 `100k.json`。
- en: The next subsection is about downloading the JavaScript project on our local
    machine and executing it from there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将介绍如何在本地机器上下载 JavaScript 项目并从那里执行它。
- en: Downloading the JavaScript code locally
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地下载 JavaScript 代码
- en: '`D3.js` and its powerful capabilities. Therefore, in this subsection, we are
    going to learn how to do so.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`D3.js` 及其强大的功能。因此，在本小节中，我们将学习如何做到这一点。'
- en: In every visualization from [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery),
    there is a menu that appears when we click on the three dots that appear near
    the upper-right corner of the web page. From that menu, click on the **Export**
    link, which displays a submenu. From that submenu, we should click on the **Download
    code** option. This is going to download the contents of the current project on
    our local machine as a compressed file that we should extract and use.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个来自 [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery)
    的可视化中，当我们点击网页右上角出现的三个点时，会出现一个菜单。从该菜单中，点击 **导出** 链接，它将显示一个子菜单。从该子菜单中，我们应该点击 **下载代码**
    选项。这将下载当前项目的内容到我们的本地机器上，作为一个压缩文件，我们应该解压缩并使用它。
- en: For the purpose of this section, we are going to download the JavaScript project
    found at [https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree),
    which is going to download a file named `tree.tgz`. After we have uncompressed
    that file, we are going to get a directory called `tree`. It is not necessary
    to fully understand the contents of the directory, but it helps. However, you
    need to know the path to the JSON file with the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本节的目的，我们将下载位于[https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)的
    JavaScript 项目，这将下载一个名为`tree.tgz`的文件。在我们解压该文件后，我们将得到一个名为`tree`的目录。虽然不需要完全理解目录的内容，但这会有所帮助。然而，你需要知道包含数据的
    JSON 文件的路径。
- en: 'The output of the `tree(1)` utility, which lists the contents of directories
    in a tree-like format, when examining the contents of the `tree` directory, is
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查`tree`目录的内容时，`tree(1)`实用程序的输出，以树形格式列出目录内容，如下所示：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The JSON file with the records is located in the `files` directory – this is
    the file that we need to overwrite with our own data file. In order to load the
    project, we need to access the `index.xhtml` file, which is going to load all
    the necessary dependencies.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 包含记录的 JSON 文件位于`files`目录中——这是我们需要用我们自己的数据文件覆盖的文件。为了加载项目，我们需要访问`index.xhtml`文件，该文件将加载所有必要的依赖项。
- en: We only need to put our own JSON data into the `files` folder – this is the
    only required change to be done.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将我们自己的 JSON 数据放入`files`文件夹中——这是需要进行的唯一更改。
- en: The next subsection is about running the downloaded JavaScript project on your
    own machine, which requires running your own local HTTP server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节是关于在你的机器上运行下载的 JavaScript 项目，这需要运行你自己的本地 HTTP 服务器。
- en: Running the code locally
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地运行代码
- en: 'The process of running the code locally includes the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行代码的过程包括以下步骤：
- en: Go into the directory with the code.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入包含代码的目录。
- en: Make changes to the JSON file with the data – each example has its own JSON
    data file in a directory named `files`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改包含数据的 JSON 文件——每个示例都有一个名为`files`的目录中的 JSON 数据文件。
- en: Run a local HTTP server.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个本地 HTTP 服务器。
- en: The JSON file with the data has a long and strange filename that is embedded
    into the JavaScript code. I am not so proficient with JavaScript, so I am going
    to use the default filename, which is located in the `files` directory. For security
    reasons, it is not allowed for the web server to access files outside of its root
    directory. Therefore, we need to *copy the JSON file* we have created with `exportJSON.py`
    in the `files` directory of each individual project and *overwrite the existing
    JSON file*, even if we are using the same one in all our examples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 包含数据的 JSON 文件有一个长而奇怪的文件名，它嵌入到 JavaScript 代码中。我对 JavaScript 并不十分精通，所以我将使用默认的文件名，它位于`files`目录中。出于安全原因，不允许网络服务器访问其根目录之外的文件。因此，我们需要将我们在每个项目的`files`目录中用`exportJSON.py`创建的
    JSON 文件*复制到*，并*覆盖现有的 JSON 文件*，即使我们在所有示例中都使用相同的文件。
- en: The next subsection shows how to run your own local HTTP server and view the
    JavaScript code in action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何运行你自己的本地 HTTP 服务器并查看 JavaScript 代码的实际运行情况。
- en: Running a local HTTP server
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行本地 HTTP 服务器
- en: The easiest way to run a local HTTP server is by executing `python3 -m http.server`
    in the directory that interests you. If everything goes fine, the HTTP server
    is going to listen to port number `8000` and it is going to be accessed as http://localhost:8000/.
    This is much easier than it looks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本地 HTTP 服务器最简单的方法是在感兴趣的目录中执行`python3 -m http.server`。如果一切顺利，HTTP 服务器将监听端口号`8000`，并且可以通过http://localhost:8000/访问。这比看起来要简单得多。
- en: This process is going to be used throughout this chapter. All the required documents
    and files are in the GitHub repository of the book, so you have nothing more to
    download. If you want to experiment, just change the contents of the JSON file
    with the data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将在本章中一直使用。所有必需的文档和文件都在本书的 GitHub 仓库中，所以你不需要下载更多。如果你想进行实验，只需更改 JSON 数据文件的內容即可。
- en: The next subsection shows how to test the process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何测试这个过程。
- en: Testing the process
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试过程
- en: I have renamed the directory of the previous project from `tree` to `TreeTidy`
    – it is a good practice to use descriptive directory names.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将上一个项目的目录从`tree`重命名为`TreeTidy`——使用描述性的目录名称是一种良好的实践。
- en: So, first, we need to go to the `ch06` directory of the GitHub repository for
    this book and then go to the `TreeTidy` directory. After that, we need to run
    `python3 -m http.server`. Now, we have an HTTP server running on our local machine
    that listens to the `8000` TCP port. Therefore, we need to point our web browser
    to `http://localhost:8000/` and see the generated visualization.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要进入本书 GitHub 仓库中的 `ch06` 目录，然后进入 `TreeTidy` 目录。之后，我们需要运行 `python3 -m
    http.server`。现在，我们已经在本地机器上运行了一个监听 `8000` TCP 端口的 HTTP 服务器。因此，我们需要将我们的网络浏览器指向 `http://localhost:8000/`
    并查看生成的可视化。
- en: 'The generated output from the Python web server is going to look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 网络服务器生成的输出将如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you see any error messages in the generated output, you should try to resolve
    them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在生成的输出中看到任何错误信息，你应该尝试解决它们。
- en: However, unless you are in the wrong directory or there is another TCP service
    running on TCP port `8000`, there should be no issues.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除非你处于错误的目录或 TCP 端口 `8000` 上运行了另一个 TCP 服务，否则应该没有问题。
- en: So far, we have learned how to represent an iSAX index in JSON format and how
    to download the JavaScript projects from [https://observablehq.com/](https://observablehq.com/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何以 JSON 格式表示 iSAX 索引以及如何从 [https://observablehq.com/](https://observablehq.com/)
    下载 JavaScript 项目。
- en: In the section that follows, we will begin our iSAX visualization journey.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开始我们的 iSAX 可视化之旅。
- en: Visualizing an iSAX index
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化 iSAX 索引
- en: In this section, we are going to begin visualizing iSAX indexes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始可视化 iSAX 索引。
- en: As in most areas of computing, your visualizations are going to improve over
    time. The first visualizations are usually less beautiful and/or informative than
    later ones. So, we are going to experiment and try things before we end up with
    a good-looking iSAX visualization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在计算的大部分领域一样，你的可视化会随着时间的推移而改进。最初的视觉通常不如后来的美观和/或信息丰富。因此，在我们最终得到一个漂亮的 iSAX 可视化之前，我们将进行实验并尝试各种方法。
- en: As visualizations include personal taste, your visualization of choice might
    differ from the ones used in this chapter. However, we need to start doing and
    improve in the process!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可视化包括个人品味，你选择的可视化可能与本章中使用的不同。然而，我们需要开始行动并在过程中不断改进！
- en: Let us begin with the visualization of the next subsection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一小节的可视化开始。
- en: A personal story
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个个人故事
- en: At the time of writing this book, I am doing research related to iSAX. In one
    of my experiments, I ran a utility that creates two iSAX indexes and joins them
    in a more sophisticated way than the one presented in [*Chapter 5*](B14769_05.xhtml#_idTextAnchor124).
    The utility processed 2 time series with 500,000 elements each and ran for more
    than 18 days! Additionally, it took the same utility about 2 hours to process
    2 time series with 1,500,000 elements each, which means that the utility works
    well. I decided to visualize each iSAX index using a separate Python utility.
    Long story short, in the case of the time series with 500,000 elements, I mistakenly
    used 32 segments and a cardinality value of 4, instead of 4 segments and a cardinality
    value of 32! This means that the root of each iSAX index had 2 32 children! Therefore,
    joining them included so many calculations, which explained the fact that the
    utility still ran after 18 days. If I had visualized each iSAX index earlier,
    I would have found the issue much sooner.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我正在进行与 iSAX 相关的研究。在我的一个实验中，我运行了一个创建两个 iSAX 索引并将它们以比第 5 章[*第 5 章*](B14769_05.xhtml#_idTextAnchor124)中展示的更复杂的方式连接的实用程序。该实用程序处理了包含
    500,000 个元素的 2 个时间序列，并且运行了超过 18 天！此外，该实用程序处理包含 1,500,000 个元素的 2 个时间序列需要大约 2 个小时，这意味着该实用程序运行良好。我决定使用一个单独的
    Python 实用程序来可视化每个 iSAX 索引。长话短说，在包含 500,000 个元素的时间序列的情况下，我错误地使用了 32 个段和 4 的基数值，而不是
    4 个段和 32 的基数值！这意味着每个 iSAX 索引的根节点有 2 的 32 个子节点！因此，连接它们需要进行如此多的计算，这解释了为什么实用程序在 18
    天后仍在运行。如果我在早期就可视化每个 iSAX 索引，我会更早地发现这个问题。
- en: Visualizing iSAX as a tree
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 iSAX 可视化为树状结构
- en: In this first try, we are going to visualize an iSAX index as a tree using various
    visualizations. As iSAX has a tree structure, using this kind of visualization
    makes perfect sense.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次尝试中，我们将使用各种可视化方法将 iSAX 索引可视化为一棵树。由于 iSAX 具有树状结构，使用这种类型的可视化是非常有意义的。
- en: For this subsection, we are going to use the visualization stored in the `TreeTidy`
    directory that we saw earlier. The first task to up is to update the JSON file
    stored in the `files` directory of the `TreeTidy` directory. If we are in the
    `TreeTidy` directory, we can run `cp ../100k.json files/85b8f8…9573750ba.json`.
    The full filename is omitted for brevity – just make sure that you use the correct
    filename with the help of `shell` auto-completion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个子节，我们将使用之前看到的`TreeTidy`目录中的可视化。首要任务是更新`TreeTidy`目录中`files`目录下存储的JSON文件。如果我们处于`TreeTidy`目录中，我们可以运行`cp
    ../100k.json files/85b8f8…9573750ba.json`。为了简洁起见，省略了完整文件名 - 只需确保在`shell`自动补全的帮助下使用正确的文件名。
- en: In *Figure 6**.2*, you can see the visualization of the iSAX index generated
    for the `100k.gz` time series using the `D3.js` code that also generated the sample
    output of *Figure 6**.1*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.2*中，你可以看到使用`D3.js`代码生成的iSAX索引的可视化，该代码也生成了*图6.1*的样本输出。
- en: '![Figure 6.2 – Visualizing an iSAX index as a tree](img/Figure_6.2_B14769.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 将iSAX索引作为树可视化](img/Figure_6.2_B14769.jpg)'
- en: Figure 6.2 – Visualizing an iSAX index as a tree
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 将iSAX索引作为树可视化
- en: What does *Figure 6**.2* tell us? It tells us that we are dealing with a relatively
    small iSAX index that is pretty balanced (the depths of the terminal nodes do
    not differ too much), which is a good thing. By default, terminal nodes are visualized
    with gray color circles, whereas inner nodes are black.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2*.2*告诉我们什么？它告诉我们我们正在处理一个相对较小的、相当平衡的iSAX索引（终端节点的深度差异不大），这是一个好事。默认情况下，终端节点以灰色圆圈进行可视化，而内部节点是黑色的。'
- en: 'So, what can we do next? Next, we can try visualizing `100k.gz` using different
    iSAX parameters. So, in this case, we are going to use the following parameters:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们接下来能做什么？接下来，我们可以尝试使用不同的iSAX参数可视化`100k.gz`。在这种情况下，我们将使用以下参数：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As before, the generated output is going to be stored in the existing JSON
    file inside the `files` directory. The updated output can be seen in *Figure 6**.3*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，生成的输出将被存储在`files`目录中现有的JSON文件中。更新的输出可以在*图6.3*中看到：
- en: '![Figure 6.3 – Increasing the threshold value to 5,000](img/Figure_6.3_B14769.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 将阈值值增加到5,000](img/Figure_6.3_B14769.jpg)'
- en: Figure 6.3 – Increasing the threshold value to 5,000
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 将阈值值增加到5,000
- en: As expected, the iSAX index is smaller than before, mainly because we have fewer
    node splits. However, it looks less balanced than the iSAX presented in *Figure
    6**.2*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，iSAX索引比之前小，主要是因为我们减少了节点分裂。然而，它看起来不如*图6.2*中展示的iSAX平衡。2*。
- en: Is there anything more to do? We can experiment a little bit more and change
    the segments value from `4` to `3` while keeping the threshold value at `5000`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他需要做的事情吗？我们可以进行更多实验，并将段值从`4`更改为`3`，同时保持阈值值在`5000`。
- en: 'So, this time, the JSON output is going to be generated using this command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次，我们将使用以下命令生成JSON输出：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we need to store the output in the JSON file located in the `files`
    directory. The new visualization can be seen in *Figure 6**.4*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要将输出存储在`files`目录中位于的JSON文件中。新的可视化可以在*图6.4*中看到：
- en: '![Figure 6.4 – Visualizing an iSAX with three segments](img/Figure_6.4_B14769.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 以三个段可视化iSAX](img/Figure_6.4_B14769.jpg)'
- en: Figure 6.4 – Visualizing an iSAX with three segments
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 以三个段可视化iSAX
- en: As expected, the root node has fewer children. However, the general shape of
    the iSAX index presented in *Figure 6**.4* is similar to the one presented in
    *Figure 6**.3*. In my personal opinion, *Figure 6**.2* shows a better and more
    balanced iSAX index compared to the other two versions. Balanced trees, and therefore
    balanced iSAX indexes, are generally faster to search, which is a desired property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，根节点有较少的子节点。然而，*图6.4*中展示的iSAX索引的总体形状与*图6.3*中展示的相似。就我个人而言，我认为*图6.2*展示的iSAX索引比其他两个版本更好、更平衡。平衡树，因此平衡的iSAX索引，通常搜索更快，这是一个期望的特性。
- en: In this section, we saw how to visualize iSAX indexes as tree structures, which
    makes perfect sense, as iSAX indexes are trees.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何将iSAX索引作为树结构进行可视化，这是很有意义的，因为iSAX索引本身就是树。
- en: In the next section, we are going to try a different kind of visualization for
    the iSAX index structure. After all, visualization and experimentation are good
    friends.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试为iSAX索引结构进行不同类型的可视化。毕竟，可视化和实验是好朋友。
- en: Trying something radical
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一些激进的方法
- en: In this section, we are going to try a different kind of visualization for visualizing
    an iSAX index, just in case it reveals any extra kind of information. So, we are
    going to use a `TreeRadialTidy` directory inside the `ch06` directory and replace
    the JSON file found in the `files` directory with `100k.json` – the correct file
    is already there. However, if you want to use your own data, you should update
    that file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试一种不同的可视化方法来可视化 iSAX 索引，以防它揭示任何额外的信息。因此，我们将使用 `ch06` 目录中的 `TreeRadialTidy`
    目录，并用 `files` 目录中找到的 `100k.json` 替换 JSON 文件——正确的文件已经在那里。然而，如果您想使用自己的数据，您应该更新该文件。
- en: 'Next, we should run the Python HTTP server and point our web browser to http://localhost:8000/.
    The generated output is presented in *Figure 6**.5*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该运行 Python HTTP 服务器并将我们的网页浏览器指向 http://localhost:8000/。生成的输出在 *图 6.5*
    中展示：
- en: '![Figure 6.5 – Using a Radial Tree structure](img/Figure_6.5_B14769.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – 使用径向树结构](img/Figure_6.5_B14769.jpg)'
- en: Figure 6.5 – Using a Radial Tree structure
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 使用径向树结构
- en: What kind of information can we get from *Figure 6**.5*? Is that better than
    a regular tree structure? I do not know whether it is better or not, but it surely
    presents the same information in a totally new way!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 *图 6.5* 中获得哪些信息？这比常规树状结构好吗？我不知道它是否更好，但它确实以全新的方式展示了相同的信息！
- en: One advantage of the radial tree is that it performs better when dealing with
    iSAX indexes with large depths as they can fit better on screen. Personally, I
    believe that the plain tree structure is more suitable for iSAX indexes than the
    radial tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 径向树的一个优点是，当处理具有较大深度的 iSAX 索引时，它表现更好，因为它们可以更好地适应屏幕。我个人认为，平面树状结构比径向树更适合 iSAX 索引。
- en: The next section continues the visualization process of iSAX indexes by trying
    more visualizations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将继续通过尝试更多可视化来继续 iSAX 索引的可视化过程。
- en: More iSAX index visualizations
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 iSAX 索引可视化
- en: We are not done yet! There exist ways to improve the previous visualization
    by adding more information to the output as well as the ability to compress various
    parts of it – there is always the danger of *putting too much information* on
    a graph or a plot, but we are not going to make that mistake here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！存在通过向输出添加更多信息以及压缩其各个部分的能力来改进先前可视化的方法——总是在图表或图表上放置过多信息的危险，但在这里我们不会犯这个错误。
- en: First, we are going to go to the `ZoomableTreemap` directory in order to try
    a zoomable structure named **Zoomable Treemap**, which is better when dealing
    with large iSAX indexes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将前往 `ZoomableTreemap` 目录，尝试一个名为 **可缩放树状图** 的可缩放结构，当处理大型 iSAX 索引时，这种结构更为合适。
- en: 'The Zoomable Treemap uses an additional attribute called `value`. In this case,
    I had two choices: either change the output of the Python script or change the
    JavaScript code. I decided to do the latter. So, I changed the `value` attribute
    in the JavaScript code to `size`, which is what the Python script generates. However,
    in our case, this created a bug in the JavaScript code related to the sum of the
    presented values, which means that this was not the correct decision.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可缩放树状图使用一个额外的属性称为 `value`。在这种情况下，我有两个选择：要么更改 Python 脚本的输出，要么更改 JavaScript 代码。我决定后者。因此，我将
    JavaScript 代码中的 `value` 属性更改为 `size`，这是 Python 脚本生成的。然而，在我们的情况下，这导致了 JavaScript
    代码中与展示值总和相关的错误，这意味着这不是正确的决定。
- en: Therefore, we are going to change the JSON file and replace the `size` field
    name with `value`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将更改 JSON 文件并将 `size` 字段名称替换为 `value`。
- en: 'As before, we should overwrite the JSON file in the `files` directory with
    `100k.json` and run the Python HTTP server. The generated output can be seen in
    *Figure 6**.6*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应该用 `100k.json` 覆盖 `files` 目录中的 JSON 文件并运行 Python HTTP 服务器。生成的输出可以在 *图
    6.6* 中看到：
- en: '![Figure 6.6 – A Zoomable Treemap visualization](img/Figure_6.6_B14769.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 可缩放树状图可视化](img/Figure_6.6_B14769.jpg)'
- en: Figure 6.6 – A Zoomable Treemap visualization
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 可缩放树状图可视化
- en: It turns out that the Zoomable Treemap might be difficult to read and understand
    – it is even difficult to realize that we are talking about a tree structure.
    Therefore, it might not be a good choice for the iSAX visualization. However,
    the *zoomable* capability is very handy in almost all cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，可缩放树状图可能难以阅读和理解——甚至难以意识到我们正在讨论一个树状结构。因此，它可能不是 iSAX 可视化的好选择。然而，*可缩放* 功能在几乎所有情况下都非常方便。
- en: If we used the buggy version, then instead of the numeric values in the output,
    we would have got a `NaN` value – this probably had to do with the JavaScript
    code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了有错误的版本，那么输出中的数值将被替换为 `NaN` 值——这很可能与 JavaScript 代码有关。
- en: 'Let us now continue with something different. Go to the `ZoomableSunburst`
    directory and replace the file in the `files` directory with the `100k.json` file.
    Once again, we need to make code changes. Specifically, we need to replace the
    `value` field used in `86ddbc29bd33f9d6@357.js` with the `size` field that our
    JSON record has. The code stored in GitHub has all the necessary changes in it.
    The generated output can be seen in *Figure 6**.7*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在继续讨论一些不同的事情。前往 `ZoomableSunburst` 目录，并将 `files` 目录中的文件替换为 `100k.json` 文件。再次，我们需要进行代码更改。具体来说，我们需要将
    `86ddbc29bd33f9d6@357.js` 中使用的 `value` 字段替换为我们 JSON 记录中的 `size` 字段。GitHub 上的代码存储了所有必要的更改。生成的输出可以在
    *图 6.7* 中看到：
- en: '![Figure 6.7 – A Zoomable Sunburst visualization](img/Figure_6.7_B14769.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 可缩放的太阳花可视化](img/Figure_6.7_B14769.jpg)'
- en: Figure 6.7 – A Zoomable Sunburst visualization
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 可缩放的太阳花可视化
- en: The main advantage of this visualization is that it does not display the entire
    iSAX from the beginning, but it can do so as we are zooming in on the visualization
    by clicking on the different parts of the sunburst. So, it hides some information,
    which can be displayed on demand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化的主要优势是它不会从一开始就显示整个 iSAX，但当我们通过点击太阳花的不同部分来放大可视化时，它可以做到这一点。因此，它隐藏了一些信息，这些信息可以根据需要显示。
- en: If we zoom into any part of the Sunburst, we are going to get a closer look
    at that particular part of the iSAX index.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大太阳花的任何部分，我们将更接近地查看 iSAX 索引的该特定部分。
- en: '*Figure 6**.8* shows such a part of the Sunburst:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.8* 展示了太阳花的一部分：'
- en: '![Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst](img/Figure_6.8_B14769.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 缩放太阳花中的 0_0_1_1 子树](img/Figure_6.8_B14769.jpg)'
- en: Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 缩放太阳花中的 0_0_1_1 子树
- en: Once again, the zooming capability is handy, and we want to have it in our visualizations.
    The next section discusses an interesting kind of plot, which is called icicle,
    and looks like it is suitable for visualizing iSAX indexes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，缩放功能很实用，我们希望在可视化中拥有它。下一节将讨论一种有趣的图表类型，称为冰柱图，看起来它适合用于可视化 iSAX 索引。
- en: Using icicle plots
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用冰柱图
- en: In this section, we are going to discuss a different kind of plot, which is
    called an **icicle plot**. An icicle plot is a method for presenting hierarchical
    clustering and is able to visualize hierarchical data using rectangular sectors
    that go from the root node to the leaves. In our case, we are going to use a **zoomable**
    **icicle plot**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一种不同类型的图表，称为 **冰柱图**。冰柱图是一种用于展示层次聚类的方法，能够使用从根节点到叶子的矩形扇区来可视化层次数据。在我们的案例中，我们将使用
    **可缩放** 的 **冰柱图**。
- en: First, please go to the `ZoomableIcicle` directory and replace the JSON file
    in `files` with `100k.json`. This time, instead of changing the JavaScript code,
    we are going to change the field name of the JSON file from `size` to `value`.
    In general, *it is better to change your input data than* *the code*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请前往 `ZoomableIcicle` 目录，并将 `files` 中的 JSON 文件替换为 `100k.json`。这次，我们不是更改 JavaScript
    代码，而是将 JSON 文件的字段名从 `size` 更改为 `value`。一般来说，*更改输入数据比更改代码更好*。
- en: '*Figure 6**.9* shows a part of the generated icicle visualization. The rectangle
    on the left side represents the root node, which contains **99,985** subsequences
    – this is the total number of subsequences stored in the iSAX index.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6.9* 展示了生成的冰柱可视化的一部分。左侧的矩形代表根节点，其中包含 **99,985** 个子序列——这是在 iSAX 索引中存储的子序列总数。'
- en: '![Figure 6.9 – Visualizing iSAX using an icicle](img/Figure_6.9_B14769.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 使用冰柱可视化 iSAX](img/Figure_6.9_B14769.jpg)'
- en: Figure 6.9 – Visualizing iSAX using an icicle
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 使用冰柱可视化 iSAX
- en: Apart from the SAX representation of a node, each rectangle displays the number
    of subsequences stored under it. So, the **1_0_0_1** subtree has **10,936** subsequences
    – this is another handy feature.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了节点的 SAX 表示之外，每个矩形还显示了其下存储的子序列数量。因此，**1_0_0_1** 子树有 **10,936** 个子序列——这是另一个实用的功能。
- en: 'Going further, if we zoom on the **1_0_0_0** subtree, we are going to get the
    output displayed as shown in *Figure 6**.10*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，如果我们放大 **1_0_0_0** 子树，我们将得到如图 *图 6.10* 所示的输出：
- en: '![Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree](img/Figure_6.10_B14769.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 仔细查看 1_0_0_0 子树](img/Figure_6.10_B14769.jpg)'
- en: Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 仔细查看 1_0_0_0 子树
- en: 'Similarly, if we zoom in on the **1_1_1_0** subtree, we are going to get the
    visualization presented in *Figure 6**.11*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们放大**1_1_1_0**子树，我们将得到*图 6.11*中展示的可视化：
- en: '![Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree](img/Figure_6.11_B14769.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 仔细查看 1_1_1_0 子树](img/Figure_6.11_B14769.jpg)'
- en: Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 仔细查看 1_1_1_0 子树
- en: Let us discuss *Figure 6**.11* a little more. What does it tell us? It tells
    us that the **1_1_1_0** child of the root node stores **4,342** subsequences.
    **4,246** of these subsequences are under the **10_1_1_0** subtree and the rest
    of the subsequences are under the **11_1_1_0** subtree.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论一下*图 6.11*。它告诉我们什么？它告诉我们根节点的**1_1_1_0**子节点存储了**4,342**个子序列。其中**4,246**个子序列位于**10_1_1_0**子树下，其余的子序列位于**11_1_1_0**子树下。
- en: If we zoom in on the **10_1_1_0** node, we are going to get *Figure 6**.12*,
    which shows that the **10_10_10_0** subtree has **4,031** nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大**10_1_1_0**节点，我们将得到*图 6.12*，它显示**10_10_10_0**子树有**4,031**个节点。
- en: '![Figure 6.12 – Taking a closer look at the 10_1_1_0  subtree](img/Figure_6.12_B14769.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 仔细查看 10_1_1_0 子树](img/Figure_6.12_B14769.jpg)'
- en: Figure 6.12 – Taking a closer look at the 10_1_1_0 subtree
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 仔细查看 10_1_1_0 子树
- en: As we are using a smaller threshold value, we know that the **10_10_10_0** node
    is an inner node that can be further expanded.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了一个较小的阈值值，我们知道**10_10_10_0**节点是一个可以进一步展开的内节点。
- en: This way, we can explore the iSAX index and find the information we want.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以探索 iSAX 索引并找到我们想要的信息。
- en: The icicle plot looks appropriate for visualizing iSAX indexes. However, we
    might find a better type of visualization if we experiment more.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 冰柱图看起来适合可视化 iSAX 索引。然而，如果我们进行更多实验，可能会发现更好的可视化类型。
- en: The next section presents a Collapsible Tree visualization of an iSAX index.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示一个 iSAX 索引的可折叠树可视化。
- en: Visualizing iSAX as a Collapsible Tree
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 iSAX 可视化为可折叠树
- en: Although the zoomable icicle looks very promising, some people might want a
    visualization that looks like a tree but still has some of the versatility of
    the zoomable icicle. For those people, we are going to try the **Collapsible Tree**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可缩放的冰柱图看起来非常有前景，但有些人可能想要一种看起来像树但仍然具有可缩放冰柱图的一些多功能性的可视化。对于这些人，我们将尝试使用**可折叠树**。
- en: 'First, we go to the `CollapsibleTree` directory and then we run the Python
    web server. Then, we go to `http://localhost:8000/`. *Figure 6**.13* shows the
    output of the Collapsible Tree visualization:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进入`CollapsibleTree`目录，然后运行 Python 网络服务器。然后，我们访问`http://localhost:8000/`。*图
    6.13*显示了可折叠树可视化的输出：
- en: '![Figure 6.13 – Visualizing iSAX as a Collapsible Tree](img/Image97716.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 将 iSAX 可视化为可折叠树](img/Image97716.jpg)'
- en: Figure 6.13 – Visualizing iSAX as a Collapsible Tree
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 将 iSAX 可视化为可折叠树
- en: The main advantage of the Collapsible Tree is that we can expand or collapse
    nodes at will, which means that we can easily concentrate on the nodes that interest
    us the most instead of getting lost in the details of the iSAX index.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可折叠树的主要优势在于我们可以随意展开或折叠节点，这意味着我们可以轻松地集中精力在最感兴趣的节点上，而不是迷失在 iSAX 索引的细节中。
- en: However, the Collapsible Tree does not display the number of subsequences stored
    under each subtree of the index.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可折叠树不显示索引每个子树下的子序列数量。
- en: In this last section, we saw the operation of the Collapsible Tree and understood
    its versatility, as well as its limitations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们看到了可折叠树的运作方式，并了解了它的多功能性以及局限性。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Visualization offers a great way to understand your data. Similarly, visualization
    is a great way to understand the structure of an iSAX index, especially a big
    one. In this chapter, we saw various ways to visualize an iSAX index with the
    help of the `D3.js` JavaScript library and got a better look at the distribution
    of the subsequences and the height of iSAX indexes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是理解数据的一种极好方式。同样，可视化也是理解 iSAX 索引结构，尤其是大型索引结构的一种极好方式。在本章中，我们看到了使用 `D3.js` JavaScript
    库可视化 iSAX 索引的各种方法，并更深入地了解了子序列的分布和 iSAX 索引的高度。
- en: However, it would be great to try your own visualizations using the `D3.js`
    JavaScript library, R, or other appropriate Python packages, which can also create
    impressive visualizations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试使用 `D3.js` JavaScript 库、R 或其他适当的 Python 包进行自己的可视化将是非常棒的，这些包也可以创建令人印象深刻的可视化。
- en: Lastly, do not underestimate the power of a good visualization as it can reveal
    lots of information in an easy-to-discover way. Just keep in mind that visualization
    is an art that is hard to master.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要低估良好可视化的力量，因为它可以以易于发现的方式揭示大量信息。只需记住，可视化是一门难以掌握的艺术。
- en: The next chapter is about using iSAX indexes for the approximate calculation
    of the Matrix Pr[ofile and the MPdist distance.](https://en.wikipedia.org/wiki/JavaScript)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何使用 iSAX 索引来进行矩阵 [Profile 和 MPdist 距离的近似计算](https://en.wikipedia.org/wiki/JavaScript)。
- en: '[Useful li](https://en.wikipedia.org/wiki/JavaScript)nks'
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[有用的链接](https://en.wikipedia.org/wiki/JavaScript)'
- en: '*JavaScript*: [https://en.wikipedia.org/wiki/JavaScript](https://en.wikipedia.org/wiki/JavaScript)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JavaScript*：[https://en.wikipedia.org/wiki/JavaScript](https://en.wikipedia.org/wiki/JavaScript)'
- en: 'The Mozilla Developer Network: [https://developer.mozilla.org/en/JavaScript](https://developer.mozilla.org/en/JavaScript)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla 开发者网络：[https://developer.mozilla.org/en/JavaScript](https://developer.mozilla.org/en/JavaScript)
- en: 'The official page for the `D3.js` JavaScript library: [https://d3js.org/](https://d3js.org/)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D3.js` JavaScript 库的官方页面：[https://d3js.org/](https://d3js.org/)'
- en: 'You can learn more information about icicle plots by reading the *Icicle Plots:
    Better Displays for Hierarchical Clustering* paper, which was wri[tten by J. B.
    Kruskal and](https://www.r-project.org/) J. M. Landwehr'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '通过阅读由 J. B. Kruskal 和 J. M. Landwehr 撰写的 *Icicle Plots: Better Displays for
    Hierarchical Clustering* 论文，您可以了解更多关于冰柱图的信息。'
- en: 'The R Project: [https://www.r-project.org/](https://www.r-project.org/)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R 项目：[https://www.r-project.org/](https://www.r-project.org/)
- en: 'The Seaborn Python package: [https://seaborn.pydata.org/](https://seaborn.pydata.org/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seaborn Python 包：[https://seaborn.pydata.org/](https://seaborn.pydata.org/)
- en: 'The Julia programming language: [https://julialang.org/](https://julialang.org/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 编程语言：[https://julialang.org/](https://julialang.org/)
- en: 'The `plotly` Python library: [https://plotly.com/python/](https://plotly.com/python/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plotly` Python 库：[https://plotly.com/python/](https://plotly.com/python/)'
- en: A very good book about the art of data visualization is *The Visual Display
    of Quantitative Information*, by Edward R. Tufte
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本关于数据可视化艺术的非常好的书是 Edward R. Tufte 所著的 *The Visual Display of Quantitative Information*。
- en: '*D3* *Gallery*: [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D3* *画廊*：[https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery)'
- en: '*Tree,* *Tidy*: [https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树，整洁*：[https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)'
- en: '*Zoomable* *Treemap*: [https://observablehq.com/@d3/zoomable-treemap](mailto:https://observablehq.com/@d3/zoomable-treemap)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缩放* *Treemap*：[https://observablehq.com/@d3/zoomable-treemap](mailto:https://observablehq.com/@d3/zoomable-treemap)'
- en: '*Zoomable* *Sunburst*: [https://observablehq.com/@d3/zoomable-sunburst](mailto:https://observablehq.com/@d3/zoomable-sunburst)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缩放* *Sunburst*：[https://observablehq.com/@d3/zoomable-sunburst](mailto:https://observablehq.com/@d3/zoomable-sunburst)'
- en: '*Zoomable* *Icicle*: [https://observablehq.com/@d3/zoomable-icicle](mailto:https://observablehq.com/@d3/zoomable-icicle)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缩放* *Icicle*：[https://observablehq.com/@d3/zoomable-icicle](mailto:https://observablehq.com/@d3/zoomable-icicle)'
- en: '*Tree, Radial* *Tidy*: [https://observablehq.com/@d3/radial-tree](mailto:https://observablehq.com/@d3/radial-tree)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*树，径向* *整洁*：[https://observablehq.com/@d3/radial-tree](mailto:https://observablehq.com/@d3/radial-tree)'
- en: '*Collapsible* *Tree*: [https://observablehq.com/@d3/collapsible-tree](mailto:https://observablehq.com/@d3/collapsible-tree)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可折叠* *树*：[https://observablehq.com/@d3/collapsible-tree](mailto:https://observablehq.com/@d3/collapsible-tree)'
- en: Exercises
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try to do the following exercises:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习：
- en: Create a time series with 50,000 elements and plot its iSAX index using 6, 8,
    and 10 segments. In all cases, use a threshold value of `500`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含 50,000 个元素的时序，并使用 6、8 和 10 个段绘制其 iSAX 索引。在所有情况下，使用阈值值 `500`。
- en: Create a time series with 150,000 elements and plot its iSAX index using 4,
    6, and 8 segments.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含 150,000 个元素的时序，并使用 4、6 和 8 个段绘制其 iSAX 索引。
- en: Create a time series with 250,000 elements and plot its iSAX index for 4, 6,
    and 10 segments. In all cases, use a threshold value of `5000`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含 250,000 个元素的时序，并绘制其 iSAX 索引，分为 4、6 和 10 个段。在所有情况下，使用阈值值 `5000`。
- en: Make a version of `exportJSON.py` that replaces the `size` field with a field
    named `value`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `exportJSON.py` 的版本，用名为 `value` 的字段替换 `size` 字段。
- en: If you are familiar with JavaScript, change the colors of the zoomable icicle
    plot.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你熟悉 JavaScript，请更改可缩放的冰柱图的色彩。
- en: If you are familiar with JavaScript, make the zoomable icicle plot go from *top
    to bottom* instead of *left* *to right*.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您熟悉JavaScript，请将可缩放的冰柱图从**上到下**调整，而不是从**左到右**。
- en: If you are familiar with JavaScript, make the Collapsible Tree visualization
    go from *top to bottom* instead of *left to right*. Is that better than before?
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您熟悉JavaScript，请将可折叠的树形图从**上到下**调整，而不是从**左到右**。这比之前更好吗？
- en: Experiment with the Zoomable Circle Packing visualization, which can be found
    at [https://observablehq.com/@d3/zoomable-circle-packing](mailto:https://observablehq.com/@d3/zoomable-circle-packing).
    What do you think of it?
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用可缩放的圆形排列可视化效果，您可以在[https://observablehq.com/@d3/zoomable-circle-packing](mailto:https://observablehq.com/@d3/zoomable-circle-packing)找到它。您对它有什么看法？
