- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizing iSAX Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about comparing and joining iSAX indexes.
    However, it is still difficult to imagine the structure and the height of an iSAX
    index without seeing it as an image.
  prefs: []
  type: TYPE_NORMAL
- en: And although some people prefer text, some other people prefer log files, and
    some others prefer numbers, almost all people like good-looking and informative
    visualizations. Additionally, all people understand the importance of having a
    high-level view of their data. This includes iSAX indexes and tree structures
    in general, mainly because there is no other practical way to perform the same
    task, especially when working with big time series.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B14769_01.xhtml#_idTextAnchor015), we saw how to visualize
    a time series. This chapter is all about visualizing iSAX indexes in order to
    get a better understanding of their size, shape, and structure.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing large structures and trees such as iSAX indexes is not a trivial
    process but of a trial-and-error one. As no single visualization can do the job,
    we are going to try different kinds of plots and see what they tell us about the
    iSAX index. Therefore, you should expect to see lots of visualizations in this
    chapter, and I expect that you are going to create many more visualizations on
    your own while reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing an iSAX index in JSON format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing an iSAX index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying something radical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More iSAX index visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using icicle plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing iSAX as a Collapsible Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub repository for the book is at [https://github.com/PacktPublishing/Time-Series-Indexing](https://github.com/PacktPublishing/Time-Series-Indexing).
    The code for each chapter is in its own directory. Therefore, the code for [*Chapter
    6*](B14769_06.xhtml#_idTextAnchor145) can be found in the `ch06` folder. However,
    in this chapter, there exist many directories under the `ch06` folder that contain
    the code for the different visualizations that we are going to create – this is
    a good way to organize code.
  prefs: []
  type: TYPE_NORMAL
- en: Storing an iSAX index in JSON format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the visualizations of this chapter, we are going to use the low-level `D3.js`
    JavaScript library.
  prefs: []
  type: TYPE_NORMAL
- en: Is D3.js the only way to create visualizations?
  prefs: []
  type: TYPE_NORMAL
- en: The powerful `D3.js` JavaScript library is not a panacea and therefore, it is
    not the only way to create visualizations. There exist many Python packages that
    are good at plotting data, as well as programming languages such as R or Julia.
    However, JavaScript can be used for presenting your plots in a web page environment,
    which is not usually the case with the other options.
  prefs: []
  type: TYPE_NORMAL
- en: For the JavaScript `D3.js` code to work, we need to represent an iSAX index
    in **JSON** format so that it can be understood by the JavaScript code – we mainly
    need to represent **the structure and the connections** between iSAX nodes in
    a way that can be understood by a computer and a programming language. Therefore,
    the first step we should take is to convert an iSAX index representation with
    its structures from Python code into a different structure made by JSON records.
  prefs: []
  type: TYPE_NORMAL
- en: Although this JSON format is not universal and might fail in some cases, it
    is going to be used throughout this chapter as all presented `D3.js` code works
    fine with it – all presented examples are tested and fully working.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to visit [https://d3js.org/](https://d3js.org/) and click on
    **Examples** at the top of the page, which is going to take us to [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery).
    The latter page is going to bring us to a page with professional, functional,
    and beautiful plots that look appropriate for the kind and amount of data that
    we want to plot in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: From the long list of available visualizations, we need to pick the ones that
    we prefer and are a good match for our data and its structure – our first attempt
    might not be perfect. Do not forget that iSAX indexes can have a large number
    of nodes. Therefore, we should think rationally and pick something that is going
    to look good with lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: From that list, we pick `Tree, Tidy`. Behind the visualization, there is JavaScript
    code embedded into HTML that reads the JSON data, parses it, and creates the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have found our visualization of preference ([https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)),
    we might begin looking at the JavaScript code to get a better idea of the data
    format that is expected from the JavaScript code. However, what is more important
    is the JSON record format.
  prefs: []
  type: TYPE_NORMAL
- en: Where is the JavaScript code?
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a powerful but low-level programming language. The good thing
    is that the presented visualizations do not need any JavaScript knowledge to work.
    You just need to put your own data in the right format, at the right place, and
    that is all!
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON records that we are going to support should have the following format
    – this format was found by looking into the JSON file that the JavaScript code
    uses to get its data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The common idea behind the structure that we want to support is that we have
    a root node – the root of the tree – that has multiple children, those children
    have children of their own, and so on. The name of each node is a `name` field
    is given to the root node of the tree – in this case, that name will be `flare`.
  prefs: []
  type: TYPE_NORMAL
- en: There is an additional field that is going to be needed in some of the presented
    visualizations. Later on in this chapter, we are going to learn that terminal
    nodes have an additional field for storing the number of the subsequences that
    they hold – this is not used by every visualization. However, the thought remains
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample tidy tree visualization with custom data can be seen in the following
    figure. We are going to present more complex visualizations in the sections that
    follow. This is a simple tree structure with a root node and 13 nodes as its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A tree visualization](img/Figure_6.1_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A tree visualization
  prefs: []
  type: TYPE_NORMAL
- en: With all that in mind, we can now begin working on our Python code. The Python
    script for representing an iSAX index as a JSON file is called `exportJSON.py`.
    The logic behind `exportJSON.py` is that after creating the iSAX index, we traverse
    it in order to generate the JSON output in the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, here is the definition of the JSON record that is going to be used
    in the Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic JSON record format – we can add more fields to this record
    depending on our needs for any customization requirements without breaking any
    JavaScript code, as JavaScript is going to read only the fields that it needs.
    Although the format is defined in the code, it is not used by the Python code,
    mainly because Python does not need a predefined structure for JSON data that
    is stored in dictionaries. However, it is good to have it defined as a point of
    reference. The `size` field stores the total number of subsequences stored under
    each terminal node. Inner nodes do not need such a field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python code within `exportJSON.py` that reads the existing iSAX index and
    prints the JSON output can be found at the end of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The name of the Python dictionary that holds the JSON records is `data`. By
    default, the root node has the name `0`, which is a string – this is analogous
    to `flare`. You can change that to anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code visits and processes the children of the root node of the
    iSAX index only. The rest is handled by the `createJSON()` function. `createJSON()`
    is the function that actually generates the JSON output by adding data for the
    current subtree that is being examined. The `data` variable holds all JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: The last statement prints all JSON records on the screen using `json.dumps()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createJSON()` function is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `createJSON()` function is called recursively in order to visit all the
    nodes of each subtree. This mainly happens because we need to process all inner
    nodes and all terminal nodes.
  prefs: []
  type: TYPE_NORMAL
- en: About the JSON output
  prefs: []
  type: TYPE_NORMAL
- en: This particular Python script generates JSON output based on a particular JSON
    record format. Once you get the idea right, it is going to be easy to make small
    changes to the script, add more fields to the JSON records, or create something
    totally different. All these depend on the format that the visualization script
    expects to work with.
  prefs: []
  type: TYPE_NORMAL
- en: For terminal nodes, we keep the number of the subsequences they hold – this
    takes place in the `size` field, and the processing of each terminal node ends
    here. However, for inner nodes, we recursively call `createJSON()` in order to
    process the left and the right children or subtrees of each inner node.
  prefs: []
  type: TYPE_NORMAL
- en: With all that in mind, let us see `exportJSON.py` in action. First, we are going
    to use it with a small iSAX index, using a time series named `ts.gz` that contains
    100 elements – due to its small size, `ts.gz` is going to be used for experimentation
    purposes. `ts.gz` was created by running `../ch01/synthetic_data.py 100 -10 10`,
    saving the output in a file named `ts` and compressing `ts` with `gzip(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `exportJSON.py` with `ts.gz` produces the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Processing that data with the `jq(1)` utility, which beautifies JSON records,
    generates the next better-looking output – in this case, all the children of the
    root are terminal nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Bear in mind that the output depends on the parameters of the iSAX index**.
    Different iSAX parameters generate different outputs and different tree structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us try `exportJSON.py` with a bigger time series that is named `100k.gz`,
    which contains 100,000 elements and was created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We ran `exportJSON.py` with `100k.gz` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The output file was saved as `100k.json`. The reason for using a threshold value
    of `2500` is to have a more compact tree. However, at the end of the day, what
    matters is your needs and the actual parameters of your iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we processed `ts.gz` and `100k.gz` with `exportJSON.py`, and
    we end up having two JSON files named `ts.json` and `100k.json`, respectively.
    Although we might need `ts.json` for testing, all coming visualizations are going
    to use `100k.json`.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about downloading the JavaScript project on our local
    machine and executing it from there.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the JavaScript code locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`D3.js` and its powerful capabilities. Therefore, in this subsection, we are
    going to learn how to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: In every visualization from [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery),
    there is a menu that appears when we click on the three dots that appear near
    the upper-right corner of the web page. From that menu, click on the **Export**
    link, which displays a submenu. From that submenu, we should click on the **Download
    code** option. This is going to download the contents of the current project on
    our local machine as a compressed file that we should extract and use.
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this section, we are going to download the JavaScript project
    found at [https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree),
    which is going to download a file named `tree.tgz`. After we have uncompressed
    that file, we are going to get a directory called `tree`. It is not necessary
    to fully understand the contents of the directory, but it helps. However, you
    need to know the path to the JSON file with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the `tree(1)` utility, which lists the contents of directories
    in a tree-like format, when examining the contents of the `tree` directory, is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The JSON file with the records is located in the `files` directory – this is
    the file that we need to overwrite with our own data file. In order to load the
    project, we need to access the `index.xhtml` file, which is going to load all
    the necessary dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We only need to put our own JSON data into the `files` folder – this is the
    only required change to be done.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection is about running the downloaded JavaScript project on your
    own machine, which requires running your own local HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process of running the code locally includes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go into the directory with the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make changes to the JSON file with the data – each example has its own JSON
    data file in a directory named `files`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a local HTTP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JSON file with the data has a long and strange filename that is embedded
    into the JavaScript code. I am not so proficient with JavaScript, so I am going
    to use the default filename, which is located in the `files` directory. For security
    reasons, it is not allowed for the web server to access files outside of its root
    directory. Therefore, we need to *copy the JSON file* we have created with `exportJSON.py`
    in the `files` directory of each individual project and *overwrite the existing
    JSON file*, even if we are using the same one in all our examples.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows how to run your own local HTTP server and view the
    JavaScript code in action.
  prefs: []
  type: TYPE_NORMAL
- en: Running a local HTTP server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to run a local HTTP server is by executing `python3 -m http.server`
    in the directory that interests you. If everything goes fine, the HTTP server
    is going to listen to port number `8000` and it is going to be accessed as http://localhost:8000/.
    This is much easier than it looks.
  prefs: []
  type: TYPE_NORMAL
- en: This process is going to be used throughout this chapter. All the required documents
    and files are in the GitHub repository of the book, so you have nothing more to
    download. If you want to experiment, just change the contents of the JSON file
    with the data.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection shows how to test the process.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have renamed the directory of the previous project from `tree` to `TreeTidy`
    – it is a good practice to use descriptive directory names.
  prefs: []
  type: TYPE_NORMAL
- en: So, first, we need to go to the `ch06` directory of the GitHub repository for
    this book and then go to the `TreeTidy` directory. After that, we need to run
    `python3 -m http.server`. Now, we have an HTTP server running on our local machine
    that listens to the `8000` TCP port. Therefore, we need to point our web browser
    to `http://localhost:8000/` and see the generated visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated output from the Python web server is going to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you see any error messages in the generated output, you should try to resolve
    them.
  prefs: []
  type: TYPE_NORMAL
- en: However, unless you are in the wrong directory or there is another TCP service
    running on TCP port `8000`, there should be no issues.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to represent an iSAX index in JSON format and how
    to download the JavaScript projects from [https://observablehq.com/](https://observablehq.com/).
  prefs: []
  type: TYPE_NORMAL
- en: In the section that follows, we will begin our iSAX visualization journey.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing an iSAX index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to begin visualizing iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: As in most areas of computing, your visualizations are going to improve over
    time. The first visualizations are usually less beautiful and/or informative than
    later ones. So, we are going to experiment and try things before we end up with
    a good-looking iSAX visualization.
  prefs: []
  type: TYPE_NORMAL
- en: As visualizations include personal taste, your visualization of choice might
    differ from the ones used in this chapter. However, we need to start doing and
    improve in the process!
  prefs: []
  type: TYPE_NORMAL
- en: Let us begin with the visualization of the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: A personal story
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, I am doing research related to iSAX. In one
    of my experiments, I ran a utility that creates two iSAX indexes and joins them
    in a more sophisticated way than the one presented in [*Chapter 5*](B14769_05.xhtml#_idTextAnchor124).
    The utility processed 2 time series with 500,000 elements each and ran for more
    than 18 days! Additionally, it took the same utility about 2 hours to process
    2 time series with 1,500,000 elements each, which means that the utility works
    well. I decided to visualize each iSAX index using a separate Python utility.
    Long story short, in the case of the time series with 500,000 elements, I mistakenly
    used 32 segments and a cardinality value of 4, instead of 4 segments and a cardinality
    value of 32! This means that the root of each iSAX index had 2 32 children! Therefore,
    joining them included so many calculations, which explained the fact that the
    utility still ran after 18 days. If I had visualized each iSAX index earlier,
    I would have found the issue much sooner.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing iSAX as a tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this first try, we are going to visualize an iSAX index as a tree using various
    visualizations. As iSAX has a tree structure, using this kind of visualization
    makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: For this subsection, we are going to use the visualization stored in the `TreeTidy`
    directory that we saw earlier. The first task to up is to update the JSON file
    stored in the `files` directory of the `TreeTidy` directory. If we are in the
    `TreeTidy` directory, we can run `cp ../100k.json files/85b8f8…9573750ba.json`.
    The full filename is omitted for brevity – just make sure that you use the correct
    filename with the help of `shell` auto-completion.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.2*, you can see the visualization of the iSAX index generated
    for the `100k.gz` time series using the `D3.js` code that also generated the sample
    output of *Figure 6**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Visualizing an iSAX index as a tree](img/Figure_6.2_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Visualizing an iSAX index as a tree
  prefs: []
  type: TYPE_NORMAL
- en: What does *Figure 6**.2* tell us? It tells us that we are dealing with a relatively
    small iSAX index that is pretty balanced (the depths of the terminal nodes do
    not differ too much), which is a good thing. By default, terminal nodes are visualized
    with gray color circles, whereas inner nodes are black.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what can we do next? Next, we can try visualizing `100k.gz` using different
    iSAX parameters. So, in this case, we are going to use the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the generated output is going to be stored in the existing JSON
    file inside the `files` directory. The updated output can be seen in *Figure 6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Increasing the threshold value to 5,000](img/Figure_6.3_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Increasing the threshold value to 5,000
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the iSAX index is smaller than before, mainly because we have fewer
    node splits. However, it looks less balanced than the iSAX presented in *Figure
    6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Is there anything more to do? We can experiment a little bit more and change
    the segments value from `4` to `3` while keeping the threshold value at `5000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this time, the JSON output is going to be generated using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to store the output in the JSON file located in the `files`
    directory. The new visualization can be seen in *Figure 6**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Visualizing an iSAX with three segments](img/Figure_6.4_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Visualizing an iSAX with three segments
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the root node has fewer children. However, the general shape of
    the iSAX index presented in *Figure 6**.4* is similar to the one presented in
    *Figure 6**.3*. In my personal opinion, *Figure 6**.2* shows a better and more
    balanced iSAX index compared to the other two versions. Balanced trees, and therefore
    balanced iSAX indexes, are generally faster to search, which is a desired property.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to visualize iSAX indexes as tree structures, which
    makes perfect sense, as iSAX indexes are trees.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to try a different kind of visualization for
    the iSAX index structure. After all, visualization and experimentation are good
    friends.
  prefs: []
  type: TYPE_NORMAL
- en: Trying something radical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to try a different kind of visualization for visualizing
    an iSAX index, just in case it reveals any extra kind of information. So, we are
    going to use a `TreeRadialTidy` directory inside the `ch06` directory and replace
    the JSON file found in the `files` directory with `100k.json` – the correct file
    is already there. However, if you want to use your own data, you should update
    that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should run the Python HTTP server and point our web browser to http://localhost:8000/.
    The generated output is presented in *Figure 6**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Using a Radial Tree structure](img/Figure_6.5_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Using a Radial Tree structure
  prefs: []
  type: TYPE_NORMAL
- en: What kind of information can we get from *Figure 6**.5*? Is that better than
    a regular tree structure? I do not know whether it is better or not, but it surely
    presents the same information in a totally new way!
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of the radial tree is that it performs better when dealing with
    iSAX indexes with large depths as they can fit better on screen. Personally, I
    believe that the plain tree structure is more suitable for iSAX indexes than the
    radial tree.
  prefs: []
  type: TYPE_NORMAL
- en: The next section continues the visualization process of iSAX indexes by trying
    more visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: More iSAX index visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are not done yet! There exist ways to improve the previous visualization
    by adding more information to the output as well as the ability to compress various
    parts of it – there is always the danger of *putting too much information* on
    a graph or a plot, but we are not going to make that mistake here.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to go to the `ZoomableTreemap` directory in order to try
    a zoomable structure named **Zoomable Treemap**, which is better when dealing
    with large iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Zoomable Treemap uses an additional attribute called `value`. In this case,
    I had two choices: either change the output of the Python script or change the
    JavaScript code. I decided to do the latter. So, I changed the `value` attribute
    in the JavaScript code to `size`, which is what the Python script generates. However,
    in our case, this created a bug in the JavaScript code related to the sum of the
    presented values, which means that this was not the correct decision.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we are going to change the JSON file and replace the `size` field
    name with `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we should overwrite the JSON file in the `files` directory with
    `100k.json` and run the Python HTTP server. The generated output can be seen in
    *Figure 6**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – A Zoomable Treemap visualization](img/Figure_6.6_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – A Zoomable Treemap visualization
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the Zoomable Treemap might be difficult to read and understand
    – it is even difficult to realize that we are talking about a tree structure.
    Therefore, it might not be a good choice for the iSAX visualization. However,
    the *zoomable* capability is very handy in almost all cases.
  prefs: []
  type: TYPE_NORMAL
- en: If we used the buggy version, then instead of the numeric values in the output,
    we would have got a `NaN` value – this probably had to do with the JavaScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now continue with something different. Go to the `ZoomableSunburst`
    directory and replace the file in the `files` directory with the `100k.json` file.
    Once again, we need to make code changes. Specifically, we need to replace the
    `value` field used in `86ddbc29bd33f9d6@357.js` with the `size` field that our
    JSON record has. The code stored in GitHub has all the necessary changes in it.
    The generated output can be seen in *Figure 6**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – A Zoomable Sunburst visualization](img/Figure_6.7_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – A Zoomable Sunburst visualization
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this visualization is that it does not display the entire
    iSAX from the beginning, but it can do so as we are zooming in on the visualization
    by clicking on the different parts of the sunburst. So, it hides some information,
    which can be displayed on demand.
  prefs: []
  type: TYPE_NORMAL
- en: If we zoom into any part of the Sunburst, we are going to get a closer look
    at that particular part of the iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.8* shows such a part of the Sunburst:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst](img/Figure_6.8_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Zooming in the 0_0_1_1 subtree of the Sunburst
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the zooming capability is handy, and we want to have it in our visualizations.
    The next section discusses an interesting kind of plot, which is called icicle,
    and looks like it is suitable for visualizing iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Using icicle plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss a different kind of plot, which is
    called an **icicle plot**. An icicle plot is a method for presenting hierarchical
    clustering and is able to visualize hierarchical data using rectangular sectors
    that go from the root node to the leaves. In our case, we are going to use a **zoomable**
    **icicle plot**.
  prefs: []
  type: TYPE_NORMAL
- en: First, please go to the `ZoomableIcicle` directory and replace the JSON file
    in `files` with `100k.json`. This time, instead of changing the JavaScript code,
    we are going to change the field name of the JSON file from `size` to `value`.
    In general, *it is better to change your input data than* *the code*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.9* shows a part of the generated icicle visualization. The rectangle
    on the left side represents the root node, which contains **99,985** subsequences
    – this is the total number of subsequences stored in the iSAX index.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Visualizing iSAX using an icicle](img/Figure_6.9_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Visualizing iSAX using an icicle
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the SAX representation of a node, each rectangle displays the number
    of subsequences stored under it. So, the **1_0_0_1** subtree has **10,936** subsequences
    – this is another handy feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going further, if we zoom on the **1_0_0_0** subtree, we are going to get the
    output displayed as shown in *Figure 6**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree](img/Figure_6.10_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Taking a closer look at the 1_0_0_0 subtree
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we zoom in on the **1_1_1_0** subtree, we are going to get the
    visualization presented in *Figure 6**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree](img/Figure_6.11_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Taking a closer look at the 1_1_1_0 subtree
  prefs: []
  type: TYPE_NORMAL
- en: Let us discuss *Figure 6**.11* a little more. What does it tell us? It tells
    us that the **1_1_1_0** child of the root node stores **4,342** subsequences.
    **4,246** of these subsequences are under the **10_1_1_0** subtree and the rest
    of the subsequences are under the **11_1_1_0** subtree.
  prefs: []
  type: TYPE_NORMAL
- en: If we zoom in on the **10_1_1_0** node, we are going to get *Figure 6**.12*,
    which shows that the **10_10_10_0** subtree has **4,031** nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Taking a closer look at the 10_1_1_0  subtree](img/Figure_6.12_B14769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Taking a closer look at the 10_1_1_0 subtree
  prefs: []
  type: TYPE_NORMAL
- en: As we are using a smaller threshold value, we know that the **10_10_10_0** node
    is an inner node that can be further expanded.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can explore the iSAX index and find the information we want.
  prefs: []
  type: TYPE_NORMAL
- en: The icicle plot looks appropriate for visualizing iSAX indexes. However, we
    might find a better type of visualization if we experiment more.
  prefs: []
  type: TYPE_NORMAL
- en: The next section presents a Collapsible Tree visualization of an iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing iSAX as a Collapsible Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the zoomable icicle looks very promising, some people might want a
    visualization that looks like a tree but still has some of the versatility of
    the zoomable icicle. For those people, we are going to try the **Collapsible Tree**.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we go to the `CollapsibleTree` directory and then we run the Python
    web server. Then, we go to `http://localhost:8000/`. *Figure 6**.13* shows the
    output of the Collapsible Tree visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Visualizing iSAX as a Collapsible Tree](img/Image97716.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Visualizing iSAX as a Collapsible Tree
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of the Collapsible Tree is that we can expand or collapse
    nodes at will, which means that we can easily concentrate on the nodes that interest
    us the most instead of getting lost in the details of the iSAX index.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Collapsible Tree does not display the number of subsequences stored
    under each subtree of the index.
  prefs: []
  type: TYPE_NORMAL
- en: In this last section, we saw the operation of the Collapsible Tree and understood
    its versatility, as well as its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualization offers a great way to understand your data. Similarly, visualization
    is a great way to understand the structure of an iSAX index, especially a big
    one. In this chapter, we saw various ways to visualize an iSAX index with the
    help of the `D3.js` JavaScript library and got a better look at the distribution
    of the subsequences and the height of iSAX indexes.
  prefs: []
  type: TYPE_NORMAL
- en: However, it would be great to try your own visualizations using the `D3.js`
    JavaScript library, R, or other appropriate Python packages, which can also create
    impressive visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, do not underestimate the power of a good visualization as it can reveal
    lots of information in an easy-to-discover way. Just keep in mind that visualization
    is an art that is hard to master.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is about using iSAX indexes for the approximate calculation
    of the Matrix Pr[ofile and the MPdist distance.](https://en.wikipedia.org/wiki/JavaScript)
  prefs: []
  type: TYPE_NORMAL
- en: '[Useful li](https://en.wikipedia.org/wiki/JavaScript)nks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*JavaScript*: [https://en.wikipedia.org/wiki/JavaScript](https://en.wikipedia.org/wiki/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Mozilla Developer Network: [https://developer.mozilla.org/en/JavaScript](https://developer.mozilla.org/en/JavaScript)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official page for the `D3.js` JavaScript library: [https://d3js.org/](https://d3js.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more information about icicle plots by reading the *Icicle Plots:
    Better Displays for Hierarchical Clustering* paper, which was wri[tten by J. B.
    Kruskal and](https://www.r-project.org/) J. M. Landwehr'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The R Project: [https://www.r-project.org/](https://www.r-project.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Seaborn Python package: [https://seaborn.pydata.org/](https://seaborn.pydata.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Julia programming language: [https://julialang.org/](https://julialang.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `plotly` Python library: [https://plotly.com/python/](https://plotly.com/python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A very good book about the art of data visualization is *The Visual Display
    of Quantitative Information*, by Edward R. Tufte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D3* *Gallery*: [https://observablehq.com/@d3/gallery](mailto:https://observablehq.com/@d3/gallery)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tree,* *Tidy*: [https://observablehq.com/@d3/tree](mailto:https://observablehq.com/@d3/tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zoomable* *Treemap*: [https://observablehq.com/@d3/zoomable-treemap](mailto:https://observablehq.com/@d3/zoomable-treemap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zoomable* *Sunburst*: [https://observablehq.com/@d3/zoomable-sunburst](mailto:https://observablehq.com/@d3/zoomable-sunburst)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zoomable* *Icicle*: [https://observablehq.com/@d3/zoomable-icicle](mailto:https://observablehq.com/@d3/zoomable-icicle)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tree, Radial* *Tidy*: [https://observablehq.com/@d3/radial-tree](mailto:https://observablehq.com/@d3/radial-tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Collapsible* *Tree*: [https://observablehq.com/@d3/collapsible-tree](mailto:https://observablehq.com/@d3/collapsible-tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try to do the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a time series with 50,000 elements and plot its iSAX index using 6, 8,
    and 10 segments. In all cases, use a threshold value of `500`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a time series with 150,000 elements and plot its iSAX index using 4,
    6, and 8 segments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a time series with 250,000 elements and plot its iSAX index for 4, 6,
    and 10 segments. In all cases, use a threshold value of `5000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a version of `exportJSON.py` that replaces the `size` field with a field
    named `value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with JavaScript, change the colors of the zoomable icicle
    plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with JavaScript, make the zoomable icicle plot go from *top
    to bottom* instead of *left* *to right*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are familiar with JavaScript, make the Collapsible Tree visualization
    go from *top to bottom* instead of *left to right*. Is that better than before?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with the Zoomable Circle Packing visualization, which can be found
    at [https://observablehq.com/@d3/zoomable-circle-packing](mailto:https://observablehq.com/@d3/zoomable-circle-packing).
    What do you think of it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
