- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transportation Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter tackles transportation logistics, which involves the movement of
    supplies or goods from one location to another. We’ll introduce a goods delivery
    problem to find the optimal routing of supplies to minimize the delivery time
    and cost to deliver the goods. We’ll explore shortest paths, optimal routes to
    visit all necessary locations, and scaling algorithms to large networks. Further,
    we’ll examine caveats to simple distance weightings to calculate route optimality,
    considering delivery hazards on routes that can influence optimality.
  prefs: []
  type: TYPE_NORMAL
- en: When you have finished this chapter, you’ll understand how to frame transportation
    problems as network problems and scale them to very large routing networks using
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to transportation problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shortest path applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traveling salesman problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maximum flow/minimum cut** (**max-flow** **min-cut**) algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with some basic problems in transportation logistics.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will require Jupyter Notebook to run the practical examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available here: [https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python](https://github.com/PacktPublishing/Modern-Graph-Theory-Algorithms-with-Python)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to transportation problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physical goods and supplies are important in many industries, and the movement
    of goods between locations represents an important problem in industries such
    as consumer-packaged goods, retail, military, and manufacturing. **Supply chain
    logistics**—the science of acquiring, transporting, and storing resources—influences
    many aspects of business in these industry sectors. Without goods to sell, a company
    cannot turn a profit. Without materials to manufacture goods, products cannot
    be made or transported to vendors.
  prefs: []
  type: TYPE_NORMAL
- en: During the COVID-19 pandemic, many critical supply chain routes shut down, leaving
    long waits for goods in many parts of the world or facing higher prices for necessities
    such as food. Crises such as the Ukraine war can leave entire countries short
    of food, creating humanitarian crises in other areas. Many supply chain logistics
    problems can be formulated through the lens of network science, and graph theory
    offers several useful tools to plan out the best routes to stock goods or materials
    across locations. In this chapter, we’ll learn more about supply chain logistics
    and leverage tools from graph theory to plan supply routes between grocery stores.
  prefs: []
  type: TYPE_NORMAL
- en: Paths between stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common supply chain logistics problem retailers face is the transportation
    of goods across several stores in an area. For instance, consider a suburban area
    with five grocery stores belonging to the same chain spread out across the area,
    as depicted in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A metro area with five grocery stores from the same chain](img/B21087_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – A metro area with five grocery stores from the same chain
  prefs: []
  type: TYPE_NORMAL
- en: 'The metro area of *Figure 4**.1* shows stores that are nearby (right corner)
    and some that are further away from each other (such as the ones on the left).
    Perhaps we are transporting fresh fruit and vegetables from a nearby farm to each
    of the five stores. Without considering streets, fuel stops, or other considerations
    (we’ll discuss these later in the chapter), it seems like a route between stores
    would be easy to define. One such path is shown in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A routing plan to deliver fruit and vegetables to each of the
    grocery stores in the hypothetical suburban area](img/B21087_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A routing plan to deliver fruit and vegetables to each of the grocery
    stores in the hypothetical suburban area
  prefs: []
  type: TYPE_NORMAL
- en: Contrary to *Figure 4**.2*, in a real situation, there are likely to be many
    routes between stores a truck could take. Alternative streets and combinations
    of routes might exist. The truck may need fuel between stores, and the locations
    of gas stations might influence which route is ideal. Roads may be closed for
    construction. Afternoon thunderstorms might flood some of the streets on good
    routes, creating hazards that the truck needs to avoid. Some stores might be out
    of oranges and grapefruit, giving them priority for early deliveries so that customers
    can purchase these fruits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over larger distances, the question of transportation mode also arises. Shipping
    by sea or routing goods by plane might be preferable if obstacles such as oceans
    or mountain ranges exist between stores that need stocking. Since the world globalized,
    it is common for goods to travel across continents and oceans (shipping is shown
    in *Figure 4**.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.3 – \uFEFFAn illustration of a cargo ship leaving port](img/B21087_04_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – An illustration of a cargo ship leaving port
  prefs: []
  type: TYPE_NORMAL
- en: Many products or parts of products used in the United States and Europe come
    from China, Japan, or India. Travel by sea can provide cheaper and quicker alternatives
    to land or air delivery. One of the key problems in supply chain logistics is
    balancing the needs for cost-effectiveness, **time-to-delivery** (**TTD**), and
    the need for bulk goods movements. Let’s dive into some of these considerations
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Fuel costs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the pressing problems in logistics today is the optimization of a route
    with respect to the cost of delivery. Customers don’t want to pay high prices
    for delivery or wait long periods of time for goods to arrive. Since the COVID-19
    shutdowns and the Ukraine war, fuel prices have increased, and some routes for
    goods are no longer available. This drives up costs for manufacturers, businesses
    that need to move goods to physical locations, and consumers buying goods from
    businesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ground routes, particularly when coupled with electric delivery vehicles (shown
    in *Figure 4**.4(a)*), can provide a good option for companies operating locally.
    However, many supply chains depend on parts or goods located overseas, and options
    such as shipping (shown in *Figure 4**.4(b)*) or air travel are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.4 – \uFEFFAn illustration of: (a) A semi-truck used to haul goods\
    \ domestically and (b) a shipping option to move goods overseas](img/B21087_04_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4 – An illustration of: (a) A semi-truck used to haul goods domestically
    and (b) a shipping option to move goods overseas'
  prefs: []
  type: TYPE_NORMAL
- en: However, the cost of fuel is rarely the only consideration, as time is critical
    for any goods that might spoil and as safety concerns related to cargo loss often
    take precedence over fuel costs in real-world problems. Let’s consider some scenarios
    where TTD is an important consideration in the optimization algorithms used to
    schedule delivery times, routes, and best modes of transportation.
  prefs: []
  type: TYPE_NORMAL
- en: Time to deliver goods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first consideration for delivery time involves the urgency factor. Goods
    may spoil within a certain time frame (such as produce or vaccines), and this
    often outweighs the cost, as the goods will not be useable outside of the necessary
    time-to-use period. Sales windows also merit consideration, as Christmas or Ramadan
    items will not be in as great a demand after the holiday passes. This results
    in a loss of profits for the business.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider two tourist cafés, one located in the city of Paramaribo, Suriname,
    and one located in rural Suriname near a nature adventure camp. The city location
    (shown in *Figure 4**.5 (a)*) has access to a refrigerator to store fruit used
    in its smoothies; the rural location (shown in *Figure 4**.5 (b)*) does not have
    a refrigerator. Delivery priority on a shipment of fresh fruit from a local farm
    might prioritize the rural location, as the fruit will spoil faster there:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.5 – \uFEFFAn illustration of: (a) A café in Paramaribo, Suriname\
    \ and (b) a café in rural Suriname near a tourist camp](img/B21087_04_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5 – An illustration of: (a) A café in Paramaribo, Suriname and (b)
    a café in rural Suriname near a tourist camp'
  prefs: []
  type: TYPE_NORMAL
- en: Besides the problem of spoiled goods and missed promotional periods, timing
    factors can include barriers to delivery, such as construction or tollways on
    a route. In addition, time spent in customs can vary dramatically from country
    to country, and it may be advantageous to take a longer driving route to avoid
    traveling through a particular country.
  prefs: []
  type: TYPE_NORMAL
- en: Often, it is necessary to mathematically weight routes not only by physical
    distance but by travel time, including factors such as customs or likelihood of
    construction.
  prefs: []
  type: TYPE_NORMAL
- en: Navigational hazards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigational concerns not only include man-made impediments to delivery; they
    also include natural ones. Hurricanes can delay shipments through busy ports,
    such as the Port of Miami. Avalanches in the Alps are a navigational consideration
    for companies opting for train transport. The shipping industry averages a loss
    of 10 ships per year to high seas and rogue waves. Some shipping routes, such
    as those off the southeast coast of South Africa, are known to produce high waves
    (typically as currents mix with a variety of ocean swells coming from different
    directions).
  prefs: []
  type: TYPE_NORMAL
- en: Hazard-weighting of paths can be wise when working with optimal travel routes
    and determining which mode of transportation is most cost-effective and convenient.
    Most areas of the world contain open source hazard data and material to determine
    which hazards are present and how likely one is to encounter them. For instance,
    the World Bank provides the **Climate Change Knowledge Portal** (**CCKP**) with
    natural disaster risks during different periods, including downloadable data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know some routing considerations, let’s dive into a simple example,
    including five stores in a localized area of Miami needing produce delivered that
    are all accessible via truck and defined to exclude current construction zones
    in a time of year when the area does not experience flooding or hurricanes. First,
    we’ll need to understand how we can calculate the shortest paths between vertices
    in a network, which has deep roots in graph theory.
  prefs: []
  type: TYPE_NORMAL
- en: Shortest path applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shortest paths between places and sets of places have a long history in
    graph theory. Originally, this problem arose from a question about traversing
    the seven bridges of Königsberg, Germany. In 1736, Leonhard Euler posited that
    a route that crossed each bridge to a region next to one side of a bridge exactly
    once did not exist. Indeed, this is the case. If there is one more region than
    the number of bridges for an odd number of bridges, a trip is possible without
    traversing bridges more than once. Note that the proof of this is beyond the scope
    of this book; if you are interested, you can find many proofs online if you search
    for proofs of the Königsberg bridge problem.
  prefs: []
  type: TYPE_NORMAL
- en: However, problems such as this come up often in the transportation industry
    and **global positioning system** (**GPS**) routing solutions and algorithms that
    calculate shortest paths with or without specific constraints such as the Königsberg
    bridge problem are common in routing problems today. We often want to visit multiple
    locations while traversing the fewest roads, bridges, or obstacles possible, and
    we can formulate this problem much in the way Euler formulated his bridge problem.
    However, we typically have many different possible routes and locations, making
    proof much more difficult given alternative routes that exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`0` or `1` representing the existence of an edge between vertices in the adjacency
    matrix) or weighted (where edges that exist have numbers not limited to `1` designating
    their existence and some property between them). In the context of shortest path
    calculation in geographical data, these weights usually represent distances between
    locations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many paths can exist between vertices. For instance, consider a network with
    seven vertices. Between vertices one and six, many possible paths exist, including
    the one shown in *Figure 4**.6*. However, the shortest path will always exist,
    minimizing the distance (physical or other, depending on how edge weights are
    assigned from a dataset) between any two vertices in the network. When a network
    is not connected, this may be undefined or set to an infinite distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – A network with seven vertices and a path from the first vertex
    to the sixth vertex](img/B21087_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – A network with seven vertices and a path from the first vertex
    to the sixth vertex
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the shortest path between vertices (say, between one and seven in
    our *Figure 4**.6* network) may not be unique. Multiple paths of the same length
    may exist, such as the two shortest paths between vertex one and vertex seven
    (shown in *Figure 4**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A network with multiple shortest paths between a pair of vertices
    (vertex one and vertex seven)](img/B21087_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A network with multiple shortest paths between a pair of vertices
    (vertex one and vertex seven)
  prefs: []
  type: TYPE_NORMAL
- en: 'In an undirected network, all edges between vertices can be considered when
    finding the shortest paths between vertices. As mentioned earlier, if the network
    is not connected, infinite path lengths may exist. For undirected and unweighted
    networks, the shortest paths will traverse the fewest edges (again, with infinite
    values possible if there are no edge paths to connect two vertices). *Figure 4**.8*
    shows a network that is not connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – A disconnected network](img/B21087_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – A disconnected network
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path between vertices eight and nine is simply the edge connecting
    vertex eight to vertex nine. Assuming that this network is not weighted, the shortest
    distance from this path is one. The shortest path between vertices one and six
    is given by the edges connecting vertex six to vertex three and vertex three to
    vertex one. The shortest distance between vertex six and three is, thus, two.
    However, the shortest path between vertex eight and vertex six does not exist
    and would be designated as an infinite distance.
  prefs: []
  type: TYPE_NORMAL
- en: Dijkstra’s algorithm begins at one of the paired vertices and explores the vertices
    to which that vertex is connected. The shortest path between that initial vertex
    and its neighboring vertices is then recorded, minus the initial vertex (as it
    is already in our path set). The next set of vertices connected to the shortest-distance
    neighboring vertex is then explored to find the next shortest path that exists.
    This iterative exploration continues until the other paired vertex is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider how Dijkstra’s algorithm can help us find the shortest route
    between stores. Consider a set of five stores from the same grocery chain in one
    suburb that may need restocking by the parent chain’s supplier. *Table 4.1* gives
    a summary of the distances between these five stores in miles:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Store 1** | **Store 2** | **Store 3** | **Store 4** | **Store 5** |'
  prefs: []
  type: TYPE_TB
- en: '| **Store 1** | `0` | `2` | `2.4` | `3` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| **Store 2** | `2` | `0` | `3.7` | `1.4` | `4.3` |'
  prefs: []
  type: TYPE_TB
- en: '| **Store 3** | `2.4` | `3.7` | `0` | `4.9` | `0.9` |'
  prefs: []
  type: TYPE_TB
- en: '| **Store 4** | `3` | `1.4` | `4.9` | `0` | `5.4` |'
  prefs: []
  type: TYPE_TB
- en: '| **Store 5** | `3` | `4.3` | `0.9` | `5.4` | `0` |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – A table of mile distances between a chain of stores in a suburb
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create this network of stores in `Script 4.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Script 4.1` gives us a network of our five stores with a nice plot summary
    showing distances between stores, as shown in *Figure 4**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – A plot of our five stores and the distances between each of
    them](img/B21087_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – A plot of our five stores and the distances between each of them
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create an adjacency matrix based on our network and find the shortest
    paths between locations by adding to `Script 4.1`. Let’s calculate the shortest
    distances between **store 1** and each other store in our chain’s locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From this calculation, we derive both the shortest distance between `length1`)
    and the shortest routes in general (`path1`). We can see the shortest distances
    between `length1`. The shortest route to **store 2** takes two miles, while the
    shortest route to **store 4** or **store 5** takes three miles. **store 3** is
    2.4 miles from **store 1**.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major drawbacks of using Dijkstra’s algorithm is that it is a blind
    search algorithm that needs to wander through all possible options to find the
    shortest paths between each possible vertex pair along the path. That takes a
    long time for large networks, and in practice, a modification of Dijkstra’s algorithm
    is needed to reduce search time.
  prefs: []
  type: TYPE_NORMAL
- en: The **A* algorithm** (pronounced A-star) modifies Dijkstra’s algorithm by using
    a heuristic function to guide the search (as opposed to visiting each vertex as
    in Dijkstra’s algorithm). Heuristic functions are common in search tasks, as they
    expedite the process and can modify the search of an algorithm that has failed.
    The heuristic used in the A* algorithm combines the cost of the path from the
    starting vertex with an estimate of remaining costs to prioritize vertices closest
    to the final vertex. One of the main uses for the A* algorithm is to give directions
    to a user of GPS to find optimal routes to a destination.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the A* algorithm efficiently finds shortest path candidates, particularly
    in large or dense networks. However, its performance depends on the heuristic
    used to estimate the cost of reaching a given destination by traversing the network.
    While Dijkstra’s algorithm is guaranteed to find the shortest path, the A* algorithm
    is not guaranteed to find the shortest path. On large, dense networks, however,
    it is not feasible to run Dijkstra’s algorithm, so A* must be used.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* summarizes the differences between Dijkstra’s algorithm and the
    A* algorithm to guide you on how and when to use each algorithm for shortest path
    computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shortest** **path algorithm** | **Type** **of search** | **Result guarantees**
    | **Computational speed** |'
  prefs: []
  type: TYPE_TB
- en: '| Dijkstra’s algorithm | Blind search of all vertices | Always finds the shortest
    path | Slow enough to limit use on dense or large networks |'
  prefs: []
  type: TYPE_TB
- en: '| A* algorithm | Heuristic function guiding search | No guarantees to finding
    the shortest path | Fast enough for most problems |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – Difference between Dijkstra’s algorithm and the A* algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a different store network, one in which routes do not exist
    from each store to every other store by creating a secondary store network in
    NetworkX through `Script 4.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.10* shows this new store network, with some stores directly connected
    to each other and others requiring a route past other stores. Note that **store
    5** is the furthest store from the other stores, connected to **store 4** but
    no other stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – A store network where not every store is connected to another
    store with a passable route](img/B21087_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – A store network where not every store is connected to another
    store with a passable route
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a route from **store 2** to **store 5**. Several possible routes
    exist (**store 2** to **store 3** to **store 4** to **store 5**, **store 2** to
    **store 1** to **store 4** to **store 5**, and **store 2** to **store 4** to **store
    5**). The shortest possible route may not have the fewest stops along the way
    if all distances are relatively short. In this case, we can simply look at our
    network and see that **store 2** to **store 4** to **store 5** is the shortest
    route. However, in very large networks, this would take a lot of time and likely
    involve much longer paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the A* algorithm in NetworkX to find our shortest route by adding
    to `Script 4.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the A* algorithm finds the shortest path from **store 2** to **store
    4** to **store 5**. Again, with a much larger network, we’d need an algorithm
    such as the A* algorithm to find the shortest route quickly. Even a network of
    20 stores with several connections among stores would be problematic to compute
    by hand from a visualization of the network. We’ve seen how algorithms can help
    us find the shortest paths between two specific destinations. Let’s now take a
    look at the shortest paths that include stops at several different vertices. This
    type of solution is critical to many optimal routing problems and builds on our
    problem of finding the shortest paths between two different destinations.
  prefs: []
  type: TYPE_NORMAL
- en: Traveling salesman problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A natural extension of shortest paths is the shortest possible route that stops
    at each location. For instance, consider a produce truck that needs to stock all
    five of our stores. The shortest route that will stop at each of our five stores
    saves time and fuel for the driver and allows produce to arrive at each store
    in the shortest time frame.
  prefs: []
  type: TYPE_NORMAL
- en: The **traveling salesman problem** seeks to find the shortest route that stops
    at each location or the shortest route that stops at an arbitrary number of possible
    locations. In graph theory, this problem (and Euler’s problem) is related to cycles
    of a graph, which define a non-empty path that starts and ends at the same vertex.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, algorithms are needed to find the shortest path, and for large
    problems, computational time and convergence to a solution can restrict the usage
    of most algorithms. NetworkX provides the **Christofides algorithm** as a solver,
    which finds the shortest spanning tree (network structured like a tree with no
    cycles) and then matches the vertices of the tree to find minimum distances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find a solution to the traveling salesman problem for our original five-store
    network with `Script 4.3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This path starts at **store 1**, proceeds to **store 3** (2.4 miles), then **store
    5** (0.9 miles), then **store 4** (5.4 miles), then **store 2** (1.4 miles), and
    finally back to **store 1** (2 miles).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works on our secondary store network by adding to `Script
    4.3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to visit some stores more than once to visit each store.
    The solution our algorithm gives us starts at **store 1**, then **store 4** (3
    miles), then **store 5** (5.4 miles), then **store 4** again (5.4 miles), then
    **store 2** (1.4 miles), then **store 3** (3.7 miles), then back to **store 2**
    (3.7 miles), and finally back to **store 1** (2 miles). This is a much longer
    route than we need in our original store network (12.1 miles versus 22.6 miles),
    owing to non-direct paths between many of the stores.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed a solution to the traveling salesman problem, where
    we have a set of vertices that we need to visit and want to find the most efficient
    way to visit all of them. In the next section, we’ll switch from examining shortest
    path problems and looking at partitioning vertices to maximize travel between
    vertices in each set (such as maximizing rush-hour traffic flow while shutting
    down a few routes for maintenance).
  prefs: []
  type: TYPE_NORMAL
- en: Max-flow min-cut algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from shortest paths and routes, transportation logistics sometimes involve
    city planning to plan, say, roadwork with the least interruption to traffic patterns
    or supply chains. The goal is to maximize traffic flow through points of interest
    (say, major intersections or buildings with high volumes of visitors/workers each
    day) while minimizing which routes are cut off.
  prefs: []
  type: TYPE_NORMAL
- en: In graph theory, the max-flow min-cut algorithm seeks to partition a network
    to maximize the flow of information through a social network, the flow of traffic
    in a transportation network, or the flow of material through an electrical or
    water pipeline network, among others. Typically, there’s a starting vertex and
    an ending vertex with respect to flow, though it is possible to run the algorithm
    through all possible combinations and aggregate results to maximize flow for the
    entire network.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the example of traffic flow from a dense residential area outside
    of a city to the downtown area, where most people work. We’d like to plan out
    work on replacing stoplights at key intersections throughout the city, which are
    divided by canals. Some roads in the city have more lanes than others, allowing
    for a higher volume of traffic to utilize those routes. We’d like to minimize
    disruption to commuters during the workday.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a network of this situation, with the residential area designated
    as vertex `"a"` and the downtown area as vertex `"g"`. We’ll designate the level
    of traffic the route can handle with the capacity parameter. Let’s build an example
    network in NetworkX with `Script 4.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This script should produce a network that looks like the one in *Figure 4**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – A plot of the traffic network](img/B21087_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – A plot of the traffic network
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our network, let’s apply our max-flow min-cut algorithm and
    find where we can replace our first traffic light by adding to `Script 4.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our partition suggests that our best option cuts the connection between intersections
    `"c"` and `"d"`. Some commuters may be disadvantaged, but this preserves movement
    for the largest number of commuters overall.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored transportation problems and routing problems, which
    come up often in real-world industries. We found the shortest paths between stores
    with the Dijkstra and A* algorithms on two example store networks. We then considered
    the traveling salesman problem for optimal route planning on our two store networks
    to see how connectivity impacts route length. Finally, we considered optimal cuts
    to maximize flow on a small city network. In the next chapter, we’ll tackle clustering
    on networks by examining ecological data.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chen, L., Kyng, R., Liu, Y. P., Peng, R., Gutenberg, M. P., & Sachdeva, S. (2022,
    October). Maximum flow and minimum-cost flow in almost linear time. *In 2022 IEEE
    63rd Annual Symposium on Foundations of Computer Science (FOCS) (pp.* *612-623).
    IEEE.*
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, D. B. (1973). A note on Dijkstra’s shortest path algorithm. *Journal
    of the ACM (JACM),* *20(3), 385-388.*
  prefs: []
  type: TYPE_NORMAL
- en: Kang, N. K., Son, H. J., & Lee, S. H. (2018). Modified A-star algorithm for
    modular plant land transportation. *Journal of Mechanical Science and Technology,*
    *32, 5563-5571.*
  prefs: []
  type: TYPE_NORMAL
- en: Little, J. D., Murty, K. G., Sweeney, D. W., & Karel, C. (1963). An algorithm
    for the traveling salesman problem. *Operations research,* *11(6), 972-989.*
  prefs: []
  type: TYPE_NORMAL
- en: Liu, S., Münch, F., & Peyerimhoff, N. (2018). Bakry–Émery curvature and diameter
    bounds on graphs. *Calculus of Variations and Partial Differential Equations,*
    *57, 1-9.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Rondinelli, D., & Berry, M. (2000). Multimodal transportation, logistics, and
    the environment: managing interactions in a global economy. *European Management
    Journal,* *18(4), 398-410.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rosenthal, W., & Lehner, S. (2008). *Rogue waves: Results of the* *MaxWave
    project.*'
  prefs: []
  type: TYPE_NORMAL
