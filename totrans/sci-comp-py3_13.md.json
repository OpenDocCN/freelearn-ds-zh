["```py\ndef bisect(f, a, b, tol=1.e-8):\n    \"\"\"\n    Implementation of the bisection algorithm \n    f real valued function\n    a,b interval boundaries (float) with the property \n    f(a) * f(b) <= 0\n    tol tolerance (float)\n    \"\"\"\n    if f(a) * f(b)> 0:\n        raise ValueError(\"Incorrect initial interval [a, b]\") \n    for i in range(100):\n        c = (a + b) / 2.\n        if f(a) * f(c) <= 0:\n            b = c\n        else:\n            a = c\n        if abs(a - b) < tol:\n            return (a + b) / 2\n    raise Exception(\n          'No root found within the given tolerance {}'.format(tol))\n```", "```py\ndef test_identity():\n    result = bisect(lambda x: x, -1., 1.) \n    expected = 0.\n    assert allclose(result, expected),'expected zero not found'\n\ntest_identity()\n```", "```py\ndef test_badinput():\n    try:\n        bisect(lambda x: x,0.5,1)\n    except ValueError:\n        pass\n    else:\n        raise AssertionError()\n\ntest_badinput()\n```", "```py\ndef test_equal_boundaries():\n    result = bisect(lambda x: x, 0., 0.)\n    expected = 0.\n    assert allclose(result, expected), \\\n                   'test equal interval bounds failed'\n\ndef test_reverse_boundaries():\n    result = bisect(lambda x: x, 1., -1.)\n    expected = 0.\n    assert allclose(result, expected),\\\n                 'test reverse interval bounds failed'\n\ntest_equal_boundaries()\ntest_reverse_boundaries()\n```", "```py\nfrom bisection import bisect\nimport unittest\n\nclass TestIdentity(unittest.TestCase):\n    def test(self):\n        result = bisect(lambda x: x, -1.2, 1.,tol=1.e-8)\n        expected = 0.\n        self.assertAlmostEqual(result, expected)\n\nif __name__=='__main__':\n    unittest.main()\n```", "```py\nRan 1 test in 0.002s\nOK\n\n```", "```py\nF\n======================================================================\nFAIL: test (__main__.TestIdentity)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"<ipython-input-11-e44778304d6f>\", line 5, in test\n    self.assertAlmostEqual(result, expected)\nAssertionError: 0.00017089843750002018 != 0.0 within 7 places\n----------------------------------------------------------------------\nRan 1 test in 0.004s\nFAILED (failures=1)\n\n```", "```py\nimport unittest\nfrom bisection import bisect\n\nclass TestIdentity(unittest.TestCase):\n    def identity_fcn(self,x):\n        return x\n    def test_functionality(self):\n        result = bisect(self.identity_fcn, -1.2, 1.,tol=1.e-8)\n        expected = 0.\n        self.assertAlmostEqual(result, expected)\n    def test_reverse_boundaries(self):\n        result = bisect(self.identity_fcn, 1., -1.)\n        expected = 0.\n        self.assertAlmostEqual(result, expected)\n    def test_exceeded_tolerance(self):\n        tol=1.e-80\n        self.assertRaises(Exception, bisect, self.identity_fcn,\n                                               -1.2, 1.,tol)\nif __name__=='__main__':\n    unittest.main()\n```", "```py\nclass NotFoundError(Exception):\n  pass\n\ndef find_string(file, string):\n    for i,lines in enumerate(file.readlines()):\n        if string in lines:\n            return i\n    raise NotFoundError(\n         'String {} not found in File {}'.format(string,file.name))\n```", "```py\nimport unittest\nimport os # used for, for example, deleting files\n\nfrom find_in_file import find_string, NotFoundError\n\nclass TestFindInFile(unittest.TestCase):\n    def setUp(self):\n        file = open('test_file.txt', 'w')\n        file.write('aha')\n        file.close()\n        self.file = open('test_file.txt', 'r')\n    def tearDown(self):\n        self.file.close()\n        os.remove(self.file.name)\n    def test_exists(self):\n        line_no=find_string(self.file, 'aha')\n        self.assertEqual(line_no, 0)\n    def test_not_exists(self):\n        self.assertRaises(NotFoundError, find_string,\n                                              self.file, 'bha')\n\nif __name__=='__main__':\n    unittest.main()\n```", "```py\nclass Tests(unittest.TestCase):\n    def checkifzero(self,fcn_with_zero,interval):\n        result = bisect(fcn_with_zero,*interval,tol=1.e-8)\n        function_value=fcn_with_zero(result)\n        expected=0.\n        self.assertAlmostEqual(function_value, expected)\n```", "```py\ntest_data=[\n           {'name':'identity', 'function':lambda x: x,\n                                     'interval' : [-1.2, 1.]},\n           {'name':'parabola', 'function':lambda x: x**2-1,\n                                        'interval' :[0, 10.]},\n           {'name':'cubic', 'function':lambda x: x**3-2*x**2,\n                                       'interval':[0.1, 5.]},\n               ] \ndef make_test_function(dic):\n        return lambda self :\\\n                   self.checkifzero(dic['function'],dic['interval'])\nfor data in test_data:\n    setattr(Tests, \"test_{name}\".format(name=data['name']),\n                                           make_test_function(data))\nif __name__=='__main__':\n  unittest.main()\n```", "```py\nself.assertTrue(allclose(computed, expected))\n```", "```py\nimport numpy.testing\n```", "```py\nimport scipy.linalg as sl\nA=rand(10,10)\n[Q,R]=sl.qr(A)\n```", "```py\nimport numpy.testing as npt \nnpt.assert_allclose(\n               dot(Q.T,self.Q),identity(Q.shape[0]),atol=1.e-12)\n```", "```py\nimport numpy.testing as npt\nnpt.assert_allclose(dot(Q,R),A))\n```", "```py\nimport unittest\nimport numpy.testing as npt\nfrom scipy.linalg import qr\nfrom scipy import *\n\nclass TestQR(unittest.TestCase):\n    def setUp(self):\n        self.A=rand(10,10)\n        [self.Q,self.R]=qr(self.A)\n    def test_orthogonal(self):\n        npt.assert_allclose(\n            dot(self.Q.T,self.Q),identity(self.Q.shape[0]),\n                                                        atol=1.e-12)\n    def test_sanity(self):\n            npt.assert_allclose(dot(self.Q,self.R),self.A)\n\nif __name__=='__main__':\n    unittest.main()\n```", "```py\ndef bisect(f,a,b,n=100):\n  ...\n  for iteration in range(n):\n    ...\n  return a,b\n```", "```py\ndef test_midpoint(self):\n  a,b = bisect(identity,-2.,1.,1)\n  self.assertAlmostEqual(a,-0.5)\n  self.assertAlmostEqual(b,1.)\n```", "```py\ntest_case = TestIdentity(methodName='test_functionality')\n```", "```py\ntest_case.debug()\n```", "```py\npython -m unittest discover\n\n```", "```py\npython -m unittest discover -s '.' -p 'Test*.py'\n\n```", "```py\nA=zeros((1000,1000))\nA[53,67]=10\n\ndef find_elements_1(A):\n    b = []\n    n, m = A.shape\n    for i in range(n):\n        for j in range(m):\n            if abs(A[i, j]) > 1.e-10:\n                b.append(A[i, j])\n    return b\n\ndef find_elements_2(A):\n    return [a for a in A.reshape((-1, )) if abs(a) > 1.e-10]\n\ndef find_elements_3(A):\n    return [a for a in A.flatten() if abs(a) > 1.e-10]\n\ndef find_elements_4(A):\n    return A[where(0.0 != A)]\n```", "```py\nIn [50]: %timeit -n 50 -r 3 find_elements_1(A)\n50 loops, best of 3: 585 ms per loop\n\nIn [51]: %timeit -n 50 -r 3 find_elements_2(A)\n50 loops, best of 3: 514 ms per loop\n\nIn [52]: %timeit -n 50 -r 3 find_elements_3(A)\n50 loops, best of 3: 519 ms per loop\n\nIn [53]: %timeit -n 50 -r 3 find_elements_4(A)\n50 loops, best of 3: 7.29 ms per loop\n```", "```py\nimport timeit\nsetup_statements=\"\"\"\nfrom scipy import zeros\nfrom numpy import where\nA=zeros((1000,1000))\nA[57,63]=10.\n\ndef find_elements_1(A):\n    b = []\n    n, m = A.shape\n    for i in range(n):\n        for j in range(m):\n            if abs(A[i, j]) > 1.e-10:\n               b.append(A[i, j])\n    return b\n\ndef find_elements_2(A):\n    return [a for a in A.reshape((-1,)) if abs(a) > 1.e-10]\n\ndef find_elements_3(A):\n    return [a for a in A.flatten() if abs(a) > 1.e-10]\n\ndef find_elements_4(A):\n    return A[where( 0.0 != A)]\n\"\"\"\nexperiment_1 = timeit.Timer(stmt = 'find_elements_1(A)',\n                            setup = setup_statements)\nexperiment_2 = timeit.Timer(stmt = 'find_elements_2(A)',\n                            setup = setup_statements)\nexperiment_3 = timeit.Timer(stmt = 'find_elements_3(A)',\n                            setup = setup_statements)\nexperiment_4 = timeit.Timer(stmt = 'find_elements_4(A)',\n                            setup = setup_statements)\n```", "```py\nt1 = experiment_1.repeat(3,5) \nt2 = experiment_2.repeat(3,5) \nt3 = experiment_3.repeat(3,5) \nt4 = experiment_4.repeat(3,5) \n# Results per loop in ms\nmin(t1)*1000/5 # 615 ms\nmin(t2)*1000/5 # 543 ms\nmin(t3)*1000/5 # 546 ms\nmin(t4)*1000/5 # 7.26 ms\n```", "```py\nimport time\nclass Timer:\n    def __enter__(self):\n        self.start = time.time()\n        # return self\n    def __exit__(self, ty, val, tb):\n        end = time.time()\n        self.elapsed=end-self.start\n        print('Time elapsed {} seconds'.format(self.elapsed))\n        return False\n```", "```py\nwith Timer():\n  find_elements_1(A)\n\n```", "```py\nwith Timer() as t1:\n    find_elements_1(A)\nt1.elapsed # contains the result\n```", "```py\nv = (u[:-2] + u[1:-1] + u[2:]) / 3\n```", "```py\nv = array([(u[i] + u[i + 1] + u[i + 2]) / 3\n  for i in range(len(u)-3)])\n```"]