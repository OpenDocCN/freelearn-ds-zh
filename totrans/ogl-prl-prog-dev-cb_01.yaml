- en: Chapter 1. Using OpenCL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 使用 OpenCL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Querying OpenCL platforms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 OpenCL 平台
- en: Querying OpenCL devices on your platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询您平台上的 OpenCL 设备
- en: Querying for OpenCL device extensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 OpenCL 设备扩展
- en: Querying OpenCL contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 OpenCL 上下文
- en: Querying an OpenCL program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询 OpenCL 程序
- en: Creating OpenCL kernels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 OpenCL 内核
- en: Creating command queues and enqueuing OpenCL kernels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建命令队列并将 OpenCL 内核入队
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Let's start the journey by looking back into the history of computing and why
    OpenCL is important from the respect that it aims to unify the software programming
    model for heterogeneous devices. The goal of OpenCL is to develop a royalty-free
    standard for cross-platform, parallel programming of modern processors found in
    personal computers, servers, and handheld/embedded devices. This effort is taken
    by "The Khronos Group" along with the participation of companies such as Intel,
    ARM, AMD, NVIDIA, QUALCOMM, Apple, and many others. OpenCL allows the software
    to be written once and then executed on the devices that support it. In this way
    it is akin to Java, this has benefits because software development on these devices
    now has a uniform approach, and OpenCL does this by exposing the hardware via
    various data structures, and these structures interact with the hardware via **Application
    Programmable Interfaces** (**APIs**). Today, OpenCL supports CPUs that includes
    x86s, ARM and PowerPC and GPUs by AMD, Intel, and NVIDIA.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下计算的历史，并从它旨在统一异构设备的软件编程模型的角度来看，为什么 OpenCL 之所以重要。OpenCL 的目标是开发一个免版税标准，用于跨平台的现代处理器的并行编程，这些处理器在个人电脑、服务器和手持/嵌入式设备中都很常见。这项努力由“Khronos
    Group”发起，并得到了英特尔、ARM、AMD、NVIDIA、QUALCOMM、苹果和其他许多公司的参与。OpenCL 允许软件一次编写，然后在其支持的设备上执行。这种方式类似于
    Java，这有好处，因为现在这些设备上的软件开发有了统一的方法，OpenCL 通过暴露各种数据结构来实现这一点，这些结构通过 **应用程序可编程接口**（**APIs**）与硬件交互。今天，OpenCL
    支持包括 x86s、ARM 和 PowerPC 的 CPU，以及 AMD、Intel 和 NVIDIA 的 GPU。
- en: Developers can definitely appreciate the fact that we need to develop software
    that is cross-platform compatible, since it allows the developers to develop an
    application on whatever platform they are comfortable with, without mentioning
    that it provides a coherent model in which we can express our thoughts into a
    program that can be executed on any device that supports this standard. However,
    what cross-platform compatibility also means is the fact that heterogeneous environments
    exists, and for quite some time, developers have to learn and grapple with the
    issues that arise when writing software for those devices ranging from execution
    model to memory systems. Another task that commonly arose from developing software
    on those heterogeneous devices is that developers were expected to express and
    extract parallelism from them as well. Before OpenCL, we know that various programming
    languages and their philosophies were invented to handle the aspect of expressing
    parallelism (for example, Fortran, OpenMP, MPI, VHDL, Verilog, Cilk, Intel TBB,
    Unified parallel C, Java among others) on the device they executed on. But these
    tools were designed for the homogeneous environments, even though a developer
    may think that it's to his/her advantage, since it adds considerable expertise
    to their resume. Taking a step back and looking at it again reveals that is there
    is no unified approach to express parallelism in heterogeneous environments. We
    need not mention the amount of time developers need to be productive in these
    technologies, since parallel decomposition is normally an involved process as
    it's largely hardware dependent. To add salt to the wound, many developers only
    have to deal with homogeneous computing environments, but in the past few years
    the demand for heterogeneous computing environments grew.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者肯定能理解我们需要开发跨平台兼容的软件这一事实，因为它允许开发者在他们感到舒适的任何平台上开发应用程序，更不用说它提供了一个连贯的模型，我们可以将我们的想法表达成可以在支持此标准的任何设备上执行的程序。然而，跨平台兼容性也意味着异构环境的存在，并且相当长一段时间以来，开发者不得不学习和应对为这些设备编写软件时出现的问题，这些问题从执行模型到内存系统都有涉及。从在那些异构设备上开发软件中通常出现的另一个任务是，开发者还被期望从它们中表达和提取并行性。在OpenCL出现之前，我们知道为了处理在它们执行的设备上表达并行性的方面（例如，Fortran、OpenMP、MPI、VHDL、Verilog、Cilk、Intel
    TBB、统一并行C、Java等），已经发明了各种编程语言及其哲学。但这些工具是为同质环境设计的，尽管开发者可能认为这对他们有利，因为它为他们简历增添了相当多的专业知识。退一步再看，我们发现没有统一的方法来在异构环境中表达并行性。我们不必提及开发者在这些技术中需要多少时间才能变得高效，因为并行分解通常是一个复杂的过程，因为它在很大程度上依赖于硬件。更糟糕的是，许多开发者只需要处理同质计算环境，但过去几年，对异构计算环境的需求增长了。
- en: The demand for heterogeneous devices grew partially due to the need for high
    performance and highly reactive systems, and with the "power wall" at play, one
    possible way to improve more performance was to add specialized processing units
    in the hope of extracting every ounce of parallelism from them, since that's the
    only way to reach power efficiency. The primary motivation for this shift to hybrid
    computing could be traced to the research headed entitled *Optimizing power using
    Transformations* by *Anantha P. Chandrakasan*. It brought out a conclusion that
    basically says that many-core chips (which run at a slightly lower frequency than
    a contemporary CPU) are actually more power-efficient. The problem with heterogeneous
    computing without a unified development methodology, for example, OpenCL, is that
    developers need to grasp several types of ISA and with that the various levels
    of parallelism and their memory systems are possible. CUDA, the GPGPU computing
    toolkit, developed by NVIDIA deserves a mention not only because of the remarkable
    similarity it has with OpenCL, but also because the toolkit has a wide adoption
    in academia as well as industry. Unfortunately CUDA can only drive NVIDIA's GPUs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对异构设备的需求部分是由于对高性能和高度反应性系统的需求，而“功耗墙”的存在使得提高更多性能的一种可能方式是在其中添加专门的处理器单元，以期从中提取每一盎司的并行性，因为这是达到能效的唯一途径。这种向混合计算转变的主要动机可以追溯到名为*Optimizing
    power using Transformations*的研究，该研究由*Anantha P. Chandrakasan*领导。它得出了一个基本结论，即多核芯片（其运行频率略低于当代CPU）实际上更节能。没有统一开发方法（例如OpenCL）的异构计算的问题在于，开发者需要掌握几种类型的ISA，以及与之相关的各种并行级别及其内存系统。NVIDIA开发的CUDA
    GPGPU计算工具包值得提及，不仅因为它与OpenCL有显著的相似性，而且还因为该工具包在学术界和工业界都有广泛的应用。不幸的是，CUDA只能驱动NVIDIA的GPU。
- en: The ability to extract parallelism from an environment that's heterogeneous
    is an important one simply because the computation should be parallel, otherwise
    it would defeat the entire purpose of OpenCL. Fortunately, major processor companies
    are part of the consortium led by The Khronos Group and actively realizing the
    standard through those organizations. Unfortunately the story doesn't end there,
    but the good thing is that we, developers, realized that a need to understand
    parallelism and how it works in both homogeneous and heterogeneous environments.
    OpenCL was designed with the intention to express parallelism in a heterogeneous
    environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从异构环境中提取并行性的能力非常重要，因为计算应该是并行的，否则就会违背OpenCL的整个目的。幸运的是，主要的处理器公司都是Khronos集团领导的联盟的一部分，并且通过这些组织积极实现这一标准。不幸的是，故事还没有结束，但好事是，我们，开发者，意识到有必要理解并行性以及它在同构和异构环境中的工作方式。OpenCL的设计初衷就是为了在异构环境中表达并行性。
- en: For a long time, developers have largely ignored the fact that their software
    needs to take advantage of the multi-core machines available to them and continued
    to develop their software in a single-threaded environment, but that is changing
    (as discussed previously). In the many-core world, developers need to grapple
    with the concept of concurrency, and the advantage of concurrency is that when
    used effectively, it maximizes the utilization of resources by providing progress
    to others while some are stalled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，开发者们很大程度上忽视了他们的软件需要利用他们可用的多核机器的事实，并且继续在单线程环境中开发他们的软件，但这种情况正在改变（如前所述）。在多核世界中，开发者需要处理并发性的概念，而并发的优势在于，当有效使用时，它通过为其他进程提供进展而使一些进程停滞，从而最大化资源利用率。
- en: 'When software is executed concurrently with multiple processing elements so
    that threads can run simultaneously, we have parallel computation. The challenge
    that the developer has is to discover that concurrency and realize it. And in
    OpenCL, we focus on two parallel programming models: task parallelism and data
    parallelism.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件与多个处理元素同时执行，使得线程可以同时运行时，我们称之为并行计算。开发者面临的挑战是发现这种并发性并实现它。在OpenCL中，我们专注于两种并行编程模型：任务并行和数据并行。
- en: Task parallelism means that developers can create and manipulate concurrent
    tasks. When developers are developing a solution for OpenCL, they would need to
    decompose a problem into different tasks and some of those tasks can be run concurrently,
    and it is these tasks that get mapped to **processing elements** (**PEs**) of
    a parallel environment for execution. On the other side of the story, there are
    tasks that cannot be run concurrently and even possibly interdependent. An additional
    complexity is also the fact that data can be shared between tasks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行意味着开发者可以创建和操作并发任务。当开发者为OpenCL开发解决方案时，他们需要将问题分解成不同的任务，其中一些任务可以并发运行，并且正是这些任务被映射到并行环境的**处理元素**（**PEs**）上以执行。另一方面，有些任务不能并发运行，甚至可能是相互依赖的。另一个复杂性是数据可以在任务之间共享。
- en: When attempting to realize data parallelism, the developer needs to readjust
    the way they think about data and how they can be read and updated concurrently.
    A common problem found in parallel computation would be to compute the sum of
    all the elements given in an arbitrary array of values, while storing the intermediary
    summed value and one possible way to do this is illustrated in the following diagram
    and the operator being applied there, that is, ![Introduction](img/4520OT_01_07.jpg)
    is any binary associative operator. Conceptually, the developer could use a task
    to perform the addition of two elements of that input to derive the summed value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试实现数据并行时，开发者需要调整他们对数据的思考方式以及它们如何可以并发读取和更新。在并行计算中常见的一个问题是计算给定任意值数组的所有元素的总和，而存储中间求和值和一种可能的实现方式如图所示，其中应用的运算符，即![简介](img/4520OT_01_07.jpg)，是任何二元结合运算符。从概念上讲，开发者可以使用一个任务来执行输入中两个元素的加法以得到求和值。
- en: '![Introduction](img/4520OT_01_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/4520OT_01_01.jpg)'
- en: Whether the developer chooses to embody task/data parallelism is dependent on
    the problem, and an example where task parallelism would make sense will be by
    traversing a graph. And regardless of which model the developer is more inclined
    with, they come with their own sets of problems when you start to map the program
    to the hardware via OpenCL. And before the advent of OpenCL, the developer needs
    to develop a module that will execute on the desired device and communication,
    and I/O with the driver program. An example example of this would be a graphics
    rendering program where the CPU initializes the data and sets everything up, before
    offloading the rendering to the GPU. OpenCL was designed to take advantage of
    all devices detected so that resource utilization is maximized, and hence in this
    respect it differs from the "traditional" way of software development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者是否选择体现任务/数据并行取决于问题，一个任务并行有意义的例子是通过遍历图。无论开发者更倾向于哪种模型，当他们开始通过OpenCL将程序映射到硬件时，都会遇到自己的一套问题。在OpenCL出现之前，开发者需要开发一个将在所需设备上执行的模块，并与驱动程序进行通信和I/O。一个例子是图形渲染程序，其中CPU初始化数据并设置一切，然后在将渲染任务卸载到GPU之前。OpenCL被设计用来利用所有检测到的设备，从而最大化资源利用率，因此在这方面它与“传统”的软件开发方式不同。
- en: 'Now that we have established a good understanding of OpenCL, we should spend
    some time understanding how a developer can learn it. And not to fret, because
    every project you embark with, OpenCL will need you to understand the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对OpenCL有了良好的理解，我们应该花些时间了解开发者如何学习它。而且不用担心，因为你在开始每一个项目时，OpenCL都会要求你理解以下内容：
- en: Discover the makeup of the heterogeneous system you are developing for
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现你正在为开发的异构系统的组成
- en: Understand the properties of those devices by probing it
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过探测来了解那些设备的属性
- en: Start the parallel program decomposition using either or all of task parallelism
    or data parallelism, by expressing them into instructions also known as kernels
    that will run on the platform
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务并行或数据并行中的任何一个或所有来启动并行程序分解，通过将它们表达为在平台上运行的指令，也称为内核
- en: Set up data structures for the computation
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置计算所需的数据结构
- en: Manipulate memory objects for the computation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作计算所需的内存对象
- en: Execute the kernels in the order that's desired on the proper device
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的设备上按所需顺序执行内核
- en: Collate the results and verify for correctness
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总结果并验证其正确性
- en: 'Next, we need to solidify the preceding points by taking a deeper look into
    the various components of OpenCL. The following components collectively make up
    the OpenCL architecture:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过更深入地研究OpenCL的各个组成部分来巩固前面的观点。以下组件共同构成了OpenCL架构：
- en: '**Platform Model**: A platform is actually a host that is connected to one
    or more OpenCL devices. Each device comprises possibly multiple **compute units**
    (**CUs**) which can be decomposed into one or possibly multiple processing elements,
    and it is on the processing elements where computation will run.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台模型**：平台实际上是一个连接到一个或多个OpenCL设备的宿主。每个设备可能包含多个**计算单元**（**CUs**），这些单元可以分解为一个或多个处理元素，计算将在处理元素上运行。'
- en: '**Execution Model**: Execution of an OpenCL program is such that the host program
    would execute on the host, and it is the host program which sends kernels to execute
    on one or more OpenCL devices on that platform.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行模型**：OpenCL程序的执行是这样的，宿主程序将在宿主上执行，并且是宿主程序将内核发送到该平台上的一个或多个OpenCL设备上执行。'
- en: When a kernel is submitted for execution, an index space is defined such that
    a work item is instantiated to execute each point in that space. A work item would
    be identified by its global ID and it executes the same code as expressed in the
    kernel. Work items are grouped into work groups and each work group is given an
    ID commonly known as its work group ID, and it is the work group's work items
    that get executed concurrently on the PEs of a single CU.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当内核提交执行时，定义了一个索引空间，以便为该空间中的每个点实例化一个工作项。工作项将通过其全局ID来识别，并执行内核中表达的同一段代码。工作项被分组到工作组中，每个工作组都有一个ID，通常称为其工作组ID，并且是工作组的工作项在单个CU的PE上并发执行。
- en: That index space we mentioned earlier is known as NDRange describing an N-dimensional
    space, where N can range from one to three. Each work item has a global ID and
    a local ID when grouped into work groups, that is distinct from the other and
    is derived from NDRange. The same can be said about work group IDs. Let's use
    a simple example to illustrate how they work.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们之前提到的索引空间被称为NDRange，它描述了一个N维空间，其中N的范围可以从一到三。当工作项分组到工作组中时，每个工作项都有一个全局ID和一个局部ID，这是与其他工作项不同的，并且是从NDRange派生出来的。工作组ID也是如此。让我们用一个简单的例子来说明它们是如何工作的。
- en: 'Given two arrays, A and B, of 1024 elements each, we would like to perform
    the computation of vector multiplication also known as dot product, where each
    element of A would be multiplied by the corresponding element in B. The kernel
    code would look something as follows:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定两个各有1024个元素的数组A和B，我们想要执行向量乘法，也称为点积，其中A的每个元素将与B中相应的元素相乘。内核代码看起来可能如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this scenario, let's assume we have 1024 processing elements and we would
    assign one work item to perform exactly one multiplication, and in this case our
    work group ID would be zero (since there's only one group) and work items IDs
    would range from {0 … 1023}. Recall what we discussed earlier, that it is the
    work group's work items that can executed on the PEs. Hence reflecting back, this
    would not be a good way of utilizing the device.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个场景中，让我们假设我们有1024个处理元素，我们将分配一个工作项来执行精确的一次乘法，在这种情况下，我们的工作组ID将是零（因为只有一个组）并且工作项ID的范围从{0
    … 1023}。回想一下我们之前讨论的内容，是工作组的工作项可以在PE上执行。因此，回顾一下，这不是利用设备的好方法。
- en: 'In this same scenario, let''s ditch the former assumption and go with this:
    we still have 1024 elements but we group four work items into a group, hence we
    would have 256 work groups with each work group having an ID ranging from {0 …
    255}, but it is noticed that the work item''s global ID still would range from
    {0 … 1023} simply because we have not increased the number of elements to be processed.
    This manner of grouping work items into their work groups is to achieve scalability
    in these devices, since it increases execution efficiency by ensuring all PEs
    have something to work on.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个相同的场景中，让我们放弃之前的假设，采用这个：我们仍然有1024个元素，但我们把四个工作项分成一组，因此我们将有256个工作组，每个工作组的ID范围从{0
    … 255}，但需要注意的是，工作项的全局ID仍然会从{0 … 1023}的范围，仅仅因为我们没有增加要处理元素的数量。这种将工作项分组到工作组的方式是为了在这些设备中实现可伸缩性，因为它通过确保所有PE都有工作可做来提高执行效率。
- en: The NDRange can be conceptually mapped into an N-dimensional grid and the following
    diagram illustrates how a 2DRange works, where WG-X denotes the length in rows
    for a particular work group and WG-Y denotes the length in columns for a work
    group, and how work items are grouped including their respective IDs in a work
    group.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: NDRange可以从概念上映射到一个N维网格，以下图表说明了2DRange的工作原理，其中WG-X表示特定工作组的行长度，WG-Y表示工作组的列长度，以及工作项是如何分组，包括它们在工作组中的相应ID。
- en: '![Introduction](img/4520OT_01_02.jpg)'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![简介](img/4520OT_01_02.jpg)'
- en: 'Before the execution of the kernels on the device(s), the host program plays
    an important role and that is to establish context with the underlying devices
    and laying down the order of execution of the tasks. The host program does the
    context creation by establishing the existence (creating if necessary) of the
    following:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在内核在设备（们）上执行之前，主程序扮演着重要的角色，那就是与底层设备建立上下文并安排任务的执行顺序。主程序通过建立以下内容的实体来创建上下文（如果需要的话）：
- en: All devices to be used by the host program
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主程序将要使用的所有设备
- en: The OpenCL kernels, that is, functions and their abstractions that will run
    on those devices
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCL内核，即将在这些设备上运行的函数及其抽象
- en: The memory objects that encapsulated the data to be used / shared by the OpenCL
    kernels.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装了OpenCL内核将要使用/共享的数据的内存对象。
- en: 'Once that is achieved, the host needs to create a data structure called a command
    queue that will be used by the host to coordinate the execution of the kernels
    on the devices and commands are issued to this queue and scheduled onto the devices.
    A command queue can accept: kernel execution commands, memory transfer commands,
    and synchronization commands. Additionally, the command queues can execute the
    commands in-order, that is, in the order they''ve been given, or out-of-order.
    If the problem is decomposed into independent tasks, it is possible to create
    multiple command queues targeting different devices and scheduling those tasks
    onto them, and then OpenCL will run them concurrently.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦实现这一点，主机需要创建一个名为命令队列的数据结构，该数据结构将由主机用于协调设备上内核的执行，并将命令发布到该队列并调度到设备上。命令队列可以接受：内核执行命令、内存传输命令和同步命令。此外，命令队列可以按顺序执行命令，即按照它们被给出的顺序执行，或者可以乱序执行。如果问题被分解为独立的任务，则可以创建多个针对不同设备的命令队列，并将这些任务调度到它们上面，然后OpenCL将并发运行它们。
- en: '**Memory Model**: So far, we have understood the execution model and it''s
    time to introduce the memory model that OpenCL has stipulated. Recall that when
    the kernel executes, it is actually the work item that is executing its instance
    of the kernel code. Hence the work item needs to read and write the data from
    memory and each work item has access to four types of memories: global, constant,
    local, and private. These memories vary from size as well as accessibilities,
    where global memory has the largest size and is most accessible to work items,
    whereas private memory is possibly the most restrictive in the sense that it''s
    private to the work item. The constant memory is a read-only memory where immutable
    objects are stored and can be shared with all work items. The local memory is
    only available to all work items executing in the work group and is held by each
    compute unit, that is, CU-specific.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存模型**：到目前为止，我们已经了解了执行模型，现在是时候介绍OpenCL规定的内存模型了。回想一下，当内核执行时，实际上是工作项在执行其内核代码的实例。因此，工作项需要从内存中读取和写入数据，每个工作项都可以访问四种类型的内存：全局、常量、局部和私有。这些内存的大小和可访问性各不相同，其中全局内存具有最大的大小，并且对工作项来说最易访问，而私有内存可能是最受限的，因为它对工作项是私有的。常量内存是一个只读内存，其中存储了不可变对象，并且可以与所有工作项共享。局部内存仅对在同一个工作组中执行的所有工作项可用，并且由每个计算单元持有，即CU特定的。'
- en: The application running on the host uses the OpenCL API to create memory objects
    in global memory and will enqueue memory commands to the command queue to operate
    on them. The host's responsibility is to ensure that data is available to the
    device when the kernel starts execution, and it does so by copying data or by
    mapping/unmapping regions of memory objects. During a typical data transfer from
    the host memory to the device memory, OpenCL commands are issued to queues which
    may be blocking or non-blocking. The primary difference between a blocking and
    non-blocking memory transfer is that in the former, the function calls return
    only once (after being queued) it is deemed safe, and in the latter the call returns
    as soon as the command is enqueued.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在主机上运行的应用程序使用OpenCL API在全局内存中创建内存对象，并将内存命令入队到命令队列以操作它们。主机的责任是确保当内核开始执行时，数据对设备可用，它通过复制数据或映射/取消映射内存对象的部分区域来实现这一点。在典型的从主机内存到设备内存的数据传输过程中，OpenCL命令被发布到队列，这些队列可能是阻塞的或非阻塞的。阻塞和非阻塞内存传输的主要区别在于，在前者中，函数调用只在队列后返回一次（在入队后被认为是安全的），而在后者中，调用在命令入队后立即返回。
- en: Memory mapping in OpenCL allows a region of memory space to be available for
    computation and this region can be blocking or non-blocking and the developer
    can treat this space as readable or writeable or both.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OpenCL中的内存映射允许内存空间的一部分可用于计算，这个区域可以是阻塞的或非阻塞的，开发者可以将这个空间视为可读的、可写的或两者兼具。
- en: Hence forth, we are going to focus on getting the basics of OpenCL by letting
    our hands get dirty in developing small OpenCL programs to understand a bit more,
    programmatically, how to use the platform and execution model of OpenCL.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从此以后，我们将专注于通过编写小的OpenCL程序来掌握OpenCL的基础知识，以更深入地了解如何使用OpenCL的平台和执行模型。
- en: 'The OpenCL specification Version 1.2 is an open, royalty-free standard for
    general purpose programming across various devices ranging from mobile to conventional
    CPUs, and lately GPUs through an API and the standard at the time of writing supports:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL规范版本1.2是一个开放、免版税的标准，适用于从移动设备到传统CPU，以及最近通过API和当时的标准支持的各种设备的通用编程。
- en: Data and task based parallel programming models
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数据和任务并行编程模型
- en: Implements a subset of ISO C99 with extensions for parallelism with some restrictions
    such as recursion, variadic functions, and macros which are not supported
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了ISO C99的一个子集，并针对并行性添加了一些限制，例如不支持递归、可变参数函数和宏
- en: Mathematical operations comply to the IEEE 754 specification
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符合IEEE 754规范
- en: Porting to handheld and embedded devices can be accomplished by establishing
    configuration profiles
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过建立配置配置文件，可以将程序移植到手持设备和嵌入式设备
- en: Interoperability with OpenGL, OpenGL ES, and other graphics APIs
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与OpenGL、OpenGL ES和其他图形API的互操作性
- en: Throughout this book, we are going to show you how you can become proficient
    in programming OpenCL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将向您展示如何精通OpenCL编程。
- en: As you go through the book, you'll discover not only how to use the API to perform
    all kinds of operations on your OpenCL devices, but you'll also learn how to model
    a problem and transform it from a serial program to a parallel program. More often
    than not, the techniques you'll learn can be transferred to other programming
    toolsets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您阅读本书，您将发现不仅如何使用API对OpenCL设备执行各种操作，而且您还将学习如何建模问题，并将其从串行程序转换为并行程序。更常见的是，您将学习的技巧可以转移到其他编程工具集中。
- en: In the toolsets, I have worked with OpenCL^(TM), CUDA^(TM), OpenMP^(TM), MPI^(TM),
    Intel thread building blocks^(TM), Cilk^(TM), CilkPlus^(TM), which allows the
    developer to express parallelism in a homogeneous environment and find the entire
    process of learning the tools to application of knowledge to be classified into
    four parts. These four phases are rather common and I find it extremely helpful
    to remember them as I go along. I hope you will be benefited from them as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具集里，我使用过OpenCL^(TM)、CUDA^(TM)、OpenMP^(TM)、MPI^(TM)、Intel线程构建块^(TM)、Cilk^(TM)、CilkPlus^(TM)，这允许开发者在一个统一的环境中表达并行性，并将学习工具到应用知识的过程分为四个部分。这四个阶段相当常见，我发现按照这个过程记忆它们非常有帮助。我希望你们也能从中受益。
- en: '**Finding concurrency**: The programmer works in the problem domain to identify
    the available concurrency and expose it to use in the algorithm design'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻找并发性**：程序员在问题域中工作，以识别可用的并发性并将其暴露出来用于算法设计'
- en: '**Algorithm structure**: The programmer works with high-level structures for
    organizing a parallel algorithm'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法结构**：程序员使用高级结构来组织并行算法。'
- en: '**Supporting Structures**: This refers to how the parallel program will be
    organized and the techniques used to manage shared data'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持结构**：这指的是并行程序的组织方式以及用于管理共享数据的技术。'
- en: '**Implementation mechanisms**: The final step is to look at specific software
    constructs for implementing a parallel program.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现机制**：最后一步是查看用于实现并行程序的具体软件结构。'
- en: Don't worry about these concepts, they'll be explained as we move through the
    book.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这些概念，随着我们通过本书的进展，它们将被解释。
- en: The next few recipes we are going to examine have to do with understanding the
    usage of OpenCL APIs, by focusing our efforts in understanding the platform model
    of the architecture.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要检查的几个菜谱都与理解OpenCL API的使用有关，通过集中精力理解架构的平台模型。
- en: Querying OpenCL platforms
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询OpenCL平台
- en: Before you start coding, ensure that you have installed the appropriate OpenCL
    development toolkit for the platform you are developing for. In this recipe, we
    are going to demonstrate how you can use OpenCL to query its platform to retrieve
    simple information about the compliant devices it has detected and its various
    properties.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编码之前，请确保你已经为你要开发的平台安装了适当的OpenCL开发工具包。在这个菜谱中，我们将演示如何使用OpenCL查询其平台以检索它检测到的兼容设备及其各种属性的信息。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this first OpenCL application, you'll get to query your computer for the
    sort of OpenCL platform that's installed. In the setup of your computer, you could
    have a configuration where both NVIDIA and AMD graphic cards are installed, and
    in this case you might have installed both the AMD APP SDK and NVIDIA's OpenCL
    toolkit. And hence you would have both the platforms installed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个OpenCL应用程序中，你将能够查询你的计算机上安装的OpenCL平台类型。在你的计算机设置中，你可能有一个配置，其中同时安装了NVIDIA和AMD显卡，在这种情况下，你可能已经安装了AMD
    APP SDK和NVIDIA的OpenCL工具包。因此，你会安装这两个平台。
- en: The following code listing is extracted from `Ch1/platform_details/platform_details.c`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表是从`Ch1/platform_details/platform_details.c`中提取的。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Pay attention to the included comments, as they would help you to understand
    each individual function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包含的注释，因为它们将帮助你理解每个单独的函数：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile it on the UNIX platform, you would run a compile command similar
    to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UNIX平台上编译它，你会运行一个类似于以下编译命令：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When that happens, you would have a binary executable named `platform_details`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，你将有一个名为`platform_details`的二进制可执行文件。
- en: 'To run the program, simply execute the `platform_details` program, and a sample
    output will be an OSX:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，只需执行`platform_details`程序，一个示例输出将是OSX：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'When you first learn to program OpenCL, it can be a daunting task but it does
    get better as we move along. So, let''s decipher the source code that we''ve just
    seen. The file is a C source file and what you''ll notice is that it''s arranged
    such that the system header files are almost always placed right near the top:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始学习编程OpenCL时，这可能是一项艰巨的任务，但随着我们的进展，它确实会变得更好。所以，让我们解析我们刚刚看到的源代码。文件是一个C源文件，你会注意到它被组织得如此之好，以至于系统头文件几乎总是放在顶部附近：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next is what the C programmers would call as the platform-dependent code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是C程序员所说的平台相关代码：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The OpenCL header files are needed for the program to be compiled because they
    contain the method signatures. Now, we will try to understand what the rest of
    the code is doing. In OpenCL, one of the code conventions is to have data types
    be prefixed by `cl_` and you'll find data types for each of the platform, device
    and context as `cl_platform_XX`, `cl_device_XX`, `cl_context_XX`, and APIs prefixed
    in a similar fashion by `cl` and one such API is `clGetPlatformInfo`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL头文件对于程序编译是必需的，因为它们包含方法签名。现在，我们将尝试理解其余代码的功能。在OpenCL中，一个代码约定是数据类型以`cl_`为前缀，你可以找到每个平台、设备和上下文的数据类型，分别以`cl_platform_XX`、`cl_device_XX`、`cl_context_XX`表示，API以类似的方式以`cl`为前缀，其中一个这样的API是`clGetPlatformInfo`。
- en: In OpenCL, the APIs do not assume that you know exactly how many resources (for
    example platforms, devices, and contexts) are present or are needed when you write
    the OpenCL code. And in order to write portable code, the developers of the language
    have figured out a clever way to present the API such that you use the same API
    to pose a general question and based on the results of that question, request
    more information via the same API. Let me illustrate with an example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCL中，API并不假设你知道当你编写OpenCL代码时确切有多少资源（例如平台、设备和上下文）存在或需要。为了编写可移植的代码，语言的开发者想出了一个巧妙的方法来呈现API，这样你可以使用相同的API提出一个一般性问题，并根据该问题的结果，通过相同的API请求更多信息。让我用一个例子来说明。
- en: In the code, you will notice that `clGetPlatformInfo()` was invoked twice. The
    first invocation was to query the number of platforms that were installed on the
    machine. Based on the results of that query, we invoked `clGetPlatformInfo` again,
    but this time we passed in context-sensitive information, for example, obtaining
    the name of the vendor. You'll find this pattern recurring when programming with
    OpenCL and the cons, I can think of is that it makes the API rather cryptic at
    times, but the nice thing about it is that it prevents the proliferation of APIs
    in the language.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，你会注意到`clGetPlatformInfo()`被调用了两次。第一次调用是为了查询机器上安装的平台数量。根据查询结果，我们再次调用了`clGetPlatformInfo`，但这次我们传递了上下文相关的信息，例如，获取供应商的名称。当你用OpenCL编程时，你会发现这种模式经常出现，我可以想到的缺点是它有时会使API变得相当晦涩难懂，但它的好处是它防止了API在语言中的过度扩散。
- en: Admittedly, this is rather trivial when it comes to the entire ecosystem of
    programming OpenCL, but subsequent chapters will show how you can transform sequential
    code to parallel code in OpenCL.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，这在整个OpenCL编程生态系统中相当简单，但后续章节将展示如何将顺序代码转换为OpenCL中的并行代码。
- en: Next, let's build on the code and query OpenCL for the devices that are attached
    to the platform.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在代码的基础上构建，并查询OpenCL以获取连接到平台上的设备。
- en: Querying OpenCL devices on your platform
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询平台上的OpenCL设备
- en: We'll now query OpenCL devices that are installed on your platforms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查询安装在你平台上的OpenCL设备。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The code listing discussed in the *How to do it…* section presents an abbreviated
    portion of the code in `Ch1/device_details/device_details.c`. This code demonstrates
    how you can obtain the types of devices installed on your platform via `clGetDeviceIDs`.
    You'll use that information to retrieve detailed data about the device by passing
    it to `clGetDeviceInfo`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做…*部分讨论的代码列表展示了`Ch1/device_details/device_details.c`中的代码的简略部分。这段代码演示了你可以如何通过`clGetDeviceIDs`获取你平台上安装的设备类型。你将使用这些信息通过传递给`clGetDeviceInfo`来检索有关设备的详细信息。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this recipe, you need to completely reference the appropriate chapter code.
    Pay attention to the included comments, as they would help you understand each
    individual function. We''ve included the main part of this recipe with highlighted
    commentary:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要完全参考相应的章节代码。注意包含的注释，因为它们将帮助你理解每个单独的函数。我们已包括带有突出注释的菜谱的主要部分：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On UNIX platforms, you can compile `device_details.c` by running this command
    on your terminal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX平台上，你可以在终端运行以下命令来编译`device_details.c`：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And a binary executable named `device_details` should be deposited locally on
    your machine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并且一个名为`device_details`的二进制可执行文件应该被本地存储在你的机器上。
- en: 'When you execute the binary executable depending on your machine''s setup,
    you will see varying results. But on my OSX platform here is the output when executed
    on a machine with Intel Core i5 processor with a NVIDIA mobile GPU GT330m (extensions
    are highlighted):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在机器上执行依赖于你机器设置的二进制可执行文件时，你会看到不同的结果。但在我这里的OSX平台上，当在配备英特尔酷睿i5处理器和NVIDIA移动GPU
    GT330m（扩展被突出显示）的机器上执行时，这是输出结果：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Don't worry too much if the information doesn't seem to make sense right now,
    the subsequent chapters will reveal all.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信息现在看起来没有意义，请不要过于担心，后续章节将揭示一切。
- en: How it works…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Leveraging the work we did in the previous section, now we have made use of
    the platform via `clGetPlatformInfo`, that was detected to query for the devices
    attached. This time, we used new API functions, `clGetDeviceIDs` and `clGetDeviceInfo`.
    The former attempts to uncover all the basic information about the devices attached
    to the given platform, and we use `clGetDeviceInfo` to iterate through the results
    to understand more about their capabilities. This information is valuable when
    you are crafting your algorithm and is not very sure about what device it's going
    to be run on. Considering that OpenCL supports various processors, it's a good
    way to write portable code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们在上一节中完成的工作，我们现在已经通过 `clGetPlatformInfo` 使用了平台，该平台被检测到以查询连接的设备。这次，我们使用了新的
    API 函数 `clGetDeviceIDs` 和 `clGetDeviceInfo`。前者试图揭示连接到给定平台的所有设备的基本信息，我们使用 `clGetDeviceInfo`
    来遍历结果以了解它们的更多功能。当您在构建算法时，这些信息非常有价值，并且不确定它将在哪个设备上运行。考虑到 OpenCL 支持各种处理器，这是一种编写可移植代码的好方法。
- en: There is actually a lot more information you can derive from your device and
    I'd strongly suggest you to refer [http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/](http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/)
    and look at the main page for `clGetDeviceInfo`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以从您的设备中获取更多信息，我强烈建议您参考 [http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/](http://www.khronos.org/registry/cl/sdk/2.0/docs/man/xhtml/)
    并查看 `clGetDeviceInfo` 的主页。
- en: Now that we've understood how to query the platform and the attached devices,
    we should take a look at how to query OpenCL extensions. The extensions allow
    the vendor to define additional capabilities that's delivered with the OpenCL
    compliant device, which in turn allows you, the programmer, to utilize them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何查询平台和连接的设备，我们应该看看如何查询 OpenCL 扩展。扩展允许供应商定义与 OpenCL 兼容设备一起提供的附加功能，这反过来又允许您，作为程序员，利用它们。
- en: Querying for OpenCL device extensions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 OpenCL 设备扩展
- en: The extensions in OpenCL allow the programmer to leverage on additional capabilities
    provided by the vendor of the device, and hence they're optional. However, there
    are extensions that are recognized by OpenCL and purportedly supported by major
    vendors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 中的扩展允许程序员利用设备供应商提供的额外功能，因此它们是可选的。然而，有一些扩展被 OpenCL 识别，并且据说被主要供应商支持。
- en: 'Here''s a partial list of the approved and supported extensions in OpenCL 1.2\.
    If you wish to discover the entire list of extensions that adopters of OpenCL
    have made public (some are given in the table), please refer to the PDF document
    via this link: [http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf](http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 OpenCL 1.2 中批准和支持的扩展的部分列表。如果您想发现 OpenCL 采用者公开的整个扩展列表（其中一些在表中给出），请通过此链接查看
    PDF 文档：[http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf](http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf)。
- en: '| Extension name | Description |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 扩展名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cl_khr_fp64` | This expression gives a double precision floating-point |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_fp64` | 此表达式提供双精度浮点数 |'
- en: '| `cl_khr_int64_base_atomics` | This expression gives 64-bit integer base atomic
    operations, provides atomic operations for addition, subtraction, exchange, increment/decrement,
    and CAS |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_int64_base_atomics` | 此表达式提供 64 位整数基本原子操作，提供加法、减法、交换、增量/减量以及 CAS
    的原子操作 |'
- en: '| `cl_khr_int64_extended_atomics` | This expression gives 64-bit integer extended
    atomic operations, provides atomic operations for finding the minimum, maximum,
    and boolean operations such as and, or, and xor |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_int64_extended_atomics` | 此表达式提供 64 位整数扩展原子操作，提供查找最小值、最大值以及布尔操作（如与、或、异或）的原子操作
    |'
- en: '| `cl_khr_3d_image_writes` | This expression writes to 3D image objects |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_3d_image_writes` | 此表达式写入 3D 图像对象 |'
- en: '| `cl_khr_fp16` | This expression gives a halfly precised floating point |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_fp16` | 此表达式提供半精度浮点数 |'
- en: '| `cl_khr_global_int32_base_atomics` | This expression gives atomics for 32-bit
    operands |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_global_int32_base_atomics` | 此表达式提供 32 位操作数的原子操作 |'
- en: '| `cl_khr_global_int32_extended_atomics` | This expression gives more atomic
    functionality for 32-bit operands |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_global_int32_extended_atomics` | 此表达式为 32 位操作数提供更多原子功能 |'
- en: '| `cl_khr_local_int32_base_atomics` | This expression gives atomics for 32-bit
    operands in shared memory space |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_local_int32_base_atomics` | 此表达式提供共享内存空间中 32 位操作数的原子操作 |'
- en: '| `cl_khr_local_int32_extended_atomics` | This expression gives more atomic
    functionality for 32-bit operands in shared memory space |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_local_int32_extended_atomics` | 这个表达式为共享内存空间中的 32 位操作数提供了更多的原子功能
    |'
- en: '| `cl_khr_byte_addressable_store` | This expression allows memory writes to
    bytes less than a 32-bit word |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_byte_addressable_store` | 这个表达式允许对小于 32 位字节的内存进行写入 |'
- en: '| `cl_APPLE_gl_sharing` | This expression provides MacOSX OpenGL sharing, and
    also allows applications to use the OpenGL buffer, texture, and render buffer
    objects as OpenCL memory objects |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `cl_APPLE_gl_sharing` | 这个表达式提供了 MacOSX OpenGL 共享，并允许应用程序将 OpenGL 缓冲区、纹理和渲染缓冲区对象用作
    OpenCL 内存对象 |'
- en: '| `cl_khr_gl_sharing` | This expression provides OpenGL sharing |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_gl_sharing` | 这个表达式提供了 OpenGL 共享 |'
- en: '| `cl_khr_gl_event` | This expression retrieves CL event objects from GL sync
    objects |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_gl_event` | 这个表达式从 GL 同步对象中检索 CL 事件对象 |'
- en: '| `cl_khr_d3d10_sharing` | This expression shares memory objects with Direct3D
    10 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `cl_khr_d3d10_sharing` | 这个表达式与 Direct3D 10 共享内存对象 |'
- en: Next, let's find out how we can determine what extensions are supported and
    available on your platform by leveraging the previous code we've worked on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们找出如何通过利用我们之前所做的工作来确定你的平台支持哪些扩展以及它们是否可用。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The listing below only shows the interesting portion of the code found in `Ch1/device_extensions/device_extensions.c`.
    Various devices that are OpenCL compliant will have different capabilities, and
    during your application development you definitely want to make sure certain extensions
    are present prior to making use of them. The code discussed in the *How to do
    it…* section of this recipe shows you how to retrieve those extensions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表仅显示了`Ch1/device_extensions/device_extensions.c`中找到的有趣代码部分。各种符合 OpenCL 标准的设备将具有不同的功能，在你开发应用程序的过程中，你肯定想在使用它们之前确保某些扩展是可用的。本配方中“如何做…”部分讨论的代码展示了如何检索这些扩展。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ve included the main querying function, which allows you to implement this
    particular recipe:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了主要的查询函数，它允许你实现这个特定的配方：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To compile the code, do as you did before by running a similar command on your
    terminal like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码，就像你之前在终端上运行类似命令一样：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On a UNIX platform, here''s what we got when executed on an Intel Core i5 processor
    with an NVIDIA mobile GPU GT330m (extensions are highlighted):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 平台上，当在英特尔酷睿 i5 处理器上使用 NVIDIA 移动 GPU GT330m 执行时，我们得到了以下结果（扩展被突出显示）：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we examine the work we just did, we simply leveraged on the existing code
    and added the needed functionality where it was required, namely by adding code
    to handle the case where `CL_DEVICE_EXTENSIONS` was being passed in. We created
    an array of a fixed size on the stack and passed that array to `clGetDeviceInfo`,
    where the API will eventually store the information into the array. Extracting
    the information is as simple as printing out the array. For advanced usage, you
    might want to deposit that information into a global table structure where the
    other parts of the application can make use of it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查我们刚刚所做的工作时，我们只是利用现有的代码，并在需要的地方添加了所需的功能，即通过添加代码来处理`CL_DEVICE_EXTENSIONS`被传递的情况。我们在栈上创建了一个固定大小的数组，并将其传递给`clGetDeviceInfo`，在那里
    API 最终将信息存储到数组中。提取信息就像打印出数组一样简单。对于高级使用，你可能希望将那些信息存储到全局表结构中，以便应用程序的其他部分可以使用它。
- en: 'To understand what those extensions mean and how you can take advantage of
    them, I''d suggest that you refer to the Khronos register for OpenCL: [http://www.khronos.org/registry/cl/](http://www.khronos.org/registry/cl/).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些扩展的含义以及如何利用它们，我建议你参考 Khronos 注册的 OpenCL：[http://www.khronos.org/registry/cl/](http://www.khronos.org/registry/cl/)。
- en: We won't dwell too much on each extension that we've seen so far. Let's move
    on to understanding the OpenCL contexts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地停留在迄今为止我们所看到的每个扩展上。让我们继续了解 OpenCL 上下文。
- en: Querying OpenCL contexts
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询 OpenCL 上下文
- en: An OpenCL context is created with one or more devices. Contexts are used by
    the OpenCL runtime for managing objects such as command queues (the object that
    allows you to send commands to the device), memory, program, and kernel objects,
    and for executing kernels on one or more devices specified in the context.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL 上下文是通过一个或多个设备创建的。上下文被 OpenCL 运行时用于管理对象，例如命令队列（允许你向设备发送命令的对象）、内存、程序和内核对象，以及执行上下文中指定的一个或多个设备上的内核。
- en: 'In more detail, OpenCL contexts can be created by associating a collection
    of devices that are available for the platform via `clCreateContext` or by associating
    it with a particular type of device, for example, CPU, GPUs, and so on, via `clCreateContextFromType`.
    However, in either way you cannot create contexts that are associated with more
    than one platform. Let''s use the example of vector multiplication in the *Introduction*
    section to demonstrate these concepts. The problem of vector multiplication or
    dot product can be solved using: pen and paper, CPU, GPU, or GPU + CPU. Obviously,
    the first option doesn''t quite scale when we have a little more than 20 elements
    and with OpenCL you have more options. The first thing you need to decide is which
    platform it should be run, and in OpenCL it means deciding whether to use the
    AMD, NVIDIA, Intel, and so on. And what comes next is to decide whether to run
    the dot product on all of the devices listed for that platform or only some of
    it.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细地说，OpenCL 上下文可以通过通过 `clCreateContext` 将可用的设备集合关联到平台，或者通过通过 `clCreateContextFromType`
    将其与特定类型的设备关联，例如 CPU、GPU 等，来创建。然而，无论哪种方式，你都不能创建与多个平台关联的上下文。让我们以 *简介* 部分中的向量乘法为例来演示这些概念。向量乘法或点积问题可以使用：笔和纸、CPU、GPU
    或 GPU + CPU 来解决。显然，当我们有超过 20 个元素时，第一种方法并不太适用，而使用 OpenCL 你有更多的选择。你需要决定的第一件事是它应该在哪个平台上运行，在
    OpenCL 中这意味着决定是否使用 AMD、NVIDIA、Intel 等等。接下来要决定的是是否要在该平台列出的所有设备上运行点积，或者只运行其中的一部分。
- en: So, let's assume that the platform reports one Intel Core i7 and 3 AMD GPUs
    and the developer could use the `clCreateContextFromType` to restrict execution
    to either CPUs or GPUs, but when you use `clCreateContext`, you can list all the
    four devices to be executed against, theoretically speaking (however, in practice
    it's hard to use all CPUs and GPUs effectively because the GPU can push more threads
    for execution than the CPU). The following diagram illustrates the options available
    to the developer to create contexts assuming the host environment is installed
    with both Intel and AMD's OpenCL platform software. The configuration gets a little
    more interesting when you consider the Ivy Bridge Intel processor, which includes
    an HD Graphics co-processor that allows a context that's both CPU and GPU aware.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，让我们假设平台报告了一个英特尔酷睿 i7 和 3 个 AMD GPU，并且开发者可以使用 `clCreateContextFromType` 来限制执行到
    CPU 或 GPU，但是当你使用 `clCreateContext` 时，你可以列出所有四个要执行的设备，从理论上讲（然而，在实践中，很难有效地使用所有 CPU
    和 GPU，因为 GPU 可以推送比 CPU 更多的线程来执行）。以下图表说明了开发者创建上下文时可供选择的选项，假设主机环境安装了英特尔和 AMD 的 OpenCL
    平台软件。当考虑到包括 HD 图形协处理器在内的 Ivy Bridge 英特尔处理器时，配置会变得更有趣，该协处理器允许上下文同时识别 CPU 和 GPU。 '
- en: '![Querying OpenCL contexts](img/4520OT_01_03.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![查询 OpenCL 上下文](img/4520OT_01_03.jpg)'
- en: Contexts have another interesting property, that is, it retains a reference
    count so that third-party libraries can refer to it and hence utilize the devices.
    For example, if the `cl_khr_d3d10_sharing` extension is available on your device,
    you can actually interoperate between OpenCL and Direct3D 10, and treat Direct3D
    10 resources similar to memory objects as OpenCL memory objects that you can read
    from or write to. However, we will not demonstrate the capability with this extension
    in this book and will instead leave it to the reader to engage themselves in further
    exploration.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文还有一个有趣的属性，即它保留了一个引用计数，这样第三方库就可以引用它并因此利用设备。例如，如果你的设备上提供了 `cl_khr_d3d10_sharing`
    扩展，你实际上可以在 OpenCL 和 Direct3D 10 之间进行互操作，并将 Direct3D 10 资源类似于内存对象作为你可以从中读取或写入的
    OpenCL 内存对象。然而，我们不会在这个书中用这个扩展来演示功能，而是将其留给读者去进一步探索。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code listing given in the *How to do it…* section is extracted from `Ch1/context_query/context_details.c`,
    and it illustrates how to create and release OpenCL contexts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做…* 部分给出的代码列表是从 `Ch1/context_query/context_details.c` 中提取的，它说明了如何创建和释放
    OpenCL 上下文。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To query an OpenCL context, you need to include a function similar to the following
    in your code. You should reference the full code listing alongside this recipe:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询 OpenCL 上下文，你需要在你的代码中包含一个类似于以下的功能。你应该参考与此菜谱相关的完整代码列表：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: On UNIX platforms, you can compile and build the program by typing the following
    command
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 平台上，你可以通过输入以下命令来编译和构建程序
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On the test machine, we have two OpenCL compliant devices. The first is the
    Intel Core i5 CPU, and the second is the NVIDIA mobile GT330m GPU. And the following
    is the output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试机器上，我们有两个符合OpenCL规范的设备。第一个是英特尔酷睿i5 CPU，第二个是NVIDIA移动GT330m GPU。以下是其输出：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: If you have been following the book, you should realize that we didn't do anything
    special other than leverage on the previous exercises where we discover the sort
    of platforms installed, and with that uncover the devices and finally use that
    information to create the relevant contexts. Finally, with those relevant contexts
    we can query them. What you will notice is that the context's reference count
    is one in both cases, which indicates that a memory object is currently referencing
    it and the fact that we passed in `CL_CONTEXT_REFERENCE_COUNT` reflects this.
    This counter is only good when you want to detect if the application is experiencing
    a context leak, which actually means a memory leak. For OpenCL devices such as
    the CPU or GPU, the problem might not sound as a big deal. But for mobile processors,
    it would pose quite a serious problem since memory leaks, in general, wastes resources
    and the ultimately depleting battery life.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随这本书学习，你应该意识到我们并没有做任何特别的事情，只是利用了之前的练习，发现了已安装的平台类型，并据此发现了设备和最终使用这些信息来创建相关上下文。最后，有了这些相关上下文，我们就可以查询它们。你会注意到，在两种情况下上下文的引用计数都是一，这表明当前有一个内存对象正在引用它，而我们传递的
    `CL_CONTEXT_REFERENCE_COUNT` 也反映了这一点。这个计数器只有在你想检测应用程序是否经历上下文泄露（实际上意味着内存泄露）时才有用。对于CPU或GPU这样的OpenCL设备，这个问题可能并不严重。但对于移动处理器来说，它可能会造成相当严重的问题，因为内存泄露通常浪费资源，并最终耗尽电池寿命。
- en: 'There are actually more details where you can query the context via `clGetContextInfo`
    by passing in various `cl_context_info` types. Here''s a list of them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你还可以通过传递各种 `cl_context_info` 类型来使用 `clGetContextInfo` 查询更多细节。以下是一个列表：
- en: '| cl_context_info | Return type | Information returned in `param_name` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| cl_context_info | 返回类型 | `param_name` 中返回的信息 |'
- en: '| --- | --- | --- |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CL_CONTEXT_REFERENCE COUNT` | `cl_uint` | This variable returns the context
    reference count |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `CL_CONTEXT_REFERENCE_COUNT` | `cl_uint` | 这个变量返回上下文的引用计数 |'
- en: '| `CL_CONTEXT_NUM_DEVICES` | `cl_uint` | This variable returns the number of
    devices in context |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `CL_CONTEXT_NUM_DEVICES` | `cl_uint` | 这个变量返回上下文中的设备数量 |'
- en: '| `CL_CONTEXT_DEVICES` | `cl_device_id[]` | This variable returns a list of
    devices in context |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `CL_CONTEXT_DEVICES` | `cl_device_id[]` | 这个变量返回上下文中的设备列表 |'
- en: '| `CL_CONTEXT_PROPERTIES` | `cl_context_properties` | This variable returns
    the properties argument specified in `clCreateContext` or `clCreateContextFromType`
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `CL_CONTEXT_PROPERTIES` | `cl_context_properties` | 这个变量返回在 `clCreateContext`
    或 `clCreateContextFromType` 中指定的属性参数 |'
- en: Now that we've understood the basics of querying the platform, devices, extensions,
    and contexts I think it's time to take a look at OpenCL kernels and how you can
    program them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了查询平台、设备、扩展和上下文的基本知识，我认为是时候看看OpenCL内核以及如何编程它们了。
- en: Querying an OpenCL program
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询OpenCL程序
- en: In OpenCL, kernels refer to a function declared in a program. A program in OpenCL
    consists of a set of kernels that are functions declared with the `__kernel` qualifier
    in the code. Such a program encapsulates a context, a program source or binary,
    and the number of kernels attached. The following sections explain how to build
    the OpenCL program and finally load the kernels for execution on the devices.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenCL中，内核指的是程序中声明的一个函数。OpenCL程序由一组内核组成，这些内核是在代码中使用 `__kernel` 限定符声明的函数。这样的程序封装了一个上下文、程序源或二进制文件以及附加的内核数量。以下几节将解释如何构建OpenCL程序，并最终在设备上加载内核以执行。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to run OpenCL kernels, you need to have a program (source or binary).
    Currently, there are two ways to build a program: from source files and other
    from binary objects via `clCreateProgramWithSource` and `clCreateProgramWithBinary`
    respectively (clever names). These two APIs return a program object represented
    by the OpenCL type, `cl_program` when successful. Let''s examine the method signatures
    to understand it better:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行OpenCL内核，你需要有一个程序（源代码或二进制文件）。目前，有两种方式来构建程序：一种是从源文件构建，另一种是通过 `clCreateProgramWithSource`
    和 `clCreateProgramWithBinary` 分别从二进制对象构建（名字很聪明）。这两个API在成功时返回一个由OpenCL类型 `cl_program`
    表示的程序对象。让我们检查方法签名以更好地理解它：
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you read the signature carefully, you''ll notice that the OpenCL context
    needs to be created prior to build our program from source. Next the `strings`
    and `lengths` arguments hold the various (kernel) filenames and their respective
    file lengths, and the last argument, `errcode_ret` reflects the presence of errors
    while building the program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细阅读签名，你会注意到在从源代码构建我们的程序之前，需要先创建OpenCL上下文。接下来，`strings`和`lengths`参数持有各种（内核）文件名及其相应的文件长度，最后一个参数`errcode_ret`反映了在构建程序时是否存在错误：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Examine the signature and you can quickly realize that the `binaries` and `lengths`
    arguments hold the pointers to the program binaries and their respective lengths.
    All the binaries are loaded into the devices represented by the `device_list`
    argument through the context. Whether the program was loaded onto the device successfully
    is reflected in the `binary_status` argument. The developer would find this manner
    of program creation useful when the binary is the only artifact that can be exposed
    to customers or even during system integration tests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 检查签名，你很快就会意识到`binaries`和`lengths`参数持有程序二进制及其相应长度的指针。所有二进制文件都是通过`device_list`参数表示的设备加载的，加载到设备上的程序是否成功，反映在`binary_status`参数中。当二进制是唯一可以暴露给客户或甚至在系统集成测试期间可以使用的工件时，开发者会发现这种程序创建方式很有用。
- en: For a developer to be able to create a valid OpenCL program by pulling offline
    binaries using `clCreateProgramWithBinary`, he needs to generate the offline binaries
    in the first place using the platform's compiler and this process is unfortunately
    vendor specific. If you are using the AMD APP SDK, then you would need to enable
    the `cl_amd_offline_devices` AMD extension, and when you create the context, you
    need to pass in the `CL_CONTEXT_OFFLINE_DEVICES_AMD` property. If you are developing
    for the Intel or Apple OpenCL platforms, we would recommend you to consult the
    documentation at their websites.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发者能够通过使用`clCreateProgramWithBinary`从离线二进制文件中创建有效的OpenCL程序，他首先需要使用平台的编译器生成离线二进制文件，但遗憾的是这个过程是供应商特定的。如果你使用AMD
    APP SDK，那么你需要启用`cl_amd_offline_devices` AMD扩展，并在创建上下文时传递`CL_CONTEXT_OFFLINE_DEVICES_AMD`属性。如果你为Intel或Apple
    OpenCL平台开发，我们建议你咨询他们网站上的文档。
- en: Next, we need to build the program by invoking `clBuildProgram` passing it the
    created `cl_program` object from `clCreateProgramFromSource` and during program
    creation, the developer can provide additional compiler options to it (just as
    you perform when compiling C/C++ programs). Let's see an example of how you might
    do this in the code given in the *How to do it…* section, abbreviated from `Ch1/build_opencl_program/build_opencl_program.c`
    and the OpenCL kernel files are listed in `Ch1/build_opencl_program/{simple.cl,
    simple_2.cl`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过调用`clBuildProgram`并传递从`clCreateProgramFromSource`创建的`cl_program`对象来构建程序。在程序创建过程中，开发者可以向它提供额外的编译器选项（就像你在编译C/C++程序时所做的）。让我们看看在*如何做…*部分给出的代码示例，该示例摘自`Ch1/build_opencl_program/build_opencl_program.c`，OpenCL内核文件列在`Ch1/build_opencl_program/{simple.cl,
    simple_2.cl}`中。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To query an OpenCL program, you need to include a function similar to the following
    in your code. You should refer to the complete code listing alongside this recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询OpenCL程序，你需要在你的代码中包含一个类似于以下的功能。你应该参考随此食谱一起提供的完整代码列表：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to what you did previously, the compilation command won''t be too far
    off:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与你之前所做的一样，编译命令不会离得太远：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll find the executable file named `build_opencl_program` deposited on the
    filesystem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在文件系统中找到名为`build_opencl_program`的可执行文件。
- en: 'There are two ways to run the program, depending on how you compile it. If
    you reexamine the code snippet shown earlier, you would notice that the compiler
    options is defined in the source code and hence it''s static, but there''s another
    dynamic way in which the compiler options can be passed during compilation and
    the following are those two simple approaches are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你如何编译程序，有两种运行程序的方式。如果你重新检查之前显示的代码片段，你会注意到编译器选项是在源代码中定义的，因此它是静态的，但还有另一种动态方式可以在编译期间传递编译器选项，以下就是这两种简单的方法：
- en: 'If you chose the option of defining the build options statically, that is,
    if you have the following lines:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了定义构建选项为静态的选项，即如果你有如下几行：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: OpenCL will simply build the program based on those build options you provided.
    This is rather suitable as the shipped application will have consistent results
    when running across different customer's setups.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCL将简单地根据你提供的构建选项构建程序。这对于随应用程序一起提供的应用程序在不同客户设置上运行时具有一致的结果是非常合适的。
- en: To run the program, simply click on the `build_opencl_program` executable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，只需单击`build_opencl_program`可执行文件。
- en: 'However, if you chose the other option of allowing your users to pass in options
    of their choice (largely depending on your algorithm design), that is, if you
    have something like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你选择了允许用户传入他们选择的选项的其他选项（很大程度上取决于你的算法设计），也就是说，如果你有类似这样的东西：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In place of options, we have the array of pointers to strings, traditionally
    used to pass in arguments to the program via the command line (conveniently known
    to the C programmer as `argv`), then you would have allowed the user to pass in
    multiple build options.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代替选项，我们有字符串指针数组，传统上用于通过命令行（对C程序员来说方便地称为`argv`）传递程序参数，然后你将允许用户传入多个构建选项。
- en: 'To run the program, you would enter a command similar to this where you quote
    the multiple options (enclosed with quotes) you wish to pass to the program via
    `–D`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行程序，你会输入一个类似于以下的命令，其中引用了（用引号括起来）你希望通过`–D`传递给程序的多个选项：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The code example in this section is a little more involved than what we''ve
    been doing so far. What we did was to build an OpenCL program with two files:
    `simple.cl` and `simple_2.cl` which contains two simple OpenCL kernels via this
    (earlier) code snippet.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码示例比我们迄今为止所做的工作要复杂一些。我们所做的是构建一个OpenCL程序，包含两个文件：`simple.cl`和`simple_2.cl`，这两个文件通过这个（较早的）代码片段包含两个简单的OpenCL内核。
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We demonstrated on to create the necessary data structures to store the contents
    of both files and the length of their program in two variables, `buffer` and `sizes`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何创建必要的两个变量`buffer`和`sizes`来存储两个文件的内容及其程序长度。
- en: Next, we demonstrated how you built an OpenCL program using the `cl_program`
    object that's returned by `clCreateProgramWithSource` with build options that
    are either pre or user defined. We've also learnt how to use the `clGetProgramInfo`
    to query the program object for the result of the build. Also, the host application
    has the capability to dump any build errors from this process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示了如何使用`clCreateProgramWithSource`返回的`cl_program`对象构建OpenCL程序，并使用预定义或用户定义的构建选项。我们还学习了如何使用`clGetProgramInfo`查询程序对象的构建结果。此外，主机应用程序还具有从该过程中转储任何构建错误的能力。
- en: 'Finally, we released the data structures associated with the program and contexts
    in reverse order of their creation. In OpenCL 1.2, there is another new manner
    in which you can build a OpenCL program object but you would need to use both
    of the new APIs: `clCompileProgram` and `clLinkProgram`. The rationale behind
    them is to facilitate separation, compilation, and linkage.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以创建顺序的相反顺序释放了与程序和上下文相关的数据结构。在OpenCL 1.2中，你可以以另一种方式构建OpenCL程序对象，但你需要使用这两个新的API：`clCompileProgram`和`clLinkProgram`。它们的背后原理是便于分离、编译和链接。
- en: The build options deserved a further mention here, as there are in general four
    groups of options available to the OpenCL programmer. Go through the following
    for more information.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 构建选项值得在这里进一步提及，因为通常有四组选项可供OpenCL程序员使用。以下信息供参考。
- en: 'There are, in general, three groups of options available when you wish to build
    the OpenCL program: options to control behavior in math, optimizations, and miscellaneous.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望构建OpenCL程序时，通常有三个选项组可用：用于控制数学行为、优化和杂项的选项。
- en: 'The following table presents the math options available:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了可用的数学选项：
- en: '| `-cl-single-precision-constant` | This option treats double precision floating
    point as a single precision constant. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-single-precision-constant` | 此选项将双精度浮点数视为单精度常数。 |'
- en: '| `-cl-denorms-are-zero` | This option controls how single and double precision
    denormalized numbers are handled. The compiler can choose to flush these numbers
    to zero. See [http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/](http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/).
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-denorms-are-zero` | 此选项控制单精度和双精度未规格化数字的处理方式。编译器可以选择将这些数字清除为零。请参阅[http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/](http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/)。
    |'
- en: '| `-cl-fp32-correctly-rounded-divide-sqrt` | This option can be passed to `clBuildProgram`
    or `clCompileProgram`, which allows an application to specify that a single precision
    floating point divide (x / y and 1 / x) and sqrt used in the program source are
    correctly rounded. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-fp32-correctly-rounded-divide-sqrt` | 此选项可以传递给 `clBuildProgram` 或 `clCompileProgram`，允许应用程序指定程序源中使用的单精度浮点除法（x
    / y 和 1 / x）以及 sqrt 是正确舍入的。|'
- en: 'The following table highlights the optimization options available:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格突出了可用的优化选项：
- en: '| `-cl-opt-disable` | This option disables all optimizations. Optimizations
    are enabled by default |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-opt-disable` | 此选项禁用所有优化。优化默认启用 |'
- en: '| `-cl-mad-enable` | This option allows a * b + c to be computed with reduced
    accuracy |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-mad-enable` | 此选项允许使用降低精度的计算 a * b + c |'
- en: '| `-cl-unsafe-math-optimizations` | This option combines the `–cl-mad-enable`
    and `–cl-no-signed-zeros` options |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-unsafe-math-optimizations` | 此选项结合了 `–cl-mad-enable` 和 `–cl-no-signed-zeros`
    选项 |'
- en: '| `-cl-no-signed-zeros` | This option allows floating point arithmetic to ignore
    the signedness of zero, since according to IEEE 754, there''s a difference between
    +0.0 and -0.0 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-no-signed-zeros` | 此选项允许浮点运算忽略零的符号，因为根据 IEEE 754，+0.0 和 -0.0 之间存在差异
    |'
- en: '| `-cl-finite-math-only` | This option allows optimizations to assume no floating
    point argument to take a NaN or an infinite value |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-finite-math-only` | 此选项允许优化假设没有浮点参数取 NaN 或无穷大值 |'
- en: '| `-cl-fast-relaxed-math` | This option combines the `–cl-unsafe-math-`optimizations
    and the `–cl-finite-math-only` options |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-fast-relaxed-math` | 此选项结合了 `–cl-unsafe-math-`优化和 `–cl-finite-math-only`
    选项 |'
- en: 'The following table here highlights the miscellaneous options available:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格突出了可用的各种选项：
- en: '| `-w` | This option prevents all warning messages |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `-w` | 此选项阻止所有警告消息 |'
- en: '| `-Werror` | This option turns all warning messages into errors |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `-Werror` | 此选项将所有警告消息转换为错误 |'
- en: '| `-cl-std=VERSION` | This option builds the program based on the version of
    the OpenCL compiler (VERSION={CL1.1}) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `-cl-std=VERSION` | 此选项根据 OpenCL 编译器的版本（VERSION={CL1.1}）构建程序 |'
- en: Let's move on to a bigger example where we create and query OpenCL kernels and
    eventually place them on a command queue for a device.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更大的例子，其中我们创建和查询 OpenCL 内核，并最终将它们放置在设备上的命令队列中。
- en: Creating OpenCL kernels
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 OpenCL 内核
- en: 'So far, we''ve managed to create a program from the source files. These source
    files are actually the OpenCL kernel code. Here''s an example of how they look
    like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从源文件中创建了一个程序。这些源文件实际上是 OpenCL 内核代码。以下是如何查看它们的示例：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The kernels are identified by `__kernel` qualified to the C-like function. The
    `__global` qualifiers refer to the memory space in which the variables reside.
    We'll have more to say about this in later chapters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过 `__kernel` 修饰符识别，类似于 C 函数。`__global` 修饰符指的是变量所在的内存空间。我们将在后面的章节中对此进行更多讨论。
- en: 'But this program cannot execute on the device even though we have created the
    program objects, as described previously. Recall that a program can reference
    several kernels and we need to hold on to those kernels, because it is the kernel
    that gets scheduled for execution on the devices and not the program object. OpenCL
    gives us the function to extract those kernels via `clCreateKernel` or `clCreateKernelsInProgram`.
    Let''s take a close look at them:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已创建了程序对象，如前所述，但此程序无法在设备上执行。回想一下，一个程序可以引用多个内核，我们需要保留这些内核，因为是在设备上调度执行的是内核而不是程序对象。OpenCL
    通过 `clCreateKernel` 或 `clCreateKernelsInProgram` 函数为我们提供了提取这些内核的功能。让我们仔细看看它们：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By looking at this code, you'll notice that in order to create the kernel we
    first need to create the program object, the name of the kernel function plus
    the capture of the return status. This API returns a `cl_kernel`, which represents
    the kernel object when successful. This API provides the programmer with an option
    of not transforming every kernel function in the program into actual OpenCL kernel
    objects ready for execution.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看此代码，您会注意到，为了创建内核，我们首先需要创建程序对象，内核函数的名称以及捕获返回状态。此 API 返回 `cl_kernel`，表示内核对象在成功时。此
    API 为程序员提供了一个选项，即不必将程序中的每个内核函数转换为实际可用于执行的 OpenCL 内核对象。
- en: 'But if you wish to simply transform all kernel functions in the program into
    kernel objects, then `clCreateKernelsInProgram` is the API to use:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您希望将程序中的所有内核函数简单地转换为内核对象，那么 `clCreateKernelsInProgram` 是要使用的 API：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You use this API to ask OpenCL to create and load the kernels into the `kernels`
    argument, and you hint to the OpenCL compiler how many kernels you're expecting
    with the `num_kernels` argument.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用此API请求OpenCL创建并加载内核到`kernels`参数中，并通过`num_kernels`参数向OpenCL编译器提示您期望的内核数量。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The complete code can be found in `ch1/kernel_query/kernel_query.c`. An abbreviated
    code is shown in the code snippet discussed in the *How to do it...* section of
    this recipe to keep us focused on the key APIs. This code requires one or more
    OpenCL source files, that is, `*.cl` and once you've placed them together you
    need to change the program's variables, `file_names` and `NUMBER_OF_FILES` to
    reflect the files accordingly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`ch1/kernel_query/kernel_query.c`中找到。为了让我们专注于关键的API，本食谱中讨论的代码片段展示了简化的代码。此代码需要一个或多个OpenCL源文件，即`*.cl`文件，一旦将它们放在一起，您需要更改程序的变量`file_names`和`NUMBER_OF_FILES`以反映相应的文件。
- en: How to do it …
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To query an OpenCL kernel, you''ll need to include a function similar to the
    following in your code. You should reference the full code listing alongside this
    recipe:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询OpenCL内核，您需要在代码中包含一个类似于以下的功能。您应该参考与此食谱一起提供的完整代码列表：
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The compilation is very similar to that of `build_opencl_program.c` illustrated
    in the previous section, so we''re skipping this step. When this application is
    run with two OpenCL source files, the output we will get is:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 编译与上一节中展示的`build_opencl_program.c`非常相似，所以我们跳过这一步。当此应用程序使用两个OpenCL源文件运行时，我们将得到以下输出：
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The two source files, each defined a simple kernel function that adds its two
    arguments and stores the result into the third argument; and hence the `arity`
    of the function is `3`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 两个源文件各自定义了一个简单的内核函数，该函数将两个参数相加并将结果存储到第三个参数中；因此，函数的`arity`为`3`。
- en: How it works…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The code invokes `clCreateKernelsInProgram` twice. If you recall, this pattern
    recurs for many of the OpenCL APIs, where the first call would query the platform
    for certain details, which in this case is the number of kernels detected in the
    program. The subsequent calls would ask OpenCL to deposit the kernel objects into
    the storage referenced by kernels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用`clCreateKernelsInProgram`两次。如果您还记得，这种模式在许多OpenCL API中都会出现，其中第一次调用会查询平台以获取某些详细信息，在这种情况下是程序中检测到的内核数量。后续调用会要求OpenCL将内核对象存入由`kernels`引用的存储中。
- en: Finally, we invoke `clGetKernelInfo`, passing to it the retrieved kernel objects,
    and printing out some information about the kernel functions, such as the kernel
    function's name and the arity of the function through the `CL_KERNEL_FUNCTION_NAME`
    and `CL_KERNEL_NUM_ARGS` variables.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`clGetKernelInfo`，向其传递检索到的内核对象，并通过`CL_KERNEL_FUNCTION_NAME`和`CL_KERNEL_NUM_ARGS`变量打印出有关内核函数的一些信息，例如内核函数的名称和函数的`arity`。
- en: 'A complete list of details that can be queried from the kernel objects is reflected
    in the following table:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从内核对象查询的详细列表反映在下表中：
- en: '| cl_kernel_info | Return Type | Information returned in param_value |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| cl_kernel_info | 返回类型 | 在param_value中返回的信息 |'
- en: '| --- | --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `CL_KERNEL_FUNCTION_NAME` | `char[]` | This variable returns the kernel function''s
    name |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `CL_KERNEL_FUNCTION_NAME` | `char[]` | 此变量返回内核函数的名称 |'
- en: '| `CL_KERNEL_NUM_ARGS` | `cl_uint` | This variable returns the number of arguments
    to kernel |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `CL_KERNEL_NUM_ARGS` | `cl_uint` | 此变量返回内核的参数数量 |'
- en: '| `CL_KERNEL_REFERENCE_COUNT` | `cl_uint` | This variable returns the kernel
    reference count |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `CL_KERNEL_REFERENCE_COUNT` | `cl_uint` | 此变量返回内核引用计数 |'
- en: '| `CL_KERNEL_CONTEXT` | `cl_context` | This variable returns the associated
    context for this kernel |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `CL_KERNEL_CONTEXT` | `cl_context` | 此变量返回与此内核关联的上下文 |'
- en: '| `CL_KERNEL_PROGRAM` | `cl_program` | This variable returns the program object,
    that will be bound to the kernel object |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `CL_KERNEL_PROGRAM` | `cl_program` | 此变量返回将绑定到内核对象的程序对象 |'
- en: Now that we've figured out how to create kernel objects, we should take a look
    at how to create command queues and start enqueuing our kernel objects and data
    for execution.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚如何创建内核对象，我们应该看看如何创建命令队列并开始将我们的内核对象和数据入队以执行。
- en: Creating command queues and enqueuing OpenCL kernels
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令队列和入队OpenCL内核
- en: This section will show you how to enqueue OpenCL kernel objects on the device.
    Before we do that, let's recall that we can create kernels without specifying
    an OpenCL device and the kernels can be executed on the device via the command
    queue.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何在设备上入队OpenCL内核对象。在我们这样做之前，让我们回顾一下，我们可以创建内核而不指定OpenCL设备，并且内核可以通过命令队列在设备上执行。
- en: At this point, we probably should spend some time talking about in-order execution
    and how they can be compared with out-of-order execution, though this subject
    is complex but intriguing as well. When a program is to be executed, the processor
    has the option of processing the instructions in the program in-order or out-of-order;
    a key difference between these two schemes is that in-order results in an execution
    order that is static, while out-of-order allows instructions to be scheduled dynamically.
    Out-of-order execution typically involves reordering the instructions, so that
    all computation units in the processors are utilized and driven by the goal of
    minimizing the stalling of the computation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可能应该花一些时间来谈谈按顺序执行以及它们如何与乱序执行进行比较，尽管这个主题很复杂，但也很吸引人。当程序要被执行时，处理器可以选择按顺序或乱序处理程序中的指令；这两种方案之间的一个关键区别是，按顺序执行会产生一个静态的执行顺序，而乱序执行允许指令动态地调度。乱序执行通常涉及重新排序指令，以便充分利用处理器中的所有计算单元，并驱动目标以最小化计算停滞。
- en: However, kernels are not the only objects that can be queued on the command
    queue. A kernel needs data so that it can perform its operations and data needs
    to transferred to the device for consumption, and these data could be OpenCL buffer
    / sub-buffer or image objects. The memory objects that encapsulate the data need
    to be transported into the device and you have to issue memory commands to the
    command queue for that to occur; and in many use cases, it is common to hydrate
    the device with data prior to computation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内核并不是唯一可以入队到命令队列的对象。内核需要数据以便执行其操作，并且数据需要传输到设备上进行消费，这些数据可以是OpenCL缓冲区/子缓冲区或图像对象。封装数据的内存对象需要被传输到设备上，并且你必须向命令队列发出内存命令以实现这一点；在许多用例中，在计算之前用数据填充设备是很常见的。
- en: The following diagram highlights this use case where a kernel is scheduled for
    in-order execution, assuming that the kernel needs the data to be copied explicitly
    or memory-mapped, and upon completion of computation, the data is copied from
    the device's memory to host memory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示突出了这种用例，其中内核被安排按顺序执行，假设内核需要显式复制数据或内存映射数据，并在计算完成后，数据从设备内存复制到主机内存。
- en: '![Creating command queues and enqueuing OpenCL kernels](img/4520OT_01_04.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![创建命令队列和入队OpenCL内核](img/4520OT_01_04.jpg)'
- en: Also multiple command queues can be created and enqueued with commands and the
    reason for their existence is because the problem you wish to solve might involve
    some, if not all of the heterogeneous devices in the host. And they could represent
    independent streams of computation where no data is shared, or dependent streams
    of computation where each subsequent task depends on the previous task (often,
    data is shared). Take care that these command queues will execute on the device
    without synchronization, provided that no data is shared. If data is shared, then
    the programmer needs to ensure synchronization of the data through synchronization
    commands provided by the OpenCL specification.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以创建多个命令队列，并使用命令入队，它们存在的原因是您希望解决的问题可能涉及主机中的某些，如果不是所有异构设备。它们可以代表独立计算流，其中没有数据共享，或者依赖计算流，其中每个后续任务都依赖于前一个任务（通常，数据是共享的）。请注意，如果没有数据共享，这些命令队列将在设备上无同步地执行。如果数据共享，则程序员需要确保通过OpenCL规范提供的同步命令来同步数据。
- en: As an example of independent streams of computation, the following diagram assumes
    that three independent tasks have been identified and they need to execute on
    a device. Three command queues (in-order execution only) with tasks enqueued in
    each of them and a pipeline can be formed, such that the device executes the kernel
    code while I/O is being performed to achieve better utilization by not having
    the device sit idle waiting for data.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为独立计算流的示例，以下图示假设已经确定了三个独立任务，并且它们需要在设备上执行。可以形成三个命令队列（仅按顺序执行），每个队列中入队了任务，并可以形成一个流水线，这样设备在执行内核代码的同时进行I/O操作，从而在不让设备空闲等待数据的情况下提高利用率。
- en: '![Creating command queues and enqueuing OpenCL kernels](img/4520OT_01_05.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![创建命令队列和入队 OpenCL 内核](img/4520OT_01_05.jpg)'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be aware that even though by default, commands enqueued in the command queue
    execute in-order, you can enable out-of-order execution by passing the `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE`
    flag when creating the command queue.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管默认情况下，入队到命令队列中的命令按顺序执行，但你可以在创建命令队列时通过传递 `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE`
    标志来启用非顺序执行。
- en: An example of out-of-order execution is shown in the following diagram, and
    let's assume that our problem is decomposed into three interdependent kernels,
    where each kernel will consume and process the data and then pass it to the next
    phase. Let's assume further that the execution of the kernels is out-of-order.
    What would happen next is mayhem and that's probably why this option is never
    the default.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了非顺序执行的示例，并假设我们的问题被分解为三个相互依赖的内核，每个内核将消耗和处理数据，然后将其传递到下一阶段。进一步假设内核的执行是非顺序的。接下来会发生的事情可能是混乱，这也可能是为什么这个选项不是默认设置的原因。
- en: '![Creating command queues and enqueuing OpenCL kernels](img/4520OT_01_06.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![创建命令队列和入队 OpenCL 内核](img/4520OT_01_06.jpg)'
- en: However, the reader should be aware about CPUs from AMD and Intel.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，读者应该注意来自 AMD 和 Intel 的 CPU。
- en: When you start working on the kernels, you might discover that certain kernels
    seem to have better performance than others. And you can profile the kernel while
    you are fine-tuning it by passing the `CL_QUEUE_PROFILING_ENABLE` flag when creating
    the command queue.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始处理内核时，你可能会发现某些内核似乎比其他内核的性能更好。你可以在微调内核时通过在创建命令队列时传递 `CL_QUEUE_PROFILING_ENABLE`
    标志来分析内核。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Without repeating too much of the previous code, here's the relevant code that
    is derived from `ch1/kernel_queue/kernel_queue.c`. This code listing would need
    valid OpenCL kernel file(s) with distinct kernel function names (function overloading
    is disallowed) and valid function parameters. In `ch1/kernel_queue/hello_world.cl`
    you can see an example of such a function or kernel otherwise.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在不重复太多之前代码的基础上，以下是源自 `ch1/kernel_queue/kernel_queue.c` 的相关代码。此代码列表需要具有不同内核函数名称（不允许函数重载）的有效
    OpenCL 内核文件，以及有效的函数参数。在 `ch1/kernel_queue/hello_world.cl` 中，你可以看到一个这样的函数或内核的示例。
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'You should reference the full code listing alongside this recipe:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该参考与此配方一起的完整代码列表：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As before, the compilation steps are similar to that in `kernel_query.c` with
    a command like:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译步骤与 `kernel_query.c` 中的类似，可以使用如下命令：
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s the sample output when I execute the application on my machine:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我在我机器上执行应用程序时的示例输出：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the output, you can tell that the task has been enqueued onto a command
    queue successfully!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以看出任务已成功入队到命令队列中！
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Following from the previous section where we successfully queried the OpenCL
    kernel objects for information, we leverage on that code to create a command queue
    via `clCreateCommandQueue`, enqueue the kernel into the queue via `clEnqueueTask`,
    but not before setting the data needed for the kernel via `clSetKernelArg` and
    `clCreateBuffer`. You can ignore these two APIs for now, until we explain them
    in a later chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们成功查询了 OpenCL 内核对象的信息之后，我们利用那段代码通过 `clCreateCommandQueue` 创建命令队列，通过 `clEnqueueTask`
    将内核入队到队列中，但在设置内核所需数据之前，需要通过 `clSetKernelArg` 和 `clCreateBuffer`。你现在可以忽略这两个 API，直到我们在后面的章节中解释它们。
