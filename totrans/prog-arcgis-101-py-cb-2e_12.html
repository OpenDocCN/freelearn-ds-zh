<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Error Handling and Troubleshooting</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring the default Python error message</li><li class="listitem" style="list-style-type: disc">Adding Python exception handling structures (try/except/finally)</li><li class="listitem" style="list-style-type: disc">Retrieving tool messages with GetMessages()</li><li class="listitem" style="list-style-type: disc">Filtering tool messages by severity level</li><li class="listitem" style="list-style-type: disc">Returning individual messages with GetMessage()</li><li class="listitem" style="list-style-type: disc">Testing for and responding to specific error messages</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec83"/>Introduction</h1></div></div></div><p>Various messages are returned during the execution of ArcGIS geoprocessing tools and functions. These messages can be informational in nature or indicate warning or error conditions that can result in the tool not creating the expected output or in outright failure of the tool to execute. These messages do not appear as message boxes. Instead, you will need to retrieve them using various ArcPy functions. To this point in the book, we have ignored the existence of these messages, warnings, and errors. This is mainly due to the fact that I wanted you to concentrate on learning some basic concepts, without adding the extra layer of code complexity that is necessary for creating robust geoprocessing scripts that can handle error situations gracefully. That being said, it's now time that you learn how to create the geoprocessing and Python exception handling structures that will enable you to create versatile geoprocessing scripts. These scripts can handle messages that indicate warnings, errors, and general information, which are generated while your script is running. These code details will help make your scripts more flexible and less error prone. You've already used the basic <code class="literal">try</code> and <code class="literal">except</code> blocks to perform some basic error handling. But, in this chapter, we'll go into more detail about why and how these structures are used.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec84"/>Exploring the default Python error message</h1></div></div></div><p>By default, Python will <a id="id809" class="indexterm"/>
<a id="id810" class="indexterm"/>generate an error message anytime it encounters a problem in your script. These error messages will not always be very informative to the end user running the script. However, it is valuable to take a look at these raw messages. In later recipes, we'll use Python error handling structures to get a cleaner look at the errors and respond as necessary.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec214"/>Getting ready</h2></div></div></div><p>In this recipe, we will create and run a script that intentionally contains error conditions. We will not include any geoprocessing or Python exception handling techniques in the script. We're intentionally doing this, because I want you to see the error information returned by Python.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec215"/>How to do it…</h2></div></div></div><p>Follow the steps below to see a raw Python error message that is generated when an error occurs while a tool is being executed in a script:</p><div><ol class="orderedlist arabic"><li class="listitem">Open IDLE and create a new script. </li><li class="listitem">Save the script to <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code>.</li><li class="listitem">Import the <code class="literal">arcpy</code> module:<div><pre class="programlisting">import arcpy</pre></div></li><li class="listitem">Set the workspace:<div><pre class="programlisting">arcpy.env.workspace = "c:/ArcpyBook/data"</pre></div></li><li class="listitem">Call the <code class="literal">Buffer</code> tool. The <code class="literal">Buffer</code> tool requires a buffer distance be entered as one of its parameters. In this code block, we have intentionally left out the distance parameter:<div><pre class="programlisting">arcpy.Buffer_analysis("Streams.shp","Streams_Buff.shp")</pre></div></li><li class="listitem">Run the script. You should see the following error message:<div><pre class="programlisting">
<strong> Runtime error Traceback (most recent call last): File "&lt;string&gt;", line 1, in &lt;module&gt; File "c:\program files (x86)\arcgis\desktop10.1\arcpy\arcpy\analysis.py", line 687, in Buffer  raise e ExecuteError: Failed to execute. Parameters are not valid. ERROR 000735: Distance [value or field]: Value is required Failed to execute (Buffer).</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec216"/>How it works…</h2></div></div></div><p>What <a id="id811" class="indexterm"/>
<a id="id812" class="indexterm"/>you see in the output error message isn't terribly informative. If you are a fairly experienced programmer, you'll generally be able to make out what the problem is. In this case we did not include a buffer distance. However, in many cases, the returned error message will not give you much information that you can use to resolve the problem. Errors in your code are simply a fact of life in programming. However, how your code responds to these errors, also called exceptions, is very important. You should plan to handle errors gracefully through the use of Python error handling structures, which examine <code class="literal">arcpy</code> generated exceptions and act accordingly. Without these structures in place, your scripts will fail immediately, frustrating your users in the process.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec85"/>Adding Python exception handling structures (try/except/finally)</h1></div></div></div><p>Python has built-in exception handling structures that allow you to capture error messages that are generated. Using this error information, you can then display a more appropriate message to the end user and respond to the situation as needed.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec217"/>Getting ready</h2></div></div></div><p>Exceptions are <a id="id813" class="indexterm"/>
<a id="id814" class="indexterm"/>unusual or error conditions that occur in your code. Exception statements in Python enable you to trap and handle errors in your code, allowing you to gracefully recover from error conditions. In addition to error handling, exceptions can be used for a variety of other things including event notification and special-case handling. </p><p>Python exceptions occur in two ways. Exceptions in Python can either be intercepted or triggered. When an error condition occurs in your code, Python automatically triggers an exception, which may or may not be handled by your code. It is up to you as a programmer to catch an automatically triggered exception. Exceptions can also be triggered manually by your code. In this case, you would also provide an exception handling routine to catch these manually triggered exceptions. You can manually trigger an exception by using the <code class="literal">raise</code> statement. </p><p>The <code class="literal">try</code>/<code class="literal">except</code> statement<a id="id815" class="indexterm"/> is a complete, compound Python statement used to handle exceptions. This variety of <code class="literal">try</code> statement starts with a <code class="literal">try</code> header line followed by a block of indented statements, then one or more optional <code class="literal">except</code> clauses that name exceptions to be caught, and an optional <code class="literal">else</code> clause at the end. </p><p>The <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code> statement<a id="id816" class="indexterm"/> works as follows. Once inside a <code class="literal">try</code> statement, Python marks the fact that you are in a <code class="literal">try</code> block and knows that any exception condition that occurs within this block will be forwarded to the various <code class="literal">except</code> statements for handling. </p><p>Each statement inside the <code class="literal">try</code> block is executed. Assuming that no exception conditions occur, the code pointer will then jump to the <code class="literal">else</code> statement and execute the code block contained within the <code class="literal">else</code> statement before moving to the next line of code below the <code class="literal">try</code> block. If an exception occurs inside the <code class="literal">try</code> block, Python searches for a matching exception code. If a matching exception is found, the code block inside the <code class="literal">except</code> block is executed. The code then picks up below the full <code class="literal">try</code> statement. The <code class="literal">else</code> statements are not executed in this case. If a matching exception header is not found, Python will propagate the exception to a <code class="literal">try</code> statement above this code block. In the event that no matching <code class="literal">except</code> header is found, the exception comes out of the top level of the process. This results in an unhandled exception and you wind up with the type of error message that we saw in our first recipe in this chapter.</p><p>In this recipe, we're going to add in some basic Python exception handling structures. There are several variations of the <code class="literal">try</code>/<code class="literal">except</code>/<code class="literal">else</code>/<code class="literal">finally</code> exception handling structure. In this recipe, we'll start with a very simple <code class="literal">try</code>/<code class="literal">except</code> structure.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec218"/>How to do it…</h2></div></div></div><p>Follow the <a id="id817" class="indexterm"/>
<a id="id818" class="indexterm"/>steps below to add Python error handling structures to a script:</p><div><ol class="orderedlist arabic"><li class="listitem">If necessary, open the <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code> file in IDLE.</li><li class="listitem">Alter your script to include a <code class="literal">try</code>/<code class="literal">except</code> block:<div><pre class="programlisting">import arcpy
try:
  arcpy.env.workspace = "c:/ArcpyBook/data"
  arcpy.Buffer_analysis("Streams.shp","Streams_Buff.shp")
except:
  print "Error"</pre></div></li><li class="listitem">Save and run the script. You should see the simple message <code class="literal">Error</code>. That's not any more helpful than the output we received in our first recipe. In fact, it's even less useful. However, the point of this recipe is simply to introduce you to the <code class="literal">try</code>/<code class="literal">except</code> error handling structure. </li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec219"/>How it works…</h2></div></div></div><p>This is an extremely simple structure. The <code class="literal">try</code> block indicates that everything indented under the <code class="literal">try</code> statement will be subject to exception handling. If an exception of any type is found, control of the code processing jumps to the <code class="literal">except</code> section and prints the error message(s), which in this case is simply <code class="literal">Error</code>. Now, as I mentioned, this is hardly informative to your users, but hopefully it gives you a basic idea of how <code class="literal">try</code>/<code class="literal">except</code> blocks work, and as a programmer you will better understand any errors reported by your users. In the next recipe, you'll learn how to add tool-generated messages to this structure.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec220"/>There's more…</h2></div></div></div><p>The other<a id="id819" class="indexterm"/>
<a id="id820" class="indexterm"/> type of <code class="literal">try</code> statement is the <code class="literal">try</code>/<code class="literal">finally</code> statement, which allows for finalization actions. When a <code class="literal">finally</code> clause is used in a <code class="literal">try</code> statement, its block of statements always run at the very end, whether an error condition occurs or not. The <code class="literal">try</code>/<code class="literal">finally</code> statement works as follows. If an exception occurs, Python runs the <code class="literal">try</code> block, then the <code class="literal">finally</code> block, and then execution continues past the entire <code class="literal">try</code> statement. If an exception does not occur during execution, Python runs the <code class="literal">try</code> block, then the <code class="literal">finally</code> block, and then execution is passed back to a higher level <code class="literal">try</code> statement. This is useful when you want to make sure an action takes place after a code block runs regardless of whether or not an error condition occurs.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec86"/>Retrieving tool messages with GetMessages()</h1></div></div></div><p>ArcPy includes <a id="id821" class="indexterm"/>a <code class="literal">GetMessages()</code> function that you can use to retrieve messages generated when an ArcGIS tool is executing. Messages can include informational messages, such as the start and ends times of a tool execution as well as warnings and errors, which can result in something less than the desired result or complete failure of the tool to execute to completion.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec221"/>Getting ready</h2></div></div></div><p>During the <a id="id822" class="indexterm"/>
<a id="id823" class="indexterm"/>execution of a tool, various messages are generated. These messages include informational messages, such as the start and end times of a tool execution, parameter values passed to the tool, and progress information. In addition, warnings and errors can also be generated by the tool. These messages can be read by your Python script, and your code can be designed to appropriately handle any warnings or errors that have been generated. </p><p>ArcPy stores the messages from the last tool that was executed and you can retrieve these messages using the <code class="literal">GetMessages()</code> function, which returns a single string containing all messages from the tool that was last executed. You can filter this string by severity to return only certain types of messages, such as warnings or errors. The first message will always include the name of the tool executed, and the last message is the start and end time. </p><p>In this recipe, <a id="id824" class="indexterm"/>
<a id="id825" class="indexterm"/>you will add a line of code to the <code class="literal">except</code> statement, which will print more descriptive information about the current tool run.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec222"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to add a <code class="literal">GetMessages()</code> function to your script that generates a list of messages from the tool last executed.</p><div><ol class="orderedlist arabic"><li class="listitem">If necessary, open the <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code> file in IDLE.</li><li class="listitem">Alter your script to include the <code class="literal">GetMessages()</code> function:<div><pre class="programlisting">import arcpy
try:
  arcpy.env.workspace = "c:/ArcpyBook/data"
  arcpy.Buffer_analysis("Streams.shp","Streams_Buff.shp")
except:
  print arcpy.GetMessages()</pre></div></li><li class="listitem">Save and run the script. This time, the error message should be much more informative. Also notice that there are other types of messages that are generated including the start and end times of the script's execution:<div><pre class="programlisting">
<strong>Executing: Buffer c:/ArcpyBook/data\Streams.shp c:/ArcpyBook/data\Streams_Buff.shp # FULL ROUND NONE #</strong>
<strong>Start Time: Tue Nov 13 22:23:04 2012</strong>
<strong>Failed to execute. Parameters are not valid.</strong>
<strong>ERROR 000735: Distance [value or field]: Value is required</strong>
<strong>Failed to execute (Buffer).</strong>
<strong>Failed at Tue Nov 13 22:23:04 2012 (Elapsed Time: 0.00 seconds)</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec223"/>How it works…</h2></div></div></div><p>The <code class="literal">GetMessages()</code> function returns all the messages generated by the last tool that was run. I want to emphasize that it only returns messages from the last tool that was run. Keep this in mind if you have a script with multiple tools that are being run. Historical tool run messages are not accessible through this function. However, there is a <code class="literal">Result</code> object that <a id="id826" class="indexterm"/>
<a id="id827" class="indexterm"/>you can use if you need to retrieve historical tool run messages.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec87"/>Filtering tool messages by severity level</h1></div></div></div><p>As I mentioned in the<a id="id828" class="indexterm"/>
<a id="id829" class="indexterm"/> last recipe, all tools generate a number of messages that can be classified as information, warning, or error messages. The <code class="literal">GetMessages()</code> method accepts a parameter that allows you to filter the messages that are returned. For example, you may not be interested in the informative or warning messages in your script. However, you are certainly interested in error messages as they indicate a fatal error that will not allow a tool to successfully execute. Using <code class="literal">GetMessages()</code>, you can filter the returned message to only error messages.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec224"/>Getting ready</h2></div></div></div><p>Messages are classified into one of the three types, which are indicated by a severity level. <strong>Informational messages</strong> <a id="id830" class="indexterm"/>provide descriptive information concerning things such as a tools progress, start and end times of the tool, output data characteristics, and much more. The severity level of an informational message is indicated by a value of <code class="literal">0</code>. <strong>Warning messages</strong> a<a id="id831" class="indexterm"/>re generated when a problem has occurred during execution that may affect the output. Warnings are indicated with a severity level of <code class="literal">1</code> and don't normally stop a tool from running. The last type of message is an <a id="id832" class="indexterm"/>
<strong>error message</strong>, which is indicated with a numeric value of <code class="literal">2</code>. These indicate fatal events that prevent a tool from running. Multiple messages may be generated during the execution of a tool, and these are stored in a list. More information about message severity levels is provided in the following image. In this recipe, you will learn how to filter the messages generated by the <code class="literal">GetMessages()</code> function.</p><div><img src="img/4445OT_Chapter_12_01.jpg" alt="Getting ready"/></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec225"/>How to do it…</h2></div></div></div><p>Filtering the <a id="id833" class="indexterm"/>
<a id="id834" class="indexterm"/>messages returned by a tool is really quite simple. You simply provide the severity level you'd like to return as a parameter to the <code class="literal">GetMessages()</code> function.</p><div><ol class="orderedlist arabic"><li class="listitem">If necessary, open the <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code> file in IDLE.</li><li class="listitem">Alter the <code class="literal">GetMessages()</code> function so that you pass in a value of <code class="literal">2</code> as the only parameter:<div><pre class="programlisting">import arcpy
try:
  arcpy.env.workspace = "c:/ArcpyBook/data"
  arcpy.Buffer_analysis("Streams.shp","Streams_Buff.shp")
except:
  print arcpy.GetMessages(2)</pre></div></li><li class="listitem">Save and run the script to see the output:<div><pre class="programlisting">
<strong>Failed to execute. Parameters are not valid.</strong>
<strong>ERROR 000735: Distance [value or field]: Value is required</strong>
<strong>Failed to execute (Buffer).</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec226"/>How it works…</h2></div></div></div><p>As I mentioned, the <code class="literal">GetMessages()</code> method can accept an integer argument of <code class="literal">0</code>, <code class="literal">1</code>, or <code class="literal">2</code>. Passing a value of <code class="literal">0</code> indicates that all messages should be returned, while passing a value of <code class="literal">1</code> indicates that you wish to see warnings. In our case, we have passed a value of <code class="literal">2</code>, which indicates that we only want to see error messages. Therefore, you won't see any of the other<a id="id835" class="indexterm"/>
<a id="id836" class="indexterm"/> information messages, such as the start and end times of the script.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec88"/>Testing for and responding to specific error messages</h1></div></div></div><p>All errors and warnings<a id="id837" class="indexterm"/> generate a specific error code. It is possible to check for<a id="id838" class="indexterm"/> specific error codes in your scripts and perform some type of action based on these errors. This can make your scripts even more versatile.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec227"/>Getting ready…</h2></div></div></div><p>All errors and warnings generated by a geoprocessing tool contain both a six digit code and a description.Your script can test for specific error codes and respond accordingly.You can get a listing of all the available error messages and codes in the ArcGIS Desktop help system by going to <strong>Geoprocessing</strong> | <strong>Tool errors and warnings</strong>.This is illustrated in the following screenshot.All errors will have a unique page that briefly describes the error by code number:</p><div><img src="img/4445_12_1.jpg" alt="Getting ready…"/></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec228"/>How to do it…</h2></div></div></div><p>Follow these <a id="id839" class="indexterm"/>steps to learn how to write a code that responds to specific error code <a id="id840" class="indexterm"/>generated by the execution of a geoprocessing tool:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the ArcGIS Desktop help system by going to <strong>Start</strong> | <strong>Programs</strong> | <strong>ArcGIS</strong> | <strong>ArcGIS for Desktop Help</strong>.</li><li class="listitem">Go to <strong>Geoprocessing</strong> | <strong>Tool errors and warnings</strong> | <strong>Tool errors 1-10000</strong> |<strong>Tool errors and warnings: 701-800</strong>.</li><li class="listitem">Select <strong>000735: &lt;value&gt;: Value is required</strong>.This error indicates that a parameter required by the tool has not been provided.You’ll recall from running this script that we have not provided the buffer distance and that the error message generated, as a result, contains the error code that we are viewing in the help system.In the following code, you will find the full text of the error message.Notice the error code.<div><pre class="programlisting">ERROR000735:Distance[valueorfield]:Valueisrequired</pre></div></li><li class="listitem">If necessary, open the <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code> file in IDLE.</li><li class="listitem">In your script, alter the <code class="literal">except</code> statement, so that it appears as follows:<div><pre class="programlisting">except:
 print “Error found in Buffer tool \n”
errCode = arcpy.GetReturnCode(3)
 if str(errCode) in “735”:
 print “Distance value not provided \n”
 print “Running the buffer again with a default value \n”
defaultDistance = “100 Feet”
arcpy.Buffer_analysis(“Streams.shp”, “Streams_Buff”, defaultDistance)
 print “Buffer complete”</pre></div></li><li class="listitem">Save and run the script.You should see various messages printed, as follows:<div><pre class="programlisting">Error found in Buffer tool
Distance value not provided for buffer
Running the buffer again with a default distance value
Buffer complete</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec229"/>How it works…</h2></div></div></div><p>What <a id="id841" class="indexterm"/>you’ve done in this code block is use the <code class="literal">arcpy.GetReturnCode()</code> function<a id="id842" class="indexterm"/> to return the <a id="id843" class="indexterm"/>error code generated by the tool.Then, an <code class="literal">if</code> statement is used to test if the error code contains the value <code class="literal">735</code>, which is the code that indicates that a required parameter has not been provided to the tool.You then provided a default value for the buffer distance and called the <code class="literal">Buffer</code> tool<a id="id844" class="indexterm"/> again; providing the default buffer value this time.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec89"/>Returning individual messages with GetMessage()</h1></div></div></div><p>While <code class="literal">GetMessages()</code> returns a list containing all messages from the last tool run, you can also get individual messages from the string using <code class="literal">GetMessage()</code>.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec230"/>Getting ready</h2></div></div></div><p>Up to this point, we have <a id="id845" class="indexterm"/>
<a id="id846" class="indexterm"/>been returning all messages generated by the tool. However, you can return individual messages to your user through the <code class="literal">GetMessage()</code> method, which takes an integer as a parameter indicating the particular message you'd like to retrieve. Each message generated by the tool is placed into a message list or array. We discussed list objects earlier in the book, so you'll remember that this is just a collection of some type of object. Just as a reminder: lists are zero-based, meaning that the first item in the list is located at position <code class="literal">0</code>. For example, <code class="literal">GetMessage(0)</code> would return the first message in the list, while <code class="literal">GetMessage(1)</code> would return the second message in the list. The first message will always be the tool being executed along with any parameters. The second message returns the start time of the script, while the last message returns the end time of the script.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec231"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">If necessary, open the <code class="literal">c:\ArcpyBook\Ch12\ErrorHandling.py</code> file in IDLE.</li><li class="listitem">Alter the <code class="literal">except</code> block as follows:<div><pre class="programlisting">import arcpy
try:
  arcpy.env.workspace = "c:/ArcpyBook/data"
  arcpy.Buffer_analysis("Streams.shp","Streams_Buff.shp")
except:
  print arcpy.GetMessage(1)
  print arcpy.GetMessage(arcpy.GetMessageCount() – 1)</pre></div></li><li class="listitem">Save and run the script to see the output:<div><pre class="programlisting">
<strong>Start Time: Wed Nov 14 09:07:35 2012</strong>
<strong>Failed at Wed Nov 14 09:07:35 2012 (Elapsed Time: 0.00 seconds)</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec232"/>How it works...</h2></div></div></div><p>We haven't covered the <code class="literal">GetMessageCount()</code> function yet. This function returns the number of messages returned by the tool. Remember that our list of messages is zero-based, so we have to subtract one from the <code class="literal">GetMessageCount()</code>function to arrive at the last message in the list. Otherwise, we'd be attempting to access a message that does not exist. In this script, we have accessed the start and end times of the script. The second message is always the start time for the script, while the last message will always be the end time of the script. This concept is illustrated as follows:</p><div><pre class="programlisting">
<strong>Message 0 - Executing: Buffer c:/ArcpyBook/data\Streams.shp c:/ArcpyBook/data\Streams_Buff.shp # FULL ROUND NONE #</strong>
<strong>Message 1 - Start Time: Tue Nov 13 22:23:04 2012</strong>
<strong>Message 2 - Failed to execute. Parameters are not valid.</strong>
<strong>Message 3 - ERROR 000735: Distance [value or field]: Value is required</strong>
<strong>Message 4 - Failed to execute (Buffer).</strong>
<strong>Message 5 - Failed at Tue Nov 13 22:23:04 2012 (Elapsed Time: 0.00 seconds)</strong>
</pre></div><p>Total message<a id="id847" class="indexterm"/>
<a id="id848" class="indexterm"/> count is <code class="literal">6</code>, but the last message is number <code class="literal">5</code>. This is because the count starts with <code class="literal">0</code>. This is why you need to subtract <code class="literal">1</code> as stated previously. In this case, the start and end times are the same, because the script contains an error. However, it does illustrate how to access the individual messages generated by the tool.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="appA"/>Appendix A. Automating Python Scripts</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running Python scripts from the command line</li><li class="listitem" style="list-style-type: disc">Using sys.argv[] to capture command-line input</li><li class="listitem" style="list-style-type: disc">Adding Python scripts to batch files</li><li class="listitem" style="list-style-type: disc">Scheduling batch files to run at prescribed times</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec90"/>Introduction</h1></div></div></div><p>Python geoprocessing scripts can be executed either outside ArcGIS as a standalone script or inside ArcGIS as a script tool. Both methods have their advantages and disadvantages. Up to this point in the book, all our scripts have been run either inside ArcGIS as a script tool, or from a Python development environment such as IDLE, or the Python Window in ArcGIS. However, Python scripts can also be executed from the Windows operating system command line. The command line is a window that you can use to type in commands rather than the usual point-and-click approach provided by Windows. This method of running Python scripts is useful for scheduling the execution of a script. There are a number of reasons why you might want to schedule your scripts. Many geoprocessing scripts take a long time to fully execute and need to be scheduled to run during non-working hours on a regular basis. Additionally, some scripts need to be executed on a routine basis (every day, week, month, and so on), and should be scheduled for efficiency. In this chapter, you will learn how to execute scripts from the command line, place scripts inside batch files, and schedule the execution of scripts at prescribed times. Please keep in mind that any scripts run from the command line will still need access to an ArcGIS Desktop license in order to use the <code class="literal">arcpy</code> module.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec91"/>Running Python scripts from the command line</h1></div></div></div><p>Up to this point in the book, all your Python scripts have been run as either script tools in ArcGIS or from a Python development environment. The Windows command prompt provides yet another way of executing your Python scripts. The command prompt is used primarily to execute scripts that will be run as a part of a batch file and/or as scheduled tasks.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec233"/>Getting ready</h2></div></div></div><p>There are a <a id="id849" class="indexterm"/>
<a id="id850" class="indexterm"/>couple of advantages to running Python geoprocessing scripts from the command prompt. These scripts can be scheduled to batch process your data during off hours for more efficient processing, and they are easier to debug due to the built-in Python error handling and debugging capabilities.</p><p>In this recipe, you will learn how to use the Windows command prompt to execute a Python script. You will need administrative rights to complete this recipe, so you may need to contact your information technology support group to make this change.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec234"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to run a script from the Windows command prompt:</p><div><ol class="orderedlist arabic"><li class="listitem">In Windows, go to <strong>Start</strong> | <strong>All Programs</strong> | <strong>Accessories</strong> | <strong>Command Prompt</strong> to display a window similar to the following screenshot:<div><img src="img/4445_A1_1.jpg" alt="How to do it…"/></div><p>The window will display the current directory. Your directory will differ to some degree. Let's change to the directory for this appendix.</p></li><li class="listitem">Type <code class="literal">cd c:\ArcpyBook\Appendix1</code>.</li><li class="listitem">Type dir to see a listing of the files and sub-directories. You should see only a single Python file called <code class="literal">ListFields.py</code>:<div><img src="img/4445_A1_2.jpg" alt="How to do it…"/></div></li><li class="listitem">You will <a id="id851" class="indexterm"/><a id="id852" class="indexterm"/>want to make sure that the Python interpreter can be run from anywhere in your directory structure. Go to <strong>Start</strong> | <strong>All Programs</strong> | <strong>Accessories</strong> | <strong>System Tools</strong> | <strong>Control Panel</strong>.<div><img src="img/4445_A1_3.jpg" alt="How to do it…"/></div></li><li class="listitem">Click on <a id="id853" class="indexterm"/><a id="id854" class="indexterm"/><strong>System and Security</strong>.</li><li class="listitem">Click on <strong>System</strong>.</li><li class="listitem">Click on <strong>Advanced system settings</strong>.</li><li class="listitem">In the <strong>System Properties</strong> dialog box, select the <strong>Advanced</strong> tab and then the <strong>Environment Variables</strong> button as shown in the following screenshot:<div><img src="img/4445_A1_4.jpg" alt="How to do it…"/></div></li><li class="listitem">Find the <a id="id855" class="indexterm"/><a id="id856" class="indexterm"/><strong>Path</strong> system variable seen in the screenshot below and click on <strong>Edit</strong>.<div><img src="img/4445_A1_5.jpg" alt="How to do it…"/></div></li><li class="listitem">Examine <a id="id857" class="indexterm"/><a id="id858" class="indexterm"/>the entire text string for the directory <code class="literal">c:\Python27\ArcGIS10.1</code>. If the text string isn't found, add it to the end. Make sure that you add a semi-colon before adding the path. Now, when you type <code class="literal">python</code> in the command prompt, it will look through each of the directories in the <strong>Path</strong> system variable, checking for an executable called <code class="literal">python.exe</code>. <div><img src="img/4445_A1_6.jpg" alt="How to do it…"/></div></li><li class="listitem">Click on <a id="id859" class="indexterm"/><a id="id860" class="indexterm"/><strong>OK</strong> to dismiss the <strong>Edit System Variable</strong> dialog box.</li><li class="listitem">Click on <strong>OK</strong> to dismiss the <strong>Environment Variables</strong> dialog box.</li><li class="listitem">Click on <strong>OK</strong> to dismiss the <strong>System Properties</strong> dialog box.</li><li class="listitem">Return to the command prompt. </li><li class="listitem">Type <code class="literal">python ListFields.py</code>. This will run the <code class="literal">ListFields.py</code> script. After a brief delay, you should see the following output:<div><img src="img/4445_A1_7.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec235"/>How it works…</h2></div></div></div><p>The <code class="literal">ListFields.py</code> script<a id="id861" class="indexterm"/> provided for you in this recipe is a simple script that lists the attribute fields for the <code class="literal">Burglaries_2009.shp</code> file. The workspace and shapefile name are hardcoded in the script. Typing <code class="literal">python</code> followed by the name of the script, which is <code class="literal">ListFields.py</code> in this <a id="id862" class="indexterm"/>
<a id="id863" class="indexterm"/>case, triggered the execution of a script using the Python interpreter. As I mentioned, the workspace and shapefile name were hardcoded in this script. In the next recipe, you will learn how to pass in arguments to the script, so that you can remove the hardcoding and make your script more flexible.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec92"/>Using sys.argv[ ] to capture command-line input</h1></div></div></div><p>Instead of hardcoding your scripts with paths to specific datasets, you can make your scripts more flexible by allowing them to accept input in the form of parameters from the command prompt. These input parameters can be captured using <a id="id864" class="indexterm"/>Python's <code class="literal">sys.argv[]</code> object.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec236"/>Getting ready</h2></div></div></div><p>Python's <code class="literal">sys.argv[]</code> object <a id="id865" class="indexterm"/>
<a id="id866" class="indexterm"/>allows you to capture input parameters from the command line when a script is executed. An example is useful for illustrating how this works. Take a look at the following screenshot:</p><div><img src="img/4445_A1_8.jpg" alt="Getting ready"/></div><p>Each word must be separated by a space. These words are stored in a zero-based list object called <code class="literal">sys.argv[]</code>. With <code class="literal">sys.argv[]</code>, the first item in the list, referenced by index <code class="literal">0</code>, stores the name of the script. In this case, it would be <code class="literal">ListFields.py</code>. Each successive word is referenced by the next integer. Therefore, the first parameter (<code class="literal">c:\ArcpyBook\data</code>) will be stored in <code class="literal">sys.argv[1]</code>, and the second parameter (<code class="literal">Burglaries.shp</code>) will be stored in <code class="literal">sys.argv[2]</code>. Each of the arguments in the <code class="literal">sys.argv[]</code> object can be accessed and used inside your geoprocessing script. In this recipe, you're going to update the <code class="literal">ListFields.py</code> script to accept input parameters from the command line.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec237"/>How to do it...</h2></div></div></div><p>Follow these<a id="id867" class="indexterm"/>
<a id="id868" class="indexterm"/> steps to create a Python script that can accept input parameters from the command prompt using <code class="literal">sys.argv[]</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">C:\ArcpyBook\Appendix1\ListFields.py</code> in IDLE.</li><li class="listitem">Import the <code class="literal">sys</code> module:<div><pre class="programlisting">import arcpy, sys</pre></div></li><li class="listitem">Create a variable to hold the workspace that will be passed into the script:<div><pre class="programlisting">wkspace = sys.argv[1]</pre></div></li><li class="listitem">Create a variable to hold the feature class that will be passed into the script:<div><pre class="programlisting">fc = sys.argv[2]</pre></div></li><li class="listitem">Update the lines of code that set the workspace and <a id="id869" class="indexterm"/>call the <code class="literal">ListFields()</code> function:<div><pre class="programlisting">arcpy.env.workspace = wkspace
fields = arcpy.ListFields(fc)</pre></div><p>Your completed script should appear as follows:</p><div><pre class="programlisting">import arcpy, sys
wkspace = sys.argv[1]
fc = sys.argv[2]
try:
  arcpy.env.workspace = wkspace
  fields = arcpy.ListFields(fc)
  for fld in fields:
    print fld.name
except:
  print arcpy.GetMessages()</pre></div></li><li class="listitem">Save the script.</li><li class="listitem">If necessary, open the command prompt and navigate to <code class="literal">c:\ArcpyBook\Appendix1</code>.</li><li class="listitem">On the command line, type the following and press on the <em>Enter</em> key:<div><pre class="programlisting">python ListFields.py c:\ArcpyBook\data Burglaries_2009.shp</pre></div></li><li class="listitem">Once again you should see the output detailing the attribute fields for the <code class="literal">Burglaries_2009.shp</code> file. The difference is that your script no longer has a hardcoded workspace and feature class name. You now have a more flexible script capable of listing the attribute fields for any feature class.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec238"/>How it works...</h2></div></div></div><p>The <code class="literal">sys</code> <a id="id870" class="indexterm"/>
<a id="id871" class="indexterm"/>module contains a list of objects called <code class="literal">argv[]</code>, which is used to store the input parameters for the command-line execution of a Python script. The first item stored in the list is always the name of the script. So, in this case, <code class="literal">sys.argv[0]</code> contains the word <code class="literal">ListFields.py</code>. Two parameters are passed into the script, including the workspace and a feature class. These are stored in <code class="literal">sys.argv[1]</code> and <code class="literal">sys.argv[2]</code> respectively. These values are then assigned to variables and used in the script. </p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec93"/>Adding Python scripts to batch files</h1></div></div></div><p>Scheduling your Python scripts to run at prescribed times will require that you create a batch file containing one or more scripts and/or operating system commands. These batch files can then be added to the Windows Scheduler to run at a specific time interval.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec239"/>Getting ready</h2></div></div></div><p>Batch files are text<a id="id872" class="indexterm"/>
<a id="id873" class="indexterm"/> files containing command-line sequences for running Python scripts or performing operating system commands. They have a file extension of <code class="literal">.bat</code>, which Windows recognizes as an executable file. Since batch files simply contain command-line sequences, they can be written with any text editor, though it is recommended that you use a basic text editor such as Notepad, so that you can avoid the inclusion of invisible special characters, which are sometimes inserted by programs such as Microsoft Word. In this recipe, you will create a simple batch file that navigates to the directory containing your <code class="literal">ListFields.py</code> script and executes it.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec240"/>How to do it...</h2></div></div></div><p>Follow these steps to create a batch file:</p><div><ol class="orderedlist arabic"><li class="listitem">Open a notepad.</li><li class="listitem">Add the following lines of text to the file:<div><pre class="programlisting">cd c:\ArcpyBook\Appendix1
python ListFields.py c:\ArcpyBook\data Burglaries_2009.shp</pre></div></li><li class="listitem">Save the file to your desktop as <code class="literal">ListFields.bat</code>. Make sure you change the <strong>Save as Type</strong> drop-down list to <strong>All Files</strong>, or else you'll wind up with a file called <code class="literal">ListFields.bat.txt</code>.</li><li class="listitem">In Windows, navigate to your desktop and double-click on <code class="literal">ListFields.bat</code> to execute the sequence of commands.</li><li class="listitem">A command prompt will be displayed during execution. After the commands have been executed, the command prompt will automatically close. </li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec241"/>How it works...</h2></div></div></div><p>Windows treats a batch file as an executable, so double-clicking on the file will automatically execute the sequence of commands contained within the file in a new command prompt window. All <code class="literal">print</code> statements will be written to the window. After the commands have been executed, the command prompt will automatically close. In the event that you need to keep track of the output, you can write the statements to an output log file. </p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec242"/>There's more...</h2></div></div></div><p>Batch files<a id="id874" class="indexterm"/>
<a id="id875" class="indexterm"/> can contain variables, loops, comments, and conditional logic. This functionality is beyond the scope of this recipe. However, if you'll be writing and running many scripts for your organization, it's worthwhile to spend some time learning more about batch files. Batch files have been around for a long time, so there is no shortage of information about these files on the Web. For more information about batch files, please consult the Wikipedia page for this topic.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec94"/>Scheduling batch files to run at prescribed times</h1></div></div></div><p>Once created, your batch files can then be scheduled to run at prescribed times using the Windows Scheduler. </p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec243"/>Getting ready</h2></div></div></div><p>Many geoprocessing scripts are time-intensive and best run after hours when they can take full advantage of system resources and free up your time to concentrate on other tasks. In this recipe, you will learn how to use the Windows Scheduler to schedule the execution of your batch files.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec244"/>How to do it...</h2></div></div></div><p>Follow these steps to <a id="id876" class="indexterm"/>
<a id="id877" class="indexterm"/>schedule a batch file with the Windows Scheduler:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the Windows Scheduler by going to <strong>Start</strong> | <strong>Programs</strong> | <strong>Accessories</strong> | <strong>System Tools</strong> | <strong>Control Panel</strong> | <strong>Administrative Tools</strong>. Select <strong>Task Scheduler</strong>. The scheduler should appear, as shown in the following screenshot: <div><img src="img/4445_A1_9.jpg" alt="How to do it..."/></div></li><li class="listitem">Select the <a id="id878" class="indexterm"/><a id="id879" class="indexterm"/><strong>Action</strong> menu item and then <strong>Create Basic Task</strong> to display the <strong>Create Basic Task Wizard</strong> dialog box, as shown in the next screenshot.</li><li class="listitem">Give your task a name. In this case, we will call <code class="literal">it List Fields from a Feature Class</code>. Click on <strong>Next</strong>:<div><img src="img/4445_A1_11.jpg" alt="How to do it..."/></div></li><li class="listitem">Select a <a id="id880" class="indexterm"/><a id="id881" class="indexterm"/>trigger for when the task should be executed. This can, and often will be, a time-based trigger, but there can also be other types of triggers such as a user login or computer start. In this case, let's just select <strong>Daily</strong>. Click on <strong>Next</strong>:<div><img src="img/4445_A1_12.jpg" alt="How to do it..."/></div></li><li class="listitem">Select a <a id="id882" class="indexterm"/><a id="id883" class="indexterm"/>start date/time as well as a recurrence interval. In the following screenshot, I have selected the date as <code class="literal">12/3/2012</code>, with time as <code class="literal">1:00:00 AM</code>, and a recurrence interval of 1 day. So, every day at 1:00 AM, this task will be executed. Click on <strong>Next</strong>:<div><img src="img/4445_A1_13.jpg" alt="How to do it..."/></div></li><li class="listitem">Select <a id="id884" class="indexterm"/><a id="id885" class="indexterm"/><strong>Start a program</strong> as the action:<div><img src="img/4445_A1_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Browse to<a id="id886" class="indexterm"/><a id="id887" class="indexterm"/> your script and add the parameters. Click on <strong>Next</strong>:<div><img src="img/4445_A1_15.jpg" alt="How to do it..."/></div></li><li class="listitem">Click on <a id="id888" class="indexterm"/><a id="id889" class="indexterm"/><strong>Finish</strong> to add a task to the scheduler:<div><img src="img/4445_A1_16.jpg" alt="How to do it..."/></div></li><li class="listitem">The <a id="id890" class="indexterm"/><a id="id891" class="indexterm"/>tasks should now be displayed in the list of active tasks:<div><img src="img/4445_A1_17.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec245"/>How it works...</h2></div></div></div><p>The <a id="id892" class="indexterm"/>
<a id="id893" class="indexterm"/>Windows Task Scheduler keeps track of all the active tasks and handles the execution of these tasks when the prescribed trigger is fired. In this recipe, we have scheduled our task to execute each day at 1:00 AM. At that time, the batch file we created will be triggered and the arguments we specified when creating the task will be passed into the script. Using the scheduler to automatically execute geoprocessing tasks after hours without the need for GIS staff to interact with the scripts gives you more flexibility and increases your efficiency. You might also want to consider logging the errors in your Python scripts to a log file, for more information about specific problems.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="appB"/>Appendix B. Five Things Every GIS Programmer Should Know How to Do with Python</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reading data from a delimited text file</li><li class="listitem" style="list-style-type: disc">Sending e-mails</li><li class="listitem" style="list-style-type: disc">Retrieving files from an FTP server</li><li class="listitem" style="list-style-type: disc">Creating ZIP files</li><li class="listitem" style="list-style-type: disc">Reading XML files</li></ul></div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec95"/>Introduction</h1></div></div></div><p>In this chapter, you will learn how to write scripts that perform general purpose tasks with Python. Tasks, such as reading and writing delimited text files, sending e-mails, interacting with FTP servers, creating <code class="literal">.zip</code> files, and reading and writing JSON and XML files. Every GIS programmer should know how to write Python scripts that incorporate this functionality.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec96"/>Reading data from a delimited text file</h1></div></div></div><p>File handling <a id="id894" class="indexterm"/>with Python is a very important topic for GIS programmers. Text files <a id="id895" class="indexterm"/>are often used as an interchange format for exchanging data between systems. They are simple, cross-platform, and easy to process. Comma-and tab-delimited text files are among the most commonly used formats for text files, so we'll take an extensive look at the Python tools available for processing these files. A common task for GIS programmers is to read comma-delimited text files containing x and y coordinates along with other attribute information. This information is then converted into GIS data formats, such as shapefiles<a id="id896" class="indexterm"/> or <a id="id897" class="indexterm"/>geodatabases. </p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec246"/>Getting ready</h2></div></div></div><p>To use Python's built-in <a id="id898" class="indexterm"/>
<a id="id899" class="indexterm"/>
<a id="id900" class="indexterm"/>file processing functionality, you must first open the file. Once open, data within the file is processed using functions provided by Python, and finally the file is closed. Always remember to close the file when you're done. </p><p>In this recipe, you will learn how to open, read, process, and close a comma-delimited text file.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec247"/>How to do it…</h2></div></div></div><p>Follow these steps to create a Python script that reads a comma-delimited text file:</p><div><ol class="orderedlist arabic"><li class="listitem">In your <code class="literal">c:\ArcpyBook\data</code> folder, you will find a file called <code class="literal">N_America.A2007275.txt</code>. Open this file in a text editor. It should appear as follows:<div><pre class="programlisting">
<strong>18.102,-94.353,310.7,1.3,1.1,10/02/2007,0420,T,72</strong>
<strong>19.300,-89.925,313.6,1.1,1.0,10/02/2007,0420,T,82</strong>
<strong>19.310,-89.927,309.9,1.1,1.0,10/02/2007,0420,T,68</strong>
<strong>26.888,-101.421,307.3,2.7,1.6,10/02/2007,0425,T,53</strong>
<strong>26.879,-101.425,306.4,2.7,1.6,10/02/2007,0425,T,45</strong>
<strong>36.915,-97.132,342.4,1.0,1.0,10/02/2007,0425,T,100</strong>
</pre></div><p>This file contains wildfire incident data derived from a satellite sensor from a single day in 2007. Each row contains latitude and longitude information for the fire along with additional information, including the date and time, the satellite type, confidence value, and others. In this recipe, you are going to pull out only the latitude, longitude, and confidence value.</p></li><li class="listitem">Open IDLE and create a file called <code class="literal">c:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py</code>.</li><li class="listitem">Use the Python <code class="literal">open()</code> function to open the file for reading:<div><pre class="programlisting">f = open("c:/ArcpyBook/data/N_America.A2007275.txt','r')</pre></div></li><li class="listitem">Read the content of the text file into a list:<div><pre class="programlisting">lstFires = f.readlines()</pre></div></li><li class="listitem">Add a <code class="literal">for</code> loop to iterate all the rows that have been read into the <code class="literal">lstFires</code> variable:<div><pre class="programlisting">for fire in lstFires:</pre></div></li><li class="listitem">Use the <code class="literal">split()</code> function<a id="id901" class="indexterm"/> to split the values into a list using a comma as the delimiter. The list will be assigned to a variable called <code class="literal">lstValues</code>. Make sure that you indent this line of code inside the <code class="literal">for</code> loop you just created:<div><pre class="programlisting">lstValues = fire.split(",")</pre></div></li><li class="listitem">Using the index values that reference latitude, longitude, and confidence values, create new variables:<div><pre class="programlisting">latitude = float(lstValues[0])
longitude = float(lstValues[1])
confid = int(lstValues[8])</pre></div></li><li class="listitem">Print the values of each with the <code class="literal">print</code> statement:<div><pre class="programlisting">print "The latitude is: " + str(latitude) + " The longitude is: " + str(longitude) + " The confidence value is: " + str(confid)</pre></div></li><li class="listitem">Close the file:<div><pre class="programlisting">f.close()</pre></div></li><li class="listitem">The entire<a id="id902" class="indexterm"/><a id="id903" class="indexterm"/><a id="id904" class="indexterm"/> script should appear as follows:<div><pre class="programlisting">f = open('c:/ArcpyBook/data/N_America.A2007275.txt','r')
lstFires = f.readlines()
for fire in lstFires:
  lstValues = fire.split(',')
  latitude = float(lstValues[0])
  longitude = float(lstValues[1])
  confid = int(lstValues[8])
  print "The latitude is: " + str(latitude) + " The longitude is: " + str(longitude) + " The confidence value is: " + str(confid)
f.close()</pre></div></li><li class="listitem">Save and run the script. You should see the following output:<div><pre class="programlisting">
<strong>The latitude is: 18.102 The longitude is: -94.353 The confidence value is: 72</strong>
<strong>The latitude is: 19.3 The longitude is: -89.925 The confidence value is: 82</strong>
<strong>The latitude is: 19.31 The longitude is: -89.927 The confidence value is: 68</strong>
<strong>The latitude is: 26.888 The longitude is: -101.421 The confidence value is: 53</strong>
<strong>The latitude is: 26.879 The longitude is: -101.425 The confidence value is: 45</strong>
<strong>The latitude is: 36.915 The longitude is: -97.132 The confidence value is: 100</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec248"/>How it works…</h2></div></div></div><p>Python's <code class="literal">open()</code> function<a id="id905" class="indexterm"/> creates a file object, which serves as a link to a file residing on your computer. You must call the <code class="literal">open()</code> function on a file before reading or writing data in a file. The first parameter for the <code class="literal">open()</code> function is a path to the file you'd like to open. The second parameter of the <code class="literal">open()</code> function corresponds to a mode, which is typically read (<code class="literal">r</code>), write (<code class="literal">w</code>), or append (<code class="literal">a</code>). A value of <code class="literal">r</code> indicates that you'd like to open the file for read-only operations, while a value of <code class="literal">w</code> indicates you'd like to open the file for write operations. If the file you open in write mode already exists, it will overwrite any existing data in the file, so be careful using this mode. Append mode<a id="id906" class="indexterm"/> (<code class="literal">a</code>) will open a file for write operations, but instead of overwriting any existing data, it will append data to the end of the file. So, in <a id="id907" class="indexterm"/>
<a id="id908" class="indexterm"/>
<a id="id909" class="indexterm"/>this recipe, we have opened the <code class="literal">N_America.A2007275.txt</code> file in read-only mode.</p><p>The <code class="literal">readlines()</code> function<a id="id910" class="indexterm"/> then reads the entire contents of the file into a Python list, which can then be iterated. This list is stored in a variable called <code class="literal">lstFires</code>. Each row in the text file will be a unique value in the list. Since this function reads the entire file into a list, you need to use this method with caution, as large files can cause significant performance problems.</p><p>Inside the <code class="literal">for</code> loop, which is used to loop through each of the values in <code class="literal">lstFires</code>, the <code class="literal">split()</code> function<a id="id911" class="indexterm"/> is used to create a list object from a line of text that is delimited in some way. Our file is comma-delimited, so we can use <code class="literal">split(",")</code>. You can also split based on other delimiters such as tabs, spaces, or any other delimiter. This new list object created by <code class="literal">split()</code> is stored in a variable called <a id="id912" class="indexterm"/> <code class="literal">lstValues</code>. This variable contains each of the wildfire values. This is illustrated in the following screenshot. You'll notice that latitude is located in the first position, longitude is located in the second position, and so on. Lists are zero based:</p><div><img src="img/4445_A2_1.jpg" alt="How it works…"/></div><p>Using the index values (which reference latitude, longitude, and confidence values), we create new variables called <code class="literal">latitude</code>, <code class="literal">longitude</code>, and <code class="literal">confid</code>. Finally, we print each of the values. A more robust geoprocessing script might write this information into a feature class <a id="id913" class="indexterm"/>
<a id="id914" class="indexterm"/>
<a id="id915" class="indexterm"/>using<a id="id916" class="indexterm"/> an <code class="literal">InsertCursor</code> object.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec249"/>There's more...</h2></div></div></div><p>Just as is the case with reading files, there are a number of methods that you can use to write data to a file. The <code class="literal">write()</code> function<a id="id917" class="indexterm"/> is probably the easiest to use. It takes a single string argument and writes it to a file. The <code class="literal">writelines()</code> function<a id="id918" class="indexterm"/> can be used to write the contents of a list structure to a file. Before writing data to a text file, you will need to open the file in either a write or append mode.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec97"/>Sending e-mails</h1></div></div></div><p>There will be occasions when you may need to send an e-mail from a Python script. An example might be an alert for the successful completion or error in a long-running geoprocessing operation. On these and other occasions, sending an e-mail can be helpful.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec250"/>Getting ready</h2></div></div></div><p>Sending an e-mail through a <a id="id919" class="indexterm"/>
<a id="id920" class="indexterm"/>Python script will require that you have access to a mail server. This can be a public e-mail service, such as Yahoo<a id="id921" class="indexterm"/>, Gmail<a id="id922" class="indexterm"/>, or others. It can also use outgoing mail servers configured with applications, such as Microsoft Outlook. In either case, you'll need to know the host name and port of the e-mail server. The Python <code class="literal">smtplib</code> module<a id="id923" class="indexterm"/> is used to create connections to the mail server and to send e-mails. </p><p>The Python <code class="literal">email</code> module<a id="id924" class="indexterm"/> contains a <code class="literal">Message</code> class<a id="id925" class="indexterm"/> that represents e-mail messages. Each message contains both headers and a body. This class can't be used to send e-mails; it just handles its object representation. In this recipe, you'll learn how to use the <code class="literal">smtp</code> class to send e-mails containing an attachment through your script. The <code class="literal">Message</code> class can parse a stream of characters or a file containing an e-mail using either the <code class="literal">message_from_file()</code> <a id="id926" class="indexterm"/> or <a id="id927" class="indexterm"/> <code class="literal">message_from_string()</code> functions. Both will create a new <code class="literal">Message</code> object. The body of the mail can be obtained by calling <code class="literal">Message.getpayload()</code>.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>We are using the Google Mail service for this exercise. If you already have a Gmail account, then simply provide your username and password as the values for these variables. If you don't have a Gmail account, you'll need to create one or use a different mail service to complete this exercise; Gmail accounts are free.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec251"/>How to do it…</h2></div></div></div><p>Follow these <a id="id928" class="indexterm"/>
<a id="id929" class="indexterm"/>steps to create a script that can send emails:</p><div><ol class="orderedlist arabic"><li class="listitem">Open IDLE and create a file called <code class="literal">c:\ArcpyBook\Appendix2\SendEmail.py</code>.</li><li class="listitem">In order to send e-mails with attachments, you're going to need to import the <code class="literal">smtplib</code> module along with the <code class="literal">os</code> module, and several classes from the e-mail module. Add the following <code class="literal">import</code> statements to your script:<div><pre class="programlisting">import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email import Encoders
import os</pre></div></li><li class="listitem">Create the following variables and assign your Gmail username and password as the values. Do keep in mind that this method of e-mailing from your Python script can invite problems, as it requires that you include your username and password:<div><pre class="programlisting">gmail_user = "&lt;username&gt;"
gmail_pwd = "&lt;password&gt;"</pre></div></li><li class="listitem">Create a new Python <a id="id930" class="indexterm"/>function called <code class="literal">mail()</code>. This function will accept four parameters: <code class="literal">to</code>, <code class="literal">subject</code>, <code class="literal">text</code>, and <code class="literal">attach</code>. Each of these parameters should be self-explanatory. Create a new <code class="literal">MIMEMultipart</code> object and assign the <code class="literal">from</code>, <code class="literal">to</code>, and <code class="literal">subject</code> keys. You can also attach the text of the e-mail to this new <code class="literal">msg</code> object using <code class="literal">MIMEMultipart.attach()</code>:<div><pre class="programlisting">def mail(to, subject, text, attach):
  msg = MIMEMultipart()
  msg['From'] = gmail_user
  msg['To'] = to
  msg['Subject'] = subject
  
  msg.attach(MIMEText(text))</pre></div></li><li class="listitem">Attach the file to the e-mail:<div><pre class="programlisting">  part = MIMEBase('application', 'octet-stream')
  part.set_payload(open(attach, 'rb').read())
  Encoders.encode_base64(part)
  part.add_header('Content-Disposition',
     'attachment; filename="%s"' % os.path.basename(attach))
  msg.attach(part)</pre></div></li><li class="listitem">Create a <a id="id931" class="indexterm"/><a id="id932" class="indexterm"/>new SMTP object that references the Google Mail service, passes in the username and password to connect to the mail services, sends the e-mail, and closes the connection:<div><pre class="programlisting">  mailServer = smtplib.SMTP("smtp.gmail.com", 587)
  mailServer.ehlo()
  mailServer.starttls()
  mailServer.ehlo()
  mailServer.login(gmail_user, gmail_pwd)
  mailServer.sendmail(gmail_user, to, msg.as_string())
  mailServer.close()</pre></div></li><li class="listitem">Call the <code class="literal">mail()</code> function, passing <a id="id933" class="indexterm"/>in the recipient of the e-mail, a subject for the e-mail, the text of the e-mail, and the attachment:<div><pre class="programlisting">  mail("&lt;email to send to&gt;",
  "Hello from python!",
  "This is an email sent with python",
  "c:/ArcpyBook/data/bc_pop1996.csv")</pre></div></li><li class="listitem">The entire script should appear as follows:<div><pre class="programlisting">import smtplib
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email import Encoders
import os

gmail_user = "&lt;username&gt;"
gmail_pwd = "&lt;password&gt;"

def mail(to, subject, text, attach):
 msg = MIMEMultipart()

 msg['From'] = gmail_user
 msg['To'] = to
 msg['Subject'] = subject

 msg.attach(MIMEText(text))

 part = MIMEBase('application', 'octet-stream')
 part.set_payload(open(attach, 'rb').read())
 Encoders.encode_base64(part)
 part.add_header('Content-Disposition',
     'attachment; filename="%s"' % os.path.basename(attach))
 msg.attach(part)

 mailServer = smtplib.SMTP("smtp.gmail.com", 587)
 mailServer.ehlo()
 mailServer.starttls()
 mailServer.ehlo()
 mailServer.login(gmail_user, gmail_pwd)
 mailServer.sendmail(gmail_user, to, msg.as_string())
 mailServer.close()

mail("&lt;email to send to&gt;",
 "Hello from python!",
 "This is an email sent with python",
 "bc_pop1996.csv")</pre></div></li><li class="listitem">Save and <a id="id934" class="indexterm"/><a id="id935" class="indexterm"/>run the script. For testing, I used my personal Yahoo account as the recipient. You'll notice that my inbox has a new message from my Gmail account; also notice the attachment:<div><img src="img/4445_A2_2.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec252"/>How it works…</h2></div></div></div><p>The first parameter passed into the <code class="literal">mail()</code> function is the e-mail address that will receive the e-mail. This can be any valid e-mail address, but you'll want to supply a mail account that you can actually check, so that you can make sure your script runs correctly. The second parameter is just the subject line of the e-mail. The third parameter is the text of the e-mail. The final parameter is the name of a file that will be attached to the e-mail. Here, I've simply defined that the <code class="literal">bc_pop1996.csv</code> file should be attached. You can use any file you have access to, but you may want to just use this file for testing.</p><p>We then create a new <code class="literal">MIMEMultipart</code> object inside the <code class="literal">mail()</code> function, and assign the <code class="literal">from</code>, <code class="literal">to</code>, and <code class="literal">subject</code> keys. You can also attach the text of the e-mail to this new <code class="literal">msg</code> object using <code class="literal">MIMEMultipart.attach()</code>. The <code class="literal">bc_pop1996.csv</code> file is then attached to the e-mail using a <code class="literal">MIMEBase</code> object and attached to the e-mail using <code class="literal">msg.attach(part)</code>.</p><p>At this point, we've <a id="id936" class="indexterm"/>
<a id="id937" class="indexterm"/>examined how a basic text e-mail can be sent. However, we want to send a more complex e-mail message that contains text and an attachment. This requires the use of MIME messages, which provides the functionality to handle multi-part e-mails. MIME messages need boundaries between the multiple parts, along with extra headers to specify the content being sent. The <code class="literal">MIMEBase</code> class is an abstract subclass of <code class="literal">Message</code> and enables this type of an e-mail to be sent. Because it is an abstract class, you can't create actual instances of this class. Instead, you use one of the subclasses, such as <code class="literal">MIMEText</code>. The last step of the <code class="literal">mail()</code> function is to create a new SMTP object that references the Google Mail service, passes in the username and password to connect to the mail services, sends the e-mail, and closes the connection.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec98"/>Retrieving files from an FTP server</h1></div></div></div><p>Retrieving files from an FTP server for processing is a very common operation for GIS programmers and can be automated with a Python script. </p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec253"/>Getting ready</h2></div></div></div><p>Connecting to an FTP<a id="id938" class="indexterm"/>
<a id="id939" class="indexterm"/> server and downloading a file is accomplished through the <a id="id940" class="indexterm"/> <code class="literal">ftplib</code> module. A connection to an FTP server is created through the FTP object, which accepts a host, username, and password to create the connection. Once a connection has been opened, you can then search for and download files. </p><p>In this recipe, you will connect to the National Interagency Fire Center Incident FTP site and download a Google Earth format file for a wildfire in Alaska.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec254"/>How to do it…</h2></div></div></div><p>Follow these steps to create a script that connects to an FTP server and downloads a file:</p><div><ol class="orderedlist arabic"><li class="listitem">Open IDLE and create a file called <code class="literal">c:\ArcpyBook\Appendix2\ftp.py</code>.</li><li class="listitem">We'll be connecting to an FTP server at the NIFC. Visit their website at <a class="ulink" href="http://ftpinfo.nifc.gov/">http://ftpinfo.nifc.gov/</a> for more information. </li><li class="listitem">Import the <code class="literal">ftplib</code>, <code class="literal">os</code>, and so<code class="literal">c</code>ket modules:<div><pre class="programlisting">import ftplib
import os
import socket</pre></div></li><li class="listitem">Add the following variables that define the URL, directory, and filename:<div><pre class="programlisting">HOST = 'ftp.nifc.gov'
DIRN = '/Incident_Specific_Data/ALASKA/Fire_Perimeters/20090805_1500'
FILE = 'FirePerimeters_20090805_1500.kmz'</pre></div></li><li class="listitem">Add the<a id="id941" class="indexterm"/><a id="id942" class="indexterm"/> following code block to create a connection. If there is a connection error, a message will be generated. If the connection was successful, a success message will be printed:<div><pre class="programlisting">try:
  f = ftplib.FTP(HOST)
except (socket.error, socket.gaierror), e:
  print 'ERROR: cannot reach "%s"' % HOST
print '*** Connected to host "%s"' % HOST</pre></div></li><li class="listitem">Add the following code block to anonymously log in to the server:<div><pre class="programlisting">try:
  f.login()
except ftplib.error_perm:
  print 'ERROR: cannot login anonymously'
  f.quit()
print '*** Logged in as "anonymous"'</pre></div></li><li class="listitem">Add the following code block to change to the directory specified in our <code class="literal">DIRN</code> variable:<div><pre class="programlisting">try:
  f.cwd(DIRN)
except ftplib.error_perm:
  print 'ERROR: cannot CD to "%s"' % DIRN
  f.quit()
print '*** Changed to "%s" folder' % DIRN</pre></div></li><li class="listitem">Use the <code class="literal">FTP.retrbinary()</code> function to retrieve the KMZ file:<div><pre class="programlisting">try:
  f.retrbinary('RETR %s' % FILE,
     open(FILE, 'wb').write)
except ftplib.error_perm:
  print 'ERROR: cannot read file "%s"' % FILE
  os.unlink(FILE)
else:
  print '*** Downloaded "%s" to CWD' % FILE</pre></div></li><li class="listitem">Make sure you disconnect from the server:<div><pre class="programlisting">f.quit()</pre></div></li><li class="listitem">The entire<a id="id943" class="indexterm"/><a id="id944" class="indexterm"/> script should appear as follows:<div><pre class="programlisting">import ftplib
import os
import socket
HOST = 'ftp.nifc.gov'
DIRN = '/Incident_Specific_Data/ALASKA/Fire_Perimeters/20090805_1500'
FILE = 'FirePerimeters_20090805_1500.kmz'

try:
  f = ftplib.FTP(HOST)
except (socket.error, socket.gaierror), e:
  print 'ERROR: cannot reach "%s"' % HOST
print '*** Connected to host "%s"' % HOST

try:
  f.login()
except ftplib.error_perm:
  print 'ERROR: cannot login anonymously'
  f.quit()
print '*** Logged in as "anonymous"'

try:
  f.cwd(DIRN)
except ftplib.error_perm:
  print 'ERROR: cannot CD to "%s"' % DIRN
  f.quit()
print '*** Changed to "%s" folder' % DIRN

try:
  f.retrbinary('RETR %s' % FILE,
     open(FILE, 'wb').write)
except ftplib.error_perm:
  print 'ERROR: cannot read file "%s"' % FILE
  os.unlink(FILE)
else:
  print '*** Downloaded "%s" to CWD' % FILE
f.quit()</pre></div></li><li class="listitem">Save and <a id="id945" class="indexterm"/><a id="id946" class="indexterm"/>run the script. If everything is successful, you should see the following output:<div><pre class="programlisting">
<strong>*** Connected to host "ftp.nifc.gov"</strong>
<strong>*** Logged in as "anonymous"</strong>
<strong>*** Changed to "/Incident_Specific_Data/ALASKA/Fire_Perimeters/20090805_1500" folder</strong>
<strong>*** Downloaded "FirePerimeters_20090805_1500.kmz" to CWD</strong>
</pre></div></li><li class="listitem">Check your <code class="literal">c:\ArcpyBook\Appendix2</code> directory for the file. By default, FTP will download files to the current working directory:<div><img src="img/4445_A2_3.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec255"/>How it works…</h2></div></div></div><p>To connect to an FTP server, you need to know the URL. You also need to know the directory and filename for the file that will be downloaded. In this script, we have hardcoded this information, so that you can focus on implementing the FTP-specific functionality. Using this information we then created a connection to the NIFC FTP server. This is done through the <code class="literal">ftplib.FTP()</code> function, which accepts a URL to the host. </p><p>Anonymous logins are accepted by the <code class="literal">nifc.gov</code> server, so we connect to the server in this manner. Keep in mind that if a server does not accept anonymous connections, you'll need to obtain a username/password. Once logged in, the script then changes directories from the root of the<a id="id947" class="indexterm"/>
<a id="id948" class="indexterm"/> FTP server to the path defined in the <code class="literal">DIRN</code> variable. This was accomplished with the <code class="literal">cwd(&lt;path&gt;)</code> function. The <code class="literal">kmz</code> file was retrieved using the <a id="id949" class="indexterm"/> <code class="literal">retrbinary()</code> function. Finally, you will want to close your connection to the FTP server when you're done. This is done with the<a id="id950" class="indexterm"/> <code class="literal">quit()</code> method. </p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec256"/>There's more…</h2></div></div></div><p>There are a number of additional FTP-related methods that you can use to perform various actions. Generally, these can be divided into directory-level operations and file-level operations. Directory-level methods include the <code class="literal">dir()</code> method<a id="id951" class="indexterm"/> to obtain a list of files in a directory, <code class="literal">mkd()</code> <a id="id952" class="indexterm"/>to create a new directory, <code class="literal">pwd()</code> <a id="id953" class="indexterm"/>to get the current working directory, and <code class="literal">cwd()</code> <a id="id954" class="indexterm"/>to change the current directory.</p><p>The <code class="literal">ftplib</code> module<a id="id955" class="indexterm"/> also includes various methods for working with files. You can upload and download<a id="id956" class="indexterm"/> files in binary or plain text format. The <code class="literal">retrbinary()</code> and <code class="literal">storbinary()</code> methods <a id="id957" class="indexterm"/>are used to retrieve and store binary files, respectively. Plain text files can be retrieved and <a id="id958" class="indexterm"/>stored using <code class="literal">retrlines()</code> <a id="id959" class="indexterm"/>and <code class="literal">storlines()</code>. </p><p>There are several others methods on the FTP class that you should be aware of. Deleting a file can be <a id="id960" class="indexterm"/>done with the <code class="literal">delete()</code> method, while renaming a file can be <a id="id961" class="indexterm"/>accomplished with <code class="literal">rename()</code>. You can also send commands to the FTP server through the <a id="id962" class="indexterm"/> <code class="literal">sendcmd()</code> method. </p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec99"/>Creating ZIP files</h1></div></div></div><p>GIS often requires the use of large<a id="id963" class="indexterm"/> files that will be compressed into a <code class="literal">.zip</code> format for ease of sharing. Python includes a module that you can use to decompress and compress files in this format.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec257"/>Getting ready</h2></div></div></div><p>Zip<a id="id964" class="indexterm"/> is a common compression and archive format and is implemented in Python through the <code class="literal">zipfile</code> module. The <code class="literal">ZipFile</code> class can be used to create, read, and write <code class="literal">.zip</code> files. To create a new <code class="literal">.zip</code> file, simply provide the filename along with a mode such as <code class="literal">w</code>, which indicates that you want to write data to the file. In the following code example, we are creating a <code class="literal">.zip</code> file called <code class="literal">datafile.zip</code>. The second parameter, <code class="literal">w</code>, indicates that a new file will be created. A new file will be created or an existing file with the same name will be truncated in the write mode. An optional compression parameter can also be used when creating the file. This value can be set to either <code class="literal">ZIP_STORED</code> or <code class="literal">ZIP_DEFLATED</code>: </p><div><pre class="programlisting">zipfile.ZipFile('dataFile.zip', 'w',zipfile.ZIP_STORED)</pre></div><p>In this exercise, you <a id="id965" class="indexterm"/>will use Python to create file, add files, and apply compression to  a <code class="literal">.zip</code>. You'll be archiving all the shapefiles located in the <code class="literal">c:\ArcpyBook\data</code> directory.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec258"/>How to do it…</h2></div></div></div><p>Follow these steps to learn how to create a script that build a <code class="literal">.zip</code> file:</p><div><ol class="orderedlist arabic"><li class="listitem">Open IDLE and create a script called <code class="literal">c:\ArcpyBook\Appendix2\CreateZipfile.py</code>.</li><li class="listitem">Import the <code class="literal">zipfile</code> and <code class="literal">os</code> modules:<div><pre class="programlisting">import os
import zipfile</pre></div></li><li class="listitem">Create a new <code class="literal">.zip</code> file called <code class="literal">shapefiles.zip</code> in write mode and add a compression parameter:<div><pre class="programlisting">zfile = zipfile.ZipFile("shapefiles.zip", "w", zipfile.ZIP_STORED)</pre></div></li><li class="listitem">Next, we'll use the <code class="literal">os.listdir()</code> function to create a list of files in the data directory:<div><pre class="programlisting">files = os.listdir("c:/ArcpyBook/data")</pre></div></li><li class="listitem">Loop through a list of all the files and write to the <code class="literal">.zip</code> file, if the file ends with <code class="literal">shp</code>, <code class="literal">dbf</code>, or <code class="literal">shx</code>:<div><pre class="programlisting">for f in files:
  if f.endswith("shp") or f.endswith("dbf") or f.endswith("shx"):
    zfile.write("C:/ArcpyBook/data/" + f)</pre></div></li><li class="listitem">Print out a list of all the files that were added to the zip archive. You can use the ZipFile.namelist() function to create a list of files in the archive:<div><pre class="programlisting">for f in zfile.namelist():
    print "Added %s" % f</pre></div></li><li class="listitem">Close the <code class="literal">.zip</code> archive:<div><pre class="programlisting">zfile.close()</pre></div></li><li class="listitem">The entire script should appear as follows:<div><pre class="programlisting">import os
import zipfile

#create the zip file
zfile = zipfile.ZipFile("shapefiles.zip", "w", zipfile.ZIP_STORED)
files = os.listdir("c:/ArcpyBook/data")

for f in files:
  if f.endswith("shp") or f.endswith("dbf") or f.endswith("shx"):
    zfile.write("C:/ArcpyBook/data/" + f)

#list files in the archive
for f in zfile.namelist():
    print "Added %s" % f

zfile.close()</pre></div></li><li class="listitem">Save and <a id="id966" class="indexterm"/>run the script. You should see the following output:<div><pre class="programlisting">
<strong>Added ArcpyBook/data/Burglaries_2009.dbf</strong>
<strong>Added ArcpyBook/data/Burglaries_2009.shp</strong>
<strong>Added ArcpyBook/data/Burglaries_2009.shx</strong>
<strong>Added ArcpyBook/data/Streams.dbf</strong>
<strong>Added ArcpyBook/data/Streams.shp</strong>
<strong>Added ArcpyBook/data/Streams.shx</strong>
</pre></div></li><li class="listitem">In Windows Explorer, you should be able to see the output <code class="literal">.zip</code> file as shown in the following screenshot. Note the size of the archive. This file was created without compression:<div><img src="img/4445_A2_4.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, we're going to create a compressed version of the <code class="literal">.zip</code> file to see the difference. Make the following changes to the line of code that creates the <code class="literal">.zip</code> file:<div><pre class="programlisting">zfile = zipfile.ZipFile("shapefiles2.zip", "w", zipfile.ZIP_DEFLATED)</pre></div></li><li class="listitem">Save and re-run the script.</li><li class="listitem">Take a look at the size of the new <code class="literal">shapefiles2.zip</code> file that you just created. Note the decreased size of the file due to compression:<div><img src="img/4445_A2_5.jpg" alt="How to do it…"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec259"/>How it works…</h2></div></div></div><p>In this recipe, you <a id="id967" class="indexterm"/>created a new <code class="literal">.zip</code> file called <code class="literal">shapefiles.zip</code> in write mode. In the first iteration of this script, you didn't compress the contents of the file. However, in the second iteration, you did by using the <code class="literal">DEFLATED</code> parameter passed into the constructor for the <code class="literal">ZipFile</code> object. The script then obtained a list of files in the data directory and looped through each of the files. Each file that has an <a id="id968" class="indexterm"/>extension of <code class="literal">.shp</code>, <code class="literal">.dbf</code>, or <code class="literal">.shx</code> is then written to the archive file using the <code class="literal">write()</code> function. Finally, the names of each of the files written to the archive is printed to the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec260"/>There's more…</h2></div></div></div><p>The contents of an existing file stored in a ZIP archive can be read using the <a id="id969" class="indexterm"/> <code class="literal">read()</code> method. The file should first be opened in a read mode, and then you can call the <code class="literal">read()</code> method passing in a parameter that represents the filename that should be read. The contents of the file can then be printed to the screen, written to another file, or stored as a list or dictionary variable. </p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Reading XML files</h1></div></div></div><p>XML files <a id="id970" class="indexterm"/>were designed as a way to transport and store data. They are platform independent, since the data is stored in a plain text file. Although similar to HTML, XML<a id="id971" class="indexterm"/> differs in that HTML<a id="id972" class="indexterm"/> is designed for display purposes, whereas XML data is designed for data. XML files are sometimes used as an interchange format for GIS data going between various software systems.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec261"/>Getting ready</h2></div></div></div><p>XML documents have a tree-like structure composed of a root element, child elements, and element attributes. Elements are also called <strong>nodes</strong>
<a id="id973" class="indexterm"/>. All XML files contain a <a id="id974" class="indexterm"/>
<strong>root</strong> element. This root element is the parent to all other elements or child nodes. The following code example illustrates the structure of an XML document. Unlike HTML files, XML files are case sensitive:</p><div><pre class="programlisting">&lt;root&gt;
 &lt;child att="value"&gt;
 &lt;subchild&gt;.....&lt;/subchild&gt;
 &lt;/child&gt;
&lt;/root&gt;</pre></div><p>Python provides several programming modules that you can use to process XML files. The module that you use should be determined by the module that is right for the job. Don't try to force a single module to do everything. Each module has specific functions that they are good at performing. In this recipe, you will learn how to read data from an XML file using the <code class="literal">nodes</code> and <code class="literal">element</code> attributes that are a part of the document. </p><p>There are a <a id="id975" class="indexterm"/>number of ways that you can access nodes within an XML document. Perhaps, the easiest way to do so is to find nodes by tag name and then walk the tree containing a list of the child nodes. Before doing so, you'll want to parse the XML document with the <code class="literal">minidom.parse()</code> method. Once parsed, you can then use the <code class="literal">childNodes</code> attribute<a id="id976" class="indexterm"/> to obtain a list of all child nodes starting at the root of the tree. Finally, you can search the nodes by tag name with the <code class="literal">getElementsByTagName(tag)</code> function<a id="id977" class="indexterm"/>, which accepts a tag name as an argument. This will return a list of all child nodes associated with the tag.</p><p>You can also determine if a node contains an attribute by calling <code class="literal">hasAttribute(name)</code>, which will return a <code class="literal">true</code>/<code class="literal">false</code> value. Once you've determined that an attribute exists, a call to <code class="literal">getAttribute(name)</code> will obtain the value for the attribute. </p><p>In this exercise, you will parse an XML file and pull out values associated with a particular element (node) and attribute. We'll be loading an XML file containing wildfire data. In this file, we'll be looking for the <code class="literal">&lt;fire&gt;</code> node and the <code class="literal">address</code> attribute from each of these nodes. The addresses will be printed out.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec262"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open IDLE and create a script called <code class="literal">c:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py</code>.</li><li class="listitem">The <code class="literal">WitchFireResidenceDestroyed.xml</code> file will be used. The file is located in your <code class="literal">c:\ArcpyBook\Appendix2</code> folder. You can see a sample of its contents as follows:<div><pre class="programlisting">&lt;fires&gt;
  &lt;fire address="11389 Pajaro Way" city="San Diego" state="CA" zip="92127" country="USA" latitude="33.037187" longitude="-117.082299" /&gt;
  &lt;fire address="18157 Valladares Dr" city="San Diego" state="CA" zip="92127" country="USA" latitude="33.039406" longitude="-117.076344" /&gt;
  &lt;fire address="11691 Agreste Pl" city="San Diego" state="CA" zip="92127" country="USA" latitude="33.036575" longitude="-117.077702" /&gt;
  &lt;fire address="18055 Polvera Way" city="San Diego" state="CA" zip="92128" country="USA" latitude="33.044726" longitude="-117.057649" /&gt;
&lt;/fires&gt;</pre></div></li><li class="listitem">Import <code class="literal">minidom</code> from <code class="literal">xml.dom</code>:<div><pre class="programlisting">from xml.dom import minidom</pre></div></li><li class="listitem">Parse the XML file:<div><pre class="programlisting">xmldoc = minidom.parse("WitchFireResidenceDestroyed.xml")</pre></div></li><li class="listitem">Generate a list of nodes from the XML file:<div><pre class="programlisting">childNodes = xmldoc.childNodes</pre></div></li><li class="listitem">Generate a list of all the <code class="literal">&lt;fire&gt;</code> nodes:<div><pre class="programlisting">eList = childNodes[0].getElementsByTagName("fire")</pre></div></li><li class="listitem">Loop <a id="id978" class="indexterm"/>through the list of elements, test for the existence of the <code class="literal">address</code> attribute, and print the value of the attribute if it exists:<div><pre class="programlisting">for e in eList:
  if e.hasAttribute("address"):
    print e.getAttribute("address")</pre></div></li><li class="listitem">Save and run the script. You should see the following output:<div><pre class="programlisting">
<strong>11389 Pajaro Way</strong>
<strong>18157 Valladares Dr</strong>
<strong>11691 Agreste Pl</strong>
<strong>18055 Polvera Way</strong>
<strong>18829 Bernardo Trails Dr</strong>
<strong>18189 Chretien Ct</strong>
<strong>17837 Corazon Pl</strong>
<strong>18187 Valladares Dr</strong>
<strong>18658 Locksley St</strong>
<strong>18560 Lancashire Way</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec263"/>How it works…</h2></div></div></div><p>Loading an XML document into your script is probably the most basic thing you can do with XML files. You can use the <code class="literal">xml.dom</code> module to do this through the use of the <code class="literal">minidom</code> object. The <code class="literal">minidom</code> object has a method called <code class="literal">parse()</code>, which accepts a path to an XML document and creates a <strong>document object model</strong> (<strong>DOM</strong>)<a id="id979" class="indexterm"/> tree object from the <code class="literal">WitchFireResidenceDestroyed.xml</code> file. </p><p>The <code class="literal">childNodes</code> property of the DOM tree generates a list of all nodes in the XML file. You can then access each of the nodes using the <code class="literal">getElementsByTagName()</code> method<a id="id980" class="indexterm"/>. The final step is to loop through each of the <code class="literal">&lt;fire&gt;</code> nodes contained within the <code class="literal">eList</code> variable. For each node, we then check for the <code class="literal">address</code> attribute with the <a id="id981" class="indexterm"/> <code class="literal">hasAttribute()</code> method, and if it exists we call the <code class="literal">getAttribute()</code> function<a id="id982" class="indexterm"/> and print the address to the screen.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec264"/>There's more…</h2></div></div></div><p>There will be times when you will need to search an XML document for a specific text string. This requires the use of the <code class="literal">xml.parsers.expat</code> module. You'll need to define a search class derived from the basic <code class="literal">expat</code> class and then create an object from this class. Once created, you can call the <code class="literal">parse()</code> method on the search object to search for data. Finally, you can then search the nodes by tag name with the <code class="literal">getElementsByTagName(tag)</code> function, which accepts a tag name as an argument. This will return a list of all child nodes associated with the tag.</p></div></div></div>
</body></html>