- en: Chapter 10. Developing a Python Plugin – Select by Radius
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 开发Python插件 – 以半径选择
- en: While Processing's models and scripts are great for automating different analysis
    tasks, sometimes you may want to extend the QGIS functionality in another way—by
    developing a plugin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然“处理”中的模型和脚本非常适合自动化不同的分析任务，但有时你可能想以另一种方式扩展QGIS的功能——通过开发一个插件。
- en: 'In this chapter, we will go through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: QGIS plugins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QGIS插件
- en: Creating a plugin's skeleton
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建插件骨架
- en: Designing a plugin's GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计插件的GUI
- en: Using designer UI files in the plugin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插件中使用设计器UI文件
- en: Implementing feature selection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现特征选择
- en: Adding translations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加翻译
- en: Preparing the plugin for publishing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备插件以发布
- en: QGIS plugins
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QGIS插件
- en: From the very beginning, QGIS was developed with the extensible and modular
    architecture. Originally, it allowed us to extend its functionality only with
    C++ plugins. But, starting from version 0.9, when Python support was added, users
    and developers were able to create plugins using the Python programming language
    as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，QGIS就是以可扩展和模块化的架构开发的。最初，它只允许我们通过C++插件来扩展其功能。但是，从版本0.9开始，当添加了对Python的支持后，用户和开发者能够使用Python编程语言创建插件。
- en: Every QGIS Python plugin is just a set of the Python modules and additional
    files bundled into a single Python package. These packages should be placed in
    separate subdirectories under a special directory in the QGIS home path. Usually,
    this is `~/.qgis2/python/plugins`, where `~` is a user home (profile) directory.
    In Windows, it is `C:\Users\your_profile`, and in UNIX-like systems, it is `/home/your_profile`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个QGIS Python插件都是一个Python模块和附加文件捆绑成的单个Python包。这些包应该放置在QGIS家目录下的一个特殊目录下的单独子目录中。通常，这是`~/.qgis2/python/plugins`，其中`~`是用户家目录（配置文件）目录。在Windows中，它是`C:\Users\your_profile`，而在类UNIX系统中，它是`/home/your_profile`。
- en: 'The minimal working plugin should contain two files in this directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最小工作插件应该包含这个目录下的两个文件：
- en: '`__init__.py`: This is the package initialization file and the plugin''s entry
    point. It should contain the `classFactory()` method.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`：这是包初始化文件和插件的入口点。它应该包含`classFactory()`方法。'
- en: '`metadata.txt`: This contains plugin metadata used by **Plugin Manager** and
    the plugins website. This metadata includes plugin name, version, description,
    and other information.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.txt`：这个文件包含由**插件管理器**和插件网站使用的插件元数据。这些元数据包括插件名称、版本、描述和其他信息。'
- en: 'However, real plugins usually contain many more files in their directory: additional
    source files, GUI forms, corresponding sources with logic, icons and other resources,
    and so on. Of course, all of these files can be placed in the plugin''s root directory,
    but to keep the source tree clean and easy to maintain, files are often organized
    in subdirectories. For example, Qt Designer forms are placed in the `ui/` subdirectory,
    corresponding sources with logic under the `gui/` subdirectory, and icons and
    other resources under `resources/` subdirectory and so on.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，真正的插件通常在其目录中包含许多其他文件：额外的源文件、GUI表单、相应的逻辑源、图标和其他资源等。当然，所有这些文件都可以放置在插件的根目录下，但为了保持源树整洁且易于维护，文件通常组织在子目录中。例如，Qt
    Designer表单放置在`ui/`子目录中，相应的逻辑源放置在`gui/`子目录下，图标和其他资源放置在`resources/`子目录中等。 '
- en: 'To develop QGIS plugins with Python, you will need these pieces of software:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python开发QGIS插件，你需要以下这些软件：
- en: '**QGIS**: This is meant for testing and debugging your plugin. It is better
    to use the same QGIS version for which the plugin is developed. If you want to
    develop a plugin that works on multiple QGIS versions, in all `2.x` series for
    example, use as old a version as possible because the newest versions may have
    some minor additions to the API.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QGIS**：这是用于测试和调试你的插件。最好使用与插件开发相同的QGIS版本。如果你想开发一个在多个QGIS版本上工作的插件，例如所有`2.x`系列，尽可能使用较旧的版本，因为最新版本可能对API有一些小的添加。'
- en: '**Text editor or Python IDE**: Here, you will be writing your code. It is better
    to use something more advanced than the standard Notepad or any other plain text
    editor. Syntax highlighting, auto-indentation, and autocompletion will make your
    work easier and more comfortable.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本编辑器或Python IDE**：在这里，你将编写你的代码。最好使用比标准记事本或其他任何纯文本编辑器更高级的工具。语法高亮、自动缩进和自动完成将使你的工作更加轻松和舒适。'
- en: '**Qt Designer**: This is used to design the user interface. For Windows, it
    can be installed using the `OSGeo4W` installer. The corresponding package is called
    **qt4-devel**. If you are a Linux user, use your package manager to find and install
    the Qt developer tools.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Designer**：用于设计用户界面。对于Windows，可以使用`OSGeo4W`安装程序进行安装。相应的包称为**qt4-devel**。如果您是Linux用户，请使用您的包管理器查找并安装Qt开发工具。'
- en: Also, to make debugging easier, we recommend that you install the **Plugin**
    **Reloader** plugin. Plugin Reloader is extremely useful because it allows you
    to reload your plugin after changing its code in one click, without having to
    restart QGIS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使调试更容易，我们建议您安装**插件重载器**插件。插件重载器极其有用，因为它允许您在单击一次后重新加载更改代码的插件，而无需重新启动QGIS。
- en: In this chapter, we will develop a plugin for selecting features of the specified
    vector layer that are located within a given distance around reference features
    (already selected by the user) of another layer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个插件，用于选择位于指定矢量层中、围绕另一个层中已由用户选择的参考特征（已选择的特征）给定距离内的特征。
- en: 'There are two ways of developing QGIS Python plugins:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 开发QGIS Python插件有两种方式：
- en: Create a plugin template with the help of the **Plugin** **Builder** plugin.
    Then, refine this template and add the necessary functionality.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**插件构建器**插件的帮助下创建一个插件模板。然后，完善此模板并添加必要的功能。
- en: Develop the plugin manually by creating all the required files and code yourself.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建所有必需的文件和代码手动开发插件。
- en: The first approach (using Plugin Builder) is the most commonly used, and is
    recommended by many authors as the easiest way for novices. However, it is necessary
    to remember that while Plugin Builder is a great and user-friendly tool, it also
    hides some details, compels you to use a specific directory structure, and makes
    some assumptions about how your plugin will work. Also, a template generated by
    this plugin will contain many additional files, and these are not really necessary
    in all cases, for example, help file template, data for unit tests, shell scripts,
    and so on. Of course, all of these files can be removed or adjusted as per your
    needs, but it is necessary to have good knowledge to avoid deleting the necessary
    stuff.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法（使用插件构建器）是最常用的，许多作者推荐它作为新手最容易的方式。然而，有必要记住，虽然插件构建器是一个伟大且用户友好的工具，但它也隐藏了一些细节，强迫您使用特定的目录结构，并对您的插件如何工作做出了一些假设。此外，由该插件生成的模板将包含许多额外的文件，而在所有情况下这些文件并非都是必需的，例如帮助文件模板、单元测试数据、shell脚本等。当然，所有这些文件都可以根据您的需要进行删除或调整，但您需要具备良好的知识以避免删除必要的文件。
- en: In this chapter, we will create a plugin manually by adding the required files
    and directories step by step. This gives us full control over the plugin structure
    and appearance and also allows us to understand things better.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过逐步添加所需的文件和目录来手动创建插件。这使我们能够完全控制插件的结构和外观，并使我们更好地理解事物。
- en: Creating the plugin's skeleton
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建插件的骨架
- en: Let's start with developing our plugin. Create a directory for the plugin somewhere
    in your disk. As our plugin will select features within a given radius, we call
    it `Select` `by` `Radius` and use `selectradius` as the name of the plugin directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开发我们的插件开始。在您的磁盘上的某个位置创建一个插件目录。由于我们的插件将在给定半径内选择特征，我们将其称为`按半径选择`，并使用`selectradius`作为插件目录的名称。
- en: 'Now, open you favorite text editor and create a file with this content:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您喜欢的文本编辑器并创建一个包含以下内容的文件：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save it as `metadata.txt` in the plugin directory. This is the metadata file
    for our plugin. As you can see, it has very simple structure, similar to `INI`
    Windows files. There is only one section called `general`, which contains all
    the metadata items in the `key=value` notation. Empty strings between metadata
    items used for logical grouping can be safely removed. The order of the metadata
    items does not matter as long as all the necessary items are there and their format
    is correct.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为插件目录中的`metadata.txt`。这是我们的插件元数据文件。如您所见，它具有非常简单的结构，类似于`INI` Windows文件。只有一个名为`general`的部分，其中包含所有元数据项，以`key=value`格式表示。用于逻辑分组的元数据项之间的空字符串可以安全地删除。只要所有必要的项都存在且格式正确，元数据项的顺序并不重要。
- en: 'All metadata items can be divided into two groups: mandatory and optional.
    The following metadata items are mandatory and should be always presented in the
    `metadata.txt` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元数据项可以分为两组：必需的和可选的。以下元数据项是必需的，并且应始终在`metadata.txt`文件中呈现：
- en: '**name**: This is the name of the plugin. Usually, it contains a human-readable
    name. Spaces and other characters such as "`-`" are allowed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**: 这是插件的名称。通常，它包含一个可读的名称。允许使用空格和其他字符，如 "`-`"。'
- en: '**description**: This is a short description of the plugin. Usually, it is
    one short sentence. More detailed information should be placed in the optional
    "about" item.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**description**: 这是插件的简短描述。通常，它是一句简短的句子。更详细的信息应放在可选的 "about" 项中。'
- en: '**version**: This is the plugin version in dotted notation, for example, `1.0.1`
    (if semantic versioning is used). Avoid adding words such as "version" here.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**version**: 这是插件的版本，使用点分隔表示法，例如，`1.0.1`（如果使用语义版本控制）。在此处避免添加如 "version" 这样的单词。'
- en: '**qgisMinimumVersion**: This defines the oldest QGIS version supported by the
    current version of the plugin. The value should be in dotted notation; for example,
    if the plugin works with QGIS version greater than 2.0, this item should have
    `2.0` as the value.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**qgisMinimumVersion**: 这定义了当前插件版本支持的最早 QGIS 版本。值应使用点分隔表示法；例如，如果插件与 QGIS 版本
    2.0 以上兼容，则此项应将 `2.0` 作为值。'
- en: '**author**: This is the name of the plugin''s author. Enter your name as the
    value.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**author**: 这是插件作者的姓名。将您的姓名作为值输入。'
- en: '**email**: This is the e-mail of the plugin''s author. Provide your valid e-mail
    address here. Note that this e-mail address is not published anywhere and is used
    only by the plugin repository admins if they need to contact the author.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**email**: 这是插件作者的电子邮件。在此处提供您的有效电子邮件地址。请注意，此电子邮件地址不会在任何地方发布，并且仅在插件存储库管理员需要联系作者时使用。'
- en: 'All other metadata items are optional and can be blank. Here is the full list
    of optional metadata items:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他元数据项都是可选的，可以是空的。以下是可选元数据项的完整列表：
- en: '**about**: This contains more detailed information about plugin. It complements
    the information in the "description" metadata item.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**about**: 这包含有关插件的更详细信息。它补充了 "description" 元数据项中的信息。'
- en: '**category**: This is the helper metadata item. It helps users understand in
    which menu to look for your plugin after its installation. The supported values
    are `Raster`, `Vector`, `Database`, and `Web`. For example, if the plugin has
    to be placed under the **Vector** menu, this metadata should have the `Vector`
    value. If this is not set, the default `Plugins` value is used. Note that this
    metadata is used only as reference. You need to write the code for creating plugin
    actions in the correct menu by yourself.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**category**: 这是辅助元数据项。它帮助用户在安装后了解在哪个菜单中查找您的插件。支持的值有 `Raster`、`Vector`、`Database`
    和 `Web`。例如，如果插件必须放置在 **Vector** 菜单下，则此元数据应具有 `Vector` 值。如果没有设置，则使用默认的 `Plugins`
    值。请注意，此元数据仅用作参考。您需要自己编写代码以在正确的菜单中创建插件操作。'
- en: '**qgisMaximumVersion**: This defines the last QGIS version supported by the
    current version of the plugin. Its value should be in dotted notation. Usually
    this is not used. By default, it is equal to the major number from `qgisMinimumVersion`
    plus 0.99\. For example, if `qgisMinimumVersion` is `2.0` and `qgisMaximumVersion`
    is not set explicitly, it will be `2.99`. This metadata is used only in rare cases
    where the plugin supports a limited subset of QGIS versions or only one QGIS version.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**qgisMaximumVersion**: 这定义了当前插件版本支持的最后一个 QGIS 版本。其值应使用点分隔表示法。通常，这不用。默认情况下，它等于
    `qgisMinimumVersion` 的主要数字加 0.99。例如，如果 `qgisMinimumVersion` 是 `2.0` 且未显式设置 `qgisMaximumVersion`，则它将是
    `2.99`。此元数据仅在罕见情况下使用，即插件支持 QGIS 版本的有限子集或仅支持一个 QGIS 版本。'
- en: '**icon**: This is the filename or the path to the plugin icon, if any. The
    path should be relative to the base plugin directory. If this is not set, the
    default icon will be used.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**icon**: 如果有，这是插件图标的文件名或路径。路径应相对于基本插件目录。如果没有设置，则使用默认图标。'
- en: '**tags**: This is a comma-separated list of tags that describe the plugin.
    Try to use tags from the existing list available at the plugins website at [http://plugins.qgis.org/](http://plugins.qgis.org/).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tags**: 这是一个用逗号分隔的标签列表，用于描述插件。尝试使用插件网站 [http://plugins.qgis.org/](http://plugins.qgis.org/)
    上可用的现有标签。'
- en: '**changelog**: This is a list of changes in the current plugin version. It
    is a multiline item.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**changelog**: 这是当前插件版本中的更改列表。这是一个多行项。'
- en: '**homepage**: This is a link to the plugin''s home page, if any. We recommend
    filling this metadata if you plan to publish your plugin in the QGIS official
    plugin repository.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**homepage**: 如果有，这是插件主页的链接。如果您计划在 QGIS 官方插件存储库中发布您的插件，我们建议填写此元数据。'
- en: '**tracker**: This is a link to the `bugtracker` plugin if any. We recommend
    filling this metadata if you plan to publish your plugin in the QGIS official
    plugin repository.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tracker**：这是 `bugtracker` 插件的链接（如果有）。如果您计划在 QGIS 官方插件仓库中发布您的插件，我们建议填写此元数据。'
- en: '**repository**: This is a link to the plugin source code repository, if any.
    We recommend filling this metadata as well if you plan to publish you plugin in
    the QGIS official plugin repository.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**repository**：这是插件源代码仓库的链接（如果有）。如果您计划在 QGIS 官方插件仓库中发布您的插件，我们建议也填写此元数据。'
- en: '**experimental**: This is a Boolean flag used to mark the plugin as experimental.
    Experimental plugins may be unstable and partly nonfunctional, so they are not
    shown in the **Plugin Manager** unless the corresponding option is set.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**experimental**：这是一个布尔标志，用于标记插件为实验性。实验性插件可能不稳定且部分功能不完整，因此除非设置了相应的选项，否则它们不会在
    **插件管理器** 中显示。'
- en: '**deprecated**: This is a Boolean flag used to mark the plugin as deprecated.
    Deprecated plugins are not supported by authors and may not work or may work incorrectly,
    so they are not shown in the Plugin Manager unless the corresponding option is
    set.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**deprecated**：这是一个布尔标志，用于标记插件为已弃用。已弃用的插件不受作者支持，可能无法正常工作或可能工作不正确，因此除非设置了相应的选项，否则它们不会在插件管理器中显示。'
- en: As you can see, in our `metadata.txt` file, we have not only the mandatory items,
    but also some optional items to provide more information for plugin users. Note
    that our demo plugin has empty `homepage`, `tracker`, and `repository` metadata
    items. In a real plugin, especially if it will be published, these items should
    contain valid links to the corresponding pages so that the plugin's users can
    submit bug reports and patches and find the relevant documentation easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们的 `metadata.txt` 文件中，我们不仅包含了强制性的项目，还有一些可选项目，以向插件用户提供更多信息。请注意，我们的演示插件具有空的
    `homepage`、`tracker` 和 `repository` 元数据项。在实际插件中，尤其是如果它将被发布，这些项应包含指向相应页面的有效链接，以便插件用户可以提交错误报告和补丁，并轻松找到相关文档。
- en: Also, if you look at the `icon` metadata item, you will see that it contains
    the relative path to the image file. So, in our plugin directory, it is necessary
    to create the `icons` subdirectory and put the `selectradius.svg` icon file into
    it. Icons can be in any raster format supported by the Qt library, but we recommend
    that you use PNG format for raster icons and SVG for vector icons. The icon size
    should be at least 24 x 24 pixels.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您查看 `icon` 元数据项，您会看到它包含到图像文件的相对路径。因此，在我们的插件目录中，有必要创建 `icons` 子目录并将 `selectradius.svg`
    图标文件放入其中。图标可以是 Qt 库支持的任何光栅格式，但我们建议您使用 PNG 格式用于光栅图标，使用 SVG 格式用于矢量图标。图标的大小至少应为 24
    x 24 像素。
- en: 'The next step is to create a plugin (and Python package) initialization file,
    `__init__.py`. This file should contain a `classFactory()` function. This function
    will be called when the plugin is loaded in QGIS. The function body is very short
    and simple:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个插件（和 Python 包）初始化文件，`__init__.py`。此文件应包含一个 `classFactory()` 函数。当插件在
    QGIS 中加载时，将调用此函数。函数体非常简短且简单：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `classFactory()` function accepts a single argument called `iface`—an instance
    of the `QgsInterface` class that provides access to the GUI of the running QGIS
    copy. It returns the `SelectRadiusPlugin` object, which is a plugin instance.
    The code of the `SelectRadiusPlugin` class, imported from the `selectradius_plugin.py`
    file, is located in the plugin's root directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`classFactory()` 函数接受一个名为 `iface` 的单个参数——一个 `QgsInterface` 类的实例，它提供了对正在运行的
    QGIS 复制的 GUI 的访问。它返回 `SelectRadiusPlugin` 对象，这是一个插件实例。`SelectRadiusPlugin` 类的代码，从
    `selectradius_plugin.py` 文件导入，位于插件的根目录中。'
- en: 'Now, let''s implement the main plugin class. Create a new file called `selectradius_plugin.py`
    in the plugin root directory and add the following code to it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现主插件类。在插件根目录下创建一个名为 `selectradius_plugin.py` 的新文件，并将以下代码添加到其中：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the first seven lines of this code, we import all the necessary Python packages
    from the Python standard library, the `PyQt4` package, and the `qgis.core` library.
    Usually, these import statements are added and edited on an iterative basis during
    development. In other words, you write the code, and when a new class or library
    is needed, you add the corresponding import statement. As a rule, all import statements
    are placed at the very beginning of the source's file. For the sake of simplicity,
    in our sample plugin, we will provide all the necessary imports at the start.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码的前七行中，我们从Python标准库、`PyQt4` 包和 `qgis.core` 库中导入所有必要的Python包。通常，这些导入语句在开发过程中基于迭代添加和编辑。换句话说，您编写代码，当需要新的类或库时，您添加相应的导入语句。按照规则，所有导入语句都放置在源文件的非常开始处。为了简化，在我们的示例插件中，我们将提供所有必要的导入。
- en: In line `9`, we determine the plugin's path, which will be used later to construct
    full paths to icons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9行，我们确定插件的路径，该路径将用于稍后构建图标的全路径。
- en: In line `12`, a base plugin class is defined. There are several methods implemented
    in it. The `__init__()` method, also called a constructor, is used for basic initialization
    of the plugin instance. In line `14`, we store a reference to the QGIS interface—passed
    as the **iface** parameter—for further usage so that we can access and use it
    from other methods. From lines `16` to `27`, an internationalization support is
    activated. We check which locale is used by QGIS and try to load the corresponding
    translation file from the `i18n` subdirectory in the plugin tree. If no translation
    is found, the plugin will be loaded with the default locale.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行，定义了一个基插件类。其中实现了几个方法。`__init__()` 方法，也称为构造函数，用于插件实例的基本初始化。在第14行，我们存储了对QGIS接口的引用——作为
    **iface** 参数传递——以便在后续使用中可以访问和使用它。从第16行到第27行，激活了国际化支持。我们检查QGIS使用的区域设置，并尝试从插件树中的
    `i18n` 子目录加载相应的翻译文件。如果没有找到翻译，则插件将以默认区域设置加载。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We recommend that you always use English as the primary language of the plugin.
    Use it for all messages and captions on GUI widgets. As English is the most common
    and widely used language, the plugin can be used by almost all users, even without
    translations. If necessary, support for any other language can be added easily
    via the localization mechanism.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您始终将英语作为插件的主要语言。请使用它来设置GUI小部件上的所有消息和标题。由于英语是最常见和广泛使用的语言，因此几乎所有的用户都可以使用该插件，即使没有翻译。如果需要，可以通过本地化机制轻松添加对任何其他语言的支持。
- en: The next important, and mandatory, method that should be implemented in the
    plugin base class is `initGui()`. This method is called when the plugin is activated
    and loaded by QGIS. Here, we add the required GUI elements, such as menu items,
    toolbar buttons, and even dock widgets. We initialize all the necessary temporary
    folders and other stuff required by the plugin. In our demo plugin, this method
    starts from line `29`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在插件基类中应该实现的下一种重要且强制性的方法是 `initGui()`。当插件被QGIS激活并加载时，会调用此方法。在这里，我们添加所需的GUI元素，例如菜单项、工具栏按钮，甚至停靠小部件。我们初始化插件所需的所有必要临时文件夹和其他东西。在我们的演示插件中，此方法从第29行开始。
- en: From lines `30` to `36`, we create a so-called action that will launch the plugin
    dialog. Actions are special objects that represent a command and provide a unified
    way to run that command from different places, such as menus and toolbars. First,
    we create a `QAction` instance and assign the `Select byRadius` label to it (lines
    `30` and `31`). Note that the label text is enclosed in the `self.tr()` method
    call. This method is implemented in the last two lines of the code snippet provided,
    and makes the text string translatable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从第30行到第36行，我们创建一个所谓的动作，该动作将启动插件对话框。动作是特殊对象，代表一个命令，并提供了一种统一的方式从不同的地方运行该命令，例如菜单和工具栏。首先，我们创建一个
    `QAction` 实例，并将 `Select byRadius` 标签分配给它（第30行和第31行）。请注意，标签文本被包含在 `self.tr()` 方法调用中。此方法在提供的代码片段的最后两行实现，并使文本字符串可翻译。
- en: Then, in lines `32` and `33`, we construct an icon for our action. Using the
    `os.path.join()` call, we create a full path to the icon file located in the `icons`
    subdirectory of the plugin tree. This is the same icon that we specified in the
    `metadata.txt` file. Of course, you can use another icon—just put it into the
    `icons` subdirectory in the plugin tree. Next, in lines `34` and `35`, we set
    the tooltip text for our action. Note that we again use `self.tr()` here, so this
    text can also be localized. Finally, in line `36`, we set the `objectName` property
    of the action. This property is required by the QGIS customization framework.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第`32`行和第`33`行，我们为我们操作构造了一个图标。使用`os.path.join()`调用，我们创建了一个指向图标文件的完整路径，该图标文件位于插件树`icons`子目录中。这是我们在`metadata.txt`文件中指定的相同图标。当然，您可以使用另一个图标——只需将其放入插件树中的`icons`子目录即可。接下来，在第`34`行和第`35`行，我们为我们的操作设置了工具提示文本。请注意，我们在这里再次使用`self.tr()`，因此此文本也可以本地化。最后，在第`36`行，我们设置了操作的`objectName`属性。这个属性是QGIS自定义框架所必需的。
- en: From lines `38` to `42`, we create another action using the same approach as
    the preceding one. This action will be used to show the **About** dialog with
    some information about our plugin. The icon for this action called `about.png`,
    and it is located in the `icons` subdirectory of the plugin tree.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从第`38`行到`42`行，我们使用与前面相同的方法创建了另一个操作。此操作将用于显示包含有关我们插件信息的**关于**对话框。此操作的图标名为`about.png`，它位于插件树的`icons`子目录中。
- en: Then, from lines `44` to `45` and `46` to `47`, we add our actions to the **Select
    by Radius** submenu, which will be created in the QGIS **Vector** menu. In line
    `48`, we put the button that opens the main plugin dialog into the **Vector**
    toolbar.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从第`44`行到`45`行以及第`46`行到`47`行，我们将我们的操作添加到**按半径选择**子菜单中，该子菜单将在QGIS的**矢量**菜单中创建。在第`48`行，我们将打开主插件对话框的按钮放入**矢量**工具栏中。
- en: The last two lines (`50` and `51`) in this method are used to connect actions
    to handlers, which will be executed when the user presses buttons or selects menu
    entries. For now, both handlers—`run()` and `about()`—are empty, and we will add
    code to them later.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中的最后两行（`50`和`51`）用于将操作连接到处理程序，这些处理程序将在用户按下按钮或选择菜单项时执行。目前，这两个处理程序——`run()`和`about()`——都是空的，我们将在稍后向它们添加代码。
- en: The second mandatory method that should be present in the plugin base class
    is `unload()`. This method is executed when the plugin is deactivated and removed
    from QGIS. Here, we should remove all of the plugin's GUI elements (buttons, menu
    entries, widgets, and so on) and perform any other cleanup actions required, such
    as removing temporary files. In our demo plugin, this method is defined in line
    `53`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应该存在于插件基类中的第二个强制方法是`unload()`。当插件被停用并从QGIS中移除时，将执行此方法。在这里，我们应该移除插件的所有GUI元素（按钮、菜单项、小部件等）并执行任何其他所需的清理操作，例如删除临时文件。在我们的演示插件中，此方法在第`53`行定义。
- en: As our plugin is simple enough, we just the remove menu entries added in the
    `initGui()` method (lines `54` to `57`), as well as the toolbar button (line `58`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的插件足够简单，我们只需从`initGui()`方法（第`54`行到`57`行）中移除添加的菜单项，以及工具栏按钮（第`58`行）。
- en: In lines `60` to `64`, we define handlers for our actions. Currently, they do
    nothing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`60`行到`64`行，我们为我们的操作定义了处理程序。目前，它们没有任何作用。
- en: The last method, `tr()`, as we have already mentioned, is required for internationalization
    support. It takes English text and returns its translated equivalent, depending
    on the current locale and presence of the translation file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法，`tr()`，正如我们之前提到的，是用于国际化支持所必需的。它接受英文文本并返回其翻译等效文本，这取决于当前的区域设置和翻译文件的存在。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We implement the `tr()` method ourselves here because the main plugin class
    is a pure Python class. Almost all Qt GUI classes have built-in internationalization
    support, and this method is already present in their code. As a result, all classes
    inheriting from them also will have the `tr()` method, as you will see soon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里自己实现`tr()`方法，因为主插件类是一个纯Python类。几乎所有的Qt GUI类都有内置的国际化支持，并且此方法已经存在于它们的代码中。因此，从它们继承的所有类也将具有`tr()`方法，您很快就会看到。
- en: 'Now, our plugin directory''s structure should look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的插件目录结构应该看起来像这样：
- en: '![Creating the plugin''s skeleton](img/image00519.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建插件的骨架](img/image00519.jpeg)'
- en: Such a plugin skeleton can be used as the starting point for a wide range of
    plugins.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的插件骨架可以用作各种插件的开发起点。
- en: At this point, our plugin should be loadable by QGIS. You can easily check this—just
    copy the plugin directory to the QGIS plugins directory, `~/.qgis2/python/plugins`.
    Start QGIS and open **Plugin Manager** by going to **Plugins** | **Manage and
    install plugins…**. You should see the **Select by Radius** plugin in the **Installed**
    tab. After activation, the plugin will be loaded, a new button will be placed
    on the **Vector** toolbar, and a new entry with two items will appear in the **Vector**
    menu. But at this stage, these items do nothing. We need to implement their functionality.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的插件应该可以被QGIS加载。您可以轻松地检查这一点——只需将插件目录复制到QGIS插件目录，`~/.qgis2/python/plugins`。启动QGIS，通过转到**插件**
    | **管理并安装插件…**来打开**插件管理器**。您应该在**已安装**选项卡中看到**按半径选择**插件。激活后，插件将被加载，**矢量**工具栏上会放置一个新按钮，**矢量**菜单中会出现一个包含两个条目的新条目。但在这个阶段，这些条目没有任何作用。我们需要实现它们的功能。
- en: Designing the plugin's GUI
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计插件的GUI
- en: 'Our plugin will have two dialogs: one is the main plugin dialog, which will
    be used to accept user input, and the second is the so-called About dialog, with
    some information about the plugin.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插件将有两个对话框：一个是主插件对话框，它将用于接受用户输入；第二个是所谓的“关于”对话框，其中包含有关插件的一些信息。
- en: The Qt framework, on top of which QGIS is built, provides a special program
    for designing dialogs and other UI elements, such as dock widgets. It is called
    **Qt Designer**. Qt Designer is a user-friendly and easy-to-use visual form designer.
    With its help, you can create a dialog without writing code, by placing GUI widgets
    on the form using your mouse. The form definition in XML format is then saved
    in a `.ui` file, which is used by the plugin or application to construct a user
    interface.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: QGIS所构建的Qt框架提供了一个用于设计对话框和其他UI元素（如停靠小部件）的特殊程序。它被称为**Qt Designer**。Qt Designer是一个用户友好且易于使用的可视化表单设计器。借助它的帮助，您可以通过使用鼠标在表单上放置GUI小部件来创建对话框，而无需编写代码。然后，将表单定义以XML格式保存到`.ui`文件中，该文件由插件或应用程序用于构建用户界面。
- en: To keep the plugin's structure clean, we will put all the `.ui` files in a separate
    subdirectory, called `ui` for example, in the plugin source tree.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持插件结构的整洁，我们将把所有的`.ui`文件放在一个单独的子目录中，例如，在插件源树中命名为`ui`。
- en: Designing the About dialog
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计“关于”对话框
- en: 'Start Qt Designer. In the **New form** welcome dialog, select the template
    called **Dialog with Buttons Bottom**, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Qt Designer。在**新建表单**欢迎对话框中，选择名为**底部按钮对话框**的模板，如下所示：
- en: '![Designing the About dialog](img/image00520.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![设计“关于”对话框](img/image00520.jpeg)'
- en: If this dialog is not opened at Designer startup, go to **File** | **New...**
    or use the *Ctrl* + *N* keyboard shortcut. A new empty Qt form will be created,
    with two buttons at the bottom.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Designer启动时没有打开此对话框，请转到**文件** | **新建...**或使用*Ctrl* + *N*键盘快捷键。将创建一个新的空Qt表单，底部有两个按钮。
- en: 'First, we will create the About dialog. We want to display the following information
    in this dialog: the plugin name, icon, version number, and a short description,
    maybe with links to the plugin home page and/or bugtracker.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建“关于”对话框。我们希望在对话框中显示以下信息：插件名称、图标、版本号以及简短描述，可能包含对插件主页和/或错误跟踪器的链接。
- en: In the **Property editor** panel (usually located in the top-right corner of
    the Designer window), find the `windowTitle` property and change it to something
    meaningful, for example, `About Select by Radius`. Go back to the form and select
    the button box. It should be marked with blue square markers now. Return to the
    **Property editor**, find the `standardButtons` property and clear the checkboxes
    from all the variants except the **Close** button. So now, our button box has
    only one button.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在**属性编辑器**面板（通常位于设计器窗口的右上角），找到`windowTitle`属性并将其更改为有意义的名称，例如，`关于按半径选择`。返回到表单并选择按钮框。现在它应该带有蓝色的方块标记。返回到**属性编辑器**，找到`standardButtons`属性并清除除**关闭**按钮之外的所有变体的复选框。因此，现在我们的按钮框只有一个按钮。
- en: Now, in the **Widget Box** panel (usually located to the left of the Designer
    window), find the **Label** widget inside the **Display Widgets** group and drag
    and drop it into the form. Keeping the newly added widget selected, go to **Property
    editor** and set the `objectName` property to `lblLogo`. This widget will be used
    to display the plugin icon.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**小部件框**面板（通常位于设计器窗口的左侧），找到**标签**小部件，它位于**显示小部件**组中，并将其拖放到表单中。保持新添加的小部件选中状态，转到**属性编辑器**并将`objectName`属性设置为`lblLogo`。这个小部件将用于显示插件图标。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `objectName` property of widgets will be used in our code to access the
    corresponding widget. So, try to assign meaningful object names for all the widgets
    that you plan to access from code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的`objectName`属性将在我们的代码中用于访问相应的部件。因此，请尝试为所有计划从代码中访问的小部件分配有意义的对象名称。
- en: 'Similarly, add another **Label** widget to the form and place it on the right
    side of the previously added widget. This time, however, don''t change its `objectName`
    property. Instead, find the `text` property and press the button labeled **…**
    on the right side of the edit field. A simple text editor will be opened, like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，向表单中添加另一个**标签**小部件，并将其放置在之前添加的小部件的右侧。然而，这次不要更改其`objectName`属性。相反，找到`text`属性，并按编辑字段右侧标有**…**的按钮。将打开一个简单的文本编辑器，如下所示：
- en: '![Designing the About dialog](img/image00521.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![设计关于对话框](img/image00521.jpeg)'
- en: Enter the plugin name and then change the font size to a larger value, for example,
    `16`. Make the font bold and align the text to the center. Close the editor by
    clicking on the **OK** button. Also modify the `alignment` property to enable
    horizontal alignment by center.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 输入插件名称，然后将字体大小更改为更大的值，例如，`16`。使字体加粗并将文本居中对齐。通过单击**确定**按钮关闭编辑器。还要修改`alignment`属性以启用水平居中对齐。
- en: Add a third label, which will be used to display the plugin version, to the
    form and change its `objectName` property to `lblVersion`. Modify the `alignment`
    property to enable horizontal alignment by center. Move this label so that it
    will be placed under the label with the plugin name. Finally, add the **TextBrowser**
    widget to the form and place it under all the labels.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中添加一个第三标签，该标签将用于显示插件版本，并将其`objectName`属性更改为`lblVersion`。修改`alignment`属性以启用水平居中对齐。将此标签移动到插件名称标签下方。最后，将**TextBrowser**小部件添加到表单中，并将其放置在所有标签下方。
- en: Qt uses a layout-based approach to manage widgets, so your form will always
    look consistent, regardless of the themes and fonts used. To enable layout in
    our form, we just have to select the form and click on the **Lay Out in a Grid**
    button on toolbar, or select this item from the **Form** menu.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Qt使用基于布局的方法来管理小部件，因此无论使用何种主题和字体，您的表单都将始终看起来一致。为了在我们的表单中启用布局，我们只需选择表单并单击工具栏上的**在网格中布局**按钮，或从**表单**菜单中选择此选项。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the Qt layout system can be found in the Qt documentation
    at [http://doc.qt.io/qt-4.8/layout.html](http://doc.qt.io/qt-4.8/layout.html).
    If you want to create nice-looking dialogs, this is a must-read piece of information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Qt布局系统的更多信息可以在Qt文档中找到，请参阅[http://doc.qt.io/qt-4.8/layout.html](http://doc.qt.io/qt-4.8/layout.html)。如果你想要创建看起来不错的对话框，这是一篇必读的信息。
- en: 'Now your form should look like what is shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的表单应该看起来像以下截图所示：
- en: '![Designing the About dialog](img/image00522.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![设计关于对话框](img/image00522.jpeg)'
- en: If some widgets are in incorrect places, try to move them around and adjust
    their sizes. When you are satisfied with the dialog's look and feel, save it as
    `aboutdialogbase.ui` in the `ui` subdirectory in the plugin root directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些小部件放置不正确，请尝试移动它们并调整它们的大小。当你对对话框的外观和感觉满意时，将其保存为`aboutdialogbase.ui`，位于插件根目录下的`ui`子目录中。
- en: Designing the main plugin dialog
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计主插件对话框
- en: 'Close the saved **About** dialog and create a new empty form for the main plugin
    dialog using the same **Dialog with buttons bottom** template. Change the dialog''s
    `windowTitle` property to `Select by Radius` and adjust the button box by changing
    its `standardButtons` property so that it contains two buttons: **OK** and **Close**.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭已保存的**关于**对话框，并使用相同的**带按钮底部的对话框**模板创建一个新的空表单作为主插件对话框。将对话框的`windowTitle`属性更改为`按半径选择`，并通过更改其`standardButtons`属性调整按钮框，使其包含两个按钮：**确定**和**关闭**。
- en: We need to specify a target layer from which we will select features. Add to
    the form a **Label** widget from the **Display Widgets** section of the **Widget
    Box** panel, and change its `text` property to `Select features from`. Now it
    is necessary to provide a widget where the user can choose a layer that will be
    used. **Combo Box** can be a good choice here but there is an even better solution.
    Starting from version 2.4, QGIS provides a set of custom widgets for Qt Designer.
    Among these widgets, there is a special combobox called **QgsMapLayerComboBox**.
    It is designed to display a list of layers from the QGIS layers registry. This
    widget, as well as all other QGIS-related custom widgets, can be found in the
    **QGIS custom** **widgets** section of the **Widget Box** panel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定一个目标层，从该层中我们将选择特征。在**小部件框**面板的**显示小部件**部分添加一个**标签**小部件，并将其`text`属性更改为`从中选择特征`。现在需要提供一个用户可以选择要使用的层的控件。**组合框**是一个不错的选择，但还有一个更好的解决方案。从版本2.4开始，QGIS为Qt
    Designer提供了一套自定义小部件。在这些小部件中，有一个特殊的选择框，称为**QgsMapLayerComboBox**。它被设计用来显示来自QGIS层注册表的层列表。这个控件，以及所有其他与QGIS相关的自定义小部件，可以在**小部件框**面板的**QGIS自定义小部件**部分找到。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is necessary to mention here that the QGIS custom widgets section may be
    not available in your system. If you cannot find it, ensure that you have installed
    all the QGIS-related packages (for example, the Debian package with custom widgets
    called `libqgis-customwidgets`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有必要提到，QGIS自定义小部件部分可能不在您的系统中可用。如果您找不到它，请确保您已安装所有QGIS相关包（例如，名为`libqgis-customwidgets`的Debian包）。
- en: Alternatively, you can use an ordinal combobox instead of **QgsMapLayerCombobox**,
    but in this case, you will need to implement code to populate it with layer names
    as well as code to retrieve a layer by its name by yourself.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用序数组合框代替**QgsMapLayerCombobox**，但在这种情况下，您将需要自己实现代码来填充它以及通过名称检索层的代码。
- en: Drag a **QgsMapLayerComboBox** combobox onto the form, place it on the right
    side of the previously added label, and change its `objectName` property to `cmbTargetLayer`.
    By default, **QgsMapLayerCombobox** will display raster layers, vector layers
    with polygonal geometry type, and plugin layers. This is not suitable for us,
    as we need only vector layers. To change this behavior, find the `filters` property
    and clear the checkboxes from all variants except **PointLayer**, **LineLayer**,
    and **PolygonLayer** (this also activates the **HasGeometry** option automatically).
    Now, this combobox will show only vector layers with geometry types specified
    previously. Raster layers, plugin layers, and vector layers without geometry will
    be not displayed in it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个**QgsMapLayerComboBox**组合框拖放到表单上，将其放置在之前添加的标签的右侧，并更改其`objectName`属性为`cmbTargetLayer`。默认情况下，**QgsMapLayerCombobox**将显示栅格层、具有多边形几何类型的矢量层和插件层。这不适合我们，因为我们只需要矢量层。要更改此行为，找到`filters`属性，并清除除**PointLayer**、**LineLayer**和**PolygonLayer**之外的所有变体的复选框（这也会自动激活**HasGeometry**选项）。现在，这个组合框将只显示之前指定的几何类型的矢量层。栅格层、插件层和没有几何的矢量层将不会显示在其中。
- en: Also, we need to specify another layer—a reference layer. So, add another **Label**
    widget to the form and change its `text` property to `Around reference features
    from`. Near this label, place the second **QgsMapLayerComboBox** combobox and
    change its `objectName` property to `cmbReferenceLayer`. Apply the same filters
    to it that we used for the previously added **QgsMapLayerCombobox** combobox.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要指定另一个层——参考层。因此，在表单中添加另一个**标签**小部件，并将其`text`属性更改为`从参考特征周围选择`。在这个标签附近，放置第二个**QgsMapLayerComboBox**组合框，并将其`objectName`属性更改为`cmbReferenceLayer`。对其应用与之前添加的**QgsMapLayerCombobox**组合框相同的过滤器。
- en: Another input value we need is a search radius. So, put another **Label** widget
    on the form, under the already added widgets. Set its `text` property to `Within
    search radius`. On the right side of this label, put **Double Spin Box** (which
    can be found in the **Input Widgets** section) and change its `objectName` property
    to `spnRadius`. Also adjust its `minimum`, `maximum`, and `value` properties to
    reasonable values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个输入值，即搜索半径。因此，在表单中添加另一个**标签**小部件，位于已添加的小部件下方。将其`text`属性设置为`在搜索半径内`。在这个标签的右侧，放置一个**双精度微调框**（可在**输入小部件**部分找到），并将其`objectName`属性更改为`spnRadius`。同时调整其`minimum`、`maximum`和`value`属性到合理的值。
- en: 'To make the plugin more useful and flexible, we provide the user with a choice
    of how to use the selected features: create a new selection, or alter an existing
    selection. The more logical way to represent available choices is a combobox.
    Add another label from the **Display Widgets** section to the form and change
    its `text` property to `Use the result to`. On the right side of this label, place
    **Combo Box** (which can be found in the **Input Widgets** section). Change the
    `objectName` property of the newly added combobox to `cmbSelectionMode`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使插件更加有用和灵活，我们为用户提供了一种选择来使用所选功能的方式：创建一个新的选择，或者修改现有的选择。表示可用选择的更合理方式是组合框。从**显示小部件**部分添加另一个标签到表单中，并将其`text`属性更改为`Use
    the result to`。在这个标签的右侧放置**组合框**（可在**输入小部件**部分找到）。将新添加的组合框的`objectName`属性更改为`cmbSelectionMode`。
- en: Put **Progress Bar** (which can be found in the **Display Widgets** section
    of the **Widget Box** panel) under the last label and the combobox, and change
    its `value` property to `zero`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将**进度条**（可在**工具箱**面板的**显示小部件**部分找到）放在最后一个标签和组合框下面，并将它的`value`属性更改为`zero`。
- en: 'Select the dialog and apply the grid layout to it by clicking on the **Lay
    Out in a Grid** button in the **Designer** toolbar. Now your form should look
    like what is shown in this screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选择对话框，通过点击**设计师**工具栏中的**在网格中布局**按钮将其应用网格布局。现在您的表单应该看起来像这个截图所示：
- en: '![Designing the main plugin dialog](img/image00523.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![设计主插件对话框](img/image00523.jpeg)'
- en: If some widgets are in incorrect places, try to move them around and adjust
    their sizes. Once you are satisfied with dialog's look and feel, save it in the
    `ui` subdirectory in the plugin root directory as `selectradiusdialogbase.ui`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些小部件位置不正确，尝试移动它们并调整它们的大小。一旦您对对话框的外观和感觉满意，将其保存在插件根目录下的`ui`子目录中，命名为`selectradiusdialogbase.ui`。
- en: As you can see, there is nothing complex in designing a user interface with
    the help of Qt Designer. The most important thing here is understanding how different
    types of layouts work and comply with the recommendations of the **Human** **Interface**
    **Guidelines** (**HIG**) of the corresponding project. QGIS HIG can be found in
    the `CODING` document inside QGIS sources. You can view it online at [https://github.com/qgis/QGIS/blob/master/CODING#L1429](https://github.com/qgis/QGIS/blob/master/CODING#L1429).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用Qt Designer设计用户界面并没有什么复杂之处。这里最重要的是理解不同类型的布局是如何工作以及如何符合相应项目的**人机界面指南**（**HIG**）的建议。QGIS
    HIG可以在QGIS源代码中的`CODING`文档中找到。您可以在[https://github.com/qgis/QGIS/blob/master/CODING#L1429](https://github.com/qgis/QGIS/blob/master/CODING#L1429)在线查看。
- en: Using Designer UI files in the plugin
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在插件中使用设计师UI文件
- en: Designing the GUI with the Qt Designer is the first part of the process. Now
    we need to use the previously created `.ui` files to construct our dialogs and
    implement the logic required for handling user actions, such as clicking on buttons,
    selecting items from lists, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer设计GUI是这个过程的第一部分。现在我们需要使用之前创建的`.ui`文件来构建我们的对话框并实现处理用户操作所需的逻辑，例如点击按钮、从列表中选择项目等。
- en: Adding the About dialog to the plugin
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将关于对话框添加到插件中
- en: We will start from the About dialog, as it is simple. To keep the plugin directory
    structure clean, we will store all the sources related to the plugin GUI in the
    `gui` subdirectory inside the plugin directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从关于对话框开始，因为它很简单。为了保持插件目录结构的整洁，我们将所有与插件GUI相关的源代码存储在插件目录内的`gui`子目录中。
- en: 'Open your text editor and create a new file with the following content:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的文本编辑器，创建一个包含以下内容的新的文件：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save this file in the `gui` subdirectory as `aboutdialog.py`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存在`gui`子目录下，命名为`aboutdialog.py`。
- en: At the very beginning of the file, from lines `1` to `6`, we import all the
    packages and classes that we will use later. Here, we use the Python standard
    library (the `os` and `ConfigParser` packages) as well as various `PyQt` classes
    (lines `4` to `6`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的开始部分，从第`1`行到第`6`行，我们导入了我们稍后将要使用的所有包和类。在这里，我们使用了Python标准库（`os`和`ConfigParser`包）以及各种`PyQt`类（第`4`行到第`6`行）。
- en: In line `8`, we determine the plugin path, as we need it in order to construct
    full paths to the dialog's `.ui` file and plugin icon.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`8`行，我们确定插件路径，因为我们需要它来构建对话框`.ui`文件和插件图标的完整路径。
- en: 'The most interesting part is lines `9` and `10`, which are actually a single
    command split into two lines due to its length. Here, we load our previously created
    `.ui` file in the Qt Designer. The `uic.loadUiType()` command returns two values:
    our custom dialog (stored as a `WIDGET` variable) and its base class (stored as
    a `BASE` variable). Using `uic` allows us to avoid compilation of UI files and
    makes plugin packaging simpler.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是第`9`行和第`10`行，实际上这是一条命令由于长度原因被拆分成了两行。在这里，我们使用Qt Designer加载我们之前创建的`.ui`文件。`uic.loadUiType()`命令返回两个值：我们的自定义对话框（存储为`WIDGET`变量）及其基类（存储为`BASE`变量）。使用`uic`可以让我们避免编译UI文件，并使插件打包更加简单。
- en: In line `13`, an implementation of the `AboutDialog` class, which will represent
    our About dialog, starts. Note that in the class definition, we use the `BASE`
    and `WIDGET` variables obtained previously from the `uic.loadUiType()` call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`13`行，开始实现`AboutDialog`类，它将代表我们的关于对话框。注意，在类定义中，我们使用了从`uic.loadUiType()`调用中获得的`BASE`和`WIDGET`变量。
- en: The `__init__()` method, also called a constructor, performs a basic class initialization.
    In lines `15` and `16`, we set up a dialog GUI. After these lines, we can access
    all dialog widgets using `self.widgetName`, where `widgetName` is the value of
    the `objectName` property of the corresponding widget. That's why it is important
    to specify meaningful and unique object names to all widgets that will be used
    in code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法，也称为构造函数，执行基本的类初始化。在第`15`行和第`16`行，我们设置了对话框GUI。在这些行之后，我们可以使用`self.widgetName`访问所有对话框小部件，其中`widgetName`是对应小部件`objectName`属性的值。这就是为什么为所有将在代码中使用的小部件指定有意义的唯一对象名称很重要的原因。'
- en: From lines `18` to `20`, we use the **ConfigParser** module from the Python
    standard library to read the plugin version from the `metadata.txt` file. Of course,
    we can enter the version number manually, but in this case, every time the plugin
    version changes, we will need to edit two files (`metadata.txt` and `aboutdialog.py`)
    instead of one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从第`18`行到第`20`行，我们使用Python标准库中的**ConfigParser**模块从`metadata.txt`文件中读取插件版本。当然，我们可以手动输入版本号，但在这种情况下，每次插件版本更改时，我们都需要编辑两个文件（`metadata.txt`和`aboutdialog.py`），而不是一个。
- en: Then, in lines `22` and `23`, the plugin icon is constructed from the path to
    the icon file and then loaded into the corresponding dialog widget. In line `24`,
    the plugin version is displayed in the `lblVersion` label widget.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第`22`行和第`23`行，从图标文件的路径构建插件图标，并将其加载到相应的小部件对话框中。在第`24`行，插件版本在`lblVersion`标签小部件中显示。
- en: Finally, in lines `26` to `29`, we instantiate the `QTextDocument` object, which
    will be used to display the About text, and assign it to the **QTextBrowser**
    widget. Line `29` allows the user to open links by clicking on them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第`26`行到第`29`行，我们实例化了`QTextDocument`对象，该对象将用于显示关于文本，并将其分配给**QTextBrowser**小部件。第`29`行允许用户通过点击来打开链接。
- en: Text for the About dialog is generated by the `getAboutText()` method, implemented
    in lines `31` to `37`. The implementation is simple—we just return a string containing
    a short description of the plugin in HTML format. The only important thing here
    is the usage of `self.tr()` method, which allows us to show translated About text.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于对话框的文本是通过第`31`行到第`37`行中实现的`getAboutText()`方法生成的。实现很简单——我们只是返回一个包含插件简短描述的字符串，格式为HTML。这里唯一重要的是使用`self.tr()`方法，它允许我们显示翻译后的关于文本。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information about Qt classes, their purpose, and their functionality,
    check out the Qt documentation at [http://doc.qt.io/qt-4.8/index.html](http://doc.qt.io/qt-4.8/index.html).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于Qt类、它们的目的和功能的信息，请查看Qt文档，网址为[http://doc.qt.io/qt-4.8/index.html](http://doc.qt.io/qt-4.8/index.html)。
- en: You may ask why we don't implement any methods to handle dialog execution and
    closing. Well, as this is a very simple dialog, we don't need to perform any special
    actions. We can use default handlers, which are implemented in the base `QDialog`
    class. This means that the dialog will be opened as modal, and clicking on the
    **Close** button will close it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我们没有实现任何处理对话框执行和关闭的方法。嗯，因为这个对话框非常简单，我们不需要执行任何特殊操作。我们可以使用默认的处理程序，这些处理程序是在基`QDialog`类中实现的。这意味着对话框将以模态方式打开，点击**关闭**按钮将关闭它。
- en: That's all! Now we need to add this dialog to the plugin main class. First,
    it is necessary to create an empty `__init__.py` file in the `gui` subdirectory
    so that Python will recognize it as a package directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了！现在我们需要将这个对话框添加到插件主类中。首先，在`gui`子目录中创建一个空的`__init__.py`文件，这样Python就会将其识别为包目录。
- en: 'Now, open the `selectradius_plugin.py` file. In the import section at the beginning
    of the file, add this line of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `selectradius_plugin.py` 文件。在文件开头的导入部分，添加以下代码行：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line makes the `AboutDialog` class accessible from the main plugin class.
    Now, find the `about()` method and modify it as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使 `AboutDialog` 类可以从主插件类中访问。现在，找到 `about()` 方法并按如下方式修改：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is nothing special here. First, we instantiate `AboutDialog` and then
    execute it. Save your edits. If you want, you can update the plugin files in the
    QGIS plugins directory or copy the entire plugin directory here. Reload the plugin
    with **Plugin Reloader** and make sure that, now, when you select the **About**
    item from the **Select by Radius** menu, an **About** dialog is shown.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。首先，我们实例化 `AboutDialog` 并执行它。保存您的编辑。如果您愿意，您可以在 QGIS 插件目录中更新插件文件，或者将整个插件目录复制到这里。使用
    **Plugin Reloader** 重新加载插件，并确保现在当您从 **Select by Radius** 菜单中选择 **About** 项时，会显示一个
    **About** 对话框。
- en: Adding the main plugin dialog
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加主插件对话框
- en: Now, let's implement the main plugin dialog. Create a new file and save it in
    the `gui` subdirectory of the plugin directory as `selectradiusdialog.py`. As
    this dialog is more complex, we split its code into small pieces, and we will
    examine them one by one.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现主插件对话框。创建一个新文件，并将其保存在插件目录的 `gui` 子目录中，命名为 `selectradiusdialog.py`。由于这个对话框比较复杂，我们将代码分成小块，并将逐一检查它们。
- en: 'As you should already know, we first import all the necessary classes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您应该已经知道的，我们首先导入所有必要的类：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Besides packages from the Python standard library and PyQt classes, we also
    import several classes from the `qgis.core` and `qgis.gui` libraries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Python 标准库和 PyQt 类之外，我们还从 `qgis.core` 和 `qgis.gui` 库中导入几个类。
- en: 'Then, as in the case of `AboutDialog`, we determine the plugin path and load
    the dialog GUI from the Qt Designer file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像 `AboutDialog` 的情况一样，我们确定插件路径并从 Qt Designer 文件中加载对话框 GUI：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preparation is complete. Now we can define the main dialog class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作已完成。现在我们可以定义主对话框类：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we initialize the dialog GUI (lines `3` to `4`). In line `6`, we store
    a reference to the QGIS interface for further usage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化对话框 GUI（行 `3` 到 `4`）。在行 `6`，我们存储对 QGIS 接口的引用，以便以后使用。
- en: In lines `8` and `9`, we get references to separate buttons of the dialog's
    button box, as we will later need to access them as individual widgets. From lines
    `11` to `14`, the `cmbSelectionMode` combobox is populated with the available
    selection modes. To keep the item text translatable, we wrap it into the `self.tr()`
    calls. It is worth mentioning that combobox items have zero-based numeration,
    so the first item will have index 0, the second item will have index 1, and so
    on. Populating the combobox from code allows us to easily check the order of items
    and determine their indices. Item indices will be used later to determine user
    choices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `8` 和 `9`，我们获取对话框按钮框中单独按钮的引用，因为我们稍后需要将它们作为独立的小部件访问。从行 `11` 到 `14`，`cmbSelectionMode`
    组合框被填充了可用的选择模式。为了保持项目文本可翻译，我们将它包装在 `self.tr()` 调用中。值得注意的是，组合框项有零基编号，因此第一个项将具有索引
    0，第二个项将具有索引 1，依此类推。从代码中填充组合框使我们能够轻松检查项目顺序并确定它们的索引。项目索引将稍后用于确定用户选择。
- en: Finally, in line `16`, we restore the plugin's settings from the previous run.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在行 `16`，我们从之前的运行中恢复插件的设置。
- en: 'Our plugin is simple enough, so there are only a few values that we want to
    save in the settings and restore. Every time a user opens the plugin dialog, we
    want to restore the previously entered search radius value and the last used selection
    mode from the **Use the result to** combobox:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件足够简单，所以我们只想在设置中保存和恢复几个值。每次用户打开插件对话框时，我们希望恢复之前输入的搜索半径值和从 **Use the result
    to** 组合框中使用的最后一种选择模式：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `loadSettings()` method is called when we want to restore the plugin's settings.
    On the first run of the plugin, we have no saved settings, so the default values
    will be picked up. The `saveSettings()` method is used to save the current values
    from the widgets to the plugin settings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要恢复插件的设置时，会调用 `loadSettings()` 方法。在插件的第一次运行中，我们没有保存的设置，所以将选择默认值。`saveSettings()`
    方法用于将当前值从小部件保存到插件设置中。
- en: 'Since we want to save the settings when the user closes the main plugin dialog
    by clicking on the **Close** button, and we need to start the data acquisition
    process when the user clicks on the **OK** button, it is necessary to replace
    the default handlers for these signals. The corresponding code is shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在用户通过点击**关闭**按钮关闭主插件对话框时保存设置，并且需要在用户点击**确定**按钮时启动数据采集过程，因此有必要替换这些信号的默认处理程序。相应的代码如下：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `reject()` method (line `1`) is called when the user clicks on the **Close**
    button. This method was initially implemented in the base `QDialog` class, and
    we reimplement it in our subclass. The only thing we do here is save the current
    plugin settings (line `2`). After that, we simply call the `reject()` method of
    the base class (line 3) to close our dialog.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**关闭**按钮时，会调用第`1`行的`reject()`方法。此方法最初在基类`QDialog`中实现，并在我们的子类中重新实现。我们在这里做的唯一事情是保存当前的插件设置（第`2`行）。之后，我们简单地调用基类的`reject()`方法（第`3`行）来关闭我们的对话框。
- en: The `accept()` method, defined in line `5`, is called when the user clicks on
    the **OK** button. This method is also initially implemented in the base `QDialog`
    class and reimplemented in our subclass. When the user clicks on the **OK** button,
    the plugin should check whether all the required parameters are specified, find
    all the features from the target layer that match the defined requirements, and
    finally, update the selection in the target layer.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在第`5`行的`accept()`方法在用户点击**确定**按钮时被调用。此方法最初在基类`QDialog`中实现，并在我们的子类中重新实现。当用户点击**确定**按钮时，插件应检查是否指定了所有必需的参数，从目标层中找到所有符合定义要求的功能，并最终更新目标层中的选择。
- en: First, in line `6`, we save the current plugin settings. Then, we check whether
    the user has selected all the necessary inputs. In line `8`, we use the `currentLayer()`
    method of `QgsMapLayerCombobox` to obtain the currently selected target layer.
    This method returns the corresponding `QgsMapLayer` instance if a layer is selected,
    otherwise it returns `None`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第`6`行，我们保存当前的插件设置。然后，我们检查用户是否选择了所有必要的输入。在第`8`行，我们使用`QgsMapLayerCombobox`的`currentLayer()`方法来获取当前选定的目标层。如果选择了图层，此方法返回相应的`QgsMapLayer`实例，否则返回`None`。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The documentation about the QGIS API can be found at [http://qgis.org/api/](http://qgis.org/api/).
    Also, don't forget *PyQGIS Developer Cookbook*, which contains detailed explanations
    on different topics and many useful examples. You always can read the latest *PyQGIS
    cookbook* online at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于QGIS API的文档可以在[http://qgis.org/api/](http://qgis.org/api/)找到。另外，别忘了查看*PyQGIS开发者手册*，其中包含不同主题的详细解释和许多有用的示例。您可以在[http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html)在线阅读最新的*PyQGIS开发者手册*。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some samples from the latest version of the PyQGIS cookbook may not
    work with older QGIS versions due to API changes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于API的变化，最新版本的PyQGIS开发者手册中的某些示例可能无法与较旧的QGIS版本兼容。
- en: If no target layer is selected (this is checked in line `9`), we show a warning
    message with the `showMessage()` method (lines `10` to `13`) and return to the
    main plugin dialog (line `14`). In other words, we don't try to perform any further
    actions, as we have incomplete or invalid input. The user should specify the correct
    input and then try again.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择目标层（这在第`9`行进行检查），我们将使用`showMessage()`方法（第`10`至`13`行）显示警告消息，并返回主插件对话框（第`14`行）。换句话说，我们不尝试执行任何进一步的操作，因为我们有不完整或无效的输入。用户应指定正确的输入，然后重试。
- en: Using the same approach, we check whether a valid reference layer is selected
    (lines `16` to `22`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法，我们检查是否选择了有效的参考层（第`16`至`22`行）。
- en: In line `24`, we obtain a list of preselected reference features from the reference
    layer. If no reference features are selected in the reference layer, the length
    of this list will be zero. We need to catch this situation because without reference
    features, we cannot continue. This is what happens in lines `25` to `31`; if there
    are no reference features selected in the reference layer, we show the corresponding
    message and return to the main plugin dialog.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`24`行，我们从参考层中获取预选的参考特征列表。如果参考层中没有选择参考特征，此列表的长度将为零。我们需要捕获这种情况，因为没有参考特征，我们无法继续。这就是第`25`至`31`行发生的事情；如果在参考层中没有选择参考特征，我们将显示相应的消息并返回主插件对话框。
- en: For now, this is all of the code we need to write for the `accept()` method.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，我们为`accept()`方法编写的代码就是这些。
- en: 'You may have already noticed the `showMessage()` method widely used in the
    preceding code. Here is its implementation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了在前面代码中广泛使用的`showMessage()`方法。以下是它的实现：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is just a wrapper that displays a message bar with the given text and importance
    level using the same timeout as defined in the global QGIS settings. By default,
    the `INFO` level will be used, but if necessary, we can specify any other supported
    level.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个包装器，它使用与全局QGIS设置中定义的相同超时显示给定文本和重要性级别的消息栏。默认情况下，将使用`INFO`级别，但如果需要，我们可以指定任何其他支持的水平。
- en: As you can see, we have implemented only the basic functionality of the main
    plugin dialog as of now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，到目前为止，我们只实现了主插件对话框的基本功能。
- en: 'Now, we need to add the main dialog to the plugin base class. To do this, open
    the `selectradius_plugin.py` file, if it is not opened already. In the import
    section at the beginning of the file, add the following line of code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将主对话框添加到插件基类中。为此，打开`selectradius_plugin.py`文件，如果尚未打开。在文件开头的导入部分，添加以下代码行：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This line makes the `SelectRadiusDialog` class accessible from the main plugin
    class. Now, find the `run()` method and modify it as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使得`SelectRadiusDialog`类可以从主插件类中访问。现在，找到`run()`方法，并按如下方式修改它：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, there is nothing special here. First, we instantiate `SelectRadiusDialog`
    and then open it as a modal dialog, as we did earlier for the About dialog.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里没有什么特别之处。首先，我们实例化`SelectRadiusDialog`，然后以模态对话框的形式打开它，就像我们之前为关于对话框所做的那样。
- en: Save your edits. If you want, you can update the plugin files in the QGIS plugins
    directory or copy the entire plugin directory here. Reload the plugin with **Plugin
    Reloader** and make sure that, now, when you select the **Select by Radius** item
    from the **Select by Radius** menu, a main plugin dialog is shown.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的编辑。如果你想，你可以更新QGIS插件目录中的插件文件，或者将整个插件目录复制到这里。使用**插件重载器**重新加载插件，并确保现在当你从**按半径选择**菜单中选择**按半径选择**项时，会显示主插件对话框。
- en: Implementing feature selection
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现特征选择
- en: Now, when dialogs are created and connected to our plugin, we can start implementing
    the main functionality—namely, feature selection using requirements defined by
    the user.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当对话框创建并连接到我们的插件时，我们可以开始实现主要功能——即使用用户定义的要求进行特征选择。
- en: 'Open the `selectradiusdialog.py` file located in the `gui` subdirectory of
    the plugin source tree. Add the following code at the end of the `accept()` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于插件源树`gui`子目录中的`selectradiusdialog.py`文件。在`accept()`方法的末尾添加以下代码：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this moment, we have already ensured that all the necessary input fields
    are defined correctly (see the previous section), and now we can safely proceed
    with feature selection.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确保所有必要的输入字段都已正确定义（参见上一节），现在我们可以安全地进行特征选择。
- en: First, it is necessary to block the **OK** and **Close** buttons to prevent
    accidental clicks on them, which may interrupt running processes. We do this in
    lines `1` and `2`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有必要阻止**确定**和**关闭**按钮，以防止意外点击，这可能会中断运行中的进程。我们在第`1`行和第`2`行这样做。
- en: Our plugin will need to request features from vector layers. As you know, every
    feature has geometry and attributes and, by default, both the geometry and attributes
    are returned when we query a feature from a layer. For our purposes, we need only
    feature geometry, so it will be better not to query attributes. This will speed
    up the process of feature retrieval, especially if the layer has a large attribute
    table or is accessed via a slow network connection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插件需要从矢量图层请求功能。正如你所知，每个功能都有几何形状和属性，并且默认情况下，当我们从图层查询一个功能时，几何形状和属性都会被返回。对于我们来说，我们只需要功能几何形状，所以最好不要查询属性。这将加快功能检索的过程，尤其是在图层有一个大的属性表或者通过慢速网络连接访问时。
- en: So, in line `4`, we instantiate the `QgsFeatureRequest` object, which is used
    to customize the process of feature retrieval. From lines `5` to `6`, we alter
    its default behavior (fetch geometry and attributes) by resetting its `SubsetOfAttributes`
    flag so that only the feature geometry will be fetched.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第`4`行，我们实例化`QgsFeatureRequest`对象，该对象用于自定义特征检索的过程。从第`5`行到第`6`行，我们通过重置其`SubsetOfAttributes`标志来改变其默认行为（获取几何形状和属性），以便只获取特征几何形状。
- en: Then, we build a spatial index for the target layer (line `8`). A spatial index
    allows us to perform quick queries on the layer and fetch only features that intersect
    some region or are located close to the given coordinates. A spatial index also
    reduces processing time by limiting the number of features we should test against
    our spatial operator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在目标层上构建空间索引（第`8`行）。空间索引允许我们对层执行快速查询，并仅获取与某些区域相交或位于给定坐标附近的特征。空间索引还可以通过限制我们应该测试的空间运算符的特征数量来减少处理时间。
- en: Now we are ready to search for features in the target layer that are located
    completely within the given radius around the reference features. But first, we
    need to create a list where we will store the identifiers of such features. This
    is done in line `10`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在目标层中搜索位于参考特征给定半径范围内的特征。但首先，我们需要创建一个列表，我们将在此列表中存储此类特征的标识符。这是在第`10`行完成的。
- en: In line `11`, we start a loop over the reference features (we already have them
    in the `referenceFeatures` list; see the previous section for details). For each
    reference feature, we get its geometry (line `12`) and create a buffer around
    it using the given radius (line `13`). As the buffer distance, we use a user-defined
    search radius set with the `spnRadius` spinbox. The second parameter in the `buffer()`
    call is the number of segments used to approximate curves. Bigger values will
    result in smoother curves and more accurate results, but will also increase processing
    time a bit. Feel free to change this value if you want.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`11`行，我们开始遍历参考特征（我们已经在`referenceFeatures`列表中有了它们；详见前文部分以获取详细信息）。对于每个参考特征，我们获取其几何形状（第`12`行），并使用给定的半径在其周围创建缓冲区（第`13`行）。作为缓冲距离，我们使用用户定义的搜索半径，该半径通过`spnRadius`微调框设置。`buffer()`调用中的第二个参数是用于逼近曲线的段数。更大的值将导致更平滑的曲线和更准确的结果，但也会略微增加处理时间。如果你想要更改此值，请随意。
- en: Then, in line `15`, with the help of the spatial index, we determine which features
    from the target layer may be located within the buffered geometry, which represents
    the current reference feature. The `intersects()` method returns the identifiers
    of all features that intersect the bounding box of the given geometry. In our
    case, this is the current reference geometry.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第`15`行，借助空间索引，我们确定目标层中哪些特征可能位于缓冲几何形状内，该几何形状代表当前参考特征。`intersects()`方法返回所有与给定几何形状边界框相交的特征的标识符。在我们的情况下，这是当前参考几何形状。
- en: In line `17`, we update the range for the progress bar. It will be used to give
    visual feedback about the execution of the process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`17`行，我们更新进度条的范围。它将被用来提供关于过程执行的视觉反馈。
- en: As the spatial index performs the intersection test with the bounding box, we
    should now test each matched feature precisely. This is done from lines `19` to
    `25`. Let's take a closer look. In line `19`, a loop starts through the matched
    feature indices. In the loop, we fetch a feature by its identifier (line `20`).
    Note that we again use the previously created `request` to fetch only the feature
    geometry. Then, the feature geometry is extracted (line `21`), and we check whether
    this geometry is located completely within the buffered reference geometry (line
    `22`). If this condition is met, the feature identifier is added to the list (line
    `23`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间索引执行与边界框的交集测试，我们现在应该精确地测试每个匹配的特征。这是从第`19`行到第`25`行完成的。让我们更仔细地看看。在第`19`行，一个循环开始遍历匹配特征索引。在循环中，我们通过其标识符获取一个特征（第`20`行）。请注意，我们再次使用之前创建的`request`来仅获取特征几何形状。然后，提取特征几何形状（第`21`行），并检查此几何形状是否完全位于缓冲的参考几何形状内（第`22`行）。如果满足此条件，特征标识符将被添加到列表中（第`23`行）。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to select features using some other criteria (for example, select
    features that intersect the reference geometry), replace the `within()` operator
    with the desired operator. A list of available operators can be found in the API
    documentation of the `QgsGeometry` class at [http://qgis.org/api/classQgsGeometry.html](http://qgis.org/api/classQgsGeometry.html).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用其他标准（例如，选择与参考几何相交的特征）来选择特征，请将`within()`运算符替换为所需的运算符。可以在`QgsGeometry`类的API文档中找到可用运算符的列表，链接为[http://qgis.org/api/classQgsGeometry.html](http://qgis.org/api/classQgsGeometry.html)。
- en: Finally, in line `25`, we update the progress bar to inform the user about the
    progress.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第`25`行，我们更新进度条以通知用户进度。
- en: When all the reference features are processed and the identifiers of the matched
    features are stored in the `selection` list, we can select features in the target
    layer according to the requested selection mode (lines `27` to `33`). First, we
    determine which selection mode we need to use using the conditions in line `27`
    and line `30`. As the selection modes are added to the corresponding combobox
    consequentially (one by one), the first added item (**Create new selection**)
    will have index `0`, the second item (**Add to current selection**) will have
    index 1, and so on. So, if the index of the currently selected item of the `cmbSelectionMode`
    combobox is equal to 1, then the user is asked to add features to the current
    selection. This means that combobox indexes match the order in which the items
    are added.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有参考特征都处理完毕，并且匹配特征的标识符存储在`selection`列表中后，我们可以根据请求的选择模式在目标层中选择特征（第`27`至`33`行）。首先，我们使用第`27`行和第`30`行的条件来确定我们需要使用哪种选择模式。由于选择模式是依次添加到相应的组合框中的（一个接一个），第一个添加的项目（**创建新选择**）将具有索引`0`，第二个项目（**添加到当前选择**）将具有索引`1`，依此类推。因此，如果`cmbSelectionMode`组合框当前选中项的索引等于`1`，则用户将被要求添加特征到当前选择。这意味着组合框索引与项目添加的顺序相匹配。
- en: When the selection mode is determined, we modify the list of selected features
    by adding or removing indices of the already selected features (lines `28` to
    `29` and `31` to `32`). Finally, in line `33`, we select features in the target
    layer.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择模式确定后，我们通过添加或删除已选特征的索引来修改所选特征的列表（第`28`至`29`行和第`31`至`32`行）。最后，在第`33`行，我们在目标层中选择特征。
- en: We are almost done; now it is necessary to perform some final actions. In line
    `35`, we reset the progress bar so that it rewinds and does not show any progress.
    Then, we enable the **OK** and **Close** buttons so that the user can change the
    parameters and run the process again, or close the plugin dialog. In line `38`,
    we inform the user that the operation is complete.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；现在需要执行一些最终操作。在第`35`行，我们重置进度条，使其回滚并显示任何进度。然后，我们启用**确定**和**关闭**按钮，以便用户可以更改参数并再次运行该过程，或者关闭插件对话框。在第`38`行，我们通知用户操作已完成。
- en: If you've made all the edits correctly, your plugin should now be fully functional
    and ready for testing. Just update the plugin files in the QGIS plugins directory
    by copying the content of your working directory, reload the plugin with **Plugin
    Reloader**, and test it. If there are any errors, check your code again or look
    at the complete plugin code shipped with this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已正确完成所有编辑，你的插件现在应该完全功能正常，并准备好进行测试。只需通过复制工作目录的内容更新QGIS插件目录中的插件文件，使用**插件重载器**重新加载插件，并对其进行测试。如果有任何错误，请再次检查你的代码或查看本书附带的全套插件代码。
- en: Adding translations
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加翻译
- en: If you followed our recommendations and used the English language for all captions
    in the plugin GUI, and in all strings in the code, almost all users will be able
    to use your plugin. Moreover, as we have made all strings translatable by enclosing
    them in `self.tr()` calls, it is very easy to translate our plugin into another
    language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了我们的建议，并使用英语为插件GUI中的所有标题以及代码中的所有字符串，那么几乎所有的用户都将能够使用你的插件。此外，由于我们已经通过将它们包含在`self.tr()`调用中来使所有字符串可翻译，因此将我们的插件翻译成另一种语言非常容易。
- en: 'To do this, we need to prepare a so-called **project file**. This is a plain
    text file with a very simple structure. Create a new file and save it as `selectradius.pro`
    in the plugin root directory. Then, add the following content to it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要准备一个所谓的**项目文件**。这是一个结构非常简单的纯文本文件。创建一个新文件，并将其保存为`selectradius.pro`在插件根目录下。然后，向其中添加以下内容：
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, there is a list of all plugin source files from all subdirectories
    (lines `1` to `4`), as well as a list of all Qt Designer UI files (lines `6` to
    `7`). Finally, in lines `9` to `10`, there is a list of translation files that
    will be generated (in this example, we have Ukrainian and German).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有一个列表列出了所有子目录中的插件源文件（第`1`至`4`行），以及所有Qt Designer UI文件的列表（第`6`至`7`行）。最后，在第`9`至`10`行，有一个将要生成的翻译文件列表（在这个例子中，我们有乌克兰语和德语）。
- en: From the preceding code, you can see that we will keep translations in the `i18n`
    subdirectory, so create it if it does not exist yet.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可以看到我们将保留翻译在`i18n`子目录中，因此如果它还不存在，请创建它。
- en: 'Now open the command-line window (OSGeo shell in the case of Windows), use
    `cd` to change to the plugin directory and run this command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开命令行窗口（在Windows的情况下是OSGeo shell），使用`cd`命令切换到插件目录，并运行以下命令：
- en: '[PRE16]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will generate the `.ts` files required for each language specified in the
    project file. These files contain all the translatable strings from the plugin
    source code and UI forms. Using Qt Linguist, the `.ts` files are translated and
    "released." By "releasing" in this case, we mean converting a `.ts` file into
    a binary `.qm` file, which can be used by the Qt translation system.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成项目文件中指定的每种语言的所需 `.ts` 文件。这些文件包含插件源代码和UI表单中的所有可翻译字符串。使用 Qt Linguist，`.ts`
    文件被翻译并“发布”。在这里，“发布”的意思是将 `.ts` 文件转换为二进制的 `.qm` 文件，该文件可以被 Qt 翻译系统使用。
- en: It is necessary to mention that after altering strings or adding new files (sources
    or UI), it is a must to update the project file and regenerate the translations.
    Don't worry about already translated strings; they will be kept, and you will
    need to translate only new or modified strings.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指出，在更改字符串或添加新文件（源或UI）之后，必须更新项目文件并重新生成翻译。不用担心已经翻译的字符串；它们将被保留，你只需要翻译新或修改的字符串。
- en: Preparing the plugin for publishing
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备插件以发布
- en: Once the plugin is ready and well-tested, you may want to share it with the
    community by uploading it to the Official QGIS Python plugins repository at [https://plugins.qgis.org/](https://plugins.qgis.org/).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦插件准备就绪并且经过充分测试，你可能希望通过将其上传到官方 QGIS Python 插件仓库 [https://plugins.qgis.org/](https://plugins.qgis.org/)
    与社区分享。
- en: 'First, it is necessary to check whether the plugin meets the following requirements:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有必要检查插件是否符合以下要求：
- en: There is no malicious code in it
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中没有恶意代码
- en: There are no architecture-dependent binaries
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有架构相关的二进制文件
- en: It has the correct `metadata.txt` file with all the required items
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包含正确的 `metadata.txt` 文件，其中包含所有必需的项目
- en: We have listed the most important requirements here. Other recommendations can
    be found at the plugins repository page and in the *Releasing your plugin* chapter
    of *PyQGIS Developer Cookbook*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里列出了最重要的要求。其他建议可以在插件仓库页面和 *PyQGIS 开发者手册* 的 *发布你的插件* 章节中找到。
- en: The next step is to prepare the plugin package. QGIS plugins are distributed
    in the form of ZIP archives, and each archive contains only one plugin. As plugins
    are extracted to the QGIS plugins directory, we must ensure that the plugin has
    its own folder inside the package.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备插件包。QGIS 插件以 ZIP 归档的形式分发，每个归档只包含一个插件。由于插件被提取到 QGIS 插件目录中，我们必须确保插件在包内有自己的文件夹。
- en: 'Also, it is good practice to include only files that are absolutely required
    by the plugin in the plugin package, and omit any generated or helper files. As
    we load the UI files and icons dynamically, the only helper files we have are
    the project file and the `.ts` files (the `.qm` files should also be included
    because they are used by the Qt translation system). So, the content of our plugin
    package will look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将仅包含插件绝对需要的文件包含在插件包中是一种良好的做法，并省略任何生成的或辅助文件。由于我们动态加载 UI 文件和图标，我们拥有的唯一辅助文件是项目文件和
    `.ts` 文件（`.qm` 文件也应包含，因为它们被 Qt 翻译系统使用）。因此，我们的插件包内容将如下所示：
- en: '![Preparing the plugin for publishing](img/image00524.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![准备插件以发布](img/image00524.jpeg)'
- en: When the plugin package is created, just log in to the QGIS plugins site using
    your OSGeo ID. In the top menu, select **Plugins**. Then, on the left side of
    the page, click on the **Share a plugin** button and upload your plugin package.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件包创建完成后，只需使用你的 OSGeo ID 登录 QGIS 插件网站。在顶部菜单中，选择 **插件**。然后，在页面左侧，点击 **分享插件**
    按钮，上传你的插件包。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to create an OSGeo ID, go to the OSGeo portal at [http://www.osgeo.org/osgeo_userid](http://www.osgeo.org/osgeo_userid).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要创建一个 OSGeo ID，请访问 OSGeo 门户 [http://www.osgeo.org/osgeo_userid](http://www.osgeo.org/osgeo_userid)。
- en: That's all! Now your plugin is available for all QGIS users. Don't forget to
    create a bugtracker and home page with documentation about your plugin so that
    users can send reports about bugs and feature requests.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在你的插件对所有 QGIS 用户都可用。别忘了创建一个带有关于你的插件文档的 bug 跟踪器和主页，以便用户可以发送有关错误和功能请求的报告。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to develop QGIS plugins using the Python programming
    language. Python plugins allow us to extend the QGIS functionality by adding new
    tools or implementing new analyses or geoprocessing algorithms. You became familiar
    with the plugin architecture and their main components. Then we created the plugin
    skeleton, which can be used by many plugins. You learned how to create dialogs
    with the Qt Designer and use them in plugin. Finally, we developed a simple plugin
    for selecting features of the specified vector layer that are located within the
    given radius around reference preselected features of any other layer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Python编程语言开发QGIS插件。Python插件使我们能够通过添加新工具或实现新的分析或地理处理算法来扩展QGIS的功能。你熟悉了插件架构及其主要组件。然后我们创建了插件骨架，它可以被许多插件使用。你学习了如何使用Qt
    Designer创建对话框并在插件中使用它们。最后，我们开发了一个简单的插件，用于选择位于任何其他图层参考预选特征给定半径内的指定矢量图层中的要素。
