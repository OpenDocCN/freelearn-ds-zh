- en: Chapter 10. Developing a Python Plugin – Select by Radius
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Processing's models and scripts are great for automating different analysis
    tasks, sometimes you may want to extend the QGIS functionality in another way—by
    developing a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: QGIS plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a plugin's skeleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a plugin's GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using designer UI files in the plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing feature selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding translations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the plugin for publishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QGIS plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the very beginning, QGIS was developed with the extensible and modular
    architecture. Originally, it allowed us to extend its functionality only with
    C++ plugins. But, starting from version 0.9, when Python support was added, users
    and developers were able to create plugins using the Python programming language
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Every QGIS Python plugin is just a set of the Python modules and additional
    files bundled into a single Python package. These packages should be placed in
    separate subdirectories under a special directory in the QGIS home path. Usually,
    this is `~/.qgis2/python/plugins`, where `~` is a user home (profile) directory.
    In Windows, it is `C:\Users\your_profile`, and in UNIX-like systems, it is `/home/your_profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minimal working plugin should contain two files in this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__.py`: This is the package initialization file and the plugin''s entry
    point. It should contain the `classFactory()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata.txt`: This contains plugin metadata used by **Plugin Manager** and
    the plugins website. This metadata includes plugin name, version, description,
    and other information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, real plugins usually contain many more files in their directory: additional
    source files, GUI forms, corresponding sources with logic, icons and other resources,
    and so on. Of course, all of these files can be placed in the plugin''s root directory,
    but to keep the source tree clean and easy to maintain, files are often organized
    in subdirectories. For example, Qt Designer forms are placed in the `ui/` subdirectory,
    corresponding sources with logic under the `gui/` subdirectory, and icons and
    other resources under `resources/` subdirectory and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop QGIS plugins with Python, you will need these pieces of software:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QGIS**: This is meant for testing and debugging your plugin. It is better
    to use the same QGIS version for which the plugin is developed. If you want to
    develop a plugin that works on multiple QGIS versions, in all `2.x` series for
    example, use as old a version as possible because the newest versions may have
    some minor additions to the API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text editor or Python IDE**: Here, you will be writing your code. It is better
    to use something more advanced than the standard Notepad or any other plain text
    editor. Syntax highlighting, auto-indentation, and autocompletion will make your
    work easier and more comfortable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Designer**: This is used to design the user interface. For Windows, it
    can be installed using the `OSGeo4W` installer. The corresponding package is called
    **qt4-devel**. If you are a Linux user, use your package manager to find and install
    the Qt developer tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, to make debugging easier, we recommend that you install the **Plugin**
    **Reloader** plugin. Plugin Reloader is extremely useful because it allows you
    to reload your plugin after changing its code in one click, without having to
    restart QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will develop a plugin for selecting features of the specified
    vector layer that are located within a given distance around reference features
    (already selected by the user) of another layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of developing QGIS Python plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a plugin template with the help of the **Plugin** **Builder** plugin.
    Then, refine this template and add the necessary functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Develop the plugin manually by creating all the required files and code yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first approach (using Plugin Builder) is the most commonly used, and is
    recommended by many authors as the easiest way for novices. However, it is necessary
    to remember that while Plugin Builder is a great and user-friendly tool, it also
    hides some details, compels you to use a specific directory structure, and makes
    some assumptions about how your plugin will work. Also, a template generated by
    this plugin will contain many additional files, and these are not really necessary
    in all cases, for example, help file template, data for unit tests, shell scripts,
    and so on. Of course, all of these files can be removed or adjusted as per your
    needs, but it is necessary to have good knowledge to avoid deleting the necessary
    stuff.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a plugin manually by adding the required files
    and directories step by step. This gives us full control over the plugin structure
    and appearance and also allows us to understand things better.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the plugin's skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with developing our plugin. Create a directory for the plugin somewhere
    in your disk. As our plugin will select features within a given radius, we call
    it `Select` `by` `Radius` and use `selectradius` as the name of the plugin directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open you favorite text editor and create a file with this content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save it as `metadata.txt` in the plugin directory. This is the metadata file
    for our plugin. As you can see, it has very simple structure, similar to `INI`
    Windows files. There is only one section called `general`, which contains all
    the metadata items in the `key=value` notation. Empty strings between metadata
    items used for logical grouping can be safely removed. The order of the metadata
    items does not matter as long as all the necessary items are there and their format
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'All metadata items can be divided into two groups: mandatory and optional.
    The following metadata items are mandatory and should be always presented in the
    `metadata.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: This is the name of the plugin. Usually, it contains a human-readable
    name. Spaces and other characters such as "`-`" are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**description**: This is a short description of the plugin. Usually, it is
    one short sentence. More detailed information should be placed in the optional
    "about" item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**version**: This is the plugin version in dotted notation, for example, `1.0.1`
    (if semantic versioning is used). Avoid adding words such as "version" here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**qgisMinimumVersion**: This defines the oldest QGIS version supported by the
    current version of the plugin. The value should be in dotted notation; for example,
    if the plugin works with QGIS version greater than 2.0, this item should have
    `2.0` as the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**author**: This is the name of the plugin''s author. Enter your name as the
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**email**: This is the e-mail of the plugin''s author. Provide your valid e-mail
    address here. Note that this e-mail address is not published anywhere and is used
    only by the plugin repository admins if they need to contact the author.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All other metadata items are optional and can be blank. Here is the full list
    of optional metadata items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**about**: This contains more detailed information about plugin. It complements
    the information in the "description" metadata item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**category**: This is the helper metadata item. It helps users understand in
    which menu to look for your plugin after its installation. The supported values
    are `Raster`, `Vector`, `Database`, and `Web`. For example, if the plugin has
    to be placed under the **Vector** menu, this metadata should have the `Vector`
    value. If this is not set, the default `Plugins` value is used. Note that this
    metadata is used only as reference. You need to write the code for creating plugin
    actions in the correct menu by yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**qgisMaximumVersion**: This defines the last QGIS version supported by the
    current version of the plugin. Its value should be in dotted notation. Usually
    this is not used. By default, it is equal to the major number from `qgisMinimumVersion`
    plus 0.99\. For example, if `qgisMinimumVersion` is `2.0` and `qgisMaximumVersion`
    is not set explicitly, it will be `2.99`. This metadata is used only in rare cases
    where the plugin supports a limited subset of QGIS versions or only one QGIS version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**icon**: This is the filename or the path to the plugin icon, if any. The
    path should be relative to the base plugin directory. If this is not set, the
    default icon will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tags**: This is a comma-separated list of tags that describe the plugin.
    Try to use tags from the existing list available at the plugins website at [http://plugins.qgis.org/](http://plugins.qgis.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**changelog**: This is a list of changes in the current plugin version. It
    is a multiline item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**homepage**: This is a link to the plugin''s home page, if any. We recommend
    filling this metadata if you plan to publish your plugin in the QGIS official
    plugin repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tracker**: This is a link to the `bugtracker` plugin if any. We recommend
    filling this metadata if you plan to publish your plugin in the QGIS official
    plugin repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**repository**: This is a link to the plugin source code repository, if any.
    We recommend filling this metadata as well if you plan to publish you plugin in
    the QGIS official plugin repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**experimental**: This is a Boolean flag used to mark the plugin as experimental.
    Experimental plugins may be unstable and partly nonfunctional, so they are not
    shown in the **Plugin Manager** unless the corresponding option is set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**deprecated**: This is a Boolean flag used to mark the plugin as deprecated.
    Deprecated plugins are not supported by authors and may not work or may work incorrectly,
    so they are not shown in the Plugin Manager unless the corresponding option is
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, in our `metadata.txt` file, we have not only the mandatory items,
    but also some optional items to provide more information for plugin users. Note
    that our demo plugin has empty `homepage`, `tracker`, and `repository` metadata
    items. In a real plugin, especially if it will be published, these items should
    contain valid links to the corresponding pages so that the plugin's users can
    submit bug reports and patches and find the relevant documentation easily.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you look at the `icon` metadata item, you will see that it contains
    the relative path to the image file. So, in our plugin directory, it is necessary
    to create the `icons` subdirectory and put the `selectradius.svg` icon file into
    it. Icons can be in any raster format supported by the Qt library, but we recommend
    that you use PNG format for raster icons and SVG for vector icons. The icon size
    should be at least 24 x 24 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a plugin (and Python package) initialization file,
    `__init__.py`. This file should contain a `classFactory()` function. This function
    will be called when the plugin is loaded in QGIS. The function body is very short
    and simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `classFactory()` function accepts a single argument called `iface`—an instance
    of the `QgsInterface` class that provides access to the GUI of the running QGIS
    copy. It returns the `SelectRadiusPlugin` object, which is a plugin instance.
    The code of the `SelectRadiusPlugin` class, imported from the `selectradius_plugin.py`
    file, is located in the plugin's root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the main plugin class. Create a new file called `selectradius_plugin.py`
    in the plugin root directory and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the first seven lines of this code, we import all the necessary Python packages
    from the Python standard library, the `PyQt4` package, and the `qgis.core` library.
    Usually, these import statements are added and edited on an iterative basis during
    development. In other words, you write the code, and when a new class or library
    is needed, you add the corresponding import statement. As a rule, all import statements
    are placed at the very beginning of the source's file. For the sake of simplicity,
    in our sample plugin, we will provide all the necessary imports at the start.
  prefs: []
  type: TYPE_NORMAL
- en: In line `9`, we determine the plugin's path, which will be used later to construct
    full paths to icons.
  prefs: []
  type: TYPE_NORMAL
- en: In line `12`, a base plugin class is defined. There are several methods implemented
    in it. The `__init__()` method, also called a constructor, is used for basic initialization
    of the plugin instance. In line `14`, we store a reference to the QGIS interface—passed
    as the **iface** parameter—for further usage so that we can access and use it
    from other methods. From lines `16` to `27`, an internationalization support is
    activated. We check which locale is used by QGIS and try to load the corresponding
    translation file from the `i18n` subdirectory in the plugin tree. If no translation
    is found, the plugin will be loaded with the default locale.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We recommend that you always use English as the primary language of the plugin.
    Use it for all messages and captions on GUI widgets. As English is the most common
    and widely used language, the plugin can be used by almost all users, even without
    translations. If necessary, support for any other language can be added easily
    via the localization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: The next important, and mandatory, method that should be implemented in the
    plugin base class is `initGui()`. This method is called when the plugin is activated
    and loaded by QGIS. Here, we add the required GUI elements, such as menu items,
    toolbar buttons, and even dock widgets. We initialize all the necessary temporary
    folders and other stuff required by the plugin. In our demo plugin, this method
    starts from line `29`.
  prefs: []
  type: TYPE_NORMAL
- en: From lines `30` to `36`, we create a so-called action that will launch the plugin
    dialog. Actions are special objects that represent a command and provide a unified
    way to run that command from different places, such as menus and toolbars. First,
    we create a `QAction` instance and assign the `Select byRadius` label to it (lines
    `30` and `31`). Note that the label text is enclosed in the `self.tr()` method
    call. This method is implemented in the last two lines of the code snippet provided,
    and makes the text string translatable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in lines `32` and `33`, we construct an icon for our action. Using the
    `os.path.join()` call, we create a full path to the icon file located in the `icons`
    subdirectory of the plugin tree. This is the same icon that we specified in the
    `metadata.txt` file. Of course, you can use another icon—just put it into the
    `icons` subdirectory in the plugin tree. Next, in lines `34` and `35`, we set
    the tooltip text for our action. Note that we again use `self.tr()` here, so this
    text can also be localized. Finally, in line `36`, we set the `objectName` property
    of the action. This property is required by the QGIS customization framework.
  prefs: []
  type: TYPE_NORMAL
- en: From lines `38` to `42`, we create another action using the same approach as
    the preceding one. This action will be used to show the **About** dialog with
    some information about our plugin. The icon for this action called `about.png`,
    and it is located in the `icons` subdirectory of the plugin tree.
  prefs: []
  type: TYPE_NORMAL
- en: Then, from lines `44` to `45` and `46` to `47`, we add our actions to the **Select
    by Radius** submenu, which will be created in the QGIS **Vector** menu. In line
    `48`, we put the button that opens the main plugin dialog into the **Vector**
    toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: The last two lines (`50` and `51`) in this method are used to connect actions
    to handlers, which will be executed when the user presses buttons or selects menu
    entries. For now, both handlers—`run()` and `about()`—are empty, and we will add
    code to them later.
  prefs: []
  type: TYPE_NORMAL
- en: The second mandatory method that should be present in the plugin base class
    is `unload()`. This method is executed when the plugin is deactivated and removed
    from QGIS. Here, we should remove all of the plugin's GUI elements (buttons, menu
    entries, widgets, and so on) and perform any other cleanup actions required, such
    as removing temporary files. In our demo plugin, this method is defined in line
    `53`.
  prefs: []
  type: TYPE_NORMAL
- en: As our plugin is simple enough, we just the remove menu entries added in the
    `initGui()` method (lines `54` to `57`), as well as the toolbar button (line `58`).
  prefs: []
  type: TYPE_NORMAL
- en: In lines `60` to `64`, we define handlers for our actions. Currently, they do
    nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The last method, `tr()`, as we have already mentioned, is required for internationalization
    support. It takes English text and returns its translated equivalent, depending
    on the current locale and presence of the translation file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We implement the `tr()` method ourselves here because the main plugin class
    is a pure Python class. Almost all Qt GUI classes have built-in internationalization
    support, and this method is already present in their code. As a result, all classes
    inheriting from them also will have the `tr()` method, as you will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our plugin directory''s structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the plugin''s skeleton](img/image00519.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Such a plugin skeleton can be used as the starting point for a wide range of
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our plugin should be loadable by QGIS. You can easily check this—just
    copy the plugin directory to the QGIS plugins directory, `~/.qgis2/python/plugins`.
    Start QGIS and open **Plugin Manager** by going to **Plugins** | **Manage and
    install plugins…**. You should see the **Select by Radius** plugin in the **Installed**
    tab. After activation, the plugin will be loaded, a new button will be placed
    on the **Vector** toolbar, and a new entry with two items will appear in the **Vector**
    menu. But at this stage, these items do nothing. We need to implement their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the plugin's GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our plugin will have two dialogs: one is the main plugin dialog, which will
    be used to accept user input, and the second is the so-called About dialog, with
    some information about the plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework, on top of which QGIS is built, provides a special program
    for designing dialogs and other UI elements, such as dock widgets. It is called
    **Qt Designer**. Qt Designer is a user-friendly and easy-to-use visual form designer.
    With its help, you can create a dialog without writing code, by placing GUI widgets
    on the form using your mouse. The form definition in XML format is then saved
    in a `.ui` file, which is used by the plugin or application to construct a user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the plugin's structure clean, we will put all the `.ui` files in a separate
    subdirectory, called `ui` for example, in the plugin source tree.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the About dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start Qt Designer. In the **New form** welcome dialog, select the template
    called **Dialog with Buttons Bottom**, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the About dialog](img/image00520.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If this dialog is not opened at Designer startup, go to **File** | **New...**
    or use the *Ctrl* + *N* keyboard shortcut. A new empty Qt form will be created,
    with two buttons at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create the About dialog. We want to display the following information
    in this dialog: the plugin name, icon, version number, and a short description,
    maybe with links to the plugin home page and/or bugtracker.'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Property editor** panel (usually located in the top-right corner of
    the Designer window), find the `windowTitle` property and change it to something
    meaningful, for example, `About Select by Radius`. Go back to the form and select
    the button box. It should be marked with blue square markers now. Return to the
    **Property editor**, find the `standardButtons` property and clear the checkboxes
    from all the variants except the **Close** button. So now, our button box has
    only one button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the **Widget Box** panel (usually located to the left of the Designer
    window), find the **Label** widget inside the **Display Widgets** group and drag
    and drop it into the form. Keeping the newly added widget selected, go to **Property
    editor** and set the `objectName` property to `lblLogo`. This widget will be used
    to display the plugin icon.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `objectName` property of widgets will be used in our code to access the
    corresponding widget. So, try to assign meaningful object names for all the widgets
    that you plan to access from code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, add another **Label** widget to the form and place it on the right
    side of the previously added widget. This time, however, don''t change its `objectName`
    property. Instead, find the `text` property and press the button labeled **…**
    on the right side of the edit field. A simple text editor will be opened, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the About dialog](img/image00521.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the plugin name and then change the font size to a larger value, for example,
    `16`. Make the font bold and align the text to the center. Close the editor by
    clicking on the **OK** button. Also modify the `alignment` property to enable
    horizontal alignment by center.
  prefs: []
  type: TYPE_NORMAL
- en: Add a third label, which will be used to display the plugin version, to the
    form and change its `objectName` property to `lblVersion`. Modify the `alignment`
    property to enable horizontal alignment by center. Move this label so that it
    will be placed under the label with the plugin name. Finally, add the **TextBrowser**
    widget to the form and place it under all the labels.
  prefs: []
  type: TYPE_NORMAL
- en: Qt uses a layout-based approach to manage widgets, so your form will always
    look consistent, regardless of the themes and fonts used. To enable layout in
    our form, we just have to select the form and click on the **Lay Out in a Grid**
    button on toolbar, or select this item from the **Form** menu.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the Qt layout system can be found in the Qt documentation
    at [http://doc.qt.io/qt-4.8/layout.html](http://doc.qt.io/qt-4.8/layout.html).
    If you want to create nice-looking dialogs, this is a must-read piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now your form should look like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the About dialog](img/image00522.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If some widgets are in incorrect places, try to move them around and adjust
    their sizes. When you are satisfied with the dialog's look and feel, save it as
    `aboutdialogbase.ui` in the `ui` subdirectory in the plugin root directory.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the main plugin dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Close the saved **About** dialog and create a new empty form for the main plugin
    dialog using the same **Dialog with buttons bottom** template. Change the dialog''s
    `windowTitle` property to `Select by Radius` and adjust the button box by changing
    its `standardButtons` property so that it contains two buttons: **OK** and **Close**.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to specify a target layer from which we will select features. Add to
    the form a **Label** widget from the **Display Widgets** section of the **Widget
    Box** panel, and change its `text` property to `Select features from`. Now it
    is necessary to provide a widget where the user can choose a layer that will be
    used. **Combo Box** can be a good choice here but there is an even better solution.
    Starting from version 2.4, QGIS provides a set of custom widgets for Qt Designer.
    Among these widgets, there is a special combobox called **QgsMapLayerComboBox**.
    It is designed to display a list of layers from the QGIS layers registry. This
    widget, as well as all other QGIS-related custom widgets, can be found in the
    **QGIS custom** **widgets** section of the **Widget Box** panel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is necessary to mention here that the QGIS custom widgets section may be
    not available in your system. If you cannot find it, ensure that you have installed
    all the QGIS-related packages (for example, the Debian package with custom widgets
    called `libqgis-customwidgets`).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use an ordinal combobox instead of **QgsMapLayerCombobox**,
    but in this case, you will need to implement code to populate it with layer names
    as well as code to retrieve a layer by its name by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Drag a **QgsMapLayerComboBox** combobox onto the form, place it on the right
    side of the previously added label, and change its `objectName` property to `cmbTargetLayer`.
    By default, **QgsMapLayerCombobox** will display raster layers, vector layers
    with polygonal geometry type, and plugin layers. This is not suitable for us,
    as we need only vector layers. To change this behavior, find the `filters` property
    and clear the checkboxes from all variants except **PointLayer**, **LineLayer**,
    and **PolygonLayer** (this also activates the **HasGeometry** option automatically).
    Now, this combobox will show only vector layers with geometry types specified
    previously. Raster layers, plugin layers, and vector layers without geometry will
    be not displayed in it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we need to specify another layer—a reference layer. So, add another **Label**
    widget to the form and change its `text` property to `Around reference features
    from`. Near this label, place the second **QgsMapLayerComboBox** combobox and
    change its `objectName` property to `cmbReferenceLayer`. Apply the same filters
    to it that we used for the previously added **QgsMapLayerCombobox** combobox.
  prefs: []
  type: TYPE_NORMAL
- en: Another input value we need is a search radius. So, put another **Label** widget
    on the form, under the already added widgets. Set its `text` property to `Within
    search radius`. On the right side of this label, put **Double Spin Box** (which
    can be found in the **Input Widgets** section) and change its `objectName` property
    to `spnRadius`. Also adjust its `minimum`, `maximum`, and `value` properties to
    reasonable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the plugin more useful and flexible, we provide the user with a choice
    of how to use the selected features: create a new selection, or alter an existing
    selection. The more logical way to represent available choices is a combobox.
    Add another label from the **Display Widgets** section to the form and change
    its `text` property to `Use the result to`. On the right side of this label, place
    **Combo Box** (which can be found in the **Input Widgets** section). Change the
    `objectName` property of the newly added combobox to `cmbSelectionMode`.'
  prefs: []
  type: TYPE_NORMAL
- en: Put **Progress Bar** (which can be found in the **Display Widgets** section
    of the **Widget Box** panel) under the last label and the combobox, and change
    its `value` property to `zero`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the dialog and apply the grid layout to it by clicking on the **Lay
    Out in a Grid** button in the **Designer** toolbar. Now your form should look
    like what is shown in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing the main plugin dialog](img/image00523.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If some widgets are in incorrect places, try to move them around and adjust
    their sizes. Once you are satisfied with dialog's look and feel, save it in the
    `ui` subdirectory in the plugin root directory as `selectradiusdialogbase.ui`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is nothing complex in designing a user interface with
    the help of Qt Designer. The most important thing here is understanding how different
    types of layouts work and comply with the recommendations of the **Human** **Interface**
    **Guidelines** (**HIG**) of the corresponding project. QGIS HIG can be found in
    the `CODING` document inside QGIS sources. You can view it online at [https://github.com/qgis/QGIS/blob/master/CODING#L1429](https://github.com/qgis/QGIS/blob/master/CODING#L1429).
  prefs: []
  type: TYPE_NORMAL
- en: Using Designer UI files in the plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing the GUI with the Qt Designer is the first part of the process. Now
    we need to use the previously created `.ui` files to construct our dialogs and
    implement the logic required for handling user actions, such as clicking on buttons,
    selecting items from lists, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the About dialog to the plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start from the About dialog, as it is simple. To keep the plugin directory
    structure clean, we will store all the sources related to the plugin GUI in the
    `gui` subdirectory inside the plugin directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your text editor and create a new file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save this file in the `gui` subdirectory as `aboutdialog.py`.
  prefs: []
  type: TYPE_NORMAL
- en: At the very beginning of the file, from lines `1` to `6`, we import all the
    packages and classes that we will use later. Here, we use the Python standard
    library (the `os` and `ConfigParser` packages) as well as various `PyQt` classes
    (lines `4` to `6`).
  prefs: []
  type: TYPE_NORMAL
- en: In line `8`, we determine the plugin path, as we need it in order to construct
    full paths to the dialog's `.ui` file and plugin icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting part is lines `9` and `10`, which are actually a single
    command split into two lines due to its length. Here, we load our previously created
    `.ui` file in the Qt Designer. The `uic.loadUiType()` command returns two values:
    our custom dialog (stored as a `WIDGET` variable) and its base class (stored as
    a `BASE` variable). Using `uic` allows us to avoid compilation of UI files and
    makes plugin packaging simpler.'
  prefs: []
  type: TYPE_NORMAL
- en: In line `13`, an implementation of the `AboutDialog` class, which will represent
    our About dialog, starts. Note that in the class definition, we use the `BASE`
    and `WIDGET` variables obtained previously from the `uic.loadUiType()` call.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method, also called a constructor, performs a basic class initialization.
    In lines `15` and `16`, we set up a dialog GUI. After these lines, we can access
    all dialog widgets using `self.widgetName`, where `widgetName` is the value of
    the `objectName` property of the corresponding widget. That's why it is important
    to specify meaningful and unique object names to all widgets that will be used
    in code.
  prefs: []
  type: TYPE_NORMAL
- en: From lines `18` to `20`, we use the **ConfigParser** module from the Python
    standard library to read the plugin version from the `metadata.txt` file. Of course,
    we can enter the version number manually, but in this case, every time the plugin
    version changes, we will need to edit two files (`metadata.txt` and `aboutdialog.py`)
    instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in lines `22` and `23`, the plugin icon is constructed from the path to
    the icon file and then loaded into the corresponding dialog widget. In line `24`,
    the plugin version is displayed in the `lblVersion` label widget.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in lines `26` to `29`, we instantiate the `QTextDocument` object, which
    will be used to display the About text, and assign it to the **QTextBrowser**
    widget. Line `29` allows the user to open links by clicking on them.
  prefs: []
  type: TYPE_NORMAL
- en: Text for the About dialog is generated by the `getAboutText()` method, implemented
    in lines `31` to `37`. The implementation is simple—we just return a string containing
    a short description of the plugin in HTML format. The only important thing here
    is the usage of `self.tr()` method, which allows us to show translated About text.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Qt classes, their purpose, and their functionality,
    check out the Qt documentation at [http://doc.qt.io/qt-4.8/index.html](http://doc.qt.io/qt-4.8/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: You may ask why we don't implement any methods to handle dialog execution and
    closing. Well, as this is a very simple dialog, we don't need to perform any special
    actions. We can use default handlers, which are implemented in the base `QDialog`
    class. This means that the dialog will be opened as modal, and clicking on the
    **Close** button will close it.
  prefs: []
  type: TYPE_NORMAL
- en: That's all! Now we need to add this dialog to the plugin main class. First,
    it is necessary to create an empty `__init__.py` file in the `gui` subdirectory
    so that Python will recognize it as a package directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `selectradius_plugin.py` file. In the import section at the beginning
    of the file, add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line makes the `AboutDialog` class accessible from the main plugin class.
    Now, find the `about()` method and modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing special here. First, we instantiate `AboutDialog` and then
    execute it. Save your edits. If you want, you can update the plugin files in the
    QGIS plugins directory or copy the entire plugin directory here. Reload the plugin
    with **Plugin Reloader** and make sure that, now, when you select the **About**
    item from the **Select by Radius** menu, an **About** dialog is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the main plugin dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's implement the main plugin dialog. Create a new file and save it in
    the `gui` subdirectory of the plugin directory as `selectradiusdialog.py`. As
    this dialog is more complex, we split its code into small pieces, and we will
    examine them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you should already know, we first import all the necessary classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Besides packages from the Python standard library and PyQt classes, we also
    import several classes from the `qgis.core` and `qgis.gui` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, as in the case of `AboutDialog`, we determine the plugin path and load
    the dialog GUI from the Qt Designer file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preparation is complete. Now we can define the main dialog class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize the dialog GUI (lines `3` to `4`). In line `6`, we store
    a reference to the QGIS interface for further usage.
  prefs: []
  type: TYPE_NORMAL
- en: In lines `8` and `9`, we get references to separate buttons of the dialog's
    button box, as we will later need to access them as individual widgets. From lines
    `11` to `14`, the `cmbSelectionMode` combobox is populated with the available
    selection modes. To keep the item text translatable, we wrap it into the `self.tr()`
    calls. It is worth mentioning that combobox items have zero-based numeration,
    so the first item will have index 0, the second item will have index 1, and so
    on. Populating the combobox from code allows us to easily check the order of items
    and determine their indices. Item indices will be used later to determine user
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in line `16`, we restore the plugin's settings from the previous run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our plugin is simple enough, so there are only a few values that we want to
    save in the settings and restore. Every time a user opens the plugin dialog, we
    want to restore the previously entered search radius value and the last used selection
    mode from the **Use the result to** combobox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `loadSettings()` method is called when we want to restore the plugin's settings.
    On the first run of the plugin, we have no saved settings, so the default values
    will be picked up. The `saveSettings()` method is used to save the current values
    from the widgets to the plugin settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to save the settings when the user closes the main plugin dialog
    by clicking on the **Close** button, and we need to start the data acquisition
    process when the user clicks on the **OK** button, it is necessary to replace
    the default handlers for these signals. The corresponding code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `reject()` method (line `1`) is called when the user clicks on the **Close**
    button. This method was initially implemented in the base `QDialog` class, and
    we reimplement it in our subclass. The only thing we do here is save the current
    plugin settings (line `2`). After that, we simply call the `reject()` method of
    the base class (line 3) to close our dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The `accept()` method, defined in line `5`, is called when the user clicks on
    the **OK** button. This method is also initially implemented in the base `QDialog`
    class and reimplemented in our subclass. When the user clicks on the **OK** button,
    the plugin should check whether all the required parameters are specified, find
    all the features from the target layer that match the defined requirements, and
    finally, update the selection in the target layer.
  prefs: []
  type: TYPE_NORMAL
- en: First, in line `6`, we save the current plugin settings. Then, we check whether
    the user has selected all the necessary inputs. In line `8`, we use the `currentLayer()`
    method of `QgsMapLayerCombobox` to obtain the currently selected target layer.
    This method returns the corresponding `QgsMapLayer` instance if a layer is selected,
    otherwise it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation about the QGIS API can be found at [http://qgis.org/api/](http://qgis.org/api/).
    Also, don't forget *PyQGIS Developer Cookbook*, which contains detailed explanations
    on different topics and many useful examples. You always can read the latest *PyQGIS
    cookbook* online at [http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html](http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some samples from the latest version of the PyQGIS cookbook may not
    work with older QGIS versions due to API changes.
  prefs: []
  type: TYPE_NORMAL
- en: If no target layer is selected (this is checked in line `9`), we show a warning
    message with the `showMessage()` method (lines `10` to `13`) and return to the
    main plugin dialog (line `14`). In other words, we don't try to perform any further
    actions, as we have incomplete or invalid input. The user should specify the correct
    input and then try again.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same approach, we check whether a valid reference layer is selected
    (lines `16` to `22`).
  prefs: []
  type: TYPE_NORMAL
- en: In line `24`, we obtain a list of preselected reference features from the reference
    layer. If no reference features are selected in the reference layer, the length
    of this list will be zero. We need to catch this situation because without reference
    features, we cannot continue. This is what happens in lines `25` to `31`; if there
    are no reference features selected in the reference layer, we show the corresponding
    message and return to the main plugin dialog.
  prefs: []
  type: TYPE_NORMAL
- en: For now, this is all of the code we need to write for the `accept()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have already noticed the `showMessage()` method widely used in the
    preceding code. Here is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is just a wrapper that displays a message bar with the given text and importance
    level using the same timeout as defined in the global QGIS settings. By default,
    the `INFO` level will be used, but if necessary, we can specify any other supported
    level.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have implemented only the basic functionality of the main
    plugin dialog as of now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the main dialog to the plugin base class. To do this, open
    the `selectradius_plugin.py` file, if it is not opened already. In the import
    section at the beginning of the file, add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This line makes the `SelectRadiusDialog` class accessible from the main plugin
    class. Now, find the `run()` method and modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Again, there is nothing special here. First, we instantiate `SelectRadiusDialog`
    and then open it as a modal dialog, as we did earlier for the About dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Save your edits. If you want, you can update the plugin files in the QGIS plugins
    directory or copy the entire plugin directory here. Reload the plugin with **Plugin
    Reloader** and make sure that, now, when you select the **Select by Radius** item
    from the **Select by Radius** menu, a main plugin dialog is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing feature selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, when dialogs are created and connected to our plugin, we can start implementing
    the main functionality—namely, feature selection using requirements defined by
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `selectradiusdialog.py` file located in the `gui` subdirectory of
    the plugin source tree. Add the following code at the end of the `accept()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this moment, we have already ensured that all the necessary input fields
    are defined correctly (see the previous section), and now we can safely proceed
    with feature selection.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is necessary to block the **OK** and **Close** buttons to prevent
    accidental clicks on them, which may interrupt running processes. We do this in
    lines `1` and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Our plugin will need to request features from vector layers. As you know, every
    feature has geometry and attributes and, by default, both the geometry and attributes
    are returned when we query a feature from a layer. For our purposes, we need only
    feature geometry, so it will be better not to query attributes. This will speed
    up the process of feature retrieval, especially if the layer has a large attribute
    table or is accessed via a slow network connection.
  prefs: []
  type: TYPE_NORMAL
- en: So, in line `4`, we instantiate the `QgsFeatureRequest` object, which is used
    to customize the process of feature retrieval. From lines `5` to `6`, we alter
    its default behavior (fetch geometry and attributes) by resetting its `SubsetOfAttributes`
    flag so that only the feature geometry will be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we build a spatial index for the target layer (line `8`). A spatial index
    allows us to perform quick queries on the layer and fetch only features that intersect
    some region or are located close to the given coordinates. A spatial index also
    reduces processing time by limiting the number of features we should test against
    our spatial operator.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to search for features in the target layer that are located
    completely within the given radius around the reference features. But first, we
    need to create a list where we will store the identifiers of such features. This
    is done in line `10`.
  prefs: []
  type: TYPE_NORMAL
- en: In line `11`, we start a loop over the reference features (we already have them
    in the `referenceFeatures` list; see the previous section for details). For each
    reference feature, we get its geometry (line `12`) and create a buffer around
    it using the given radius (line `13`). As the buffer distance, we use a user-defined
    search radius set with the `spnRadius` spinbox. The second parameter in the `buffer()`
    call is the number of segments used to approximate curves. Bigger values will
    result in smoother curves and more accurate results, but will also increase processing
    time a bit. Feel free to change this value if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in line `15`, with the help of the spatial index, we determine which features
    from the target layer may be located within the buffered geometry, which represents
    the current reference feature. The `intersects()` method returns the identifiers
    of all features that intersect the bounding box of the given geometry. In our
    case, this is the current reference geometry.
  prefs: []
  type: TYPE_NORMAL
- en: In line `17`, we update the range for the progress bar. It will be used to give
    visual feedback about the execution of the process.
  prefs: []
  type: TYPE_NORMAL
- en: As the spatial index performs the intersection test with the bounding box, we
    should now test each matched feature precisely. This is done from lines `19` to
    `25`. Let's take a closer look. In line `19`, a loop starts through the matched
    feature indices. In the loop, we fetch a feature by its identifier (line `20`).
    Note that we again use the previously created `request` to fetch only the feature
    geometry. Then, the feature geometry is extracted (line `21`), and we check whether
    this geometry is located completely within the buffered reference geometry (line
    `22`). If this condition is met, the feature identifier is added to the list (line
    `23`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to select features using some other criteria (for example, select
    features that intersect the reference geometry), replace the `within()` operator
    with the desired operator. A list of available operators can be found in the API
    documentation of the `QgsGeometry` class at [http://qgis.org/api/classQgsGeometry.html](http://qgis.org/api/classQgsGeometry.html).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in line `25`, we update the progress bar to inform the user about the
    progress.
  prefs: []
  type: TYPE_NORMAL
- en: When all the reference features are processed and the identifiers of the matched
    features are stored in the `selection` list, we can select features in the target
    layer according to the requested selection mode (lines `27` to `33`). First, we
    determine which selection mode we need to use using the conditions in line `27`
    and line `30`. As the selection modes are added to the corresponding combobox
    consequentially (one by one), the first added item (**Create new selection**)
    will have index `0`, the second item (**Add to current selection**) will have
    index 1, and so on. So, if the index of the currently selected item of the `cmbSelectionMode`
    combobox is equal to 1, then the user is asked to add features to the current
    selection. This means that combobox indexes match the order in which the items
    are added.
  prefs: []
  type: TYPE_NORMAL
- en: When the selection mode is determined, we modify the list of selected features
    by adding or removing indices of the already selected features (lines `28` to
    `29` and `31` to `32`). Finally, in line `33`, we select features in the target
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done; now it is necessary to perform some final actions. In line
    `35`, we reset the progress bar so that it rewinds and does not show any progress.
    Then, we enable the **OK** and **Close** buttons so that the user can change the
    parameters and run the process again, or close the plugin dialog. In line `38`,
    we inform the user that the operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: If you've made all the edits correctly, your plugin should now be fully functional
    and ready for testing. Just update the plugin files in the QGIS plugins directory
    by copying the content of your working directory, reload the plugin with **Plugin
    Reloader**, and test it. If there are any errors, check your code again or look
    at the complete plugin code shipped with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding translations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed our recommendations and used the English language for all captions
    in the plugin GUI, and in all strings in the code, almost all users will be able
    to use your plugin. Moreover, as we have made all strings translatable by enclosing
    them in `self.tr()` calls, it is very easy to translate our plugin into another
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to prepare a so-called **project file**. This is a plain
    text file with a very simple structure. Create a new file and save it as `selectradius.pro`
    in the plugin root directory. Then, add the following content to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a list of all plugin source files from all subdirectories
    (lines `1` to `4`), as well as a list of all Qt Designer UI files (lines `6` to
    `7`). Finally, in lines `9` to `10`, there is a list of translation files that
    will be generated (in this example, we have Ukrainian and German).
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding code, you can see that we will keep translations in the `i18n`
    subdirectory, so create it if it does not exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the command-line window (OSGeo shell in the case of Windows), use
    `cd` to change to the plugin directory and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the `.ts` files required for each language specified in the
    project file. These files contain all the translatable strings from the plugin
    source code and UI forms. Using Qt Linguist, the `.ts` files are translated and
    "released." By "releasing" in this case, we mean converting a `.ts` file into
    a binary `.qm` file, which can be used by the Qt translation system.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to mention that after altering strings or adding new files (sources
    or UI), it is a must to update the project file and regenerate the translations.
    Don't worry about already translated strings; they will be kept, and you will
    need to translate only new or modified strings.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the plugin for publishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the plugin is ready and well-tested, you may want to share it with the
    community by uploading it to the Official QGIS Python plugins repository at [https://plugins.qgis.org/](https://plugins.qgis.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it is necessary to check whether the plugin meets the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no malicious code in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no architecture-dependent binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the correct `metadata.txt` file with all the required items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have listed the most important requirements here. Other recommendations can
    be found at the plugins repository page and in the *Releasing your plugin* chapter
    of *PyQGIS Developer Cookbook*.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to prepare the plugin package. QGIS plugins are distributed
    in the form of ZIP archives, and each archive contains only one plugin. As plugins
    are extracted to the QGIS plugins directory, we must ensure that the plugin has
    its own folder inside the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it is good practice to include only files that are absolutely required
    by the plugin in the plugin package, and omit any generated or helper files. As
    we load the UI files and icons dynamically, the only helper files we have are
    the project file and the `.ts` files (the `.qm` files should also be included
    because they are used by the Qt translation system). So, the content of our plugin
    package will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing the plugin for publishing](img/image00524.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the plugin package is created, just log in to the QGIS plugins site using
    your OSGeo ID. In the top menu, select **Plugins**. Then, on the left side of
    the page, click on the **Share a plugin** button and upload your plugin package.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to create an OSGeo ID, go to the OSGeo portal at [http://www.osgeo.org/osgeo_userid](http://www.osgeo.org/osgeo_userid).
  prefs: []
  type: TYPE_NORMAL
- en: That's all! Now your plugin is available for all QGIS users. Don't forget to
    create a bugtracker and home page with documentation about your plugin so that
    users can send reports about bugs and feature requests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to develop QGIS plugins using the Python programming
    language. Python plugins allow us to extend the QGIS functionality by adding new
    tools or implementing new analyses or geoprocessing algorithms. You became familiar
    with the plugin architecture and their main components. Then we created the plugin
    skeleton, which can be used by many plugins. You learned how to create dialogs
    with the Qt Designer and use them in plugin. Finally, we developed a simple plugin
    for selecting features of the specified vector layer that are located within the
    given radius around reference preselected features of any other layer.
  prefs: []
  type: TYPE_NORMAL
