- en: Chapter 7. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces functions, a fundamental building block in programming.
    We show how to define them, how to handle input and output, how to properly use
    them, and how to treat them as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, a function is written as a map that uniquely assigns an element
    *y* from the range *R* to every element *x* from the domain *D*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is expressed by *f : D → R*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, when considering particular elements *x* and *y*, one writes *f
    : x → y*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *f* is called the name of the function and *f(x)* is its value when applied
    to *x*. Here, *x* is sometimes called the argument of *f.* Let's first look at
    an example before considering functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *D =* ℝ x ℝ  and *y = f(x[1], x[2]) = x[1] - x[2]*. This function
    maps two real numbers to their difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, functions can have numbers, vectors, matrices, and even other
    functions as arguments. Here is an example of a function with mixed arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basics](img/B05511_07_01-1.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a number is returned. When working with functions, we have to
    distinguish between two different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evaluation of the function, that is, the computation of *f(x) *for a given
    value of *x*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step is done once, while the second can be performed many times for
    various arguments. Functions in programming languages follow the same concept
    and apply it to a wide range of types of input arguments, for example, strings,
    lists, or any object. We demonstrate a definition of the function by considering
    the given example again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `def`  indicates that we are going to define a function. `subtract`
    is the function’s name and `x1` and  `*x2*` are its parameters. The colon indicates
    that we are using a block command and the value that is returned by the function
    follows the `return` keyword. Now, we can evaluate this function. This function
    is called with its parameters replaced by input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result 0.7 is computed and assigned to the `r` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When defining a function, its input variables are called the parameters of the
    function. The input used when executing the function is called its argument.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments - by position and by keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will consider the previous example again, where the function takes two parameters,
    namely `x1` and `x2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Their names serve to distinguish the two numbers, which in this case cannot
    be interchanged without altering the result. The first parameter defines the number
    from which the second parameter is subtracted. When `subtract` is called, every
    parameter is replaced by an argument. Only the order of the arguments matters;
    the arguments can be any objects. For instance, we may call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides this standard way of calling a function, which is by passing the arguments
    by position, it might sometimes be convenient to pass arguments using keywords.
    The names of the parameters are the keywords; consider the following instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the arguments are assigned to the parameters by name and not by position
    in the call. Both ways of calling a function can be combined so that the arguments
    given by position come first and the arguments given by keyword follow last. We
    show this by using the function `plot`, which was described in [Chapter 6](ch06.html
    "Chapter 6. Plotting"), *Plotting*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Changing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of parameters is to provide the function with the necessary input
    data. Changing the value of the parameter inside the function normally has no
    effect on its value outside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This applies to all immutable arguments, such as strings, numbers, and tuples.
    The situation is different if mutable arguments, such as lists or dictionaries,
    are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, passing mutable input arguments to a function and changing them
    inside the function can change them outside the function too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Such a function misuses its arguments to return results. We strongly dissuade
    you from such constructions and recommend that you do not change input arguments
    inside the function (for more information refer to *Default Arguments* section).
  prefs: []
  type: TYPE_NORMAL
- en: Access to variables defined outside the local namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python allows functions to access variables defined in any of its enclosing
    program units. These are called global variables, in contrast to local variables.
    The latter are only accessible within the function. For example, consider the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature should not be abused. The following code is an example of what
    not to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When changing the variable `a` the function, `multiply` tacitly changes its
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is much better in that case to provide the variable as a parameter through
    the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Global variables can be useful when working with closures. Namespaces and scopes
    are discussed more extensively in [Chapter 11](ch11.html "Chapter 11. Namespaces,
    Scopes, and Modules"), *Namespaces, Scopes, and Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions can have many parameters, and among them some might only be of
    interest in nonstandard situations. It would be practical if arguments could automatically
    be set to standard (default) values. We demonstrate the use of default arguments
    by looking at the command `norm` in the `scipy.linalg` module. It computes various
    norms of matrices and vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet calls for computing the **Frobenius norm ** of the *3 ×
    3* identity matrix are equivalent (more on matrix norms can be found in [[10]](apa.html
    "Appendix . References") ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the first call, no information about the `ord` keyword is given.
    How does Python know that it should compute the Frobenius norm and not another
    norm, for example, the Euclidean 2-norm?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the previous question is the use of default values. A default
    value is a value already given by the function definition. If the function is
    called without providing this argument, Python uses the value that the programmer
    provided when the function was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we call the function `subtract` only one argument; we get an error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the omission of the argument `x2`, the definition of the function
    has to provide a default value, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To summarize, arguments can be given as positional arguments and keyword arguments.
    All positional arguments have to be given first. You do not need to provide all
    keyword arguments as long as those omitted arguments have default values in the
    function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Beware of mutable default arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default arguments are set upon function definition. Changing mutable arguments
    inside a function has a side effect when working with default values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Variable number of arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lists and dictionaries may be used to define or call functions with a variable
    number of arguments. Let''s define a list and a dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can call the `plot` function using starred (`*`) arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable name prefixed by `*` , such as `*data` in the preceding example,
    means that a list that gets unpacked in the function call is provided. In this
    way, a list generates positional arguments. Similarly, a variable name prefixed
    by `**`, such as `**style` in the example, unpacks a dictionary to keyword arguments.
    Refer to the following figure (*Figure 7.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable number of arguments](img/starred_arguments_on_call.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Starred arguments in function calls'
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to use the reverse process, where all given positional arguments
    are packed into a list and all keyword arguments are packed into a dictionary
    when passed to a function.
  prefs: []
  type: TYPE_NORMAL
- en: In the function definition, this is indicated by parameters prefixed by `*` 
    and `**`, respectively. You will often find the `*args` and `**kwargs` parameters
    in code documentation, refer *Figure 7.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable number of arguments](img/starred_arguments_at_definition.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Starred arguments in function definitions'
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function in Python always returns a single object. If a function has to return
    more than one object, these are packed and returned as a single tuple object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following function takes a complex number *z* and returns
    its polar coordinate representation as magnitude *r* and angle ![Return values](img/varphi.jpg)
    according to Euler’s formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Return values](img/euler.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the Python counterpart would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `sqrt(x)` NumPy function for the square root of a number `x`
    and `arctan2(x,y)` for the expression tan^(-1)(*x/y*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last three statements can be written more elegantly in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can test our function by calling `polar_to_comp`; refer to *Exercise 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function has no `return` statement, it returns the value `None`. There
    are many cases where a function does not need to return any value. This could
    be because the variables passed to a function may be subject to modification.
    Consider, for instance, the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function does not return anything because it modifies one of the
    objects that is given as an argument. We mentioned in *Parameters and Arguments*
    section why this is useful. There are many methods that behave in the same way.
    To mention the list methods only, the `append`, `extend`, `reverse`, and `sort`
    methods do not return anything (that is, they return `None` ). When an object
    is modified by a method in this way, the modification is called in-place. It is
    difficult to know whether a method changes an object, except by looking at the
    code or the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for a function, or a method, not to return anything is when it
    prints out a message or writes to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution stops at the first occurring `return` statement. Lines after
    that statement are dead code, which will never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Recursive functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, many functions are defined recursively. In this section, we
    will show how this concept can be used even when programming a function. This
    makes the relation of the program to its mathematical counterpart very clear,
    which may ease the readability of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we recommend that you use this programming technique with care,
    especially within scientific computing. In most applications, the more straightforward
    iterative approach is more efficient. This will become immediately clear from
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chebyshev polynomials are defined by a three-term recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursive functions](img/chebychev.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such a recursion needs to be initialized, that is, *T*[0](*x*) =1, *T*[1](*x*)
    = *x.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, this three term recursion can be realized by the following function
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is then called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This example also illustrates the risk of dramatically wasting computation time.
    The number of function evaluations increases exponentially with the recursion
    level and most of these evaluations are just duplicates of previous computations.
    While it might be tempting to use recursive programs for demonstrating the strong
    relation between code and mathematical definition, a production code will avoid
    this programming technique (refer to *Exercise* 6). We also refer to a technique
    called memoization (refer to [[22]](apa.html "Appendix . References") for more
    details*)* that combines recursive programming with a caching technique to save
    replicated function evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive function usually has a level parameter. In the previous example,
    it is *n.* It is used to control the function''s  two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The base case, here, the first two `if` branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive body, in which the function itself is called once or several times
    with smaller level parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The number of levels passed by an execution of a recursive function is called
    the recursion depth. This quantity should not be too large; otherwise the computation
    might no longer be effective and in the ultimate case, the following error will
    be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The maximal recursion depth depends on the memory of the computer you use. This
    error also occurs when the initialization step is missing in the function definition.
    We encourage the use of recursive programs for very small recursion depths (for
    more information, refer to the section *Infinite Iteration* of [Chapter 9](ch09.html
    "Chapter 9. Iterating"), *Iterating*.
  prefs: []
  type: TYPE_NORMAL
- en: Function documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should document your functions using a string at the beginning. This is
    called docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling `help(newton)`, you get this docstring displayed together with
    the call of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The docstring is internally saved as an attribute, `__doc__`, of the given function.
    In the example, it's `newton.__doc__`. The minimal information you should provide
    in a docstring is the purpose of the function and the description of the input
    and output objects. There are tools to automatically generate full code documentation
    by collecting all docstrings in your program (for more information refer to [[32]](apa.html
    "Appendix . References")).
  prefs: []
  type: TYPE_NORMAL
- en: Functions are objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are objects, like everything else in Python. One may pass functions
    as arguments, change their names, or delete them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Passing functions as arguments is very common when applying algorithms in scientific
    computing. The functions `fsolve`  in `scipy.optimize` for computing a zero of
    a given function or `quad` in `scipy.integrate` for computing integrals are typical
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: A function itself can have a different number of arguments with differing types.
    So, when passing your function `f` to another function `g` as argument, make sure
    that `f` has exactly the form described in the docstring of `g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The docstring of `fsolve`  gives information about its `func` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Partial application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with an example of a function with two variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function ![Partial application](img/fullsine.jpg)can be viewed as a function
    in two variables. Often one considers ω not as a free variable but as a fixed
    parameter of a family of functions *f*[ω]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Partial application](img/partialsine.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This interpretation reduces a function in two variables to a function in one
    variable, `t`, given a fixed parameter value *ω*. The process of defining a new
    function by fixing (freezing) one or several parameters of a function is called
    partial application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial applications are easily created using the Python module `functools`,
    which provides a function called `partial` for precisely this purpose. We illustrate
    this by constructing a function that returns a sine for a given frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the view that functions are objects, partial applications can be realized
    by writing a function, which itself returns a new function, with a reduced number
    of input arguments. For instance, the function could be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example the inner function `mysine` has access to the variable `freq`;
    it is neither a local variable of this function nor is it passed to it via the
    argument list. Python allows such a construction (refer to *Namespaces* section
    in [Chapter 11](ch11.html "Chapter 11. Namespaces, Scopes, and Modules"), *Namespaces,
    Scopes, and Modules*).
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions - the  lambda keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The keyword lambda is used in Python to define anonymous functions, that is;
    functions without a name and described by a single expression. You might just
    want to perform an operation on a function that can be expressed by a simple expression
    without naming this function and without defining this function by a lengthy `def`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name *lambda* originates from a special branch of calculus and mathematical
    logic, the ![Anonymous functions - the  lambda keyword](img/lambda.jpg)-calculus.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to compute the following expression, we may use SciPy’s function
    `quad`, which requires the function to be integrated as its first argument and
    the integration bounds as the next two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Anonymous functions - the  lambda keyword](img/B05511_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the function to integrate is just a simple one-liner and we use the `lambda`
    keyword to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `lambda` function can only consist of a single expression
    and in particular, cannot contain loops. `lambda` functions are, just like other
    functions, objects and can be assigned to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The lambda construction is always replaceable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to note that lambda construction is only syntactic sugar in
    Python. Any lambda construction may be replaced by an explicit function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The main reason to use a construction is for very simple functions, when a full
    function definition would be too cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda` functions provide a third way to make closures as we demonstrate by
    continuing with the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `sin_omega` function to compute the integral of the sine function
    for various frequencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Functions as decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the partial application section, we saw how a function can be used to modify
    another function. A decorator is a syntax element in Python that conveniently
    allows us to alter the behavior of a function without changing the definition
    of the function itself. Let us start with the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we have a function that determines the degree of sparsity of a
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns an error if it is not called with an array object as
    input. More precisely, it will not work with an object that does not implement
    the `reshape` method. For instance, the `how_sparse` function will not work with
    a list, because lists have no `reshape` method. The following helper function
    modifies any function with one input parameter so that it tries to make a type
    conversion to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the modified function `how_sparse = cast2array(how_sparse)` can be applied
    to any object that can be cast to an array. The same functionality is achieved
    if the definition of `how_sparse` is decorated with the type conversion function.
    It is recommend also to consider the `functools.wraps` (refer to [[8]](apa.html
    "Appendix . References") for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To define a decorator, you need a callable object such as a function that modifies
    the definition of the function to be decorated. The main purposes are:'
  prefs: []
  type: TYPE_NORMAL
- en: To increase code readability by separating parts from a function that do not
    directly serve its functionality (for example, memoizing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put common preamble and epilogue parts of a family of similar functions in
    a common place (for example, type checking)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to easily switch off and on additional functionalities of a function
    (for example, test prints, tracing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are not only the ideal tools for making your program modular, but
    they also reflect mathematical thinking. You learned the syntax of function definitions
    and to distinguish between defining and calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: We considered functions as objects that can be modified by other functions.
    When working with functions, it is important to be familiar with the notion of
    the scope of a variable and how information is passed into a function by parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is convenient to define functions on the fly with so-called anonymous
    functions. For this, we introduced the keyword lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex 1** → Write a function `polar_to_comp`, which takes two arguments *r*
    and ![Exercises](img/varphi.jpg) and returns the complex number ![Exercises](img/euler.jpg)
    Use the NumPy function `exp` for the exponential function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 2** → In the description of the Python module `functools`, (refer to [[8]](apa.html
    "Appendix . References") for more detail on functools) you find the following
    Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Explain and test this function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 3** → Write a decorator for the function `how_sparse`,  which cleans the
    input matrix *A* by setting the elements that are less than 1.e-16 to zero (consider
    example in section *Function as decorators*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex 4** → A continuous function *f* with *f*(*a*)*f*(*b*) < 0 changes its
    sign in the interval [*a, b*] and has at least one root (zero) in this interval.
    Such a root can be found with the bisection method. This method starts from the
    given interval. Then it investigates the sign changes in the subintervals,'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/subintervals.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the sign changes in the first subinterval *b* is redefined to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, it is redefined in the same manner to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And the process is repeated until the *b-a* is less than a given tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement this method as a function that takes as arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – the function *f*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: – the initial interval [*a, b*]
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: – the tolerance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This function `bisec` should return the final interval and its midpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the method with the function `arctan` and also with the polynomial *f(x)
    = 3 x² -5* in the interval [1.1, 1.4]*,* and alternatively in [1.3, 1.4].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ex. 5** → The greatest common divisor of two integers can be computed with
    Euclid’s algorithm described by the following recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Write a function that computes the greatest common divisor of two integers.
    Write another function that computes the least common multiple of these numbers
    using the relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Ex. 6** → Study the recursive implementation of Chebyshev polynomials, consider
    the example in section *Recursive Function*. Rewrite the program in a non-recursive
    way and study computation time versus polynomial degree (see also the `timeit`
    module).'
  prefs: []
  type: TYPE_NORMAL
