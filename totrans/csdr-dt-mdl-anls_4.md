# 第四章 索引

毫无疑问，Cassandra可以轻松地存储大量数据。然而，如果我们不能高效地在这样的数据深渊中找到我们想要的东西，那么这一切都是没有意义的。Cassandra通过主索引和二级索引提供了非常好的支持，以搜索和检索所需的数据。

在本章中，我们将探讨Cassandra如何使用主索引和二级索引来突出显示数据。在理解了它们之后，我们就可以设计一个高性能的数据模型。

# 主索引

Cassandra是一个基于列的数据库。每一行可以有不同的列数。单元格是值的占位符，时间戳数据通过行和列来标识。每个单元格可以存储小于2 GB的值。行通过分区进行分组。每个分区的单元格数量限制在行数乘以列数小于20亿的条件之下。每一行通过行键来标识，该键决定了存储该行的机器。换句话说，行键决定了行的节点位置。一个表的所有行键列表称为主键。主索引仅仅创建在主键上。

主键可以定义在单个列或多个列上。在任一情况下，表的主键的第一个组件是分区键。每个节点存储表的数据分区，并维护其管理的数据的主键。因此，每个节点都知道它可以管理的行键的范围，并且可以通过扫描相关副本上的行索引来定位行。节点管理的主键范围由分区键和一个称为分区器的集群范围配置参数确定。Cassandra提供了三种分区器选择，将在本章后面介绍。

主键可以通过CQL关键字`PRIMARY KEY`来定义，包括要索引的列。想象一下，我们想要将每日股票报价存储到名为`dayquote01`的Cassandra表中。`CREATE TABLE`语句创建了一个具有简单主键的表，该主键仅涉及一个列，如下面的截图所示：

![主索引](img/8884OS_04_01.jpg)

`symbol`字段被分配为`dayquote01`表的唯一键。这意味着具有相同`symbol`的所有行都存储在同一个节点上。因此，这使得这些行的检索非常高效。

或者，主键可以通过显式的`PRIMARY KEY`子句来定义，如下面的截图所示：

![主索引](img/8884OS_04_02.jpg)

与关系数据库不同，Cassandra不对主键强制唯一约束，因为在Cassandra中没有*主键违规*。使用现有行键的`INSERT`语句是允许的。因此，在CQL中，`INSERT`和`UPDATE`的行为相同，这被称为**UPSERT**。例如，我们可以将两个记录插入到`dayquote01`表中，具有相同的符号，并且不会发出主键违规的警告，如下面的截图所示：

![主索引](img/8884OS_04_03.jpg)

返回的查询结果只包含一行，而不是预期的两行。这是因为主键是符号，后一个`INSERT`语句中的行覆盖了前一个`INSERT`语句创建的记录。对于重复的主键没有警告。Cassandra简单地、默默地更新了行。这种静默的UPSERT行为有时可能会在应用逻辑中产生不良影响。

### 小贴士

因此，对于应用程序开发者来说，在应用逻辑中处理重复主键情况非常重要。不要依赖Cassandra为您检查唯一性。

实际上，当我们知道Cassandra的内部存储引擎如何存储行时，Cassandra CLI显示的以下截图会使这种行为的原因变得更加清晰：

![主索引](img/8884OS_04_04.jpg)

行键是 `0001.HK`。它用于定位哪个节点被用来存储该行。每次当我们插入或更新具有相同行键的行时，Cassandra都会盲目地定位该行并相应地修改列，即使使用了`INSERT`语句。

虽然单列主键并不罕见，但由多个列组成的复合主键更加实用。

# 复合主键和复合分区键

复合主键由多个列组成。列的顺序很重要。复合主键的结构如图所示：

![复合主键和复合分区键](img/8884OS_04_05.jpg)

列1到A被用作Cassandra的分区键，以确定分区所在的节点位置。其余的列，即列B到N，被称为排序列，用于数据的排序。排序列用于定位数据节点中的唯一记录。默认情况下，它们是有序的，并且可以在`SELECT`语句中使用`ORDER BY [DESC]`子句。此外，我们可以使用`LIMIT 1`子句获取排序键的`MIN`或`MAX`值。我们还需要在`WHERE`子句的谓词中使用排序列。在构建查询时，我们不能省略任何一个。

要定义复合主键，必须在`CREATE TABLE`或`ALTER TABLE`语句中使用显式的`PRIMARY KEY`子句。我们可以为`dayquote03`表定义一个复合主键，如下面的截图所示：

![复合主键和复合分区键](img/8884OS_04_06.jpg)

因为主键的第一部分（即`symbol`）与简单主键相同，所以分区键与`dayquote01`中的相同。因此，无论主键是复合的还是简单的，节点位置都是相同的，就像在这个例子中一样。

那么，简单主键（`symbol`）和这个复合主键（`symbol, price_time`）之间有什么区别呢？额外的字段`price_time`指示Cassandra通过`price_time`的值保证分区内行的聚类或排序。因此，复合主键按`price_time`对相同符号的行进行排序。我们在`dayquote03`表中插入两条记录，并选择所有记录以查看效果，如下面的截图所示：

![复合主键和复合分区键](img/8884OS_04_07.jpg)

如预期地返回了两条记录（与`dayquote01`中仅返回一条记录相比）。此外，结果按`price_time`的值排序。以下截图显示了`dayquote03`表中行的内部视图：

![复合主键和复合分区键](img/8884OS_04_08.jpg)

行键仍然是分区键，即`0001.HK`。然而，Cassandra将CQL `SELECT`语句返回的两个行存储为其存储中的一个单独的内部行。聚类列的值用作未在`PRIMARY KEY`子句中指定的列的前缀。由于Cassandra按列名排序存储内部列，因此CQL `SELECT`语句返回的行是按顺序存储的。简而言之，在物理节点上，当分区键的行按聚类列的顺序存储时，行的检索效率非常高。

现在你已经知道复合主键的第一部分是分区键。如果我们需要继续存储`0001.HK`的3,000条每日报价（大约10年），尽管CQL `SELECT`语句返回3,000条虚拟行，但Cassandra需要根据分区键将这些3,000条虚拟行作为一个完整的行存储在节点上。随着每日报价的存储越来越多，整个行的大小在节点上会越来越大。随着时间的推移，行将迅速变得巨大，并因此由于集群不平衡而引发严重的性能问题。解决方案是Cassandra提供的一个称为复合分区键的功能。

复合分区键将数据分散到多个节点上。它由`PRIMARY KEY`子句中的额外一组括号定义。让我们创建另一个具有复合分区键的表`dayquote04`，以便说明其效果。现在，`exchange`和`symbol`列是复合分区键的成员，而`price_time`列是一个聚类列。我们向`dayquote04`中插入相同但符号不同的两条记录，如下面的截图所示：

![复合主键和复合分区键](img/8884OS_04_09.jpg)

如以下截图所示，返回了两个内部行，它们的行键分别为`SEHK:0001.HK`和`SEHK:0002.HK`。在内部，Cassandra将复合分区键中的列连接起来作为一个内部行键。简而言之，原始的没有复合分区键的行现在被分割成两个行。由于行键现在不同，相应的行可以存储在不同的节点上。聚类列`price_time`的值仍然用作内部列名的前缀，以保留数据的顺序：

![复合主键和复合分区键](img/8884OS_04_10.jpg)

## 时间序列数据

Cassandra非常适合处理时间序列类型的数据，例如Web服务器日志文件、使用数据、传感器数据、SIP数据包等。前几节中的`dayquote01`到`dayquote04`表用于存储每日股票报价，是时间序列数据的一个例子。

我们在上一个部分中已经看到，复合分区键是一种避免过度压榨行的更好方法。它基于符号限制行的尺寸。然而，这仅仅部分解决了问题。符号行的尺寸仍然会在一段时间内增长。您还有其他建议吗？我们可以在表中定义一个人工列，`quote_date`，并将复合分区键设置为`exchange`和`quote_date`，如下面的截图所示：

![时间序列数据](img/8884OS_04_11.jpg)

现在复合分区键基于每日限制行的尺寸，并使行更加易于管理。这种方式类似于将数据插入由特定日期标记的不同桶中。因此，它被命名为**日期桶模式**。按日期分区还通过允许您删除`quote_date`的分区，使表维护更容易。日期桶模式的一个缺点是您总是需要知道分区键才能获取行。因此，在`dayquote05`中，您不能使用`ORDER BY DESC`和`LIMIT 1`子句获取最新的`quote_date`值。

日期桶模式为应用程序开发者提供了一个设计选项，以实现更平衡的集群，但集群的平衡程度取决于许多因素，其中最重要的因素是分区器的选择。

# 分区器

分区器基本上是一个哈希函数，用于计算行键的`TOKEN()`（哈希值），因此它决定了数据如何在集群的节点之间分布。选择分区器决定了哪个节点用于放置数据的第一个副本。每一行数据都由一个分区键唯一标识，并通过`TOKEN()`的值在集群中分布。Cassandra提供了以下三个分区器：

+   `Murmur3Partitioner`（自1.2版本以来为默认值）

+   `RandomPartitioner` (版本 1.2 之前的默认值)

+   `ByteOrderedPartitioner`

## Murmur3Partitioner

`Murmur3Partitioner` 提供比 `RandomPartitioner` 更快的哈希和改进的性能。在几乎所有情况下，它都是默认的分区策略，也是新集群的正确选择。它使用 *MurmurHash* 函数，该函数创建分区键的 64 位哈希值。哈希值的可能范围是从 -2^(63) 到 +2^(63) -1。当使用 `Murmur3Partitioner` 时，你可以通过在 CQL `SELECT` 语句中使用 `TOKEN()` 函数来翻页查看所有行。

## RandomPartitioner

`RandomPartitioner` 在 Cassandra 版本 1.2 之前是默认的分区器。它通过使用行键的 *MD5* 哈希值将数据均匀地分布在节点之间。哈希值的可能范围是从 0 到 2^(127) -1。MD5 哈希函数在性能上较慢，这就是为什么 Cassandra 转向了 Murmur3 哈希。当使用 `RandomPartitioner` 时，你可以通过在 CQL `SELECT` 语句中使用 `TOKEN()` 函数来翻页查看所有行。

## ByteOrderedPartitioner

如其名称所示，`ByteOrderedPartitioner` 用于有序分区。这个分区器按照键字节进行排序。令牌是通过查看分区键数据的实际值并使用键的前导字符的十六进制表示来计算的。例如，如果你想按字母顺序分区行，你可以使用其十六进制表示 `0x42` 分配一个 B `TOKEN()`。

使用 `ByteOrderedPartitioner` 允许通过主键进行有序扫描，就像你在关系型表的传统索引中移动游标一样。这种类型的范围扫描查询在 `RandomPartitioner` 中是不可能的，因为键是按照它们的 MD5 哈希顺序存储的，而不是按照键的顺序。

显然，对行执行范围扫描听起来像是 `ByteOrderedPartitioner` 的一个期望特性。有方法可以通过使用二级索引来实现相同的功能。相反，出于以下原因不建议使用 `ByteOrderedPartitioner`：

+   **负载均衡困难**：需要更多的管理开销来平衡集群。`ByteOrderedPartitioner` 要求管理员根据他们对分区键分布的估计手动计算分区范围。

+   **顺序写入可能导致热点问题**：如果应用程序倾向于一次写入或更新一个顺序的行块，写入将不会在集群中分布。它们都会流向一个节点。这对于处理时间戳数据的应用程序来说通常是一个问题。

+   **多表负载不均衡**：如果应用程序有多个表，这些表可能有不同的行键和不同的数据分布。为一张表平衡的有序分区器可能会在同一个集群中的另一张表上造成热点和不均匀的分布。

## 分页和令牌函数

当使用 `RandomPartitioner` 或 `Murmur3Partitioner` 时，行按其值的哈希值排序。因此，行的顺序没有意义。使用 CQL，即使使用 `RandomPartitioner` 或 `Murmur3Partitioner`，也可以通过 `TOKEN()` 函数遍历行，如下面的截图所示：

![分页和令牌功能](img/8884OS_04_12.jpg)

`ByteOrderedPartitioner` 以与键值相同的方式排列令牌，而 `RandomPartitioner` 和 `Murmur3Partitioner` 以完全无序的方式分配令牌。`TOKEN()` 函数使得可以遍历无序分区器的结果。它实际上直接使用令牌查询结果。

# 二级索引

由于 Cassandra 只允许每个表有一个主键，因此它支持在主键之外的列上创建二级索引。好处是可以在 `WHERE` 子句中快速、高效地查找匹配索引列的数据。每个表可以有多个二级索引。Cassandra 使用二级索引来查找不使用行键的行。在幕后，二级索引作为由 Cassandra 内部进程自动维护的单独、隐藏的表实现。与关系数据库一样，保持二级索引的更新不是免费的，因此应避免不必要的索引。

### 注意

主索引和二级索引之间的主要区别在于，主索引是一个分布式索引，用于定位存储行键的节点，而二级索引是一个本地索引，仅用于索引本地节点上的数据。

因此，在没有检查集群中的所有节点的情况下，二级索引将无法立即知道所有匹配行的位置。这使得二级索引的性能不可预测。

### 注意

当使用等值谓词时，二级索引是最有效的。这确实是一个限制，必须至少有一个等值谓词子句，以希望限制需要读入内存的行集。

此外，二级索引不能创建在主键本身上。

### 注意

**注意！**

Cassandra 中的二级索引与传统的 RDBMS 中的二级索引并不相同。它们不类似于 RDBMS 中的 B-tree 索引。它们更像是哈希。因此，范围查询在 Cassandra 的二级索引上不工作，只有等值查询在二级索引上工作。

我们可以使用 CQL 的 `CREATE INDEX` 语句在定义表之后在列上创建索引。例如，我们可能想添加一个 `sector` 列来指示股票所属的部门，如下面的截图所示：

![二级索引](img/8884OS_04_13.jpg)

如果我们想在 `dayquote06` 中搜索属于 `Properties` 的符号，我们可能会运行以下命令，如下面的截图所示：

![二级索引](img/8884OS_04_14.jpg)

由于`sector`不在主键中，我们无法直接通过`sector`查询Cassandra。相反，我们可以在列`sector`上创建一个二级索引来实现这一点，如下面的截图所示：

![二级索引](img/8884OS_04_15.jpg)

索引名称`dayquote06_sector_idx`是可选的，但必须在键空间内是唯一的。如果您不提供名称，Cassandra将分配一个类似于`dayquote06_idx`的名称。我们现在可以通过`sector`查询Cassandra的每日股票报价。

您可以看到，在先前的截图中的`WHERE`谓词子句中，主键列不存在，Cassandra使用二级索引来查找匹配选择条件的行。

## 多个二级索引

Cassandra支持在表上创建多个二级索引。如果至少有一个列参与了二级索引，则执行`WHERE`子句。因此，我们可以在`WHERE`子句中使用多个条件来过滤结果。当`WHERE`谓词子句中的多个数据匹配条件时，Cassandra将首先处理最不频繁出现的条件，以提高查询效率。

当尝试执行可能昂贵的查询，例如范围查询时，Cassandra需要`ALLOW FILTERING`子句，该子句可以对其他非索引列的值应用额外的过滤器，以对结果集进行过滤。由于它扫描所有节点上的所有行，因此它运行得非常慢。`ALLOW FILTERING`子句用于显式指导Cassandra在`WHERE`子句上执行该可能昂贵的查询，而不创建二级索引，尽管性能不可预测。

## 二级索引的注意事项

二级索引最适合具有许多行且包含较少唯一值的表，在关系数据库术语中称为低基数，这对关系数据库人员来说可能是不直观的。一个特定列中存在的唯一值越多，查询和维护索引的开销就越大。因此，它不适合查询大量记录以获取少量结果。

### 小贴士

不要对具有低基数值的列进行索引。Cassandra将二级索引仅存储为数据节点上的本地行的哈希多映射或位图索引，您可以在[https://issues.apache.org/jira/browse/CASSANDRA-1472](https://issues.apache.org/jira/browse/CASSANDRA-1472)中参考它。

在以下情况下应避免使用二级索引：

+   在大量行中，对于少量结果的高基数列

    在高基数列上的索引将导致为非常少的查询结果进行多次搜索。对于包含唯一值的列，从性能角度来看，使用索引以方便查询是可以接受的，只要对索引列族的查询量适中，并且不是持续负载。

+   在使用计数器列的表中

+   在频繁更新或删除的列上

    Cassandra 存储墓碑（行中的一个标记，表示某个列已被删除。在压缩过程中，标记的列在索引（一个隐藏的表）中被删除，直到墓碑限制达到 100 K 个单元格。超过这个限制后，使用索引值进行的查询将失败。

+   在大型分区中查找行

    在大型集群中对索引列进行查询通常需要从多个数据分区收集响应。随着集群中机器数量的增加，查询响应速度会变慢。

### 小贴士

**需要注意的重要要点**

+   不要在高基数列上建立索引

+   不要在具有计数列的表中使用索引

+   不要在频繁更新或删除的列上建立索引

+   不要滥用索引在大型分区中查找行

# 摘要

在本章中，我们学习了主索引和辅助索引。复合主键、复合分区键和分区器等相关主题也进行了介绍。通过解释 Cassandra 的内部存储和内部工作原理，你现在应该能够说明主索引和辅助索引之间的区别，并在数据模型中正确使用它们。

在下一章中，我们将开始构建使用 Cassandra 和 Python 的第一个版本的技术分析应用程序。还将提供如何将 Python 连接到 Cassandra 并收集市场数据的快速安装和设置指南。
