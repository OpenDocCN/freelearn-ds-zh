- en: Chapter 5. Analyzing Geospatial Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 分析地理空间数据
- en: In this chapter, we will look at the process of analyzing geospatial data. Sometimes,
    the results of your geospatial analysis will be one or more numbers, for example,
    *How many countries lie south of the Equator?* or *What is the length of the Australian
    coastline?* At other times, the results of your analysis will be a geometry object,
    for example, *Where is the northernmost point in Alaska?* or *What part of Texas
    lies east of New Mexico?* And at other times, the results of your analysis will
    be a list, for example, *Which countries are within 1,000 kilometers of New Guinea?*
    In all these cases, you will need to be familiar with the tools and techniques
    available for calculating your desired results.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨分析地理空间数据的过程。有时，你的地理空间分析结果可能是一或多个数字，例如，*有多少个国家位于赤道以南？* 或者 *澳大利亚海岸线的长度是多少？*
    在其他时候，你的分析结果可能是一个几何对象，例如，*阿拉斯加的最北点在哪里？* 或者 *德克萨斯州中哪些部分位于新墨西哥州以东？* 在其他时候，你的分析结果可能是一个列表，例如，*哪些国家位于新几内亚1,000公里范围内？*
    在所有这些情况下，你需要熟悉可用于计算所需结果的工具和技术。
- en: 'To help you learn these tools and techniques, we will examine the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你学习这些工具和技术，我们将检查以下内容：
- en: How to install and use two powerful Python libraries for solving geospatial
    problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装和使用两个强大的Python库来解决地理空间问题
- en: How to calculate and work with locations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何计算和操作位置
- en: How to calculate the length of a LineString geometry in real-world units
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何计算LineString几何形状在现实世界单位中的长度
- en: How to calculate the area of a Polygon using real-world units
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用现实世界单位计算多边形的面积
- en: How to use a shapefile containing roads to build an abstract model of connected
    LineString geometries, and then use that model to calculate the shortest path
    between two points.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用包含道路的shapefile构建连接的LineString几何形状的抽象模型，然后使用该模型计算两点之间的最短路径。
- en: Let's start by looking at some of the Python libraries you can use for geospatial
    analysis.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一些你可以用于地理空间分析的Python库开始。
- en: Libraries for spatial analysis
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间分析库
- en: 'You already have a couple of libraries that are useful for analyzing geospatial
    data: the OGR library includes methods for comparing and manipulating geometries,
    and Shapely is a wonderful library for working with and analyzing geometry data.
    There are, however, two other libraries that you will want to become familiar
    with: **PyProj**, which is a powerful library for calculating distances and locations
    on the Earth''s surface, and **NetworkX**, which can build abstract mathematical
    models out of geospatial data and then analyze those models to solve various problems.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有一些对分析地理空间数据有用的库：OGR库包括比较和操作几何形状的方法，Shapely是一个用于处理和分析几何数据的优秀库。然而，还有两个其他库你可能想熟悉：**PyProj**，这是一个用于在地球表面上计算距离和位置的强大库，以及**NetworkX**，它可以从地理空间数据中构建抽象的数学模型，然后分析这些模型以解决各种问题。
- en: Let's take a closer look at these two libraries and install them both onto your
    computer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地研究这两个库，并将它们都安装到你的计算机上。
- en: PyProj
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyProj
- en: PyProj ([https://pypi.python.org/pypi/pyproj](https://pypi.python.org/pypi/pyproj))
    is a powerful tool for working with spatial reference systems using Python. PyProj
    itself is simply a Python interface to the PROJ.4 cartographic projection library,
    which is written in C. So, to install PyProj, you typically need to install the
    PROJ.4 library, and then install or build PyProj itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PyProj ([https://pypi.python.org/pypi/pyproj](https://pypi.python.org/pypi/pyproj))
    是一个使用Python处理空间参考系统的强大工具。PyProj本身只是PROJ.4地图投影库的Python接口，该库是用C编写的。因此，要安装PyProj，你通常需要安装PROJ.4库，然后安装或构建PyProj本身。
- en: 'Before we get into the details of installing PyProj (and PROJ.4), let''s look
    at what this library does and how it can be useful. If you remember from [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, a spatial reference
    system is a way of representing positions on the Earth''s surface using coordinates.
    **Unprojected coordinates**, such as latitude and longitude values, directly represent
    a location on the Earth''s surface by tracing a line from the center of the earth
    out to the desired point and then measuring the angle of that line in the east-west
    and north-south directions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解安装 PyProj（和 PROJ.4）的细节之前，让我们看看这个库的功能以及它如何有用。如果你还记得 [第 2 章](ch02.html
    "第 2 章。地理空间数据") 中的内容，“地理空间数据”，空间参考系统是使用坐标表示地球表面位置的一种方式。**未投影坐标**，如纬度和经度值，通过从地球中心到所需点的线条追踪，然后测量该线条在东西和南北方向上的角度，直接表示地球表面的一个位置：
- en: '![PyProj](img/4102_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![PyProj](img/4102_05_01.jpg)'
- en: '**Projected coordinates**, on the other hand, represent locations as positions
    on a two-dimensional Cartesian plane:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**投影坐标**表示为二维笛卡尔平面上的位置：
- en: '![PyProj](img/4102_05_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![PyProj](img/4102_05_02.jpg)'
- en: A spatial reference system, also known as a cartographic projection, is a way
    of translating from points on the Earth's surface to points on a two-dimensional
    plane. PROJ.4 (and also PyProj) is a tool for working with these projections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 空间参考系统，也称为地图投影，是将地球表面的点转换为二维平面上的点的一种方式。PROJ.4（以及 PyProj）是处理这些投影的工具。
- en: 'It is vital that you know which map projection was used to generate your geospatial
    data. Using the wrong projection will ruin all your calculations and map visualizations.
    Map projections are also important because it is all-but-impossible to do spatial
    calculations using data in unprojected coordinate systems such as EPSG 4326\.
    For example, imagine that you want to calculate the area of the following polygon,
    which represents the outline of Loch Ness in Scotland:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 了解用于生成你的地理空间数据的地图投影至关重要。使用错误的投影将毁掉你所有的计算和地图可视化。地图投影也很重要，因为使用未投影坐标系统（如 EPSG 4326）中的数据进行空间计算几乎是不可能的。例如，想象一下你想计算以下多边形的面积，它代表苏格兰尼斯湖的轮廓：
- en: '![PyProj](img/4102_05_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![PyProj](img/4102_05_03.jpg)'
- en: 'The coordinates for this polygon are in EPSG 4326—that is, they are latitude
    and longitude values. If you wanted to, you could load this polygon into Shapely
    and ask it to calculate the area:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多边形的坐标是 EPSG 4326——也就是说，它们是纬度和经度值。如果你愿意，你可以将这个多边形加载到 Shapely 中，并要求它计算面积：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result, however, is an *area in degrees*, which is a meaningless number.
    This is because Shapely doesn't know about spatial reference systems. It naively
    treats the latitude and longitude values as (x,y) coordinates, which means that
    spatial calculations like this cannot produce useful or accurate results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结果是按度数计算的面积，这是一个没有意义的数字。这是因为 Shapely 不了解空间参考系统。它天真地对待纬度和经度值作为 (x,y) 坐标，这意味着这种空间计算无法产生有用或准确的结果。
- en: What you actually want is the area measured in something meaningful, such as
    square meters or square miles. This is where PyProj comes in. PyProj allows you
    to perform calculations and conversions using any spatial reference system. PyProj
    does all the heavy mathematical lifting so you don't have to.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你真正想要的是以有意义的单位（如平方米或平方英里）测量的面积。这正是 PyProj 发挥作用的地方。PyProj 允许你使用任何空间参考系统进行计算和转换。PyProj
    承担了所有的繁重数学运算，因此你不必亲自去做。
- en: 'Now, let''s install PyProj and see how it works. How you install PyProj (and
    the underlying PROJ.4 library), depends on which operating system you are using:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装 PyProj 并看看它是如何工作的。你安装 PyProj（以及底层的 PROJ.4 库）的方式取决于你使用的操作系统：
- en: For MS Windows, you can install a prebuilt copy of PyProj from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj).
    This installer includes PROJ.4, so you don't need to install it separately.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 MS Windows，你可以从 [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj)
    安装预构建的 PyProj 版本。此安装程序包括 PROJ.4，因此你不需要单独安装它。
- en: 'For Mac OS X, you will need to do the following:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Mac OS X，你需要执行以下操作：
- en: Download and install the PROJ.4 library. A Mac installer for PROJ.4 can be downloaded
    from [http://www.kyngchaos.com/software/frameworks](http://www.kyngchaos.com/software/frameworks).
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 PROJ.4 库。可以从 [http://www.kyngchaos.com/software/frameworks](http://www.kyngchaos.com/software/frameworks)
    下载 PROJ.4 的 Mac 安装程序。
- en: If you don't already have XCode installed on your computer, go to the Mac App
    store and download the latest version. XCode is Apple's development system, and
    can be downloaded for free.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你电脑上还没有安装 XCode，请前往 Mac App Store 下载最新版本。XCode 是苹果的开发系统，可以免费下载。
- en: If you are using a version of Mac OS X less than 10.9 (Yosemite), you will need
    to separately install the command-line tools. To do this, start up XCode and choose
    the **Preferences…** command from the **XCode** menu. In the **Downloads** tab,
    there will be an option to install the command-line tools; enable this option
    and wait for the required tools to be installed.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是低于 10.9（Yosemite）版本的 Mac OS X，你需要单独安装命令行工具。为此，启动 XCode 并从 **XCode** 菜单中选择
    **Preferences…** 命令。在 **Downloads** 选项卡中，将有一个安装命令行工具的选项；启用此选项并等待所需工具安装完成。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using Mac OS X 10.9 (Yosemite) or later, you can skip this step.
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是 Mac OS X 10.9（Yosemite）或更高版本，你可以跳过此步骤。
- en: Download the source code to PyProj from [https://pypi.python.org](https://pypi.python.org).
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://pypi.python.org](https://pypi.python.org) 下载 PyProj 的源代码。
- en: 'Using the terminal, `cd` into the PyProj directory you downloaded and type
    the following commands:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用终端，`cd` 到你下载的 PyProj 目录，并输入以下命令：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, start up Python and try typing the following command:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，启动 Python 并尝试输入以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Python prompt should reappear without any error message.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 提示符应该会重新出现，没有任何错误信息。
- en: For Linux, you can either use your favorite package manager to install PROJ.4
    and then PyProj, or else you can build them both from source by following the
    instructions available at [http://trac.osgeo.org/proj](http://trac.osgeo.org/proj)
    and [https://github.com/jswhit/pyproj](https://github.com/jswhit/pyproj).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Linux，你可以使用你喜欢的包管理器安装 PROJ.4 和 PyProj，或者你可以按照 [http://trac.osgeo.org/proj](http://trac.osgeo.org/proj)
    和 [https://github.com/jswhit/pyproj](https://github.com/jswhit/pyproj) 上提供的说明从源代码构建它们。
- en: 'Now that you have installed PyProj, let''s see how the library can be used.
    There are two main classes provided by PyProj:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了 PyProj，让我们看看这个库是如何使用的。PyProj 提供了两个主要的类：
- en: '**Proj**: This class represents a spatial projection, and allows you to convert
    coordinates, either singly or en masse, between projections'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Proj**：这个类代表一个空间投影，并允许你将坐标在投影之间进行单次或批量转换'
- en: '**Geod**: This is a *geodetic* *computation* class that allows you to perform
    various calculations based on coordinates that use a given spatial reference system'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Geod**：这是一个 *大地测量* *计算* 类，允许你根据使用给定空间参考系统的坐标执行各种计算'
- en: 'Let''s see how PyProj can be used to calculate the distance between two points.
    Open up a terminal window, start up your Python interpreter, and enter the following
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 PyProj 来计算两点之间的距离。打开一个终端窗口，启动你的 Python 解释器，并输入以下代码：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The two coordinates represent the locations of the cities of Rotorua and Wellington,
    in New Zealand:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个坐标代表新西兰罗托鲁阿和惠灵顿两座城市的地理位置：
- en: '![PyProj](img/4102_05_05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![PyProj](img/4102_05_05.jpg)'
- en: All going well, you should see the number 374,729 printed out, which is the
    as-the-crow-flies (great circle) distance between these two cities, measured in
    meters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到打印出数字 374,729，这是这两座城市之间的直线距离（大圆距离），单位是米。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we use `ellps="WGS84"` to set the spatial reference system for our
    Geod object. This value sets the mathematical model for the shape of the Earth
    to be used by the geodetic calculator—WGS84 is the name for the ellipsoid used
    by the EPSG 4326 spatial reference system, so we are effectively telling PyProj
    that the coordinates are measured in latitude and longitude.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `ellps="WGS84"` 来设置 Geod 对象的空间参考系统。此值设置了用于大地测量计算器地球形状的数学模型——WGS84 是
    EPSG 4326 空间参考系统使用的椭球体的名称，因此我们实际上是在告诉 PyProj 坐标是以纬度和经度测量的。
- en: PyProj can also be used to convert between coordinate systems. We will look
    at this shortly, when we see how it can be combined with Shapely to perform accurate
    spatial calculations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: PyProj 还可以用于在坐标系之间进行转换。我们将在看到它如何与 Shapely 结合以执行精确的空间计算时简要介绍这一点。
- en: NetworkX
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NetworkX
- en: 'NetworkX is a Python library for defining and analyzing mathematical **graphs**.
    In mathematical terms, a graph is a collection of **vertices** joined together
    by **edges**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX 是一个用于定义和分析数学 **图** 的 Python 库。在数学术语中，图是由 **顶点** 通过 **边** 连接在一起的一组：
- en: '![NetworkX](img/4102_05_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![NetworkX](img/4102_05_06.jpg)'
- en: Each edge is typically assigned a value, called a **weight**, which can be used
    to perform queries against the graph. Each edge can be **directed**—that is, you
    can only follow the edge in one direction—or it can be undirected, allowing you
    to follow the edge in either direction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每条边通常都会分配一个值，称为**权重**，它可以用来对图进行查询。每条边可以是**有向的**——也就是说，你只能沿着一个方向跟随边——或者它可以是无向的，允许你沿着任意方向跟随边。
- en: While these graphs are an interesting mathematical concept, they are also useful
    for geospatial analysis because you can use a graph to represent locations and
    the ways of moving between them. For example, the vertices may represent towns,
    while the edges may represent roads that connect these various towns together.
    When used in this way, the edges are usually weighted by how long the road is,
    so that longer roads have a greater weight, and the entire graph can be used to
    calculate the shortest path between two points.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些图是一个有趣的数学概念，但它们在地理空间分析中也非常有用，因为你可以使用图来表示地点以及在这些地点之间移动的方式。例如，顶点可能代表城镇，而边可能代表连接这些城镇的道路。当以这种方式使用时，边通常根据道路的长度进行加权，这样较长的道路就有更大的权重，整个图可以用来计算两点之间的最短路径。
- en: NetworkX is a very powerful library for working with mathematical graphs. Even
    better, it includes the ability to read a shapefile and convert it into a graph.
    This allows you to very simply convert geospatial data into an abstract graph
    representation, which you can then use to analyze the relationship between locations
    in various useful ways.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX是一个用于处理数学图非常强大的库。更好的是，它包括读取shapefile并将其转换为图的能力。这允许你非常简单地转换地理空间数据为抽象图表示，然后你可以用它以各种有用的方式分析地点之间的关系。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In NetworkX, the vertices in a graph are called **nodes**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetworkX中，图中的顶点被称为**节点**。
- en: Let's go ahead and install the NetworkX library now. The main website for NetworkX
    can be found at [https://networkx.github.io](https://networkx.github.io), and
    you can download the library directly from [https://pypi.python.org/pypi/networkx](https://pypi.python.org/pypi/networkx).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续安装NetworkX库。NetworkX的主网站可以在[https://networkx.github.io](https://networkx.github.io)找到，你可以直接从[https://pypi.python.org/pypi/networkx](https://pypi.python.org/pypi/networkx)下载库。
- en: Since NetworkX is written in pure Python, you can simply download the source
    code and then type `python setup.py install` to install it into your `site-packages`
    directory, or if you prefer you can install it using pip by typing `pip install
    networkx`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NetworkX是用纯Python编写的，你可以简单地下载源代码，然后输入`python setup.py install`将其安装到你的`site-packages`目录中，或者如果你更喜欢，你可以通过输入`pip
    install networkx`使用pip安装它。
- en: For more details, refer to the NetworkX installation instructions, which can
    be found at [http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多详细信息，请参阅NetworkX的安装说明，可以在[http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html)找到。
- en: 'Once you have installed NetworkX, check that it works by typing the following
    into the Python command prompt:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你安装了NetworkX，可以通过在Python命令提示符中输入以下内容来检查它是否工作：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This simple program builds a NetworkX graph where the nodes represent cities
    and the edges represent roads connecting those cities. For each edge, the weight
    represents the driving distance in miles between those two cities. Using this
    simple graph, we then ask NetworkX to show us the shortest path between New York
    and Portland in Oregon.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序构建了一个NetworkX图，其中的节点代表城市，而边代表连接这些城市的道路。对于每条边，权重代表这两个城市之间的驾驶距离（英里）。使用这个简单的图，我们然后要求NetworkX显示纽约和俄勒冈州波特兰之间的最短路径。
- en: 'All going well, running the preceding code will tell you that the shortest
    path is to go from New York to San Francisco, and from there to Portland:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，运行前面的代码将告诉你最短路径是从纽约到旧金山，然后从那里到波特兰：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Obviously, there is a lot more you can do with NetworkX, and we will be using
    this library later in this chapter. For the moment, however, it's enough to know
    that you can use NetworkX to build an abstract graph out of your spatial data,
    and then use the NetworkX analysis functions to calculate useful information based
    on your graph.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以用NetworkX做更多的事情，我们将在本章后面使用这个库。然而，目前来说，了解你可以使用NetworkX从你的空间数据中构建一个抽象图，然后使用NetworkX的分析函数根据你的图计算有用的信息就足够了。
- en: Spatial analysis recipes
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间分析食谱
- en: Now that we have a full set of geospatial analysis libraries available to us,
    let's see how we can use them to solve some real-world problems. We will look
    at how we can calculate and work with locations, lengths, and areas, as well as
    how we can use NetworkX to calculate the shortest available path between two points.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了一套完整的地理空间分析库，让我们看看我们如何使用它们来解决一些实际问题。我们将探讨如何计算和操作位置、长度和面积，以及如何使用 NetworkX
    来计算两点之间的最短路径。
- en: Calculating and comparing coordinates
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算和比较坐标
- en: As we saw earlier, PyProj can be used to calculate the real-world distance between
    two locations. It can also be used to measure the angle of a line going between
    two points, and calculate new points based on a starting point, a distance, and
    a heading.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，PyProj 可以用来计算两个位置之间的实际距离。它还可以用来测量两点之间线的角度，并基于起点、距离和航向计算新点。
- en: Let's use PyProj to calculate the distance between two points. We will then
    use it to calculate a location at a certain distance and heading from a given
    point.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 PyProj 来计算两点之间的距离。然后我们将用它来计算从给定点出发的一定距离和航向的位置。
- en: 'Start by creating a new Python program named `coord_analysis.py`. Enter the
    following code into the start of this program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的 Python 程序，命名为 `coord_analysis.py`。将以下代码输入到这个程序的开始部分：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So far, this is identical to the code we saw earlier: we simply import the
    PyProj library and create a geodetic calculation object based on the WGS84 ellipsoid.
    If you remember, this is the mathematical model of the Earth''s surface that is
    used by the standard EPSG 4326 spatial reference system.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这与我们之前看到的代码相同：我们只是导入 PyProj 库并基于 WGS84 椭球体创建一个大地测量计算对象。如果你还记得，这是标准 EPSG
    4326 空间参考系统所使用的地球表面的数学模型。
- en: 'We are now going to add some code to prompt the user to enter the desired coordinates.
    This is all standard Python code, and should not require any further explanation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一些代码来提示用户输入所需的坐标。这完全是标准的 Python 代码，不需要任何进一步的解释：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have the two sets of latitude and longitude values, we can use
    PyProj to calculate the actual distance between these two points:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两组纬度和经度值，我们可以使用 PyProj 来计算这两点之间的实际距离：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is exactly the same code that we saw earlier. The `geod.inv()` method takes
    the two coordinates and returns the *heading* (the angle in degrees of a line
    from the first point to the second point, measured clockwise from due north),
    the *inverse heading* (the angle of a line from the second point back to the first
    point, again measured clockwise from due north), and the *distance* (measured
    in meters) between the two points.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们之前看到的相同代码。`geod.inv()` 方法接受两个坐标，并返回 *航向*（从第一个点到第二个点的线角度，从正北顺时针测量），*逆航向*（从第二个点回到第一个点的线角度，同样从正北顺时针测量），以及两点之间的
    *距离*（以米为单位）。
- en: Notice that the call to `geod.inv()` requires us to supply the longitude value
    before the latitude value. This is because PyProj works with any coordinate system,
    and the longitude represents the x (left-to-right) value, while the latitude represents
    the y (bottom-to-top) value. The x value is always listed first when dealing with
    generic coordinates that could be in any spatial reference system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 `geod.inv()` 需要我们在纬度值之前提供经度值。这是因为 PyProj 与任何坐标系统一起工作，而经度代表 x（从左到右）值，而纬度代表
    y（从下到上）值。在处理可能位于任何空间参考系统中的通用坐标时，x 值始终列在第一位。
- en: 'Now that we have calculated these three numbers, let''s display them so that
    the user can see the results of our calculation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了这三个数字，让我们显示它们，以便用户可以看到我们计算的结果：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To check it out, save your program and run it in a terminal window. Then enter
    the following coordinates into your program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，请保存你的程序并在终端窗口中运行它。然后输入以下坐标到你的程序中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These two coordinates represent the locations of San Francisco and Los Angeles.
    Assuming that you have entered the program correctly, the following results should
    be displayed:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个坐标代表旧金山和洛杉矶的位置。假设你已正确输入程序，以下结果应该会显示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This tells us that if we were in a plane directly above downtown San Francisco
    and flew 559 kilometers at a heading of 136.38 degrees (measured clockwise from
    due north), you would end up in downtown Los Angeles. Similarly, if you were in
    Los Angeles and headed 559 kilometers at a heading of -41.17 degrees (again measured
    clockwise from due north), you would end up in San Francisco:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，如果我们直接在旧金山市中心上空的飞机上飞行559公里，航向为136.38度（从正北顺时针测量），你将最终到达洛杉矶市中心。同样，如果你在洛杉矶，航向为-41.17度（再次从正北顺时针测量），你将最终到达旧金山：
- en: '![Calculating and comparing coordinates](img/4102_05_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![计算和比较坐标](img/4102_05_07.jpg)'
- en: 'Now, let''s add some code to calculate the coordinates for a point a certain
    distance and heading from an existing location. Comment out everything you wrote
    after the end of the `get_coord()` function, and then add the following to the
    end of your program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些代码来计算从现有位置出发，一定距离和航向的点的坐标。注释掉`get_coord()`函数之后的全部内容，然后添加以下内容到程序末尾：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a simple utility function to prompt the user to enter a numeric value.
    We will use this (along with the `get_coord()` function we wrote earlier) to prompt
    the user for the information we will need. Now add the following to the end of
    your program:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实用函数，用于提示用户输入数值。我们将使用这个（以及我们之前编写的`get_coord()`函数）来提示用户输入我们需要的信息。现在将以下内容添加到程序末尾：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we convert the distance measured in kilometers into the distance
    in meters—PyProj always works in meters, so we have to provide the distance in
    meters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将以公里为单位的距离转换为以米为单位的距离——PyProj始终以米为单位工作，因此我们必须以米为单位提供距离。
- en: 'We are now ready to calculate the ending coordinate. Using PyProj, this is
    easy:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以计算终点坐标了。使用PyProj，这很简单：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `geod.fwd()` method returns the desired coordinate (with the X value listed
    first), as well as the inverse heading. Our last task is to display these results
    to the user:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`geod.fwd()`方法返回所需的坐标（X值列在前面），以及反向航向。我们的最后一个任务是向用户显示这些结果：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run this program, you can try entering a starting point, heading and
    distance, and the program will display the ending point. For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你可以尝试输入起点、航向和距离，程序将显示终点。例如：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The calculated end point is not quite the same as the value we saw earlier.
    This is because the distance and heading are only specified to two decimal degrees
    of accuracy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的终点坐标与之前看到的不完全相同。这是因为距离和航向只指定到小数点后两位的精度。
- en: Of course, for our program, we commented out the first calculation so we could
    concentrate on the second. An obvious improvement would be to add a simple text
    prompt asking the user which calculation to perform. But you can see how PyProj
    can be used to calculate and compare points on the Earth's surface—something that
    cannot be done easily when you use latitude and longitude values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于我们的程序，我们注释掉了第一次计算，以便我们能够专注于第二次计算。一个明显的改进是添加一个简单的文本提示，询问用户要执行哪个计算。但你可以看到PyProj是如何用来计算和比较地球表面上的点的——当你使用经纬度值时，这不容易做到。
- en: Calculating lengths
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算长度
- en: Now that we know how to calculate the distance (in meters) between two points,
    let's apply this technique to calculate the true length of any LineString geometry.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何计算两点之间的距离（以米为单位），让我们应用这项技术来计算任何LineString几何形状的真实长度。
- en: 'To calculate the total length of a LineString geometry, we need to split the
    LineString up into individual line segments, calculate the length of each line
    segment, and sum the result to get the total length of the entire LineString:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算LineString几何形状的总长度，我们需要将LineString分割成单个线段，计算每个线段的长度，然后将结果相加以获得整个LineString的总长度：
- en: '![Calculating lengths](img/4102_05_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![计算长度](img/4102_05_08.jpg)'
- en: To see this in action, we need some LineString geometries to work with. For
    this example, we will use LineStrings representing the primary and secondary roads
    in California. This data can be downloaded from the US Census Bureau's website
    at [https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html).
    Scroll down to the section labeled **2014 TIGER/Line Shapefiles**, and click on
    the **Download** option, then click on **Web interface**. From the download page,
    choose **Roads** from the **Select a layer type** drop-down menu, and then click
    on the **Submit** button. Finally, choose **California** from the **Primary and
    Secondary Roads** drop-down menu, and click on the **Download** button to download
    the required data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个动作，我们需要一些LineString几何来工作。在这个例子中，我们将使用代表加利福尼亚州主要和次要道路的LineStrings。这些数据可以从美国人口普查局的网站[https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html)下载。向下滚动到标记为**2014
    TIGER/Line Shapefiles**的部分，然后点击**下载**选项，然后点击**Web interface**。在下载页面，从**Select
    a layer type**下拉菜单中选择**Roads**，然后点击**Submit**按钮。最后，从**Primary and Secondary Roads**下拉菜单中选择**California**，然后点击**Download**按钮以下载所需数据。
- en: 'The resulting shapefile will be in a compressed ZIP archive named `tl_2014_06_prisecroads.zip`.
    Decompress this archive, and place the resulting shapefile somewhere convenient.
    Create a new file in the same directory as the shapefile with the name `calc_lengths.py`,
    and then enter the following code into this file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的shapefile将是一个名为`tl_2014_06_prisecroads.zip`的压缩ZIP存档。解压这个存档，并将生成的shapefile放置在方便的位置。在shapefile所在的目录中创建一个名为`calc_lengths.py`的新文件，然后将以下代码输入到这个文件中：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This should all be quite familiar to you—we just import the various libraries
    we will use, create a new `pyproj.Geod` object to use for our length calculations,
    and then iterate over the contents of the shapefile one feature at a time. As
    you can see, we use the `shapely.wkt.loads()` function to convert the feature
    into a Shapely geometry object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切对你来说都应该非常熟悉——我们只是导入我们将要使用的各种库，创建一个新的`pyproj.Geod`对象用于我们的长度计算，然后逐个遍历shapefile的内容。正如你所见，我们使用`shapely.wkt.loads()`函数将特征转换为Shapely几何对象。
- en: 'Now that we have a Shapely geometry, our next task is to split that geometry
    into individual line segments and calculate the length of each segment. Let''s
    do that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Shapely几何，我们的下一个任务是将其分割成单独的线段并计算每个线段的长度。让我们来做这件事：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the Shapely geometry is a LineString, we can access the individual coordinates
    that make up the LineString using `geometry.coords`. We then process each pair
    of coordinates in turn, using the technique we learned earlier to calculate the
    distance in meters between the two coordinates. We keep track of the total calculated
    length across all the coordinate pairs, giving us the total length of the LineString
    geometry.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Shapely几何是LineString，我们可以使用`geometry.coords`访问构成LineString的各个坐标。然后我们依次处理每一对坐标，使用我们之前学到的技术来计算两个坐标之间以米为单位的距离。我们跟踪所有坐标对的总计算长度，从而得到LineString几何的总长度。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If our road data had been in a projected coordinate system that preserved distances,
    we could have simply asked Shapely to calculate the total length of each LineString
    by accessing the `geometry.length` attribute. This won't work for EPSG 4326 data,
    however, because once again the results would be a length in degrees.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的道路数据是在一个保持距离的投影坐标系中，我们可以简单地要求Shapely通过访问`geometry.length`属性来计算每个LineString的总长度。然而，这对于EPSG
    4326数据是不行的，因为结果又将是度数长度。
- en: 'Our last task is to do something with the calculated length. Let''s simply
    print it out, along with the name of the road:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个任务是处理计算出的长度。让我们简单地打印出来，包括道路的名称：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In theory, our program should now work, so let''s try running it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们的程序现在应该可以工作了，让我们尝试运行它：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So far so good; as you can see, the total length of each road, in meters, is
    being calculated. Unfortunately, if we wait a few more seconds, our program will
    raise a Python exception and stop:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利；正如你所见，每条道路的总长度（以米为单位）正在被计算。不幸的是，如果我们再等几秒钟，我们的程序将引发Python异常并停止：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What''s going on here? It seems that `geometry.coords` is not available because
    the geometry is not an ordinary LineString. Indeed, if you remember from [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, shapefiles make
    no distinction between simple geometries and collections of those geometries,
    so a LineString in the shapefile might actually be a collection of LineStrings.
    This is exactly what is happening in this case—if you were to load the affected
    feature into memory using the interactive Python command prompt, you could print
    out the geometry type to see what is wrong:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？看起来`geometry.coords`不可用，因为几何形状不是一个普通的LineString。实际上，如果您还记得[第二章](ch02.html
    "第二章。地理空间数据")中的内容，shapefiles在简单几何形状和这些几何形状的集合之间没有区别，因此shapefile中的LineString实际上可能是一系列LineString的集合。这正是本例中发生的情况——如果您使用交互式Python命令提示符将受影响的要素加载到内存中，您可以打印出几何类型以查看问题所在：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So we have a road represented by a MultiLineString geometry rather than a LineString
    geometry. Fortunately, it''s easy to split apart a MultiLineString and process
    the individual LineStrings one at a time. Here is what our entire program looks
    like once we add this feature:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们用MultiLineString几何形状而不是LineString几何形状来表示道路。幸运的是，很容易将MultiLineString拆分并逐个处理单个LineString。以下是添加此功能后我们整个程序的外观：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using this technique, we can calculate the exact length, in meters, for any
    linear geometry such as a LineString or MultiLineString. Indeed, we could even
    use the same technique to calculate the perimeter of a polygon geometry, by accessing
    the polygon''s exterior linear ring and then processing it as if it were a LineString:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以计算任何线性几何形状（如LineString或MultiLineString）的确切长度，单位为米。实际上，我们甚至可以使用相同的技巧来计算多边形几何形状的周长，通过访问多边形的外部线性环，然后将其处理成LineString：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Calculating areas
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算面积
- en: In [Chapter 2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, we
    saw how we can calculate the area of a polygon using OGR and the World Mollweide
    projection (EPSG 54009). World Mollweide is an equal-area map projection that
    is reasonably accurate worldwide, and so is useful for calculating areas in square
    meters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html "第二章。地理空间数据")中，我们了解到如何使用OGR和世界莫勒韦德投影（EPSG 54009）来计算多边形的面积。世界莫勒韦德是一种等面积地图投影，在全球范围内具有较高的准确性，因此适用于计算平方米面积。
- en: Instead of using OGR, let's apply the same technique using Shapely. The advantage
    of doing this is that we'll have access to all of Shapely's functionality, allowing
    us to manipulate and measure geometries in all sorts of useful ways. To do this,
    we will make use of a handy Shapely function called `shapely.ops.transform()`.
    This lets you apply a transformation function to every coordinate within a geometry.
    The transformation can be anything you want (you can write your own transformation
    function in Python if you want), but most importantly, you can use PyProj to implement
    a transformation function that converts from EPSG 4326 to ESPG 54009 so that you
    can accurately calculate the area for any geometry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用OGR，让我们使用Shapely应用相同的技巧。这样做的好处是，我们将能够访问Shapely的所有功能，允许我们以各种有用的方式操作和测量几何形状。为此，我们将使用一个方便的Shapely函数`shapely.ops.transform()`。这个函数允许您将转换函数应用于几何形状中的每个坐标。转换可以是任何您想要的内容（如果您想的话，您可以在Python中编写自己的转换函数），但最重要的是，您可以使用PyProj实现一个转换函数，将EPSG
    4326转换为EPSG 54009，以便您能够准确计算任何几何形状的面积。
- en: 'Let''s see how this works. Place a copy of the `TM_WORLD_BORDERS-0.3` shapefile
    you downloaded earlier into a convenient directory, and create a new file named
    `calc_areas.py` in the same directory. Then enter the following code into this
    new file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。将您之前下载的`TM_WORLD_BORDERS-0.3` shapefile的副本放入一个方便的目录中，并在同一目录中创建一个名为`calc_areas.py`的新文件。然后，将以下代码输入到这个新文件中：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, we have defined a transformation function, `latlong_to_mollweide()`,
    that converts a given latitude and longitude value into an (x,y) coordinate in
    the Mollweide coordinate reference system. Mollweide is based on meters, so Shapely
    can then perform calculations against that geometry and return a result in meters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们定义了一个转换函数`latlong_to_mollweide()`，它将给定的纬度和经度值转换为莫勒韦德坐标系中的(x,y)坐标。莫勒韦德基于米，因此Shapely可以针对该几何形状进行计算，并以米为单位返回结果。
- en: 'When you run the `calc_areas.py` program, you should see a list of countries
    and the area of the associated polygons in the World Borders Dataset, measured
    in square kilometers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `calc_areas.py` 程序时，你应该会看到一个国家列表以及与 World Borders Dataset 中相关多边形的面积，以平方公里为单位：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The great thing about using `shapely.ops.transform()` is that you can use all
    of Shapely''s calculative and geometry-manipulation features on the resulting
    geometries. For example, New Zealand has an exclusive economic zone that extends
    200 miles out from the coastline. Using the `buffer()` method, you could calculate
    the shape of this exclusive economic zone by expanding the outline of New Zealand
    to include all points within 200 miles of the coastline:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `shapely.ops.transform()` 的好处是，你可以对生成的几何形状使用 Shapely 的所有计算和几何操作功能。例如，新西兰有一个专属经济区，从海岸线向外延伸
    200 英里。使用 `buffer()` 方法，你可以通过将新西兰的轮廓扩展到包括海岸线 200 英里内的所有点来计算这个专属经济区的形状：
- en: '![Calculating areas](img/4102_05_09.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![计算面积](img/4102_05_09.jpg)'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Buffering is an extremely powerful operation. For example, you can use `buffer()`
    along with the `intersects()` method to identify all countries within a given
    distance of a starting geometry. For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是一个极其强大的操作。例如，你可以使用 `buffer()` 与 `intersects()` 方法一起识别给定起始几何形状一定距离内的所有国家。例如：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Calculating shortest paths
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算最短路径
- en: For our final example, we will take a shapefile containing road data and use
    it to calculate the shortest path between two points. This is a fairly complex
    example employing various techniques for analyzing and manipulating geometry data.
    It also uses the NetworkX library to perform the shortest path calculation on
    an abstract representation of the road network.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终示例中，我们将使用包含道路数据的 shapefile 来计算两点之间的最短路径。这是一个相当复杂的示例，使用了各种分析和操作几何数据的技术。它还使用了
    NetworkX 库在道路网络的抽象表示上执行最短路径计算。
- en: 'Let''s start by looking at how NetworkX converts a shapefile containing LineString
    geometries into an abstract network. If you were to look at a small part of the
    `tl_2014_06_prisecroads` shapefile, you would see what appears to be a connected
    series of roads, for example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从看看 NetworkX 如何将包含 LineString 几何形状的 shapefile 转换为抽象网络开始。如果你查看 `tl_2014_06_prisecroads`
    shapefile 的一小部分，你会看到看起来像是一系列相连的道路，例如：
- en: '![Calculating shortest paths](img/4102_05_10.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![计算最短路径](img/4102_05_10.jpg)'
- en: 'However, the roads don''t actually stop where they intersect—the road features
    simply continue on, overlapping other roads as necessary. On the map, these may
    look like intersections, but there is no real intersection point where two roads
    meet or cross:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，道路实际上并没有在它们相交的地方停止——道路特征只是继续延伸，根据需要与其他道路重叠。在地图上，这些可能看起来像是交叉点，但实际上在两条道路相遇或交叉的地方没有真正的交叉点：
- en: '![Calculating shortest paths](img/4102_05_11.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![计算最短路径](img/4102_05_11.jpg)'
- en: This is important because of the way NetworkX converts LineString geometries
    into an abstract graph—NetworkX will think that two LineStrings intersect if and
    only if they have identical starting or ending points; simply crossing over does
    not mean that the two roads intersect. In the preceding example, **Road 2** and
    **Road 4** will be the only roads that are considered to be connected—even though
    **Road 2** appears to intersect with **Road 1** and **Road 3**, the lack of matching
    endpoints means that these roads will be excluded from the graph.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为 NetworkX 将 LineString 几何形状转换为抽象图的方式——NetworkX 会认为只有当两个 LineString 具有相同的起始或结束点时它们才会相交；简单的交叉并不意味着两条道路相交。在先前的例子中，**道路
    2** 和 **道路 4** 将是唯一被认为是相连的道路——即使 **道路 2** 看起来与 **道路 1** 和 **道路 3** 相交，由于没有匹配的端点，这些道路将被排除在图之外。
- en: 'To allow NetworkX to convert the road shapefile into a network, we need to
    split the roads at the points where they intersect:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许 NetworkX 将道路 shapefile 转换为网络，我们需要在道路相交的点处分割道路：
- en: '![Calculating shortest paths](img/4102_05_12.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![计算最短路径](img/4102_05_12.jpg)'
- en: Mathematically speaking, this is known as generating a **planar graph** out
    of the network of overlapping roads. This process is not perfect—it ignores places
    where bridges and viaducts, not to mention *Do Not Enter* signs, prevent a traveler
    from taking a particular turnoff. However, converting the road shapefile into
    a planar graph is a good starting point, and you can always exclude particular
    intersections from the calculation if you have a list of bridges and other no-entry
    points.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，这被称为从重叠道路网络中生成**平面图**。这个过程并不完美——它忽略了桥梁和立交桥，以及*禁止进入*标志阻止旅行者采取特定转弯的地方。然而，将道路形状文件转换为平面图是一个好的起点，如果你有一份桥梁和其他禁止进入点的列表，你总是可以排除特定的交叉口来计算。
- en: 'Let''s go ahead and convert our road shapefile into a planar graph. To do this,
    create a new Python program called `split_roads.py`, and enter the following code
    into this file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将我们的道路形状文件转换为平面图。为此，创建一个新的Python程序，命名为`split_roads.py`，并将以下代码输入到这个文件中：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Apart from the extra `import` statements (which we will need shortly), this
    code should be fairly clear: we''re simply loading the LineString geometries from
    our `tl_2014_06_prisecroads.shp` shapefile into the `all_roads` list.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了额外的`import`语句（我们很快就会需要它们）之外，这段代码应该相当清晰：我们只是将`tl_2014_06_prisecroads.shp`形状文件中的LineString几何形状加载到`all_roads`列表中。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If your shapefile is in a different directory, edit the `SRC_SHAPEFILE` constant
    so that the program can find the shapefile.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的形状文件在不同的目录中，编辑`SRC_SHAPEFILE`常量，以便程序可以找到形状文件。
- en: 'Our next task is to split the roads up at the intersection points. Fortunately,
    Shapely makes this quite easy. Add the following to the end of your program:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是分割交叉口处的道路。幸运的是，Shapely使这变得相当简单。将以下内容添加到程序的末尾：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, we identify any roads that cross the current road by calling
    Shapely''s `crosses()` method. We then use the `difference()` method to remove
    each crossroad from the current road; this has the effect of splitting the road
    up at the point where the other road crosses it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们通过调用Shapely的`crosses()`方法来识别与当前道路交叉的任何道路。然后，我们使用`difference()`方法从当前道路中移除每个交叉口；这会在其他道路与之交叉的点将道路分割开来：
- en: '![Calculating shortest paths](img/4102_05_13.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![计算最短路径](img/4102_05_13.jpg)'
- en: 'Finally, we want to save the split roads back into a shapefile. To do this,
    add the following code to the end of your program:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们想要将分割的道路保存回形状文件。为此，将以下代码添加到程序的末尾：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This code should be familiar to you, as we used the same technique in [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, when we looked
    at how to write vector data into a shapefile. The only new thing here is the fact
    that we're using `shutil.rmtree()` followed by `os.mkdir()` to delete and then
    re-create the directory in which we store the shapefile; this allows us to run
    the program again without having to remember to delete the shapefile each time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码你应该很熟悉，因为我们已经在[第2章](ch02.html "第2章。地理空间数据")中使用了相同的技巧，当我们查看如何将矢量数据写入形状文件时。这里唯一的新事物是我们使用`shutil.rmtree()`后跟`os.mkdir()`来删除并重新创建存储形状文件的目录；这允许我们再次运行程序，而无需每次都记得删除形状文件。
- en: This completes our `split_roads.py` program. It will take a few minutes to split
    all 8,000 roads in the `tl_2014_06_prisecroads` shapefile, so just leave it running
    as you start working on the next program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的`split_roads.py`程序。将`tl_2014_06_prisecroads`形状文件中的8,000条道路分割开来可能需要几分钟时间，所以当你开始编写下一个程序时，只需让它运行即可。
- en: 'Once we have the set of split roads, we''ll want to have another program which
    uses them to calculate the shortest path between two points. Let''s start writing
    that program now. We''ll call this program `calc_shortest_path.py`. Create this
    file, and enter the following code into it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了分割道路的集合，我们就会想要另一个程序来使用它们来计算两点之间的最短路径。现在让我们开始编写这个程序。我们将把这个程序命名为`calc_shortest_path.py`。创建这个文件，并将以下代码输入到其中：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are now going to write some utility functions which we''ll need to do the
    shortest-path calculation. First off, we''ll use the technique we saw earlier
    to calculate the distance in meters between two points:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一些实用函数，这些函数是我们进行最短路径计算所需的。首先，我们将使用我们之前看到的技巧来计算两点之间以米为单位的距离：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will use this function to write another function that calculates the total
    length of a LineString geometry:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个函数来编写另一个函数，用于计算LineString几何形状的总长度：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will need a copy of the `get_coord()` function we wrote earlier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要复制我们之前编写的`get_coord()`函数：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is one more function that we need to write: `find_closest_node`. This
    will find the node within a NetworkX graph that is closest to a given latitude
    and longitude value. We will need this to identify the starting and ending nodes
    for the shortest-path calculation.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写一个额外的函数：`find_closest_node`。这个函数将在NetworkX图中找到最接近给定纬度和经度值的节点。我们需要这个函数来识别最短路径计算中的起始和结束节点。
- en: 'Here is the code for the `find_closest_node` function, which you should add
    to the end of your program:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`find_closest_node`函数的代码，你应该将其添加到程序的末尾：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To find the closest node, we simply go through all the nodes (vertices) in the
    graph and calculate the distance in meters between the node and the desired coordinate.
    We then select and return the node with the smallest distance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最近的节点，我们只需遍历图中的所有节点（顶点），并计算节点与所需坐标之间的距离（以米为单位）。然后我们选择并返回距离最小的节点。
- en: 'We are now ready to start writing the main part of our program. The first step
    is to ask NetworkX to read the `split_roads` shapefile and create a graph out
    of the road data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始编写程序的主要部分。第一步是让NetworkX读取`split_roads`形状文件，并从道路数据中创建一个图：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This reads through the shapefile and generates a NetworkX graph, where each
    edge represents a road and each node represents the endpoint of a road. Because
    NetworkX has no way of knowing how a road or endpoint should be identified, it
    uses the latitude and longitude to identify each endpoint (that is, each node),
    and the starting and ending latitude and longitude to identify each road (that
    is, each edge). Thus, the resulting graph will consist of nodes and edges that
    look something like the following diagram:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将读取形状文件并生成一个NetworkX图，其中每条边代表一条道路，每个节点代表道路的端点。因为NetworkX无法知道如何识别道路或端点，它使用纬度和经度来识别每个端点（即每个节点），以及起始和结束的纬度和经度来识别每条道路（即每条边）。因此，生成的图将包含类似于以下图示的节点和边：
- en: '![Calculating shortest paths](img/4102_05_14.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![计算最短路径](img/4102_05_14.jpg)'
- en: The resulting graph will be quite large, as there are almost 10,000 roads to
    be imported from our shapefile.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图将会相当大，因为我们几乎需要从我们的shapefile中导入10,000条道路。
- en: 'Our next task might seem a bit odd: because there is no guarantee that every
    road can be reached from every other road, we need to reduce the graph down to
    just the reachable set of roads. If we don''t do this, our shortest-path calculation
    is likely to fail. To remove the unreachable roads, we use the `connected_component_subgraphs()`
    function to identify the portion of the graph which contains the largest number
    of connected roads, and use this subgraph for the shortest-path calculation. Here
    is the necessary code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务可能看起来有些奇怪：因为没有保证每条道路都能从其他每条道路到达，我们需要将图缩减到仅包含可到达的道路集合。如果我们不这样做，我们的最短路径计算很可能会失败。为了移除不可到达的道路，我们使用`connected_component_subgraphs()`函数来识别包含最多连接道路的图的一部分，并使用这个子图进行最短路径计算。以下是必要的代码：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that, because the `connected_component_subgraphs()` function requires an
    undirected graph, while the `read_shp()` function returns a directed graph, we
    have to use the `to_undirected()` method to make the graph undirected.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`connected_component_subgraphs()`函数需要一个无向图，而`read_shp()`函数返回一个有向图，所以我们必须使用`to_undirected()`方法使图变为无向。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you get a `'list' object has no attribute 'next'` error, you may be using
    a different version of NetworkX. In this case, replace this line with `graph =
    networkx.connected_component_subgraphs(graph.to_undirected())[0]`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到`'list' object has no attribute 'next'`错误，你可能在使用NetworkX的不同版本。在这种情况下，将此行替换为`graph
    = networkx.connected_component_subgraphs(graph.to_undirected())[0]`。
- en: 'Now that we have the useable set of roads, our next task is to calculate the
    length of each of these roads. This length value will be used as the basis for
    the shortest-path calculation. Fortunately, the length calculation is quite straightforward:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了可用的道路集合，我们的下一个任务是计算每条道路的长度。这个长度值将作为最短路径计算的基础。幸运的是，长度计算相当直接：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we extract the original LineString geometry for each edge, in
    WKT format, and then use that to create a Shapely geometry object. We then use
    our `calc_length()` function to calculate the total length of the road and store
    the resulting value as a `length` attribute into the edge. Running this code will
    calculate and store the length for every road in the graph.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们提取了每个边的原始LineString几何形状，以WKT格式表示，然后使用它来创建一个Shapely几何对象。然后我们使用我们的`calc_length()`函数来计算道路的总长度，并将结果值作为`length`属性存储到边中。运行此代码将计算并存储图中每条道路的长度。
- en: 'With this done, we are finally ready to calculate the shortest path. We start
    by asking the user to enter the latitude and longitude values for the desired
    start and end points:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们终于可以计算最短路径了。我们首先要求用户输入所需起始点和终点的大致纬度和经度值：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The values entered by the user define two coordinates; we need to use these
    to identify the starting and ending nodes. We can do this using the `find_closest_node()`
    function we wrote earlier:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的值定义了两个坐标；我们需要使用这些坐标来识别起始节点和结束节点。我们可以使用我们之前编写的`find_closest_node()`函数来完成这项工作：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can get the shortest path between the two nodes, based on the length
    values we calculated earlier:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据之前计算出的长度值，获取两个节点之间的最短路径：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The returned `path` value is a list of the nodes that make up the shortest
    path. Let''s finish our program by printing out the details of this path:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的`path`值是由构成最短路径的节点组成的列表。让我们通过打印出这条路径的详细信息来完成我们的程序：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we''ve completed the program, let''s test it out. Run the `calc_shortest_path.py`
    script. The program will start by loading the road network into memory and calculating
    the length for each road:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了程序，让我们来测试一下。运行`calc_shortest_path.py`脚本。程序将首先将道路网络加载到内存中，并计算每条道路的长度：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After the lengths are calculated, the program will then prompt you for the
    desired starting and ending coordinates. Let''s enter the coordinates for Oakland
    and San Louis Obespo, which are both cities within California:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算长度之后，程序将提示您输入所需的起始和结束坐标。让我们输入奥克兰和圣路易斯奥比斯波这两个位于加利福尼亚州的城市坐标：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The program will then calculate the nearest matching nodes, and the shortest
    path between these two points:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 程序接下来将计算最近的匹配节点，以及这两点之间的最短路径：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Of course, printing out the latitude and longitude of each endpoint like this
    isn't particularly useful—it would be much nicer for the user if we displayed
    the shortest path on a map. If you wanted to, you could save the calculated path
    into a shapefile and then use Mapnik to display the contents of that shapefile
    as part of a map. But you can see how the shortest path calculation works, and
    what's required to get road data into a format that NetworkX can work with.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像这样打印出每个终点的纬度和经度并不特别有用——如果我们在地图上显示最短路径，对用户来说会更好。如果您愿意，可以将计算出的路径保存到shapefile中，然后使用Mapnik将shapefile的内容作为地图的一部分显示出来。但您可以看到最短路径计算是如何工作的，以及将道路数据转换为NetworkX可以处理格式的所需条件。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about two new useful libraries for analyzing geospatial
    data. We then looked at various techniques for manipulating and analyzing spatial
    data, including ways of accurately calculating distances, lengths, locations,
    and areas.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了两个用于分析地理空间数据的新有用库。然后我们探讨了各种操作和分析空间数据的技术，包括准确计算距离、长度、位置和面积的方法。
- en: Next, we looked at how to convert intersecting roads into a planar graph, which
    we stored in a shapefile so that we could perform a shortest-path calculation
    based on the road data. Finally, we wrote a program to calculate the shortest
    path between any two points. As we worked through these various problems, we learned
    a number of techniques for manipulating and analyzing geospatial data—techniques
    which you will use regularly when you write your own programs for geospatial analysis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了如何将交叉道路转换为平面图，并将其存储为shapefile，以便基于道路数据进行最短路径计算。最后，我们编写了一个程序来计算任意两点之间的最短路径。在我们解决这些各种问题时，我们学习了许多操作和分析地理空间数据的技术——这些技术您在编写自己的地理空间分析程序时将经常使用。
- en: In the next chapter, we will bring together everything you have learned to implement
    a complete geospatial analysis system using Python.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把您所学的一切结合起来，使用Python实现一个完整的地理空间分析系统。
