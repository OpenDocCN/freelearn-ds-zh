- en: Chapter 5. Analyzing Geospatial Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the process of analyzing geospatial data. Sometimes,
    the results of your geospatial analysis will be one or more numbers, for example,
    *How many countries lie south of the Equator?* or *What is the length of the Australian
    coastline?* At other times, the results of your analysis will be a geometry object,
    for example, *Where is the northernmost point in Alaska?* or *What part of Texas
    lies east of New Mexico?* And at other times, the results of your analysis will
    be a list, for example, *Which countries are within 1,000 kilometers of New Guinea?*
    In all these cases, you will need to be familiar with the tools and techniques
    available for calculating your desired results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you learn these tools and techniques, we will examine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install and use two powerful Python libraries for solving geospatial
    problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to calculate and work with locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to calculate the length of a LineString geometry in real-world units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to calculate the area of a Polygon using real-world units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a shapefile containing roads to build an abstract model of connected
    LineString geometries, and then use that model to calculate the shortest path
    between two points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at some of the Python libraries you can use for geospatial
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries for spatial analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You already have a couple of libraries that are useful for analyzing geospatial
    data: the OGR library includes methods for comparing and manipulating geometries,
    and Shapely is a wonderful library for working with and analyzing geometry data.
    There are, however, two other libraries that you will want to become familiar
    with: **PyProj**, which is a powerful library for calculating distances and locations
    on the Earth''s surface, and **NetworkX**, which can build abstract mathematical
    models out of geospatial data and then analyze those models to solve various problems.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at these two libraries and install them both onto your
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: PyProj
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyProj ([https://pypi.python.org/pypi/pyproj](https://pypi.python.org/pypi/pyproj))
    is a powerful tool for working with spatial reference systems using Python. PyProj
    itself is simply a Python interface to the PROJ.4 cartographic projection library,
    which is written in C. So, to install PyProj, you typically need to install the
    PROJ.4 library, and then install or build PyProj itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into the details of installing PyProj (and PROJ.4), let''s look
    at what this library does and how it can be useful. If you remember from [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, a spatial reference
    system is a way of representing positions on the Earth''s surface using coordinates.
    **Unprojected coordinates**, such as latitude and longitude values, directly represent
    a location on the Earth''s surface by tracing a line from the center of the earth
    out to the desired point and then measuring the angle of that line in the east-west
    and north-south directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PyProj](img/4102_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Projected coordinates**, on the other hand, represent locations as positions
    on a two-dimensional Cartesian plane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PyProj](img/4102_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A spatial reference system, also known as a cartographic projection, is a way
    of translating from points on the Earth's surface to points on a two-dimensional
    plane. PROJ.4 (and also PyProj) is a tool for working with these projections.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is vital that you know which map projection was used to generate your geospatial
    data. Using the wrong projection will ruin all your calculations and map visualizations.
    Map projections are also important because it is all-but-impossible to do spatial
    calculations using data in unprojected coordinate systems such as EPSG 4326\.
    For example, imagine that you want to calculate the area of the following polygon,
    which represents the outline of Loch Ness in Scotland:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PyProj](img/4102_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The coordinates for this polygon are in EPSG 4326—that is, they are latitude
    and longitude values. If you wanted to, you could load this polygon into Shapely
    and ask it to calculate the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The result, however, is an *area in degrees*, which is a meaningless number.
    This is because Shapely doesn't know about spatial reference systems. It naively
    treats the latitude and longitude values as (x,y) coordinates, which means that
    spatial calculations like this cannot produce useful or accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: What you actually want is the area measured in something meaningful, such as
    square meters or square miles. This is where PyProj comes in. PyProj allows you
    to perform calculations and conversions using any spatial reference system. PyProj
    does all the heavy mathematical lifting so you don't have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s install PyProj and see how it works. How you install PyProj (and
    the underlying PROJ.4 library), depends on which operating system you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: For MS Windows, you can install a prebuilt copy of PyProj from [http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj](http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyproj).
    This installer includes PROJ.4, so you don't need to install it separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Mac OS X, you will need to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download and install the PROJ.4 library. A Mac installer for PROJ.4 can be downloaded
    from [http://www.kyngchaos.com/software/frameworks](http://www.kyngchaos.com/software/frameworks).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't already have XCode installed on your computer, go to the Mac App
    store and download the latest version. XCode is Apple's development system, and
    can be downloaded for free.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using a version of Mac OS X less than 10.9 (Yosemite), you will need
    to separately install the command-line tools. To do this, start up XCode and choose
    the **Preferences…** command from the **XCode** menu. In the **Downloads** tab,
    there will be an option to install the command-line tools; enable this option
    and wait for the required tools to be installed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Mac OS X 10.9 (Yosemite) or later, you can skip this step.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Download the source code to PyProj from [https://pypi.python.org](https://pypi.python.org).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the terminal, `cd` into the PyProj directory you downloaded and type
    the following commands:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, start up Python and try typing the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The Python prompt should reappear without any error message.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: For Linux, you can either use your favorite package manager to install PROJ.4
    and then PyProj, or else you can build them both from source by following the
    instructions available at [http://trac.osgeo.org/proj](http://trac.osgeo.org/proj)
    and [https://github.com/jswhit/pyproj](https://github.com/jswhit/pyproj).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have installed PyProj, let''s see how the library can be used.
    There are two main classes provided by PyProj:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proj**: This class represents a spatial projection, and allows you to convert
    coordinates, either singly or en masse, between projections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geod**: This is a *geodetic* *computation* class that allows you to perform
    various calculations based on coordinates that use a given spatial reference system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how PyProj can be used to calculate the distance between two points.
    Open up a terminal window, start up your Python interpreter, and enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The two coordinates represent the locations of the cities of Rotorua and Wellington,
    in New Zealand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PyProj](img/4102_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All going well, you should see the number 374,729 printed out, which is the
    as-the-crow-flies (great circle) distance between these two cities, measured in
    meters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we use `ellps="WGS84"` to set the spatial reference system for our
    Geod object. This value sets the mathematical model for the shape of the Earth
    to be used by the geodetic calculator—WGS84 is the name for the ellipsoid used
    by the EPSG 4326 spatial reference system, so we are effectively telling PyProj
    that the coordinates are measured in latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: PyProj can also be used to convert between coordinate systems. We will look
    at this shortly, when we see how it can be combined with Shapely to perform accurate
    spatial calculations.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NetworkX is a Python library for defining and analyzing mathematical **graphs**.
    In mathematical terms, a graph is a collection of **vertices** joined together
    by **edges**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![NetworkX](img/4102_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each edge is typically assigned a value, called a **weight**, which can be used
    to perform queries against the graph. Each edge can be **directed**—that is, you
    can only follow the edge in one direction—or it can be undirected, allowing you
    to follow the edge in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: While these graphs are an interesting mathematical concept, they are also useful
    for geospatial analysis because you can use a graph to represent locations and
    the ways of moving between them. For example, the vertices may represent towns,
    while the edges may represent roads that connect these various towns together.
    When used in this way, the edges are usually weighted by how long the road is,
    so that longer roads have a greater weight, and the entire graph can be used to
    calculate the shortest path between two points.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkX is a very powerful library for working with mathematical graphs. Even
    better, it includes the ability to read a shapefile and convert it into a graph.
    This allows you to very simply convert geospatial data into an abstract graph
    representation, which you can then use to analyze the relationship between locations
    in various useful ways.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In NetworkX, the vertices in a graph are called **nodes**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and install the NetworkX library now. The main website for NetworkX
    can be found at [https://networkx.github.io](https://networkx.github.io), and
    you can download the library directly from [https://pypi.python.org/pypi/networkx](https://pypi.python.org/pypi/networkx).
  prefs: []
  type: TYPE_NORMAL
- en: Since NetworkX is written in pure Python, you can simply download the source
    code and then type `python setup.py install` to install it into your `site-packages`
    directory, or if you prefer you can install it using pip by typing `pip install
    networkx`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, refer to the NetworkX installation instructions, which can
    be found at [http://networkx.github.io/documentation/latest/install.html](http://networkx.github.io/documentation/latest/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed NetworkX, check that it works by typing the following
    into the Python command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This simple program builds a NetworkX graph where the nodes represent cities
    and the edges represent roads connecting those cities. For each edge, the weight
    represents the driving distance in miles between those two cities. Using this
    simple graph, we then ask NetworkX to show us the shortest path between New York
    and Portland in Oregon.
  prefs: []
  type: TYPE_NORMAL
- en: 'All going well, running the preceding code will tell you that the shortest
    path is to go from New York to San Francisco, and from there to Portland:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, there is a lot more you can do with NetworkX, and we will be using
    this library later in this chapter. For the moment, however, it's enough to know
    that you can use NetworkX to build an abstract graph out of your spatial data,
    and then use the NetworkX analysis functions to calculate useful information based
    on your graph.
  prefs: []
  type: TYPE_NORMAL
- en: Spatial analysis recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a full set of geospatial analysis libraries available to us,
    let's see how we can use them to solve some real-world problems. We will look
    at how we can calculate and work with locations, lengths, and areas, as well as
    how we can use NetworkX to calculate the shortest available path between two points.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating and comparing coordinates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw earlier, PyProj can be used to calculate the real-world distance between
    two locations. It can also be used to measure the angle of a line going between
    two points, and calculate new points based on a starting point, a distance, and
    a heading.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use PyProj to calculate the distance between two points. We will then
    use it to calculate a location at a certain distance and heading from a given
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new Python program named `coord_analysis.py`. Enter the
    following code into the start of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this is identical to the code we saw earlier: we simply import the
    PyProj library and create a geodetic calculation object based on the WGS84 ellipsoid.
    If you remember, this is the mathematical model of the Earth''s surface that is
    used by the standard EPSG 4326 spatial reference system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to add some code to prompt the user to enter the desired coordinates.
    This is all standard Python code, and should not require any further explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the two sets of latitude and longitude values, we can use
    PyProj to calculate the actual distance between these two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same code that we saw earlier. The `geod.inv()` method takes
    the two coordinates and returns the *heading* (the angle in degrees of a line
    from the first point to the second point, measured clockwise from due north),
    the *inverse heading* (the angle of a line from the second point back to the first
    point, again measured clockwise from due north), and the *distance* (measured
    in meters) between the two points.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the call to `geod.inv()` requires us to supply the longitude value
    before the latitude value. This is because PyProj works with any coordinate system,
    and the longitude represents the x (left-to-right) value, while the latitude represents
    the y (bottom-to-top) value. The x value is always listed first when dealing with
    generic coordinates that could be in any spatial reference system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have calculated these three numbers, let''s display them so that
    the user can see the results of our calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To check it out, save your program and run it in a terminal window. Then enter
    the following coordinates into your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'These two coordinates represent the locations of San Francisco and Los Angeles.
    Assuming that you have entered the program correctly, the following results should
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that if we were in a plane directly above downtown San Francisco
    and flew 559 kilometers at a heading of 136.38 degrees (measured clockwise from
    due north), you would end up in downtown Los Angeles. Similarly, if you were in
    Los Angeles and headed 559 kilometers at a heading of -41.17 degrees (again measured
    clockwise from due north), you would end up in San Francisco:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating and comparing coordinates](img/4102_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add some code to calculate the coordinates for a point a certain
    distance and heading from an existing location. Comment out everything you wrote
    after the end of the `get_coord()` function, and then add the following to the
    end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple utility function to prompt the user to enter a numeric value.
    We will use this (along with the `get_coord()` function we wrote earlier) to prompt
    the user for the information we will need. Now add the following to the end of
    your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we convert the distance measured in kilometers into the distance
    in meters—PyProj always works in meters, so we have to provide the distance in
    meters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to calculate the ending coordinate. Using PyProj, this is
    easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `geod.fwd()` method returns the desired coordinate (with the X value listed
    first), as well as the inverse heading. Our last task is to display these results
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program, you can try entering a starting point, heading and
    distance, and the program will display the ending point. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The calculated end point is not quite the same as the value we saw earlier.
    This is because the distance and heading are only specified to two decimal degrees
    of accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for our program, we commented out the first calculation so we could
    concentrate on the second. An obvious improvement would be to add a simple text
    prompt asking the user which calculation to perform. But you can see how PyProj
    can be used to calculate and compare points on the Earth's surface—something that
    cannot be done easily when you use latitude and longitude values.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating lengths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to calculate the distance (in meters) between two points,
    let's apply this technique to calculate the true length of any LineString geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the total length of a LineString geometry, we need to split the
    LineString up into individual line segments, calculate the length of each line
    segment, and sum the result to get the total length of the entire LineString:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating lengths](img/4102_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To see this in action, we need some LineString geometries to work with. For
    this example, we will use LineStrings representing the primary and secondary roads
    in California. This data can be downloaded from the US Census Bureau's website
    at [https://www.census.gov/geo/maps-data/data/tiger-line.html](https://www.census.gov/geo/maps-data/data/tiger-line.html).
    Scroll down to the section labeled **2014 TIGER/Line Shapefiles**, and click on
    the **Download** option, then click on **Web interface**. From the download page,
    choose **Roads** from the **Select a layer type** drop-down menu, and then click
    on the **Submit** button. Finally, choose **California** from the **Primary and
    Secondary Roads** drop-down menu, and click on the **Download** button to download
    the required data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting shapefile will be in a compressed ZIP archive named `tl_2014_06_prisecroads.zip`.
    Decompress this archive, and place the resulting shapefile somewhere convenient.
    Create a new file in the same directory as the shapefile with the name `calc_lengths.py`,
    and then enter the following code into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This should all be quite familiar to you—we just import the various libraries
    we will use, create a new `pyproj.Geod` object to use for our length calculations,
    and then iterate over the contents of the shapefile one feature at a time. As
    you can see, we use the `shapely.wkt.loads()` function to convert the feature
    into a Shapely geometry object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a Shapely geometry, our next task is to split that geometry
    into individual line segments and calculate the length of each segment. Let''s
    do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the Shapely geometry is a LineString, we can access the individual coordinates
    that make up the LineString using `geometry.coords`. We then process each pair
    of coordinates in turn, using the technique we learned earlier to calculate the
    distance in meters between the two coordinates. We keep track of the total calculated
    length across all the coordinate pairs, giving us the total length of the LineString
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our road data had been in a projected coordinate system that preserved distances,
    we could have simply asked Shapely to calculate the total length of each LineString
    by accessing the `geometry.length` attribute. This won't work for EPSG 4326 data,
    however, because once again the results would be a length in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last task is to do something with the calculated length. Let''s simply
    print it out, along with the name of the road:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In theory, our program should now work, so let''s try running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good; as you can see, the total length of each road, in meters, is
    being calculated. Unfortunately, if we wait a few more seconds, our program will
    raise a Python exception and stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s going on here? It seems that `geometry.coords` is not available because
    the geometry is not an ordinary LineString. Indeed, if you remember from [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, shapefiles make
    no distinction between simple geometries and collections of those geometries,
    so a LineString in the shapefile might actually be a collection of LineStrings.
    This is exactly what is happening in this case—if you were to load the affected
    feature into memory using the interactive Python command prompt, you could print
    out the geometry type to see what is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have a road represented by a MultiLineString geometry rather than a LineString
    geometry. Fortunately, it''s easy to split apart a MultiLineString and process
    the individual LineStrings one at a time. Here is what our entire program looks
    like once we add this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this technique, we can calculate the exact length, in meters, for any
    linear geometry such as a LineString or MultiLineString. Indeed, we could even
    use the same technique to calculate the perimeter of a polygon geometry, by accessing
    the polygon''s exterior linear ring and then processing it as if it were a LineString:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Calculating areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, we
    saw how we can calculate the area of a polygon using OGR and the World Mollweide
    projection (EPSG 54009). World Mollweide is an equal-area map projection that
    is reasonably accurate worldwide, and so is useful for calculating areas in square
    meters.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using OGR, let's apply the same technique using Shapely. The advantage
    of doing this is that we'll have access to all of Shapely's functionality, allowing
    us to manipulate and measure geometries in all sorts of useful ways. To do this,
    we will make use of a handy Shapely function called `shapely.ops.transform()`.
    This lets you apply a transformation function to every coordinate within a geometry.
    The transformation can be anything you want (you can write your own transformation
    function in Python if you want), but most importantly, you can use PyProj to implement
    a transformation function that converts from EPSG 4326 to ESPG 54009 so that you
    can accurately calculate the area for any geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works. Place a copy of the `TM_WORLD_BORDERS-0.3` shapefile
    you downloaded earlier into a convenient directory, and create a new file named
    `calc_areas.py` in the same directory. Then enter the following code into this
    new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have defined a transformation function, `latlong_to_mollweide()`,
    that converts a given latitude and longitude value into an (x,y) coordinate in
    the Mollweide coordinate reference system. Mollweide is based on meters, so Shapely
    can then perform calculations against that geometry and return a result in meters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `calc_areas.py` program, you should see a list of countries
    and the area of the associated polygons in the World Borders Dataset, measured
    in square kilometers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The great thing about using `shapely.ops.transform()` is that you can use all
    of Shapely''s calculative and geometry-manipulation features on the resulting
    geometries. For example, New Zealand has an exclusive economic zone that extends
    200 miles out from the coastline. Using the `buffer()` method, you could calculate
    the shape of this exclusive economic zone by expanding the outline of New Zealand
    to include all points within 200 miles of the coastline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating areas](img/4102_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Buffering is an extremely powerful operation. For example, you can use `buffer()`
    along with the `intersects()` method to identify all countries within a given
    distance of a starting geometry. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Calculating shortest paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our final example, we will take a shapefile containing road data and use
    it to calculate the shortest path between two points. This is a fairly complex
    example employing various techniques for analyzing and manipulating geometry data.
    It also uses the NetworkX library to perform the shortest path calculation on
    an abstract representation of the road network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at how NetworkX converts a shapefile containing LineString
    geometries into an abstract network. If you were to look at a small part of the
    `tl_2014_06_prisecroads` shapefile, you would see what appears to be a connected
    series of roads, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating shortest paths](img/4102_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the roads don''t actually stop where they intersect—the road features
    simply continue on, overlapping other roads as necessary. On the map, these may
    look like intersections, but there is no real intersection point where two roads
    meet or cross:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating shortest paths](img/4102_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is important because of the way NetworkX converts LineString geometries
    into an abstract graph—NetworkX will think that two LineStrings intersect if and
    only if they have identical starting or ending points; simply crossing over does
    not mean that the two roads intersect. In the preceding example, **Road 2** and
    **Road 4** will be the only roads that are considered to be connected—even though
    **Road 2** appears to intersect with **Road 1** and **Road 3**, the lack of matching
    endpoints means that these roads will be excluded from the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow NetworkX to convert the road shapefile into a network, we need to
    split the roads at the points where they intersect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating shortest paths](img/4102_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mathematically speaking, this is known as generating a **planar graph** out
    of the network of overlapping roads. This process is not perfect—it ignores places
    where bridges and viaducts, not to mention *Do Not Enter* signs, prevent a traveler
    from taking a particular turnoff. However, converting the road shapefile into
    a planar graph is a good starting point, and you can always exclude particular
    intersections from the calculation if you have a list of bridges and other no-entry
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and convert our road shapefile into a planar graph. To do this,
    create a new Python program called `split_roads.py`, and enter the following code
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the extra `import` statements (which we will need shortly), this
    code should be fairly clear: we''re simply loading the LineString geometries from
    our `tl_2014_06_prisecroads.shp` shapefile into the `all_roads` list.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your shapefile is in a different directory, edit the `SRC_SHAPEFILE` constant
    so that the program can find the shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task is to split the roads up at the intersection points. Fortunately,
    Shapely makes this quite easy. Add the following to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we identify any roads that cross the current road by calling
    Shapely''s `crosses()` method. We then use the `difference()` method to remove
    each crossroad from the current road; this has the effect of splitting the road
    up at the point where the other road crosses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating shortest paths](img/4102_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we want to save the split roads back into a shapefile. To do this,
    add the following code to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This code should be familiar to you, as we used the same technique in [Chapter
    2](ch02.html "Chapter 2. Geospatial Data"), *Geospatial Data*, when we looked
    at how to write vector data into a shapefile. The only new thing here is the fact
    that we're using `shutil.rmtree()` followed by `os.mkdir()` to delete and then
    re-create the directory in which we store the shapefile; this allows us to run
    the program again without having to remember to delete the shapefile each time.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our `split_roads.py` program. It will take a few minutes to split
    all 8,000 roads in the `tl_2014_06_prisecroads` shapefile, so just leave it running
    as you start working on the next program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the set of split roads, we''ll want to have another program which
    uses them to calculate the shortest path between two points. Let''s start writing
    that program now. We''ll call this program `calc_shortest_path.py`. Create this
    file, and enter the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to write some utility functions which we''ll need to do the
    shortest-path calculation. First off, we''ll use the technique we saw earlier
    to calculate the distance in meters between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this function to write another function that calculates the total
    length of a LineString geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need a copy of the `get_coord()` function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more function that we need to write: `find_closest_node`. This
    will find the node within a NetworkX graph that is closest to a given latitude
    and longitude value. We will need this to identify the starting and ending nodes
    for the shortest-path calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `find_closest_node` function, which you should add
    to the end of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To find the closest node, we simply go through all the nodes (vertices) in the
    graph and calculate the distance in meters between the node and the desired coordinate.
    We then select and return the node with the smallest distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to start writing the main part of our program. The first step
    is to ask NetworkX to read the `split_roads` shapefile and create a graph out
    of the road data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This reads through the shapefile and generates a NetworkX graph, where each
    edge represents a road and each node represents the endpoint of a road. Because
    NetworkX has no way of knowing how a road or endpoint should be identified, it
    uses the latitude and longitude to identify each endpoint (that is, each node),
    and the starting and ending latitude and longitude to identify each road (that
    is, each edge). Thus, the resulting graph will consist of nodes and edges that
    look something like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calculating shortest paths](img/4102_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting graph will be quite large, as there are almost 10,000 roads to
    be imported from our shapefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next task might seem a bit odd: because there is no guarantee that every
    road can be reached from every other road, we need to reduce the graph down to
    just the reachable set of roads. If we don''t do this, our shortest-path calculation
    is likely to fail. To remove the unreachable roads, we use the `connected_component_subgraphs()`
    function to identify the portion of the graph which contains the largest number
    of connected roads, and use this subgraph for the shortest-path calculation. Here
    is the necessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that, because the `connected_component_subgraphs()` function requires an
    undirected graph, while the `read_shp()` function returns a directed graph, we
    have to use the `to_undirected()` method to make the graph undirected.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get a `'list' object has no attribute 'next'` error, you may be using
    a different version of NetworkX. In this case, replace this line with `graph =
    networkx.connected_component_subgraphs(graph.to_undirected())[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the useable set of roads, our next task is to calculate the
    length of each of these roads. This length value will be used as the basis for
    the shortest-path calculation. Fortunately, the length calculation is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we extract the original LineString geometry for each edge, in
    WKT format, and then use that to create a Shapely geometry object. We then use
    our `calc_length()` function to calculate the total length of the road and store
    the resulting value as a `length` attribute into the edge. Running this code will
    calculate and store the length for every road in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this done, we are finally ready to calculate the shortest path. We start
    by asking the user to enter the latitude and longitude values for the desired
    start and end points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The values entered by the user define two coordinates; we need to use these
    to identify the starting and ending nodes. We can do this using the `find_closest_node()`
    function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get the shortest path between the two nodes, based on the length
    values we calculated earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned `path` value is a list of the nodes that make up the shortest
    path. Let''s finish our program by printing out the details of this path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve completed the program, let''s test it out. Run the `calc_shortest_path.py`
    script. The program will start by loading the road network into memory and calculating
    the length for each road:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After the lengths are calculated, the program will then prompt you for the
    desired starting and ending coordinates. Let''s enter the coordinates for Oakland
    and San Louis Obespo, which are both cities within California:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will then calculate the nearest matching nodes, and the shortest
    path between these two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Of course, printing out the latitude and longitude of each endpoint like this
    isn't particularly useful—it would be much nicer for the user if we displayed
    the shortest path on a map. If you wanted to, you could save the calculated path
    into a shapefile and then use Mapnik to display the contents of that shapefile
    as part of a map. But you can see how the shortest path calculation works, and
    what's required to get road data into a format that NetworkX can work with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about two new useful libraries for analyzing geospatial
    data. We then looked at various techniques for manipulating and analyzing spatial
    data, including ways of accurately calculating distances, lengths, locations,
    and areas.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at how to convert intersecting roads into a planar graph, which
    we stored in a shapefile so that we could perform a shortest-path calculation
    based on the road data. Finally, we wrote a program to calculate the shortest
    path between any two points. As we worked through these various problems, we learned
    a number of techniques for manipulating and analyzing geospatial data—techniques
    which you will use regularly when you write your own programs for geospatial analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will bring together everything you have learned to implement
    a complete geospatial analysis system using Python.
  prefs: []
  type: TYPE_NORMAL
