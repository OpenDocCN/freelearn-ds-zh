- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Statistical Analysis: Linear and Logistic Regression'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计分析：线性与逻辑回归
- en: 'Welcome to our comprehensive guide on linear and logistic regression using
    R and Python, where we will explore these essential statistical techniques using
    two popular frameworks: `tidymodels` and base R and Python. Whether you’re a data
    science enthusiast or a professional looking to sharpen your skills, this tutorial
    will help you gain a deep understanding of **linear** and **logistic regression**
    and how to implement them in R and Python. Now, it is possible to perform linear
    and logistic regression. The issue here is that linear regression can only be
    performed on a single series of ungrouped data, and performing logistic regression
    is cumbersome and may require the use of external solver add-ins. Also, the process
    can only be performed against ungrouped or non-nested data. In R and Python, we
    do not have such limitations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎阅读我们关于使用R和Python进行线性与逻辑回归的全面指南，我们将使用两个流行的框架：`tidymodels`和基础R与Python来探索这些重要的统计技术。无论您是数据科学爱好者还是希望提升技能的专业人士，本教程都将帮助您深入理解**线性**和**逻辑回归**，以及如何在R和Python中实现它们。现在，执行线性与逻辑回归成为可能。问题在于，线性回归只能应用于单个未分组的数据序列，而执行逻辑回归则较为繁琐，可能需要使用外部求解器插件。此外，这个过程只能针对未分组或非嵌套数据进行。在R和Python中，我们没有这样的限制。
- en: 'In this chapter, we will cover the following topics in both base R and Python
    and using the `tidymodels` framework:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用基础R、Python以及`tidymodels`框架来介绍以下主题：
- en: Performing linear regression in both base R and Python and the `tidymodels`
    frameworks as well as in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础R、Python以及`tidymodels`框架中执行线性回归，以及在Python中
- en: Performing logistic regression in both base R and Python and the `tidymodels`
    frameworks as well as in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础R、Python以及`tidymodels`框架中执行逻辑回归，以及在Python中
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All code for this chapter can be found on GitHub at this URL: [https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter9](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter9).
    You will need the following R packages installed to follow along:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有代码可在GitHub上通过此URL找到：[https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter9](https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/tree/main/Chapter9)。为了跟随教程，您需要安装以下R包：
- en: '`readxl 1.4.3`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readxl 1.4.3`'
- en: '`performance 0.10.8`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performance 0.10.8`'
- en: '`tidymodels 1.1.1`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidymodels 1.1.1`'
- en: '`purrr 1.0.2`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`purrr 1.0.2`'
- en: We will begin by learning about what linear and logistic regression are and
    then move into the details of everything.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解线性与逻辑回归是什么，然后深入探讨所有相关细节。
- en: Linear regression
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性回归
- en: Linear regression is a fundamental statistical method used for modeling the
    relationship between a dependent variable (usually denoted as “Y”) and one or
    more independent variables (often denoted as “X”). It aims to find the best-fitting
    linear equation that describes how changes in the independent variables affect
    the dependent variable. Many of you may know this as the **ordinary least squares**
    (**OLS**) method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是一种基本的统计方法，用于建模因变量（通常表示为“Y”）与一个或多个自变量（通常表示为“X”）之间的关系。它的目标是找到最佳拟合的线性方程，描述自变量的变化如何影响因变量。你们中许多人可能知道这是**普通最小二乘法**（**OLS**）。
- en: In simpler terms, linear regression helps us predict a continuous numeric outcome
    based on one or more input features. For this to work, if you are unaware, many
    assumptions must be held true. If you would like to understand these more, then
    a simple search will bring you a lot of good information on them. In this tutorial,
    we will delve into both simple linear regression (one independent variable) and
    multiple linear regression (multiple independent variables).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，线性回归帮助我们根据一个或多个输入特征预测连续数值结果。为了使其工作，如果您不知道，必须满足许多假设。如果您想了解更多，简单的搜索会为您带来大量关于这些假设的好信息。在本教程中，我们将深入探讨简单线性回归（一个自变量）和多元线性回归（多个自变量）。
- en: Logistic regression
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑回归
- en: Logistic regression is another crucial statistical technique, which is primarily
    used for binary classification problems. Instead of predicting continuous outcomes,
    logistic regression predicts the probability of an event occurring, typically
    expressed as a “yes” or “no” outcome. This method is particularly useful for scenarios
    where we need to model the likelihood of an event, such as whether a customer
    will churn or not or whether an email is spam or not. Logistic regression models
    the relationship between the independent variables and the log odds of the binary
    outcome.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归是另一种重要的统计技术，主要用于二元分类问题。逻辑回归不是预测连续结果，而是预测事件发生的概率，通常表示为“是”或“否”的结果。这种方法在需要模拟事件发生可能性的场景中特别有用，例如，客户是否会流失或电子邮件是否为垃圾邮件。逻辑回归模型独立变量与二元结果的逻辑优势之间的关系。
- en: Frameworks
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: 'We will explore two approaches to implementing linear and logistic regression
    in R. First, we will use the base R framework, which is an excellent starting
    point to understand the underlying concepts and functions. Then, we will dive
    into `tidymodels`, a modern and tidy approach to modeling and machine learning
    in R. `tidymodels` provides a consistent and efficient way to build, tune, and
    evaluate models, making it a valuable tool for data scientists. In Python, we
    will parallel this exploration with two prominent libraries: `sklearn` and `statsmodels`.
    `sklearn`, or Scikit-learn, offers a wide array of simple and efficient tools
    for predictive data analysis that are accessible to everybody and reusable in
    various contexts. `statsmodels` is more focused on statistical models and hypothesis
    tests. Together, these Python libraries offer a robust framework for implementing
    linear and logistic regression, catering to both machine learning and statistical
    needs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种在R中实现线性回归和逻辑回归的方法。首先，我们将使用基础R框架，这是理解基本概念和函数的绝佳起点。然后，我们将深入研究`tidymodels`，这是R中建模和机器学习的现代且整洁的方法。`tidymodels`提供了一种一致且高效的方式来构建、调整和评估模型，使其成为数据科学家的一个宝贵工具。在Python中，我们将使用两个突出的库来并行这一探索：`sklearn`和`statsmodels`。`sklearn`，或Scikit-learn，提供了一系列简单且高效的预测数据分析工具，这些工具对每个人都是可访问的，并且可以在各种环境中重复使用。`statsmodels`更专注于统计模型和假设检验。这两个Python库共同提供了一个强大的框架，用于实现线性回归和逻辑回归，满足机器学习和统计需求。
- en: Throughout this chapter, we will provide step-by-step instructions, code examples,
    and practical insights to ensure that you can confidently apply linear and logistic
    regression techniques to your own data analysis projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供逐步说明、代码示例和实用见解，以确保你可以自信地将线性回归和逻辑回归技术应用于自己的数据分析项目中。
- en: Let’s embark on this learning journey and unlock the power of regression analysis
    in R! With this in place, we move to the first example in base R using the `iris`
    dataset we saved in [*Chapter 1*](B19142_01.xhtml#_idTextAnchor014).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这段学习之旅，并解锁R中回归分析的力量！有了这个基础，我们将转向第一个示例，使用我们保存在[*第1章*](B19142_01.xhtml#_idTextAnchor014)中的`iris`数据集在基础R中进行操作。
- en: Performing linear regression in R
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在R中执行线性回归
- en: For this section, we are going to perform linear regression in R, both in base
    R and by way of the `tidymodels` framework. In this section, you will learn how
    to do this on a dataset that has different groups in it. We will do this because
    if you can learn to do it this way, then doing it in a single group becomes simpler
    as there is no need to group data and perform actions by group. The thought process
    here is that by doing it on grouped data, we hope you can learn an extra skill.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用R进行线性回归，包括基础R和通过`tidymodels`框架。在本节中，你将学习如何在包含不同组的数据集中进行这一操作。我们将这样做，因为如果你能学会这种方式，那么在单一组中进行操作就会变得简单，因为不需要按组分组数据并按组执行操作。这里的思路是，通过在分组数据上操作，我们希望你能学会一项额外的技能。
- en: Linear regression in base R
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础R中的线性回归
- en: The first example we are going to show is using the `lm()` function to perform
    a linear regression in base R. Let’s dive right into it with the `iris` dataset.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的第一个示例是使用`lm()`函数在基础R中执行线性回归。让我们直接使用`iris`数据集来深入探讨。
- en: 'We will break the code down into chunks and discuss what is happening at each
    step. The first step for us is to use the `library` command to bring in the necessary
    packages into our development environment:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把代码分解成块，并讨论每个步骤中发生的事情。对我们来说，第一步是使用`library`命令将必要的包引入我们的开发环境：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this section, we’re loading a library called `readxl`. Libraries are collections
    of pre-written R functions and code that we can use in our own R scripts. In this
    case, we’re loading the `readxl` library, which is commonly used for reading data
    from Excel files. The path assumes you have a `chapter1` folder and a data file
    in it called `iris_data.xlsx`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在加载一个名为`readxl`的库。库是预先编写的R函数和代码的集合，我们可以在自己的R脚本中使用它们。在这种情况下，我们正在加载`readxl`库，它通常用于从Excel文件中读取数据。路径假设你有一个名为`chapter1`的文件夹，其中包含一个名为`iris_data.xlsx`的数据文件：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we’re reading data from an Excel file named `iris_data.xlsx`, located
    in the `chapter1` folder. We’re specifically reading the `iris` sheet from that
    Excel file. The `read_xlsx` function is used for this purpose. The resulting data
    is stored in a variable called `df`. The `head(df)` function displays the first
    few rows of this data frame (`df`) so we can see what it looks like:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在从位于`chapter1`文件夹中的Excel文件`iris_data.xlsx`中读取数据。我们特别读取该Excel文件中的`iris`工作表。`read_xlsx`函数用于此目的。得到的数据存储在一个名为`df`的变量中。`head(df)`函数显示这个数据框（`df`）的前几行，以便我们可以看到它的样子：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code splits the `df` dataset into multiple subsets based on the unique
    values in the `species` column. The result is a list of data frames where each
    data frame contains only the rows that correspond to a specific species of `iris`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`df`数据集根据`species`列中的唯一值分割成多个子集。结果是包含多个数据框的列表，其中每个数据框只包含对应特定`iris`物种的行。
- en: 'Now, we are going to define what will be the dependent and independent variables
    along with the `formula` object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义将是什么是因变量和自变量，以及`formula`对象：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we’re defining the variables needed for linear regression. `dependent_variable`
    is `petal_length`, which is the variable we want to predict. `independent_variables`
    are `petal_width`, `sepal_length`, and `sepal_width`, which are the variables
    we’ll use to predict the dependent variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义线性回归所需的变量。`dependent_variable`是`petal_length`，这是我们想要预测的变量。`independent_variables`是`petal_width`、`sepal_length`和`sepal_width`，我们将使用这些变量来预测因变量。
- en: 'The code then creates an `f_x` formula that represents the linear regression
    model. It essentially says that we want to predict `petal_length` using the other
    variables listed, separated by a plus sign:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后创建了一个`f_x`公式，它代表了线性回归模型。它本质上表示我们想要使用其他列出的变量来预测`petal_length`，这些变量通过加号分隔：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this part, we’re defining a custom R function called `perform_linear_regression`.
    This function takes one `data` argument, which is a data frame. Inside the function,
    we use the `lm` function to perform linear regression, using the `f_x` formula
    we defined earlier and the provided data frame. The resulting linear model is
    stored in `lm_model`, and we return it as the output of the function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们正在定义一个名为`perform_linear_regression`的自定义R函数。这个函数接受一个`data`参数，它是一个数据框。在函数内部，我们使用`lm`函数执行线性回归，使用我们之前定义的`f_x`公式和提供的数据框。得到的线性模型存储在`lm_model`中，并将其作为函数的输出返回：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we’re applying the `perform_linear_regression` function to each subset
    of the `iris` dataset using the `lapply` function. This means that we’re running
    linear regression separately for each species of iris, and the results are stored
    in the `results` list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用`lapply`函数将`perform_linear_regression`函数应用于`iris`数据集的每个子集。这意味着我们正在为每个iris物种单独运行线性回归，并将结果存储在`results`列表中：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code uses `lapply` again, but this time we’re applying the `summary` function
    to each linear regression model in the `results` list. The `summary` function
    provides statistical information about the linear regression model, such as coefficients
    and R-squared values:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码再次使用`lapply`，但这次我们将`summary`函数应用于`results`列表中的每个线性回归模型。`summary`函数提供了关于线性回归模型的统计信息，例如系数和R-squared值：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These lines of code are used to create a set of four plots to visualize the
    model performance. We first set the layout of the plots to be a 2x2 grid using
    `par(mfrow = c(2,2))`, so that 4 plots will be displayed in a 2x2 grid. Then,
    we use `lapply` to plot each linear regression model in the `results` list. Finally,
    we reset the plot layout to the default with `par(mfrow =` `c(1, 1))`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码用于创建一组四个图表来可视化模型性能。我们首先使用`par(mfrow = c(2,2))`设置图表布局为2x2网格，这样4个图表将显示在一个2x2网格中。然后，我们使用`lapply`来绘制`results`列表中的每个线性回归模型。最后，我们使用`par(mfrow
    = c(1, 1))`将绘图布局重置为默认设置：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This part accomplishes the same linear regression analysis as before but combines
    the linear model creation and summarization into a more concise form using anonymous
    functions. It first applies the `lm` function to each species subset within `iris_split`,
    creating a list of linear models stored in `lm_models`. Then, it uses `lapply`
    to obtain summaries for each of these linear models.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分与之前完成的线性回归分析相同，但将线性模型创建和总结结合成一个更简洁的形式，使用匿名函数实现。首先，它将 `lm` 函数应用于 `iris_split`
    中的每个物种子集，创建一个存储在 `lm_models` 中的线性模型列表。然后，使用 `lapply` 获取这些线性模型的总结。
- en: In summary, this R code reads iris data from an Excel file, performs linear
    regression for each species of `iris`, summarizes the results, and creates visualizations
    to assess the model’s performance. It provides a detailed analysis of how the
    dependent variable (`petal_length`) is influenced by independent variables (`petal_width`,
    `sepal_length`, and `sepal_width`) for each species of `iris`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段 R 代码从 Excel 文件中读取鸢尾花数据，对 `iris` 的每个物种进行线性回归，总结结果，并创建可视化来评估模型性能。它详细分析了每个物种的因变量（`petal_length`）如何受自变量（`petal_width`、`sepal_length`
    和 `sepal_width`）的影响。
- en: Linear regression with tidymodels and purrr
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 tidymodels 和 purrr 进行线性回归
- en: 'Now that we have gone over how to perform a simple linear regression in R on
    the `iris` dataset, we will do the same with the `tidymodels` framework. Let’s
    dive right into it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了如何在 R 中对 `iris` 数据集进行简单线性回归，我们将使用 `tidymodels` 框架进行相同的操作。让我们直接进入正题：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This block defines a formula for the linear regression model. The `formula()`
    function takes two arguments: the response variable and the predictor variables.
    The response variable is the variable that we want to predict, and the predictor
    variables are the variables that we think can help us predict the response variable.
    In this case, the response variable is `petal_width` and the predictor variables
    are `petal_length`, `sepal_width`, and `sepal_length`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分定义了线性回归模型的公式。`formula()` 函数接受两个参数：响应变量和预测变量。响应变量是我们想要预测的变量，预测变量是我们认为可以帮助我们预测响应变量的变量。在这种情况下，响应变量是
    `petal_width`，预测变量是 `petal_length`、`sepal_width` 和 `sepal_length`：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This block creates a nested linear regression model using the `nest()` function
    from the `tidyr` package. The `nest()` function groups the data by a specified
    variable, in this case, the `species` variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分使用 `tidyr` 包中的 `nest()` 函数创建一个嵌套的线性回归模型。`nest()` 函数根据指定的变量分组数据，在这种情况下，是 `species`
    变量。
- en: For each group, the `nest()` function creates a list containing the data for
    that group. The `mutate()` function is then used to add new columns to the nested
    data frame.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个组，`nest()` 函数创建一个包含该组数据的列表。然后，使用 `mutate()` 函数向嵌套数据框添加新列。
- en: The `split()` function is used to randomly split the data in each group into
    a training set and a test set. The `training()` and `testing()` functions are
    then used to select the training and test sets, respectively. With `map()` and
    `map2()`, we can iterate over a vector or list or two vectors or lists and apply
    a function to them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 函数用于将每个组中的数据随机分成训练集和测试集。然后，使用 `training()` 和 `testing()` 函数分别选择训练集和测试集。通过
    `map()` 和 `map2()`，我们可以遍历一个向量或列表，或者两个向量或列表，并应用一个函数。'
- en: 'The `lm()` function is used to fit a linear regression model to the training
    data in each group. The `predict()` function is then used to predict the response
    variable for the test data in each group using the fitted linear regression model:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lm()` 函数将线性回归模型拟合到每个组中的训练数据。然后，使用 `predict()` 函数预测每个组测试数据的响应变量，使用拟合的线性回归模型：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This block selects the `species` and `pred` columns from the nested data frame
    and unnests the `pred` column. The `unnest()` function converts the nested data
    frame to a regular data frame, with one row for each observation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分从嵌套数据框中选择 `species` 和 `pred` 列，并解包 `pred` 列。`unnest()` 函数将嵌套数据框转换为常规数据框，每行对应一个观测值。
- en: The resulting data frame is a nested linear regression model, with one fitted
    linear regression model for each species.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据框是一个嵌套的线性回归模型，每个物种都有一个拟合的线性回归模型。
- en: 'Let’s take a look at an example. We are going to use the `f_x` formula that
    was created earlier along with the `df` `tibble` variable we created at the beginning.
    The following code shows an example of how to use the nested linear regression
    model to predict the petal width for a new iris flower:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们将使用之前创建的`f_x`公式以及我们在开头创建的`df` `tibble`变量。以下代码展示了如何使用嵌套线性回归模型预测新鸢尾花的花瓣宽度：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s the output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The predicted petal width is 1.45 cm. We have now finished going over linear
    regression in R with a basic example. We will now continue the chapter in the
    next section on performing logistic regression in R.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 预测的花瓣宽度是1.45厘米。我们现在已经用基本示例完成了R中的线性回归的讲解。我们将在下一节继续本章，讲解在R中执行逻辑回归。
- en: Performing logistic regression in R
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在R中执行逻辑回归
- en: As we did in the section on linear regression, in this section, we will also
    perform logistic regression in base R and with the `tidymodels` framework. We
    are going to only perform a simple binary classification regression problem using
    the `Titanic` dataset, where we will be deciding if someone is going to survive
    or not. Let’s dive right into it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在线性回归部分所做的那样，在这一节中，我们也将使用基础R和`tidymodels`框架执行逻辑回归。我们将只使用`Titanic`数据集执行一个简单的二元分类回归问题，我们将决定某人是否会幸存。让我们直接进入正题。
- en: Logistic regression with base R
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑回归使用基础R
- en: In order to get going, we are going to start with a base R implementation of
    logistic regression on the `Titanic` dataset where we will be modeling the response
    of `Survived`. So, let’s get straight into it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将从`Titanic`数据集上的基础R实现逻辑回归开始，我们将对`Survived`的响应进行建模。所以，让我们直接进入正题。
- en: 'The following is the code that will perform the data modeling along with explanations
    of what is happening:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将执行数据建模，并解释正在发生的事情：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This block of code starts by loading a library called `tidyverse`, which contains
    various data manipulation and visualization tools. It then creates a data frame
    called `df` by taking the `Titanic` dataset (assuming it’s available in your environment)
    and performing three operations on it using the `|>` operator, where we then use
    `as.data.frame()`, which converts the dataset into a data frame, followed by `uncount(Freq)`,
    which repeats each row in the dataset according to the value in the `Freq` column.
    This is often done to expand summarized data:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块首先加载了一个名为`tidyverse`的库，其中包含各种数据处理和可视化工具。然后，通过使用`|>`运算符对`Titanic`数据集（假设它存在于你的环境中）执行三个操作来创建一个名为`df`的数据框，其中我们使用`as.data.frame()`将数据集转换为数据框，接着是`uncount(Freq)`，它根据`Freq`列中的值重复数据集中的每一行。这通常是为了扩展汇总数据：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This section is about splitting the data into a training set and a test set,
    which is a common practice in machine learning:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容是关于将数据分为训练集和测试集，这在机器学习中是一种常见的做法：
- en: '`set.seed(123)`: This sets a random seed for reproducibility, ensuring that
    random operations produce the same results each time.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set.seed(123)`：这设置了一个随机种子以确保可重复性，确保每次随机操作产生相同的结果。'
- en: '`sample(nrow(df), floor(nrow(df) * 0.8), replace = FALSE)`: This randomly selects
    80% of the rows in the `df` data frame (the training set) without replacement
    and stores their indices in `train_index`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample(nrow(df), floor(nrow(df) * 0.8), replace = FALSE)`：这随机选择`df`数据框（训练集）中的80%的行，不进行替换，并将它们的索引存储在`train_index`中。'
- en: '`train <- df[train_index, ]`: This creates the training set by selecting the
    rows from `df` using the `train_index` indices.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train <- df[train_index, ]`：这是通过使用`train_index`索引从`df`中选择行来创建训练集。'
- en: '`test <- df[-train_index, ]`: This creates the test set by selecting the rows
    from `df` that are not in the training set. We next create the model.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test <- df[-train_index, ]`：这是通过从`df`中选择不在训练集中的行来创建测试集。接下来，我们创建模型。'
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let’s discuss the model code as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按以下方式讨论模型代码：
- en: This block trains a logistic regression model using the `glm` function.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个代码块使用`glm`函数训练逻辑回归模型。
- en: The model is trained to predict the `Survived` variable based on the `Sex`,
    `Age`, and `Class` variables in the training data. Here, `Age` is actually discrete.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模型被训练来根据训练数据中的`Sex`、`Age`和`Class`变量预测`Survived`变量。在这里，`Age`实际上是离散的。
- en: 'The `family = "binomial"` argument specifies that this is a binary classification
    problem, where the outcome is either `Yes` or `No`. The following link helps in
    choosing an appropriate family: [https://stats.stackexchange.com/a/303592/35448](https://stats.stackexchange.com/a/303592/35448).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`family = "binomial"` 参数指定这是一个二元分类问题，其中结果要么是 `Yes`，要么是 `No`。以下链接有助于选择合适的家族：[https://stats.stackexchange.com/a/303592/35448](https://stats.stackexchange.com/a/303592/35448)。'
- en: 'Now, let’s set up the model predictions and response variable:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置模型预测和响应变量：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s go over what we just did:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们刚才所做的工作：
- en: Here, we use the trained model to make predictions on the test set.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们使用训练好的模型对测试集进行预测。
- en: '`predict(model, newdata = test, type = "response")` calculates the predicted
    probabilities of survival for each passenger in the test set.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predict(model, newdata = test, type = "response")` 计算测试集中每个乘客的生存预测概率。'
- en: '`ifelse(predictions <= 0.5, "No", "Yes")` converts these probabilities into
    binary predictions: `"No"` if the probability is less than or equal to `0.5`,
    and `"Yes"` otherwise. This is common practice, but you must know your project
    first in order to determine if this is correct or not. Now, onto the `accuracy`
    variable:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifelse(predictions <= 0.5, "No", "Yes")` 将这些概率转换为二元预测：如果概率小于或等于 `0.5`，则输出
    `"No"`，否则输出 `"Yes"`。这是一种常见做法，但您必须首先了解您的项目，才能确定这种方法是否正确。现在，让我们继续到 `accuracy` 变量：'
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We created the `accuracy` variable by doing the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式创建了 `accuracy` 变量：
- en: This line calculates the accuracy of the model’s predictions by comparing `pred_resp`
    (the model’s predictions) to the actual survival status in the test set (`test$Survived`).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一行通过比较 `pred_resp`（模型的预测）与测试集中的实际生存状态（`test$Survived`）来计算模型预测的准确度。
- en: 'It computes the mean of the resulting logical values, where `TRUE` represents
    a correct prediction, and `FALSE` represents an incorrect prediction. Let’s now
    go over the rest of the code:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它计算了结果逻辑值的平均值，其中 `TRUE` 代表正确预测，而 `FALSE` 代表错误预测。现在，让我们回顾一下代码的其余部分：
- en: '[PRE19]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code prints two things:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码打印了两件事：
- en: The accuracy of the model on the test set.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试集上模型的准确度。
- en: 'A confusion matrix that shows how many predictions were correct and how many
    were incorrect. If you would like to understand confusion matrices more, here
    is a good link: [https://www.v7labs.com/blog/confusion-matrix-guide](https://www.v7labs.com/blog/confusion-matrix-guide).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个混淆矩阵，显示了有多少预测是正确的，有多少是错误的。如果您想更深入地了解混淆矩阵，这里有一个好的链接：[https://www.v7labs.com/blog/confusion-matrix-guide](https://www.v7labs.com/blog/confusion-matrix-guide)。
- en: In summary, this code loads a dataset, splits it into a training and test set,
    trains a logistic regression model to predict survival, evaluates the model’s
    accuracy, and displays the results. It’s a basic example of a binary classification
    machine learning workflow. Now that we have covered performing logistic regression
    for a classification problem in base R, we will try our hand at the same but this
    time using the `tidymodels` framework.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段代码加载了一个数据集，将其分为训练集和测试集，训练了一个逻辑回归模型来预测生存，评估了模型的准确度，并显示了结果。这是一个二元分类机器学习工作流程的基本示例。现在我们已经覆盖了在基础
    R 中执行分类问题的逻辑回归，我们将尝试使用 `tidymodels` 框架来完成同样的任务。
- en: Performing logistic regression using tidymodels
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 tidymodels 进行逻辑回归
- en: 'In this section, we will use the `tidymodels` framework to perform the logistic
    regression on the `Titanic` dataset. Since we have done this in base R already,
    let’s get right into it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `tidymodels` 框架对 `Titanic` 数据集进行逻辑回归。由于我们已经在基础 R 中完成了这项工作，让我们直接进入正题：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code loads the two libraries that we will need for our analysis: `tidymodels`
    and `healthyR.ai`. `tidymodels` is a library that provides a common interface
    for many machine learning algorithms, while `healthyR.ai` provides a set of tools
    for evaluating the performance of machine learning models:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码加载了我们将需要用于分析的两个库：`tidymodels` 和 `healthyR.ai`。`tidymodels` 是一个库，它为许多机器学习算法提供了一个通用接口，而
    `healthyR.ai` 提供了一套用于评估机器学习模型性能的工具：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code converts the `Titanic` dataset to a `tibble`, which is a data structure
    that is compatible with `tidymodels`. It also uncounts the `n` column, which is
    a column that contains the number of times each row appears in the dataset and
    is created by the `uncount()` function. Finally, it converts all the character
    variables in the dataset to factors:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`Titanic`数据集转换为`tibble`，这是一种与`tidymodels`兼容的数据结构。它还取消了`n`列的计数，该列包含每行在数据集中出现的次数，由`uncount()`函数创建。最后，它将数据集中的所有字符变量转换为因子：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code splits the `df` dataset into training and test sets. The training
    set is used to train the model, while the test set is used to evaluate the performance
    of the model on unseen data. The `initial_split()` function from `tidymodels`
    is used to perform the split. The `prop` argument specifies the proportion of
    the data that should be used for training. In this case, we are using 80% of the
    data for training and 20% of the data for testing:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`df`数据集拆分为训练集和测试集。训练集用于训练模型，而测试集用于评估模型在未见数据上的性能。使用`tidymodels`中的`initial_split()`函数进行拆分。`prop`参数指定了应该用于训练的数据比例。在这种情况下，我们使用80%的数据进行训练，20%的数据进行测试：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This code trains a logistic regression model to predict survival on the Titanic.
    The `recipe()` function from `tidymodels` is used to pre-process the data. The
    `logistic_reg()` function from `tidymodels` is used to specify the logistic regression
    model. The `workflow()` function from `tidymodels` is used to combine the recipe
    and model into a workflow. Finally, the `fit()` function from `tidymodels` is
    used to train the model on the training data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码训练了一个逻辑回归模型来预测泰坦尼克号上的生存情况。使用`tidymodels`中的`recipe()`函数来预处理数据。使用`tidymodels`中的`logistic_reg()`函数来指定逻辑回归模型。使用`tidymodels`中的`workflow()`函数将recipe和模型组合成一个工作流程。最后，使用`tidymodels`中的`fit()`函数在训练数据上训练模型：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code predicts the survival probability for each passenger in the test
    set. The `predict()` function from `tidymodels` is used to make the predictions.
    The `new_data` argument specifies the data that we want to make predictions on.
    In this case, we are making predictions on the test set. The `bind_cols()` function
    is used to bind the predictions to the test set data. The `select()` function
    is used to select the columns that we want to keep. The `pred_fit_tbl` object
    is a `tibble` instance that contains the predictions from the model, as well as
    the ground truth survival labels. This object will be used to evaluate the performance
    of the model:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码预测测试集中每位乘客的生存概率。使用`tidymodels`中的`predict()`函数进行预测。`new_data`参数指定了我们想要进行预测的数据。在这种情况下，我们正在对测试集进行预测。使用`bind_cols()`函数将预测绑定到测试集数据上。使用`select()`函数选择我们想要保留的列。`pred_fit_tbl`对象是一个包含模型预测以及真实生存标签的`tibble`实例。该对象将用于评估模型的性能：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The accuracy check code block evaluates the performance of the model on the
    test set. It does this by using the `hai_default_classification_metric_set()`
    function from the healthyR.ai package to create a set of default classification
    metrics. These metrics include accuracy, precision, recall, and F1 score.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 准确度检查代码块通过使用来自healthyR.ai包的`hai_default_classification_metric_set()`函数创建一组默认分类指标来评估模型在测试集上的性能。这些指标包括准确率、精确率、召回率和F1分数。
- en: The `perf()` function is then used to calculate the accuracy metrics on the
    test set. The `pred_fit_tbl` object is the data frame that contains the predictions
    from the model, as well as the ground truth survival labels. The `truth` and `estimate`
    arguments specify the columns in the data frame that contain the ground truth
    and predicted labels, respectively.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`perf()`函数在测试集上计算准确度指标。`pred_fit_tbl`对象是一个包含模型预测以及真实生存标签的数据框。`truth`和`estimate`参数指定了数据框中包含真实标签和预测标签的列。
- en: The `conf_mat()` function is then used to print the confusion matrix for the
    model. The confusion matrix is a table that shows how many observations were correctly
    and incorrectly predicted by the model.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`conf_mat()`函数打印模型的混淆矩阵。混淆矩阵是一个表格，显示了模型正确和错误预测的观测数。
- en: Finally, the `tidy()` and `glance()` functions from the `broom` package can
    be used to tidy and summarize the fitted model. The `tidy()` function converts
    the model object to a `tibble` instance, which is a data structure that is easy
    to work with. The `glance()` function prints a summary of the model, including
    the coefficients, standard errors, and p-values for all of the variables in the
    model.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 `broom` 包中的 `tidy()` 和 `glance()` 函数来整理和总结拟合的模型。`tidy()` 函数将模型对象转换为
    `tibble` 实例，这是一种易于处理的数据结构。`glance()` 函数打印出模型的摘要，包括模型中所有变量的系数、标准误差和 p 值。
- en: 'Here is a simple explanation of each of the accuracy metrics that are calculated
    in the accuracy check code block:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对准确性检查代码块中计算的每个准确性指标的一个简单解释：
- en: '**Accuracy**: The accuracy of a model is the proportion of observations that
    are correctly predicted by the model.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确率**：模型的准确率是指模型正确预测的观测值的比例。'
- en: '**Precision**: The precision of a model is the proportion of positive predictions
    that are correct.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确率**：模型的精确率是指正确预测的正预测的比例。'
- en: '**Recall**: The recall of a model is the proportion of actual positive observations
    that are correctly predicted by the model.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**召回率**：模型的召回率是指模型正确预测的实际正观测值的比例。'
- en: '**F1 score**: The F1 score is a harmonic mean of the precision and recall metrics.
    It is a good overall measure of the performance of a model.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F1 分数**：F1 分数是精确率和召回率的调和平均值。它是衡量模型性能的良好整体指标。'
- en: The confusion matrix is a helpful tool for understanding how the model is performing.
    The ideal confusion matrix would have all of the observations on the diagonal,
    indicating that all of the observations were correctly predicted. However, in
    practice, no model is perfect and there will be some observations that are incorrectly
    predicted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆矩阵是理解模型性能的有用工具。理想的混淆矩阵将对角线上的所有观测值都正确预测。然而，在实践中，没有模型是完美的，总会有一些观测值被错误预测。
- en: 'Lastly, we will visualize the model with a **receiver operating characteristic**
    (**ROC**) curve. To read more about this type of curve, you can see the following
    link: [https://www.tmwr.org/performance](https://www.tmwr.org/performance). Here
    is the code that creates the ROC curve:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 **接收者操作特征**（ROC）曲线来可视化模型。要了解更多关于这种曲线的信息，请参阅以下链接：[https://www.tmwr.org/performance](https://www.tmwr.org/performance)。以下是创建
    ROC 曲线的代码：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![Figure 9.1 – ROC curve for the logistic regression model](img/B19142_09_1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 逻辑回归模型的 ROC 曲线](img/B19142_09_1.jpg)'
- en: Figure 9.1 – ROC curve for the logistic regression model
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 逻辑回归模型的 ROC 曲线
- en: Now, we have learned how to perform both linear and logistic regression in both
    base R and via the `tidymodels` modeling framework. We did this with the `Titanic`
    and `iris` datasets. Now, it’s time to do the same in Python!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何在基础 R 和 `tidymodels` 模型框架中执行线性回归和逻辑回归。我们使用 `Titanic` 和 `iris` 数据集做到了这一点。现在是时候在
    Python 中做同样的事情了！
- en: Performing linear regression in Python using Excel data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Excel 数据在 Python 中执行线性回归
- en: 'Linear regression in Python can be carried out with the help of libraries such
    as `pandas`, `scikit-learn`, `statsmodels`, and `matplotlib`. The following is
    a step-by-step code example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，可以使用 `pandas`、`scikit-learn`、`statsmodels` 和 `matplotlib` 等库执行线性回归。以下是一个逐步的代码示例：
- en: 'First, import the necessary libraries:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入必要的库：
- en: '[PRE27]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we create an Excel file with test data. Of course, in a real-life scenario,
    you would not need the mock data – you would skip this step and load the data
    from Excel (see the next step) after loading the necessary libraries:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含测试数据的 Excel 文件。当然，在实际场景中，你不需要模拟数据 - 你会跳过这一步，在加载必要的库之后（见下一步）从 Excel
    加载数据：
- en: '[PRE28]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, import the data from the Excel file with test data and prepare it for
    analysis using tools you have learned in the previous chapter:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用你在上一章中学到的工具从 Excel 文件中导入测试数据，并对其进行分析准备：
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we are ready to carry out the actual analysis. Split the data into training
    and test data so we can evaluate the model on a dedicated data (sub)set, then
    fit the **Ordinary Least Squares** (**OLS**) linear model on the training data:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行实际分析了。将数据分为训练数据和测试数据，以便我们可以在一个专门的数据（子集）上评估模型，然后在训练数据上拟合 **普通最小二乘法**（OLS）线性模型：
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that doing imputation as part of the data cleaning process before splitting
    the test and training sets may lead to pollution of the test set from the training
    set. Be conscious of this when performing the data cleaning and preparation steps!
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在分割测试集和训练集之前，作为数据清洗过程的一部分进行插补可能会导致测试集受到训练集的污染。在执行数据清洗和准备步骤时要对此保持警觉！
- en: 'Next, evaluate the trained model on the test data:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，评估训练好的模型在测试数据上的表现：
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will create summary statistics as the output that provides valuable insights
    into the relationships within your dataset:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成输出摘要统计信息，这些信息可以提供关于数据集中关系的重要见解：
- en: '![Figure 9.2 – Summary statistics of the model fitted](img/B19142_09_2.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 拟合模型的摘要统计](img/B19142_09_2.jpg)'
- en: Figure 9.2 – Summary statistics of the model fitted
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 拟合模型的摘要统计
- en: 'Actual interpretation of model results is a topic that is beyond the scope
    of this book, but here are some hints to get you started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上对模型结果的解释超出了本书的范围，但以下是一些帮助你开始的提示：
- en: '**Coefficients**: The coefficients associated with each independent variable
    (predictor) in the model tell you about the strength and direction of the relationship.
    A positive coefficient indicates a positive correlation, meaning that as the predictor
    increases, the target variable tends to increase as well. Conversely, a negative
    coefficient signifies a negative correlation.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系数**：与模型中每个自变量（预测器）相关的系数告诉你关系的强度和方向。正系数表示正相关，这意味着随着预测器的增加，目标变量倾向于增加。相反，负系数表示负相关。'
- en: '**Intercept**: The intercept represents the predicted value of the target variable
    when all predictor variables are set to zero. It’s essential to consider the intercept’s
    value in the context of your analysis.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截距**：截距表示当所有预测变量都设置为零时目标变量的预测值。在分析上下文中考虑截距的值是至关重要的。'
- en: '**R-squared (****R**2**)**: The R-squared value measures the goodness of fit
    of the model. It tells you the proportion of variance in the target variable that
    can be explained by the predictors. Higher R-squared values (closer to 1) indicate
    a better fit. Note that adding more variables will always increase this measure.
    A “better” fit might result in “overfitting,” which is something we don’t want.
    You may want to check model-fit selection criteria such as Mallow’s Cp, AIC, BIC,
    and adjusted R-squared, which penalizes the number of parameters used to fit the
    model.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R平方（R²）**：R平方值衡量模型的拟合优度。它告诉你目标变量中可以由预测器解释的方差比例。较高的R平方值（接近1）表示更好的拟合。请注意，添加更多变量总会增加这个度量。一个“更好的”拟合可能会导致“过拟合”，这是我们不想看到的。你可能想检查模型拟合选择标准，如Mallow的Cp、AIC、BIC和调整R平方，后者对用于拟合模型的参数数量进行惩罚。'
- en: '**P-values**: P-values associated with coefficients help determine the statistical
    significance of each predictor. Lower p-values suggest greater significance (in
    the sense that it is stronger evidence to reject the null hypothesis). If a p-value
    is less than a chosen significance level (for example, 0.05), you can conclude
    that the predictor has a statistically significant effect on the target variable.
    Please be aware that there are good reasons to not rely on p-values alone; see
    the ongoing debate on p-hacking and related topics in statistical science.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P值**：与系数相关的P值有助于确定每个预测器的统计显著性。较低的P值表示更大的显著性（在拒绝零假设的证据更强的意义上）。如果一个P值小于选定的显著性水平（例如，0.05），你可以得出结论，该预测器对目标变量有统计显著的效应。请注意，有很好的理由不单独依赖P值；请参阅关于p-hacking和统计科学相关主题的持续辩论。'
- en: '**Residuals**: Examining the residuals (the differences between the observed
    and predicted values) is crucial for assessing model performance. Ideally, residuals
    should be random, with no apparent patterns. Patterns in residuals may indicate
    model misspecification.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**残差**：检查残差（观测值与预测值之间的差异）对于评估模型性能至关重要。理想情况下，残差应该是随机的，没有明显的模式。残差中的模式可能表明模型存在误设。'
- en: '**Confidence intervals**: Confidence intervals around coefficients provide
    a range within which the true population parameter is likely to lie. Wider intervals
    indicate greater uncertainty.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置信区间**：系数周围的置信区间提供了一个范围，其中真实的总体参数很可能位于其中。较宽的区间表示更大的不确定性。'
- en: '**F-statistic**: The F-statistic tests the overall significance of the model.
    A small F-statistic suggests that the model doesn’t explain much variance in the
    target variable, while a large value indicates a better overall fit.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F 统计量**：F 统计量检验模型的总体显著性。小的 F 统计量表明模型对目标变量的方差解释不多，而大的值则表示更好的整体拟合。'
- en: '**Adjusted R-squared**: Adjusted R-squared adjusts the R-squared value for
    the number of predictors in the model. It helps you determine whether adding more
    predictors improves the model’s fit.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调整后的 R 平方**：调整后的 R 平方根据模型中的预测因子数量调整 R 平方值。它帮助您确定添加更多预测因子是否可以改善模型的拟合度。'
- en: By carefully examining these elements, you can gain insights into how well the
    linear model fits your data, the significance of predictor variables, and the
    overall quality of the model. This information is invaluable for making informed
    decisions and drawing meaningful conclusions from your analysis.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细检查这些元素，您可以深入了解线性模型与您的数据拟合得如何，预测变量的显著性以及模型的总体质量。这些信息对于做出明智的决策和从分析中得出有意义的结论至关重要。
- en: 'With the model trained and the fit evaluated, we can visualize the results
    to help with interpretation. The following code creates a scatterplot of predicted
    versus observed values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型训练和拟合评估后，我们可以可视化结果以帮助解释。以下代码创建了一个预测值与观察值之间的散点图：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the scatterplot for it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的散点图：
- en: '![Figure 9.3 – Linear regression prediction plot](img/B19142_09_3.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 线性回归预测图](img/B19142_09_3.jpg)'
- en: Figure 9.3 – Linear regression prediction plot
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 线性回归预测图
- en: 'In addition, we can create diagnostic plots and visualizations such as residual
    plots and Q-Q plots, which can help you identify potential issues with the model,
    such as heteroscedasticity or outliers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以创建诊断图和可视化，如残差图和 Q-Q 图，这有助于您识别模型中可能存在的问题，例如异方差性或异常值：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The two preceding plots look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个图表看起来像这样：
- en: '![Figure 9.4 – Residuals plot](img/B19142_09_4.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 残差图](img/B19142_09_4.jpg)'
- en: Figure 9.4 – Residuals plot
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 残差图
- en: '![Figure 9.5 – Residuals Q-Q plot](img/B19142_09_5.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 残差 Q-Q 图](img/B19142_09_5.jpg)'
- en: Figure 9.5 – Residuals Q-Q plot
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 残差 Q-Q 图
- en: Finally, we can export the results to Excel. This will be covered in detail
    in the next subsection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将结果导出到 Excel。这将在下一小节中详细介绍。
- en: As a side note, `scikit-learn` also has an in-built linear model but that does
    not come with the handy summary statistics we have used in the preceding code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，`scikit-learn` 也内置了线性模型，但它没有提供我们在前面代码中使用的手动汇总统计信息。
- en: This code demonstrated a basic linear regression workflow using Python and Excel
    data. Let’s move on to logistic regression!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了使用 Python 和 Excel 数据进行基本线性回归工作流程。让我们继续学习逻辑回归！
- en: Logistic regression in Python using Excel data
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Excel 数据在 Python 中进行逻辑回归
- en: In the following code, we generate random sample data with two features (`Feature1`
    and `Feature2`) and a binary target variable (`Target`) based on a simple condition.
    We perform logistic regression, evaluate the model using accuracy, the confusion
    matrix, and a classification report, visualize the results for binary classification,
    and interpret the coefficients.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们根据简单条件生成具有两个特征（`Feature1` 和 `Feature2`）和二元目标变量（`Target`）的随机样本数据。我们执行逻辑回归，使用准确率、混淆矩阵和分类报告评估模型，可视化二元分类的结果，并解释系数。
- en: 'The following is a step-by-step code example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个逐步的代码示例：
- en: 'Again, we start with importing the necessary libraries:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们从导入必要的库开始：
- en: '[PRE34]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For this example, we will use a different sample dataset:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用不同的样本数据集：
- en: '[PRE35]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With your data available in Excel, we can read it and prepare it for the modeling
    step:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Excel 中有了您的数据后，我们可以读取它并为建模步骤做准备：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can create and fit a model. We will use the `scikit-learn` library
    this time:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建和拟合一个模型。这次我们将使用 `scikit-learn` 库：
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With a model fit, we can now visualize the results:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模型拟合后，我们现在可以可视化结果：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Unlike with linear regression, we need different goodness-of-fit metrics because
    we are using logistic regression for a binary classification:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与线性回归不同，我们需要不同的拟合优度指标，因为我们使用逻辑回归进行二元分类：
- en: '[PRE39]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result looks like this:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果看起来像这样：
- en: '![Figure 9.6 – Logistic regression prediction plot](img/B19142_09_6.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 逻辑回归预测图](img/B19142_09_6.jpg)'
- en: Figure 9.6 – Logistic regression prediction plot
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 逻辑回归预测图
- en: 'This is the code result:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码结果：
- en: '![Figure 9.7 – Model summary statistics](img/B19142_09_7.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 模型摘要统计](img/B19142_09_7.jpg)'
- en: Figure 9.7 – Model summary statistics
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 模型摘要统计
- en: 'To interpret the preceding results, you can start with the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释前面的结果，您可以从以下内容开始：
- en: '`Accuracy` is a fundamental metric, representing the ratio of correctly predicted
    instances to the total number of instances. While easy to understand, accuracy
    can be misleading if there’s an imbalance between the classes.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`准确度`是一个基本指标，表示正确预测的实例数与总实例数的比率。虽然容易理解，但如果类别之间存在不平衡，准确度可能会误导。'
- en: '`Confusion Matrix` offers a more detailed view. It breaks down predictions
    into four categories: true positives, true negatives, false positives, and false
    negatives. This matrix provides a clear understanding of how well the model performs
    in terms of correctly classifying positive and negative instances.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`混淆矩阵`提供了更详细的视图。它将预测分解为四个类别：真正例、真负例、假正例和假负例。这个矩阵清晰地说明了模型在正确分类正负实例方面的表现。'
- en: '`Classification Report` provides a comprehensive summary. It includes metrics
    such as `precision`, `recall`, `f1-score`, and `support` for both classes. `Precision`
    measures how many predicted positives were actually positive, while `recall` quantifies
    how many actual positives were correctly predicted. The `F1-score` balances `precision`
    and `recall`. `Support` denotes the number of instances for each class. Together,
    these metrics offer a more nuanced evaluation of the model’s performance in binary
    classification tasks.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分类报告`提供了全面的摘要。它包括针对两个类别的`精确度`、`召回率`、`F1 分数`和`支持度`等指标。`精确度`衡量预测为正的实例中有多少实际上是正的，而`召回率`量化了多少实际正例被正确预测。`F1
    分数`平衡了`精确度`和`召回率`。`支持度`表示每个类别的实例数量。这些指标共同提供了对模型在二元分类任务中性能的更细致评估。'
- en: You can use this sample data and code for testing and experimenting with logistic
    regression.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此示例数据和代码进行逻辑回归的测试和实验。
- en: Please note that contrary to the popular (but incorrect) assertion, logistic
    regression can be used as a regression as well – what makes it a classifier is
    an arbitrary cut-off point for the predicted probability. For some use cases,
    you might want to use the raw regression output (if, for example, you are interested
    in the predicted probability of the data point belonging to a class, and not the
    more likely class only) and for others, you might want to play with the cut-off
    point (if, for example, there is pre-existing domain information that implies
    that 50% is not the right cut-off point).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与流行的（但错误）说法相反，逻辑回归也可以用作回归——使其成为分类器的是预测概率的任意截止点。对于某些用例，您可能希望使用原始回归输出（例如，如果您对数据点属于某个类别的预测概率感兴趣，而不仅仅是更可能的类别），而对于其他用例，您可能希望调整截止点（例如，如果存在先验领域信息表明
    50% 不是正确的截止点）。
- en: That’s it! Logistic regression is a relatively simple model with lots of benefits.
    It’s performant, easy to fit, easy to interpret, and very versatile. It’s most
    often used for classification with a domain-knowledge-driven cut-off point, but
    under the hood, it remains a regression method that can be used for predicting
    class probabilities.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！逻辑回归是一个相对简单的模型，具有许多优点。它性能良好，易于拟合，易于解释，并且非常灵活。它最常用于具有领域知识驱动的截止点的分类，但本质上，它仍然是一种可以用于预测类别概率的回归方法。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the powerful world of linear and logistic regression
    using Excel data. Linear regression, a fundamental statistical technique, allows
    us to model relationships between dependent and independent variables. We discussed
    its assumptions and applications, and walked through the entire process of loading
    data from Excel, preparing it for analysis, and fitting linear regression models
    using both R (using base R and `tidymodels`) and Python (with the `scikit-learn`
    and `statsmodels` libraries).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Excel 数据探索了线性回归和逻辑回归强大的世界。线性回归是一种基本的统计技术，使我们能够建模因变量和自变量之间的关系。我们讨论了其假设和应用，并介绍了从
    Excel 加载数据、准备分析以及使用 R（使用基础 R 和 `tidymodels`）和 Python（使用 `scikit-learn` 和 `statsmodels`
    库）拟合线性回归模型的全过程。
- en: Through comprehensive code examples, you learned how to perform regression analysis,
    assess model accuracy, and generate valuable statistics and metrics to interpret
    model results. We gained insights into creating diagnostic plots, such as residual
    plots and Q-Q plots, which aid in identifying issues such as heteroscedasticity
    and outliers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过综合的代码示例，你学习了如何进行回归分析，评估模型准确性，并生成有价值的统计数据和指标来解释模型结果。我们获得了创建诊断图（如残差图和Q-Q图）的见解，这些图有助于识别异方差性和异常值等问题。
- en: Additionally, we delved into logistic regression, a powerful tool for class
    probability prediction and binary classification tasks. We established its importance
    and applications and outlined the process of data preparation, model fitting,
    and metrics evaluation. With practical code examples, we observed how logistic
    regression models can be constructed using `tidymodels` in R and the `scikit-learn`
    library in Python.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还深入探讨了逻辑回归，这是一种用于类别概率预测和二分类任务的强大工具。我们阐述了其重要性和应用，并概述了数据准备、模型拟合和指标评估的过程。通过实际代码示例，我们观察了如何在R中的`tidymodels`和Python中的`scikit-learn`库中使用逻辑回归模型进行构建。
- en: By the end of this chapter, you should have a strong grasp of linear and logistic
    regression, from theory to practical application, and the ability to harness these
    techniques to analyze your data efficiently.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对线性回归和逻辑回归有深刻的理解，从理论到实际应用，并能够利用这些技术高效地分析你的数据。
- en: With these skills, you are well-equipped to conduct regression analyses and
    extract valuable insights from your data in Python.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些技能，你将能够熟练地进行回归分析，并从你的数据中提取有价值的见解，使用Python。
- en: On to the next chapter, where you will learn about time series analysis and
    its applications to Excel data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是下一章，你将学习时间序列分析及其在Excel数据中的应用。
