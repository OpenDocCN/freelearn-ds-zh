<html><head></head><body><div><div><h1 id="_idParaDest-72"><em class="italics"><a id="_idTextAnchor088"/>Chapter 3</em></h1>
		</div>
		<div><h1 id="_idParaDest-73"><a id="_idTextAnchor089"/>Introduction to NumPy, Pandas,and Matplotlib</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of the chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Create and manipulate one-dimensional and multi-dimensional arrays</li>
				<li class="bullets">Create and manipulate pandas DataFrames and series objects</li>
				<li class="bullets">Plot and visualize numerical data using the Matplotlib library</li>
				<li class="bullets">Apply matplotlib, NumPy, and pandas to calculate descriptive statistics from a DataFrame/matrix</li>
			</ul>
			<p>In this chapter, you will learn about the fundamentals of the NumPy, pandas, and matplotlib libraries.</p>
		</div>
		<div><h2 id="_idParaDest-74"><a id="_idTextAnchor090"/>Introduction</h2>
			<p>In the preceding chapters, we have covered some advanced data structures, such as stack, queue, iterator, and file operations in Python. In this section, we will cover three essential libraries, namely NumPy, pandas, and matplotlib.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor091"/>NumPy Arrays</h2>
			<p>In the life of a data scientist, reading and manipulating arrays is of prime importance, and it is also the most frequently encountered task. These arrays could be a one-dimensional list or a multi-dimensional table or a matrix full of numbers.</p>
			<p>The array could be filled with integers, floating-point numbers, Booleans, strings, or even mixed types. However, in the majority of cases, numeric data types are predominant.</p>
			<p>Some example scenarios where you will need to handle numeric arrays are as follows:</p>
			<ul>
				<li>To read a list of phone numbers and postal codes and extract a certain pattern</li>
				<li>To create a matrix with random numbers to run a Monte Carlo simulation on some statistical process</li>
				<li>To scale and normalize a sales figure table, with lots of financial and transactional data</li>
				<li>To create a smaller table of key descriptive statistics (for example, mean, median, min/max range, variance, inter-quartile ranges) from a large raw data table</li>
				<li>To read in and analyze time series data in a one-dimensional array daily, such as the stock price of an organization over a year or daily temperature data from a weather station</li>
			</ul>
			<p>In short, arrays and numeric data tables are everywhere. As a data wrangling professional, the importance of the ability to read and process numeric arrays cannot be overstated. In this regard, NumPy arrays will be the most important object in Python that you need to know about.</p>
			<h3 id="_idParaDest-76"><a id="_idTextAnchor092"/>NumPy Array and Features</h3>
			<p><strong class="keyword">NumPy</strong> and <strong class="keyword">SciPy</strong> are open source add-on modules for Python that provide common mathematical and numerical routines in pre-compiled, fast functions. These have grown into highly mature libraries that provide functionality that meets, or perhaps exceeds, what is associated with common commercial software such as <strong class="keyword">MATLAB</strong> or <strong class="keyword">Mathematica</strong>.</p>
			<p>One of the main advantages of the NumPy module is to handle or create one-dimensional or multi-dimensional arrays. This advanced data structure/class is at the heart of the NumPy package and it serves as the fundamental building block of more advanced classes such as <strong class="keyword">pandas</strong> and<strong class="keyword"> DataFrame</strong>, which we will cover shortly in this chapter.</p>
			<p>NumPy arrays are different than common Python lists, since Python lists can be thought as simple array. NumPy arrays are built for <strong class="keyword">vectorized</strong> operations that process a lot of numerical data with just a single line of code. Many built-in mathematical functions in NumPy arrays are written in low-level languages such as C or Fortran and pre-compiled for real, fast execution.</p>
			<h4>Note</h4>
			<p class="callout">NumPy arrays are optimized data structures for numerical analysis, and that's why they are so important to data scientists.</p>
			<h3 id="_idParaDest-77"><a id="_idTextAnchor093"/><a id="_idTextAnchor094"/>Exercise 26: Creating a NumPy Array (from a List)</h3>
			<p>In this exercise, we will create a NumPy array from a list:</p>
			<ol>
				<li>To work with NumPy, we must import it. By convention, we give it a short name, <code>np</code>, while importing:<pre>import numpy as np</pre></li>
				<li>Create a list with three elements, 1, 2, and 3:<pre>list_1 = [1,2,3]</pre></li>
				<li>Use the <code>array</code> function to convert it into an array:<pre>array_1 = np.array(list_1)</pre><p>We just created a NumPy array object called <code>array_1</code> from the regular Python list object, <code>list_1</code>.</p></li>
				<li>Create an array of floating type elements 1.2, 3.4, and 5.6:<pre>import array as arr
a = arr.array('d', [1.2, 3.4, 5.6])
print(a)</pre><p>The output is as follows:</p><pre>array('d', [1.2, 3.4, 5.6])</pre></li>
				<li>Let's check the type of the newly created object by using the <code>type</code> function:<pre>type(array_1)</pre><p>The output is as follows:</p><pre>numpy.ndarray</pre></li>
				<li>Use <code>type</code> on <code>list_1</code>:<pre>type (list_1)</pre><p><a id="_idTextAnchor095"/>The output is as follows:</p><pre>list</pre></li>
			</ol>
			<p>So, this is indeed different from the regular <code>list</code> object.</p>
			<h3 id="_idParaDest-78"><a id="_idTextAnchor096"/>Exercise 27: Adding Two NumPy Arrays</h3>
			<p>This simple exercise will demonstrate the addition of two NumPy arrays, and thereby show the key difference between a regular Python list/array and a NumPy array:</p>
			<ol>
				<li value="1">Consider <code>list_1</code> and <code>array_1</code> from the preceding exercise. If you have changed the Jupyter notebook, you will have to declare them again.</li>
				<li>Use the <code>+</code> notation to add two <code>list_1</code> object and save the results in <code>list_2</code>:<pre>list_2 = list_1 + list_1
print(list_2)</pre><p>The output is as follows:</p><pre> [1, 2, 3, 1, 2, 3]</pre></li>
				<li>Use the same <code>+</code> notation to add two <code>array_1</code> objects and save the result in <code>array_2</code>:<pre>array_2 = array_1 + array_1
print(array_2)</pre><p>The output is as follows:</p><pre>[2, ,4, 6]</pre></li>
			</ol>
			<p>Did you notice the difference? The first print shows a list with 6 elements [1, 2, 3, 1, 2, 3]. But the second print shows another NumPy array (or vector) with the elements [2, 4, 6], which are just the sum of the individual elements of <code>array_1</code>.</p>
			<p>NumPy arrays are like mathematical objects – <strong class="keyword">vectors</strong>. They are built for element-wise operations, that is, when we add two NumPy arrays, we add the first element of the first array to the first element of the second array – there is an element-to-element correspondence in this operation. This is in contrast to Python lists, where the elements are simply appended and there is no element-to-element relation. This is the real power of a NumPy array: they can be treated just like mathematical vectors.</p>
			<p>A vector is a collection of numbers that can represent, for example, the coordinates of points in a three-dimensional space or the color of numbers (RGB) in a picture. Naturally, relative order is important for such a collection and as we discussed previously, a NumPy array can maintain such order relationships. That's why they are perfectly suitable to use in numerical computations.</p>
			<h3 id="_idParaDest-79"><a id="_idTextAnchor097"/>Exercise 28: Mathematical Operations on NumPy Arrays</h3>
			<p>Now that you know that these arrays are like vectors, we will try some mathematical operations on arrays.</p>
			<p>NumPy arrays even support element-wise exponentiation. For example, suppose there are two arrays – the elements of the first array will be raised to the power of the elements in the second array:</p>
			<ol>
				<li value="1">Multiply two arrays using the following command:<pre>print("array_1 multiplied by array_1: ",array_1*array_1)</pre><p>The output is as follows:</p><pre>array_1 multiplied by array_1:  [1 4 9]</pre></li>
				<li>Divide two arrays using the following command:<pre>print("array_1 divided by array_1: ",array_1/array_1)</pre><p>The output is as follows:</p><pre>array_1 divided by array_1:  [1. 1. 1.]</pre></li>
				<li>Raise one array to the second arrays power using the following command:<pre>print("array_1 raised to the power of array_1: ",array_1**array_1)</pre><p>The output is as follows:</p><pre>array_1 raised to the power of array_1:  [ 1  4 27]</pre></li>
			</ol>
			<h3 id="_idParaDest-80"><a id="_idTextAnchor098"/>Exercise 29: Advanced Mathematical Operations on NumPy Arrays</h3>
			<p>NumPy has all the built-in mathematical functions that you can think of. Here, we are going to be creating a list and converting it into a NumPy array. Then, we will perform some advanced mathematical operations on that array.</p>
			<p>Here, we are creating a list and then converting that into a NumPy array. We will then show you how to perform some advanced mathematical operations on that array:</p>
			<ol>
				<li value="1">Create a list with five elements:<pre>list_5=[i for i in range(1,6)]
print(list_5)</pre><p>The output is as follows:</p><pre>[1, 2, 3, 4, 5]</pre></li>
				<li>Convert the list into a NumPy array by using the following command:<pre>array_5=np.array(list_5)
array_5</pre><p>The output is as follows:</p><pre>array([1, 2, 3, 4, 5])</pre></li>
				<li>Find the <code>sine</code> value of the array by using the following command:<pre># sine function
print("Sine: ",np.sin(array_5))</pre><p>The output is as follows:</p><pre>Sine:  [ 0.84147098  0.90929743  0.14112001 -0.7568025  -0.95892427]</pre></li>
				<li>Find the logarithmic value of the array by using the following command:<pre># logarithm
print("Natural logarithm: ",np.log(array_5))
print("Base-10 logarithm: ",np.log10(array_5))
print("Base-2 logarithm: ",np.log2(array_5))</pre><p>The output is as follows:</p><pre>Natural logarithm:  [0.         0.69314718 1.09861229 1.38629436 1.60943791]
Base-10 logarithm:  [0.         0.30103    0.47712125 0.60205999 0.69897   ]
Base-2 logarithm:  [0.         1.         1.5849625  2.         2.32192809]</pre></li>
				<li>Find the exponential value of the array by using the following command:<pre># Exponential
print("Exponential: ",np.exp(array_5))</pre><p>The output is as follows:</p><pre>Exponential:  [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]</pre></li>
			</ol>
			<h3 id="_idParaDest-81"><a id="_idTextAnchor099"/>Exercise 30: Generating Arrays Using arange and linspace</h3>
			<p>Generation of numerical arrays is a fairly common task. So far, we have been doing this by creating a Python list object and then converting that into a NumPy array. However, we can bypass that and work directly with native NumPy methods.</p>
			<p>The <code>arange</code> function creates a series of numbers based on the minimum and maximum bounds you give and the step size you specify. Another function, <code>linspace</code>, creates a series of the fixed numbers of intermediate points between two extremes:</p>
			<ol>
				<li value="1">Create a series of numbers using the <code>arange</code> method, by using the following command:<pre>print("A series of numbers:",np.arange(5,16))</pre><p>The output is as follows:</p><pre>A series of numbers: [ 5  6  7  8  9 10 11 12 13 14 15]</pre></li>
				<li>Print numbers using the <code>arange</code> function by using the following command:<pre><a id="_idTextAnchor100"/>print("Numbers spaced apart by 2: ",np.arange(0,11,2))
print("Numbers spaced apart by a floating point number: ",np.arange(0,11,2.5))
print("Every 5th number from 30 in reverse order\n",np.arange(30,-1,-5))</pre><p>The output is as follows:</p><pre>Numbers spaced apart by 2:  [ 0  2  4  6  8 10]
Numbers spaced apart by a floating point number:  [ 0.   2.5  5.   7.5 10. ]
Every 5th number from 30 in reverse order
 [30 25 20 15 10  5  0]</pre></li>
				<li>For linearly spaced numbers, we can use the <code>linspace</code> method, as follows:<pre>print("11 linearly spaced numbers between 1 and 5: ",np.linspace(1,5,11))</pre><p>The output is as follows:</p><pre>11 linearly spaced numbers between 1 and 5:  [1.  1.4 1.8 2.2 2.6 3.  3.4 3.8 4.2 4.6 5. ]</pre></li>
			</ol>
			<h3 id="_idParaDest-82"><a id="_idTextAnchor101"/>Exercise 31: Creating Multi-Dimensional Arrays</h3>
			<p>So far, we have created only one-dimensional arrays. Now, let's create some multi-dimensional arrays (such as a matrix in linear algebra). Just like we created the one-dimensional array from a simple flat list, we can create a two-dimensional array from a list of lists:</p>
			<ol>
				<li value="1">Create a list of lists and convert it into a two-dimensional NumPy array by using the following command:<pre>list_2D = [[1,2,3],[4,5,6],[7,8,9]]
mat1 = np.array(list_2D)
print("Type/Class of this object:",type(mat1))
print("Here is the matrix\n----------\n",mat1,"\n----------")</pre><p>The output is as follows:</p><pre>Type/Class of this object: &lt;class 'numpy.ndarray'&gt;
Here is the matrix
---------- 
[[1 2 3] 
[4 5 6] 
[7 8 9]] 
----------</pre></li>
				<li>Tuples can be converted into multi-dimensional arrays by using the following code:<pre>tuple_2D = np.array([(1.5,2,3), (4,5,6)])
mat_tuple = np.array(tuple_2D)
print (mat_tuple)</pre><p>The output is as follows:</p><pre>[[1.5 2.  3. ]
 [4.  5.  6. ]]</pre></li>
			</ol>
			<p>Thus, we have created multi-dimensional arrays using Python lists and tuples.</p>
			<h3 id="_idParaDest-83"><a id="_idTextAnchor102"/>Exercise 32: The Dimension, Shape, Size, and Data Type of the Two-dimensional Array</h3>
			<p>The following methods let you check the dimension, shape, and size of the array. Note that if it's a 3x2 matrix, that is, it has 3 rows and 2 columns, then the shape will be (3,2), but the size will be 6, as 6 = 3x2:</p>
			<ol>
				<li value="1">Print the dimension of the matrix using <code>ndim</code> by using the following command:<pre>print("Dimension of this matrix: ",mat1.ndim,sep='')</pre><p>The output is as follows:</p><pre>Dimension of this matrix: 2</pre></li>
				<li>Print the size using <code>size</code>:<pre>print("Size of this matrix: ", mat1.size,sep='') </pre><p>The output is as follows:</p><pre>Size of this matrix: 9</pre></li>
				<li>Print the shape of the matrix using <code>shape</code>:<pre>print("Shape of this matrix: ", mat1.shape,sep='')</pre><p>The output is as follows:</p><pre>Shape of this matrix: (3, 3)</pre></li>
				<li>Print the dimension type using <code>dtype</code>:<pre>print("Data type of this matrix: ", mat1.dtype,sep='')</pre><p>The output is as follows:</p><pre>Data type of this matrix: int32</pre></li>
			</ol>
			<h3 id="_idParaDest-84"><a id="_idTextAnchor103"/>Exercise 33: Zeros, Ones, Random, Identity Matrices, and Vectors</h3>
			<p>Now that we are familiar with basic vector (one-dimensional) and matrix data structures in NumPy, we will take a look how to create special matrices easily. Often, you may have to create matrices filled with zeros, ones, random numbers, or ones in the diagonal:</p>
			<ol>
				<li value="1">Print the vector of zeros by using the following command:<pre>print("Vector of zeros: ",np.zeros(5))</pre><p>The output is as follows:</p><pre>Vector of zeros:  [0. 0. 0. 0. 0.]</pre></li>
				<li>Print the matrix of zeros by using the following command:<pre>print("Matrix of zeros: ",np.zeros((3,4)))</pre><p>The output is as follows:</p><pre>Matrix of zeros:  [[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]</pre></li>
				<li>Print the matrix of fives by using the following command:<pre>print("Matrix of 5's: ",5*np.ones((3,3)))</pre><p>The output is as follows:</p><pre>Matrix of 5's:  [[5. 5. 5.]
 [5. 5. 5.]
 [5. 5. 5.]]</pre></li>
				<li>Print an identity matrix by using the following command:<pre>print("Identity matrix of dimension 2:",np.eye(2))</pre><p>The output is as follows:</p><pre>Identity matrix of dimension 2: [[1. 0.]
 [0. 1.]]</pre></li>
				<li>Print an identity matrix with a dimension of 4x4 by using the following command:<pre>print("Identity matrix of dimension 4:",np.eye(4))</pre><p>The output is as follows:</p><pre>Identity matrix of dimension 4: [[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]</pre></li>
				<li>Print a matrix of random shape using the <code>randint</code> function:<pre>print("Random matrix of shape (4,3):\n",np.random.randint(low=1,high=10,size=(4,3)))</pre><p>The sample output is as follows:</p><pre>Random matrix of shape (4,3):
 [[6 7 6]
 [5 6 7]
 [5 3 6]
 [2 9 4]]</pre><h4>Note</h4><p class="callout">When creating matrices, you need to pass on tuples of integers as arguments.</p></li>
			</ol>
			<p>Random number generation is a very useful utility and needs to be mastered for data science/data wrangling tasks. We will look at the topic of random variables and distributions again in the section on statistics and see how NumPy and pandas have built-in random number and series generation, as well as manipulation functions.</p>
			<h3 id="_idParaDest-85"><a id="_idTextAnchor104"/>Exercise 34: Reshaping, Ravel, Min, Max, and Sorting</h3>
			<p><code>reshape</code> is the <code>ravel</code> function, which flattens any given array into a one-dimensional array. It is a very useful action in many machine learning and data analytics tasks.</p>
			<p>The following functions reshape the function. We will first generate a random one-dimensional vector of 2-digit numbers and then reshape the vector into multi-dimensional vectors:</p>
			<ol>
				<li value="1">Create an array of 30 random integers (sampled from 1 to 99) and reshape it into two different forms using the following code:<pre>a = np.random.randint(1,100,30)
b = a.reshape(2,3,5)
c = a.reshape(6,5)</pre></li>
				<li>Print the shape using the <code>shape</code> function by using the following code:<pre>print ("Shape of a:", a.shape)
print ("Shape of b:", b.shape)
print ("Shape of c:", c.shape)</pre><p>The output is as follows:</p><pre>Shape of a: (30,)
Shape of b: (2, 3, 5)
Shape of c: (6, 5)</pre></li>
				<li>Print the arrays a, b, and c using the following code:<pre>print("\na looks like\n",a)
print("\nb looks like\n",b)
print("\nc looks like\n",c)</pre><p>The sample output is as follows:</p><pre>a looks like
 [ 7 82  9 29 50 50 71 65 33 84 55 78 40 68 50 15 65 55 98 38 23 75 50 57
 32 69 34 59 98 48]
b looks like
 [[[ 7 82  9 29 50]
  [50 71 65 33 84]
  [55 78 40 68 50]]
 [[15 65 55 98 38]
  [23 75 50 57 32]
  [69 34 59 98 48]]]
c looks like
 [[ 7 82  9 29 50]
 [50 71 65 33 84]
 [55 78 40 68 50]
 [15 65 55 98 38]
 [23 75 50 57 32]
 [69 34 59 98 48]]</pre><h4>Note</h4><p class="callout">"b" is a three-dimensional array – a kind of list of a list of a list.</p></li>
				<li>Ravel file b using the following code:<pre>b_flat = b.ravel()
print(b_flat)</pre><p>The sample output is as follows:</p><pre>[ 7 82  9 29 50 50 71 65 33 84 55 78 40 68 50 15 65 55 98 38 23 75 50 57
 32 69 34 59 98 48]</pre></li>
			</ol>
			<h3 id="_idParaDest-86"><a id="_idTextAnchor105"/>Exercise 35: Indexing and Slicing</h3>
			<p><strong class="keyword">Indexing</strong> and <strong class="keyword">slicing</strong> of NumPy arrays is very similar to regular list indexing. We can even step through a vector of elements with a definite step size by providing it as an additional argument in the format (start, step, end). Furthermore, we can pass a list as the argument to select specific elements.</p>
			<p>In this exercise, we will learn about indexing and slicing on one-dimensional and multi-dimensional arrays:</p>
			<h4>Note</h4>
			<p class="callout">In multi-dimensional arrays, you can use two numbers to denote the position of an element. For example, if the element is in the third row and second column, its indices are 2 and 1 (because of Python's zero-based indexing).</p>
			<ol>
				<li value="1">Create an array of 10 elements and examine its various elements by slicing and indexing the array with slightly different syntaxes. Do this by using the following command:<pre>array_1 = np.arange(0,11)
print("Array:",array_1)</pre><p>The output is as follows:</p><pre>Array: [ 0  1  2  3  4  5  6  7  8  9 10]</pre></li>
				<li>Print the element in the seventh position by using the following command:<pre>print("Element at 7th index is:", array_1[7])</pre><p>The output is as follows:</p><pre>Element at 7th index is: 7</pre></li>
				<li>Print the elements between the third and sixth positions by using the following command:<pre>print("Elements from 3rd to 5th index are:", array_1[3:6])</pre><p>The output is as follows:</p><pre>Elements from 3rd to 5th index are: [3 4 5]</pre></li>
				<li>Print the elements until the fourth position by using the following command:<pre>print("Elements up to 4th index are:", array_1[:4])</pre><p>The output is as follows:</p><pre>Elements up to 4th index are: [0 1 2 3]</pre></li>
				<li>Print the elements backwards by using the following command:<pre>print("Elements from last backwards are:", array_1[-1::-1])</pre><p>The output is as follows:</p><pre>Elements from last backwards are: [10  9  8  7  6  5  4  3  2  1  0]</pre></li>
				<li>Print the elements using their backward index, skipping three values, by using the following command:<pre>print("3 Elements from last backwards are:", array_1[-1:-6:-2])</pre><p>The output is as follows:</p><pre>3 Elements from last backwards are: [10  8  6]</pre></li>
				<li>Create a new array called <code>array_2</code> by using the following command:<pre>array_2 = np.arange(0,21,2)
print("New array:",array_2)</pre><p>The output is as follows:</p><pre>New array: [ 0  2  4  6  8 10 12 14 16 18 20]</pre></li>
				<li>Print the second, fourth, and ninth elements of the array:<pre>print("Elements at 2nd, 4th, and 9th index are:", array_2[[2,4,9]])</pre><p>The output is as follows:</p><pre>Elements at 2nd, 4th, and 9th index are: [ 4  8 18]</pre></li>
				<li>Create a multi-dimensional array by using the following command:<pre>matrix_1 = np.random.randint(10,100,15).reshape(3,5)
print("Matrix of random 2-digit numbers\n ",matrix_1)</pre><p>The sample output is as follows:</p><pre>Matrix of random 2-digit numbers
  [[21 57 60 24 15]
 [53 20 44 72 68]
 [39 12 99 99 33]]</pre></li>
				<li>Access the values using double bracket indexing by using the following command:<pre>print("\nDouble bracket indexing\n")
print("Element in row index 1 and column index 2:", matrix_1[1][2])</pre><p>The sample output is as follows:</p><pre>Double bracket indexing
Element in row index 1 and column index 2: 44</pre></li>
				<li>Access the values using single bracket indexing by using the following command:<pre>print("\nSingle bracket with comma indexing\n")
print("Element in row index 1 and column index 2:", matrix_1[1,2])</pre><p>The sample output is as follows:</p><pre>Single bracket with comma indexing
Element in row index 1 and column index 2: 44</pre></li>
				<li>Access the values in a multi-dimensional array using a row or column by using the following command:<pre>print("\nRow or column extract\n")
print("Entire row at index 2:", matrix_1[2])
print("Entire column at index 3:", matrix_1[:,3])</pre><p>The sample output is as follows:</p><pre>Row or column extract
Entire row at index 2: [39 12 99 99 33]
Entire column at index 3: [24 72 99]</pre></li>
				<li>Print the matrix with the specified row and column indices by using the following command:<pre>print("\nSubsetting sub-matrices\n")
print("Matrix with row indices 1 and 2 and column indices 3 and 4\n", matrix_1[1:3,3:5])</pre><p>The sample output is as follows:</p><pre>Subsetting sub-matrices
Matrix with row indices 1 and 2 and column indices 3 and 4
 [[72 68]
 [99 33]]</pre></li>
				<li>Print the matrix with the specified row and column indices by using the following command:<pre>print("Matrix with row indices 0 and 1 and column indices 1 and 3\n", matrix_1[0:2,[1,3]])</pre><p>The sample output is as follows:</p><pre>Matrix with row indices 0 and 1 and column indices 1 and 3
 [[57 24]
 [20 72]]</pre></li>
			</ol>
			<h3 id="_idParaDest-87"><a id="_idTextAnchor106"/>Conditional Subsetting</h3>
			<p><strong class="keyword">Conditional subsetting</strong> is a way to select specific elements based on some numeric condition. It is almost like a shortened version of a SQL query to subset elements. See the following example:</p>
			<pre>matrix_1 = np.array(np.random.randint(10,100,15)).reshape(3,5)
print("Matrix of random 2-digit numbers\n",matrix_1)
print ("\nElements greater than 50\n", matrix_1[matrix_1&gt;50])</pre>
			<p>The sample output is as follows (note that the exact output will be different for you as it is random):</p>
			<pre>Matrix of random 2-digit numbers
 [[71 89 66 99 54]
 [28 17 66 35 85]
 [82 35 38 15 47]]
Elements greater than 50
 [71 89 66 99 54 66 85 82]</pre>
			<h3 id="_idParaDest-88"><a id="_idTextAnchor107"/>Exercise 36: Array Operations (array-array, array-scalar, and universal functions)</h3>
			<p>NumPy arrays operate just like mathematical matrices, and the operations are performed element-wise.</p>
			<p>Create two matrices (multi-dimensional arrays) with random integers and demonstrate element-wise mathematical operations such as addition, subtraction, multiplication, and division. Show the exponentiation (raising a number to a certain power) operation, as follows:</p>
			<h4>Note</h4>
			<p class="callout">Due to random number generation, your specific output could be different to what is shown here.</p>
			<ol>
				<li value="1">Create two matrices:<pre>matrix_1 = np.random.randint(1,10,9).reshape(3,3)
matrix_2 = np.random.randint(1,10,9).reshape(3,3)
print("\n1st Matrix of random single-digit numbers\n",matrix_1)
print("\n2nd Matrix of random single-digit numbers\n",matrix_2)</pre><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><pre>1st Matrix of random single-digit numbers
 [[6 5 9]
 [4 7 1]
 [3 2 7]]
2nd Matrix of random single-digit numbers
 [[2 3 1]
 [9 9 9]
 [9 9 6]]</pre></li>
				<li>Perform addition, subtraction, division, and linear combination on the matrices:<pre>print("\nAddition\n", matrix_1+matrix_2)
print("\nMultiplication\n", matrix_1*matrix_2)
print("\nDivision\n", matrix_1/matrix_2)
print("\nLinear combination: 3*A - 2*B\n", 3*matrix_1-2*matrix_2)</pre><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><pre>Addition
 [[ 8  8 10]
 [13 16 10]
 [12 11 13]] ^
Multiplication
 [[12 15  9]
 [36 63  9]
 [27 18 42]]
Division
 [[3.         1.66666667 9.        ]
 [0.44444444 0.77777778 0.11111111]
 [0.33333333 0.22222222 1.16666667]]
Linear combination: 3*A - 2*B
 [[ 14   9  25]
 [ -6   3 -15]
 [ -9 -12   9]]</pre></li>
				<li>Perform the addition of a scalar, exponential matrix cube, and exponential square root:<pre>print("\nAddition of a scalar (100)\n", 100+matrix_1)
print("\nExponentiation, matrix cubed here\n", matrix_1**3)
print("\nExponentiation, square root using 'pow' function\n",pow(matrix_1,0.5))</pre><p>The sample output is as follows (note that the exact output will be different for you as it is random):</p><pre>Addition of a scalar (100)
 [[106 105 109]
 [104 107 101]
 [103 102 107]]
Exponentiation, matrix cubed here
 [[216 125 729]
 [ 64 343   1]
 [ 27   8 343]]
Exponentiation, square root using 'pow' function
 [[2.44948974 2.23606798 3.        ]
 [2.         2.64575131 1.        ]
 [1.73205081 1.41421356 2.64575131]]</pre></li>
			</ol>
			<h3 id="_idParaDest-89"><a id="_idTextAnchor108"/>Stacking Arrays</h3>
			<p><strong class="keyword">Stacking arrays</strong> on top of each other (or side by side) is a useful operation for data wrangling. Here is the code:</p>
			<pre>a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])
print("Matrix a\n",a)
print("Matrix b\n",b)
print("Vertical stacking\n",np.vstack((a,b)))
print("Horizontal stacking\n",np.hstack((a,b)))</pre>
			<p>The output is as follows:</p>
			<pre>Matrix a
 [[1 2]
 [3 4]]
Matrix b
 [[5 6]
 [7 8]]
Vertical stacking
 [[1 2]
 [3 4]
 [5 6]
 [7 8]]
Horizontal stacking
 [[1 2 5 6]
 [3 4 7 8]]</pre>
			<p>NumPy has many other advanced features, mainly related to statistics and linear algebra functions, which are used extensively in machine learning and data science tasks. However, not all of that is directly useful for beginner level data wrangling, so we won't cover it here.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor109"/>Pandas DataFrames</h2>
			<p>The pandas library is a Python package that provides fast, flexible, and expressive data structures that are designed to make working with relational or labeled data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real-world data analysis in Python. Additionally, it has the broader goal of becoming the most powerful and flexible open source data analysis/manipulation tool that's available in any language.</p>
			<p>The two primary data structures of pandas, <code>Series</code> (one-dimensional) and <code>DataFrame</code> (two-dimensional), handle the vast majority of typical use cases. Pandas is built on top of NumPy and is intended to integrate well within a scientific computing environment with many other third-party libraries.</p>
			<h3 id="_idParaDest-91"><a id="_idTextAnchor110"/>Exercise 37: Creating a Pandas Series</h3>
			<p>In this exercise, we will learn about how to create a pandas series object from the data structures that we created previously. If you have imported pandas as <code>pd</code>, then the function to create a series is simply <code>pd.Series</code>:</p>
			<ol>
				<li value="1">Initialize labels, lists, and a dictionary:<pre>labels = ['a','b','c']
my_data = [10,20,30]
array_1 = np.array(my_data)
d = {'a':10,'b':20,'c':30}
print ("Labels:", labels)
print("My data:", my_data)
print("Dictionary:", d)</pre><p>The output is as follows:</p><pre>Labels: ['a', 'b', 'c']
My data: [10, 20, 30]
Dictionary: {'a': 10, 'b': 20, 'c': 30}</pre></li>
				<li>Import pandas as <code>pd</code> by using the following command:<pre>import pandas as pd</pre></li>
				<li>Create a series from the <code>my_data</code> list by using the following command:<pre>series_1=pd.Series(data=my_data)
print(series_1)</pre><p>The output is as follows:</p><pre>0    10
1    20
2    30
dtype: int64</pre></li>
				<li>Create a series from the <code>my_data</code> list along with the <code>labels</code> as follows:<pre>series_2=pd.Series(data=my_data, index = labels)
print(series_2)</pre><p>The output is as follows:</p><pre>a    10
b    20
c    30
dtype: int64</pre></li>
				<li>Then, create a series from the NumPy array, as follows:<pre>series_3=pd.Series(array_1,labels)
print(series_3)</pre><p>The output is as follows:</p><pre>a    10
b    20
c    30
dtype: int32</pre></li>
				<li>Create a series from the dictionary, as follows:<pre>series_4=pd.Series(d)
print(series_4)</pre><p>The output is as follows:</p><pre>a    10
b    20
c    30
dtype: int64</pre></li>
			</ol>
			<h3 id="_idParaDest-92"><a id="_idTextAnchor111"/>Exercise 38: Pandas Series and Data Handling</h3>
			<p>The pandas series object can hold many types of data. This is the key to constructing a bigger table where multiple series objects are stacked together to create a database-like entity:</p>
			<ol>
				<li value="1">Create a pandas series with numerical data by using the following command:<pre>print ("\nHolding numerical data\n",'-'*25, sep='')
print(pd.Series(array_1))</pre><p>The output is as follows:</p><pre>Holding numerical data
-------------------------
0    10
1    20
2    30
dtype: int32</pre></li>
				<li>Create a pandas series with labels by using the following command:<pre>print ("\nHolding text labels\n",'-'*20, sep='')
print(pd.Series(labels))</pre><p>The output is as follows:</p><pre>Holding text labels
--------------------
0    a
1    b
2    c
dtype: object</pre></li>
				<li>Create a pandas series with functions by using the following command:<pre>print ("\nHolding functions\n",'-'*20, sep='')
print(pd.Series(data=[sum,print,len]))</pre><p>The output is as follows:</p><pre>Holding functions
--------------------
0      &lt;built-in function sum&gt;
1    &lt;built-in function print&gt;
2      &lt;built-in function len&gt;
dtype: object</pre></li>
				<li>Create a pandas series with a dictionary by using the following command:<pre>print ("\nHolding objects from a dictionary\n",'-'*40, sep='')
print(pd.Series(data=[d.keys, d.items, d.values]))</pre><p>The output is as follows:</p><pre>Holding objects from a dictionary
----------------------------------------
0    &lt;built-in method keys of dict object at 0x0000...
1    &lt;built-in method items of dict object at 0x000...
2    &lt;built-in method values of dict object at 0x00...
dtype: object</pre></li>
			</ol>
			<h3 id="_idParaDest-93"><a id="_idTextAnchor112"/>Exercise 39: Creating Pandas DataFrames</h3>
			<p>The pandas DataFrame is similar to an Excel table or relational database (SQL) table that consists of three main components: the data, the index (or rows), and the columns. Under the hood, it is a stack of pandas series objects, which are themselves built on top of NumPy arrays. So, all of our previous knowledge of NumPy array applies here:</p>
			<ol>
				<li value="1">Create a simple DataFrame from a two-dimensional matrix of numbers. First, the code draws 20 random integers from the uniform distribution. Then, we need to reshape it into a (5,4) NumPy array – 5 rows and 4 columns:<pre>matrix_data = np.random.randint(1,10,size=20).reshape(5,4)</pre></li>
				<li>Define the rows labels as <code>('A','B','C','D','E')</code> and column labels as <code>('W','X','Y','Z')</code>:<pre>row_labels = ['A','B','C','D','E']
column_headings = ['W','X','Y','Z']
df = pd.DataFrame(data=matrix_data, index=row_labels,
                  columns=column_headings)</pre></li>
				<li>The function to create a DataFrame is <code>pd.DataFrame</code> and it is called in next:<pre>print("\nThe data frame looks like\n",'-'*45, sep='')
print(df) </pre><p>The sample output is as follows:</p><pre>The data frame looks like
---------------------------------------------
   W  X  Y  Z
A  6  3  3  3
B  1  9  9  4
C  4  3  6  9
D  4  8  6  7
E  6  6  9  1</pre></li>
				<li>Create a DataFrame from a Python dictionary of some lists of integers by using the following command:<pre>d={'a':[10,20],'b':[30,40],'c':[50,60]}</pre></li>
				<li>Pass this dictionary as the data argument to the <code>pd.DataFrame</code> function. Pass on a list of rows or indices. Notice how the dictionary keys became the column names and that the values were distributed among multiple rows:<pre>df2=pd.DataFrame(data=d,index=['X','Y'])
print(df2)</pre><p>The output is as follows:</p><pre>    a   b   c
X  10  30  50
Y  20  40  60</pre><h4>Note</h4><p class="callout">The most common way that you will encounter to create a pandas DataFrame will be to read tabular data from a file on your local disk or over the internet – CSV, text, JSON, HTML, Excel, and so on. We will cover some of these in the next chapter.</p></li>
			</ol>
			<h3 id="_idParaDest-94"><a id="_idTextAnchor113"/>Exercise 40: Viewing a DataFrame Partially</h3>
			<p>In the previous section, we used <code>print(df)</code> to print the whole DataFrame. For a large dataset, we would like to print only sections of data. In this exercise, we will read a part of the DataFrame:</p>
			<ol>
				<li value="1">Execute the following code to create a DataFrame with 25 rows and fill it with random numbers:<pre># 25 rows and 4 columns
matrix_data = np.random.randint(1,100,100).reshape(25,4)
column_headings = ['W','X','Y','Z']
df = pd.DataFrame(data=matrix_data,columns=column_headings)</pre></li>
				<li>Run the following code to view only the first five rows of the DataFrame:<pre>df.head()</pre><p>The sample output is as follows (note that your output could be different due to randomness):</p><div><img src="img/C11065_03_01.jpg" alt="Figure 3.1: First five rows of the DataFrame" width="640" height="200"/></div><h6>Figure 3.1: First five rows of the DataFrame</h6><p>By default, <code>head</code> shows only five rows. If you want to see any specific number of rows just pass that as an argument.</p></li>
				<li> Print the first eight rows by using the following command:<pre>df.head(8)</pre><p>The sample output is as follows:</p><div><img src="img/C11065_03_02.jpg" alt="Figure 3.2: First eight rows of the DataFrame" width="568" height="290"/></div><h6>Figure 3.2: First eight rows of the DataFrame</h6><p>Just like <code>head</code> shows the first few rows, <code>tail</code> shows the last few rows.</p></li>
				<li>Print the DataFrame using the <code>tail</code> command, as follows:<pre>df.tail(10)</pre><p>The sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_03.jpg" alt="Figure 3.3: Last ten rows of the DataFrame" width="611" height="290"/>
				</div>
			</div>
			<h6>Figure 3.3: Last ten rows of the DataFrame</h6>
			<h3 id="_idParaDest-95"><a id="_idTextAnchor114"/>Indexing and Slicing Columns</h3>
			<p>There are two methods for indexing and slicing columns from a DataFrame. They are as follows:</p>
			<ul>
				<li><strong class="keyword">DOT method</strong></li>
				<li><strong class="keyword">Bracket method</strong></li>
			</ul>
			<p>The DOT method is good to find specific element. The bracket method is intuitive and easy to follow. In this method, you can access the data by the generic name/header of the column.</p>
			<p>The following code illustrates these concepts. Execute them in your Jupyter notebook:</p>
			<pre>print("\nThe 'X' column\n",'-'*25, sep='')
print(df['X'])
print("\nType of the column: ", type(df['X']), sep='')
print("\nThe 'X' and 'Z' columns indexed by passing a list\n",'-'*55, sep='')
print(df[['X','Z']])
print("\nType of the pair of columns: ", type(df[['X','Z']]), sep='')</pre>
			<p>The output is as follows (a screenshot is shown here because the actual column is long):</p>
			<div><div><img src="img/C11065_03_04.jpg" alt="" width="647" height="226"/>
				</div>
			</div>
			<h6>Figure 3.4: Rows of the 'X' columns</h6>
			<p>This is the output showing the type of column:</p>
			<div><div><img src="img/C11065_03_05.jpg" alt="Figure 3.5: Type of ‘X’ column" width="555" height="37"/>
				</div>
			</div>
			<h6>Figure 3.5: Type of 'X' column</h6>
			<p>This is the output showing the X and Z column indexed by passing a list:</p>
			<div><div><img src="img/C11065_03_06.jpg" alt="Figure 3.6: Rows of the ‘Y’ columns" width="665" height="239"/>
				</div>
			</div>
			<h6>Figure 3.6: Rows of the 'Y' columns</h6>
			<p>This is the output showing the type of the pair of column:</p>
			<div><div><img src="img/C11065_03_07.jpg" alt="Figure 3.7: Type of ‘Y’ column" width="621" height="22"/>
				</div>
			</div>
			<h6>Figure 3.7: Type of 'Y' column</h6>
			<h4>Note</h4>
			<p class="callout">For more than one column, the object turns into a DataFrame. But for a single column, it is a pandas series object.</p>
			<h3 id="_idParaDest-96"><a id="_idTextAnchor115"/>Indexing and Slicing Rows</h3>
			<p>Indexing and slicing rows in a DataFrame can also be done using following methods:</p>
			<ul>
				<li><strong class="keyword">Label-based 'loc' method</strong></li>
				<li><strong class="keyword">Index based 'iloc' method</strong></li>
			</ul>
			<p>The <code>loc</code> method is intuitive and easy to follow. In this method, you can access the data by the generic name of the row. On the other hand, the <code>iloc</code> method allows you to access the rows by their numerical index. It can be very useful for a large table with thousands of rows, especially when you want to iterate over the table in a loop with a numerical counter. The following code illustrate the concepts of <code>iloc</code>:</p>
			<pre>matrix_data = np.random.randint(1,10,size=20).reshape(5,4)
row_labels = ['A','B','C','D','E']
column_headings = ['W','X','Y','Z']
df = pd.DataFrame(data=matrix_data, index=row_labels,
                  columns=column_headings)
print("\nLabel-based 'loc' method for selecting row(s)\n",'-'*60, sep='')
print("\nSingle row\n")
print(df.loc['C'])
print("\nMultiple rows\n")
print(df.loc[['B','C']])
print("\nIndex position based 'iloc' method for selecting row(s)\n",'-'*70, sep='')
print("\nSingle row\n")
print(df.iloc[2])
print("\nMultiple rows\n")
print(df.iloc[[1,2]])</pre>
			<p>The sample output is as follows:</p>
			<div><div><img src="img/C11065_03_08.jpg" alt="Figure 3.8: Output of loc and iloc methods" width="604" height="434"/>
				</div>
			</div>
			<h6>Figure 3.8: Output of the loc and iloc methods</h6>
			<h3 id="_idParaDest-97">Exercise<a id="_idTextAnchor116"/> 41: Creating and Deleting a New Column or Row</h3>
			<p>One of the most common tasks in data wrangling is creating or deleting columns or rows of data from your DataFrame. Sometimes, you want to create a new column based on some mathematical operation or transformation involving the existing columns. This is similar to manipulating database records and inserting a new column based on simple transformations. We show some of these concepts in the following code blocks:</p>
			<ol>
				<li value="1">Create a new column using the following snippet:<pre>print("\nA column is created by assigning it in relation\n",'-'*75, sep='')
df['New'] = df['X']+df['Z']
df['New (Sum of X and Z)'] = df['X']+df['Z']
print(df)</pre><p>The sample output is as follows:</p><div><img src="img/C11065_03_09.jpg" alt="Figure 3.9: Output after adding a new column" width="807" height="182"/></div><h6>Figure 3.9: Output after adding a new column</h6></li>
				<li>Drop a column using the <code>df.drop</code> method:<pre>print("\nA column is dropped by using df.drop() method\n",'-'*55, sep='')
df = df.drop('New', axis=1) # Notice the axis=1 option, axis = 0 is #default, so one has to change it to 1
print(df)</pre><p>The sample output is as follows:</p><div><img src="img/C11065_03_10.jpg" alt="Figure 3.10: Output after dropping a column" width="758" height="185"/></div><h6>Figure 3.10: Output after dropping a column</h6></li>
				<li>Drop a specific row using the <code>df.drop</code> method:<pre>df1=df.drop('A')
print("\nA row is dropped by using df.drop method and axis=0\n",'-'*65, sep='')
print(df1)</pre><p>The sample output is as follows:</p><div><img src="img/C11065_03_11.jpg" alt="Figure 3.11: Output after dropping a row" width="698" height="153"/></div><h6>Figure 3.11: Output after dropping a row</h6><p>Dropping methods creates a copy of the DataFrame and does not change the original DataFrame.</p></li>
				<li>Change the original DataFrame by setting the <code>inplace</code> argument to <code>True</code>:<pre>print("\nAn in-place change can be done by making inplace=True in the drop method\n",'-'*75, sep='')
df.drop('New (Sum of X and Z)', axis=1, inplace=True)
print(df)</pre><p>A sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_12.jpg" alt="Figure 3.12: Output after using the inplace argument" width="799" height="179"/>
				</div>
			</div>
			<h6>Figure 3.12: Output after using the inplace argument</h6>
			<h4>Note</h4>
			<p class="callout">All the normal operations are not in-place, that is, they do not impact the original DataFrame object but return a copy of the original with addition (or deletion). The last bit of code shows how to make a change in the existing DataFrame with the <code>inplace=True</code> argument. Please note that this change is irreversible and should be used with caution.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor117"/>Statistics and Visualization with NumPy and Pandas</h2>
			<p>One of the great advantages of using libraries such as NumPy and pandas is that a plethora of built-in statistical and visualization methods are available, for which we don't have to search for and write new code. Furthermore, most of these subroutines are written using C or Fortran code (and pre-compiled), making them extremely fast to execute.</p>
			<h3 id="_idParaDest-99"><a id="_idTextAnchor118"/>Refresher of Basic Descriptive Statistics (and the Matplotlib Library for Visualization)</h3>
			<p>For any data wrangling task, it is quite useful to extract basic descriptive statistics from the data and create some simple visualizations/plots. These plots are often the first step in identifying fundamental patterns as well as oddities (if present) in the data. In any statistical analysis, descriptive statistics is the first step, followed by inferential statistics, which tries to infer the underlying distribution or process from which the data might have been generated.</p>
			<p>As the inferential statistics are intimately coupled with the machine learning/predictive modeling stage of a data science pipeline, descriptive statistics naturally becomes associated with the data wrangling aspect.</p>
			<p>There are two broad approaches for descriptive statistical analysis:</p>
			<ul>
				<li>Graphical techniques: Bar plots, scatter plots, line charts, box plots, histograms, and so on</li>
				<li>Calculation of central tendency and spread: Mean, median, mode, variance, standard deviation, range, and so on</li>
			</ul>
			<p>In this topic, we will demonstrate how you can accomplish both of these tasks using Python. Apart from NumPy and pandas, we will need to learn the basics of another great package – <strong class="keyword">matplotlib</strong> – which is the most powerful and versatile visualization library in Python.</p>
			<h3 id="_idParaDest-100">Exercise 42:<a id="_idTextAnchor119"/> Introduction to Matplotlib Through a Scatter Plot</h3>
			<p>In this exercise, we will demonstrate the power and simplicity of matplotlib by creating a simple scatter plot from some data about the age, weight, and height of a few people:</p>
			<ol>
				<li value="1">First, we define simple lists of names, age, weight (in kgs), and height (in centimeters):<pre>people = ['Ann','Brandon','Chen','David','Emily','Farook',
          'Gagan','Hamish','Imran','Joseph','Katherine','Lily']
age = [21,12,32,45,37,18,28,52,5,40,48,15]
weight = [55,35,77,68,70,60,72,69,18,65,82,48]
height = [160,135,170,165,173,168,175,159,105,171,155,158]</pre></li>
				<li>Import the most important module from matplotlib, called <code>pyplot</code>:<pre>import matplotlib.pyplot as plt</pre></li>
				<li>Create simple scatter plots of age versus weight:<pre>plt.scatter(age,weight)
plt.show()</pre><p>The output is as follows:</p><div><img src="img/C11065_03_13.jpg" alt="Figure 3.13: A screenshot of a scatter plot containing age and weight" width="496" height="252"/></div><h6>Figure 3.13: A screenshot of a scatter plot containing age and weight</h6><p>The plot can be improved by enlarging the figure size, customizing the aspect ratio, adding a title with a proper font size, adding X-axis and Y-axis labels with a customized font size, adding grid lines, changing the Y-axis limit to be between 0 and 100, adding X and Y-tick marks, customizing the scatter plot's color, and changing the size of the scatter dots.</p></li>
				<li>The code for the improved plot is as follows:<pre>plt.figure(figsize=(8,6))
plt.title("Plot of Age vs. Weight (in kgs)",fontsize=20)
plt.xlabel("Age (years)",fontsize=16)
plt.ylabel("Weight (kgs)",fontsize=16)
plt.grid (True)
plt.ylim(0,100)
plt.xticks([i*5 for i in range(12)],fontsize=15)
plt.yticks(fontsize=15)
plt.scatter(x=age,y=weight,c='orange',s=150,edgecolors='k')
plt.text(x=20,y=85,s="Weights after 18-20 years of age",fontsize=15)
plt.vlines(x=20,ymin=0,ymax=80,linestyles='dashed',color='blue',lw=3)
plt.legend(['Weight in kgs'],loc=2,fontsize=12)
plt.show()</pre><p>The output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_14.jpg" alt="Figure 3.14: A screenshot of a scatter plot showing age versus weight" width="715" height="402"/>
				</div>
			</div>
			<h6>Figure 3.14: A screenshot of a scatter plot showing age versus weight</h6>
			<p>Observe the following:</p>
			<ul>
				<li>A <code>tuple (8,6)</code> is passed as an argument for the figure size.</li>
				<li>A list comprehension is used inside <code>Xticks</code> to create a customized list of 5-10-15-…-55.</li>
				<li>A newline (<code>\n</code>) character is used inside the <code>plt.text()</code> function to break up and distribute the text in two lines.</li>
				<li>The <code>plt.show()</code> function is used at the very end. The idea is to keep on adding various graphics properties (font, color, axis limits, text, legend, grid, and so on) until you are satisfied and then show the plot with one function. The plot will not be displayed without this last function call.</li>
			</ul>
			<h3 id="_idParaDest-101"><a id="_idTextAnchor120"/>Definition of Statistical Measures – Central Tendency and Spread</h3>
			<p>A measure of central tendency is a single value that attempts to describe a set of data by identifying the central position within that set of data. They are also categorized as summary statistics:</p>
			<ul>
				<li><strong class="keyword">Mean</strong>: Mean is the sum of all values divided by the total number of values.</li>
				<li><strong class="keyword">Median</strong>: The median is the middle value. It is the value that splits the dataset in half. To find the median, order your data from smallest to largest, and then find the data point that has an equal amount of values above it and below it.</li>
				<li><strong class="keyword">Mode</strong>: The mode is the value that occurs the most frequently in your dataset. On a bar chart, the mode is the highest bar.</li>
			</ul>
			<p>Generally, the mean is a better measure to use for symmetric data and median is a better measure for data with a skewed (left or right heavy) distribution. For categorical data, you have to use the mode:</p>
			<div><div><img src="img/C11065_03_15.jpg" alt="Figure 3.15: A screenshot of a curve showing the mean, median, and mode" width="928" height="350"/>
				</div>
			</div>
			<h6>Figure 3.15: A screenshot of a curve showing the mean, median, and mode</h6>
			<p>The spread of the data is a measure of by how much the values in the dataset are likely to differ from the mean of the values. If all the values are close together then the spread is low; on the other hand, if some or all of the values differ by a large amount from the mean (and each other), then there is a large spread in the data:</p>
			<ul>
				<li><strong class="keyword">Variance</strong>: This is the most common measure of spread. Variance is the average of the squares of the deviations from the mean. Squaring the deviations ensures that negative and positive deviations do not cancel each other out.</li>
				<li><strong class="keyword">Standard Deviation</strong>: Because variance is produced by squaring the distance from the mean, its unit does not match that of the original data. Standard deviation is a mathematical trick to bring back the parity. It is the positive square root of the variance.</li>
			</ul>
			<h3 id="_idParaDest-102"><a id="_idTextAnchor121"/>Random Variables and Probability Distribution</h3>
			<p>A <strong class="keyword">random variable</strong> is defined as the value of a given variable that represents the outcome of a statistical experiment or process.</p>
			<p>Although it sounds very formal, pretty much everything around us that we can measure can be thought of as a random variable.</p>
			<p>The reason behind this is that almost all natural, social, biological, and physical processes are the final outcome of a large number of complex processes, and we cannot know the details of those fundamental processes. All we can do is observe and measure the final outcome. </p>
			<p>Typical examples of random variables that are around us are as follows:</p>
			<ul>
				<li>The economic output of a nation</li>
				<li>The blood pressure of a patient</li>
				<li>The temperature of a chemical process in a factory</li>
				<li>Number of friends of a person on Facebook</li>
				<li>The stock market price of a company</li>
			</ul>
			<p>These values can take any discrete or continuous value and they follow a particular pattern (although the pattern may vary over time). Therefore, they can all be classified as random variables.</p>
			<h3 id="_idParaDest-103"><a id="_idTextAnchor122"/>What Is a Probability Distribution?</h3>
			<p>A <strong class="keyword">probability distribution</strong> is a function that describes the likelihood of obtaining the possible values that a random variable can assume. In other words, the values of a variable vary based on the underlying probability distribution.</p>
			<p>Suppose you go to a school and measure the heights of students who have been selected randomly. Height is an example of a random variable here. As you measure height, you can create a distribution of height. This type of distribution is useful when you need to know which outcomes are most likely, the spread of potential values, and the likelihood of different results.</p>
			<p>The concepts of central tendency and spread are applicable to a distribution and are used to describe the properties and behavior of a distribution.</p>
			<p>Statisticians generally divide all distributions into two broad categories:</p>
			<ul>
				<li>Discrete distributions</li>
				<li>Continuous distributions</li>
			</ul>
			<h3 id="_idParaDest-104"><a id="_idTextAnchor123"/>Discrete Distributions</h3>
			<p><strong class="keyword">Discrete probability functions</strong> are also known as <strong class="keyword">probability mass functions</strong> and can assume a discrete number of values. For example, coin tosses and counts of events are discrete functions. You can have only heads or tails in a coin toss. Similarly, if you're counting the number of trains that arrive at a station per hour, you can count 11 or 12 trains, but nothing in-between.</p>
			<p>Some prominent discrete distributions are as follows:</p>
			<ul>
				<li><strong class="keyword">Binomial distribution</strong> to model binary data, such as coin tosses</li>
				<li><strong class="keyword">Poisson distribution</strong> to model count data, such as the count of library book checkouts per hour</li>
				<li><strong class="keyword">Uniform distribution</strong> to model multiple events with the same probability, such as rolling a die</li>
			</ul>
			<h3 id="_idParaDest-105"><a id="_idTextAnchor124"/>Continuous Distributions</h3>
			<p><strong class="keyword">Continuous probability functions</strong> are also known as <strong class="keyword">probability density functions</strong>. You have a continuous distribution if the variable can assume an infinite number of values between any two values. Continuous variables are often measurements on a real number scale, such as height, weight, and temperature.</p>
			<p>The most well-known continuous distribution is the <strong class="keyword">normal distribution</strong>, which is also known as the <strong class="keyword">Gaussian distribution</strong> or the <strong class="keyword">bell curve</strong>. This symmetric distribution fits a wide variety of phenomena, such as human height and IQ scores.</p>
			<p>The normal distribution is linked to the famous <strong class="keyword">68-95-99.7 rule</strong>, which describes the percentage of data that falls within 1, 2, or 3 standard deviations away from the mean if the data follows a normal distribution. This means that you can quickly look at some sample data, calculate the mean and standard deviation, and can have a confidence (a statistical measure of uncertainty) that any future incoming data will fall within those <em class="italics">68%-95%-99.7%</em> boundaries. This rule is widely used in industries, medicine, economics, and social science:</p>
			<div><div><img src="img/C11065_03_16.jpg" alt="" width="1800" height="767"/>
				</div>
			</div>
			<h6>Figure 3.16: Curve showing the normal distribution of the famous 68-95-99.7 rule</h6>
			<h3 id="_idParaDest-106"><a id="_idTextAnchor125"/>Data Wrangling in Statistics and Visualization</h3>
			<p>A good data wrangling professional is expected to encounter a dizzying array of diverse data sources each day. As we explained previously, due to a multitude of complex sub-processes and mutual interactions that give rise to such data, they all fall into the category of discrete or continuous random variables.</p>
			<p>It will be extremely difficult and confusing to the data wrangler or data science team if all of this data continues to be treated as completely random and without any shape or pattern. A formal statistical basis must be given to such random data streams, and one of the simplest ways to start that process is to measure their descriptive statistics.</p>
			<p>Assigning a stream of data to a particular distribution function (or a combination of many distributions) is actually part of <strong class="keyword">inferential statistics</strong>. However, inferential statistics starts only when descriptive statistics is done alongside measuring all the important parameters of the pattern of the data.</p>
			<p>Therefore, as the front line of a data science pipeline, data wrangling must deal with measuring and quantifying such descriptive statistics of the incoming data. Along with the formatted and cleaned-up data, the primary job of a data wrangler is to hand over these measures (and sometimes accompanying plots) to the next team member of analytics.</p>
			<p><strong class="keyword">Plotting</strong> and <strong class="keyword">visualization</strong> also help a data wrangling team identify potential outliers and misfits in the incoming data stream and help them to take appropriate action. We will see some examples of such tasks in the next chapter, where we will identify odd data points by creating scatter plots or histograms and either impute or omit the data point.</p>
			<h3 id="_idParaDest-107"><a id="_idTextAnchor126"/>Using NumPy and Pandas to Calculate Basic Descriptive Statistics on the DataFrame</h3>
			<p>Now that we have some basic knowledge of NumPy, pandas, and matplotlib under our belt, we can explore a few additional topics related to these libraries, such as how we can bring them together for advanced data generation, analysis, and visualization.</p>
			<h3 id="_idParaDest-108"><a id="_idTextAnchor127"/>Random Number Generation Using NumPy</h3>
			<p>NumPy offers a dizzying array of random number generation utility functions, all of which correspond to various statistical distributions, such as uniform, binomial, Gaussian normal, Beta/Gamma, and chi-square. Most of these functions are extremely useful and appear countless times in advanced statistical data mining and machine learning tasks. Having a solid knowledge of them is strongly encouraged for all the students taking this book.</p>
			<p>Here, we will discuss three of the most important distributions that may come in handy for data wrangling tasks – uniform, binomial, and gaussian normal. The goal here is to show an example of simple function calls that can generate one or more random numbers/arrays whenever the user needs them.</p>
			<h4>Note</h4>
			<p class="callout">The results will be different for each student when they use these functions as they are supposed to be random.</p>
			<h3 id="_idParaDest-109">Exercise 43: Gen<a id="_idTextAnchor128"/>erating Random Numbers from a Uniform Distribution</h3>
			<p>In this exercise, we will be generating random numbers from a uniform distribution:</p>
			<ol>
				<li value="1">Generate a random integer between <code>1</code> and <code>10</code>:<pre>x = np.random.randint(1,10)
print(x)</pre><p>The sample output is as follows (your output could be different):</p><pre>1</pre></li>
				<li>Generate a random integer between 1 and 10 but with size=1 as an argument. It generates a NumPy array of size 1:<pre>x = np.random.randint(1,10,size=1)
print(x)</pre><p>The sample output is as follows (your output could be different due to random draw):</p><pre>[8]</pre><p>Therefore, we can easily write the code to generate the outcome of a dice being thrown (a normal 6-sided dice) for 10 trials.</p><p>How about moving away from the integers and generating some real numbers? Let's say that we want to generate artificial data for weights (in kgs) of 20 adults and we can measure the accurate weights up to two decimal places.</p></li>
				<li>Generate decimal data using the following command:<pre>x = 50+50*np.random.random(size=15)
x= x.round(decimals=2)
print(x)</pre><p>The sample output is as follows:</p><pre>[56.24 94.67 50.66 94.36 77.37 53.81 61.47 71.13 59.3  65.3  63.02 65.
 58.21 81.21 91.62]</pre><p>We are not only restricted to one-dimensional arrays.</p></li>
				<li>Generate and show a 3x3 matrix with random numbers between <code>0</code> and <code>1</code>:<pre>x = np.random.rand(3,3)
print(x)</pre><p>The sample output is as follows (note that your specific output could be different due to randomness):</p><pre>[[0.99240105 0.9<a id="_idTextAnchor129"/>149215  0.04853315]
 [0.8425871  0.11617792 0.77983995]
 [0.82769081 0.57579771 0.11358125]]</pre></li>
			</ol>
			<h3 id="_idParaDest-110"><a id="_idTextAnchor130"/>Exercise 44: Generating Random Numbers from a Binomial Distribution and Bar Plot</h3>
			<p>A binomial distribution is the probability distribution of getting a specific number of successes in a specific number of trials of an event with a pre-determined chance or probability.</p>
			<p>The most obvious example of this is a coin toss. A fair coin may have an equal chance of heads or tails, but an unfair coin may have more chances of the head coming up or vice versa. We can simulate a coin toss in NumPy in the following manner.</p>
			<p>Suppose we have a biased coin where the probability of heads is <code>0.6</code>. We toss this coin ten times and note down the number of heads turning up each time. That is one trial or experiment. Now, we can repeat this experiment (10 coin tosses) any number of times, say 8 times. Each time, we record the number of heads:</p>
			<ol>
				<li value="1">The experiment can be simulated using the following code:<pre>x = np.random.binomial(10,0.6,size=8)
print(x)</pre><p>The sample output is as follows (note your specific output could be different due to randomness):</p><pre>[6 6 5 6 5 8 4 5]</pre></li>
				<li>Plot the result using a bar chart:<pre>plt.figure(figsize=(7,4))
plt.title("Number of successes in coin toss",fontsize=16)
plt.bar(left=np.arange(1,9),height=x)
plt.xlabel("Experiment number",fontsize=15)
plt.ylabel("Number of successes",fontsize=15)
plt.show()</pre><p>The sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_17.jpg" alt="Figure 3.17: A screenshot of a graph showing the binomial distribution and the bar plot" width="668" height="285"/>
				</div>
			</div>
			<h6>Figure 3.17: A screenshot of a graph showing the binomial distribution and the bar plot</h6>
			<h3 id="_idParaDest-111">Exercise 45: Gene<a id="_idTextAnchor131"/>rating Random Numbers from Normal Distribution and Histograms</h3>
			<p>We discussed the normal distribution in the last topic and mentioned that it is the most important probability distribution because many pieces of natural, social, and biological data follow this pattern closely when the number of samples is large. NumPy provides an easy way to generate random numbers corresponding to this distribution:</p>
			<ol>
				<li value="1">Draw a single sample from a normal distribution by using the following command:<pre>x = np.random.normal()
print(x)</pre><p>The sample output is as follows (note that your specific output could be different due to randomness):</p><pre>-1.2423774071573694</pre><p>We know that normal distribution is characterized by two parameters – mean (µ) and standard deviation (σ). In fact, the default values for this particular function are µ = 0.0 and σ = 1.0.</p><p>Suppose we know that the heights of the teenage (12-16 years) students in a particular school is distributed normally with a mean height of 155 cm and a standard deviation of 10 cm.</p></li>
				<li>Generate a histogram of 100 students by using the following command:<pre># Code to generate the 100 samples (heights)
heights = np.random.normal(loc=155,scale=10,size=100)
# Plotting code
#-----------------------
plt.figure(figsize=(7,5))
plt.hist(heights,color='orange',edgecolor='k')
plt.title("Histogram of teen aged students's height",fontsize=18)
plt.xlabel("Height in cm",fontsize=15)
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
plt.show()</pre><p>The sample output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_18.jpg" alt="" width="836" height="347"/>
				</div>
			</div>
			<h6>Figure 3.18: Histogram of teenage student's height</h6>
			<p>Note the use of the <code>loc</code> parameter for the mean (=155) and the <code>scale</code> parameter for standard deviation (=10). The size parameter is set to 100 for that may samples' generation.</p>
			<h3 id="_idParaDest-112">Exercise 46: Calcu<a id="_idTextAnchor132"/>lation of Descriptive Statistics from a DataFrame</h3>
			<p>Recollect the <code>age</code>, <code>weight</code>, and <code>height</code> parameters that we defined for the plotting exercise. Let's put that data in a DataFrame to calculate various descriptive statistics about them.</p>
			<p>The best part of working with a pandas DataFrame is that it has a built-in utility function to show all of these descriptive statistics with a single line of code. It does this by using the <code>describe</code> method:</p>
			<ol>
				<li value="1">Construct a dictionary with the available series data by using the following command:<pre>people_dict={'People':people,'Age':age,'Weight':weight,'Height':height}
people_df=pd.DataFrame(data=people_dict)
people_df</pre><p>The output is as follows:</p><div><img src="img/C11065_03_19.jpg" alt="" width="645" height="363"/></div><h6>Figure 3.19: Output of the created dictionary</h6></li>
				<li>Find the number of rows and columns of the DataFrame by executing the following command:<pre>print(people_df.shape)</pre><p>The output is as follows:</p><pre>(12, 4)</pre></li>
				<li>Obtain a simple <code>count</code> (any column can be used for this purpose) by executing the following command:<pre>print(people_df['Age'].count())</pre><p>The output is as follows:</p><pre>12</pre></li>
				<li>Calculate the <code>sum</code> total of age by using the following command:<pre>print(people_df['Age'].sum())</pre><p>The output is as follows:</p><pre>353</pre></li>
				<li>Calculate the <code>mean</code> age by using the following command:<pre>print(people_df['Age'].mean())</pre><p>The output is as follows:</p><pre>29.416666666666668</pre></li>
				<li>Calculate the <code>median</code> weight by using the following command:<pre>print(people_df['Weight'].median())</pre><p>The output is as follows:</p><pre>66.5</pre></li>
				<li>Calculate the <code>maximum</code> height by using the following command:<pre>print(people_df['Height'].max())</pre><p>The output is as follows:</p><pre>175</pre></li>
				<li>Calculate the <code>standard deviation</code> of the weights by using the following command:<pre>print(people_df['Weight'].std())</pre><p>The output is as follows:</p><pre>18.45120510148239</pre><p>Note how we are calling the statistical functions directly from a DataFrame object.</p></li>
				<li>To calculate <code>percentile</code>, we can call a function from NumPy and pass on the particular column (a pandas series). For example, to calculate the 75th and 25th percentiles of age distribution and their difference (called the inter-quartile range), use the following code:<pre>pcnt_75 = np.percentile(people_df['Age'],75)
pcnt_25 = np.percentile(people_df['Age'],25)
print("Inter-quartile range: ",pcnt_75-pcnt_25)</pre><p>The output is as follows:</p><pre>Inter-quartile range:  24.0</pre></li>
				<li>Use the <code>describe</code> command to find a detailed description of the DataFrame:<pre>print(people_df.describe())</pre><p>The output is as follows:</p></li>
			</ol>
			<div><div><img src="img/C11065_03_20.jpg" alt="Figure 3.20: Output of the DataFrame using the describe method" width="655" height="196"/>
				</div>
			</div>
			<h6>Figure 3.20: Output of the DataFrame using the describe method</h6>
			<h4>Note</h4>
			<p class="callout">This function works only on the columns where numeric data is present. It has no impact on the non-numeric columns, for example, People in this DataFrame.</p>
			<h3 id="_idParaDest-113">Exercise 47: Built-i<a id="_idTextAnchor133"/>n Plotting Utilities</h3>
			<p>DataFrame also has built-in plotting utilities that wrap around matplotlib functions and create basic plots of numeric data:</p>
			<ol>
				<li value="1">Find the histogram of the weights by using the <code>hist</code> function:<pre>people_df['Weight'].hist()
plt.show()</pre><p>The output is as follows:</p><div><img src="img/Image60813.jpg" alt="Figure 3.21: Histogram of the weights" width="566" height="252"/></div><h6>Figure 3.21: Histogram of the weights</h6></li>
				<li>Create a simple scatter plot directly from the DataFrame to plot the relationship between weight and heights by using the following command:<pre>people_df.plot.scatter('Weight','Height',s=150,
c='orange',edgecolor='k')
plt.grid(True)
plt.title("Weight vs. Height scatter plot",fontsize=18)
plt.xlabel("Weight (in kg)",fontsize=15)
plt.ylabel("Height (in cm)",fontsize=15)
plt.show()</pre><p>The output is as follows:</p></li>
			</ol>
			<div><div><img src="img/Image60822.jpg" alt="" width="660" height="287"/>
				</div>
			</div>
			<h6>Figure 3.22: Weight versus Height scatter plot</h6>
			<h4>Note</h4>
			<p class="callout">You can try regular matplotlib methods around this function call to make your plot pretty.</p>
			<h3 id="_idParaDest-114"><a id="_idTextAnchor134"/>Activity 5: Generating Statistics from a CSV File</h3>
			<p>Suppose you are working with the famous Boston housing price (from 1960) dataset. This dataset is famous in the machine learning community. Many regression problems can be formulated, and machine learning algorithms can be run on this dataset. You will do perform a basic data wrangling activity (including plotting some trends) on this dataset by reading it as a pandas DataFrame.</p>
			<h4>Note</h4>
			<p class="callout">The pandas function for reading a CSV file is <code>read_csv</code>.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Load the necessary libraries.</li>
				<li>Read in the Boston housing dataset (given as a <code>.csv</code> file) from the local directory.</li>
				<li>Check the first 10 records. Find the total number of records.</li>
				<li>Create a smaller DataFrame with columns that do not include <code>CHAS</code>, <code>NOX</code>, <code>B</code>, and <code>LSTAT</code>.</li>
				<li>Check the last seven records of the new DataFrame you just created.</li>
				<li>Plot the histograms of all the variables (columns) in the new DataFrame.</li>
				<li>Plot them all at once using a <code>for</code> loop. Try to add a unique title to a plot.</li>
				<li>Create a scatter plot of crime rate versus price.</li>
				<li>Plot using <code>log10(crime)</code> versus <code>price</code>.</li>
				<li>Calculate some useful statistics, such as mean rooms per dwelling, median age, mean distances to five Boston employment centers, and the percentage of houses with a low price (&lt; $20,000).<h4>Note</h4><p class="callout">The solution for this activity can be found on page 292.</p></li>
			</ol>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor135"/>Summary</h2>
			<p>In this chapter, we started with the basics of NumPy arrays, including how to create them and their essential properties. We discussed and showed how a NumPy array is optimized for vectorized element-wise operations and differs from a regular Python list. Then, we moved on to practicing various operations on NumPy arrays such as indexing, slicing, filtering, and reshaping. We also covered special one-dimensional and two-dimensional arrays, such as zeros, ones, identity matrices, and random arrays.</p>
			<p>In the second major topic of this chapter, we started with pandas series objects and quickly moved on to a critically important object – pandas DataFrames. It is analogous to Excel or MATLAB or a database tab, but with many useful properties for data wrangling. We demonstrated some basic operations on DataFrames, such as indexing, subsetting, row and column addition, and deletion.</p>
			<p>Next, we covered the basics of plotting with matplotlib, the most widely used and popular Python library for visualization. Along with plotting exercises, we touched upon refresher concepts of descriptive statistics (such as central tendency and measure of spread) and probability distributions (such as uniform, binomial, and normal).</p>
			<p>In the next chapter, we will cover more advanced operation with pandas DataFrames that will come in very handy for day-to-day working in a data wrangling job.</p>
		</div>
	</div>



  </body></html>