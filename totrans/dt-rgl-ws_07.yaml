- en: 7\. Advanced Web Scraping and Data Gathering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 高级网络爬虫和数据收集
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to the concepts of advanced web scraping and
    data gathering. It will enable you to use `requests` and `BeautifulSoup` to read
    various web pages and gather data from them. You can perform read operations on
    XML files and the web using an **Application Program Interface** (**API**). You
    can use regex techniques to scrape useful information from a large and messy text
    corpus. By the end of this chapter, you will have learned how to gather data from
    web pages, XML files, and APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍高级网络爬虫和数据收集的概念。它将使您能够使用`requests`和`BeautifulSoup`读取各种网页并从中收集数据。您可以使用**应用程序编程接口**（**API**）对XML文件和网页执行读取操作。您可以使用正则表达式技术从大量杂乱无章的文本语料库中抓取有用信息。到本章结束时，您将学会如何从网页、XML文件和API中收集数据。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter covered how to create a successful data wrangling pipeline.
    In this chapter, we will build a web scraper that can be used by a data wrangling
    professional in their daily tasks using all of the techniques that we have learned
    so far. This chapter builds on the foundation of `BeautifulSoup` and introduces
    various methods for scraping a web page and using an API to gather data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了如何创建一个成功的数据整理管道。在本章中，我们将构建一个网络爬虫，数据整理专业人士可以使用我们迄今为止学到的所有技术在其日常任务中使用。本章建立在`BeautifulSoup`的基础上，并介绍了各种抓取网页和使用API收集数据的方法。
- en: 'In today''s connected world, one of the most valued and widely used skills
    for a data wrangling professional is the ability to extract and read data from
    web pages and databases hosted on the web. Most organizations host data on the
    cloud (public or private), and the majority of web microservices these days provide
    some kind of API for external users to access data. Let''s take a look at the
    following diagram:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今互联的世界中，对于数据整理专业人士来说，最宝贵和最广泛使用的技能之一是能够从托管在网上的网页和数据库中提取和读取数据。大多数组织将数据托管在云端（公共或私有），而如今的大多数网络微服务都为外部用户提供某种API来访问数据。让我们看一下以下图表：
- en: '![Figure 7.1: Data wrangling HTTP request and an XML/JSON reply'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：数据整理HTTP请求和XML/JSON响应'
- en: '](img/B15780_07_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_01.jpg)'
- en: 'Figure 7.1: Data wrangling HTTP request and an XML/JSON reply'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：数据整理HTTP请求和XML/JSON响应
- en: As we can see in the diagram, to fetch data from a web server or a database,
    we initiate `XML/JSON`. It is necessary that, as a data wrangling engineer, you
    know about the structure of web pages and the Python libraries so that you are
    able to extract data from a web page. The **World Wide Web** (**WWW**) is an ever-growing,
    ever-changing universe, where different data exchange protocols and formats are
    used. A few of these are widely used and have become standard.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，要从网络服务器或数据库获取数据，我们需要发起`XML/JSON`请求。作为一名数据整理工程师，了解网页结构和Python库的结构是必要的，这样您才能从网页中提取数据。**万维网**（**WWW**）是一个不断增长、不断变化的宇宙，其中使用了不同的数据交换协议和格式。其中一些被广泛使用，并已成为标准。
- en: Python comes equipped with built-in modules, such as `urllib 3`, which can initiate
    HTTP requests and receive data from the cloud. However, these modules operate
    at a low level and require a deep knowledge of HTTP protocols, encoding, and requests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带内置模块，例如`urllib 3`，可以发起HTTP请求并从云端接收数据。然而，这些模块在低级别操作，需要深入了解HTTP协议、编码和请求。
- en: The Requests and BeautifulSoup Libraries
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Requests和BeautifulSoup库
- en: 'We will take advantage of two Python libraries in this chapter: `requests`
    and `BeautifulSoup`. To avoid dealing with HTTP methods at a lower level, we will
    use the `requests` library. It is an API built on top of pure Python web utility
    libraries, which makes placing HTTP requests easy and intuitive.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将利用两个Python库：`requests`和`BeautifulSoup`。为了避免在较低级别处理HTTP方法，我们将使用`requests`库。它是一个基于纯Python网络实用库的API，这使得发起HTTP请求变得简单直观。
- en: '`BeautifulSoup` is one of the most popular HTML parser packages. It parses
    the HTML content you pass on and builds a detailed tree of all the tags and markup
    within the page for easy and intuitive traversal. This tree can be used by a programmer
    to look for certain markup elements (for example, a table, a hyperlink, or a blob
    of text within a particular `div` ID) to scrape useful data.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeautifulSoup`是最受欢迎的HTML解析包之一。它解析您传递的HTML内容，并在页面上构建一个详细的标签和标记树，以便于直观地遍历。程序员可以使用这个树来查找特定的标记元素（例如，一个表格、一个超链接或特定`div`
    ID内的文本块）以抓取有用的数据。'
- en: We are going to do a couple of exercises in order to demonstrate how to use
    the `requests` library and decode the contents of the response received when data
    is fetched from the server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行几个练习，以展示如何使用 `requests` 库并解码从服务器获取数据时收到的响应内容。
- en: 'Exercise 7.01: Using the Requests Library to Get a Response from the Wikipedia
    Home Page'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：使用 Requests 库从维基百科首页获取响应
- en: 'In this exercise, we will use the `requests` library to extract data from a
    Wikipedia web page. The Wikipedia home page consists of many elements and scripts,
    all of which are a mix of HTML, CSS, and JavaScript code blocks. While reading
    from the home page of Wikipedia ([https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page)),
    the code or markup elements/texts might not be very useful. Therefore, we will
    peel off the layers of HTML/CSS/JavaScript to pry away the information we are
    interested in. Let''s follow these steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `requests` 库从维基百科网页中提取数据。维基百科首页由许多元素和脚本组成，它们是 HTML、CSS 和 JavaScript
    代码块的混合。当从维基百科首页（[https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page)）读取时，代码或标记元素/文本可能不太有用。因此，我们将剥离
    HTML/CSS/JavaScript 层，以获取我们感兴趣的信息。让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and import the `requests` library:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并导入 `requests` 库：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assign the home page URL to a variable, `wiki_home`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将首页 URL 分配给变量 `wiki_home`：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the `get` method from the `requests` library to get a response from this
    page:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `requests` 库的 `get` 方法从该页面获取响应：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To find out more about the `response` object, enter the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解更多关于 `response` 对象的信息，请输入以下代码：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, the output is an object that models the data structure of an
    HTTP response. It is defined in the `requests` library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，输出是一个对象，它模拟了 HTTP 响应的数据结构。它在 `requests` 库中定义。
- en: The web is an extremely dynamic place. For example, it is quite possible that
    the home page of Wikipedia will have changed by the time somebody uses your code,
    or that a particular web server will be not be running and your request will fail.
    If you proceed to write more complex and elaborate code without checking the status
    of your request, then all that subsequent work will be fruitless.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个极其动态的地方。例如，当有人使用您的代码时，维基百科的首页可能已经改变，或者特定的 Web 服务器可能没有运行，您的请求将失败。如果您在未检查请求状态的情况下继续编写更复杂和详尽的代码，那么所有后续的工作都将徒劳无功。
- en: 'A web page request generally comes back with various numeric codes. They are
    the standard HTTP response codes. The following table shows the common codes you
    may encounter:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页请求通常会返回各种数字代码。它们是标准的 HTTP 响应代码。以下表格显示了您可能遇到的常见代码：
- en: '![Figure 7.2: HTTP response codes'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2：HTTP 响应代码'
- en: '](img/B15780_07_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_02.jpg)'
- en: 'Figure 7.2: HTTP response codes'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：HTTP 响应代码
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3d7qmK0.](https://packt.live/3d7qmK0%20)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3d7qmK0.](https://packt.live/3d7qmK0%20)
- en: You can also run this example online at [https://packt.live/3hEKbff](https://packt.live/3hEKbff).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在此在线运行此示例：[https://packt.live/3hEKbff](https://packt.live/3hEKbff)。
- en: In the next exercise, we are going to write a function to check the return code
    and print out messages as needed. These kinds of small helper/utility functions
    are incredibly useful for complex projects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将编写一个函数来检查返回代码，并根据需要打印出消息。这类小型辅助/实用函数对于复杂项目非常有用。
- en: 'Exercise 7.02: Checking the Status of the Web Request'
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：检查 Web 请求状态
- en: 'In this exercise, we will write a small utility function called `status_check`
    to check the status of the response received from the server. Our goal here is
    to check the status code and flag an error/no-error situation by writing a function.
    We will start by getting into the habit of writing small functions to accomplish
    small modular tasks, instead of writing long scripts, which are hard to debug
    and track. Let''s follow these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个名为 `status_check` 的小型实用函数，用于检查从服务器收到的响应状态。我们的目标是编写一个函数来检查状态代码，并通过标记错误/无错误情况。我们将首先养成编写小型函数来完成小型模块化任务的习惯，而不是编写长脚本，因为长脚本难以调试和跟踪。让我们按照以下步骤进行：
- en: 'Open a new Jupyter notebook and create a `status_check` function as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter 笔记本并创建一个 `status_check` 函数，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that, along with printing the appropriate message, we are returning either
    `1` or `-1` from this function. This is important because in the code that utilizes
    this function, we will be able to examine this return value to find out whether
    the request was a success or a failure.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，除了打印适当的消息外，我们从这个函数返回`1`或`-1`。这很重要，因为在利用此函数的代码中，我们将能够检查这个返回值以确定请求是否成功或失败。
- en: 'Import the `requests` library:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`requests`库：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Assign the home page URL to a variable, `wiki_home`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主页URL分配给变量`wiki_home`：
- en: '[PRE8]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the `get` method from the `requests` library to get a response from this page:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`requests`库的`get`方法从这个页面获取响应：
- en: '[PRE9]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Pass the response object to the `status_check` function to examine the status
    of the response:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应对象传递给`status_check`函数以检查响应的状态：
- en: '[PRE10]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3hHcf1k.](https://packt.live/3hHcf1k%20)
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3hHcf1k.](https://packt.live/3hHcf1k%20)。
- en: You can also run this example online at [https://packt.live/3hDUhNp](https://packt.live/3hDUhNp).
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在这个网址上在线运行此示例：[https://packt.live/3hDUhNp](https://packt.live/3hDUhNp)。
- en: In this chapter, for more complex programming activity, we will proceed only
    if we get `1` as the return value of the `status_check` function, that is, we
    will write a conditional statement to check the return value and then execute
    the subsequent code based on it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，对于更复杂的编程活动，我们只有在获得`status_check`函数的返回值为`1`时才会继续进行，也就是说，我们将编写一个条件语句来检查返回值，然后根据它执行后续代码。
- en: Checking the Encoding of a Web Page
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查网页编码
- en: We can also write a utility function to check the encoding of a web page. Various
    encodings are possible with any HTML document, although the most popular is `UTF-8`.
    Some of the most popular encodings are `ASCII`, `Unicode`, and `UTF-8`. `ASCII`
    is the simplest, but it cannot capture the complex symbols used in various spoken
    and written languages all over the world, so `UTF-8` has become the almost universal
    standard in web development these days.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写一个实用函数来检查网页的编码。任何HTML文档都可以使用各种编码，尽管最流行的是`UTF-8`。一些最流行的编码包括`ASCII`、`Unicode`和`UTF-8`。`ASCII`是最简单的，但它无法捕捉到全球各种口语和书面语言中使用的复杂符号，因此`UTF-8`已经成为当今网络开发的几乎通用标准。
- en: 'When we run this function on the Wikipedia home page, we get back the particular
    encoding type that''s used for that page. This function, like the previous one,
    takes the `response` object as an argument and returns a value:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在维基百科主页上运行此函数时，我们会得到该页使用的特定编码类型。这个函数，就像之前的那个函数一样，接受一个`response`对象作为参数，并返回一个值：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Check the response:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 检查响应：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `'UTF-8'` denotes the most popular character encoding scheme that's used
    in the digital medium and on the web today. It employs variable-length encoding
    with `1-4` bytes, thereby representing all Unicode characters in various languages
    around the world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`'UTF-8'`表示目前数字媒体和互联网上使用的最流行的字符编码方案。它采用`1-4`字节的可变长度编码，从而表示世界各种语言的Unicode字符。
- en: 'Exercise 7.03: Decoding the Contents of a Response and Checking Its Length'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：解码响应内容并检查其长度
- en: 'In this exercise, we will create a function to get the Wikipedia page''s contents
    as a blob of text or as a string object that Python can process afterward. We
    will first initiate a request to get the contents of a Wikipedia page and store
    the data in a `response` object. We will then decode this `response` object. To
    do this, follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数来获取维基百科页面的内容作为一个文本块或Python可以后续处理的字符串对象。我们首先发起一个请求以获取维基百科页面的内容，并将数据存储在`response`对象中。然后我们将解码这个`response`对象。为此，请按照以下步骤操作：
- en: 'Open a new Jupyter Notebook and import the `requests` library:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Jupyter Notebook并导入`requests`库：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Assign the home page URL to a variable, `wiki_home`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主页URL分配给变量`wiki_home`：
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `get` method from the `requests` library to get a response from this
    page:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`requests`库的`get`方法从这个页面获取响应：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write a utility function to decode the contents of the response:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用函数来解码响应的内容：
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check the type of the decoded object to see what type of data we are finally
    getting:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查解码对象的类型，以查看我们最终得到的数据类型：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We finally got a string object by reading the HTML page.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们最终通过读取HTML页面得到了一个字符串对象。
- en: 'Check the length of the object using the `len` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `len` 函数检查对象的长度：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This output is variable and is susceptible to change depending on the updates
    made to the Wikipedia web page.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此输出是可变的，并且会根据维基百科网页的更新而变化。
- en: 'Use the following code to print the first `10,000` characters of this string.
    It will look something similar to this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码打印此字符串的前 `10,000` 个字符。它看起来类似于以下内容：
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.3: Partial output showing a mixed blob of HTML markup tags, text,'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.3：部分输出显示包含 HTML 标记标签、文本，'
- en: and element names and properties
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元素名称和属性
- en: '](img/B15780_07_03.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_03.jpg](img/B15780_07_03.jpg)'
- en: 'Figure 7.3: Partial output showing a mixed blob of HTML markup tags, text,
    and element names and properties'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：部分输出显示包含 HTML 标记标签、文本和元素名称及属性的混合块
- en: Obviously, this is a mixed blob of various HTML markup tags, text, and element
    names/properties. We cannot hope to extract meaningful information from this that
    could be used for efficient analysis without using sophisticated functions or
    methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个包含各种 HTML 标记标签、文本和元素名称/属性的混合块。我们无法期望从中提取出有意义的信息，用于高效分析，而不使用复杂的功能或方法。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BfmUQq.](https://packt.live/2BfmUQq%20)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2BfmUQq.](https://packt.live/2BfmUQq%20)
- en: You can also run this example online at [https://packt.live/2UW2L8L](https://packt.live/2UW2L8L).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2UW2L8L](https://packt.live/2UW2L8L) 上运行此示例。
- en: Fortunately, the `BeautifulSoup` library or `bs4` library provides such methods,
    and we will see how to use them in the following exercise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`BeautifulSoup` 库或 `bs4` 库提供了这样的方法，我们将在接下来的练习中看到如何使用它们。
- en: 'Exercise 7.04: Extracting Readable Text from a BeautifulSoup Object'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.04：从 BeautifulSoup 对象中提取可读文本
- en: 'In this exercise, we will create a utility function, `decode_content`, to decode
    the response received after initiating a request to the Wikipedia web page. We
    will use the `BeautifulSoup` library on the `response` object to further process
    it so that it becomes easier for us to extract any meaningful information from
    it. `BeautifulSoup` has a `text` method, which can be used to extract text. Let''s
    follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个实用函数 `decode_content`，用于解码向维基百科网页发起请求后收到的响应。我们将使用 `BeautifulSoup`
    库对 `response` 对象进行进一步处理，使其更容易从中提取任何有意义的信息。`BeautifulSoup` 有一个 `text` 方法，可以用来提取文本。让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and import the `requests` library:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并导入 `requests` 库：
- en: '[PRE24]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assign the home page URL to a variable, `wiki_home`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主页 URL 分配给变量 `wiki_home`：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `get` method from the `requests` library to get a response from this
    page:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `requests` 库的 `get` 方法从该页面获取响应：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Write a utility function to decode the contents of the response:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用函数以解码响应的内容：
- en: '[PRE27]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Import the package and then pass on the whole string (HTML content) to a method
    for parsing:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入包，然后将整个字符串（HTML 内容）传递给解析方法：
- en: '[PRE28]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Execute the following code in your notebook:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的笔记本中执行以下代码：
- en: '[PRE29]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Find the type of the `txt_dmp`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `txt_dmp` 的类型：
- en: '[PRE30]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Find the length of the `txt_dmp`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `txt_dmp` 的长度：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This output is variable and is susceptible to change depending on the updates
    made to the Wikipedia web page.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此输出是可变的，并且会根据维基百科网页的更新而变化。
- en: Now, the length of the text dump is much smaller than the raw HTML string's
    length. This is because the `bs4` library has parsed through the HTML and extracted
    only human-readable text for further processing.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，文本转储的长度比原始 HTML 字符串的长度小得多。这是因为 `bs4` 库已经解析了 HTML 并提取了仅用于进一步处理的可读文本。
- en: 'Print the initial portion of this text:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印此文本的初始部分：
- en: '[PRE34]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will see something similar to the following:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到类似以下的内容：
- en: '![Figure 7.4: Output showing the initial portion of text'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.4：显示文本初始部分的输出'
- en: '](img/B15780_07_04.jpg)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_04.jpg](img/B15780_07_04.jpg)'
- en: 'Figure 7.4: Output showing the initial portion of text'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：显示文本初始部分的输出
- en: In this exercise, we were introduced to the main interface of `BeautifulSoup`
    or `bs4` and we also saw how we can parse a raw string containing HTML and other
    types of data using `bs4` and retain only HTML-related data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们介绍了 `BeautifulSoup` 或 `bs4` 的主要界面，我们还看到了如何使用 `bs4` 解析包含 HTML 和其他类型数据的原始字符串，并仅保留与
    HTML 相关的数据。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Cky5rt.](https://packt.live/2Cky5rt%20)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2Cky5rt.](https://packt.live/2Cky5rt%20)
- en: You can also run this example online at [https://packt.live/2Bj2Xbr](https://packt.live/2Bj2Xbr).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/2Bj2Xbr](https://packt.live/2Bj2Xbr) 上运行此示例。
- en: Web pages are becoming more and more dynamic with more and more diverse types
    of elements and content in them. As a data wrangling engineer, you will have to
    deal with the growing complexity and the heterogeneous nature of data. So, knowing
    what we just saw will often give you a big advantage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 网页正变得越来越动态，其中包含更多不同类型的元素和内容。作为一名数据整理工程师，您将不得不处理不断增长复杂性和数据的异构性。因此，了解我们刚才看到的将经常给您带来很大的优势。
- en: Extracting Text from a Section
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从部分提取文本
- en: 'Now, let''s move on to more exciting data wrangling tasks. If you open the
    Wikipedia home page, [https://en.wikipedia.org/wiki/Main_Page,](https://en.wikipedia.org/wiki/Main_Page)
    you are likely to see a section called `From today''s featured article`. This
    is an excerpt from the day''s featured article, which is randomly selected and
    promoted on the home page. This article can also change throughout the day:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行更令人兴奋的数据整理任务。如果您打开维基百科主页，[https://en.wikipedia.org/wiki/Main_Page,](https://en.wikipedia.org/wiki/Main_Page)
    您可能会看到一个名为 `From today's featured article` 的部分。这是当天特色文章的摘录，它是随机选择并在主页上推广的。这篇文章也可能在一天中发生变化：
- en: '![Figure 7.5: Sample Wikipedia page highlighting the "From today''s featured
    article" section'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.5：突出显示“今天的特色文章”部分的样本维基百科页面'
- en: '](img/B15780_07_05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_05.jpg)'
- en: 'Figure 7.5: Sample Wikipedia page highlighting the "From today''s featured
    article" section'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5：突出显示“今天的特色文章”部分的样本维基百科页面
- en: You need to extract the text from this section. There are several ways to accomplish
    this task. We will go through a simple and intuitive method for doing so here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从这部分提取文本。有几种方法可以完成这个任务。我们将在下面介绍一种简单直观的方法。
- en: 'First, we try to identify two indices – the *start index* and *end index* of
    the line string – which demarcate the start and end of the text we are interested
    in extracting or reading. In the next screenshot, the indices are shown:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试识别两个索引——行字符串的 *起始索引* 和 *结束索引*，这些索引标志着我们想要提取或读取的文本的开始和结束。在下一个屏幕截图中，索引被显示出来：
- en: '![Figure 7.6: Wikipedia page highlighting the text to be extracted'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：突出显示要提取文本的维基百科页面'
- en: '](img/B15780_07_06.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_06.jpg)'
- en: 'Figure 7.6: Wikipedia page highlighting the text to be extracted'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：突出显示要提取文本的维基百科页面
- en: 'The following code accomplishes the extraction:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码完成了提取：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that we have to add the length of the `From today's featured article` string
    to `idx1` and then pass that as the starting index. This is because `idx1` finds
    where the `From today's featured article` string starts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须将 `From today's featured article` 字符串的长度添加到 `idx1` 中，然后将它作为起始索引传递。这是因为
    `idx1` 找到 `From today's featured article` 字符串的起始位置。
- en: 'It prints out something like this (this is a sample output):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它会打印出类似这样的内容（这是一个示例输出）：
- en: '![Figure 7.7: The extracted text'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7：提取的文本'
- en: '](img/B15780_07_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_07.jpg)'
- en: 'Figure 7.7: The extracted text'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：提取的文本
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output you get will vary based on the current featured article.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您得到的输出将根据当前的特色文章而变化。
- en: As you can see, the `BeautifulSoup` library provides an efficient technique
    to read data from a source. It will also be interesting to know the events that
    occurred on a particular day.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`BeautifulSoup` 库提供了一种高效的技术来从源中读取数据。了解特定一天发生的事件也会很有趣。
- en: Extracting Important Historical Events that Happened on Today's Date
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取今天日期发生的重要历史事件
- en: 'Next, we will try to extract the text corresponding to the important historical
    events that happened on today''s date. This can generally be found in the bottom-right
    corner, as shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试提取今天日期发生的重要历史事件的文本。这通常可以在以下截图的右下角找到：
- en: '![Figure 7.8: Wikipedia page highlighting the On this day section'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8：突出显示“这一天”部分的维基百科页面'
- en: '](img/B15780_07_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_08.jpg)'
- en: 'Figure 7.8: Wikipedia page highlighting the On this day section'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：突出显示“这一天”部分的维基百科页面
- en: 'So, can we apply the same technique as we did for `From today''s featured article`?
    Apparently not, because there is text just below where we want our extraction
    to end, which is not fixed, unlike in the previous case. Note that, in the previous
    section, the fixed string `Recently featured` occurs at the exact place where
    we want the extraction to stop, so we could use it in our code. However, we cannot
    do that in this case, and the reason for this is illustrated in the following
    screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能否应用我们在“从今天的特色文章”中使用的相同技术？显然不行，因为在我们想要提取结束的地方下面有文本，这与之前的情况不同。注意，在前一节中，固定的字符串“最近特色”出现在我们想要提取停止的确切位置，因此我们可以将其用于我们的代码中。然而，在这种情况下我们不能这样做，原因如下面的截图所示：
- en: '![Figure 7.9: Wikipedia page highlighting the text to be extracted'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：维基百科页面突出显示要提取的文本'
- en: '](img/B15780_07_09.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_09.jpg)'
- en: 'Figure 7.9: Wikipedia page highlighting the text to be extracted'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：维基百科页面突出显示要提取的文本
- en: 'So, in this section, we just want to find out what the text looks like around
    the main content we are interested in. For that, we must find out the start of
    the `On this day` string and print out the next 1,000 characters using the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在本节中，我们只想找出围绕我们感兴趣的主要内容的文本看起来是什么样子。为此，我们必须找出“On this day”字符串的起始位置，并使用以下代码打印出接下来的1,000个字符：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 7.10: Output of the On this day section from Wikipedia'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：维基百科“这一天”部分的输出'
- en: '](img/B15780_07_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_10.jpg)'
- en: 'Figure 7.10: Output of the On this day section from Wikipedia'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：维基百科“这一天”部分的输出
- en: As we can see, there is a bit of unwanted data along with the relevant information
    that we are really interested in reading (as shown by the arrows). To address
    this issue, we need to think differently and use some other methods apart from
    `BeautifulSoup` (and write another utility function).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，除了我们真正感兴趣阅读的相关信息外，还有一些不必要的数据（如箭头所示）。为了解决这个问题，我们需要换一种思维方式，并使用一些除了`BeautifulSoup`之外的其他方法（并编写另一个实用函数）。
- en: HTML pages are made of many markup tags, such as `<div>`, which denotes a division
    of text/images, and `<ul>`, which denotes lists. In the following exercise, we'll
    use advanced techniques from the `BeautifulSoup` library to extract relevant information
    from a web page.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面由许多标记标签组成，例如`<div>`，表示文本/图像的分区，以及`<ul>`，表示列表。在接下来的练习中，我们将使用`BeautifulSoup`库的高级技术从网页中提取相关信息。
- en: 'Exercise 7.05: Using Advanced BS4 Techniques to Extract Relevant Text'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.05：使用高级BS4技术提取相关文本
- en: 'In this exercise, we''ll take advantage of `BeautifulSoup` library techniques
    and extract the element that contains the text we are interested in. Let''s perform
    the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用`BeautifulSoup`库的技术，提取包含我们感兴趣文本的元素。让我们执行以下步骤：
- en: 'Open the Wikipedia page using this link: [https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page).'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此链接打开维基百科页面：[https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page)。
- en: 'In the Mozilla Firefox browser, right-click and select the `Inspect Element`
    option (in Chrome, we do the same, except the menu option is called `Inspect`)
    as shown in the following screenshot:![Figure 7.11: Inspecting elements on Wikipedia'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mozilla Firefox浏览器中，右键单击并选择“检查元素”选项（在Chrome中，我们做同样的事情，只是菜单选项称为“检查”），如下面的截图所示：![图7.11：检查维基百科上的元素
- en: '](img/B15780_07_11.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_07_11.jpg)'
- en: 'Figure 7.11: Inspecting elements on Wikipedia'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.11：检查维基百科上的元素
- en: 'As you hover over this with the mouse, you will see different portions of the
    page being highlighted. By doing this, it is easy to find out which precise block
    of markup text is responsible for the textual information we are interested in.
    Here, we can see that a certain `<ul>` block contains the text:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你用鼠标悬停在这个上面时，你会看到页面上的不同部分被突出显示。通过这样做，很容易找出哪个精确的标记文本块是我们感兴趣的文本信息所负责的。在这里，我们可以看到某个`<ul>`块包含以下文本：
- en: '![Figure 7.12: Identifying the HTML block that contains the text we are interested
    in'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.12：识别包含我们感兴趣文本的HTML块'
- en: '](img/B15780_07_12.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_07_12.jpg)'
- en: 'Figure 7.12: Identifying the HTML block that contains the text we are interested
    in'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.12：识别包含我们感兴趣文本的HTML块
- en: 'Now, it is prudent to find the `<div>` tag that contains this `<ul>` block
    within it. By looking around the same screen as before, we can find the `<div>`
    and its `ID`:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，找到包含此`<ul>`块的`<div>`标签是明智的。通过查看与之前相同的屏幕，我们可以找到`<div>`及其`ID`：
- en: '![Figure 7.13: The <ul> tag containing the text'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.13：包含文本的<ul>标签'
- en: '](img/B15780_07_13.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_13.jpg](img/B15780_07_13.jpg)'
- en: 'Figure 7.13: The <ul> tag containing the text'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.13：包含文本的<ul>标签
- en: We can do similar things using `bs4` functions.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`bs4`函数做类似的事情。
- en: Start off by importing `requests` and `BeautifulSoup`. Also, retrieve the contents
    of the Wikipedia Main Page (highlighted).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入`requests`和`BeautifulSoup`。同时，检索维基百科主页的内容（高亮显示）。
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `find_all` method from `BeautifulSoup`, which scans all the tags of
    the HTML page (and their sub-elements) to find and extract the text associated
    with this particular `<div>` element. Create an empty list and append the text
    from the `NavigableString` class to this list as we traverse the page:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BeautifulSoup`的`find_all`方法，该方法扫描HTML页面的所有标签（及其子元素）以找到并提取与这个特定的`<div>`元素相关的文本。创建一个空列表，并在遍历页面时将`NavigableString`类的文本追加到这个列表中：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `find_all` method returns a `NavigableString` class, which has a useful
    `text` method associated with it for extraction. Note how we are utilizing the
    `mp-otd` ID of the `<div>` element to identify it among tens of other `<div>`
    elements. Now, if we examine the `text_list` list, we will see that it has three
    elements.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`find_all`方法返回一个`NavigableString`类，它与一个有用的`text`方法相关联，用于提取。注意我们是如何利用`<div>`元素的`mp-otd`
    ID来在数十个其他`<div>`元素中识别它的。现在，如果我们检查`text_list`列表，我们会看到它有三个元素。'
- en: 'Print the elements separated by a marker. We will see that the text we are
    interested in appears as the first element:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按标记分隔元素。我们会看到我们感兴趣的文本作为第一个元素出现：
- en: '[PRE39]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.14: The text highlighted'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：高亮显示的文本'
- en: '](img/B15780_07_14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_07_14.jpg](img/B15780_07_14.jpg)'
- en: 'Figure 7.14: The text highlighted'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：高亮显示的文本
- en: As we can see, it is the first element of the list that we are interested in.
    However, the exact position will depend on the web page. In this exercise, we
    were introduced to some advanced uses of `BeautifulSoup` and saw how we can extract
    meaningful information using its APIs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这是我们感兴趣列表的第一个元素。然而，确切的位臵将取决于网页。在这个练习中，我们介绍了一些`BeautifulSoup`的高级用法，并看到了我们如何使用其API提取有意义的信息。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2USTDSg.](https://packt.live/2USTDSg%20)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2USTDSg.](https://packt.live/2USTDSg%20)
- en: You can also run this example online at [https://packt.live/2zGIUTG](https://packt.live/2zGIUTG).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2zGIUTG](https://packt.live/2zGIUTG)在线运行此示例。
- en: Next, we will create a compact function to encapsulate some of those. Creating
    such functions helps us to increase the reusability of code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个紧凑的函数来封装其中的一些。创建这样的函数有助于我们提高代码的可重用性。
- en: As we discussed before, it is always good to try to functionalize specific tasks,
    particularly in a web-scraping application. In the following exercise, we are
    going to create a compact function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，尝试将特定任务功能化总是好的，尤其是在网络爬虫应用程序中。在接下来的练习中，我们将创建一个紧凑的函数。
- en: 'Exercise 7.06: Creating a Compact Function to Extract the On this day Text
    from the Wikipedia Home Page'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.06：创建一个紧凑的函数，从维基百科主页提取“On this day”文本
- en: 'In this exercise, we are going to create a function that will take the Wikipedia
    URL (as a string), [https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page),
    and return the text corresponding to the `On this day` section. The benefit of
    a functional approach is that you can call this function from any Python script
    and use it anywhere in another program as a standalone module. To do this, let''s
    follow these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，该函数将接受维基百科URL（作为字符串），[https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page)，并返回对应于“On
    this day”部分的文本。函数式方法的好处是您可以从任何Python脚本中调用此函数，并在另一个程序中的任何地方将其用作独立模块。为此，让我们遵循以下步骤：
- en: 'Create the compact `def` function. Extract the text from the `On this day`
    section of the Wikipedia home page, [https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page).
    Accept the Wikipedia home page URL as a string. A default URL is provided:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建紧凑的`def`函数。从维基百科主页的“On this day”部分提取文本，[https://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page)。接受维基百科主页URL作为字符串。提供了一个默认的URL：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a function that will check the status of the response received from
    the web page:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于检查从网页收到的响应状态：
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a `BeautifulSoup` object and read the contents of the web page:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`BeautifulSoup`对象并读取网页内容：
- en: '[PRE42]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let's see the function in action.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这个函数的实际效果。
- en: '[PRE43]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output will be:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '![Figure 7.15: Output of wiki_on_this_day'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.15：wiki_on_this_day的输出'
- en: '](img/B15780_07_15.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15780_07_15.jpg)'
- en: 'Figure 7.15: Output of wiki_on_this_day'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.15：wiki_on_this_day的输出
- en: 'Note how this function utilizes the status check and prints out an error message
    if the request failed. When we test this function with an intentionally incorrect
    URL, it behaves as expected:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这个函数如何利用状态检查，如果请求失败则打印出错误信息。当我们用故意错误的URL测试这个函数时，它表现得如预期：
- en: '[PRE44]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this exercise, we saw how to write a function to encapsulate a lot of important
    things that we have learned about `BeautifulSoup`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何编写一个函数来封装我们关于`BeautifulSoup`学到的许多重要内容。
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YcaEJm.](https://packt.live/2YcaEJm%20)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YcaEJm](https://packt.live/2YcaEJm)。
- en: You can also run this example online at [https://packt.live/3hBS2dn](https://packt.live/3hBS2dn).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hBS2dn](https://packt.live/3hBS2dn)上在线运行此示例。
- en: Reading Data from XML
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从XML读取数据
- en: '**XML** or **Extensible Markup Language** is a web markup language that''s
    similar to HTML but with significant flexibility (on the part of the user) built
    in, such as the ability to define your own tags. It was one of the most hyped
    technologies in the 1990s and early 2000s. It is a meta-language, that is, a language
    that allows us to define other languages using its mechanics, such as RSS and
    MathML (a mathematical markup language widely used for web publication and the
    display of math-heavy technical information). XML is also heavily used in regular
    data exchanges over the web, and as a data wrangling professional, you should
    have enough familiarity with its basic features to tap into the data flow pipeline
    whenever you need to extract data for your project.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML**或**可扩展标记语言**是一种类似于HTML但具有显著灵活性的网络标记语言（用户方面），例如能够定义自己的标签。它是20世纪90年代和21世纪初最被炒作的技术之一。它是一种元语言，也就是说，一种允许我们使用其机制定义其他语言的语言，例如RSS和MathML（一种广泛用于网络发布和显示数学密集型技术信息的数学标记语言）。XML在互联网上的常规数据交换中也得到了广泛使用，作为一名数据整理专业人士，你应该对其基本特性有足够的了解，以便在需要为项目提取数据时随时访问数据流管道。'
- en: 'Exercise 7.07: Creating an XML File and Reading XML Element Objects'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.07：创建XML文件和读取XML元素对象
- en: 'In this exercise, we''ll create some random data and store it in XML format.
    We''ll then read from the XML file and examine the XML-formatted data string.
    Let''s follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一些随机数据并将其以XML格式存储。然后我们将从XML文件中读取并检查XML格式的数据字符串。让我们按照以下步骤进行：
- en: 'Create an XML file using the following command:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个XML文件：
- en: '[PRE46]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can see, the `phone` type is a triple-quoted string or multiline string.
    If you print this object, you will get the following output. This is an XML-formatted
    data string in a tree structure, as we will see when we parse the structure and
    break apart the individual parts.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，`phone`类型是一个三引号字符串或多行字符串。如果你打印这个对象，你会得到以下输出。这是一个树结构的XML格式数据字符串，正如我们将在解析结构和分解各个部分时看到的那样。
- en: 'To process and wrangle with the data, we have to read it as an `Element` object
    using the Python XML parser engine:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理和整理数据，我们必须使用Python XML解析器引擎将其读取为`Element`对象：
- en: '[PRE47]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is as follows:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE48]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this exercise, we saw how to create an XML file, how to read an XML file,
    and what kind of object we can expect when we read an XML file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何创建一个XML文件，如何读取一个XML文件，以及当我们读取一个XML文件时可以期待什么样的对象。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37EDwgt.](https://packt.live/37EDwgt%20)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/37EDwgt](https://packt.live/37EDwgt)。
- en: You can also run this example online at [https://packt.live/3hDwUDv](https://packt.live/3hDwUDv).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hDwUDv](https://packt.live/3hDwUDv)上在线运行此示例。
- en: 'Exercise 7.08: Finding Various Elements of Data within a Tree (Element)'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.08：在树（元素）中查找各种数据元素
- en: 'In this exercise, we will use the `find` method to search for various pieces
    of useful data within an XML element object and print them using the `text` method.
    We will also use the `get` method to extract the specific attribute we want. To
    do so, let''s follow these steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`find`方法在XML元素对象中搜索各种有用的数据，并使用`text`方法打印它们。我们还将使用`get`方法提取我们想要的特定属性。为此，让我们按照以下步骤进行：
- en: 'Create an XML file using the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建XML文件：
- en: '[PRE49]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To process and wrangle with the data, we have to read it as an `Element` object
    using the Python XML parser engine:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理和整理数据，我们必须使用Python XML解析器引擎将其读取为`Element`对象：
- en: '[PRE50]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `find` method to find `Name`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Name`：
- en: '[PRE51]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE52]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use the `find` method to find `Surname`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Surname`：
- en: '[PRE53]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE54]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Use the `find` method to find `Phone`. Note the use of the `strip` method to
    strip away any trailing spaces/blanks:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`Phone`。注意使用`strip`方法去除任何尾随空格/空白：
- en: '[PRE55]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output will be as follows:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE56]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the `find` method to find `email status` and `actual email`. Note the use
    of the `get` method to extract the status:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`find`方法查找`email status`和`actual email`。注意使用`get`方法提取状态：
- en: '[PRE57]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output will be as follows:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE58]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this exercise, we saw how we can use the `find` method to read the relevant
    information from an XML file. XML is a very diverse format of expressing data.
    Apart from following some ground rules, everything else is customizable in an
    XML document. In this exercise, we saw how to access a custom XML element and
    extract data from it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用`find`方法从XML文件中读取相关信息。XML是一种非常多样化的数据表示格式。除了遵循一些基本规则外，XML文档中的其他内容都是可定制的。在这个练习中，我们看到了如何访问自定义XML元素并从中提取数据。
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dgSoTf.](https://packt.live/3dgSoTf%20)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取本节的源代码，请参阅[https://packt.live/3dgSoTf](https://packt.live/3dgSoTf)。
- en: You can also run this example online at [https://packt.live/2CjDnU9](https://packt.live/2CjDnU9).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2CjDnU9](https://packt.live/2CjDnU9)上运行此示例。
- en: Reading from a Local XML File into an ElementTree Object
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地XML文件读取到ElementTree对象
- en: We can also read from an XML file saved locally on disk. This is a fairly common
    situation where a frontend web scraping module has already downloaded a lot of
    XML files by reading a table of data on the web and the data wrangler needs to
    parse through this XML file to extract meaningful pieces of numerical and textual
    data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从本地磁盘上保存的XML文件中读取。这是一种相当常见的情况，即前端网络爬虫模块已经通过读取网络上的数据表下载了大量XML文件，而数据处理员需要解析这个XML文件以提取有意义的数值和文本数据。
- en: 'We have a file associated with this chapter called `xml1.xml`. The file can
    be found here: [https://packt.live/3e8jM7n](https://packt.live/3e8jM7n).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章相关联的文件名为`xml1.xml`。文件可在此处找到：[https://packt.live/3e8jM7n](https://packt.live/3e8jM7n)。
- en: 'Please make sure you have the file in the same directory that you are running
    your Jupyter notebook from:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您有文件在您运行Jupyter笔记本的同一目录中：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output will be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note how we use the `parse` method to read this XML file. This is slightly different
    than using the `fromstring` method used in the previous exercise, where we were
    directly reading from a `string` object. This produces an `ElementTree` object
    instead of a simple `Element`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`parse`方法读取此XML文件。这与之前练习中使用的`fromstring`方法略有不同，当时我们直接从`string`对象中读取。这产生了一个`ElementTree`对象而不是简单的`Element`。
- en: 'The idea of building a tree-like object is the same as in the domains of computer
    science and programming. Let''s take a look at the following diagram:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 构建树形对象的想法与计算机科学和编程领域相同。让我们看看以下图表：
- en: '![Figure 7.16: Tree-like children nodes'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.16：树形子节点'
- en: '](img/B15780_07_16.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_16.jpg](img/B15780_07_16.jpg)'
- en: 'Figure 7.16: Tree-like children nodes'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16：树形子节点
- en: 'In the preceding diagram, we can see the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到以下内容：
- en: There is a root.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个根节点。
- en: There are child objects attached to the root.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根节点下有子节点。
- en: There could be multiple levels, that is, children of children, recursively going
    down.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在多个级别，即子节点的子节点，递归地向下。
- en: All of the nodes of the tree (root and children alike) have attributes attached
    to them that contain data.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树中的所有节点（包括根节点和子节点）都附加有包含数据的属性。
- en: Tree traversal algorithms can be used to search for a particular attribute.
    If provided, special methods can be used to probe a node more deeply.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 树遍历算法可以用来搜索特定的属性。如果提供，可以使用特殊方法更深入地探测节点。
- en: 'Every node in the XML tree has tags and attributes. The idea is as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每个XML树节点都有标签和属性。其想法如下：
- en: '![Figure 7.17: Finding the root and child nodes of an XML tag'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.17：查找XML标签的根节点和子节点'
- en: '](img/B15780_07_17.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_17.jpg](img/B15780_07_17.jpg)'
- en: 'Figure 7.17: Finding the root and child nodes of an XML tag'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17：找到 XML 标签的根节点和子节点
- en: As the document is organized in a tree fashion, we can use a tree traversal
    algorithm to go through it and visit all the children, starting at the root.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档以树的形式组织，我们可以使用树遍历算法遍历它并访问所有子节点，从根节点开始。
- en: 'Exercise 7.09: Traversing the Tree, Finding the Root, and Exploring All the
    Child Nodes and Their Tags and Attributes'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.09：遍历树，找到根节点，并探索所有子节点及其标签和属性
- en: In this exercise, we will use the tree traversal algorithm to traverse a tree,
    find the root, and explore all the child nodes. We will first define a variable
    called `tree2`, which will contain the contents of the `xml1.xml` file. Then,
    we will use a `for` loop to traverse through this XML document tree.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用树遍历算法来遍历树，找到根节点，并探索所有子节点。我们首先定义一个名为 `tree2` 的变量，它将包含 `xml1.xml`
    文件的内容。然后，我们将使用一个 `for` 循环遍历这个 XML 文档树。
- en: 'The XML file can be found here: [https://packt.live/3e8jM7n](https://packt.live/3e8jM7n).
    Follow these steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: XML 文件可以在以下位置找到：[https://packt.live/3e8jM7n](https://packt.live/3e8jM7n)。按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and define the tree:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并定义树：
- en: '[PRE61]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Explore these tags and attributes using the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码探索这些标签和属性：
- en: '[PRE62]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output will be as follows:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 7.18: The output showing the extracted XML tags'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.18：显示提取的 XML 标签的输出'
- en: '](img/B15780_07_18.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15780_07_18.jpg)'
- en: 'Figure 7.18: The output showing the extracted XML tags'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18：显示提取的 XML 标签的输出
- en: In this exercise, we saw how to traverse an XML document tree.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何遍历 XML 文档树。
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AEgqe1.](https://packt.live/2AEgqe1%20)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2AEgqe1.](https://packt.live/2AEgqe1%20)
- en: You can also run this example online at [https://packt.live/3ebu5re](https://packt.live/3ebu5re).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/3ebu5re](https://packt.live/3ebu5re) 上运行此示例。
- en: Remember that every XML data file could follow a different naming or structural
    format, but using an element tree approach puts the data into a somewhat structured
    flow that can be explored systematically. Still, it is best to examine the raw
    XML file structure once and understand (even if at a high level) the data format
    before attempting automatic extractions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个 XML 数据文件可能遵循不同的命名或结构格式，但使用元素树方法将数据放入一种结构化的流程中，可以系统地探索。然而，最好在尝试自动提取之前先检查原始
    XML 文件结构一次，并理解（即使是在高层次上）数据格式。
- en: In the following exercise, we will see how to extract relevant information from
    a tree.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将看到如何从树中提取相关信息。
- en: 'Exercise 7.10: Using the text Method to Extract Meaningful Data'
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.10：使用文本方法提取有意义的数据
- en: 'In this exercise, we will be using the `text` method from the `BeautifulSoup`
    library to extract different types of data from a particular node of the XML document
    tree. We can almost think of the XML tree as a **list of lists** and index it
    accordingly. Let''s follow these steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `text` 方法从 `BeautifulSoup` 库中提取 XML 文档树特定节点的不同类型的数据。我们可以几乎将 XML
    树视为一个 **列表的列表** 并相应地进行索引。让我们按照以下步骤进行：
- en: 'Open a new Jupyter Notebook and define the tree:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Jupyter Notebook 并定义树：
- en: '[PRE63]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Explore these tags and attributes using the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码探索这些标签和属性：
- en: '[PRE64]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Access the `root[0][2]` element by using the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码通过 `root[0][2]` 元素访问：
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output will be as follows:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE66]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: So, this points to the `gdppc` piece of data. Here, `gdppc` is the tag and the
    actual GDP/per capita data is attached to this tag.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，这指向了 `gdppc` 数据片段。在这里，`gdppc` 是标签，实际的人均 GDP 数据附加到这个标签上。
- en: 'Use the `text` method to access the data:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `text` 方法访问数据：
- en: '[PRE67]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The output will be as follows:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE68]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the `tag` method to access `gdppc`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tag` 方法访问 `gdppc`：
- en: '[PRE69]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output will be as follows:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE70]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Check `root[0]`:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `root[0]`：
- en: '[PRE71]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output will be as follows:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE72]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Check the tag:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查标签：
- en: '[PRE73]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output will be as follows:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE74]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can use the `attrib` method to access it:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `attrib` 方法来访问它：
- en: '[PRE75]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output will be as follows:'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE76]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So, `root[0]` is again an element, but it has a different set of tags and attributes
    than `root[0][2]`. This is expected because they are all part of the tree as nodes,
    but each is associated with a different level of data.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，`root[0]` 仍然是一个元素，但它与 `root[0][2]` 的标签和属性集合不同。这是预期的，因为它们都是树的节点的一部分，但每个节点都与不同级别的数据相关联。
- en: In this exercise, we saw how to access a particular node in an XML document
    and how to get the data, attributes, and other related things from it. This knowledge
    is very valuable as a lot of data is still presented and exchanged in XML format.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何访问 XML 文档中的特定节点，以及如何从中获取数据、属性和其他相关内容。这种知识非常有价值，因为大量的数据仍然以 XML
    格式呈现和交换。
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3ee0mhl.](https://packt.live/3ee0mhl%20)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3ee0mhl.](https://packt.live/3ee0mhl%20)
- en: You can also run this example online at [https://packt.live/2YMqbyz](https://packt.live/2YMqbyz).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2YMqbyz](https://packt.live/2YMqbyz) 上运行此示例。
- en: This last piece of code output is interesting because it returns a dictionary
    object. Therefore, we can just index it by its keys. We will do that in the next
    exercise.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后输出很有趣，因为它返回了一个字典对象。因此，我们可以通过其键来索引它。我们将在下一个练习中这样做。
- en: Extracting and Printing the GDP/Per Capita Information Using a Loop
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用循环提取和打印 GDP/人均信息
- en: 'Now that we know how to read the GDP/per capita data and how to get a dictionary
    back from the tree, we can easily construct a simple dataset by running a loop
    over the tree:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何读取 GDP/人均数据以及如何从树中获取字典，我们可以通过在树上运行循环来轻松构建一个简单的数据集：
- en: '[PRE77]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can put these in a DataFrame or a CSV file to be saved to a local disk for
    further processing, such as a simple plot.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些内容放入一个 DataFrame 或 CSV 文件中，然后保存到本地磁盘以进行进一步处理，例如简单的绘图。
- en: Finding All the Neighboring Countries for Each Country and Printing Them
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个国家找到所有邻近国家并打印它们
- en: There are efficient search algorithms for tree structures, and one such method
    for XML trees is `findall`. We can use this, for this example, to find all the
    neighbors a country has and print them out.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于树结构，存在高效的搜索算法，其中一种针对 XML 树的方法是 `findall`。我们可以使用这个方法，在这个例子中，找到某个国家所有的邻近国家并将它们打印出来。
- en: 'Why do we need to use `findall` instead of `find`? Well, because not all countries
    have an equal number of neighbors and `findall` searches for all the data with
    that tag that is associated with a particular node, and we want to traverse all
    of them:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要使用 `findall` 而不是 `find`？嗯，因为并非所有国家都有相同数量的邻近国家，`findall` 搜索与特定节点关联的具有该标签的所有数据，而我们想要遍历所有这些：
- en: '[PRE79]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output looks something like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来可能像这样：
- en: '![Figure 7.19: The output that''s generated by using findall'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.19：使用 findall 生成的输出'
- en: '](img/B15780_07_19.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_07_19.jpg](img/B15780_07_19.jpg)'
- en: 'Figure 7.19: The output that''s generated by using findall'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19：使用 findall 生成的输出
- en: In this section, we have looked into how to use specific search algorithms in
    the form of pre-defined functions to traverse through an XML document and get
    interesting data from the nodes we visit.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用预定义函数的形式的特定搜索算法来遍历 XML 文档，并从我们访问的节点中获取有趣的数据。
- en: In the previous topic of this chapter, we learned about simple web scraping
    using the `requests` library. So far, we have worked with static XML data, that
    is, data from a local file or a string object we've scripted. Now, it is time
    to combine our learning and read XML data directly over the internet (as you are
    expected to do almost all the time).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一个主题中，我们学习了如何使用 `requests` 库进行简单的网络爬取。到目前为止，我们一直在处理静态 XML 数据，即来自本地文件或我们编写的字符串对象的数据。现在，是时候结合我们的学习，直接从互联网上读取
    XML 数据了（正如你预期的那样，几乎所有的数据都是这样处理的）。
- en: 'Exercise 7.11: A Simple Demo of Using XML Data Obtained by Web Scraping'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.11：使用网络爬取获得的 XML 数据的简单演示
- en: 'In this exercise, we will obtain XML data using web scraping. We will read
    a cooking recipe from a website called [http://www.recipepuppy.com/](http://www.recipepuppy.com/),
    which contains aggregates links of various other sites with the recipe. Next,
    we will use the `find` method to extract the appropriate attribute from the XML
    file and display the relevant content. Let''s follow these steps:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用网络爬取获取 XML 数据。我们将从一个名为 [http://www.recipepuppy.com/](http://www.recipepuppy.com/)
    的网站上读取烹饪食谱，该网站包含各种其他网站的食谱聚合链接。接下来，我们将使用 `find` 方法从 XML 文件中提取适当的属性并显示相关内容。让我们按照以下步骤进行：
- en: 'Import the necessary libraries:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE80]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Read from the [http://www.recipepuppy.com/](http://www.recipepuppy.com/) website:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 [http://www.recipepuppy.com/](http://www.recipepuppy.com/) 网站读取：
- en: '[PRE81]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This code will ask the user for input. You have to enter the name of a food
    item: ''`chicken tikka`''.'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将要求用户输入。你必须输入一个食品项目的名称：`chicken tikka`。
- en: 'You will get the following output:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE82]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If we print the last variable, `data`, we may see that it is a mix of a legitimate
    XML document and some junk HTML appended to it. We need to first check if that
    is the case.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们打印最后一个变量`data`，我们可能会看到它是一个合法的XML文档和一些附加的垃圾HTML的混合体。我们需要首先检查这是否是这种情况。
- en: 'Use the `find` method from Python. As `data` is a string, we can simply do
    the following:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python的`find`方法。由于`data`是一个字符串，我们可以简单地这样做：
- en: '[PRE83]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This should return an integer if that string is found in `data`. Otherwise,
    it will return `–1`. If we get a positive integer, then we know – thanks to Python's
    `find` method – it is the start index of the string we are searching.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在`data`中找到该字符串，则应返回一个整数。否则，它将返回`–1`。如果我们得到一个正整数，那么我们知道——多亏了Python的`find`方法——它是我们正在搜索的字符串的起始索引。
- en: 'Get only the XML part using a piece of code like the following:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用如下代码片段仅获取XML部分：
- en: '[PRE84]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: However, if we do not get a positive integer, then we assume that the whole
    return text is valid XML and we simply set the `end_marker` as the total length
    of the string. Although, it is always good practice to print the raw data and
    check whether it is pure XML or some junk added with it.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果我们没有得到一个正整数，那么我们假设整个返回文本是有效的XML，我们只需将`end_marker`设置为字符串的总长度。尽管如此，始终打印原始数据并检查它是否是纯XML或其中添加了一些垃圾数据是个好习惯。
- en: 'Write the code to get back data in XML format and read and decode it before
    creating an XML tree out of it:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以获取XML格式的数据，并在创建XML树之前读取和解析它：
- en: '[PRE85]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we can use another useful method, called `iter`, which basically iterates
    over the nodes under an element. If we traverse the tree and extract the text,
    we get the following output:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用另一个有用的方法，称为`iter`，它基本上遍历一个元素下的节点。如果我们遍历树并提取文本，我们将得到以下输出：
- en: '[PRE86]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 7.20: The output that''s generated by using iter'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.20：使用iter生成的输出]'
- en: '](img/B15780_07_20.jpg)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_07_20.jpg)'
- en: 'Figure 7.20: The output that''s generated by using iter'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.20：使用iter生成的输出
- en: We can use the `find` method to search for the appropriate attribute and extract
    its content. This is the reason it is important to scan through the XML data manually
    and check what attributes are used. Remember, this means scanning the raw string
    data, not the tree structure.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用`find`方法来搜索适当的属性并提取其内容。这就是为什么手动扫描XML数据并检查使用了哪些属性很重要的原因。记住，这意味着扫描原始字符串数据，而不是树结构。
- en: 'Print the raw string data:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印原始字符串数据：
- en: '[PRE87]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下：
- en: '![Figure 7\. 21: output of raw string data'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.21：原始字符串数据的输出]'
- en: '](img/B15780_07_21.jpg)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_07_21.jpg)'
- en: 'Figure 7\. 21: output of raw string data'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.21：原始字符串数据的输出
- en: 'Let''s examine the XML data that we received, and let''s locate the `<title>`
    and `<href>` tags:'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查我们收到的XML数据，并定位`<title>`和`<href>`标签：
- en: '![Figure 7.22: The output showing the extracted href tags'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图7.22：显示提取的href标签的输出]'
- en: '](img/B15780_07_22.jpg)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_07_22.jpg)'
- en: 'Figure 7.22: The output showing the extracted href tags'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.22：显示提取的href标签的输出
- en: Now we know what tags to search for.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们知道要搜索哪些标签。
- en: 'Print the `<title>` and `<href>` hyperlinks in the XML data:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印XML数据中的`<title>`和`<href>`超链接：
- en: '[PRE88]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The final output (partially shown) is as follows:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终输出（部分显示）如下：
- en: '![Figure 7.23: The output showing the final output'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.23：显示最终输出的输出]'
- en: '](img/B15780_07_23.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15780_07_23.jpg)'
- en: 'Figure 7.23: The output showing the final output'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：显示最终输出的输出
- en: Note the use of `h!=None` and `t!=None`. These are difficult to anticipate when
    you first run this kind of code. You may get an error because some of the tags
    may return a `None` object, that is, they were empty for some reason in this XML
    data stream. This kind of situation is fairly common and cannot be anticipated
    beforehand. You have to use your Python knowledge and programming intuition to
    get around it if you receive such an error. Here, we are just checking for the
    type of the object and if it is not `None`, then we need to extract the text associated
    with it.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`h!=None`和`t!=None`的使用。当你第一次运行这类代码时，这些是难以预料的。你可能会得到一个错误，因为一些标签可能返回一个`None`对象，即它们在这个XML数据流中由于某种原因而为空。这种情况相当常见，无法事先预料。你必须使用你的Python知识和编程直觉来处理这种错误。在这里，我们只是在检查对象的类型，如果它不是`None`，那么我们需要提取与之相关的文本。
- en: As we can see in the output of this exercise, we're getting a nice output with
    links to recipes relevant to the food item we searched for. And this concludes
    this exercise. We have used our knowledge of making HTTP requests and getting
    data from the internet and mixed it with our newly acquired knowledge of parsing
    and traversing XML documents to accomplish a small but functional data pipeline.
    This kind of data pipeline building is a fairly common task for a data wrangling
    engineer. Now you know how to approach that.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这次练习的输出中可以看到的，我们得到了一个很好的输出，其中包含了与我们所搜索的食物相关的食谱链接。这就结束了这次练习。我们使用了我们关于制作HTTP请求和从互联网获取数据的知识，并结合了我们新获得的对解析和遍历XML文档的知识，来完成了一个小型但功能性的数据处理管道。这种数据处理管道的构建对于数据整理工程师来说是一项相当常见的任务。现在你知道如何去处理这个问题了。
- en: Note
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2ALU6yZ.](https://packt.live/2ALU6yZ%20)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这个特定部分的源代码，请参阅[https://packt.live/2ALU6yZ](https://packt.live/2ALU6yZ)。
- en: You can also run this example online at [https://packt.live/3hBSMPH](https://packt.live/3hBSMPH).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hBSMPH](https://packt.live/3hBSMPH)上在线运行这个示例。
- en: Reading Data from an API
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从API读取数据
- en: Fundamentally, an API or Application Programming Interface is an interface to
    a computing resource (for example, an operating system or database table), which
    has a set of exposed methods (function calls) that allow a programmer to access
    particular data or internal features of that resource.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，API或应用程序编程接口是访问计算资源（例如，操作系统或数据库表）的接口，它提供了一组公开的方法（函数调用），允许程序员访问该资源的特定数据或内部功能。
- en: A web API is, as the name suggests, an API over the web. Note that it is not
    a specific technology or programming framework, but an architectural concept.
    Think of an API like a fast-food restaurant's customer service desk. Internally,
    there are many food items, raw materials, cooking resources, and recipe management
    systems, but all you see are fixed menu items on the board and you can only interact
    through those items. It is like a port that can be accessed using an HTTP protocol
    and that's able to deliver data and services if used properly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API，正如其名所示，是在网络上的API。请注意，它不是一个特定的技术或编程框架，而是一个架构概念。想象一下，API就像快餐店的顾客服务台。内部有许多食品、原材料、烹饪资源和食谱管理系统，但你所能看到的是固定的菜单项，而你只能通过这些项进行交互。它就像一个可以使用HTTP协议访问的端口，并且如果使用得当，能够提供数据和服务的端口。
- en: Web APIs are extremely popular these days for all kinds of data services. In
    the very first chapter, we talked about how UC San Diego's data science team pulls
    data from Twitter feeds to analyze the occurrence of forest fires. For this, they
    do not go to [twitter.com](http://twitter.com) and scrape the data by looking
    at HTML pages and text. Instead, they use the Twitter API, which sends this data
    continuously in a streaming format.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 网络API在当今各种数据服务中极为流行。在第一章中，我们讨论了加州大学圣地亚哥分校的数据科学团队如何从Twitter动态中提取数据来分析森林火灾的发生情况。为此，他们不是去[twitter.com](http://twitter.com)通过查看HTML页面和文本来抓取数据。相反，他们使用了Twitter
    API，该API以流式格式连续发送这些数据。
- en: Therefore, it is very important for a data wrangling professional to understand
    the basics of data extraction from a web API as you are extremely likely to find
    yourself in a situation where large quantities of data must be read through an
    API for processing and wrangling. These days, most APIs stream data in JSON format.
    In this chapter, we will use a free API to read some information about various
    countries around the world in JSON format and process it.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于数据整理专业人士来说，了解从网络API中提取数据的基本知识非常重要，因为你极有可能发现自己处于必须通过API读取大量数据进行处理和整理的情况。如今，大多数API以JSON格式流式传输数据。在本章中，我们将使用一个免费的API以JSON格式读取有关世界各地各种国家的信息，并进行处理。
- en: 'We will use Python''s built-in `urllib` module for this topic, along with pandas
    to make a DataFrame. So, we can import them now. We will also import Python''s
    `json` module:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的内置`urllib`模块以及pandas来创建一个DataFrame。因此，我们现在可以导入它们。我们还将导入Python的`json`模块：
- en: '[PRE89]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Defining the Base URL (or API Endpoint)
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义基本URL（或API端点）
- en: 'First, we need to set the base URL. When we are dealing with API microservices,
    this is often called the **API endpoint**. Therefore, look for such a phrase in
    the web service portal you are interested in and use the endpoint URL they give
    you:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置基本URL。当我们处理API微服务时，这通常被称为**API端点**。因此，在你感兴趣的网站服务门户中寻找这样的短语，并使用他们提供的端点URL：
- en: '[PRE90]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: API-based microservices are extremely dynamic in nature in terms of what and
    how they offer their services and data. It can change at any time. At the time
    of writing, we found this particular API to be a nice choice for extracting data
    easily and without using authorization keys (login or special API keys).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 基于API的微服务在提供服务和数据方面具有极高的动态性。它们可以随时更改。在撰写本文时，我们发现这个特定的API是一个很好的选择，可以轻松提取数据，而不需要使用授权密钥（登录或特殊API密钥）。
- en: For most APIs, however, you need to have your own API key. You get that by registering
    with their service. A basic usage (up to a fixed number of requests or a data
    flow limit) is often free, but after that, you will be charged. To register for
    an API key, you often need to enter credit card information.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数API，然而，你需要有自己的API密钥。通过注册他们的服务来获得。基本使用（直到固定数量的请求或数据流限制）通常是免费的，但之后你将需要付费。为了注册API密钥，你通常需要输入信用卡信息。
- en: We wanted to avoid all that hassle to teach you the basics and that's why we
    chose this example, which does not require such authorization. But, depending
    on what kind of data you will encounter in your work, please be prepared to learn
    about using an API key.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免所有这些麻烦来教你基础知识，这就是为什么我们选择了这个例子，它不需要这样的授权。但是，根据你工作中会遇到的数据类型，请准备好学习如何使用API密钥。
- en: 'Exercise 7.12: Defining and Testing a Function to Pull Country Data from an
    API'
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.12：定义和测试从API获取国家数据的函数
- en: 'In this exercise, we''ll use a particular API, `https://restcountries.eu/rest/v2/name/`,
    that serves basic information about countries around the world. We will first
    connect with the API. Next, we will create a user-defined function to get the
    data for a specific country. Let''s follow these steps:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个特定的API，`https://restcountries.eu/rest/v2/name/`，它提供有关世界各地国家的基本信息。我们首先将与API建立连接。接下来，我们将创建一个用户定义的函数来获取特定国家的数据。让我们按照以下步骤进行：
- en: 'Import the necessary libraries:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE91]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define the `service_url` variable:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`service_url`变量：
- en: '[PRE92]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Define a function to pull out data when we pass the name of a country as an
    argument. The crux of the operation is contained in the following two lines of code:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，当我们传递国家名称作为参数时，从中提取数据。操作的核心包含在以下两行代码中：
- en: '[PRE93]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The first line of code appends the country name as a string to the base URL
    and the second line sends a `get` request to the API endpoint. If all goes well,
    we get back the data, decode it, and read it as a `JSON` file. This whole exercise
    is coded in the following function, along with some error-handling code wrapped
    around the basic actions we talked about previously.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行代码将国家名称作为字符串附加到基本URL上，第二行向API端点发送`get`请求。如果一切顺利，我们将返回数据，对其进行解码，并将其读取为`JSON`文件。整个练习的代码如下，其中包括围绕我们之前讨论的基本操作的一些错误处理代码。
- en: 'Define the `get_country_data` function:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`get_country_data`函数：
- en: '[PRE94]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Test this function by passing some arguments. Note that we are using the `try..except`
    block here. The `try` block lets you test a block of code and see whether there
    are any errors; the `except` block lets you handle the errors.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过传递一些参数来测试这个函数。请注意，我们在这里使用`try..except`块。`try`块让你测试一段代码并查看是否有错误；`except`块让你处理错误。
- en: 'Type in the following command:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE95]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE96]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Feed erroneous data in `country_name1`:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`country_name1`中输入错误数据：
- en: '[PRE97]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We pass a correct name and an erroneous name. The response is as follows:'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们传递了一个正确的名称和一个错误的名称。响应如下：
- en: '[PRE98]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is an example of rudimentary error handling. You have to think about various
    possibilities and put in the right code to catch and gracefully respond to user
    input when you are building a real-life web or enterprise application.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的错误处理示例。在构建实际的Web或企业应用程序时，你必须考虑各种可能性，并编写正确的代码来捕获并优雅地响应用户输入。
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30QU3MY.](https://packt.live/30QU3MY%20)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/30QU3MY.](https://packt.live/30QU3MY%20)
- en: You can also run this example online at [https://packt.live/2UUPc9I](https://packt.live/2UUPc9I).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2UUPc9I](https://packt.live/2UUPc9I)上在线运行此示例。
- en: Now that we have written a function to get this data with some kind of error
    handling built into it, we are ready to move on to the next part, where we deal
    with the data that we just got.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一个具有某种错误处理的函数来获取这些数据，我们可以继续进行下一部分，其中我们将处理我们刚刚获取的数据。
- en: Using the Built-In JSON Library to Read and Examine Data
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的JSON库读取和检查数据
- en: As we have already mentioned, JSON looks a lot like a Python dictionary.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，JSON看起来很像Python字典。
- en: 'We will use Python''s `requests` module to read raw data in that format and
    see what we can process further:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的`requests`模块来读取该格式的原始数据，并查看我们可以进一步处理的内容：
- en: '[PRE99]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output will be as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE100]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It reads a string datatype into a list of dictionaries. In this case, we get
    only one element in the list, so we extract that and check its type to make sure
    it is a dictionary.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 它将字符串数据类型读入一个字典列表。在这种情况下，列表中只有一个元素，所以我们提取它并检查其类型，以确保它是一个字典。
- en: We can quickly check the keys of the dictionary by using the `keys()` method
    on the dictionary, that is, the JSON data (note that a full screenshot is not
    shown here).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在字典上使用`keys()`方法来快速检查字典的键，即JSON数据（注意这里没有显示完整的截图）。
- en: 'Let''s try the following command:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下命令：
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output (partially shown), will be:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（部分显示），如下所示：
- en: '![Figure 7.24: The output of dict_keys'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24：dict_keys的输出]'
- en: '](img/B15780_07_24.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_24.jpg]'
- en: 'Figure 7.24: The output of dict_keys'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：dict_keys的输出
- en: We can see the relevant country data, such as calling codes, population, area,
    time zones, borders, and so on.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到相关的国家数据，例如电话区号、人口、面积、时区、边界等。
- en: Printing All the Data Elements
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印所有数据元素
- en: 'This task is extremely simple given that we have a dictionary at our disposal.
    All we have to do is iterate over the dictionary and print the key/item pairs
    one by one:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有现成的字典，这项任务非常简单。我们只需遍历字典，逐个打印键/项对即可：
- en: '[PRE102]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output (partially shown) is as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（部分显示）如下所示：
- en: '![Figure 7.25: The output using dict'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.25：使用字典的输出]'
- en: '](img/B15780_07_25.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_25.jpg]'
- en: 'Figure 7.25: The output using dict'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：使用字典的输出
- en: Note that the items in the dictionary are not of the same type, that is, they
    are not similar objects. Some are floating-point numbers, such as `area`, many
    are simple strings, but some are lists or even lists of dictionaries.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字典中的项不是同一类型，也就是说，它们不是相似的对象。有些是浮点数，例如`area`，许多是简单的字符串，但有些是列表或甚至是字典的列表。
- en: This is fairly common with JSON data. The internal data structure of JSON can
    be arbitrarily complex and multilevel, that is, you can have a dictionary of lists
    of dictionaries of dictionaries of lists of lists… and so on.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这在JSON数据中相当常见。JSON的内部数据结构可以是任意复杂和多层级的，也就是说，你可以有一个字典，其中包含列表、字典、列表的字典、列表的列表……等等。
- en: Note
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is clear, therefore, that there is no universal method or processing function
    for the JSON data format, and you have to write custom loops and functions to
    extract data from such a dictionary object based on your particular needs.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显，对于JSON数据格式，没有通用的方法或处理函数，你必须根据特定的需求编写自定义循环和函数来从这样的字典对象中提取数据。
- en: 'Now, we will write a small loop to extract the languages spoken in Switzerland.
    First, let''s examine the dictionary closely and see where the language data is:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个小循环来提取瑞士使用的语言。首先，让我们仔细检查字典，看看语言数据在哪里：
- en: '![Figure 7.26: The tags'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.26：标签]'
- en: '](img/B15780_07_26.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_26.jpg]'
- en: 'Figure 7.26: The tags'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26：标签
- en: So, the data is embedded inside a list of dictionaries, which is accessed by
    a particular key of the main dictionary.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数据嵌套在一个字典的列表中，通过主字典的特定键来访问。
- en: 'We can write two simple lines of code to extract this data:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写两行简单的代码来提取这些数据：
- en: '[PRE103]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output is as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 7.27: The output showing the languages'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.27：显示语言的输出]'
- en: '](img/B15780_07_27.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B15780_07_27.jpg]'
- en: 'Figure 7.27: The output showing the languages'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.27：显示语言的输出
- en: Using a Function that Extracts a DataFrame Containing Key Information
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用提取包含关键信息的DataFrame的函数
- en: 'Here, we are interested in writing a function that can take a list of countries
    and return a `pandas` DataFrame with some key information:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们感兴趣的是编写一个函数，该函数可以接受一个国家列表，并返回一个包含一些关键信息的`pandas` DataFrame：
- en: Capital
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首都
- en: Region
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地区
- en: Sub-region
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子区域
- en: Population
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人口
- en: Latitude/longitude
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度/经度
- en: Area
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积
- en: Gini index
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基尼系数
- en: Time zones
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区
- en: Currencies
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 货币
- en: Languages
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言
- en: Note
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This is the kind of wrapper function you are generally expected to write in
    real-life data wrangling tasks, that is, a utility function that can take a user
    argument and output a useful data structure (or a mini database-type object) with
    key information extracted over the internet about the item the user is interested
    in.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一种你通常在现实生活中的数据处理任务中需要编写的包装函数，即一个可以接受用户参数并输出一个包含从互联网上提取的关于用户感兴趣的项目关键信息的有效数据结构（或小型数据库类型对象）的实用函数。
- en: 'We will show you the whole function first and then discuss some key points
    about it. It is a slightly complex and long piece of code. However, with your
    Python data-wrangling knowledge, you should be able to examine this function closely
    and understand what it is doing:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示整个函数，然后讨论一些关于它的关键点。这是一段稍微复杂且较长的代码。然而，凭借你的 Python 数据处理知识，你应该能够仔细检查这个函数并理解它在做什么：
- en: '[PRE104]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here are some of the key points about this function:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个函数的一些关键点如下：
- en: It starts by building an empty dictionary of lists. This is the chosen format
    for finally passing to the pandas **DataFrame** method, which accepts this format
    and returns a nice DataFrame with column names set to the dictionary keys' names.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首先构建一个空的列表字典。这是最终传递给 pandas **DataFrame** 方法的格式，该方法接受此格式并返回一个具有列名设置为字典键名称的漂亮的
    DataFrame。
- en: We use the previously defined `get_country_data` function to extract data for
    each country in the user-defined list. For this, we simply iterate over the list
    and call this function.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用之前定义的 `get_country_data` 函数来提取用户定义列表中每个国家的数据。为此，我们只需遍历列表并调用此函数。
- en: We check the output of the `get_country_data` function. If for some reason it
    returns a `None` object, we will know that the API reading was not successful,
    and we will print out a suitable message. Again, this is an example of an error-handling
    mechanism and you must have them in your code. Without this small error-checking
    code, your application won't be robust enough for the occasional incorrect input
    or API malfunction.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查 `get_country_data` 函数的输出。如果由于某种原因它返回一个 `None` 对象，我们将知道 API 读取没有成功，并将打印出一条合适的消息。这又是一个错误处理机制的例子，你必须在代码中实现它。没有这个小错误检查代码，你的应用程序将不足以应对偶尔的错误输入或
    API 故障。
- en: For many data types, we simply extract the data from the main JSON dictionary
    and append it to the corresponding list in our data dictionary.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于许多数据类型，我们只需从主 JSON 字典中提取数据并将其追加到我们数据字典中相应的列表中。
- en: However, for special data types, such as time zones, currencies, and languages,
    we write a special loop to extract the data without error.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，对于特殊的数据类型，例如时区、货币和语言，我们编写一个特殊的循环来提取数据，而不会出错。
- en: We also take care of the fact that these special data types can have a variable
    length, that is, some countries may have multiple spoken languages, but most will
    have only one entry. So, we check whether the length of the list is greater than
    one and handle the data accordingly.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还注意到了这些特殊数据类型可能具有可变长度的事实，也就是说，一些国家可能有多种官方语言，但大多数只有一个条目。因此，我们检查列表的长度是否大于一个，并相应地处理数据。
- en: 'Exercise 7.13: Testing the Function by Building a Small Database of Country
    Information'
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.13：通过构建一个小型国家信息数据库来测试函数
- en: In this exercise, we will use the example code used in the previous section
    and build a database of country information. We will test this function by passing
    a list of country names.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用上一节中使用的示例代码，并构建一个国家信息数据库。我们将通过传递一个国家名称列表来测试这个功能。
- en: 'Let''s follow these steps:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行：
- en: 'Import the necessary libraries:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE105]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Define the `service_url` variable:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `service_url` 变量：
- en: '[PRE106]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Define the `get_country_data` function:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `get_country_data` 函数：
- en: '[PRE107]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Define the name of the country:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义国家名称：
- en: '[PRE108]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Type in the following command:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE109]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output is as follows:'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE110]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Feed erroneous data in `country_name1`:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `country_name1` 中输入错误数据：
- en: '[PRE111]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'On passing an erroneous name, the response is as follows:'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当传递错误名称时，响应如下：
- en: '[PRE112]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, import the `json` library:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导入 `json` 库：
- en: '[PRE113]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Load from string `data` as follows:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式从字符串 `data` 加载：
- en: '[PRE114]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Load the only element as follows:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式加载唯一元素：
- en: '[PRE115]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Check the type of `y` as follows:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式检查 `y` 的类型：
- en: '[PRE116]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This will return `dict`
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回 `dict`
- en: 'Print the keys of `y` as follows:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打印 `y` 的键：
- en: '[PRE117]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The output is as follows:'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE118]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Iterate over the dictionary and print the key/item pairs one by one:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历字典并逐个打印键/项对：
- en: '[PRE119]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'A section of output is as follows:'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出的一部分如下：
- en: '[PRE120]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Create a loop to extract the languages spoken in `Switzerland`:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建循环以提取 `Switzerland` 中使用的语言：
- en: '[PRE121]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The output is as follows:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE122]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Import the necessary libraries:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库：
- en: '[PRE123]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Define the `build_country_database`:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `build_country_database`：
- en: '[PRE124]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To test its robustness, we pass in an erroneous name, such as `Turmeric` in
    this case:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试其健壮性，我们传递了一个错误的名字，例如本例中的 `Turmeric`：
- en: '[PRE125]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The output is as follows:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 7.28: output of country database'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.28：国家数据库输出'
- en: '](img/B15780_07_28.jpg)'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_28.jpg](img/B15780_07_28.jpg)'
- en: 'Figure 7.28: output of country database'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.28：国家数据库输出
- en: 'As we can see from the output, it detected that it did not get any data back
    for the incorrect entry and printed out a suitable message. The key thing is that
    if you do not have the error-checking and handling code in your function, then
    it will stop the execution on that entry and will not return the expected mini
    database. To avoid this behavior, error-handling code is invaluable. The following
    screenshot points at the incorrect entry:'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，它没有为错误条目返回任何数据，并打印出一条合适的消息。关键是，如果您在函数中没有错误检查和处理代码，那么它将在该条目上停止执行，并且不会返回预期的微型数据库。为了避免这种行为，错误处理代码是无价的。以下截图指向错误条目：
- en: '![Figure 7.29: The incorrect entry highlighted'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.29：高亮显示的错误条目'
- en: '](img/B15780_07_29.jpg)'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_29.jpg](img/B15780_07_29.jpg)'
- en: 'Figure 7.29: The incorrect entry highlighted'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.29：高亮显示的错误条目
- en: 'Print the `pandas` DataFrame:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `pandas` DataFrame：
- en: '[PRE126]'
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The output is as follows (only partial output is shown):'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下（仅显示部分输出）：
- en: '![Figure 7.30: Partial output'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.30：部分输出'
- en: '](img/B15780_07_30.jpg)'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15780_07_30.jpg](img/B15780_07_30.jpg)'
- en: 'Figure 7.30: Partial output'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.30：部分输出
- en: 'Let''s analyze the data that has been extracted:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析已提取的数据：
- en: '![Figure 7.31: The data extracted correctly'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.31：正确提取的数据'
- en: '](img/B15780_07_31.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15780_07_31.jpg](img/B15780_07_31.jpg)'
- en: 'Figure 7.31: The data extracted correctly'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.31：正确提取的数据
- en: As we can see from the output, single as well as multiple pieces of data have
    been extracted correctly.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，单条以及多条数据都已被正确提取。
- en: Note
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YeRDpP.](https://packt.live/2YeRDpP%20)
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YeRDpP](https://packt.live/2YeRDpP)。
- en: You can also run this example online at [https://packt.live/3fvAY6U](https://packt.live/3fvAY6U).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/3fvAY6U](https://packt.live/3fvAY6U) 上在线运行此示例。
- en: Fundamentals of Regular Expressions (RegEx)
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式（RegEx）基础
- en: '**Reg**ular **ex**pressions or **regex** are used to identify whether a pattern
    exists in a given sequence of characters (a string) or not. They help with manipulating
    textual data, which is often a prerequisite for data science projects that involve
    text mining.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则** **表达式** 或 **regex** 用于确定在给定的字符序列（字符串）中是否存在模式。它们有助于操作文本数据，这对于涉及文本挖掘的数据科学项目通常是先决条件。'
- en: RegEx in the Context of Web Scraping
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web Scraping 中的 RegEx
- en: Web pages are often full of text, and while there are some methods in `BeautifulSoup`
    or XML parsers to extract raw text, there is no method for the intelligent analysis
    of that text. If, as a data wrangler, you are looking for a particular piece of
    data (for example, email IDs or phone numbers in a special format), you have to
    do a lot of string manipulation on a large corpus to extract email IDs or phone
    numbers. `RegEx` is very powerful and can save a data wrangling professional a
    lot of time and effort with string manipulation because they can search for complex
    textual patterns with wildcards of an arbitrary length.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 网页通常充满了文本，虽然 `BeautifulSoup` 或 XML 解析器中有一些方法可以提取原始文本，但没有用于智能分析文本的方法。如果您作为数据整理员正在寻找特定的数据（例如，特殊格式的电子邮件
    ID 或电话号码），您必须在大量语料库上进行大量字符串操作以提取电子邮件 ID 或电话号码。`RegEx` 非常强大，可以通过字符串操作节省数据整理专业人士的大量时间和精力，因为他们可以使用任意长度的通配符搜索复杂的文本模式。
- en: '`RegEx` is like a mini-programming language in itself and common ideas are
    used not only in Python, but in all widely used web app languages, such as JavaScript,
    PHP, and Perl. The `regex` module is built into Python, and you can import it
    by using the following code:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegEx` 本身就像是一种微型编程语言，常见思想不仅用于 Python，还用于所有广泛使用的网络应用语言，如 JavaScript、PHP 和 Perl。`regex`
    模块是 Python 内置的，您可以使用以下代码导入它：'
- en: '[PRE127]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the next exercise, we are going to use the `match` method to check whether
    a pattern matches a string or sequence.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用 `match` 方法来检查模式是否与字符串或序列匹配。
- en: 'Exercise 7.14: Using the match Method to Check Whether a Pattern Matches a
    String/Sequence'
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.14：使用 `match` 方法检查模式是否与字符串/序列匹配
- en: 'In this exercise, we will use one of the most common regex methods, `match`,
    to check for an exact or partial match at the beginning of a string. Let''s follow
    these steps:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用最常用的正则表达式方法之一，`match`，来检查字符串开头的精确匹配或部分匹配。让我们按照以下步骤进行：
- en: 'Import the `regex` module:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `regex` 模块：
- en: '[PRE128]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Define a string and a pattern:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个字符串和一个模式：
- en: '[PRE129]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Write a conditional expression to check for a match:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个条件表达式来检查匹配：
- en: '[PRE130]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output should be as follows:'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE131]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Test this with a string that only differs in the first letter by making it
    lowercase:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个仅第一个字母不同（变为小写）的字符串来测试它：
- en: '[PRE132]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The output is as follows:'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE133]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2N8SKAW.](https://packt.live/2N8SKAW%20)
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2N8SKAW](https://packt.live/2N8SKAW)。
- en: You can also run this example online at [https://packt.live/3hHJOAr](https://packt.live/3hHJOAr).
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以在 [https://packt.live/3hHJOAr](https://packt.live/3hHJOAr) 上运行此示例。
- en: In this exercise, we just saw how to do the most basic regex operations. In
    itself, it may not look very impressive, but we will be building further complex
    logic on top of this basic idea in the forthcoming exercises.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们只看到了如何进行最基本的正则表达式操作。本身可能看起来并不那么令人印象深刻，但我们将在这个基本想法的基础上在接下来的练习中构建更复杂的逻辑。
- en: Using the compile Method to Create a RegEx Program
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编译方法创建正则表达式程序
- en: In a program or module, if we are making heavy use of a particular pattern,
    then it is better to use the `compile` method and create a regex program and then
    call methods on this program.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序或模块中，如果我们正在大量使用特定的模式，那么使用 `compile` 方法创建正则表达式程序并调用该程序的方法会更好。
- en: 'Here is how you compile a regex program:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何编译一个正则表达式程序：
- en: '[PRE134]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The output is as follows:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE135]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This code produced an `SRE.Match` object that has a `span` of (`0,6`) and the
    matched string of `Python`. The span here simply denotes the start and end indices
    of the pattern that was matched. These indices may come in handy in a text mining
    program where the subsequent code uses the indices for further search or decision-making
    purposes.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了一个 `SRE.Match` 对象，其 `span` 为 (`0,6`)，匹配的字符串为 `Python`。这里的 `span` 简单地表示匹配模式的起始和结束索引。这些索引在文本挖掘程序中可能很有用，后续代码可以使用这些索引进行进一步搜索或决策。
- en: Compiled objects act like functions in that they return `None` if the pattern
    does not match. This concept will come in handy later when we write a small utility
    function to check for the type of the returned object from regex-compiled programs
    and act accordingly. We cannot be sure whether a pattern will match a given string
    or whether it will appear in a corpus of text (if we are searching for the pattern
    anywhere within the text). Depending on the situation, we may encounter `Match`
    objects or `None` as the returned value, and we have to handle this gracefully.
    Let's practice this in the following exercise.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 编译对象就像函数一样，如果模式不匹配，则返回 `None`。这个概念在我们编写一个小型实用函数来检查正则表达式编译程序返回的对象类型并相应地操作时将很有用。我们无法确定模式是否会匹配给定的字符串，或者它是否会在文本语料库中（如果我们正在搜索文本中的任何位置）出现。根据情况，我们可能会遇到
    `Match` 对象或 `None` 作为返回值，我们必须优雅地处理这种情况。让我们在以下练习中练习这个。
- en: 'Exercise 7.15: Compiling Programs to Match Objects'
  id: totrans-607
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.15：编译程序以匹配对象
- en: 'In this exercise, we will define two strings and a pattern. We will use the
    `compile` method to compile a regex program. Next, we will write a small conditional
    to test whether the compiled object matches the defined pattern. Let''s follow
    these steps:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义两个字符串和一个模式。我们将使用 `compile` 方法编译一个正则表达式程序。接下来，我们将编写一个小型条件表达式来测试编译对象是否与定义的模式匹配。让我们按照以下步骤进行：
- en: 'Use the `compile` function from the `regex` module:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `regex` 模块的 `compile` 函数：
- en: '[PRE136]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Match it with the first string:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其与第一个字符串匹配：
- en: '[PRE137]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The output is as follows:'
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE138]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Match it with the second string:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其与第二个字符串匹配：
- en: '[PRE139]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The output is as follows:'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE140]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: So, the `compile` method returns special objects, such as `match` objects. But
    if they don't match, it will return `None`, so we can still run our conditional
    loop.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`compile` 方法返回特殊对象，如 `match` 对象。但如果它们不匹配，它将返回 `None`，因此我们仍然可以运行我们的条件循环。
- en: Note
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/30SJ4m9.](https://packt.live/30SJ4m9%20)
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/30SJ4m9.](https://packt.live/30SJ4m9%20)
- en: You can also run this example online at [https://packt.live/3hIBkJE](https://packt.live/3hIBkJE).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hIBkJE](https://packt.live/3hIBkJE)上在线运行此示例。
- en: 'Exercise 7.16: Using Additional Parameters in the match Method to Check for
    Positional Matching'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.16：在 `match` 方法中使用附加参数以检查位置匹配
- en: 'In this exercise, we will use the `match` method to check whether there''s
    a match at a specific location in the string. Let''s follow these steps:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `match` 方法来检查字符串中特定位置是否存在匹配项。让我们按照以下步骤进行：
- en: 'Match `y` in the second position:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个位置匹配 `y`：
- en: '[PRE141]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The output is as follows:'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE142]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This is the `match` object that we talked about before.
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们之前提到的 `match` 对象。
- en: 'Check for a pattern called `thon` starting from `pos=2`, that is, the third
    character:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `pos=2` 开始检查名为 `thon` 的模式，即第三个字符：
- en: '[PRE143]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The output is as follows:'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE144]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Find a match in a different string by using the following command:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在另一个字符串中查找匹配项：
- en: '[PRE145]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The output is as follows:'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE146]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: So, we have seen how can we use regex, and use it in various use cases.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何使用正则表达式，并在各种用例中使用它。
- en: Note
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2CmKc7z.](https://packt.live/2CmKc7z%20)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2CmKc7z.](https://packt.live/2CmKc7z%20)
- en: You can also run this example online at [https://packt.live/30OsDY6](https://packt.live/30OsDY6).
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/30OsDY6](https://packt.live/30OsDY6)上在线运行此示例。
- en: Finding the Number of Words in a List That End with "ing"
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找以 "ing" 结尾的单词数量
- en: 'Suppose we want to find out whether a given string has the last three letters
    `ing`. This kind of query may come up in a text analytics/text mining program
    where somebody is interested in finding instances of present continuous tense
    words, which are highly likely to end with `ing`. However, nouns may also end
    with `ing` (as we will see in this example):'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想找出给定的字符串是否有最后的三个字母 `ing`。这种查询可能会出现在文本分析/文本挖掘程序中，有人对查找现在进行时态单词的实例感兴趣，这些单词很可能以
    `ing` 结尾。然而，名词也可能以 `ing` 结尾（正如我们将在本例中看到的那样）：
- en: '[PRE147]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Create a `for` loop to find words ending with `ing`:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `for` 循环来查找以 `ing` 结尾的单词：
- en: '[PRE148]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The output is as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE149]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The search Method in RegEx
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式中的搜索方法
- en: It looks plain and simple, and you may well wonder what the purpose of using
    a special regex module for this is. A simple string method should have been sufficient.
    Yes, it would have been OK for this particular example, but the whole point of
    using regex is to be able to use very complex string patterns that are not at
    all obvious when it comes to how they are written using simple string methods.
    We will see the real power of regex compared to string methods shortly. But before
    that, let's explore another of the most commonly used methods, called `search`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来很普通，简单，你可能想知道为什么需要使用特殊的正则表达式模块来做这件事。简单的字符串方法应该就足够了。是的，对于这个特定的例子来说，这样做是可以的，但使用正则表达式的真正目的是能够使用非常复杂的字符串模式，这些模式在使用简单的字符串方法编写时并不明显。我们很快就会看到正则表达式与字符串方法相比的真正威力。但在那之前，让我们探索另一个最常用的方法，称为
    `search`。
- en: '`search` and `match` are related concepts, and they both return the same `match`
    object. The real difference between them is that **match works for only the first
    match** (either at the beginning of the string or at a specified position, as
    we saw in the previous exercises), whereas **search looks for the pattern anywhere
    in the string** and returns the position if it finds a match.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 和 `match` 是相关概念，它们都返回相同的 `match` 对象。它们之间的真正区别在于 **match 只针对第一个匹配**（要么在字符串的开头，要么在指定的位置，就像我们在前面的练习中看到的那样），而
    **search 则在字符串的任何位置寻找模式**，如果找到匹配项则返回位置。'
- en: 'Exercise 7.17: The search Method in RegEx'
  id: totrans-652
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.17：正则表达式中的搜索方法
- en: 'In this exercise, we will use the `search` method to find the `ing` pattern
    in a regex structure. Let''s follow these steps:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `search` 方法在正则表达式中查找 `ing` 模式。让我们按照以下步骤进行：
- en: 'Use the `compile` method to find matching strings:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `compile` 方法查找匹配的字符串：
- en: '[PRE150]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The output is as follows:'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE151]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Search the string by using the following command:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令搜索字符串：
- en: '[PRE152]'
  id: totrans-659
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The output is as follows:'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE153]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Let''s use `Ringtone` as the search parameter:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 `Ringtone` 作为搜索参数：
- en: '[PRE154]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The output is as follows:'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE155]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: As you can see, the `match` method returns `None` for the input `Spring`, and
    we had to write code to print that out explicitly (because in a Jupyter notebook,
    nothing will show up for a `None` object). But `search` returns a `match` object
    with `span=(3,6)` as it finds the `ing` pattern spanning those positions.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`match`方法对于输入`Spring`返回`None`，我们不得不编写代码来显式打印出来（因为在Jupyter笔记本中，对于`None`对象将不会显示任何内容）。但是`search`返回一个带有`span=(3,6)`的`match`对象，因为它找到了跨越这些位置的`ing`模式。
- en: Similarly, for the `Ringtone` string, it finds the correct position of the match
    and returns `span=(1,4)`.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`Ringtone`字符串，它找到了匹配的正确位置并返回`span=(1,4)`。
- en: Note
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3fDRmme.](https://packt.live/3fDRmme%20)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3fDRmme.](https://packt.live/3fDRmme%20)
- en: You can also run this example online at [https://packt.live/30U2WFm](https://packt.live/30U2WFm).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在此在线运行此示例：[https://packt.live/30U2WFm](https://packt.live/30U2WFm)。
- en: 'Exercise 7.18: Using the span Method of the Match Object to Locate the Position
    of the Matched Pattern'
  id: totrans-671
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.18：使用Match对象的span方法定位匹配模式的起始位置
- en: 'In this exercise, we will use the `span` contained in the `Match` object to
    locating the exact position of the pattern as it appears in the string. Let''s
    follow these steps:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`Match`对象中的`span`来定位模式在字符串中的确切位置。让我们按照以下步骤进行：
- en: 'Initialize `prog` with the `ing` pattern:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ing`模式初始化`prog`：
- en: '[PRE156]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Create a function to return a tuple of the start and end positions of the match:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以返回匹配的起始和结束位置的元组：
- en: '[PRE157]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Print the word ending with `ing` and its start and end position:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印以`ing`结尾的单词及其起始和结束位置：
- en: '[PRE158]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'The output is as follows:'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE159]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Note
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YIZB9y.](https://packt.live/2YIZB9y%20)
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YIZB9y.](https://packt.live/2YIZB9y%20)
- en: You can also run this example online at [https://packt.live/37FXSG5](https://packt.live/37FXSG5).
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在此在线运行此示例：[https://packt.live/37FXSG5](https://packt.live/37FXSG5)。
- en: Now, we will start getting into the real usage of regex with examples of various
    useful pattern matching. In the following exercise, we will explore single-character
    matching.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过各种有用的模式匹配示例开始深入了解正则表达式的实际应用。在以下练习中，我们将探索单字符匹配。
- en: 'Exercise 7.19: Examples of Single-Character Pattern Matching with search'
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.19：使用search进行单字符模式匹配的示例
- en: 'In this exercise, we will use the `group` method, which will return the matched
    pattern in a string format so that we can print and process it easily. Let''s
    follow these steps:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`group`方法，它将以字符串格式返回匹配的模式，这样我们就可以轻松地打印和处理它。让我们按照以下步骤进行：
- en: 'Pass a regex expression with a dot (`.`) inside the `compile` method. It matches
    any single character except a newline character:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compile`方法中传递一个包含点（`.`）的正则表达式。它匹配任何单个字符，除了换行符：
- en: '[PRE160]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The output is as follows:'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE161]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Pass a regex expression with `\w` (lowercase w) inside the `compile` method.
    It matches any single letter, digit, or underscore:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compile`方法中传递一个包含`\w`（小写w）的正则表达式。它匹配任何单个字母、数字或下划线：
- en: '[PRE162]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The output is as follows:'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE163]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Pass a regex expression with `\W` (uppercase W) inside the `compile` method.
    It matches anything not covered by `\w`:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compile`方法中传递一个包含`\W`（大写W）的正则表达式。它匹配`\w`未涵盖的任何内容：
- en: '[PRE164]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The output is as follows:'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE165]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Pass a regex expression with `\s` (lowercase s) inside the `compile` method.
    It matches a single whitespace character, such as a space, newline, tab, or return:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compile`方法中传递一个包含`\s`（小写s）的正则表达式。它匹配单个空白字符，例如空格、换行符、制表符或回车符：
- en: '[PRE166]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The output is as follows:'
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE167]'
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Pass a regex expression with `\d` inside the `compile` method. It matches numerical
    digits 0-9:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`compile`方法中传递一个包含`\d`的正则表达式。它匹配数字0-9：
- en: '[PRE168]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The output is as follows:'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE169]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: As we can see, we can use the `group` function to return a group of matched characters.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以使用`group`函数来返回一组匹配的字符。
- en: Note
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YOJcAi.](https://packt.live/2YOJcAi%20)
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YOJcAi.](https://packt.live/2YOJcAi%20)
- en: You can also run this example online at [https://packt.live/3edPMHj](https://packt.live/3edPMHj).
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在此在线运行此示例：[https://packt.live/3edPMHj](https://packt.live/3edPMHj)。
- en: In the following exercise, we will manipulate the start or end of a string using
    pattern matching.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将使用模式匹配来操作字符串的开始或结束。
- en: 'Exercise 7.20: Handling Pattern Matching at the Start or End of a String'
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.20：处理字符串开头或结尾的模式匹配
- en: 'In this exercise, we will match patterns with strings using the `^` (caret)
    operator. The focus is to find out whether the pattern is present at the start
    or the end of the string. Let''s follow these steps:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将使用`^`（插入符）操作符匹配模式。重点是确定模式是否存在于字符串的开始或末尾。让我们按照以下步骤进行：
- en: 'Write a function to handle cases where a match is not found, that is, to handle
    `None` objects that are returned:'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来处理找不到匹配的情况，即处理返回的`None`对象：
- en: '[PRE170]'
  id: totrans-715
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Use `^` (caret) to match a pattern at the start of the string:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`^`（插入符）来匹配字符串开头的模式：
- en: '[PRE171]'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The output is as follows:'
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE172]'
  id: totrans-719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Use `$` (dollar sign) to match a pattern at the end of the string:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$`（美元符号）来匹配字符串末尾的模式：
- en: '[PRE173]'
  id: totrans-721
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The output is as follows:'
  id: totrans-722
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE174]'
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Note
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3ddku23.](https://packt.live/3ddku23%20)
  id: totrans-725
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/3ddku23.](https://packt.live/3ddku23%20)
- en: You can also run this example online at [https://packt.live/3djOXeV](https://packt.live/3djOXeV).
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3djOXeV](https://packt.live/3djOXeV)上在线运行此示例。
- en: For these examples and exercises, also try to think about how you would implement
    them without regex, that is, by using simple string methods and any other logic
    that you can think of. Then, compare that solution to the ones implemented with
    regex for brevity and efficiency.
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这些示例和练习，也要考虑如何在不使用正则表达式的情况下实现它们，即通过使用简单的字符串方法和任何其他你可以想到的逻辑。然后，将此解决方案与使用正则表达式实现的解决方案进行比较，以实现简洁和高效。
- en: 'Exercise 7.21: Pattern Matching with Multiple Characters'
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.21：使用多个字符进行模式匹配
- en: 'In this exercise, we will use the `match` method for matching multiple characters.
    Let''s perform the following steps:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将使用`match`方法进行多字符匹配。让我们执行以下步骤：
- en: 'Use `*` to match `0` or more repetitions of the preceding regular expression:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`*`来匹配前面正则表达式的`0`个或多个重复：
- en: '[PRE175]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The output is as follows:'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE176]'
  id: totrans-733
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Using `+` causes the resulting `RE` to match `1` or more repetitions of the
    preceding regular expression:'
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`+`会导致结果`RE`匹配前面正则表达式的`1`个或多个重复：
- en: '[PRE177]'
  id: totrans-735
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The output is as follows:'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE178]'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '? causes the resulting `re` string to match precisely 0 or 1 repetitions of
    the preceding regular expression:'
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`?`会导致结果`re`字符串精确匹配前面正则表达式的`0`个或`1`个重复：'
- en: '[PRE179]'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The output is as follows:'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE180]'
  id: totrans-741
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Here, we saw how we can use regex to search for and match a set of characters
    in the same order as they occur in the search pattern.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了如何使用正则表达式按搜索模式中字符出现的顺序搜索和匹配一组字符。
- en: Note
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/310l7Jw.](https://packt.live/310l7Jw%20)
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/310l7Jw.](https://packt.live/310l7Jw%20)
- en: You can also run this example online at [https://packt.live/3hCdnDz](https://packt.live/3hCdnDz).
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3hCdnDz](https://packt.live/3hCdnDz)上在线运行此示例。
- en: The standard (default) mode of pattern matching in regex is **greedy**, that
    is, the program tries to match as much as it can. Sometimes, this behavior is
    natural, but in some cases, you may want to match minimally. This is called **non-greedy**
    matching.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式匹配的标准（默认）模式是**贪婪**的，即程序尝试尽可能多地匹配。有时，这种行为是自然的，但在某些情况下，你可能希望进行最小匹配。这被称为**非贪婪**匹配。
- en: 'Exercise 7.22: Greedy versus Non-Greedy Matching'
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.22：贪婪与非贪婪匹配
- en: 'In this exercise, we will perform greedy and non-greedy pattern matching. Let''s
    go through the following steps:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将执行贪婪和非贪婪模式匹配。让我们按照以下步骤进行：
- en: 'Write the code to check the greedy way of matching a string, as follows:'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码以检查字符串匹配的贪婪方式，如下所示：
- en: '[PRE181]'
  id: totrans-750
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The output is as follows:'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE182]'
  id: totrans-752
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: So, the preceding regex found both tags with the `<>` pattern, but what if we
    wanted to match the first tag only and stop there.
  id: totrans-753
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，前面的正则表达式找到了具有`<>`模式的两个标签，但如果我们只想匹配第一个标签并停止，该怎么办。
- en: 'Use `?` by inserting it after any regex expression to make it non-greedy:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在正则表达式后插入`?`使其变为非贪婪：
- en: '[PRE183]'
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The output is as follows:'
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE184]'
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: In the following exercise, we will be handling repetitions using `match`.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将使用`match`处理重复。
- en: Note
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/37Hz944.](https://packt.live/37Hz944%20)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的具体源代码，请参阅[https://packt.live/37Hz944.](https://packt.live/37Hz944%20)
- en: You can also run this example online at [https://packt.live/2UVlK3q](https://packt.live/2UVlK3q).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2UVlK3q](https://packt.live/2UVlK3q)上在线运行此示例。
- en: 'Exercise 7.23: Controlling Repetitions to Match in a Text'
  id: totrans-762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.23：在文本中控制重复以匹配
- en: 'In this exercise, we will check the number of repetitions of the pattern we
    want to match in a text. Let''s go through the following steps:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查文本中我们想要匹配的模式重复的次数。让我们按照以下步骤进行：
- en: '`{m}` specifies exactly `m` copies of `RE` to match. Fewer matches cause a
    non-match and return `None`:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m}`指定恰好`m`个`RE`的匹配。匹配次数少于`m`将导致不匹配并返回`None`：'
- en: '[PRE185]'
  id: totrans-765
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The output is as follows:'
  id: totrans-766
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE186]'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '`{m,n}` specifies exactly `m` to `n` copies of `RE` to match:'
  id: totrans-768
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m,n}`指定恰好`m`到`n`个`RE`的匹配：'
- en: '[PRE187]'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The output is as follows:'
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE188]'
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Omitting `m` specifies a lower bound of zero:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 省略`m`指定下界为零：
- en: '[PRE189]'
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The output is as follows:'
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE190]'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Omitting `n` specifies an infinite upper bound:'
  id: totrans-776
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 省略`n`指定无限上界：
- en: '[PRE191]'
  id: totrans-777
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The output is as follows:'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE192]'
  id: totrans-779
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '`{m,n}?` specifies `m` to `n` copies of `RE` to match in a non-greedy fashion:'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{m,n}?`指定以非贪婪方式匹配`m`到`n`个`RE`：'
- en: '[PRE193]'
  id: totrans-781
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'The output is as follows:'
  id: totrans-782
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE194]'
  id: totrans-783
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Note
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YOzAWf.](https://packt.live/2YOzAWf%20)
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YOzAWf.](https://packt.live/2YOzAWf%20)
- en: You can also run this example online at [https://packt.live/2YKO7T4](https://packt.live/2YKO7T4).
  id: totrans-786
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/2YKO7T4](https://packt.live/2YKO7T4)上在线运行此示例。
- en: Let's go over to the next section.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到下一节。
- en: Sets of Matching Characters
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配字符的集合
- en: To match an arbitrarily complex pattern, we need to be able to include a logical
    combination of characters together as a bunch. Regex gives us that kind of capability.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配任意复杂的模式，我们需要能够将字符的逻辑组合作为一个整体包括在内。正则表达式提供了这种能力。
- en: 'The following examples demonstrate such uses of regex. `[x,y,z]` matches `x`,
    `y`, or `z`:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了正则表达式的这种用法。`[x,y,z]`匹配`x`、`y`或`z`：
- en: '[PRE195]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The output will be as follows:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE196]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: A range of characters can be matched inside the set using `-`. This is one of
    the most widely used regex techniques.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-`在集合内匹配字符范围。这是最广泛使用的正则表达式技术之一。
- en: 'Exercise 7.24: Sets of Matching Characters'
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.24：匹配字符的集合
- en: 'In this exercise, we will find the sets of matching characters from a defined
    string. We will look for an email address pattern, `<some name>@<some domain name>.<some
    domain identifier>`, from a string. Let''s go through the following steps:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从定义的字符串中找到匹配字符的集合。我们将从一个字符串中查找电子邮件地址模式`<some name>@<some domain name>.<some
    domain identifier>`。让我们按照以下步骤进行：
- en: 'Suppose we want to pick out an email address from some text:'
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要从某些文本中挑选出一个电子邮件地址：
- en: '[PRE197]'
  id: totrans-798
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The output is as follows:'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE198]'
  id: totrans-800
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Look at the regex pattern inside [ `…` ]. It is `a-zA-Z`. This covers all letters,
    including lowercase and uppercase. With this one simple regex, you are able to
    match any (pure) alphabetical string for that part of the email. Now, the next
    pattern is `@`, which is added to the previous regex by the `+` character. This
    is the way to build up a complex regex: by adding/stacking up individual regex
    patterns. We also use the same `[a-zA-Z]` for the email domain name and add a
    `.com` at the end to complete the pattern as a valid email address. Why `\.`?
    Because, by itself, a dot (`.`) is used as a special modifier in regex but here
    we want to use a dot (`.`) just as a dot (`.`), not as a modifier. So, we need
    to precede it with `\`.'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看正则表达式模式内部的[ `…` ]。它是`a-zA-Z`。这涵盖了所有字母，包括小写和大写。使用这个简单的正则表达式，你能够匹配电子邮件该部分的任何（纯）字母字符串。现在，下一个模式是`@`，它通过`+`字符添加到之前的正则表达式中。这就是构建复杂正则表达式的方式：通过添加/堆叠单个正则表达式模式。我们同样使用相同的`[a-zA-Z]`作为电子邮件域名，并在末尾添加`.com`以完成模式，使其成为一个有效的电子邮件地址。为什么`\.`？因为，单独使用时，点（`.`）在正则表达式中用作特殊修饰符，但在这里我们只想使用点（`.`）作为点（`.`），而不是作为修饰符。因此，我们需要在它之前加上`\`。
- en: So, with this regex, we could extract the first email address perfectly but
    got `No match` with the second one. What happened with the second email ID?
  id: totrans-802
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，使用这个正则表达式，我们可以完美地提取第一个电子邮件地址，但第二个却得到了“无匹配”的结果。第二个电子邮件ID发生了什么？
- en: The regex could not capture it because it had the number `12` in the name. That
    pattern is not captured by the expression [`a-zA-Z`].
  id: totrans-803
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正则表达式无法捕获它，因为它在名称中包含数字`12`。这个模式没有被表达式`[`a-zA-Z`]`捕获。
- en: 'Let''s change that and add the digits as well:'
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们改变一下，并添加数字：
- en: '[PRE199]'
  id: totrans-805
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'The output is as follows:'
  id: totrans-806
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE200]'
  id: totrans-807
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: We caught the first email ID perfectly. But what's going on with the second
    one? Again, we got a mismatch. The reason is that we changed the `.com` to `.org`
    in that email, and in our regex expression, that portion was hardcoded as `.com`,
    so it did not find a match.
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们完美地捕获了第一个电子邮件 ID。但第二个电子邮件 ID 发生了什么？我们又得到了一个不匹配。原因是我们在那个电子邮件中将 `.com` 改为了 `.org`，而在我们的正则表达式表达式中，这部分是硬编码为
    `.com` 的，所以它没有找到匹配项。
- en: 'Let''s try to address this in the following regex:'
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在以下正则表达式中尝试解决这个问题：
- en: '[PRE201]'
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The output is as follows:'
  id: totrans-811
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE202]'
  id: totrans-812
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: In this regex, we used the fact that most domain identifiers have two or three
    characters, so we used `[a-zA-Z]{2,3}` to capture that.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个正则表达式中，我们使用了这样一个事实，即大多数域名标识符有 2 到 3 个字符，所以我们使用了 `[a-zA-Z]{2,3}` 来捕获这一点。
- en: What happened with the second email ID? This is an example of the small tweaks
    that you can make to stay ahead of telemarketers who want to scrape online forums
    or any other corpus of text and extract your email ID. If you do not want your
    email to be found, you can change `@` to `[AT]` and `.` to `[DOT]`, and hopefully,
    that should beat some regex techniques (but not all of them).
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个电子邮件 ID 发生了什么？这是一个例子，说明你可以进行一些小的调整，以领先于那些想要从在线论坛或任何其他文本语料库中抓取你的电子邮件 ID 的电话推销员。如果你不希望你的电子邮件被发现，你可以将
    `@` 改为 `[AT]`，将 `.` 改为 `[DOT]`，并且希望这样应该能够击败一些正则表达式技术（但不是所有）。
- en: Note
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2UXv6eS.](https://packt.live/2UXv6eS%20)
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/2UXv6eS](https://packt.live/2UXv6eS)。
- en: You can also run this example online at [https://packt.live/315GaL9](https://packt.live/315GaL9).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/315GaL9](https://packt.live/315GaL9) 上在线运行此示例。
- en: 'Exercise 7.25: The Use of OR in RegEx Using the OR Operator'
  id: totrans-818
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.25：使用 OR 操作符的正则表达式使用 OR 操作符
- en: 'In this exercise, we will use the `OR` operator in a Regex expression. We will
    try to extract patterns of 10-digit numbers that could be phone numbers. We can
    do that by using the `|` operator. Let''s go through the following steps:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用正则表达式中的 `OR` 操作符。我们将尝试提取可能是电话号码的 10 位数字模式。我们可以通过使用 `|` 操作符来实现这一点。让我们按以下步骤进行：
- en: 'Let''s start with the `OR` operator:'
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `OR` 操作符开始：
- en: '[PRE203]'
  id: totrans-821
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'The output is as follows:'
  id: totrans-822
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE204]'
  id: totrans-823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Note the use of `{10}` to denote exactly `10`-digit numbers in the pattern.
    But the second number could not be matched for obvious reasons – it had `-` symbols
    inserted in between groups of numbers.
  id: totrans-824
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到使用 `{10}` 来表示模式中的确切的 `10` 位数字。但第二个数字由于明显的原因无法匹配——它在中间的数字组之间插入了 `-` 符号。
- en: 'Use multiple smaller regexes and logically combine them by using the following
    command:'
  id: totrans-825
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个较小的正则表达式，并通过以下命令逻辑组合它们：
- en: '[PRE205]'
  id: totrans-826
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The output is as follows:'
  id: totrans-827
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE206]'
  id: totrans-828
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Phone numbers are written in a myriad of ways and if you search on the web,
    you will see examples of very complex regexes (written not only in Python but
    in other widely used languages for web apps such as JavaScript, C++, PHP, and
    Perl) for capturing phone numbers.
  id: totrans-829
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电话号码以无数种方式书写，如果你在网上搜索，你会看到捕获电话号码的非常复杂的正则表达式示例（不仅是在 Python 中，还在其他广泛使用的网络应用程序语言中，如
    JavaScript、C++、PHP 和 Perl）。
- en: 'Create four strings and execute `print_match` on them:'
  id: totrans-830
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建四个字符串并在它们上执行 `print_match`：
- en: '[PRE207]'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The output is as follows:'
  id: totrans-832
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE208]'
  id: totrans-833
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: So, as you can see, thanks to all the different patterns we have added together
    using the `OR` operator, we are able to detect phone numbers even if they are
    written in very different ways.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你所看到的，多亏了我们使用 `OR` 操作符添加的所有不同模式，我们能够检测到即使以非常不同的方式书写的电话号码。
- en: Note
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eeZc59.](https://packt.live/3eeZc59%20)
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅 [https://packt.live/3eeZc59](https://packt.live/3eeZc59)。
- en: You can also run this example online at [https://packt.live/2APMFH5](https://packt.live/2APMFH5).
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [https://packt.live/2APMFH5](https://packt.live/2APMFH5) 上在线运行此示例。
- en: The findall Method
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: findall 方法
- en: The last regex method that we will cover in this chapter is `findall`. Essentially,
    it is a **search-and-aggregate** method, that is, it puts together all the instances
    that match the regex pattern in a given text and returns them in a list. This
    is extremely useful, as we can just count the length of the returned list to count
    the number of occurrences or pick and use the returned pattern-matched words one
    by one as we see fit.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们将要介绍的最后一个正则表达式方法是 `findall`。本质上，它是一个 **搜索和聚合** 方法，也就是说，它将给定文本中与正则表达式模式匹配的所有实例组合在一起，并以列表的形式返回它们。这非常有用，因为我们可以直接计算返回列表的长度来计算出现的次数，或者根据我们的需要逐个选择并使用返回的模式匹配词。
- en: Note that although we are giving short examples of single sentences in this
    chapter, you will often deal with a large corpus of text when using a regex.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们在本章中给出了单个句子的简短示例，但您在使用正则表达式时经常会处理大量文本。
- en: 'In those cases, you are likely to get many matches from a single regex pattern
    search. For all of those cases, the `findall` method is going to be the most useful:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您可能从单个正则表达式模式搜索中获得许多匹配项。对于所有这些情况，`findall` 方法将是最有用的：
- en: '[PRE209]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The output is as follows:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE210]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: With all this knowledge gained from the chapter, let's get started with solving
    the following activities.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章获得的所有知识，让我们开始解决以下活动。
- en: 'Activity 7.01: Extracting the Top 100 e-books from Gutenberg'
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.01：从古腾堡提取前 100 本电子书
- en: Project Gutenberg encourages the creation and distribution of eBooks by encouraging
    volunteer efforts to digitize and archive cultural works. This activity aims to
    scrape the URL of Project Gutenberg's Top 100 eBooks to identify the eBooks' links.
    It uses `BeautifulSoup` to parse the HTML and regular expression code to identify
    the Top 100 eBook file numbers. You can use these numbers to download the book
    into your local drive if you want.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 古腾堡项目鼓励通过鼓励志愿者努力数字化和归档文化作品来创建和分发电子书。此活动旨在抓取古腾堡项目前 100 本电子书的 URL 以识别电子书的链接。它使用
    `BeautifulSoup` 解析 HTML 并使用正则表达式代码来识别前 100 本电子书的文件编号。如果您想将书籍下载到本地驱动器，可以使用这些编号。
- en: 'These are the steps that will help you complete this activity:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Import the necessary libraries, including `regex` and `BeautifulSoup`.
  id: totrans-849
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，包括 `regex` 和 `BeautifulSoup`。
- en: Read the HTML from the URL.
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 URL 读取 HTML。
- en: Write a small function to check the status of the web request.
  id: totrans-851
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小的函数来检查网络请求的状态。
- en: Decode the response and pass this on to `BeautifulSoup` for HTML parsing.
  id: totrans-852
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码响应并将其传递给 `BeautifulSoup` 进行 HTML 解析。
- en: Find all the `href` tags and store them in the list of links. Check what the
    list looks like – print the first 30 elements.
  id: totrans-853
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有的 `href` 标签并将它们存储在链接列表中。检查列表看起来像什么——打印前 30 个元素。
- en: Use a regular expression to find the numeric digits in these links. These are
    the file numbers for the top 100 eBooks.
  id: totrans-854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式在这些链接中查找数字。这些是前 100 本电子书的文件编号。
- en: Initialize the empty list to hold the file numbers over an appropriate range
    and use `regex` to find the numeric digits in the link `href` string. `findall`
    method.
  id: totrans-855
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个空列表来存储文件编号，并在适当的范围内使用 `regex` 在链接 `href` 字符串中查找数字。`findall` 方法。
- en: What does the `soup` object's text look like? Use the `.text` method and print
    only the first 2,000 characters (do not print the whole thing, as it is too long).
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`soup` 对象的文本看起来是什么样子？使用 `.text` 方法并仅打印前 2,000 个字符（不要打印整个内容，因为它太长了）。'
- en: Search in the extracted text (using a regular expression) from the `soup` object
    to find the names of the top 100 eBooks (yesterday's ranking).
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `soup` 对象提取的文本中（使用正则表达式）搜索以找到前 100 本电子书的名称（昨天的排名）。
- en: Create a starting index. It should point at the text *Top 100 Ebooks yesterday*.
    Use the `splitlines` method of `soup.text`. It splits the lines of text of the
    `soup` object.
  id: totrans-858
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个起始索引。它应该指向文本 *Top 100 Ebooks yesterday*。使用 `soup.text` 的 `splitlines` 方法。它分割
    `soup` 对象的文本行。
- en: Run the `for` loop `1-100` to add the strings of the next `100` lines to this
    temporary list. `splitlines` method.
  id: totrans-859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `for` 循环 `1-100` 以将下一 `100` 行的字符串添加到此临时列表中。`splitlines` 方法。
- en: Use a regular expression to extract only text from the name strings and append
    it to an empty list. Use `match` and `span` to find the indices and use them.
  id: totrans-860
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用正则表达式仅从名称字符串中提取文本并将其追加到空列表中。使用 `match` 和 `span` 来查找索引并使用它们。
- en: Print the list of titles.
  id: totrans-861
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印标题列表。
- en: 'The output (shown partially) should look like this:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（部分显示）应该看起来像这样：
- en: '[PRE211]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Note
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor323).
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor323)找到。
- en: 'Activity 7.02: Building Your Own Movie Database by Reading an API'
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.02：通过读取 API 构建自己的电影数据库
- en: In this activity, you will build a complete movie database by communicating
    and interfacing with a free API from the OMDb portal [http://www.omdbapi.com/?](http://www.omdbapi.com/?).You
    will obtain a unique user key from the OMDb website that must be used when your
    program tries to access the API. Then, you will need to store this key value in
    a `.json` file.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将通过与 OMDb 站点的免费 API 进行通信和接口，构建一个完整的电影数据库。[http://www.omdbapi.com/?](http://www.omdbapi.com/?).您将从
    OMDb 网站获得一个唯一的用户密钥，当您的程序尝试访问 API 时必须使用此密钥。然后，您需要将此密钥值存储在一个 `.json` 文件中。
- en: 'The aims of this activity are as follows:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目标如下：
- en: To retrieve and print basic data about a movie (the title is entered by the
    user) from the web (the OMDb database).
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络（OMDb 数据库）检索并打印关于电影的基本数据（用户输入的标题）。
- en: If a poster of the movie can be found, download the file and save it in a user-specified
    location.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以找到电影的海报，则下载文件并将其保存在用户指定的位置。
- en: 'These are the steps that will help you complete this activity:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Import `urllib.request`, `urllib.parse`, `urllib.error`, and `json`.
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `urllib.request`、`urllib.parse`、`urllib.error` 和 `json`。
- en: Load the secret API key (you have to get one from the OMDb website and use that;
    it has a daily limit of 1,000 API keys) from a JSON file, stored in the same folder,
    in a variable.
  id: totrans-873
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储在同一文件夹中的 JSON 文件中加载秘密 API 密钥（您必须从 OMDb 网站获取一个并使用它；它有每日 1,000 个 API 密钥的限制），并将其存储在一个变量中。
- en: '`json.loads()`.'
  id: totrans-874
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`json.loads()`.'
- en: Students/users will need to obtain a key and store it in a JSON file.
  id: totrans-875
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生/用户需要获取一个密钥并将其存储在 JSON 文件中。
- en: Obtain a key and store it in a JSON file as `APIkeys.json`.
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个密钥并将其存储在 JSON 文件中作为 `APIkeys.json`。
- en: Open the `APIkeys.json` file.
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `APIkeys.json` 文件。
- en: Assign the OMDb portal ([http://www.omdbapi.com/?](http://www.omdbapi.com/?))
    as a string to a variable.
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 OMDb 站点 ([http://www.omdbapi.com/?](http://www.omdbapi.com/?)) 作为字符串分配给一个变量。
- en: Create a variable called `apikey` with the last portion of the URL (`&apikey=secretapikey`),
    where `secretapikey` is your own API key.
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `apikey` 的变量，包含 URL 的最后一部分（`&apikey=secretapikey`），其中 `secretapikey`
    是您自己的 API 密钥。
- en: Write a utility function called `print_json` to print the movie data from a
    JSON file (which we will get from the portal).
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `print_json` 的实用函数，用于从 JSON 文件（我们将从该门户获取）打印电影数据。
- en: Write a utility function to download a poster of the movie based on the information
    from the JSON dataset and save it in your local folder. Use the `os` module. The
    poster data is stored in a JSON key called `Poster`. Use the `open` Python command
    to open a file and write the poster data. Close the file after you're done. This
    function will save the poster data as an image file.
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个实用函数，根据 JSON 数据集中的信息下载电影海报，并将其保存在您的本地文件夹中。使用 `os` 模块。海报数据存储在一个名为 `Poster`
    的 JSON 键中。使用 `open` Python 命令打开文件并写入海报数据。完成后关闭文件。此函数将海报数据保存为图像文件。
- en: Write a utility function called `search_movie` to search for a movie by its
    name, print the downloaded `JSON` data, and save the movie poster in the local
    folder. Use a `try-except` loop for this. Use the previously created `serviceurl`
    and `apikey` variables. You have to pass on a dictionary with a key, `t`, and
    the movie name as the corresponding value to the `urllib.parse.urlencode()` function
    and then add the `serviceurl` and `apikey` variables to the output of the function
    to construct the full URL. This URL will be used to access the data. The `JSON`
    data has a key called `Response`. If it is `True`, that means the read was successful.
    Check this before processing the data. If it's not successful, then print the
    `JSON` key `Error`, which will contain the appropriate error message returned
    by the movie database.
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为 `search_movie` 的实用函数，通过电影名称搜索电影，打印下载的 `JSON` 数据，并将电影海报保存在本地文件夹中。为此使用
    `try-except` 循环。使用之前创建的 `serviceurl` 和 `apikey` 变量。您必须传递一个包含键 `t` 和电影名称作为相应值的字典到
    `urllib.parse.urlencode()` 函数，然后将 `serviceurl` 和 `apikey` 变量添加到函数的输出中，以构造完整的 URL。此
    URL 将用于访问数据。`JSON` 数据有一个名为 `Response` 的键。如果它是 `True`，则表示读取成功。在处理数据之前检查这一点。如果不成功，则打印
    `JSON` 键 `Error`，它将包含电影数据库返回的适当错误消息。
- en: 'Test the `search_movie` function by entering `Titanic`. The output should look
    like this:'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 `Titanic` 测试 `search_movie` 函数。输出应如下所示：
- en: '[PRE212]'
  id: totrans-884
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Test the `search_movie` function by entering `Random_error` and retrieve the
    data for `Random_error` (obviously, this will not be found, and you should be
    able to check whether your error-catching code is working properly). The expected
    output is as follows:'
  id: totrans-885
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入`Random_error`来测试`search_movie`函数，并检索`Random_error`的数据（显然，这将找不到，你应该能够检查你的错误捕获代码是否正常工作）。预期的输出如下：
- en: '[PRE213]'
  id: totrans-886
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Note
  id: totrans-887
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15780_Solution_Final_RK.xhtml#_idTextAnchor324).
  id: totrans-888
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过[这个链接](B15780_Solution_Final_RK.xhtml#_idTextAnchor324)找到这个活动的解决方案。
- en: Look for a folder called `Posters` in the same directory you are working in.
    It should contain a file called `Titanic.jpg`. Check the file.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在你工作的同一目录中寻找名为`Posters`的文件夹。它应该包含一个名为`Titanic.jpg`的文件。检查该文件。
- en: In this activity, we have seen a few general tricks for working with an API
    that are fairly common for other popular API services such as Google and Twitter.
    Now, you should be confident about writing more complex programs to scrape data
    from such services.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们了解了一些处理API的通用技巧，这些技巧在其他流行的API服务（如Google和Twitter）中也很常见。现在，你应该对编写更复杂的程序从这些服务中抓取数据充满信心。
- en: Summary
  id: totrans-891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through several important concepts and learning modules
    related to advanced data gathering and web scraping. We started by reading data
    from web pages using two of the most popular Python libraries – `requests` and
    `BeautifulSoup`. In this task, we utilized the knowledge we gained in the previous
    chapter about the general structure of HTML pages and their interaction with Python
    code. We extracted meaningful data from the Wikipedia home page during this process.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与高级数据收集和网络抓取相关的一些重要概念和学习模块。我们首先使用Python中最受欢迎的两个库——`requests`和`BeautifulSoup`——从网页中读取数据。在这个任务中，我们利用了上一章中关于HTML页面的一般结构和它们与Python代码交互的知识。在这个过程中，我们从维基百科主页中提取了有意义的资料。
- en: Then, we learned how to read data from XML and JSON files – two of the most
    widely used data streaming/exchange formats on the web. For XML, we showed you
    how to traverse the tree-structure data string efficiently to extract key information.
    For JSON, we mixed it with reading data from the web using an API. The API we
    consumed was RESTful, which is one of the major standards in web APIs.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何从XML和JSON文件中读取数据——这两种在网络上最广泛使用的数据流/交换格式。对于XML，我们向您展示了如何高效地遍历树形结构数据字符串以提取关键信息。对于JSON，我们将其与使用API从网络中读取数据相结合。我们使用的API是RESTful，这是网络API的主要标准之一。
- en: At the end of this chapter, we went through a detailed exercise using regex
    techniques in tricky string-matching problems to scrape useful information from
    a large and messy text corpus, parsed from HTML. This chapter should come in extremely
    handy for string and text processing tasks in your data wrangling career.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们通过使用正则表达式技术在复杂的字符串匹配问题中进行了详细的练习，从解析自HTML的大量杂乱文本语料库中抓取有用的信息。这一章对于你在数据整理职业生涯中的字符串和文本处理任务将非常有用。
- en: In the next chapter, we will learn about databases with Python.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用Python处理数据库。
