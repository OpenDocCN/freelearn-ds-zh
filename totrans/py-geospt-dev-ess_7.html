<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 7. Packaging and Distributing Your Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Packaging and Distributing Your Application</h1></div></div></div><p>We have now arrived at the final step in our application development process. We have a working application that contains a number of basic GIS features. However, so far, it can only be run on our own computer in the very specific development environment we have set up. If you want people besides yourself to benefit from your application or just to make it easier for you to travel with and use your application on multiple computers, you need to package the application so it can be more easily installed. In this chapter, we will walk through this final steps of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assigning an icon to be displayed as the logo of our application</li><li class="listitem" style="list-style-type: disc">Converting your development environment to a self-contained folder structure with an executable (<code class="literal">.exe</code>) file for running your application</li><li class="listitem" style="list-style-type: disc">Giving your application an installer wizard for a more permanent installation</li></ul></div><div class="section" title="Attaching an application logo"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec35"/>Attaching an application logo</h1></div></div></div><p>Up until now, you <a id="id261" class="indexterm"/>have probably noticed that our application is shown with a small rather generic-looking red icon in the top left of the window and down by the list of open applications. This is the standard Tkinter logo used for all Tkinter GUI applications made in Python including the IDLE editor. For your own application, you will obviously want your own icon.</p><div class="section" title="The icon image file"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec40"/>The icon image file</h2></div></div></div><p>First, you must find <a id="id262" class="indexterm"/>or create the icon that you want. Now, in order to assign the logo to your application, you need it to be in a <code class="literal">.ico</code> format, a format that contains the same image at multiple different resolutions for optimal display. In all likelihood, the image you created or found will be a normal image file such as <code class="literal">.png</code>, <code class="literal">.bmp</code>, or <code class="literal">.gif</code>, so we need to convert it. We will do this as a one-time process using Python and PIL, since we already have them installed.</p><p>Using this PIL approach, there is one small obstacle that we may have to hack our way past. The online documentation for py2exe (the package we will be using to create an EXE file for our application) warns us that in order to assign an icon to the EXE file, it matters in what order the various resolutions of the icon file are saved. The sizes must be assigned in order of largest to smallest, otherwise it won't work.</p><p>We come across an obstacle in PIL, in version 2.8.1 or lower, where it automatically orders image sizes in reverse order of smallest to largest behind the scenes, regardless of the order you originally specify. Luckily, the PIL/Pillow development team were very responsive<a id="id263" class="indexterm"/> when I raised the issue, so the problem has already been fixed and should no longer be a problem once the next stable version 2.8.2 is released.</p><p>If the new patched PIL version is not out yet, it is still easy to fix on our own. Brave as we are, we dive into the internal working files of PIL, located in <code class="literal">C:/Python27/Lib/site-packages/PIL</code>. In the <code class="literal">IcoImagePlugin.py</code> file, towards the top of the script, there is a <code class="literal">_save</code> function. There you will see that it sorts the specified sizes argument from smallest to largest with the following code: <code class="literal">sizes = sorted(sizes, key=lambda x: x[0])</code>. All we have to do is delete or comment out that line so that it is entirely up to the user in which order the sizes are saved.</p><p>Now, we are ready to convert your chosen logo image. We only need to do this once and it is fairly easy, so we do this in the interactive Python Shell window instead of the usual file editor. If you are already in the Python IDLE file editor, just click on <span class="strong"><strong>Run</strong></span> from the Python Shell in the top menu. Essentially we just import PIL, load your chosen image file, and save it to a new file with the <code class="literal">.ico</code> extension. When saving, we give it the sizes argument containing a list of width-height tuples with the standard icon resolutions we want to support, in the descending order. It makes sense to save this icon image in the <code class="literal">pythongis/app</code> folder. Run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import PIL, PIL.Image</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; img = PIL.Image.open("your/path/to/icon.png")</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; img.save("your/path/to/pythongis/app/icon.ico", sizes=[(255,255),(128,128),(64,64),(48,48),(32,32),(16,16),(8,8)])</strong></span>
</pre></div></div><div class="section" title="Assigning the icon"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec41"/>Assigning the icon</h2></div></div></div><p>Now that we have the icon file, we can assign it to our application. This is done by assigning the icon to Tkinter<a id="id264" class="indexterm"/> which will place our icon in the top-left corner of our application window and down by the Windows taskbar of active applications. We do this in <code class="literal">app/builder.py</code> in the <code class="literal">run</code> function, simply by pointing our root application window to the path of our icon. The icon file is in the same folder as <code class="literal">app/builder.py</code>, so one may think that a relative path to <code class="literal">logo.ico</code> will suffice, but apparently for this particular task of assigning a GUI icon, Tkinter requires a full absolute path. For this, we take advantage of the global <code class="literal">__file__</code> variable, which points to the absolute path of the running script:</p><div class="informalexample"><pre class="programlisting">    # assign logo from same directory as this file
    import sys, os
    curfolder,curfile = os.path.split(__file__)
    logopath = os.path.join(curfolder, "logo.ico")
    window.iconbitmap(logopath)</pre></div><p>If you run the application now, you should see that the icon appears in the top-left corner and at the bottom. Although <a id="id265" class="indexterm"/>we have told Tkinter to use the icon inside the application itself, this will not affect what the EXE file will look like when we browse and view the file in Windows explorer. We will now see how this is done as we move onto packaging and creating the EXE file.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The application start up script"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec36"/>The application start up script</h1></div></div></div><p>Since we want an EXE file that opens and runs our application, we need a script that explicitly defines how<a id="id266" class="indexterm"/> to start up our application. Our <code class="literal">guitester.py</code> script that we have used for testing purposes throughout the book does exactly that. So we take our testing script and, for the sake of clarity, rename it to <code class="literal">mygisapp.py</code> (or whatever you wish to call your app). The folder location of our main <code class="literal">pythongis</code> folder should then look like this:</p><div class="mediaobject"><img src="images/5407OS_07_01.jpg" alt="The application start up script"/></div><p>Since all we did was rename our previous <code class="literal">guitester.py</code> script to <code class="literal">mygisapp.py</code>, the content should remain unchanged and it will look like this:</p><div class="informalexample"><pre class="programlisting">import pythongis as pg
pg.app.run()</pre></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Packaging your application"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec37"/>Packaging your application</h1></div></div></div><p>With the application startup defined, we are now ready for packaging it. Packaging our application means<a id="id267" class="indexterm"/> that our application becomes self-contained with all the necessary files grouped into one folder tree (that are currently spread out across numerous locations on your computer), along with an EXE file that the user can double-click on to run the application.</p><div class="section" title="Installing py2exe"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec42"/>Installing py2exe</h2></div></div></div><p>There are <a id="id268" class="indexterm"/>numerous libraries in Python for packaging projects, and here we<a id="id269" class="indexterm"/> choose to use py2exe since it is very easy to install:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go<a id="id270" class="indexterm"/> to <a class="ulink" href="http://www.py2exe.org">www.py2exe.org</a>.</li><li class="listitem">Click on the <span class="strong"><strong>Download</strong></span> link<a id="id271" class="indexterm"/> at the top, which takes you to <a class="ulink" href="http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/">http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/</a>.</li><li class="listitem">Download and run the latest version for Python 2.7, which is currently <code class="literal">py2exe-0.6.9.win32-py2.7.exe</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>py2exe is specific to the Windows platform; you have to build on Windows and your program can only be used on Windows.</p><p>Another alternative for Windows<a id="id272" class="indexterm"/> will be PyInstaller: <a class="ulink" href="http://pythonhosted.org/PyInstaller/">http://pythonhosted.org/PyInstaller/</a>.</p><p>The equivalent for<a id="id273" class="indexterm"/> Mac OS X is py2app: <a class="ulink" href="https://pythonhosted.org/py2app/">https://pythonhosted.org/py2app/</a>.</p><p>For Linux you<a id="id274" class="indexterm"/> can use cx_Freeze: <a class="ulink" href="http://cx-freeze.sourceforge.net/">http://cx-freeze.sourceforge.net/</a>.</p></div></div></li></ol></div></div><div class="section" title="Developing a packaging strategy"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec43"/>Developing a packaging strategy</h2></div></div></div><p>There are many ways to package an application, so before we go diving in we should first understand how py2exe works and plan a packaging strategy accordingly. Given a script that the user wants to<a id="id275" class="indexterm"/> package, what py2exe does is run through the script detecting all import statements recursively and thus which libraries must be included in the final package. It then creates a folder called <code class="literal">dist</code> (it also creates one called <code class="literal">build</code> but that one is irrelevant for us) which becomes the distributable folder that contains all the required files and an EXE file that runs our application based on our startup script.</p><p>A crucial decision is how we choose to bundle our package. We can either bundle most of the required files and dependencies into the EXE file itself or a ZIP file, or not bundle anything by keeping everything loose in a folder structure. At first, bundling may seem like the neatest and best organized choice. Unfortunately, py2exe (as with other packaging libraries) often does not correctly detect or copy all the necessary files from dependencies (especially the <code class="literal">.dll</code> and <code class="literal">.pyc</code> files), leading to a startup failure of our application. There are options we can specify to help py2exe detect and include everything correctly, but this can get tedious for large projects and still might not let us correct every error. By leaving everything as files and folders instead of bundling it away, we can actually go in and correct some of the mistakes made by py2exe after it has done its work.</p><p>We get greater control with the non-bundle approach because the EXE file becomes like the Python interpreter, and everything in the top level of the <code class="literal">dist</code> folder becomes like Python's <code class="literal">site-packages</code> folder for importable libraries. This way, by manually copying dependencies in full from <code class="literal">site-packages</code> to the <code class="literal">dist</code> folder they become importable in the same way that they do when Python usually imports them from <code class="literal">site-packages</code>. py2exe will detect and handle correctly our imports of built-in Python libraries, but for the more advanced<a id="id276" class="indexterm"/> third-party dependencies, including our main <code class="literal">pythongis</code> library, we want to add them ourselves. We can put this strategy into practice when we next create the build script.</p></div><div class="section" title="Creating the build script"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec44"/>Creating the build script</h2></div></div></div><p>To package a project, py2exe needs a very simple script of instructions. Save this as <code class="literal">setup.py</code> in the same <a id="id277" class="indexterm"/>directory that our main <code class="literal">pythongis</code> folder is located in. Here is the hierarchical directory structure:</p><div class="mediaobject"><img src="images/5407OS_07_02.jpg" alt="Creating the build script"/></div><p>We start our <code class="literal">setup.py</code> file by linking to the <code class="literal">mygisapp.py</code> startup script that should be run by the EXE file, and point to the path of our icon file so that the EXE file will look like that when browsing. Under options, we set <code class="literal">skip_archive</code> to <code class="literal">True</code> following our non-bundle strategy. We also prevent py2exe from trying to read and copy two binary files from the <code class="literal">pyagg</code> package that lead to errors that aren't actually necessary because they are only provided for cross-version and cross-platform portability.</p><p>If you meet other build errors as your application evolves, ignoring such errors using <code class="literal">dll_excludes</code> for the <code class="literal">.dll</code> and <code class="literal">.pyd</code> files or excludes for modules or packages can be a good way to ignore those, and instead copy-paste the required files after building. Following is the code for the procedures we just described, as written in the <code class="literal">setup.py</code> script:</p><div class="informalexample"><pre class="programlisting">############
### allow building the exe by simply running this script
import sys
sys.argv.append("py2exe") 

############
### imports
from distutils.core import setup
import py2exe

###########
### options
WINDOWS = [{"script": "mygisapp.py",
            "icon_resources": [(1,"pythongis/app/logo.ico")] }]
OPTIONS = {"skip_archive": True,
           "dll_excludes": ["python26.dll","python27.so"],
           "excludes": [] }

###########
### build
setup(windows=WINDOWS,
      options={"py2exe": OPTIONS}
      )</pre></div><p>The <code class="literal">setup</code> function will <a id="id278" class="indexterm"/>build the <code class="literal">dist</code> folder next to <code class="literal">setup.py</code> and the <code class="literal">pythongis</code> folder. As we stated previously in our packaging strategy, py2exe might not copy all of our third-party libraries correctly if they have an advanced layout of files such as the <code class="literal">.dll</code>, <code class="literal">.pyd</code>, images, or other data files. Therefore, we choose to add some additional code to the script that<a id="id279" class="indexterm"/> copies and overwrites the more advanced dependencies such <code class="literal">PIL</code>, <code class="literal">Pyagg</code>, <code class="literal">Rtree</code>, and <code class="literal">Shapely</code> from <code class="literal">site-packages</code> (assuming you did not install them to some other location), as well as our entire <code class="literal">pythongis</code> library, over to the <code class="literal">dist</code> folder after the build process. You must make sure the path to <code class="literal">site-packages</code> matches your platform.</p><div class="informalexample"><pre class="programlisting">###########
### manually copy pythongis package to dist
### ...because py2exe may not copy all files
import os
import shutil
frompath = "pythongis"
topath = os.path.join("dist","pythongis")
shutil.rmtree(topath) # deletes the folder copied by py2exe
shutil.copytree(frompath, topath)

###########
### and same with advanced dependencies
### ...only packages, ie folders
site_packages_folder = "C:/Python27/Lib/site-packages"
advanced_dependencies = ["PIL", "pyagg", "rtree", "shapely"]
for dependname in advanced_dependencies:
    frompath = os.path.join(site_packages_folder, dependname)
    topath = os.path.join("dist", dependname)
    shutil.rmtree(topath) # deletes the folder copied by py2exe
    shutil.copytree(frompath, topath) </pre></div><p>With the <code class="literal">setup.py</code> script created, you simply run the script to package your application. It may take a minute or two for py2exe to copy everything. Once finished, there will be a <code class="literal">dist</code> folder available in the same folder as <code class="literal">setup.py</code> and <code class="literal">pythongis</code>:</p><div class="mediaobject"><img src="images/5407OS_07_03.jpg" alt="Creating the build script"/></div><p>Inside the <code class="literal">dist</code> folder, there will be a <code class="literal">mygisapp.exe</code> file (assuming that was the name of your startup script) that should look like your chosen icon, and that when run, should successfully launch your similarly iconified application window. While inside the <code class="literal">dist</code> folder, check to<a id="id280" class="indexterm"/> see that py2exe did not accidentally include any libraries that you were trying to avoid. For instance, Shapely has optional support for and will try to import NumPy when available, which causes py2exe to add it to your <code class="literal">dist</code> folder even if you do not use it. Avoid this by adding the unwanted packages to the setup script's excludes option.</p></div><div class="section" title="Adding the visual C runtime DLL"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec45"/>Adding the visual C runtime DLL</h2></div></div></div><p>If you are doing this on Windows, there is one last crucial step before our application is fully standalone. The Python programming environment relies on a Microsoft Visual C runtime DLL that was included when we installed Python. However, many versions of this DLL exist, so not all computers or users will have the specific one that our application needs. py2exe<a id="id281" class="indexterm"/> will not include the required DLL by default, so it is up to us to include it in our <code class="literal">dist</code> folder. Including the DLL in your<a id="id282" class="indexterm"/> installation is a simple matter of copy and paste, using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Although we should technically already have the DLL somewhere on our computer, I think there is enough variability and pitfalls with finding the correct one that it is best to get it by doing a clean install of the (free) Microsoft Visual C redistributable program. Download and install the version that your version of Python<a id="id283" class="indexterm"/> uses, for which 32-bit Python 2.7 is <span class="strong"><strong>Microsoft Visual C++ 2008 Redistributable Package (x86)</strong></span>, available from <a class="ulink" href="http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=29">http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=29</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>For an overview of other Python versions and bit architectures and their required VC++ and DLL versions, see<a id="id284" class="indexterm"/> this excellent post:</p><p><a class="ulink" href="http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version">http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version</a></p></div></div></li><li class="listitem">Once installed, go to the folder of your new installation, which should be something like <code class="literal">C:\Program Files\Microsoft Visual Studio 9.0\VC\redist\x86\</code>, although this may vary depending on your version and bit-architecture.</li><li class="listitem">Once there, you will <a id="id285" class="indexterm"/>find a folder <a id="id286" class="indexterm"/>called <code class="literal">Microsoft.VC90.CRT</code> containing the following files:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Microsoft.VC90.CRT.manifest</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">msvcm90.dll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">msvcp90.dll</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">msvcr90.dll</code></li></ul></div><p>As part of the free license, Microsoft requires that you include that entire folder with your application, so go ahead and copy it to your <code class="literal">dist</code> folder.</p></li><li class="listitem">Now, your EXE file should always be able to find the required DLLs. If you experience trouble or want more information, check out the DLL section of the official py2exe<a id="id287" class="indexterm"/> tutorial at <a class="ulink" href="http://www.py2exe.org/index.cgi/Tutorial#Step5">http://www.py2exe.org/index.cgi/Tutorial#Step5</a>.</li></ol></div><p>You have now successfully packaged your application and made it portable! Notice how the entire application only weighs a mere 30 MB, making it a breeze to upload, download, or even email. If you built your application and the package using 32-bit Python as recommended, your program should work on any Windows 7 or 8 computer (they are essentially the same in the eyes of Python and EXE files). This includes both 32-bit and 64-bit Windows, since 64-bit code is backwards-compatible with 32-bit code. If you used 64-bit Python, it will only work for those who have 64-bit Windows, which is not ideal.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating an installer"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec38"/>Creating an installer</h1></div></div></div><p>At this point, you <a id="id288" class="indexterm"/>can theoretically slap your <code class="literal">dist</code> folder on a USB stick as a portable GIS application or share it with others by means of a ZIP archive. This is fine up to a certain point, but is not the most professional or credible way to distribute your application if you are aiming for a wider audience. In order to run the application, the user, including yourself, has to locate the EXE file far down the long list of oddly named files they don't understand. This is just too much of the gory details and manual work that should have come straight out of the box.</p><p>More often, people are used to receiving an installer file that guides the user to install the program in a more permanent location and that creates the shortcuts from them. This not only seems more<a id="id289" class="indexterm"/> professional, but also takes care of the more advanced steps for the user. As the final step, we will create such an installer for our GIS application, using the widely recommended installation software <span class="strong"><strong>Inno Setup</strong></span>.</p><div class="section" title="Installing Inno Setup"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec46"/>Installing Inno Setup</h2></div></div></div><p>To install<a id="id290" class="indexterm"/> Inno Setup, use the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go<a id="id291" class="indexterm"/> to <a class="ulink" href="http://www.jrsoftware.org/">http://www.jrsoftware.org/</a>.</li><li class="listitem">Click on the <span class="strong"><strong>Inno Setup</strong></span> link <a id="id292" class="indexterm"/>on the left side.</li><li class="listitem">Click on the <span class="strong"><strong>Downloads</strong></span> link on the left side.</li><li class="listitem">Under the stable heading, download and install the file called <code class="literal">isetup-5.5.5.exe</code>.</li></ol></div></div><div class="section" title="Setting up your application's installer"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec47"/>Setting up your application's installer</h2></div></div></div><p>Once you run the<a id="id293" class="indexterm"/> Inno Setup, you will be prompted with a welcome screen where you<a id="id294" class="indexterm"/> should choose <span class="strong"><strong>Create a new script file using the Script Wizard</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/5407OS_07_04.jpg" alt="Setting up your application's installer"/></div><p>This gives you a <a id="id295" class="indexterm"/>step-by-step wizard, where you will do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the first <a id="id296" class="indexterm"/>screen of the wizard, leave the checkbox unchecked and click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">On the second screen, provide the name and version of the application, as well as the publisher name and a website if applicable.</li><li class="listitem">On the third, screen leave the default install locations.</li><li class="listitem">The fourth screen is the most crucial one: you tell the installer the location of your EXE file and the location of your entire self-contained <code class="literal">dist</code> folder by clicking on <span class="strong"><strong>Add folder</strong></span> (which you should probably rename to the name of your application).</li><li class="listitem">On the fifth screen, leave the default start menu options.</li><li class="listitem">On the sixth screen, you can provide a license text file, and/or some custom information text to display at the beginning and end of the installation.</li><li class="listitem">On the seventh screen, choose the language of the installer.</li><li class="listitem">On the eight screen, set <span class="strong"><strong>Custom compiler output folder</strong></span> to your application name (the name of the program folder once installed), <span class="strong"><strong>Compiler output base file name</strong></span> (the name of the installer file) to <code class="literal">[your-application-name]_setup</code>, and <span class="strong"><strong>Custom Setup icon file</strong></span> to the icon we created earlier.</li><li class="listitem">On the ninth screen, click on <span class="strong"><strong>Finish</strong></span> to create the installer.</li><li class="listitem">When prompted to save the setup script, choose <span class="strong"><strong>Yes</strong></span> and save it alongside your <code class="literal">setup.py</code> script, so you can rebuild or modify the installer later.</li></ol></div><p>With this, you should now<a id="id297" class="indexterm"/> have a setup file bearing your icon that guides the user through installing your newly made GIS application. All of your hard work is now neatly wrapped<a id="id298" class="indexterm"/> into a single file, and can finally be shared and used by a broader audience.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you completed the final packaging step of creating your GIS application. You gave the application a finishing touch by giving it a logo icon to be displayed on the executable file and as part of the application window. We then packaged the application in a self-contained folder that can be run on any Windows 7 or 8 computer (including both 32- and 64-bit systems, provided you used 32-bit Python). Finally, we gave it a professional touch by making an install wizard for a more "official" introduction and installation of your application. The end users of your application do not need to know Python programming or the fact that it was used to make the program. The only thing they need is to run your friendly setup file, and they can begin using your application by clicking on the newly added shortcuts on their Windows desktop or start menu.</p><p>Having completed the steps of making a simple GIS application in Python from start to finish, follow on to the last chapter, as we quickly look back at the lessons learned, and consider possible paths and tips for you to further extend and customize your very own application.</p></div></div>
</body></html>