<html><head></head><body><div><div><div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-148" class="chapterTitle">Simulating Quantum Systems and Noise Models</h1>
    <p class="normal"><strong class="keyWord">Qiskit</strong> is a provider <a id="_idIndexMarker942"/>of high-performance backends that can be used to execute quantum circuits. The various backend simulators available can be used in unique ways where each can provide different information pertaining to your circuit. Qiskit also provides a variety of tools that can be leveraged to construct noise models to simulate various errors that occur on real quantum devices. These tools are very helpful should you need to compare the difference between your results from an ideal simulator and that which replicates the effects of noise from a quantum device.</p>
    <p class="normal">Both the simulators and tools <a id="_idIndexMarker943"/>such as the <strong class="keyWord">noise model</strong> will help you understand the reasons for some of the effects on your results, as well as provide insights should you later want to mitigate those errors yourself.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding the differences between simulators</li>
      <li class="bulletList">Generating noise models</li>
      <li class="bulletList">Building your own noise model</li>
      <li class="bulletList">Executing quantum circuits with custom noise models</li>
    </ul>
    <p class="normal">In this chapter, we will review the Qiskit simulators and understand the differences between each of them and what unique functionality each one provides. We will also delve into the Qiskit noise models that we can generate based on the specified backend devices to allow us to simulate noise on our ideal Qiskit simulators.</p>
    <p class="normal">After reading this chapter, you will be able to reproduce similar noise effects on the simulator. This will allow you to observe how the noise affects our results, which would allow us to simulate a real quantum device. Finally, we will cover how you can create your own noise models and apply them to your circuits.</p>
    <h1 id="_idParaDest-149" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, it is expected that you are familiar with the basics of quantum circuits described in previous chapters, such as creating and executing quantum circuits, obtaining backend properties and configurations, and customizing and visualizing circuit diagrams, and you should have knowledge of qubit logic gate operators and states. Also, some familiarity with noise effects such as decoherence time would be ideal; however, we will cover some of the basics in this chapter as a refresher. You will need to install the latest version of <strong class="keyWord">qiskit-aer</strong> to run <a id="_idIndexMarker944"/>the notebooks in this chapter; details can be found in the Qiskit documentation: <a href="https://qiskit.github.io/qiskit-aer/getting_started.html">https://qiskit.github.io/qiskit-aer/getting_started.html</a>.</p>
    <p class="normal">Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</a>.</p>
    <h1 id="_idParaDest-150" class="heading-1">Understanding the differences between simulators</h1>
    <p class="normal">In this section, you will learn about the various simulator backends that are included in Qiskit Aer, including the <a id="_idIndexMarker945"/>differences between them and their distinct features. Note that you will need to install <strong class="keyWord">qiskit-aer</strong> separately as it is not part of the base Qiskit install.</p>
    <p class="normal">These features include generating noise models and configuring the simulator backends that allow you to take advantage of modifying their behavior and characteristics to suit your needs.</p>
    <p class="normal">We will learn <a id="_idIndexMarker946"/>about the following simulators and their key features:</p>
    <ul>
      <li class="bulletList">The Aer simulator, which executes a quantum circuit with multiple shots to simulate a noisy backend quantum system</li>
      <li class="bulletList">The Statevector simulator, which provides the state vector of the quantum circuit</li>
      <li class="bulletList">The Unitary simulator, which provides the unitary matrix of the quantum circuit being executed</li>
    </ul>
    <p class="normal">Let’s move on and look at the quantum systems, herein referred to as simply backends.</p>
    <h2 id="_idParaDest-151" class="heading-2">Viewing all available backends</h2>
    <p class="normal">If you have read the previous chapters of this book, then you are aware of some of the simulators <a id="_idIndexMarker947"/>we have used. Let’s start off by displaying every simulator available from the various sources.</p>
    <p class="normal">We will create a new <strong class="keyWord">notebook </strong>on IQP and run the autogenerated cell to ensure you have loaded some base classes and methods and loaded your account information so we can access IQP:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by importing some useful classes and functions including, those in the helper file:
        <pre class="programlisting code-one"><code class="hljs-code"># Load helper file and import functions:
%run helper_file_1.0.ipynb
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerProvider, AerSimulator, QasmSimulator, StatevectorSimulator, UnitarySimulator
from qiskit.visualization import *
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options
# Load your IBM Quantum account(s)
service = QiskitRuntimeService(channel="ibm_quantum")
</code></pre>
      </li>
      <li class="numberedList">Next, we’ll display all the available simulators in the Qiskit Aer library by using the following code:
        <pre class="programlisting code-one"><code class="hljs-code"># View all available backends
provider = AerProvider()
provider.backends()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will display a list of all the available simulators:</p>
    <pre class="programlisting code-one"><code class="hljs-code">[AerSimulator('aer_simulator'),
 AerSimulator('aer_simulator_statevector'),
 AerSimulator('aer_simulator_density_matrix'),
 AerSimulator('aer_simulator_stabilizer'),
 AerSimulator('aer_simulator_matrix_product_state'),
 AerSimulator('aer_simulator_extended_stabilizer'),
 AerSimulator('aer_simulator_unitary'),
 AerSimulator('aer_simulator_superop'),
 QasmSimulator('qasm_simulator'),
 StatevectorSimulator('statevector_simulator'),
 UnitarySimulator('unitary_simulator')])]
</code></pre>
    <ol>
      <li class="numberedList" value="3">The following code will list out the simulators that are part of the <code class="inlineCode">Qiskit-Aer</code> library. These are also available as Python built-in simulators, should you not want to install Aer and just use Qiskit. For simplicity and performance considerations, we will be using the Qiskit simulators throughout this book. However, you can certainly interchange the Aer simulators <a id="_idIndexMarker948"/>with those actual quantum systems listed in <code class="inlineCode">service</code> as needed. But since we want to conserve usage time, let’s stick with the simulator for these basic circuits and learning concepts.</li>
      <li class="numberedList">And finally, we can list all the quantum systems available from the Qiskit Runtime Service:
        <pre class="programlisting code-one"><code class="hljs-code"># View all available IBM Quantum backends
service.backends()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will not only list the simulator but also list the real quantum devices available to you based on your account. Those listed will vary based on available devices and upgrades since this writing:</p>
    <pre class="programlisting code-one"><code class="hljs-code">[&lt;IBMBackend('ibm_brisbane')&gt;,
 &lt;IBMBackend('ibm_kyiv')&gt;,
 &lt;IBMBackend('ibm_nazca')&gt;,
 &lt;IBMBackend('ibm_sherbrooke')&gt;,
 &lt;IBMBackend('ibm_kyoto')&gt;,
]
</code></pre>
    <p class="normal">As this chapter is focused on simulators, we will learn about the local simulators that are installed from the Qiskit library going forward. We’ll start with the Aer simulators, which we can use to execute small circuits.</p>
    <h2 id="_idParaDest-152" class="heading-2">Running circuits on the Aer simulator</h2>
    <p class="normal">The <strong class="keyWord">Aer simulator</strong> is not only <a id="_idIndexMarker949"/>used to execute quantum circuits but is also very <a id="_idIndexMarker950"/>versatile because of its ability to apply various simulation methods and configuration options.</p>
    <p class="normal">A few of the available simulation methods are described as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">statevector</code>: This is a statevector simulation within the Aer library that allows ideal <a id="_idIndexMarker951"/>circuit measurements at the end of the quantum circuit. In addition, each shot that executes the circuit can sample random noise from noise models to provide noisy simulations.</li>
      <li class="bulletList"><code class="inlineCode">density_matrix</code>: This method provides a density matrix simulation that like the statevector, samples the quantum circuits with measurements given at the end of each circuit.</li>
      <li class="bulletList"><code class="inlineCode">matrix_product_state</code>: This is a tensor-network statevector simulator that leverages a Matrix Product State as the representation of the state.</li>
      <li class="bulletList"><code class="inlineCode">automatic</code>: If no method is set, then this method will select one automatically based on the number of qubits, the quantum circuit, and the noise model.</li>
    </ul>
    <p class="normal">There are <a id="_idIndexMarker952"/>many backend options available; below is a subset of the available <code class="inlineCode">backend_options</code>:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">device</code>: This sets the simulation device where <code class="inlineCode">CPU</code> is set by default. However, the <code class="inlineCode">statevector</code>, <code class="inlineCode">unitary</code>, and <code class="inlineCode">density_matrix </code>simulators can also <a id="_idIndexMarker953"/>run on systems equipped with an Nvidia <strong class="keyWord">Graphical Processing Unit</strong> (<strong class="keyWord">GPU</strong>). To configure the simulator to a GPU, simply set the options parameter, <code class="inlineCode">device='GPU'</code>.</li>
      <li class="bulletList"><code class="inlineCode">precision</code>: This sets the floating point to either single or double precision; the default is <code class="inlineCode">double</code>. Setting the precision to <code class="inlineCode">single</code> will halve the required memory of the backend, which could provide some performance improvement on certain systems.</li>
      <li class="bulletList"><code class="inlineCode">zero_threshold</code>: This truncates small values to 0 and will truncate very small values. The default truncation value is set to 1e-10, but this can be adjusted to suit the needs of the developer.</li>
      <li class="bulletList"><code class="inlineCode">validation_threshold</code>: This threshold is used to verify if the initial statevector of the quantum circuit is valid, with the default value set to 1x10<sup class="superscript">-8</sup>.</li>
      <li class="bulletList"><code class="inlineCode">max_parallel_threads</code>: Setting this parameter to (the default value) <code class="inlineCode">0</code> enables the simulator to run on all available cores.</li>
      <li class="bulletList"><code class="inlineCode">max_parallel_experiments</code>: The maximum number of <strong class="keyWord">qobj</strong> (<strong class="keyWord">QASM object</strong>), which rep­resents a single payload of a Qiskit provider to run circuits in parallel. The max value cannot exceed the <code class="inlineCode">max_parallel_threads</code> value. If the max is set to <code class="inlineCode">0</code>, it will be set to the <code class="inlineCode">max_parallel_threads</code> value.</li>
      <li class="bulletList"><code class="inlineCode">max_parallel_threads</code>: This sets the maximum number of CPU cores for parallelization. The default value is set to <code class="inlineCode">0</code>, which means it will set it to the maximum number of CPU cores.</li>
      <li class="bulletList"><code class="inlineCode">max_memory_mb</code>: Setting this parameter to <code class="inlineCode">0</code> enables the simulators to maximize the size of system memory to store a state vector; the default value is set to <code class="inlineCode">0</code>. If more memory is needed, an error will be thrown. As a reference, a state vector of n-qubits uses 2<sup class="superscript">n</sup> complex values of approximately 16 bytes.</li>
    </ul>
    <p class="normal">Now that you <a id="_idIndexMarker954"/>have knowledge of the simulation methods and backend options, we’ll create a simple circuit and execute it using Aer’s <code class="inlineCode">QasmSimulator</code> class. For this example, we will create the same circuit example we have been using so far, consisting of Hadamard and CX gates, which places the quantum circuit in a superposition and entangles both qubits together:</p>
    <div><p class="normal">Here, we are creating a 2-qubit and 2-bit circuit; when using the <code class="inlineCode">measure_all()</code> function, we will need to set the <code class="inlineCode">add_bits</code> parameter to <code class="inlineCode">False</code> so that it does not add the classical bits since we have already added them in the <code class="inlineCode">QuantumCircuit</code> constructor.</p>
    </div>
    <pre class="programlisting code"><code class="hljs-code"># Create a quantum circuit
qc = QuantumCircuit(2, 2)
qc.h(0)
qc.cx(0, 1)
qc.measure_all(add_bits=False)
</code></pre>
    <p class="normal">Now, let’s create the Aer simulator using the <code class="inlineCode">get_backend()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"># Instantiate the QASM simulator from the Aer provider
backend_simulator = QasmSimulator()
# Transpile the circuit transpiled_qc = transpile(qc, backend_simulator)
# Run the circuit using the transpiled circuit
job = backend_simulator.run(transpiled_qc)
# Print out the result counts
result = job.result()
counts = result.get_counts(qc)
print(counts)
</code></pre>
    <p class="normal">This will print out the results from executing the quantum circuit on the Aer simulator, with the method set to a state vector, obtaining the result counts.</p>
    <p class="normal">As you can see, this runs the same results as if you ran <code class="inlineCode">aer_simulator</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"># Get the Aer simulator and set the backend options
aer_simulator = AerSimulator(method='statevector')
# Transpile the circuit
transpiled_qc = transpile(qc, aer_simulator) # Run the circuit with the Aer simulator
job = aer_simulator.run(transpiled_qc)
print(job.result().get_counts(qc))
</code></pre>
    <p class="normal">Both forms <a id="_idIndexMarker955"/>execute the circuit in the same manner, with varying values in the results, of course. Here, you can see the results, which both ran a total, 1024 shots, as this is set by default:</p>
    <pre class="programlisting code"><code class="hljs-code">{'00': 501, '11': 523}
</code></pre>
    <p class="normal">We’ll continue by extending the backend options to include other parameters that we might find useful, such as shots and memory, in the next section.</p>
    <h3 id="_idParaDest-153" class="heading-3">Adding parameters to the backend options</h3>
    <p class="normal">We may already be familiar with the <code class="inlineCode">shots</code> parameter, which specifies how many times to execute <a id="_idIndexMarker956"/>the circuit on the backend. However, as illustrated in the previous example, the counts returned are the total values of all the shots, but not in the order in which each result was returned. There may be situations when you would like to examine the results of each shot in chronological order.</p>
    <p class="normal">To examine the measured results that are stored in the individual memory slots, you will need to set the <code class="inlineCode">memory</code> parameter in the backend options. Let’s rerun the previous circuit; however, this time we will set the <code class="inlineCode">memory</code> flag to <code class="inlineCode">True</code> and display the results. We’ll run just 10 shots this time to avoid a very large output string:</p>
    <pre class="programlisting code"><code class="hljs-code"># Run the circuit on the simulator and set the memory to True
# Run the transpiled circuit using the backend options created
job = backend_simulator.run(transpiled_qc, shots=10, memory=True)
result = job.result()
# Pull the memory slots from the results
memory = result.get_memory(transpiled_qc)
# Print the results from the memory slots
print('Memory results: ', memory)
</code></pre>
    <p class="normal">This will output the 10 memory slot entry results from the execution of the circuit. Notice that the results are varying combinations of <code class="inlineCode">00</code> and <code class="inlineCode">11</code>, as expected for the circuit:</p>
    <pre class="programlisting code"><code class="hljs-code">Memory results: ['00', '11', '11', '11', '00', '00', '00', '11', '00', '11']
</code></pre>
    <p class="normal">Having <a id="_idIndexMarker957"/>the memory feature built into the Aer simulator gives you the ability to visualize each result of your circuit count. The next section will illustrate how to initialize and set up all, or just a subset, of the qubits.</p>
    <h3 id="_idParaDest-154" class="heading-3">Initializing the qubits on a circuit</h3>
    <p class="normal">As we learned early on, each qubit is initialized to the ground state, or the <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker958"/> state. However, there may be times when <a id="_idIndexMarker959"/>we would like to set a different initial state. Luckily for us, the Aer simulator allows us to initialize the state of the circuit to some other state, <img src="img/B18420_09_002.png" alt="" width="25" height="25"/><a id="_idIndexMarker960"/> , in lieu of all <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker961"/>states.</p>
    <p class="normal">We will follow the next steps to initialize the qubits:</p>
    <ol>
      <li class="numberedList" value="1">In the previous example, we created a circuit that contained a Hadamard and Control-Not gate to obtain the entangled state results of <img src="img/B18420_09_004.png" alt="" width="33" height="25"/><a id="_idIndexMarker962"/> or <img src="img/B18420_09_005.png" alt="" width="33" height="25"/><a id="_idIndexMarker963"/>. In this example, we will initialize our circuit so that the results are the same without needing to add any gates:
        <pre class="programlisting code-one"><code class="hljs-code"># Construct a 2 qubit quantum circuit
qc_init = QuantumCircuit(2, 2)
# Import numpy to simplify some math for us
import numpy as np
# Select the qubits by their index which you wish to initialize
init_qubits = [0, 1]
# Inititialize qubit states
qc_init.initialize([1, 0, 0, 1] / np.sqrt(2), init_qubits)
# Add measurements and draw the initialized circuit
qc_init.measure(range(2), range(2))
qc_init.decompose()
qc_init.draw(output="mpl")
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This results in the following circuit diagram:</p>
    <figure class="mediaobject"><img src="img/B18420_09_01.png" alt="Diagram  Description automatically generated" width="437" height="253"/></figure>
    <p class="packt_figref">Figure 9.1: Initialized qubits to an initial state other than the zero state</p>
    <p class="normal-one">Notice <a id="_idIndexMarker964"/>that the qubits are collectively initialized into the state of <img src="img/B18420_09_006.png" alt="" width="98" height="35"/><a id="_idIndexMarker965"/>. This circuit now has an initialized state that can be applied to any circuit should you wish a circuit to begin in a state other than the ground/zero state. Initializing a state can be needed when using a variational quantum algorithm that needs to be updated each time it is run to optimize its results.</p>
    <ol>
      <li class="numberedList" value="2">Now, let’s execute this circuit and observe each result:
        <pre class="programlisting code-one"><code class="hljs-code"># Set the memory to True so we can observe each result
result = backend_simulator.run(qc_init, shots=10,
    memory=True).result()
# Retrieve the individual results from the memory slots
memory = result.get_memory(qc_init)
# Print the memory slots
print(memory)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This prints out the following results:</p>
    <pre class="programlisting code-one"><code class="hljs-code">['11', '11', '00', '11', '11', '00', '00', '00', '11', '00']
</code></pre>
    <p class="normal-one">As you can observe from the results, we get only the two initialized state results of either <img src="img/B18420_09_004.png" alt="" width="33" height="25"/><a id="_idIndexMarker966"/> or <img src="img/B18420_09_005.png" alt="" width="33" height="25"/><a id="_idIndexMarker967"/>, as expected.</p>
    <ol>
      <li class="numberedList" value="3">Now, you <a id="_idIndexMarker968"/>don’t have to initialize all qubits in a circuit; you can also specify a group of qubits to initialize, as illustrated in the following code:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a 4 qubit circuit
qc_init2 = QuantumCircuit(4, 4)
# Initialize only the last 3 qubits
initialized_qubits = [1, 2, 3]
# Set the initial state, remember that the sum of # amplitudes-squared must equal 1
qc_init2.initialize([0, 1, 0, 1, 0, 1, 0, 1] / np.sqrt(4), 
                    initialized_qubits)
# Add a barrier so it is easier to read
qc_init2.barrier(range(4))
# Measure qubits, decompose and draw circuit
qc_init2.measure(range(4), range(4))
qc_init2.decompose()
qc_init2.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This results in the following circuit, which initializes the state of the <code class="inlineCode">q_1</code> to <code class="inlineCode">q_3</code> qubits, while all the other qubits that are initialized remain in the ground/zero state:</p>
    <figure class="mediaobject"><img src="img/B18420_09_02.png" alt="Diagram, schematic  Description automatically generated" width="654" height="358"/></figure>
    <p class="packt_figref">Figure 9.2: Initialization of the last three qubits</p>
    <p class="normal-one">Here, our 3-qubit initialized state is set to <img src="img/B18420_09_009.png" alt="" width="208" height="25"/><a id="_idIndexMarker969"/> However, since we are executing a 4-qubit circuit, and we have initialized the last 3 qubits, our results should include the fourth qubit (q<sub class="subscript">0</sub>), which would append a 0 to the least significant bit.</p>
    <ol>
      <li class="numberedList" value="4">Let’s run <a id="_idIndexMarker970"/>the experiment and see whether the initial state of the partial qubits is successful:
        <pre class="programlisting code-one"><code class="hljs-code"># Execute the circuit and print results and histogram
result = backend_simulator.run(qc_init2).result()
counts = result.get_counts(qc_init2)
print(counts)
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As expected, our results are as follows (note that due to the randomness of the circuit, actual results could vary):</p>
    <pre class="programlisting code-one"><code class="hljs-code">{'0010': 275, '1010': 250, '0110': 255, '1110': 244}
</code></pre>
    <p class="normal-one">We also get the following output graph:</p>
    <figure class="mediaobject"><img src="img/B18420_09_03.png" alt="Chart, bar chart  Description automatically generated" width="747" height="520"/></figure>
    <p class="packt_figref">Figure 9.3: Results of initialized quantum circuit</p>
    <p class="normal-one">As you can see, the results are exactly as we expected them to be. Notice that the <a id="_idIndexMarker971"/>least significant bit (the bit on the far right) is always set to 0 as it was not one of the initialized qubits. The other thing to take note of is that the other bits are exactly as we expected, <img src="img/B18420_09_010.png" alt="" width="258" height="25"/><a id="_idIndexMarker972"/>, where the bold indicates the initialized bits, and if you combine them all together, they will provide the results displayed.</p>
    <ol>
      <li class="numberedList" value="5">Now that we have initialized a circuit, we can apply any gate as needed. The only difference is that the gates applied to the circuit after initialization will then be applied to the initialized state of each qubit, rather than the default initialized state <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker973"/>. Let’s test this out by adding a NOT (X) gate to all the qubits. This should result in all the values being flipped:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a 4-qubit circuit
qc_init_x = QuantumCircuit(4, 4)
# Import numpy
import numpy as np
# Initialize the last 3 qubits, same as before
initialized_qubits = [1, 2, 3]
  qc_init_x.initialize([0, 1, 0, 1, 0, 1, 0, 1] /
np.sqrt(4), initialized_qubits)
# Add a barrier so it is easier to read
qc_init_x.barrier(range(4))
# Include an X gate on all qubits
for idx in range(4):
    qc_init_x.x(idx)
# Measure and draw the circuit
qc_init_x.measure(range(4), range(4))
# Decompose the circuit down a level
qc_init_x.decompose()
# Draw the completed circuit
qc_init_x.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This <a id="_idIndexMarker974"/>results in the following circuit:</p>
    <figure class="mediaobject"><img src="img/B18420_09_04.png" alt="Diagram, schematic  Description automatically generated" width="713" height="348"/></figure>
    <p class="packt_figref">Figure 9.4: Initialized quantum circuit with X gates applied to all qubits before measuring</p>
    <p class="normal-one">Notice the initialized qubits are as before, only after the X gates on all qubits that we have added just before measuring. This should result in all bits flipping from 0 to 1, and vice versa.</p>
    <ol>
      <li class="numberedList" value="6">Let’s execute the circuit and display the results using the following code:
        <pre class="programlisting code-one"><code class="hljs-code"># Execute and get counts
result = backend_simulator.run(qc_init_x).result()
counts = result.get_counts(qc_init_x)
print(counts)
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This results exactly as expected; the results are based on the initialized state, followed by the NOT gates being applied on all qubits:</p>
    <pre class="programlisting code-one"><code class="hljs-code">{'0101': 256, '0001': 268, '1101': 232, '1001': 244}
</code></pre>
    <p class="normal-one">We also <a id="_idIndexMarker975"/>get to see the following graph:</p>
    <figure class="mediaobject"><img src="img/B18420_09_05.png" alt="Chart, bar chart  Description automatically generated" width="741" height="534"/></figure>
    <p class="packt_figref">Figure 9.5: Results of the initialized circuit with X gate applied to all qubits</p>
    <p class="normal">The Aer simulator’s ability to be very flexible and configurable means that creating custom circuits with the ability to initialize qubit states is quite an advantage. We will see this in more detail in <em class="chapterRef">Chapter 12</em>, <em class="italic">Understanding Quantum Algorithms</em>, where we will see how this is applied to variational or other hybrid quantum algorithms.</p>
    <p class="normal">Now that we are familiar with the Aer simulator, let’s move on to the statevector simulator and see what unique features we have available.</p>
    <h2 id="_idParaDest-155" class="heading-2">Running circuits on the statevector simulator</h2>
    <p class="normal">The <strong class="keyWord">statevector simulator</strong>, like the Aer simulator, allows you to initialize and execute a quantum circuit. There are of course some distinct differences, one of which is that it returns <a id="_idIndexMarker976"/>the state vector of the quantum circuit by executing a <a id="_idIndexMarker977"/>single shot. This allows you to capture a snapshot of the state vector so you can, in some sense, calculate or observe the expected results on the qubits. Because the statevector simulator simulates the ideal execution of a quantum circuit and results in the final quantum state vector of the device at the end of a simulation, this result can then be used for debugging or educational purposes.</p>
    <p class="normal">We will also leverage some of the Aer visualization tools to help display the state information of the qubits and the quantum circuit. We will follow the next steps to do so:</p>
    <ol>
      <li class="numberedList" value="1">To begin, let’s create a simple 1-qubit circuit and add a Hadamard gate to it so we have a qubit in a superposition:
        <pre class="programlisting code-one"><code class="hljs-code"># Construct quantum circuit
qc = QuantumCircuit(1)
# Place qubit in superposition
qc.h(0)
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of this is as follows, where we have a single qubit in a superposition, that is, a complex linear combination of <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker978"/> and <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker979"/>:</p>
    <figure class="mediaobject"><img src="img/B18420_09_06.png" alt="A picture containing text, clock  Description automatically generated" width="160" height="68"/></figure>
    <p class="packt_figref">Figure 9.6: Single qubit circuit with a Hadamard gate</p>
    <ol>
      <li class="numberedList" value="2">Next, we want to see the state vector representation of the circuit. Before coding it, let’s review the mathematics around it. We know that each basis state is represented by state vectors, such as the following for the <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker980"/> state:</li>
    </ol>
    <p class="center"><img src="img/B18420_05_007.png" alt="" width="73" height="42"/><a id="_idIndexMarker981"/></p>
    <p class="normal-one">Similarly, the <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker982"/> state can be represented by a state vector as follows:</p>
    <p class="center"><img src="img/B18420_09_017.png" alt="" width="73" height="40"/><a id="_idIndexMarker983"/></p>
    <ol>
      <li class="numberedList" value="3">The initial state of a qubit is <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker984"/>. The Hadamard gate generally applies the Hadamard matrix to the current <a id="_idIndexMarker985"/>state of the qubit, which places the qubit into a superposition state. Therefore, if a Hadamard gate is applied to a qubit in the state <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker986"/> the operation would be as follows:</li>
    </ol>
    <p class="center"><img src="img/B18420_09_020.png" alt="" width="344" height="102"/><a id="_idIndexMarker987"/></p>
    <p class="normal-one">Multiplying the matrix by the vector results in the following:</p>
    <p class="center"><img src="img/B18420_09_021.png" alt="" width="188" height="102"/><a id="_idIndexMarker988"/></p>
    <ol>
      <li class="numberedList" value="4">Now, let’s execute our circuit using the state vector simulator and output the state vector values:
        <pre class="programlisting code-one"><code class="hljs-code"># Select the Statevector simulator from the Aer provider
simulator = StatevectorSimulator()
# Transpile the circuit
transpiled_qc = transpile(qc, simulator)
# Run the transpiled circuit
result = simulator.run(transpiled_qc).result()
# Get the state vector and display the results
statevector = result.get_statevector(transpiled_qc)
statevector
</code></pre>
      </li>
    </ol>
    <p class="normal-one">From the results, we can obtain the state vector of the quantum circuit by simply extracting it from the <code class="inlineCode">Job</code> object, in this case, <code class="inlineCode">result.get_statevector()</code>.</p>
    <p class="normal-one">This <a id="_idIndexMarker989"/>should result in the following output that correctly matches our expected results, which include the state vector matrix dimension information, and where the amplitude values in the results are exactly <img src="img/B18420_09_022.png" alt="" width="19" height="35"/><a id="_idIndexMarker990"/>. Furthermore, if we square the amplitudes, the results will provide us with the probability of obtaining a 0 or a 1. The statevector results represent the expected results when applying a Hadamard to an initial state vector <img src="img/_eqn_023.png" alt="" width="35" height="24"/> as we described in step 3:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([0.70710678+0.j, 0.70710678+0.j], dims=(2,))
</code></pre>
    <ol>
      <li class="numberedList" value="5">Let’s extend this by adding another qubit in superposition:
        <pre class="programlisting code-one"><code class="hljs-code"># Construct quantum circuit
qc = QuantumCircuit(2)
# Place both qubits in superposition
qc.h(0)
qc.h(1)
qc.draw()
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result of this circuit is similar to the previous, just with an addition of an added qubit:</p>
    <figure class="mediaobject"><img src="img/B18420_09_07.png" alt="A picture containing text, clock  Description automatically generated" width="152" height="152"/></figure>
    <p class="packt_figref">Figure 9.7: Two qubits in superposition</p>
    <ol>
      <li class="numberedList" value="6">Let’s run this circuit using the state vector simulator and print out the results of our state vector:
        <pre class="programlisting code-one"><code class="hljs-code"># Transpile the circuit
transpiled_qc = transpile(qc, simulator)
# Run the circuit using the state vector simulator
result = simulator.run(transpiled_qc).result()
# Extract the state vector of the circuit from the # results
statevector = result.get_statevector(transpiled_qc)
# Output the state vector values
statevector
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This results <a id="_idIndexMarker991"/>in the following output, which represents equal amplitudes for all 4 possible states, <img src="img/B18420_09_023.png" alt="" width="119" height="25"/><a id="_idIndexMarker992"/>, and <img src="img/B18420_09_005.png" alt="" width="33" height="25"/><a id="_idIndexMarker993"/>:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([0.5+0.j, 0.5+0.j, 0.5+0.j, 0.5+0.j], dims=(2,2))
</code></pre>
    <p class="normal-one">Here, if we square each of the values to obtain the probability measurements, we will see that each has a 25% probability of being correct. Recall that all probabilities must add up to 1.</p>
    <ol>
      <li class="numberedList" value="7">Finally, let’s entangle the qubits and see what the state vector results would be when applying a Hadamard gate to the first qubit:
        <pre class="programlisting code-one"><code class="hljs-code"># Construct quantum circuit
qc = QuantumCircuit(2)
# Place the first qubit in superposition
qc.h(0)
# Entangle the two qubits together using a CNOT gate,
# where the first is the control and the second qubit is
# the target
qc.cx(0, 1)
# Transpile the circuit
transpiled_qc = transpile(qc, simulator)
# Run the circuit on the state vector simulator
result = simulator.run(transpiled_qc).result()
# Obtain the state vector of the circuit
statevector = result.get_statevector(transpiled_qc)
# Output the state vector values
statevector
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The state vector results are as expected, with equal amplitude values of <img src="img/B18420_09_025.png" alt="" width="140" height="29"/><a id="_idIndexMarker994"/> for 00 and 11, and no values <img src="img/B18420_09_026.png" alt="" width="83" height="25"/><a id="_idIndexMarker995"/> for the states 01 and 10:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Statevector([0.70710678+0.j, 0.+0.j, 0.+0.j, 0.70710678+0.j], dims=(2,2))
</code></pre>
    <ol>
      <li class="numberedList" value="8">We can also seek the aid of the visualization tools to help illustrate the state vector results for the circuit we just executed. We will add the <code class="inlineCode">plot_state_city</code> vector function:
        <pre class="programlisting code-one"><code class="hljs-code"># Display state vector
plot_state_city(statevector)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results <a id="_idIndexMarker996"/>are the same values we saw earlier, only here we can see the amplitudes of both the real (left) and imaginary (right) components. When we square the amplitudes of our result, we will get a 50% probability for the 00 and 11 states, which is what we see in the following state vector plot. A state city plot is a term used to describe a view of a 3D bar graph (typically two-dimensional). The term is taken as the bar graphs on the 2D plot look like buildings in a city. In this case, we have two: one to represent the real values and another to represent the imaginary values of our state vectors. </p>
    <p class="normal-one">Note that in our results, we did not have any value in any of the imaginary components of our state vector <code class="inlineCode">1.</code>+<code class="inlineCode">0.j</code>:</p>
    <figure class="mediaobject"><img src="img/B18420_09_08.png" alt="Figure 10.9 – State vector plot with real (left) and imaginary (right) components " width="747" height="266"/></figure>
    <p class="packt_figref">Figure 9.8: State vector plot with real (left) and imaginary (right) components</p>
    <p class="normal-one">The state vector plot helps visualize the density matrix of 2-qubits, which itself has 16 complex qubit amplitudes. The topic of density matrices is outside the scope of this book but in short, it is generally an alternative to express all the quantum states such as <img src="img/_eqn_028.png" alt="" width="59" height="22"/> and <img src="img/_eqn_029.png" alt="" width="67" height="25"/>, where this is the same with respect to the expected measurement outcome but allows us to describe these mathematically using the density matrix.</p>
    <div><p class="normal">Details <a id="_idIndexMarker997"/>describing the density matrix and how it is used can be found in the documentation here: <a href="https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.DensityMatrix">https://docs.quantum.ibm.com/api/qiskit /qiskit.quantum_info.DensityMatrix</a>.</p>
    </div>
    <p class="normal-one">The state <a id="_idIndexMarker998"/>vector plot isn’t the only visualization tool we have available. Another great tool available is the <strong class="keyWord">Qiskit qsphere</strong>. This plots <a id="_idIndexMarker999"/>the state vector onto a two-dimensional graph and includes unique visualization features that allow you to see the probabilistic results and the phase when squaring the amplitudes of the state vector.</p>
    <ol>
      <li class="numberedList" value="9">Let’s plot the probabilistic results from the same state vector on a qsphere:
        <pre class="programlisting code-one"><code class="hljs-code"># Import the plot_state_qsphere class
from qiskit.visualization import plot_state_qsphere
%matplotlib inline
# Create quantum circuit
qc = QuantumCircuit(1)
# Place the qubit in a superposition state
qc.h(0)
# Execute the circuit on the statevector simulator
backend = StatevectorSimulator()
# Tanspile and run the circuit on the statevector simulator
transpiled_qc = transpile(qc, backend)
result = backend.run(transpiled_qc).result()
# Display the QSphere with results from the previous cell
plot_state_qsphere(transpiled_qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Let’s review the results and how they are displayed in the qsphere:</p>
    <figure class="mediaobject"><img src="img/B18420_09_09.png" alt="Chart  Description automatically generated" width="495" height="583"/></figure>
    <p class="packt_figref">Figure 9.9: Qsphere representation of the results after squaring the state vector results</p>
    <p class="normal-one">First, notice the vectors point to the north <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1000"/> state and south <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1001"/> state with the spheres at the end of each vector having equal diameters. This is to illustrate that there is an <a id="_idIndexMarker1002"/>equal probability that the result will either be a 0 or 1, hence they are in superposition, as expected.</p>
    <p class="normal-one">Next, the color of each sphere matches the color corresponding to the phase of the state as described in the phase wheel located at the bottom right of the qsphere. This indicates that each vector is in phase (0°), which corresponds to a blue color. The results here match the expected equation we derived earlier, where we are placing the qubit in a superposition state; however, we have not applied any phase rotations, which are rotations around the <em class="italic">Z</em>-axis in this case:</p>
    <p class="center"><img src="img/B18420_09_029.png" alt="" width="179" height="50"/><a id="_idIndexMarker1003"/></p>
    <p class="normal-one">Let’s do something interesting by introducing a phase shift. As we saw in the preceding screenshot, the vector moves from |0⟩ to |+⟩ in phase (0°) when <a id="_idIndexMarker1004"/>we apply the Hadamard gate. We’ll now include a Z gate, also known as a phase gate, which rotates the vector by an angle of <img src="img/B18420_09_030.png" alt="" width="10" height="25"/><a id="_idIndexMarker1005"/> around the <em class="italic">z</em> axis. As before, we’ll review the mathematics first to confirm what we should expect to see. Recall earlier how we described the effects of applying the Hadamard gate when the state vector originates from |0ñ. The following applies the Hadamard gate to the |1ñ state:</p>
    <p class="center"><img src="img/B18420_09_031.png" alt="" width="344" height="102"/><a id="_idIndexMarker1006"/></p>
    <p class="normal-one">Multiplying the matrix with the vector results produces the following:</p>
    <p class="center"><img src="img/B18420_09_032.png" alt="" width="221" height="102"/><a id="_idIndexMarker1007"/></p>
    <ol>
      <li class="numberedList" value="1">We will create a circuit originating from the <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1008"/> state and apply the H gate to it to confirm the preceding vector results:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a quantum circuit
qc = QuantumCircuit(1)
# Rotate the state from |0&gt; to |1&gt; by applying an X gate
qc.x(0)
# Place qubit in a superposition from the |1&gt; state
qc.h(0)
# Transpile the circuit
transpiled_qc = transpile(qc, backend)
# Run the circuit
result = backend.run(transpiled_qc).result()
# Extract the state vector results and plot them onto the
# QSphere
plot_state_qsphere(result.get_statevector(transpiled_qc))
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The resulting qsphere now has the same probability as before; however, since the rotation originated from the <img src="img/B18420_09_034.png" alt="" width="23" height="25"/><a id="_idIndexMarker1009"/> state, it is now at the <img src="img/B18420_09_035.png" alt="" width="25" height="25"/><a id="_idIndexMarker1010"/> side, therefore out of phase by <img src="img/B18420_09_030.png" alt="" width="10" height="25"/><a id="_idIndexMarker1011"/>, which we can confirm by observing <a id="_idIndexMarker1012"/>the following phase color chart (note that the color representations might change over time. Just compare the color to the color phase wheel for value to color mapping):</p>
    <figure class="mediaobject"><img src="img/B18420_09_10.png" alt="Chart, radar chart  Description automatically generated" width="478" height="547"/></figure>
    <p class="packt_figref">Figure 9.10: A superposition state that is also out of phase by an angle of <img src="img/B18420_09_030.png" alt="" width="10" height="25"/><a id="_idIndexMarker1013"/></p>
    <ol>
      <li class="numberedList" value="2">Now, let’s try the same thing, this time originating from the <img src="img/B18420_09_039.png" alt="" width="23" height="25"/>state:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a quantum circuit
qc = QuantumCircuit(1)
# Place qubit in a superposition from the |0&gt; state
qc.h(0)
# Apply a Z (phase) gate, to rotate it by
# an angle π around the Z axis
qc.z(0)
# Transpile the circuit
transpiled_qc = transpile(qc, backend)
# Run the circuit
result = backend.run(transpiled_qc).result()
# Extract the state vector results and plot them onto the
# QSphere
plot_state_qsphere(result.get_statevector(transpiled_qc))
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results, as we <a id="_idIndexMarker1014"/>can see, are the same – there is a relative phase difference of <img src="img/B18420_09_030.png" alt="" width="10" height="25"/> between the two states, <img src="img/B18420_09_039.png" alt="" width="23" height="25"/><a id="_idIndexMarker1015"/> and <img src="img/B18420_09_034.png" alt="" width="23" height="25"/><a id="_idIndexMarker1016"/> :</p>
    <figure class="mediaobject"><img src="img/B18420_09_11.png" alt="Chart, radar chart  Description automatically generated" width="483" height="549"/></figure>
    <p class="packt_figref">Figure 9.11: A state vector in superposition and out of phase by <img src="img/B18420_09_030.png" alt="" width="10" height="25"/><a id="_idIndexMarker1017"/></p>
    <p class="normal">We can see that the state vector representation illustrates what we see mathematically, which is the following in this case:</p>
    <p class="center"><img src="img/B18420_09_042.png" alt="" width="179" height="50"/><a id="_idIndexMarker1018"/></p>
    <p class="normal">From the <a id="_idIndexMarker1019"/>preceding equation, the negative value represents the out-of-phase component. We will see later on how various quantum algorithms leverage this in order to take advantage of the effects of interference in <em class="chapterRef">Chapter 12</em>, <em class="italic">Understanding Quantum Algorithms</em>.</p>
    <p class="normal">So far, we have seen that we can obtain and visualize the quantum state information from our quantum circuits using the state vector simulator. This allows us to determine whether the state of our circuit is what we are expecting, which helps when we are trying to debug the results of our circuit. We can also visually inspect our quantum circuits using various graphs to review information such as the density matrix and the probabilistic results based on the results from our state vector. Next, we will look at how we can obtain the unitary matrix of our circuit by leveraging the unitary simulator.</p>
    <h2 id="_idParaDest-156" class="heading-2">Running circuits on the unitary simulator</h2>
    <p class="normal">The <strong class="keyWord">unitary simulator</strong> provides the construction of the unitary matrix, <strong class="keyWord">U</strong>, of the circuit. The unitary <a id="_idIndexMarker1020"/>matrix is the operator representation of your quantum circuit, which allows you to determine whether the circuit represents an operator <a id="_idIndexMarker1021"/>you are either trying to replicate or create. The unitary simulator builds out the unitary matrix by stepping through the circuit and applying each gate to the initial state of the circuit. As described in the API documentation (<a href="https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html">https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html</a>), the semantic validations will verify the constraints of the <strong class="keyWord">qobj</strong> and backend options, which are as described as follows:</p>
    <ul>
      <li class="bulletList">The number of shots is set to 1, so only a single shot will be run to calculate the unitary matrix.</li>
      <li class="bulletList">The circuit cannot contain any resets or measurements. Since the unitary simulator’s job is to just calculate the unitary matrix, there is no need to determine the measurement of the circuit.</li>
      <li class="bulletList">No noise models can be applied as it would require working with non-unitaries.</li>
      <li class="bulletList">If the circuit goes beyond any of the preceding constraints, it will raise an <code class="inlineCode">AerError</code>.</li>
    </ul>
    <p class="normal">We will leverage the same circuit we created earlier for the state vector example to run through our unitary simulator so we can compare and contrast the results:</p>
    <ol>
      <li class="numberedList" value="1">First, let’s validate what we should expect to see mathematically. As we will be applying a single Hadamard gate, it should be fairly simple to determine the unitary matrix. Starting from the initial state, we will apply an H gate to the circuit:</li>
    </ol>
    <p class="center"><img src="img/B18420_09_043.png" alt="" width="433" height="102"/><a id="_idIndexMarker1022"/></p>
    <ol>
      <li class="numberedList" value="2">Now, we will <a id="_idIndexMarker1023"/>run our circuit on the unitary simulator, where we will create a quantum circuit and add a Hadamard gate, then set the simulator to the unitary simulator provided by Aer. We should expect to see the same result:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a quantum circuit and add a Hadamard gate
qc = QuantumCircuit(1)
qc.h(0)
# Set the simulator to the UnitarySimulator from the Aer
# provider
simulator = UnitarySimulator()
# Transpile the circuit
transpiled_qc = transpile(qc, simulator)
# Run the circuit on the unitary simulator
result = simulator.run(transpiled_qc).result()
# Extract the unitary matrix from the results
unitary = result.get_unitary(transpiled_qc)
# Print out the unitary matrix representation of the circuit
print("Unitary of the circuit:\n", unitary)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Your unitary results should match the results we calculated mathematically; you can ignore the significantly small numbers in the imaginary component:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Unitary of the circuit:
[[ 0.70710678+0.00000000e+00j 0.70710678-8.65956056e-17j]
[ 0.70710678+0.00000000e+00j -0.70710678+8.65956056e-17j]]
</code></pre>
    <ol>
      <li class="numberedList" value="3">Now, let’s create another circuit, only this time, let’s apply a phase shift after placing our circuit into a superposition. Let’s do this by adding a Z phase gate after the H gate:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a new circuit, adding an H gate followed by a Z gate
qc = QuantumCircuit(1)
qc.h(0)
qc.z(0)
# Transpile the circuit
transpiled_qc = transpile(qc, simulator)
# Run the circuit on the unitary simulator
result = simulator.run(transpiled_qc).result()
# Retrieve the unitary matrix from the results
unitary = result.get_unitary(transpiled_qc)
# Print the unitary matrix representation of the circuit
print("Unitary of the circuit:\n", unitary)
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will <a id="_idIndexMarker1024"/>produce the following unitary matrix representation of the quantum circuit we created. Note the difference in the signs:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Unitary of the circuit:
[[ 0.70710678+0.00000000e+00j 0.70710678-8.65956056e- 17j]
[-0.70710678+0.00000000e+00j 0.70710678-8.65956056e- 17j]]
</code></pre>
    <p class="normal-one">This will also give us the following circuit diagram:</p>
    <figure class="mediaobject"><img src="img/B18420_09_12.png" alt="A picture containing text, clock  Description automatically generated" width="216" height="64"/></figure>
    <p class="packt_figref">Figure 9.12: 2-gate circuit applying an H gate followed by a Z gate</p>
    <p class="normal-one">We can confirm this using a bit of linear algebra. One thing to note is that when we apply gates on a circuit and visualize them, we generally apply them from left to right, as illustrated in the preceding circuit diagram, where we see the <strong class="keyWord">H</strong> gate first, followed by the <strong class="keyWord">Z</strong> gate.</p>
    <ol>
      <li class="numberedList" value="4">However, when calculating the unitary matrix, we place the unitary matrices of each gate we add from right to left. This is the order for the writing convention used to describe the order of applying operations onto an initial state. For example, in this circuit, we calculated the unitary matrix in the following order: first applying the H gate, then the Z gate, so from right to left this results in <strong class="keyWord">ZH = U</strong>, where <strong class="keyWord">U</strong> is the unitary matrix solution. Let’s calculate this matrix now:</li>
    </ol>
    <p class="center"><img src="img/B18420_09_044.png" alt="" width="646" height="102"/><a id="_idIndexMarker1025"/></p>
    <p class="normal">As you can <a id="_idIndexMarker1026"/>see from the preceding equation, we have now confirmed that it is the same result we received from the unitary simulator for this circuit.</p>
    <p class="normal">As with the previous simulators, we can also initialize the unitary simulator with a given unitary matrix. Let’s use the results from the previous example as our initial unitary matrix:</p>
    <pre class="programlisting code"><code class="hljs-code"># Create a quantum circuit
qc_init = QuantumCircuit(1)
# Set the initial unitary using the result from the
# previous example and apply it to q<sub class="subscript">0</sub>
qc_init.unitary(unitary, [0])
# Transpile the circuit
transpiled_qc = transpile(qc_init, simulator)
# Execute and obtain the unitary matrix of the circuit
result = simulator.run(transpiled_qc).result()
# Retrieve the unitary matrix from the result
unitary_result = result.get_unitary(transpiled_qc)
# Print the unitary matrix results representing the
# circuit
print("Unitary of the circuit:\n", unitary_result)
</code></pre>
    <p class="normal">The results from the initialized circuit are now the same as the previous circuit, without the need to add any of the gates used to generate this unitary matrix. The output result is represented as a unitary operator:</p>
    <pre class="programlisting code"><code class="hljs-code">Unitary of the circuit:
 Operator([[ 0.70710678+0.00000000e+00j,  0.70710678+8.65956056e-17j],
          [-0.70710678-8.65956056e-17j,  0.70710678+1.73191211e-16j]],
         input_dims=(2,), output_dims=(2,))
</code></pre>
    <p class="normal">We’ve seen how the unitary simulator is an exceptional component to use should you wish to experiment using a predefined unitary matrix. Using the unitary simulator, we learned how to calculate the unitary operator from a given quantum circuit, and how to create a circuit from a unitary.</p>
    <p class="normal">Now that we have a better understanding of the various simulators and the differences between them, we’ll use them to simulate some of the noise we get when running a circuit on a <a id="_idIndexMarker1027"/>real quantum device. You’ve also learned about the various options and parameters each simulator has available to you so you can leverage each one in multiple ways to obtain various results, such as count and state vector information, from the provided quantum circuit. This will help simulate the results from circuits where noise models affect the outcome, as opposed to the results from running on an ideal, noiseless simulator. So, let’s generate the noise models in the next section.</p>
    <h1 id="_idParaDest-157" class="heading-1">Accounting for noise in quantum circuits</h1>
    <p class="normal">Noise models are used to represent various noise effects that cause errors in quantum circuits. The origin <a id="_idIndexMarker1028"/>of the noise stems from many sources within the quantum system. Based on the currently available devices and those coming in the near future, the number of errors on a device could be significant, depending on the quantum circuit executed on them.</p>
    <p class="normal">In this section, we will review the various types of errors that can affect a qubit, gates, and readouts. We will also learn how to generate noise models either based on the configuration information from the real devices, or noise models created by ourselves, with which we can simulate the real devices using the Aer simulators.</p>
    <h2 id="_idParaDest-158" class="heading-2">Implementing an Aer noise model</h2>
    <p class="normal">We’ll begin <a id="_idIndexMarker1029"/>by demonstrating how to implement the various types of noise models that are prebuilt in the Aer noise libraries that will help make our experiments seem more realistic:</p>
    <ol>
      <li class="numberedList" value="1">We’ll create the same simple circuit we have used in most of our examples, the Bell state, which includes a Hadamard and CNOT gate, followed by a set of measurement operators, and execute it on an ideal simulator, with no errors. This should result in the expected values of 00 and 11:
        <pre class="programlisting code-one"><code class="hljs-code"># Create a 2-qubit circuit
qc = QuantumCircuit(2, 2)
# Add some arbitrary gates and measurement operators
qc.h(0)
qc.cx(0, 1)
qc.measure([0, 1], [0, 1])
backend = AerSimulator()
# Transpile the circuit
transpiled_qc= transpile(qc, backend)
# Run the circuit on the Aer simulator
result = backend.run(transpiled_qc).result()
# Obtain and counts
counts = result.get_counts(transpiled_qc)
# Plot the count results on a histogram
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results <a id="_idIndexMarker1030"/>from this circuit on an ideal simulator are as follows. Notice we only obtain two values, 00 and 11, as expected:</p>
    <figure class="mediaobject"><img src="img/B18420_09_13.png" alt="Figure 10.14 – Results from an ideal simulator with no effects of noise " width="568" height="385"/></figure>
    <p class="packt_figref">Figure 9.13: Results from an ideal simulator with no effects of noise</p>
    <ol>
      <li class="numberedList" value="2">Now we will execute the same circuit on an actual device instead of a simulator. To save time, let’s find the least busy device that has enough qubits to run our experiment as well. Keep in mind the time to complete this on a <a id="_idIndexMarker1031"/>quantum system may vary depending on your position in the queue:
        <pre class="programlisting code-one"><code class="hljs-code"># Let's set the number of qubits needed and get the least busy
num_qubits = 2
backend = service.least_busy(min_num_qubits = num_qubits, simulator = False, operational=True)
# Transpile the circuit
transpiled_qc = transpile(qc, backend)
# Run the circuit
options = Options(optimization_level=0)
shots=1000
with Session(service=service, backend=backend) as session:
    sampler = Sampler(session=session, options=options)
    job = sampler.run(circuits=transpiled_qc, shots=shots)
    result = job.result()
    print('Quasi dist results: ', result.quasi_dists[0])
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The results are very similar to that of the earlier execution on the simulator, only this time, notice there are some errors in the results. Rather than only obtaining results of <strong class="keyWord">0</strong> and <strong class="keyWord">3</strong>, we see a few instances of <strong class="keyWord">1</strong> and <strong class="keyWord">2</strong>. These are the effects of backend noise on the results of the circuit:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Quasi distribution results:  {0: 0.49323295547592433, 1: 0.01753366164023622, 2: -0.009464115736336355, 3: 0.49869749862017565}
</code></pre>
    <ol>
      <li class="numberedList" value="3">Now, let’s do something interesting. Let’s make use of a noise model based on the properties of a specific backend device. Aer’s <code class="inlineCode">NoiseModel</code> provides the ability to do this with a simple method call.</li>
    </ol>
    <pre>ibmq_kyoto</code> and its properties: <code class="inlineCode">coupling_map</code>, which describes how the qubits are physically connected to each other on the physical device, and the available basis gates. When executing the quantum circuit, we will provide the noise model, <code class="inlineCode">coupling_map</code>, and basis gates. This way, when executing <a id="_idIndexMarker1032"/>the quantum circuit on the simulator, it will simulate the results as experiencing the same effects that would occur when running the circuit on a real device, noise and all:</pre>
    <pre class="programlisting code-one"><code class="hljs-code"># Import the NoiseModel
from qiskit_aer.noise import NoiseModel
# Obtain an available backend to simulate
backend = service.get_backend('ibm_kyoto')
# Create the noise model based on the backend properties
noise_model = NoiseModel.from_backend(backend)
# Get coupling map from backend
coupling_map = backend.configuration().coupling_map
# Get basis gates from noise model
basis_gates = noise_model.basis_gates
# Get the Aer simulator to apply noise model
noisy_simulator = AerSimulator()
# Execute the circuit on the simulator with the backend
# properties, and generated noise model
result = noisy_simulator.run(transpiled_qc,
                 coupling_map=coupling_map,
                 basis_gates=basis_gates,
                 noise_model=noise_model).result()
# Obtain and print results
counts = result.get_counts()
plot_distribution(counts)
</code></pre>
    <p class="normal">The following plot of the results of the preceding code, as you can see, is not as ideal as before. We can observe a few errors here:</p>
    <figure class="mediaobject"><img src="img/B18420_09_14.png" alt="Figure 10.16 – Results from a simulator with noise effects based on a specified backend " width="562" height="378"/></figure>
    <p class="packt_figref">Figure 9.14: Results from a simulator with noise effects based on a specified backend</p>
    <p class="normal">Now that <a id="_idIndexMarker1033"/>we can simulate the effects of noise from a backend system onto a simulator, let’s develop an understanding of what the cause is of some of these noise effects.</p>
    <h2 id="_idParaDest-159" class="heading-2">Tracing the source of noise</h2>
    <p class="normal">When executing quantum circuits on a real device, there are various effects that can cause errors in our computations. In this section, we will review some of those effects so that when you’re generating or building your noise models, you will have a better understanding of how they affect each qubit.</p>
    <h3 id="_idParaDest-160" class="heading-3">Understanding decoherence</h3>
    <p class="normal"><strong class="keyWord">Decoherence</strong> is defined as <a id="_idIndexMarker1034"/>the loss of quantum coherence due to a quantum system’s physical interaction with its environment. Decoherence affects each qubit in many ways, one of which is when each qubit starts in a <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1035"/> ground state, and we operate on the qubit to move it from the <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1036"/> state to the <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1037"/> state. For example, we say the qubit has transitioned from the ground state, <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1038"/>, to the excited state, <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1039"/>. An analogy for this is to think of yourself sitting peacefully and perfectly at rest. This peaceful relaxed moment is you in the ground state.</p>
    <p class="normal">Then, imagine someone jumping out of nowhere and screaming at you! You’re immediately startled as your heart rate jumps up and your adrenaline kicks in. This is you now in the excited state. Now, after telling the person who startled you to never do that again, you manage to catch your breath and get your heart rate down. You begin to relax and get your body back down to the grounded state it was in before. The time required to change <a id="_idIndexMarker1040"/>from the excited state to the grounded state is, coincidentally, called the style <strong class="keyWord">relaxation time</strong>. Of course, one very important thing to note is that while it is ideal for us as humans to quickly get back to our relaxed state, for a quantum system, it is ideal for this time to stay in the set state for as long as possible. This will <a id="_idIndexMarker1041"/>ensure that whichever state we place a qubit in, it maintains that state as long as possible. </p>
    <p class="normal">The relaxation time, denoted as <strong class="keyWord">T</strong><sub class="subscript">1</sub>, is the time constant of the longitudinal loss (oriented along the <em class="italic">z</em> axis) of the signal intensity. Another decoherence effect is <strong class="keyWord">dephasing</strong>, denoted as <strong class="keyWord">T</strong><sub class="subscript">2</sub>, where the phase information spreads out widely so that the phase information is lost. We will cover details on how the information is lost in the next chapter. An example of this is if we set the qubit to the <img src="img/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1042"/> state. The dephasing time is a decay constant time where the initial state decays down to a mixed state of <img src="img/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1043"/> and <img src="img/B18420_09_052.png" alt="" width="25" height="25"/><a id="_idIndexMarker1044"/>, where it is difficult to predict the state of the system and is not perfectly in a superposition state and tends to collapse.</p>
    <p class="normal">There are two ways to measure T<sub class="subscript">1</sub> and T<sub class="subscript">2</sub> decoherence times:</p>
    <ul>
      <li class="bulletList">To measure T<sub class="subscript">1</sub>, you would apply a series of pulses separated by a fixed time delay and capture the statistical results of the state as it moves from <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1045"/>to <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1046"/>. The oscillations that show up in the measurements after applying pulses of varying lengths or amplitudes <a id="_idIndexMarker1047"/>are called <strong class="keyWord">Rabi oscillations</strong>.</li>
      <li class="bulletList">To measure T<sub class="subscript">2</sub>, you would set the state of the qubit to <img src="img/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1048"/> or <img src="img/B18420_09_052.png" alt="" width="25" height="25"/><a id="_idIndexMarker1049"/>, and then apply <img src="img/B18420_06_041.png" alt="" width="13" height="25"/><a id="_idIndexMarker1050"/> pulses at sequences to apply a phase rotation. After applying a particular sequence of pulses over time, the state should return to its original position, that is, <img src="img/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1051"/> or <img src="img/B18420_09_052.png" alt="" width="25" height="25"/><a id="_idIndexMarker1052"/>. If dephasing occurs, then the result will have a lower probability of returning to its original starting position. This technique <a id="_idIndexMarker1053"/>of measuring T<sub class="subscript">2</sub> is called a <strong class="keyWord">spin echo</strong>.</li>
    </ul>
    <p class="normal">Now that we <a id="_idIndexMarker1054"/>are a bit more familiar with the sources of noise, let’s shift our discussion to the contributors to decoherence and how they vary based on their sources. There are generally two source types – <strong class="keyWord">intrinsic</strong> and <strong class="keyWord">extrinsic</strong>:</p>
    <ul>
      <li class="bulletList">Intrinsic noise, often <a id="_idIndexMarker1055"/>regarded as generic in nature, originates from sources within the system, such as temperature, or defects within the system, so essentially, materials or defects.</li>
      <li class="bulletList">Extrinsic noise <a id="_idIndexMarker1056"/>originates from environmentally coupled systems such as wave interference, vibrations, and electromagnetic fields.</li>
    </ul>
    <p class="normal">Let’s run a quick example of thermal relaxation on a pair of qubits as this is generally intrinsic to a qubit. In the following example, we will define our T<sub class="subscript">1</sub> and T<sub class="subscript">2</sub> values in seconds and apply them to a set of basis gates for all qubits. These values can be set to whatever time constant you wish; the time value provided in the backend properties is stated as an average so it is not likely your results would be the same each time. One thing to note is that the parameters you set must be true for the following, <img src="img/B18420_09_060.png" alt="" width="73" height="25"/><a id="_idIndexMarker1057"/>, otherwise an error will be thrown. We’ll then run a sample circuit with these thermal relaxation errors to see the difference. The circuit that we will create and execute will be the same Bell state circuit we created earlier and ran on a simulator, so we can compare the results:</p>
    <pre class="programlisting code"><code class="hljs-code"># Initialize your T1 and T2 time constant values in seconds
t1 = 0.0125 
t2 = 0.0025  
# Apply the T1 and T2 to create the thermal relaxation error
from qiskit_aer.noise import thermal_relaxation_error
t_error = thermal_relaxation_error(t1, t2, 0.01)
# Add the errors to a noise model
# and apply to all basis gates on all qubits
noise_model = NoiseModel()
noise_model.add_all_qubit_quantum_error(t_error, ['id', 'rz', 'sx','u1', 'u2', 'u3'])
# Print out the noise model
print(noise_model)
#Create the same 2-qubit quantum circuit as before
qc_error = QuantumCircuit(2,2)
qc_error.h(0)
qc_error.cx(0,1)
qc_error.measure(range(2), range(2))
# Set the simulator
simulator = QasmSimulator()
# Transpile the circuit
transpiled_qc = transpile(qc_error, simulator)
# Apply the noise model we created and run the circuit
result = simulator.run(transpiled_qc, shots=1024, basis_gates=noise_model.basis_gates, noise_model=noise_model).result()
# Obtain result counts
counts = result.get_counts(transpiled_qc)
# Plot the result counts
plot_distribution(counts)
</code></pre>
    <p class="normal">The <code class="inlineCode">NoiseModel</code> output provides a description of the noise model by indicating which basis gates are available, which gate instructions would be affected by the noise, and which basis <a id="_idIndexMarker1058"/>gates errors are applied to the qubits. Keep in mind, that the results may vary based on available backend systems:</p>
    <pre class="programlisting code"><code class="hljs-code">NoiseModel:
  Basis gates: ['cx', 'id', 'rz', 'sx', 'u1', 'u2', 'u3']
  Instructions with noise: ['sx', 'id', 'u1', 'u3', 'u2', 'rz']
  All-qubits errors: ['id', 'rz', 'sx', 'u1', 'u2', 'u3']
</code></pre>
    <p class="normal">As you will see, the results after executing this circuit on the simulator with the generated noise are not quite the same as before. In the earlier case, without errors, we had a very close 50/50 split between <strong class="keyWord">00</strong> and <strong class="keyWord">11</strong>. However, as you can see in the following screenshot, the result is more of a 75/25 split between <strong class="keyWord">00</strong> and <strong class="keyWord">11</strong>. This, of course, is due to the thermal relaxation error we added to the simulator, thus causing much of the results to encounter a relaxation from the excited state to the ground state, as illustrated in the following plot:</p>
    <figure class="mediaobject"><img src="img/B18420_09_15.png" alt="Figure 10.17 – Results on a simulator with thermal relaxation errors " width="573" height="404"/></figure>
    <p class="packt_figref">Figure 9.15: Results on a simulator with thermal relaxation errors</p>
    <p class="normal">Both T<sub class="subscript">1</sub> and T<sub class="subscript">2</sub> are environmental <a id="_idIndexMarker1059"/>effects that act upon the qubits and their ability to maintain their states. Other effects that contribute to the overall noise of a system are contributed by the gates that manipulate the qubits. Let’s look at a few of them now.</p>
    <h3 id="_idParaDest-161" class="heading-3">Understanding single-gate, multi-gate, and readout errors</h3>
    <p class="normal"><strong class="keyWord">Single-gate errors</strong> and <strong class="keyWord">multi-gate errors</strong> are generally introduced when a qubit is operated <a id="_idIndexMarker1060"/>upon by the various gates on the system. These errors are based on probabilities that the gate applied to the qubit may not operate exactly as <a id="_idIndexMarker1061"/>expected. For example, if we apply a 5% gate error probability to a single-qubit gate such as a NOT gate, then the result of the operation has a 5% probability of not resulting in the expected value. The single-gate error could be from poor <a id="_idIndexMarker1062"/>gate fidelity, whereas the multi-gate error could be from crosstalk or spectator noise from neighboring qubits, or from the physical connection <a id="_idIndexMarker1063"/>between the qubits. The Aer library has a list of noise model methods <a id="_idIndexMarker1064"/>to choose from, including <strong class="keyWord">Pauli error</strong>, <strong class="keyWord">depolarizing error</strong>, <strong class="keyWord">amplitude damping error</strong>, and many more for us to use.</p>
    <p class="normal">Single-gate and <a id="_idIndexMarker1065"/>multi-gate errors can be applied to all qubits at once using the <code class="inlineCode">add_all_qubit_quantum_error()</code> method contained in the <code class="inlineCode">NoiseModel</code> class. This method applies a quantum error object to the noise model for the specified basis gates, which is then applied to all qubits. The first argument is the quantum error, and the second is the list of basis gates to apply the error to.</p>
    <p class="normal"><strong class="keyWord">Readout errors</strong> are those <a id="_idIndexMarker1066"/>that occur when a measurement and acquisition are triggered to read out the value of the qubit. During the operations of measuring and acquiring the signal from the qubit, errors can exist that may interfere with the results of the qubit measurement. The <code class="inlineCode">NoiseModel</code> class also has methods available to add readout errors to the noise model.</p>
    <p class="normal">Let’s build our own noise model with single-qubit, multi-qubit, and readout errors on a circuit to observe the effects of these errors on our quantum circuit.</p>
    <h2 id="_idParaDest-162" class="heading-2">Building your own noise model</h2>
    <p class="normal">There may be times when you wish to build your own custom noise models. Whether it’s to generate <a id="_idIndexMarker1067"/>specific errors to test your error-mitigation methods or to create something resembling a specific device, having the ability to customize your own noise model is a handy feature to have available.</p>
    <p class="normal">In the following steps, we will set the single- and multi-qubit errors and view the results. We will then set the readout errors and run them on the same circuit just to visualize the difference in the results when measurement errors are introduced to an ideal system. The single-qubit error will have an amplitude dampening error, the multi-qubit error will have a depolarizing error, and the readout error will be applied to both qubits in the circuit:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by defining our quantum circuit and transpiling it with the simulator:
        <pre class="programlisting code-one"><code class="hljs-code"># Create quantum circuit qc_error = QuantumCircuit(2,2)qc_error.h(0)qc_error.cx(0,1)qc_error.measure(range(2), range(2))# Let's get the qasm simulator
simulator = QasmSimulator()# Transpile the circuit
transpiled_qc = transpile(qc_error, simulator)
</code></pre>
      </li>
      <li class="numberedList">Next, we’ll begin by defining the single- and multi-qubit probability error values, followed by initializing and setting the depolarizing errors, first to the single qubit, and then to the multi-qubit error:
        <pre class="programlisting code-one"><code class="hljs-code"># Import the error classes and methods
from qiskit_aer.noise import depolarizing_error
from qiskit_aer.noise import ReadoutError
# Single and multi-qubit probability error
single_qubit_gate_p = 0.25 
multi_qubit_gate_p = 0.1  
# Apply the depolarizing quantum errors
single_error = depolarizing_error(single_qubit_gate_p, 1)
multi_error = depolarizing_error(multi_qubit_gate_p, 2)  
</code></pre>
      </li>
      <li class="numberedList">Next, we will create our <code class="inlineCode">NoiseModel</code> object and add both the single- and multi-qubit errors. The single qubit error will be assigned to the basis gate <code class="inlineCode">u2</code>, and the multi-qubit error will be assigned to the CNOT (<code class="inlineCode">cx</code>) gate:
        <pre class="programlisting code-one"><code class="hljs-code"># Add the single and multi-qubit errors to the noise # model
noise_model = NoiseModel()
noise_model.add_all_qubit_quantum_error(single_error, ['u2'])
noise_model.add_all_qubit_quantum_error(multi_error, ['cx'])
# Print out the noise model
print(noise_model)
</code></pre>
      </li>
      <li class="numberedList">We’ll now <a id="_idIndexMarker1068"/>print out the <code class="inlineCode">NoiseModel</code> to confirm out noise model entries are set. As we can see from the output of the noise model, we have a list of all basis gates available, a list of instructions that have been assigned noise, and a list of all the basis states that will affect all of the qubits in our circuit:
        <pre class="programlisting code-one"><code class="hljs-code">NoiseModel:
  Basis gates: ['cx', 'id', 'rz', 'sx', 'u2']
  Instructions with noise: ['u2', 'cx']
  All-qubits errors: ['u2', 'cx']
</code></pre>
      </li>
      <li class="numberedList">Now, let’s add this to our simulator and run it with both the single and multi-qubit noise model:
        <pre class="programlisting code-one"><code class="hljs-code"># Run the circuit on the simulator with the noise model
result = simulator.run(transpiled_qc, shots=1024, basis_gates=noise_model.basis_gates, noise_model=noise_model).result() # Obtain the counts and plot the results
counts = result.get_counts(transpiled_qc)plot_distribution(counts)
</code></pre>
      </li>
      <li class="numberedList">This will result in the following histogram: </li>
    </ol>
    <figure class="mediaobject"><img src="img/B18420_09_16.png" alt="Chart, bar chart  Description automatically generated" width="639" height="438"/></figure>
    <p class="packt_figref">Figure 9.16: Results on a simulator with single and multi-qubit errors</p>
    <ol>
      <li class="numberedList" value="7">As you can see, the errors we introduced had an effect on our results and we now get some unexpected values, 01 and 10, which we didn’t expect or see in our <a id="_idIndexMarker1069"/>ideal case when running on a system with no noise. However, even with the noise, we can see that our results are correct in that we still have a high probability of the states 00 and 11. So here, the noise is minimal so that we can get some good results. Let’s try a different error next and increase the noise to see what we get when we have very noisy readout errors.</li>
      <li class="numberedList">Next, let’s include some readout errors. Readout errors are defined in the Aer API documentation as follows:</li>
    </ol>
    <p class="normal-one"><em class="italic">Classical readout errors are specified by a list of assignment probabilities vectors P(A|B), where A is the recorded classical bit value, and B is the true bit value returned from the measurement.</em></p>
    <p class="normal-one">This means that the probabilities of the expected values will be recorded and used to apply readout errors based on the probability values we pass in as arguments to the noise model.</p>
    <p class="normal-one">The equation for a single-qubit readout probability vector is defined as follows:</p>
    <p class="center"><img src="img/B18420_09_061.png" alt="" width="227" height="25"/><a id="_idIndexMarker1070"/></p>
    <p class="normal-one">When constructing the <code class="inlineCode">ReadoutError</code> class, P(A|B) is provided as the argument. For our example, we will provide the probability of 0 given 1 as <code class="inlineCode">0.7</code>, and the probability of 1 given 0 as <code class="inlineCode">0.2</code>. We will also add our readout error to the <a id="_idIndexMarker1071"/>noise model and print out the results, as illustrated in the following code:</p>
    <div><p class="normal">Note, of course, that these values we are setting are very high and do not necessarily need to add up to 1. I’m using them to highlight the impact noise has, in this case, in a very exaggerated yet visually recognizable way to see that the errors are actually pulling the results away from the expected values into the biased values.</p>
    </div>
    <pre class="programlisting code-one"><code class="hljs-code"># Set the readout error probabilities for 0 given 1,
# &amp; 1 given 0,
p0_1 = 0.7
p1_0 = 0.2
p0 = 1 – p1_0
p1 = 1 - p1_1 # Construct a noise model
noise_model = NoiseModel()
# Construct the ReadoutError with the probabilities
readout_error = ReadoutError([[p0, p1_0], [p0_1, p1]])
# Apply the readout error to all qubits
noise_model.add_all_qubit_readout_error(readout_error)
# Print the noise model
print(noise_model)
</code></pre>
    <p class="normal-one">We will see the addition of some instructions and listings of qubits in the result. The first line specifies <code class="inlineCode">Basis gates</code>, and the following line is the list of <code class="inlineCode">Instructions with noise</code> added to them. Notice that it now only includes the <code class="inlineCode">measure</code> instruction. Next, we see the qubits that have been specified for a particular noise – in this case, we added the readout error to all qubit measurement operators:</p>
    <pre class="programlisting code-one"><code class="hljs-code">NoiseModel:
  Basis gates: ['cx', 'id', 'rz', 'sx']
  Instructions with noise: ['measure']
  All-qubits errors: ['measure']
</code></pre>
    <p class="normal">Now that we have our readout noise model complete, we’ll add our custom noise model and run it on the Aer simulator to see the results.</p>
    <p class="normal">Similar to the <a id="_idIndexMarker1072"/>previous example, where we included a thermal relaxation noise model, we will provide the readout noise model in the same manner:</p>
    <pre class="programlisting code"><code class="hljs-code"># Run the circuit with the readout error noise model
result = simulator.run(transpiled_qc, shots=1024,      basis_gates=noise_model.basis_gates, noise_model=noise_model).result()
# Obtain the result counts and print
counts = result.get_counts(transpiled_qc)
plot_distribution(counts)
</code></pre>
    <p class="normal">The results, as you can see in the following plot, are now not as ideal as before:</p>
    <figure class="mediaobject"> <img src="img/B18420_09_17.png" alt="Chart, bar chart  Description automatically generated" width="672" height="461"/></figure>
    <p class="packt_figref">Figure 9.17: Result with effects from our custom noise model on a quantum circuit</p>
    <p class="normal">We can observe various errors here, caused by the readout noise. First and foremost, our expected results of <strong class="keyWord">00</strong> and <strong class="keyWord">11</strong> are no longer easily visible from our results. In this sense, we see that the readout of each qubit has a higher probability of 0 given 1, which therefore causes the probability results to be higher for the values <strong class="keyWord">00</strong>,<strong class="keyWord"> 01</strong>, and <strong class="keyWord">10</strong>. This is caused by the readout errors that are applied to all the qubits, which greatly reduces the probability of 1.</p>
    <p class="normal">The advantage of all this noise is that you have an insight as to the cause of this noise based on the type of noise we included, and the amount of noise applied to a specified qubit(s). This allows you to simulate certain noise effects should you wish to work on some noise-mitigating techniques.</p>
    <p class="normal">By applying <a id="_idIndexMarker1073"/>noise and understanding its effects, you can create noise-mitigating techniques and verify the results on a simulator. By doing this, you can test various combinations of noise effects, which can help minimize the error rate on some algorithms, and therefore increase the performance of the quantum computer. We will look at noise-mitigating techniques in the next chapter.</p>
    <h1 id="_idParaDest-163" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered various simulators. You now have the skills to leverage various simulators to simulate running circuits on a quantum computer and obtain specific content from the circuits, such as state vectors and unitary matrices.</p>
    <p class="normal">We also covered various visualization techniques. The skills that you have gained will help you visualize the various pieces of information from the simulator, such as visualizing the state and phase information of a qubit using the qsphere and plotting state vector graphs.</p>
    <p class="normal">And finally, we looked into the noise models that Qiskit provides by either extracting the noise from an existing quantum computer or creating our own noise models and applying them to the simulators.</p>
    <p class="normal">In the next chapter, we will learn how to characterize and mitigate noise. This will allow us to optimize the performance of the quantum computer and increase its computational power.</p>
    <h1 id="_idParaDest-164" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">Can you list all the simulators found in the Qiskit Aer module?</li>
      <li class="numberedList">Create a qsphere representation of a qubit on the negative <em class="italic">y</em> axis, creating the state <img src="img/B18420_09_062.png" alt="" width="56" height="34"/><a id="_idIndexMarker1074"/>, using only a single Hadamard gate along with the phase gates.</li>
      <li class="numberedList">When initializing a set of qubits in a circuit, what must the total probability across all states be?</li>
      <li class="numberedList">Can you use the qsphere to visualize both the phase and probability information of a qubit?</li>
      <li class="numberedList">What would happen if you set the depolarization error values close to 1?</li>
      <li class="numberedList">If you applied a readout error equally to all qubits, what results would you expect, and why?</li>
    </ol>
    <h1 id="_idParaDest-165" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_9.xhtml">https://packt.link/3FyN1</a></p>
    <p class="normal"><img src="img/QR_Code2617625996838265931.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>