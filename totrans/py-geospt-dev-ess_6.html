<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Analyzing Geographic Data</h1></div></div></div><p>At some point, after acquiring, preparing, and organizing data to fit your needs, you eventually get to the point where you can actually use this data for some greater good: to form queries, explore, answer questions, test hypotheses, and so on. In this chapter, you will develop some of these capabilities along with their application components, specifically:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Create the analysis functionality:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Overlay summary and distance buffer for vector data</li><li class="listitem" style="list-style-type: disc">Zonal summary statistics for raster data</li></ul></div></li><li class="listitem" style="list-style-type: disc">Add ways to access them through the user interface</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Creating the analysis module</h1></div></div></div><p>We start by creating what <a id="id237" class="indexterm"/>we will call the <code class="literal">app/analyzer.py</code> module with the necessary imports. One in the <code class="literal">vector</code> folder:</p><div><pre class="programlisting">import itertools, operator
from .data import *

import shapely
from shapely.prepared import prep as supershapely</pre></div><p>And one in the <code class="literal">raster</code> folder:</p><div><pre class="programlisting">import itertools, operator
from .data import *
from .manager import *

import PIL.Image, PIL.ImageMath, PIL.ImageStat</pre></div><p>As usual, we must make these new modules importable from their parent packages, to add the following import statement in both <code class="literal">vector/__init__.py</code> and <code class="literal">raster/__init__.py</code>:</p><div><pre class="programlisting">from . import analyzer</pre></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Analyzing data</h1></div></div></div><p>The first half <a id="id238" class="indexterm"/>of this chapter creates the analysis functionality, while the other half weaves the functionality into the application design. Let's begin by making the functionality. This includes overlap summary and buffer for vector data and zonal statistics for raster data.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Vector data</h2></div></div></div><p>For vector data, we will focus <a id="id239" class="indexterm"/>on two commonly used analysis tools: overlap summary and buffer.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec31"/>Overlap summary</h3></div></div></div><p>One of the most basic spatial analysis operations in a GIS is to summarize statistics for a layer of features that touches or overlaps another layer of features. Typical questions to warrant such <a id="id240" class="indexterm"/>analysis include: how many points fall within each country polygon, or what is the sum or average of their values for each country? This type of analysis is typically done using a <em>spatial join</em> tool, with the many-to-one option representing multiple matching features with a summary statistic. These summary statistics are then attached to the original country polygons. A spatial join is not an analysis in itself, it just does the number crunching that the user can later use to analyze, for instance, visually on a map or in a table graph. In my experience, this is one of the most common reasons for using spatial joins, as a preprocessing step, but it is still a crucial part of overlay analysis.</p><p>The following screenshot shows a typical way that overlay analysis can be used to aggregate values and visualize patterns:</p><div><img src="img/5407OS_06_01.jpg" alt="Overlap summary"/></div><p>Since our application is geared more toward less technical users, and we want to make everything as obvious as possible, we make this particular usage of spatial join into a tool of its own and give it <a id="id241" class="indexterm"/>a name that more appropriately describes the analysis end product: overlap summary. The tool has been assigned the data, to group the statistics into the data, containing the values that will be summarized, and a list of fieldname statistic tuples to be calculated in the output, also known as a<a id="id242" class="indexterm"/> <strong>fieldmapping</strong>. Valid statistic values are count, sum, max, min, and average. As an example of a fieldmapping, this tool expects that if we want the output file to calculate the count of major cities and the sum of their populations, we will write it as <code class="literal">[("city_id", "count"), ("city_pop", "sum")]</code>. Note that the fieldmapping follows the usual Python syntax with strings having quote marks around them, which is also how we input them through the user interface later in text. For detecting overlap, we use the Shapely module's <code class="literal">intersects</code> operation. Also note that the use of Shapely's less known <a id="id243" class="indexterm"/>
<code class="literal">prep</code> function (imported as <code class="literal">supershapely</code>) gives incredible speedups for multiple repeated intersect comparisons on the same geometry.</p><p>So, head into <code class="literal">vector/analyzer.py</code> and add the following function:</p><div><pre class="programlisting">def overlap_summary(groupbydata, valuedata, fieldmapping=[]):
    # prep
    data1,data2 = groupbydata,valuedata
    if fieldmapping: aggfields,aggtypes = zip(*fieldmapping)
    aggfunctions = dict([("count",len),
                         ("sum",sum),
                         ("max",max),
                         ("min",min),
                         ("average",lambda seq: sum(seq)/float(len(seq)) ) ])

    # create spatial index
    if not hasattr(data1, "spindex"): data1.create_spatial_index()
    if not hasattr(data2, "spindex"): data2.create_spatial_index()

    # create new
    new = VectorData()
    new.fields = list(data1.fields)
    if fieldmapping: 
        for aggfield,aggtype in fieldmapping:
            new.fields.append(aggfield)

    # for each groupby feature
    for i,feat in enumerate(data1.quick_overlap(data2.bbox)):
        geom = feat.get_shapely()
        geom = supershapely(geom)
        matches = []

        # get all value features that intersect
        for otherfeat in data2.quick_overlap(feat.bbox):        
            othergeom = otherfeat.get_shapely()
            if geom.intersects(othergeom):
                matches.append(otherfeat)

        # make newrow from original row
        newrow = list(feat.row)

        # if any matches
        if matches:
            def make_number(value):
                try: return float(value)
                except: return None
                
            # add summary values to newrow based on fieldmapping
            for aggfield,aggtype in fieldmapping:
                values = [otherfeat[aggfield] for otherfeat in matches]
                if aggtype in ("sum","max","min","average"):
                    # only consider number values if numeric stats
                    values = [make_number(value) for value in values if make_number(value) != None]
                aggregatefunc = aggfunctions[aggtype]
                summaryvalue = aggregatefunc(values)
                newrow.append(summaryvalue)

        # otherwise, add empty values
        else:
            newrow.extend(("" for _ in fieldmapping))

        # write feature to output
        new.add_feature(newrow, feat.geometry)

    return new</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec32"/>Buffer</h3></div></div></div><p>If, in your analysis, you also want to include features that don't necessarily overlap the grouping features but are within a certain distance, then buffering is a good tool to use. A buffer operation is one <a id="id244" class="indexterm"/>where a geometric feature is grown or shrunk by a specified distance. After expanding the geometries to the desired distance, one can then follow up with the previously implemented overlap summary tool and, this way, also include near-overlap features in the statistics. Refer to the following screenshot to see an example of a polygon buffer operation:</p><div><img src="img/5407OS_06_02.jpg" alt="Buffer"/></div><p>We implement this quite simply with Shapely's <a id="id245" class="indexterm"/>
<code class="literal">buffer</code> method, with positive numbers for growing and negative numbers for shrinking. To make it a bit more interesting, we let the user dynamically set the buffer distance based on an expression. The expression should take the form of a string representing Python code, referencing the feature as <strong>feat</strong>, which allows<a id="id246" class="indexterm"/> buffering based on one or more of its attributes or even math expressions. For instance, to buffer a layer of countries based on GDP per capita and scaled down for visibility, we may write something like: <em>(feat['GDP'] / float(feat['population'])) / 500.0</em>.</p><p>Inside <code class="literal">vector/analyzer.py</code>, add the following code:</p><div><pre class="programlisting">def buffer(data, dist_expression):
    # buffer and change each geojson dict in-place
    new = VectorData()
    new.fields = list(data.fields)
    for feat in data:
        geom = feat.get_shapely()
        dist = eval(dist_expression)
        buffered = geom.buffer(dist)
        if not buffered.is_empty:
            geojson = buffered.__geo_interface__
            geojson["type"] = buffered.type
            new.add_feature(feat.row, geojson)
    # change data type to polygon
    new.type = "Polygon"
    return new</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec37"/>Raster data</h2></div></div></div><p>To analyze raster data in our lightweight application, we are somewhat constrained by the speed and <a id="id247" class="indexterm"/>capabilities that our main dependency PIL has to offer. Luckily, there are many hidden gems inside the PIL package, one of them being the <code class="literal">ImageStat</code> module that we use to implement zonal statistics analysis.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Other useful functionalities from the PIL library can be found in its <code class="literal">ImageMath</code> module. This will allow us to produce an output raster based on a math expression combining one or more input raster layers. However, if your application is first and foremost meant for advanced analysis of raster data or satellite imagery, you may want to consider going the GDAL/NumPy/SciPy route. We return to some of these possibilities in the final chapter.</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Zonal statistics</h3></div></div></div><p>Zonal statistics is a <a id="id248" class="indexterm"/>common GIS tool that takes each category or zone from one raster and summarizes the values of overlapping cells from another raster. In a sense, zonal statistics is the raster equivalent of overlap summary. In our implementation, we return both a dictionary containing various statistics for each zone and a copy of the zonal raster, where the value for each zone is based on one of its global summary statistics. The user must specify which band from the zonal and value data to use, and set the<a id="id249" class="indexterm"/> outstat statistics option to one of: <code class="literal">mean</code>, <code class="literal">median</code>, <code class="literal">max</code>, <code class="literal">min</code>, <code class="literal">stdev</code>, <code class="literal">var</code>, <code class="literal">count</code>, or <code class="literal">sum</code>.</p><p>Inside <code class="literal">raster/analyser.py</code> write:</p><div><pre class="programlisting">def zonal_statistics(zonaldata, valuedata, zonalband=0, valueband=0, outstat="mean"):
    """
    For each unique zone in "zonaldata", summarizes "valuedata" cells that overlap "zonaldata".
    Which band to use must be specified for each.

    The "outstat" statistics option can be one of: mean, median, max, min, stdev, var, count, or sum
    """
    # get nullvalues
    nullzone = zonaldata.info.get("nodata_value")

    # position value grid into zonal grid
    (valuedata,valuemask) = valuedata.positioned(zonaldata.width, zonaldata.height,
                                                 zonaldata.bbox)

    # pick one image band for each
    zonalimg = zonaldata.bands[zonalband].img
    valueimg = valuedata.bands[valueband].img

    # create output image, using nullzone as nullvalue
    outimg = PIL.Image.new("F", zonalimg.size, nullzone)

    # get stats for each unique value in zonal data
    zonevalues = [val for count,val in zonalimg.getcolors()]
    zonesdict = {}
    for zoneval in zonevalues:
        # exclude nullzone
        if zoneval == nullzone: continue

        # mask only the current zone
        zonemask = zonalimg.point(lambda px: 1 if px == zoneval else 0, "1")
        fullmask = PIL.Image.new("1", zonemask.size, 0)
        # also exclude null values from calculations
        fullmask.paste(zonemask, valuemask)

        # retrieve stats
        stats = PIL.ImageStat.Stat(valueimg, fullmask)
        statsdict = {}
        statsdict["min"],statsdict["max"] = stats.extrema[0]
        for stattype in ("count","sum","mean","median","var","stddev"):
            try: statsdict[stattype] = stats.__getattr__(stattype)[0]
            except ZeroDivisionError: statsdict[stattype] = None
        zonesdict[zoneval] = statsdict

        # write chosen stat to outimg
        outimg.paste(statsdict[outstat], (0,0), zonemask)

    # make outimg to raster
    outraster = Raster(image=outimg, **zonaldata.info)
        
    return zonesdict, outraster</pre></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Weaving functionality into the user interface</h1></div></div></div><p>Next, let's make the<a id="id250" class="indexterm"/> analysis functionality created so<a id="id251" class="indexterm"/> far accessible in the user interface of our application.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Layer-specific right-click functions</h2></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Managing and Organizing Geographic Data">Chapter 5</a>, <em>Managing and Organizing Geographic Data</em>, we instructed our application that right-clicking a layer in the LayersPane give us a menu of actions to choose from that is specific to that particular layer. In<a id="id252" class="indexterm"/> the current chapter, the only layer-specific functionality we made is the <code class="literal">buffer</code> operation. Therefore, we add the buffer menu option to the <code class="literal">RightClickMenu_VectorLayer</code> class in <code class="literal">app/dialogues.py</code>. Remember to find and save an <code class="literal">app/icons/buffer.png</code> icon so that it can be displayed next to the menu's buffer item:</p><div><pre class="programlisting">        # Buffering
        def open_options_window():
            window = VectorBufferOptionWindow(self.layeritem, self.layerspane, self.layeritem, statusbar)
        self.imgs["buffer"] = icons.get("buffer.png", width=32, height=32)
        self.add_command(label="Buffer", command=open_options_window, image=self.imgs["buffer"], compound="left")</pre></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Defining the tool options windows</h3></div></div></div><p>Still in <code class="literal">app/dialogues.py</code>, we define the layer-specific tool options windows that should pop up. Since they are layer-specific, we add the LayerItem's data as a hidden option that the user <a id="id253" class="indexterm"/>shouldn't worry about setting. The only user input here is the buffer distance expression we introduced earlier based on the units of the data's coordinate reference system, which can be either positive for growing or negative for shrinking. An expression calculator may be a nice touch for the user to add here on their own.</p><div><img src="img/5407OS_06_03.jpg" alt="Defining the tool options windows"/></div><p>Here is the code for the mentioned functionality:</p><div><pre class="programlisting">class VectorBufferOptionWindow(Window):
    def __init__(self, master, layerspane, layeritem, statusbar, **kwargs):
        # Make this class a subclass and add to it
        Window.__init__(self, master, **kwargs)

        # Create runtoolframe
        self.runtool = RunToolFrame(self)
        self.runtool.pack(fill="both", expand=True)
        self.runtool.assign_statusbar(statusbar)

        # Add a hidden option from its associated layeritem data
        self.runtool.add_hidden_option(argname="data", value=layeritem.renderlayer.data)

        # Set the remaining options
        self.runtool.set_target_method("Buffering data...", vector.analyzer.buffer)
        self.runtool.add_option_input(argname="dist_expression",
                              label="Distance calculation",
                              valuetype=str)

        # Define how to process
        def process(result):
            if isinstance(result, Exception):
                popup_message(self, "Failed to buffer the data:" + "\n\n" + str(result) )
            else:
                layerspane.add_layer(result)
                self.destroy()
        self.runtool.set_finished_method(process)</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Setting up the analysis tab</h2></div></div></div><p>Next, we focus on those<a id="id254" class="indexterm"/> tools that should be available in the top ribbon area. First, we go to <code class="literal">app/builder.py</code> in the initialization phase of the GUI class, add a new tab for analysis, and add toolbars and buttons for our remaining<a id="id255" class="indexterm"/> functionality, as shown in the following screenshot:</p><div><img src="img/5407OS_06_04.jpg" alt="Setting up the analysis tab"/></div><p>Here is the code to create the <strong>Analyze</strong> tab:</p><div><pre class="programlisting">        ## Analysis tab
        analysistab = self.ribbon.add_tab("Analyze")
        ### (Vector toolbar)
        vectorfiles = analysistab.add_toolbar("Vector")
        def open_overlapsummary_window():
            window = VectorOverlapSummaryWindow(self, self.layerspane, self.statusbar)
        vectorfiles.add_button(text="Overlap Summary", icon="overlap.png",
                               command=open_overlapsummary_window)
        ### (Raster toolbar)
        rasterfiles = analysistab.add_toolbar("Raster")
        def open_zonalstats_window():
            window = RasterZonalStatsOptionWindow(self, self.layerspane, self.statusbar)
        rasterfiles.add_button(text="Zonal statistics", icon="zonalstats.png",
                               command=open_zonalstats_window)</pre></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec35"/>Defining the tool options window</h3></div></div></div><p>In the tool options window, for overlap summary, we define the standard way in <code class="literal">app/dialogues.py</code>. Note that the process of adding fieldname statistic tuples for the output should ideally be chosen from two drop-down lists (one for available fieldnames and one for available <a id="id256" class="indexterm"/>statistic types). Since we have no such double drop-down widget readily available, we instead settle for having the user spell it out as a tuple with two quote-enclosed strings, which, unfortunately, is not very user friendly. Using double drop-down lists can be an exercise for the reader to implement. Furthermore, since we have no way of visualizing the output data based on their attributes, this method is currently useless within the confines of our application:</p><div><img src="img/5407OS_06_05.jpg" alt="Defining the tool options window"/></div><p>Here is the code to<a id="id257" class="indexterm"/> implement the mentioned functionality:</p><div><pre class="programlisting">class VectorOverlapSummaryWindow(Window):
    def __init__(self, master, layerspane, statusbar, **kwargs):
        # Make this class a subclass and add to it
        Window.__init__(self, master, **kwargs)

        # Create runtoolframe
        self.runtool = RunToolFrame(self)
        self.runtool.pack(fill="both", expand=True)
        self.runtool.assign_statusbar(statusbar)
        
        # Set the remaining options
        self.runtool.set_target_method("Calculating overlap summary on data...", vector.analyzer.overlap_summary)
        def get_data_from_layername(name):
            data = None
            for layeritem in layerspane:
                if layeritem.namelabel["text"] == name:
                    data = layeritem.renderlayer.data
                    break
            return data
        self.runtool.add_option_input(argname="groupbydata",
                              label="Group by data",
                              default="(Choose layer)",
                              choices=[layeritem.namelabel["text"] for layeritem in layerspane],
                              valuetype=get_data_from_layername)
        self.runtool.add_option_input(argname="valuedata",
                              label="Value data",
                              default="(Choose layer)",
                              choices=[layeritem.namelabel["text"] for layeritem in layerspane],
                              valuetype=get_data_from_layername)
        self.runtool.add_option_input(argname="fieldmapping",
                              label="Field mapping",
                              multi=True,
                              valuetype=eval)

        # Define how to process
        def process(result):
            if isinstance(result, Exception):
                popup_message(self, "Failed to calculate overlap summary on data:" + "\n\n" + str(result) )
            else:
                layerspane.add_layer(result, name="overlap summary")
        self.runtool.set_finished_method(process)</pre></div><p>For the zonal<a id="id258" class="indexterm"/> statistics tool, we do the same:</p><div><img src="img/5407OS_06_06.jpg" alt="Defining the tool options window"/></div><p>Here is the code to<a id="id259" class="indexterm"/> implement the mentioned functionality:</p><div><pre class="programlisting">class RasterZonalStatsOptionWindow(Window):
    def __init__(self, master, layerspane, statusbar, **kwargs):
        # Make this class a subclass and add to it
        Window.__init__(self, master, **kwargs)

        # Create runtoolframe
        self.runtool = RunToolFrame(self)
        self.runtool.pack(fill="both", expand=True)
        self.runtool.assign_statusbar(statusbar)
        
        # Set the remaining options
        self.runtool.set_target_method("Calculating zonal statistics on data...", raster.analyzer.zonal_statistics)
        def get_data_from_layername(name):
            data = None
            for layeritem in layerspane:
                if layeritem.namelabel["text"] == name:
                    data = layeritem.renderlayer.data
                    break
            return data
        self.runtool.add_option_input(argname="zonaldata",
                              label="Zonal data",
                              default="(Choose layer)",
                              choices=[layeritem.namelabel["text"] for layeritem in layerspane],
                              valuetype=get_data_from_layername)
        self.runtool.add_option_input(argname="valuedata",
                              label="Value data",
                              default="(Choose layer)",
                              choices=[layeritem.namelabel["text"] for layeritem in layerspane],
                              valuetype=get_data_from_layername)
        self.runtool.add_option_input(argname="zonalband",
                              label="Zonal band",
                              valuetype=int,
                              default=0)
        self.runtool.add_option_input(argname="valueband",
                              label="Value band",
                              valuetype=int,
                              default=0)
        self.runtool.add_option_input(argname="outstat",
                              label="Output Raster Statistic",
                              valuetype=str,
                              default="mean",
                              choices=["min","max","count","sum","mean","median","var","stddev"] )</pre></div><p>However, when it is time to process the zonal statistics results, we not only add the output raster as a layer, but also<a id="id260" class="indexterm"/> pop up a scrollable window displaying the summary statistics for all the zones. To create the scrollable text widget, Tkinter already has a prebuilt scrollable text widget (which for some odd reason is placed in a module of its own, imported here as <code class="literal">tkst</code>), so we use this:</p><div><pre class="programlisting">        # Define how to process
        def process(result):
            if isinstance(result, Exception):
                popup_message(self, "Failed to calculate zonal statistics on the data:" + "\n\n" + str(result) )
            else:
                zonesdict, outraster = result
                # add the resulting zonestatistics layer
                layerspane.add_layer(outraster, name="zonal statistic")
                # also view stats in window
                win = Window()
                textbox = tkst.ScrolledText(win)
                textbox.pack(fill="both", expand=True)
                textbox.insert(tk.END, "Zonal statistics detailed result:")
                textbox.insert(tk.END, "\n------------------------ ---------\n")
                for zone,stats in zonesdict.items():
                    statstext = "\n"+"Zone %i:"%zone
                    statstext += "\n\t" + "\n\t".join(["%s: %f"%(key,val) for key,val in stats.items()])
                    textbox.insert(tk.END, statstext)
        self.runtool.set_finished_method(process)</pre></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we added the bare minimum of basic and commonly used GIS analysis tools. Specifically, we added a flexible buffer tool available when right-clicking on a vector layer, and an analysis tab with one button for overlap summary between vector data, and another button for zonal statistics between raster data.</p><p>However, this is only barely scratching the surface of the types of analyses one can do in a GIS application, and the fun part comes when you choose to take the application further and build additional functionalities. For instance, how you can link tools together to simplify the steps needed and create custom analysis tools that help you, or your intended target audience, become more efficient.</p><p>With the completion of the analysis component of our application, we are left with a very simple but functional GIS application that works, at least for demonstration purposes. In order for the application to be usable outside of our own development environment, especially to non-programmers, you must turn our attention to making it a self-contained application, which is what we will do in the next chapter.</p></div></div>
</body></html>