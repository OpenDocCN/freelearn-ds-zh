["```py\n    # Importing standard Qiskit libraries\n    from qiskit import QuantumCircuit, transpile\n    from qiskit.transpiler.preset_passmanagers import\n                 generate_preset_pass_manager\n    from qiskit.visualization import *\n    from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options\n    service = QiskitRuntimeService(channel=\"ibm_quantum\") \n    ```", "```py\n    # Initialize the 3-qubit quantum circuit\n    # Set the state '110'\n    s = '110'\n    num_qubits = len(s)\n    qc = QuantumCircuit(num_qubits) \n    ```", "```py\n    # Set reverse ordering\n    s = s[::-1]\n    # Construct the state 110\n    for idx in range(num_qubits):\n        if s[idx] == '1':\n            qc.x(idx)   \n    qc.barrier()\n    qc.draw(output='mpl') \n    ```", "```py\n    # Import the value pi for our rotations\n    from numpy import pi\n    # Always start from the most significant qubit,\n    # in this case it's q2.\n    # Step 1, add a Hadamard gate\n    qc.h(2) \n    ```", "```py\n# Step 2, add CROT gates from most significant qubit\nqc.cp(pi/2, 1, 2) \n```", "```py\n    # Step 3, add another CROT from 2 to the next qubit down,\n    # while doubling the phase denominator\n    qc.cp(pi/4, 0, 2)\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Now that we finished from 2 down to 0\n    # We'll drop to the next least significant qubit and\n    # start again,\n    # Step 1, add a Hadamard gate\n    qc.h(1) \n    ```", "```py\n    # Step 2, add Control Rotation (CROT) gates from most\n    # significant towards\n    # least significant starting a pi/2, and doubling the\n    # denominator\n    # as you go down each qubit.\n    qc.cp(pi/2, 0, 1)\n    # Draw the circuit\n    qc.draw(output='mpl')\n    # Now that we finished from 1 down to 0\n    # We'll drop to the next least significant qubit and\n    # start again. \n    ```", "```py\n    # Step 1, add a Hadamard gate\n    qc.h(0)\n    # Since we are at the least significant qubit,\n    # we are done!\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n# Define a function which will add the swap gates to the\n# outer pair of qubits\ndef add_swap_gates(qc_swaps, qubits):\n    for qubit in range(qubits//2):\n        qc_swaps.swap(qubit, qubits-qubit-1)\n    return qc_swaps \n```", "```py\n    qft_circuit = add_swap_gates(qc, num_qubits)\n    qft_circuit.draw(output='mpl') \n    ```", "```py\n    # Run on a local Sampler\n    def run_on_sampler(circuit, shots):\n        from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n        from qiskit_ibm_runtime import SamplerV2 as Sampler\n        from qiskit_ibm_runtime.fake_provider import FakeManilaV2\n        # Run the sampler job locally using FakeManilaV2\n        fake_manila = FakeManilaV2()\n        pass_manager = generate_preset_pass_manager(backend=fake_manila, optimization_level=1)\n        transpiled_qc = pass_manager.run(circuit)\n        # To ensure we get fixed results, set seed\n        options = {\"simulator\": {\"seed_simulator\": 10258}}\n        sampler = Sampler(mode=fake_manila, options=options)\n\n        result = sampler.run([transpiled_qc], shots=shots).result()[0]\n        return result\n    # Run on the least busy quantum computer\n    def run_on_qc(circuit, shots):\n        # At the time of this writing we are using the latest version of \n        # the Sampler primitive (V2), please review the documentation to follow updates if you are using a previous version.\n        from qiskit_ibm_runtime import SamplerV2 as Sampler2\n        # Assign least busy device to backend\n        backend = \n                        service.least_busy(min_num_qubits=circuit.num_qubits,\n                 simulator=False, operational=True)\n        #Print the least busy device\n        print('The least busy device: {}'.format(backend))\n        result = {}\n\n       transpiler = generate_preset_pass_manager(backend=backend, optimization_level=3) \n       transpiled_qc = transpiler.run(circuit)\n       sampler = Sampler2(backend)\n       job = sampler.run([transpiled_qc], shots=shots)\n       job_result = job.result()\n\n       # Extract the results\n       result = job_result[0]\n       return result \n    ```", "```py\n    # Get the state vector simulator to view our final QFT\n    # state\n    from qiskit.quantum_info import Statevector\n    statevector = Statevector(qft_circuit)\n    plot_bloch_multivector(statevector) \n    ```", "```py\nplot_state_qsphere(statevector) \n```", "```py\n    # Set the state we wish to search\n    N = '110'\n    num_qubits = len(N)\n    # Create the quantum circuit\n    qc = QuantumCircuit(num_qubits)\n    # Set all qubits in superposition\n    qc.h(range(num_qubits))\n    qc.barrier()\n    #Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Reverse the state so it's in proper qubit ordering\n    N = N[::-1]\n    # Encode N into our circuit\n    for idx in range(num_qubits):\n        if N[idx] == '0':\n            qc.x(idx)\n    qc.barrier()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Create the Grover oracle for our 3-qubit quantum circuit\n    qc.h(2)\n    qc.ccx(0, 1, 2)\n    qc.h(2)\n    qc.barrier()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Reset the value after the oracle\n    for idx in range(num_qubits):\n        if N[idx] == '0':\n            qc.x(idx)\n    qc.barrier()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Set all qubits in superposition\n    qc.h(range(num_qubits))\n    qc.x(range(num_qubits))\n    qc.barrier()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Apply another oracle, same as the previous\n    qc.h(2)\n    qc.ccx(0, 1, 2)\n    qc.h(2)\n    qc.barrier()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Reapply the X rotations on all qubits\n    qc.x(range(num_qubits))\n    qc.barrier()\n    # Reapply Hadamard gates to all qubits\n    qc.h(range(num_qubits))\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Add measurement operators\n    qc.measure_all()\n    # Draw the circuit\n    qc.draw(output='mpl') \n    ```", "```py\n    # Run on the sampler\n    result = run_on_sampler(qc, shots=4000)\n    counts = result.data.meas.get_counts()\n    # Print and plot results\n    print(counts)\n    plot_distribution(counts) \n    ```", "```py\n{'010': 274, '110': 2237, '000': 198, '100': 499, '101': 175, '111': 238, '001': 191, '011': 188} \n```", "```py\n    # Execute the circuit on the least busy quantum computer\n    backend = service.least_busy(min_num_qubits = num_qubits,\n                                 simulator = False,                    \n                                 operational = True)\n    print(\"Set backend: \", backend) \n    ```", "```py\n    # Run the circuit on the backend\n    shots = 1000\n    results = run_on_qc(qc, shots)\n    counts = results.data.meas.get_counts()\n    # Print results\n    print(counts) \n    ```", "```py\n    The least busy device: <IBMBackend('ibm_osaka')>\n    {'000': 85, '100': 52, '111': 219, '010': 61, '110': 373, '001': 73, '011': 71, '101': 66} \n    ```", "```py\n    # Plot results\n    plot_distribution(counts) \n    ```"]