<html><head></head><body><div><div><div></div>
		</div>
		<div><h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>1. Introduction to Data Wrangling with Python</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter will help you understand the importance of data wrangling in data science. You will gain practical knowledge of how to manipulate the data structures that are available in Python by comparing the different implementations of the built-in Python data structures. Overall, this chapter describes the importance of data wrangling, identifies the important tasks to be performed in data wrangling, and introduces basic Python data structures. By the end of this chapter, you will be adept at working with lists, sets, and dictionaries, which are the key building blocks of data structures in Python.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Introduction</h1>
			<p>Since data science and analytics have become key parts of our lives, the role of a data scientist has become even more important. Finding the source of data is an essential part of data science; however, it is the <em class="italic">science</em> part that makes you – the practitioner – truly valuable.</p>
			<p>To practice high-quality science with data, you need to make sure it is properly sourced, cleaned, formatted, and pre-processed. This book will teach you the most essential basics of this invaluable component of the data science pipeline: data wrangling. In short, data wrangling is the process that ensures that the data is being presented in a way that is clean, accurate, formatted, and ready to be used for data analysis.</p>
			<p>A prominent example of data wrangling with a large amount of data is the analysis conducted at the Supercomputer Center of the <strong class="bold">University of California San Diego</strong> (<strong class="bold">UCSD</strong>) every year. Wildfires are very common in California and are caused mainly by the dry weather and extreme heat, especially during the summers. Data scientists at the UCSD Supercomputer Center run an analysis every year and gather data to predict the nature and spread direction of wildfires in California. The data comes from diverse sources, such as weather stations, sensors in the forest, fire stations, satellite imagery, and Twitter feeds. However, this data might be incomplete or missing.</p>
			<p>After collecting the data from various sources, if it is not cleaned and formatted using ways including scaling numbers and removing unwanted characters in strings, it could result in erroneous data. In cases where we might get a flawed analysis, we might need to reformat the data from <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) into <strong class="bold">Comma Separated Value</strong> (<strong class="bold">CSV</strong>); we may also need the numbers to be normalized, that is, centered and scaled with relation to themselves. Processing data in such a way might be required when we feed data to certain machine learning models.</p>
			<p>This is an example of how data wrangling and data science can prove to be helpful and relevant. This chapter will discuss the fundamentals of data wrangling. Let's get started. </p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Importance of Data Wrangling</h1>
			<p>A common mantra of the modern age is <em class="italic">Data is the New Oil</em>, meaning data is now a resource that's more valuable than oil. But just as crude oil does not come out of the rig as gasoline and must be processed to get gasoline and other products, data must be curated, massaged, or cleaned and refined to be used in data science and products based on data science. This is known as wrangling. Most data scientists spend the majority of their time data wrangling.</p>
			<p>Data wrangling is generally done at the very first stage of a data science/analytics pipeline. After the data scientists have identified any useful data sources for solving the business problem at hand (for instance, in-house database storage, the internet, or streaming sensor data such as an underwater seismic sensor), they then proceed to extract, clean, and format the necessary data from those sources.</p>
			<p>Generally, the task of data wrangling involves the following steps:</p>
			<ol>
				<li>Scraping raw data from multiple sources (including web and database tables)</li>
				<li>Imputing (replacing missing data using various techniques), formatting, and transforming – basically making it ready to be used in the modeling process (such as advanced machine learning)</li>
				<li>Handling read/write errors</li>
				<li>Detecting outliers</li>
				<li>Performing quick visualizations (plotting) and basic statistical analysis to judge the quality of formatted data</li>
			</ol>
			<p>The following is an illustrative representation of the positioning and the essential functional role of data wrangling in a typical data science pipeline:</p>
			<div><div><img src="img/B15780_01_01.jpg" alt="Figure 1.1: Process of data wrangling&#13;&#10;" width="721" height="406"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: Process of data wrangling</p>
			<p>The process of data wrangling includes finding the appropriate data that's necessary for the analysis. Often, analysis is exploratory, so there is not enough scope. You often need to do data wrangling for this type of analysis to be able to understand your data better. This could lead to more analysis or machine learning. </p>
			<p>This data can be from one or multiple sources, such as tweets, bank transaction statements in a relational database, sensor data, and so on. This data needs to be cleaned. If there is missing data, we will either delete or substitute it, with the help of several techniques. If there are outliers, we need to detect them and then handle them appropriately. If the data is from multiple sources, we will have to combine it using Structured Query Language (SQL) operations like JOIN.</p>
			<p>In an extremely rare situation, data wrangling may not be needed. For example, if the data that's necessary for a machine learning task is already stored in an acceptable format in an in-house database, then a simple SQL query may be enough to extract the data into a table, ready to be passed on to the modeling stage.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Python for Data Wrangling</h1>
			<p>There is always a debate regarding whether to perform the wrangling process using an enterprise tool or a programming language and its associated frameworks. There are many commercial, enterprise-level tools for data formatting and preprocessing that do not involve much coding on the user's part. Some of these examples include the following:</p>
			<ul>
				<li>General-purpose data analysis platforms, such as <strong class="bold">Microsoft Excel</strong> (with add-ins)</li>
				<li>Statistical discovery package, such as <strong class="bold">JMP</strong> (from SAS)</li>
				<li>Modeling platforms, such as <strong class="bold">RapidMiner</strong></li>
				<li>Analytics platforms from niche players that focus on data wrangling, such as <strong class="bold">Trifacta</strong>, <strong class="bold">Paxata</strong>, and <strong class="bold">Alteryx</strong></li>
			</ul>
			<p>However, programming languages such as Python and R provide more flexibility, control, and power compared to these off-the-shelf tools. This also explains their tremendous popularity in the data science domain:</p>
			<div><div><img src="img/B15780_01_02.jpg" alt="Figure 1.2: Google trends worldwide over the last 5 years&#13;&#10;" width="960" height="221"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Google trends worldwide over the last 5 years</p>
			<p>Furthermore, as the volume, velocity, and variety (the three Vs of <strong class="bold">big data</strong>) of data undergo rapid changes, it is always a good idea to develop and nurture a significant amount of in-house expertise in data wrangling using fundamental programming frameworks so that an organization is not beholden to the whims and fancies of any particular enterprise platform for as basic a task as data wrangling.</p>
			<p>A few of the obvious advantages of using an open source, free programming paradigm for data wrangling are as follows:</p>
			<ul>
				<li>A general-purpose open-source paradigm puts no restrictions on any of the methods you can develop for the specific problem at hand.</li>
				<li>There's a great ecosystem of fast, optimized, open-source libraries, focused on data analytics.</li>
				<li>There's also growing support for connecting Python to every conceivable data source type.</li>
				<li>There's an easy interface to basic statistical testing and quick visualization libraries to check data quality.</li>
				<li>And there's a seamless interface of the data wrangling output with advanced machine learning models.</li>
			</ul>
			<p>Python is the most popular language for machine learning and artificial intelligence these days. Let's take a look at a few data structures in Python.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Lists, Sets, Strings, Tuples, and Dictionaries</h1>
			<p>Now that we have touched upon a few advantages of using Python, we will start by exploring various basic data structures in Python. We will also learn about a few techniques we can use to handle these data structures. This is invaluable for a data practitioner.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Lists</h2>
			<p>Lists are fundamental Python data structures that have continuous memory locations and can host different data types (such as strings, numbers, floats, and doubles) and can be accessed by the index.</p>
			<p>We will start with a list and list comprehension. A list comprehension is a syntactic sugar (or shorthand) for a <code>for</code> loop, which iterates over a list. We will generate a list of numbers, and then examine which ones among them are even. We will sort, reverse, and check for duplicates. We will also see the different ways we can access the list elements, iterating over them and checking the membership of an element.</p>
			<p>The following is an example of a simple list:</p>
			<pre>list_example = [51, 27, 34, 46, 90, 45, -19]</pre>
			<p>The following is also an example of a list:</p>
			<pre>list_example2 = [15, "Yellow car", True, 9.456, [12, "Hello"]]</pre>
			<p>As you can see, a list can contain any number of the allowed data types, such as <code>int</code>, <code>float</code>, <code>string</code>, and <code>boolean</code>, and a list can also be a mix of different data types (including nested lists).</p>
			<p>If you are coming from a strongly typed language, such as C, C++, or Java, then this will probably be strange as you are not allowed to mix different kinds of data types in a single array in those languages. Lists in Python are loosely typed, that is, they are not restricted to a single type. Lists are somewhat like arrays in the sense that they are both based on continuous memory locations and can be accessed using indexes. But the power of Python lists comes from the fact that they can host different data types and you are allowed to manipulate the data.</p>
			<p>In Python, there is a concept of creating a slice of a list. Here is the syntax:</p>
			<pre>my_list [ inclusive start index : exclusive end index ]</pre>
			<p>Known as <code>0</code> to <code>1</code> minus the total length. The first number given represents the first position to include in the slice. The second number is used to indicate which place you want to stop at, but not include. A slice can have an index of <code>–1</code> to indicate the last element.</p>
			<p>The indices will be automatically assigned, as follows:</p>
			<div><div><img src="img/B15780_01_03.jpg" alt="Figure 1.3: List showing the forward and backward indices&#13;&#10;" width="1152" height="332"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: List showing the forward and backward indices</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Be careful, though, as the very power of lists, and the fact that you can mix different data types in a single list, can actually create subtle bugs that can be very difficult to track.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>List Functions</h1>
			<p>In this section, we will discuss a few basic functions for handling lists.</p>
			<p>You can access list elements using the following code:</p>
			<pre>list_example = [51, 27, 34, 46, 90, 45, -19]
list_example[0]</pre>
			<p>The output is as follows:</p>
			<pre>51</pre>
			<p>To find out the length of a list, we simply use the <code>len</code> function. The <code>len</code> function in Python returns the length of the specified list:</p>
			<pre>len(list_example)</pre>
			<p>The output is as follows:</p>
			<pre>7</pre>
			<p>We can append new elements in the list. <code>append</code> is a built-in method in Python for the list data type:</p>
			<pre>list_example.append(11)
list_example</pre>
			<p>The output is as follows:</p>
			<pre>[51, 27, 34, 46, 90, 45, -19, 11]</pre>
			<p>Let's go through some exercises to practice these functions.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Exercise 1.01: Accessing the List Members</h2>
			<p>In this exercise, we will be reading a list of social security numbers from the <code>ssn.csv</code> file and then observing the different ways of accessing the elements from the list using the forward and backward indices. We will be using our first Python function, <code>len</code>, which will return the length of the specified list. We will be starting with the basic building blocks for future exercises. Let's go through the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>ssn.csv</code> file can be found here: <a href="https://packt.live/2AydLCx">https://packt.live/2AydLCx</a>.</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and define a list called <code>ssn</code>. Read from the <code>ssn.csv</code> file using the <code>read_csv</code> command and print the list elements:<pre>import pandas as pd
ssn = list(pd.read_csv("<strong class="bold">../datasets/ssn.csv</strong>"))
print(ssn)
['218-68-9955',
 '165-73-3124',
 '432-47-4043',
 '563-93-1393',
 '153-93-3401',
 '670-09-7369',
 '123-05-9652',
 '812-13-2476',
 '726-13-1007',
 '825-05-4836']</pre></li>
				<li>Access the first element of <code>ssn</code> using its forward index:<pre>ssn[0]</pre><p>The output is as follows:</p><pre>'218-68-9955'</pre></li>
				<li>Access the fourth element of <code>ssn</code> using its forward index:<pre>ssn[3]</pre><p>The output is as follows:</p><pre>'563-93-1393'</pre></li>
				<li>Access the last element of <code>ssn</code> using the <code>len</code> function:<pre>ssn[len(ssn) - 1]</pre><p>The output is as follows:</p><pre>'825-05-4836'</pre></li>
				<li>Access the last element of <code>ssn</code> using its backward index:<pre>ssn[-1] </pre><p>The output is as follows:</p><pre>'825-05-4836'</pre></li>
				<li>Access the first three elements of <code>ssn</code> using forward indices:<pre>ssn[1:3]</pre><p>The output is as follows:</p><pre>['165-73-3124', '432-47-4043']</pre></li>
				<li>Access the last two elements of <code>ssn</code> by slicing:<pre>ssn[-2:]</pre><p>The output is as follows:</p><pre>['726-13-1007', '825-05-4836']</pre></li>
				<li>Access the first two elements using backward indices:<pre>ssn[:-2]</pre><p>The output is as follows:</p><div><img src="img/B15780_01_04.jpg" alt="Figure 1.4: Output after using backward indices&#13;&#10;" width="1073" height="362"/></div><p> </p><p class="figure-caption">Figure 1.4: Output after using backward indices</p><p>When we leave one side of the colon (<code>:</code>) blank, we are basically telling Python either to go until the end or start from the beginning of the list. It will automatically apply the rule of list slices that we just learned.</p></li>
				<li>Reverse the elements in the list:<pre>ssn[-1::-1]</pre><p>The output is as follows:</p><div><img src="img/B15780_01_05.jpg" alt="Figure 1.5: Output after elements are reversed&#13;&#10;" width="1184" height="431"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.5: Output after elements are reversed</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fzTvzk">https://packt.live/3fzTvzk</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YF3zA0">https://packt.live/2YF3zA0</a>.</p>
			<p>In this exercise, we learned how to access the list members with forward and backward indices. We'll create a list in the next exercise.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Exercise 1.02: Generating and Iterating through a List</h2>
			<p>In this exercise, we are going to examine various ways of generating a list and a nested list using the same file containing the list of social security numbers (<code>ssn.csv</code>) that we used in the previous exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>ssn.csv</code> file can be found here: <a href="https://packt.live/2AydLCx">https://packt.live/2AydLCx</a>.</p>
			<p>We are going to use the <code>append</code> method to add new elements to the list and a <code>while</code> loop to iterate through the list. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and import the necessary Python libraries. Read from the <code>ssn.csv</code> file:<pre>import pandas as pd
ssn = list(pd.read_csv("<code>ssn.csv</code> file on your system.</p></li>
				<li>Create a list using the <code>append</code> method. The <code>append</code> method from the Python library will allow you to add items to the list:<pre>ssn_2 = []
for x in ssn:
    ssn_2.append(x)
ssn_2</pre><p>The output will be as follows:</p><div><img src="img/B15780_01_06.jpg" alt="Figure 1.6: Output after creating a list using the append method&#13;&#10;" width="1022" height="355"/></div><p class="figure-caption">Figure 1.6: Output after creating a list using the append method</p><p>Here, we started by declaring an empty list called <code>ssn_2</code>, and then we used a <code>for</code> loop to append values to it after reading from the <code>ssn.csv</code> file.</p></li>
				<li>Generate a list using the following command:<pre>ssn_3 = ["soc: " + x for x in ssn_2]
ssn_3</pre><p>The output is as follows:</p><div><img src="img/B15780_01_07.jpg" alt="Figure 1.7: Output of a generated list&#13;&#10;" width="1524" height="527"/></div><p class="figure-caption">Figure 1.7: Output of a generated list</p><p>This is list comprehension, which is a very powerful tool that we need to master. The power of list comprehension comes from the fact that we can use conditionals such as <code>for..in</code> inside the comprehension itself. This will be discussed in detail in <em class="italic">Chapter 2, Advanced Operations on Built-in Data Structures</em>.</p></li>
				<li>Use a <code>while</code> loop to iterate over the list:<pre>i = 0
while i &lt; len(ssn_3):
    print(ssn_3[i])
    i += 1</pre><p>The output is as follows:</p><pre>soc: 218-68-9955
soc: 165-73-3124
soc: 432-47-4043
soc: 563-93-1393
soc: 153-93-3401
soc: 670-09-7369
soc: 123-05-9652
soc: 812-13-2476
soc: 726-13-1007
soc: 825-05-4836</pre></li>
				<li>Search all the social security numbers with the number <code>5</code> in them:<pre>numbers = [x for x in ssn_3 if "5" in x]
numbers</pre><p>The output will be as follows:</p><div><img src="img/B15780_01_08.jpg" alt="Figure 1.8: SSNs with the number 5 in them&#13;&#10;" width="1565" height="310"/></div><p class="figure-caption">Figure 1.8: SSNs with the number 5 in them</p><p>Let's explore a few more list operations. We are going to use the <code>+</code> operator to add the contents of two lists and use the <code>extend</code> keyword to replace the contents of the existing list with another list. </p></li>
				<li>Generate a list by adding the two lists. Here, we will just use the <code>+</code> operator:<pre>ssn_4 = ["102-90-0314" , "247-17-2338" , "318-22-2760"]
ssn_5 = ssn_4 + ssn
ssn_5</pre><p>The output is as follows:</p><div><img src="img/B15780_01_09.jpg" alt="Figure 1.9: Generated list by adding two lists&#13;&#10;" width="1628" height="686"/></div><p class="figure-caption">Figure 1.9: Generated list by adding two lists</p></li>
				<li>Extend a string using the <code>extend</code> keyword:<pre>ssn_2.extend(ssn_4)
ssn_2</pre><p>The output is as follows:</p><div><img src="img/B15780_01_10.jpg" alt="Figure 1.10: The extend string operation&#13;&#10;" width="1665" height="627"/></div><p class="figure-caption">Figure 1.10: The extend string operation</p><p class="callout-heading">Note</p><p class="callout">The <code>extend</code> operation changes the original list (<code>ssn_2</code>) and appends all the elements of <code>ssn_4</code> to it. So, be careful while using it.</p></li>
				<li>Now, let's loop over the first list and create a nested list inside that loop that goes over the second list:<pre>for x in ssn_2:
    for y in ssn_5:
        print(str(x) + ' , ' + str(y))</pre><p> The output (partially shown) is as follows:</p><div><img src="img/B15780_01_11.jpg" alt="Figure 1.11: Partial output of ssn&#13;&#10;" width="873" height="424"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.11: Partial output of ssn</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Y6vObR">https://packt.live/2Y6vObR</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YLJybf">https://packt.live/2YLJybf</a>.</p>
			<p>In this exercise, we used the built-in methods of Python to manipulate lists. In the next exercise, we'll check whether the elements or members in a dataset are present as per our expectations.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Exercise 1.03: Iterating over a List and Checking Membership</h2>
			<p>This exercise will demonstrate how we can iterate over a list and verify that the values are as expected. This is a manual test that can often be done while dealing with a reasonably sized dataset for business case scenarios. Let's go through the following steps to check the membership of values and whether they exist in the <code>.csv</code> file:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>car_models.csv</code> file can be found at <a href="https://packt.live/3d8DUVy">https://packt.live/3d8DUVy</a>.</p>
			<ol>
				<li value="1">Import the necessary Python libraries and read from the <code>car_models.csv</code> file:<pre>import pandas as pd
car_models = list(pd.read_csv("<strong class="bold">../datasets/car_models.csv</strong>"))
car_models
['Escalade ',
 ‹ X5 M›,
 ‹D150›,
 ‹Camaro›,
 ‹F350›,
 ‹Aurora›,
 ‹S8›,
 ‹E350›,
 ‹Tiburon›,
 ‹F-Series Super Duty ‹]</pre></li>
				<li>Iterate over a list:<pre>list_1 = [x for x in car_models]
for i in range(0, len(list_1)):
    print(list_1[i])</pre><p>The output is as follows:</p><pre>Escalade
X5 M
D150
Camaro
F350
Aurora
S8
E350
Tiburon
F-Series Super Duty</pre><p>However, this is not very Pythonic. Being Pythonic means to follow and conform to a set of best practices and conventions that have been created over the years by thousands of capable developers. In this case, this means we could use the <code>in</code> keyword in the <code>for..in</code> conditional because Python does not have index initialization, bounds checking, or index incrementing, unlike traditional languages. Python uses syntactic sugar to make iterating through lists easy and readable. In other languages, you might have to create a variable (index initialization) as you loop over the list check that variable (bounds checking) since it will be incremented in the loop (index incrementing).</p></li>
				<li>Write the following code to see the Pythonic way of iterating over a list:<pre>for i in list_1:
    print(i)</pre><p>The output is as follows:</p><pre>Escalade
X5 M
D150
Camaro
F350
Aurora
S8
E350
Tiburon
F-Series Super Duty</pre><p>Notice that in the second method, we do not need a counter anymore to access the list index; instead, Python's <code>in</code> operator gives us the element at the <code>i</code>th position directly.</p></li>
				<li>Check whether the strings <code>D150</code> and <code>Mustang</code> are in the list using the <code>in</code> operator:<pre>"D150" in list_1</pre><p>The output is <code>True</code>.</p><pre>"Mustang" in list_1</pre><p>The output is <code>False</code>.</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/30TpGp5">https://packt.live/30TpGp5</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2Y8z06L">https://packt.live/2Y8z06L</a>.</p></li>
			</ol>
			<p>In this exercise, we've seen how to iterate over a list and verified the membership of each element. This is an important skill. Often, when working with large applications, manually checking a list could be useful. If at any time you are unsure of a list, you can easily verify what values are present. Now, we will see how we can perform a sort operation on a list.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Exercise 1.04: Sorting a List</h2>
			<p>In this exercise, we will sort a list of numbers, first by using the <code>sort</code> method and then by using the <code>reverse</code> method. To do so, let's go through the following steps:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>ssn.csv</code> file can be found here: <a href="https://packt.live/2AydLCx">https://packt.live/2AydLCx</a>.</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and import the necessary Python libraries: <pre>import pandas as pd
ssn = list(pd.read_csv("<code>ssn.csv</code> file on your system. </p></li>
				<li>Use the <code>sort</code> method with <code>reverse=True</code>:<pre>list_1 = [*range(0, 21, 1)]
list_1.sort(reverse=True)
list_1</pre><p>The output is as follows:</p><pre>[20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 
6, 5, 4, 3, 2, 1, 0]</pre></li>
				<li>Use the <code>reverse</code> method directly to achieve this result:<pre>list_1.reverse()
list_1</pre><p>The output is as follows:</p><pre>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
17, 18, 19, 20]</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Y7HlYe">https://packt.live/2Y7HlYe</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2YGNvOd">https://packt.live/2YGNvOd</a>.</p></li>
			</ol>
			<p>The difference between the <code>sort</code> method and the <code>reverse</code> method is that we can use <code>sort</code> with customized sorting, whereas we can only use <code>reverse</code> to reverse a list. Also, both methods work in-place, so be aware of this while using them. Now, let's create a list with random numbers. Random numbers can be very useful in a variety of situations and preprocessing data is a common process in machine learning.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Exercise 1.05: Generating a Random List</h2>
			<p>In this exercise, we will be generating a <code>list</code> with random numbers using the <code>random</code> library in Python and performing mathematical operations on them. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Import the <code>random</code> library:<pre>import random</pre></li>
				<li>Use the <code>randint</code> method to generate some random integers and add them to a list:<pre>list_1 = [random.randint(0, 30) for x in range (0, 100)]</pre></li>
				<li>Let's print the list. Note that there will be duplicate values in <code>list_1</code>:<pre>list_1</pre><p>The sample output (partially shown) is as follows:</p><p> </p><div><img src="img/B15780_01_12.jpg" alt="Figure 1.12: List of random numbers&#13;&#10;" width="1665" height="639"/></div><p class="figure-caption">Figure 1.12: List of random numbers</p><p class="callout-heading">Note</p><p class="callout">The output will vary with every run since we are generating random numbers.</p></li>
				<li>Let's find the square of each element:<pre>list_2 = [x**2 for x in list_1]
list_2</pre><p>The output is as follows:</p><p> </p><div><img src="img/B15780_01_13.jpg" alt="Figure 1.13: List of random numbers&#13;&#10;" width="1652" height="716"/></div><p class="figure-caption">Figure 1.13: List of random numbers</p></li>
				<li>Now let's find the log of the <code>1</code> elements of <code>list_2</code>:<pre>import math 
list_2 = [math.log(x+1,10) for x in list_2]
list_2</pre><p>The output (partially shown) is as follows:</p><p> </p><div><img src="img/B15780_01_14.jpg" alt="Figure 1.14: Partial output for list_2&#13;&#10;" width="1592" height="610"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.14: Partial output for list_2</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The output is susceptible to change since we are generating random numbers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37BerTD">https://packt.live/37BerTD</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3hHwlsH">https://packt.live/3hHwlsH</a>.</p>
			<p>In this exercise, we worked on random variables, lists comprehension, and preprocessing data. Let's put what we have learned so far together and go through an activity to practice how to handle lists.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Activity 1.01: Handling Lists</h2>
			<p>In this activity, you will generate a list of random numbers and then generate another list from the first one, which only contains numbers that are divisible by three. Repeat the experiment 10 times; you'll see that the output varies each time, given that a different set of random numbers will be generated each time. Then, you will calculate the average difference between the lengths of the two lists.</p>
			<p>These are the steps for completing this activity:</p>
			<ol>
				<li value="1">Create a <code>list</code> of <code>100</code> random numbers. </li>
				<li>Create a new <code>list</code> from this random <code>list</code>, with numbers that are divisible by <code>3</code>.</li>
				<li>Calculate the length of these two lists and store the difference in a new variable.</li>
				<li>Using a loop, perform steps 1, 2, and 3, and find the difference variable 10 times.</li>
				<li>Find the arithmetic mean of these <code>10</code> difference values.<p>The output (will vary with each run) should look similar to this:</p><pre>66.3</pre><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor304">this link</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Sets</h2>
			<p>A set, mathematically speaking, is just a collection of well-defined distinct objects. Python gives us a straightforward way to deal with them using its set data type.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Introduction to Sets</h2>
			<p>With the last list that we generated in the previous section; we are going to revisit the problem of getting rid of duplicates from it. We can achieve that with the following line of code:</p>
			<pre>list_12 = list(set(list_1))</pre>
			<p>If we print this, we will see that it only contains unique numbers. We used the <strong class="bold">set</strong> data type to turn the first list into a set, thus getting rid of all duplicate elements, and then used the <strong class="bold">list</strong> function to turn it into a list from a set once more:</p>
			<pre>list_12</pre>
			<p>The output will be as follows:</p>
			<div><div><img src="img/B15780_01_15.jpg" alt="Figure 1.15: Section of output for list_12&#13;&#10;" width="664" height="244"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15: Section of output for list_12</p>
			<p>In the next section, we will discuss the union and intersection of sets.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Union and Intersection of Sets</h2>
			<p>In mathematical terms, a list of unique objects is a set. There are many ways of combining sets in the same mathematical term. One such way is the use of a union.</p>
			<p>This is what a union between two sets looks like:</p>
			<div><div><img src="img/B15780_01_16.jpg" alt="Figure 1.16: Venn diagram showing the union of two sets&#13;&#10;" width="1635" height="515"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16: Venn diagram showing the union of two sets</p>
			<p>This simply means taking everything from both sets but only taking the common elements once.</p>
			<p>We can implement this concept by using the following code:</p>
			<pre>set1 = {"Apple", "Orange", "Banana"}
set2 = {"Pear", "Peach", "Mango", "Banana"}</pre>
			<p>To find the union of the two sets, the following code should be used:</p>
			<pre>set1 | set2</pre>
			<p>The output would be as follows:</p>
			<pre>{'Apple', 'Banana', 'Mango', 'Orange', 'Peach', 'Pear'}</pre>
			<p>Notice that the common element, <code>Banana</code>, appears only once in the resulting set. The common elements of two sets can be identified by obtaining the intersection of the two sets, as follows:</p>
			<div><div><img src="img/B15780_01_17.jpg" alt="Figure 1.17: Venn diagram showing the intersection of two sets&#13;&#10;" width="1665" height="483"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17: Venn diagram showing the intersection of two sets</p>
			<p>We get the intersection of two sets in Python as follows:</p>
			<pre>set1 &amp; set2</pre>
			<p>This will give us a set with only one element. The output is as follows:</p>
			<pre>{'Banana'}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also calculate the difference between sets (also known as complements). To find out more, refer to this link: https://docs.python.org/3/tutorial/datastructures.html#sets. </p>
			<p>In this section, we went through sets and how we can do basic set functionality. Sets are used throughout database programming and design, and they are very useful for data wrangling.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>Creating Null Sets</h2>
			<p>In mathematical terms, a set that has nothing inside it is called a null set or an empty set.</p>
			<p>You can create a null set by creating a set containing no elements. You can do this by using the following code:</p>
			<pre>null_set_1 = set({})
null_set_1</pre>
			<p>The output is as follows:</p>
			<pre>set()</pre>
			<p>However, to create a dictionary with null values, use the following command:</p>
			<pre>null_set_2 = {}
null_set_2</pre>
			<p>The output is as follows:</p>
			<pre>{}</pre>
			<p>We are going to learn about this in detail in the next section.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>Dictionary</h2>
			<p>A dictionary is like a list, which means it is a collection of several elements. However, with the dictionary, it is a collection of key-value pairs, where the key can be anything that can fit into memory. Generally, we use numbers or strings as keys.</p>
			<p>To create a dictionary, use the following code: </p>
			<pre>dict_1 = {"key1": "value1", "key2": "value2"}
dict_1</pre>
			<p>The output is as follows:</p>
			<pre>{'key1': 'value1', 'key2': 'value2'}</pre>
			<p>This is also a valid dictionary:</p>
			<pre>dict_2 = {"key1": 1, "key2": ["list_element1", 34], \
          "key3": "value3","key4": {"subkey1": "v1"}, \
          "key5": 4.5}
dict_2</pre>
			<p class="callout-heading">Note</p>
			<pre>\</strong> ) to split the logic across multiple lines. When the code is executed, Python will ignore the backslash, and treat the code on the next line as a direct continuation of the current line.</pre>
			<p>The output is as follows:</p>
			<pre>{'key1': 1,
 'key2': ['list_element1', 34],
 'key3': 'value3',
 'key4': {'subkey1': 'v1'},
 'key5': 4.5}</pre>
			<p>The keys must be unique in a dictionary. </p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Exercise 1.06: Accessing and Setting Values in a Dictionary</h2>
			<p>In this exercise, we are going to access the elements and set values in a dictionary. When working with dictionaries, it's important to be able to iterate through each key-value pair, which will allow you to process the data as needed. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">To access a value in the dictionary, you must provide the key. Keep in mind there is no given order for any pair in the dictionary:<pre>stocks = \
{"Solar Capital Ltd.":"$920.44M", \
 "Zoe's Kitchen, Inc.":"$262.32M",\
 "Toyota Motor Corp Ltd Ord":"$156.02B",\
 "Nuveen Virginia Quality Municipal Income Fund":"$238.33M",\
 "Kinross Gold Corporation":"$5.1B",\
 "Vulcan Materials Company":"$17.1B",\
 "Hi-Crush Partners LP":"$955.69M",\
 "Lennox International, Inc.":"$8.05B",\
 "WMIH Corp.":"$247.66M",\
 "Comerica Incorporated":"n/a"}</pre></li>
				<li>Print a particular element from the <code>stocks</code> list:<pre>stocks["WMIH Corp."]</pre><p>This will return the value associated with it, as follows:</p><pre>'$247.66M'</pre></li>
				<li>Set a value using the same method we use to access a value:<pre>stocks["WMIH Corp."] = "$300M"</pre></li>
				<li>Define a blank dictionary and then use the key notation to assign values to it:<pre>dict_3 = {} # Not a null set. It is a dict
dict_3["key1"] = "Value1"
dict_3
{'key1': 'Value1'}</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2AGFaly">https://packt.live/2AGFaly</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/3d8fyeJ">https://packt.live/3d8fyeJ</a>.</p></li>
			</ol>
			<p>As we can see, the manipulation techniques of a dictionary are pretty simple. Now, just like a list, iterating through a dictionary is very important in order to process the data.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Exercise 1.07: Iterating over a Dictionary</h2>
			<p>In this exercise, we are going to iterate over a dictionary and print the values and keys. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">Open a new Jupyter Notebook and define a dictionary with the key provided along with it. Keep in mind there is no given order for any pair in the dictionary:<pre>stocks = \
{"Solar Capital Ltd.":"$920.44M",\
 "Zoe's Kitchen, Inc.":"$262.32M",\
 "Toyota Motor Corp Ltd Ord":"$156.02B",\
 "Nuveen Virginia Quality Municipal Income Fund":"$238.33M",\
 "Kinross Gold Corporation":"$5.1B",\
 "Vulcan Materials Company":"$17.1B",\
 "Hi-Crush Partners LP":"$955.69M",\
 "Lennox International, Inc.":"$8.05B",\
 "WMIH Corp.":"$247.66M",\
 "Comerica Incorporated":"n/a"}</pre></li>
				<li>Remove the <code>$</code> character from the <code>stocks</code> dictionary:<pre>for key,val in stocks.items():
    stocks[key] = val.replace('$', '')
stocks</pre><p>The output should be as follows:</p><pre>{'Solar Capital Ltd.': '920.44M',
 "Zoe's Kitchen, Inc.": '262.32M',
 'Toyota Motor Corp Ltd Ord': '156.02B',
 'Nuveen Virginia Quality Municipal Income Fund': '238.33M',
 'Kinross Gold Corporation': '5.1B',
 'Vulcan Materials Company': '17.1B',
 'Hi-Crush Partners LP': '955.69M',
 'Lennox International, Inc.': '8.05B',
 'WMIH Corp.': '300M',
 'Comerica Incorporated': 'n/a'}</pre></li>
				<li>Iterate over the <code>stocks</code> dictionary again and split the value into a list with price (<code>val</code>) and multiplier (<code>mult</code>) as separate elements where a single value is assigned to each key:<pre>for key,val in stocks.items():
    mult = val[-1]
    stocks[key] = [val[:-1],mult]
stocks</pre><p>The output is as follows:</p><pre>{'Solar Capital Ltd.': ['920.44', 'M'],
 «Zoe›s Kitchen, Inc.»: [‹262.32›, ‹M›],
 ‹Toyota Motor Corp Ltd Ord›: [‹156.02›, ‹B›],
 ‹Nuveen Virginia Quality Municipal Income Fund›: [‹238.33›, ‹M›],
 ‹Kinross Gold Corporation›: [‹5.1›, ‹B›],
 ‹Vulcan Materials Company›: [‹17.1›, ‹B›],
 ‹Hi-Crush Partners LP›: [‹955.69›, ‹M›],
 ‹Lennox International, Inc.›: [‹8.05›, ‹B›],
 ‹WMIH Corp.›: [‹300›, ‹M›],
 ‹Comerica Incorporated›: [‹n/›, ‹a›]}</pre></li>
			</ol>
			<p>Notice the difference between how we did the iteration on the list and how we are doing it here. A dictionary always contains a key-value pair, and we always need to access the value of any element in a dictionary with its key. In a dictionary, all the keys are unique.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3db0xZF">https://packt.live/3db0xZF</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2zDFHnU">https://packt.live/2zDFHnU</a>.</p>
			<p>In the next exercise, we will revisit the problem that we encountered with the list earlier in this chapter to create a list with unique values. We will look at another workaround to fix this problem.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Exercise 1.08: Revisiting the Unique Valued List Problem</h2>
			<p>In this exercise, we will use the unique nature of a dictionary, and we will drop the duplicate values from a list. First, we will create a random list with duplicate values. Then, we'll use the <code>fromkeys</code> and <code>keys</code> methods of a dictionary to create a unique valued list. To do so, let's go through the following steps:</p>
			<ol>
				<li value="1">First, generate a random list with duplicate values:<pre>import random
list_1 = [random.randint(0, 30) for x in range (0, 100)]</pre></li>
				<li>Create a unique valued list from <code>list_1</code>:<pre>list(dict.fromkeys(list_1).keys())</pre><p>The sample output is as follows:</p><div><img src="img/B15780_01_18.jpg" alt="Figure 1.18: Output showing the unique valued list&#13;&#10;" width="626" height="517"/></div></li>
			</ol>
			<p class="figure-caption">Figure 1.18: Output showing the unique valued list</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The output is susceptible to change since we are generating random numbers.</p>
			<p>Here, we have used two useful methods of the <code>dict</code> data type in Python, <code>fromkeys</code> and <code>keys</code>. <code>fromkeys</code> is a built-in function in which a new dictionary is created from the given sequence of elements with values given by the user, while the <code>keys</code> method gives us the keys of a dictionary.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2URp6EA">https://packt.live/2URp6EA</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2UTCFmO">https://packt.live/2UTCFmO</a>.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Exercise 1.09: Deleting a Value from Dict</h2>
			<p>In this exercise, we are going to delete a value from <code>dict</code> using the <code>del</code> method. Perform the following steps:</p>
			<ol>
				<li value="1">Create <code>list_1</code> with five elements:<pre>dict_1 = {"key1": 1, "key2": ["list_element1", 34], \
          "key3": "value3","key4": {"subkey1": "v1"}, \
          "key5": 4.5}
dict_1</pre><p>The output is as follows:</p><pre>{'key1': 1,
 'key2': ['list_element1', 34],
 'key3': 'value3',
 'key4': {'subkey1': 'v1'},
 'key5': 4.5}</pre></li>
				<li>We will use the <code>del</code> function and specify the element we want to delete:<pre>del dict_1["key2"]
dict_1</pre><p>The output is as follows:</p><pre>{'key1': 1, 'key3': 'value3', 'key4': {'subkey1': 'v1'}, 'key5': 4.5}</pre></li>
				<li>Let's delete <code>key3</code> and <code>key4</code>:<pre>del dict_1["key3"]
del dict_1["key4"]</pre></li>
				<li>Now, let's print the dictionary to see its content:<pre>dict_1</pre><p>The output should be as follows:</p><pre>{'key1': 1, 'key5': 4.5}</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2Nb3oqF">https://packt.live/2Nb3oqF</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/30Os7ct">https://packt.live/30Os7ct</a>.</p></li>
			</ol>
			<p>In this exercise, we learned how to delete elements from a dictionary. This is a very useful functionality of dictionaries, and you will find that it's used heavily when writing Python applications.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>del</code> operator can be used to delete a specific index from a list as well.</p>
			<p>In our final exercise on <code>dict</code>, we will go over a less commonly used list comprehension called <code>dict</code>, which can be very useful for processing dictionaries in one line. There could be cases where this could be used as a range of key-value pairs of name and age or credit card number and credit card owner. A dictionary comprehension works exactly the same way as list comprehension, but we need to specify both the key and the value.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor039"/>Exercise 1.10: Dictionary Comprehension</h2>
			<p>In this exercise, we will generate a dictionary using the following steps:</p>
			<ol>
				<li value="1">Generate a <code>dict</code> that has <code>0</code> to <code>9</code> as the keys and the square of the key as the values:<pre>list_1 = [x for x in range(0, 10)]
dict_1 = {x : x**2 for x in list_1}
dict_1</pre><p>The output is as follows:</p><pre>{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}</pre><p>Can you generate a <code>dict</code> using <code>dict</code> comprehension without using a list? Let's try this now.</p></li>
				<li>Generate a <code>dictionary</code> using the <code>dict</code> function:<pre>dict_2 = dict([('Tom', 100), ('Dick', 200), ('Harry', 300)])
dict_2</pre><p>The output is as follows:</p><pre>{'Tom': 100, 'Dick': 200, 'Harry': 300}</pre></li>
				<li>You can also a <code>dictionary</code> using the <code>dict</code> function, as follows:<pre>dict_3 = dict(Tom=100, Dick=200, Harry=300)
dict_3</pre><p>The output is as follows:</p><pre>{'Tom': 100, 'Dick': 200, 'Harry': 300}</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3hz8zPp">https://packt.live/3hz8zPp</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/3hA8WJw">https://packt.live/3hA8WJw</a>.</p></li>
			</ol>
			<p>Dictionaries are very flexible and can be used for a variety of tasks. The compact nature of comprehension makes them very popular. The strange-looking pair of values that just looked at (<code>'Harry', 300</code>) is called a tuple. This is another important fundamental data type in Python. We will learn about tuples in the next section.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor040"/>Tuples</h2>
			<p>A tuple is another data type in Python. Tuples in Python are similar to lists, with one key difference. A tuple is a variant of a Python list that is immutable. Immutable basically means you can't modify it by adding or removing from the list. It is sequential in nature and similar to lists. </p>
			<p>A tuple consists of values separated by commas, as follows:</p>
			<pre>tuple_1 = 24, 42, 2.3456, "Hello"</pre>
			<p>Notice that, unlike lists, we did not open and close square brackets here. </p>
			<p>When referring to a tuple, the length of the tuple is called its <strong class="bold">cardinality</strong>. This comes from database and set theory and is a common way to reference its length.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor041"/>Creating a Tuple with Different Cardinalities</h2>
			<p>This is how we create an empty tuple:</p>
			<pre>tuple_1 = ()</pre>
			<p>This is how we create a tuple with only one value:</p>
			<pre>tuple_1 = "Hello",</pre>
			<p>Notice the trailing comma here.</p>
			<p>We can nest tuples, similar to lists and dicts, as follows:</p>
			<pre>tuple_1 = "hello", "there"
tuple_12 = tuple_1, 45, "Sam"</pre>
			<p>One special thing about tuples is the fact that they are an immutable data type. So, once they're created, we cannot change their values. We can just access them, as follows:</p>
			<pre>tuple_1 = "Hello", "World!"
tuple_1[1] = "Universe!"</pre>
			<p>The last line of the preceding code will result in a <code>TypeError</code> as a tuple does not allow modification.</p>
			<p>This makes the use case for tuples a bit different than lists, although they look and behave very similarly in a few ways.</p>
			<p>We can access the elements of a tuple in the same manner we can for lists:</p>
			<pre>tuple_1 = ("good", "morning!" , "how", "are" "you?")
tuple_1[0]</pre>
			<p>The output is as follows:</p>
			<pre>'good'</pre>
			<p>Let's access another element:</p>
			<pre>tuple_1[4]</pre>
			<p>The output will be:</p>
			<pre>'you?'</pre>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor042"/>Unpacking a Tuple</h2>
			<p>The expression "unpacking a tuple" simply means getting the values contained in the tuple in different variables:</p>
			<pre>tuple_1 = "Hello", "World"
hello, world = tuple_1
print(hello)
print(world)</pre>
			<p>The output is as follows:</p>
			<pre>Hello
World</pre>
			<p>Of course, as soon as we do that, we can modify the values contained in those variables.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor043"/>Exercise 1.11: Handling Tuples</h2>
			<p>In this exercise, we will walk through the basic functionalities of tuples. Let's go through the steps one by one:</p>
			<ol>
				<li value="1">Create a tuple to demonstrate how tuples are immutable. Unpack it to read all the elements, as follows:<pre>tupleE = "1", "3", "5"
tupleE</pre><p>The output is as follows:</p><pre>('1', '3', '5')</pre></li>
				<li>Try to override a variable from the <code>tupleE</code> tuple:<pre>tupleE[1] = "5"</pre><p>This step will result in <code>TypeError</code> as the tuple does not allow modification.</p><pre>TypeError                                 Traceback (most recent call last)
&lt;ipython-input-58-b4cba6d5ed11&gt; in &lt;module&gt;
----&gt; 1 tupleE[1] = "5"
TypeError: 'tuple' object does not support item assignment</pre></li>
				<li>Try to assign a series to the <code>tupleE</code> tuple:<pre>1, 3, 5 = tupleE</pre><p>This step will also result in a <code>SyntaxError</code>, stating that it can't assign to the literal:</p><pre>File "&lt;ipython-input-3-a5283cb38d62&gt;", line 1
    1, 3, 5 = tupleE
                     ^
SyntaxError: can't assign to literal</pre></li>
				<li>Print variables at <code>0</code>th and <code>1</code>st positions:<pre>print(tupleE[0])
print(tupleE[1])</pre><p>The output is as follows:</p><pre>1
3</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3ebuvOf">https://packt.live/3ebuvOf</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2URh9zo">https://packt.live/2URh9zo</a>.</p></li>
			</ol>
			<p>We have seen two different types of data so far. One is represented by numbers, while the other is represented by textual data. Now it's time to look into textual data in a bit more detail.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>Strings</h2>
			<p>In the final section of this chapter, we will learn about strings. Strings in Python are similar to strings in any other programming language.</p>
			<p>This is a string:</p>
			<pre>string1 = 'Hello World!' </pre>
			<p>A string can also be declared in this manner:</p>
			<pre>string2 = "Hello World 2!"</pre>
			<p>You can use single quotes and double quotes to define a string. </p>
			<p>The start and end of a string is defined as:</p>
			<pre>str[ inclusive start position:  exclusive end position ]. </pre>
			<p>Strings in Python behave similar to lists, apart from one big caveat. Strings are immutable, whereas lists are mutable data structures.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>Exercise 1.12: Accessing Strings</h2>
			<p>In this exercise, we are going perform mathematical operations to access strings. Let's go through the following steps:</p>
			<ol>
				<li value="1">Create a string called <code>str_1</code>:<pre>str_1 = "Hello World!"
str_1</pre><p>The output is as follows:</p><pre>'Hello World!'</pre><p>You can access the elements of the string by specifying the location of the element, like we did for lists.</p></li>
				<li>Access the first member of the string:<pre>str_1[0]</pre><p>The output is as follows:</p><pre>'H'</pre></li>
				<li>Access the fifth member of the string:<pre>str_1[4]</pre><p>The output is as follows:</p><pre>'o'</pre></li>
				<li>Access the last member of the string:<pre>str_1[len(str_1) - 1]</pre><p>The output is as follows:</p><pre>'!'</pre></li>
				<li>Access the last member of the string, in a different way this time:<pre>str_1[-1]</pre><p>The output is as follows:</p><pre>'!'</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YHEmF9">https://packt.live/2YHEmF9</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/3db191p">https://packt.live/3db191p</a>.</p></li>
			</ol>
			<p>Each of the preceding operations will give you the character at the specific index. The method for accessing the elements of a string is like accessing a list. Let's do a couple of more exercises to manipulate strings.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>Exercise 1.13: String Slices</h2>
			<p>This exercise will demonstrate how we can slice strings the same way as we did with lists. Although strings are not lists, the functionality will work in the same way.</p>
			<p>Let's go through the following steps:</p>
			<ol>
				<li value="1">Create a string, <code>str_1</code>:<pre>str_1 = "Hello World! I am learning data wrangling"
str_1</pre><p>The output is as follows:</p><pre>'Hello World! I am learning data wrangling'</pre></li>
				<li>Specify the slicing values and slice the string:<pre>str_1[2:10]</pre><p>The output is as follows:</p><pre>'llo Worl'</pre></li>
				<li>Slice a string by skipping a slice value:<pre>str_1[-31:]</pre><p>The output is as follows: </p><pre>'d! I am learning data wrangling'</pre></li>
				<li>Use negative numbers to slice the string:<pre>str_1[-10:-5]</pre><p>The output is as follows:</p><pre>' wran'</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2N70Bis">https://packt.live/2N70Bis</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/3d6X9Pu">https://packt.live/3d6X9Pu</a>.</p></li>
			</ol>
			<p>As we can see, it is quite simple to manipulate strings with basic operations.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>String Functions</h2>
			<p>To find out the length of a string, we simply use the <code>len</code> function:</p>
			<pre>str_1 = "Hello World! I am learning data wrangling"
len(str_1)</pre>
			<p>The length of the string is <code>41</code>. To convert a string's case, we can use the <code>lower</code> and <code>upper</code> methods:</p>
			<pre>str_1 = "A COMPLETE UPPER CASE STRING"
str_1.lower()</pre>
			<p>The output is as follows:</p>
			<pre>'a complete upper case string'</pre>
			<p>To change the case of the string, use the following code:</p>
			<pre>str_1.upper()</pre>
			<p>The output is as follows:</p>
			<pre>'A COMPLETE UPPER CASE STRING'</pre>
			<p>To search for a string within a string, we can use the <code>find</code> method:</p>
			<pre>str_1 = "A complicated string looks like this"
str_1.find("complicated")
str_1.find("hello")</pre>
			<p>The output is <code>-1</code>. Can you figure out whether the <code>find</code> method is case-sensitive or not? Also, what do you think the <code>find</code> method returns when it actually finds the string?</p>
			<p>To replace one string with another, we have the <code>replace</code> method. Since we know that a string is an immutable data structure, <code>replace</code> actually returns a new string instead of replacing and returning the actual one:</p>
			<pre>str_1 = "A complicated string looks like this"
str_1.replace("complicated", "simple")</pre>
			<p>The output is as follows:</p>
			<pre>'A simple string looks like this'</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">You should look up string methods in the standard documentation of Python 3 to discover more about these methods. Visit <a href="https://docs.python.org/3.7/">https://docs.python.org/3.7/</a>.</p>
			<p>Strings have two useful methods: <code>split</code> and <code>join</code>. Here are their definitions:</p>
			<pre>str.split(separator)</pre>
			<p>The <code>seperator</code> argument is a delimiter that you define:</p>
			<pre>string.join(seperator)</pre>
			<p>Let's take a look at the following exercise to practice the <code>split</code> and <code>join</code> functionalities.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>Exercise 1.14: Splitting and Joining a String</h2>
			<p>This exercise will demonstrate how to perform split and join operations on a string. These two string methods need separate approaches as they allow you to convert a string into a list and vice versa. Let's go through the following steps to do so:</p>
			<ol>
				<li value="1">Create a string and convert it into a list using the <code>split</code> method:<pre>str_1 = "Name, Age, Sex, Address"
list_1 = str_1.split(",")
list_1</pre><p>The preceding code will give you a list similar to the following:</p><pre>['Name', ' Age', ' Sex', ' Address']</pre></li>
				<li>Combine this list into another string using the <code>join</code> method:<pre>s = " | "
s.join(list_1) </pre><p>This code will give you a string like this:</p><pre>'Name |  Age |  Sex |  Address'</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2N1lprE">https://packt.live/2N1lprE</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2UOOQBC">https://packt.live/2UOOQBC</a>.</p></li>
			</ol>
			<p>With these, we are at the end of the second topic of this chapter. Now, we have the motivation to learn about data wrangling and have had a solid introduction to the fundamentals of data structures using Python. There is more to this topic, which will be covered in <em class="italic">Chapter 2</em>, <em class="italic">Advanced Operation on Built-In Data Structures</em>. </p>
			<p>The next section will ensure that you have understood the various basic types of data structures and their manipulation techniques. We will do that by going through an activity that has been designed specifically for this purpose.</p>
			<h2 id="_idParaDest-49">Activity 1.02: Ana<a id="_idTextAnchor049"/>lyzing a Multiline String and Generating the Unique Word Count</h2>
			<p>In this activity, you will do the following:</p>
			<ul>
				<li>Get multiline text and save it in a Python variable.</li>
				<li>Get rid of all new lines in it using string methods.</li>
				<li>Get all the unique words and their occurrences from the string.</li>
				<li>Repeat the steps to find all unique words and occurrences, without considering case sensitivity.<p class="callout-heading">Note</p><p class="callout">For the sake of simplicity, the original text (which can be found at <a href="https://www.gutenberg.org/files/1342/1342-h/1342-h.htm">https://www.gutenberg.org/files/1342/1342-h/1342-h.htm</a>) has been pre-processed  bit.</p></li>
			</ul>
			<p>These are the steps to guide you through solving this activity:</p>
			<ol>
				<li value="1">Create a <code>mutliline_text</code> variable by copying the text from the first chapter of <em class="italic">Pride and Prejudice</em>. <p><strong class="bold">Hint</strong>: Remember to add triple quotation marks to enter a multiline text. This is the only way to enter a chunk of text in Python.</p><p class="callout-heading">Note</p><p class="callout">Part of the first chapter of <em class="italic">Pride and Prejudice</em> by Jane Austen has been made available on this book's GitHub repository at <a href="https://packt.live/2N6ZGP6">https://packt.live/2N6ZGP6</a>.</p></li>
				<li>Find the type and length of the <code>multiline_text</code> string using the <code>type</code> and <code>len</code> commands.</li>
				<li>Remove all new lines and symbols using the <code>replace</code> method.</li>
				<li>Find all of the words in <code>multiline_text</code> using the <code>split</code> method.</li>
				<li>Create a list from this list that will contain only the unique words.</li>
				<li>Count the number of times the unique word has appeared in the list using the <code>key</code> and <code>value</code> in <code>dict</code>.</li>
				<li>Find the top 25 words from the unique words that you have found using the <code>slice</code> method.</li>
			</ol>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_01_19.jpg" alt="Figure 1.19: Top 25 words from the unique list&#13;&#10;" width="817" height="639"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19: Top 25 words from the unique list</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor305">this link</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor050"/>Summary</h1>
			<p>In this chapter, we learned about data wrangling and looked at examples from various real-life data science situations where data wrangling is very useful. We moved on to learn about the different built-in data structures that Python has to offer. We got our hands dirty by exploring lists, sets, dictionaries, tuples, and strings. These are the fundamental building blocks of Python data structures, and we need them all the time when working and manipulating data in Python. We did several small hands-on exercises to learn more about them. We finished this chapter with carefully designed activities that let us combine a lot of different tricks from all the different data structures and let us observe the interplay between all of them. In the next chapter, we will learn about the data structures in Python and utilize them to solve problems.</p>
		</div>
		<div><div></div>
		</div>
	</div></body></html>