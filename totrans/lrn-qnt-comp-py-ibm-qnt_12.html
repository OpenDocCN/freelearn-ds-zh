<html><head></head><body><div><div><div><h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-201" class="chapterTitle">Applying Quantum Algorithms</h1>
    <p class="normal">In the last chapter, we considered the fundamentals that highlight the difference between classical and quantum systems, particularly the use of superposition and entanglement. In this chapter, we will focus on algorithms that have the potential to solve more applicable problems, such as periodicity and searching. These algorithms differ from the earlier algorithms as they are used in various domains and are included in many <a id="_idIndexMarker1387"/>modern quantum algorithms. A few examples <a id="_idIndexMarker1388"/>of these quantum algorithms <a id="_idIndexMarker1389"/>are the <strong class="keyWord">quantum amplitude estimation</strong>, <strong class="keyWord">variational quantum eigensolvers</strong>, and <strong class="keyWord">quantum support vector machine</strong> algorithms. Having a good understanding of these algorithms will help you when learning about or creating your own algorithms as the techniques used can be applied in many industries. In this chapter, we will cover some of the fundamental principles and techniques that these more modern, and complex, algorithms leverage, to help you better understand them.</p>
    <p class="normal"><strong class="keyWord">Periodic algorithms</strong> can be <a id="_idIndexMarker1390"/>used to solve factorization or phase <a id="_idIndexMarker1391"/>estimation problems. <strong class="keyWord">Search algorithms</strong> can also provide some speedup over classical algorithms in how they leverage amplitude amplification to find a specified entry.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Understanding periodic quantum algorithms</li>
      <li class="bulletList">Understanding the Quantum Fourier Transform algorithm</li>
      <li class="bulletList">Understanding Grover’s search algorithm</li>
    </ul>
    <p class="normal">After completing this chapter, you will be able to grasp the concepts of these algorithms and leverage the <a id="_idIndexMarker1392"/>algorithms already provided in <strong class="keyWord">Qiskit</strong>, so you can use them without having to <em class="italic">reinvent the wheel</em>.</p>
    <h1 id="_idParaDest-202" class="heading-1">Technical requirements</h1>
    <p class="normal">This chapter assumes that you are familiar with some of the basic quantum algorithm components, such as superposition, oracles, phase kickback, and programming with Qiskit. You are also expected to understand basic linear algebra, such as multiplying matrices, the complex conjugation of a matrix, and inner products. Some advanced mathematics, such as <a id="_idIndexMarker1393"/>an understanding of the <strong class="keyWord">Fourier transform</strong>, is also assumed.</p>
    <p class="normal">Here is the source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</a>.</p>
    <h1 id="_idParaDest-203" class="heading-1">Understanding periodic quantum algorithms</h1>
    <p class="normal">In <em class="chapterRef">Chapter 11</em>, <em class="italic">Understanding Quantum Algorithms</em>, we covered algorithms that use phase kickback to solve various problems.</p>
    <p class="normal">In this section, we will start by understanding periodic quantum algorithms. Periodic functions <a id="_idIndexMarker1394"/>are those where values are repeated over time. Your watch, for example, is periodic in that each minute has 60 seconds, each hour has 60 minutes, and each day has 24 hours.</p>
    <p class="normal">If you have your watch set up with the hours from 1 to 12, then your watch has 2 periods per day, in that your watch will cycle through the numbers 1 to 12 twice in one day. Of course, this is separate from the AM and PM indicators, whether it is before or after midday. Periodic functions occur all around us in many ways, so understanding how to relate them to a quantum circuit is key to understanding many of the quantum algorithms, including <a id="_idIndexMarker1395"/>one of the most famous, <strong class="keyWord">Grover’s algorithm</strong>.</p>
    <p class="normal">But for now, we will begin by extending our understanding of periodic functions, particularly <a id="_idIndexMarker1396"/>how we can understand and implement the <strong class="keyWord">Quantum Fourier Transform </strong>(<strong class="keyWord">QFT</strong>) algorithm.</p>
    <h2 id="_idParaDest-204" class="heading-2">Learning about the QFT algorithm</h2>
    <p class="normal">QFT is <a id="_idIndexMarker1397"/>related to <strong class="keyWord">Discrete Fourier Transform</strong> (<strong class="keyWord">DFT</strong>) in that it <a id="_idIndexMarker1398"/>too can transform from one domain to another.</p>
    <div><p class="normal"><strong class="keyWord">DFT</strong> converts a finite sequence of samples into a complex-valued function of frequency that is used to analyze many applications, such as image processing and signal processing, and can also be used to help solve partial differential equations.</p>
    </div>
    <p class="normal">DFT is used to transfer signals from the time domain to the frequency domain, or in a more generalized description, mapping one domain, <em class="italic">x</em>, to another domain, <img src="img/B18420_12_001.png" alt="" width="46" height="25"/><a id="_idIndexMarker1399"/>, with the following formula:</p>
    <p class="center"><img src="img/B18420_12_002.png" alt="" width="175" height="71"/><a id="_idIndexMarker1400"/></p>
    <p class="normal">Similarly, we can define a quantum transformation as a transformation from one basis to another. For example, all the computations we have done in this book so far have been measured according to the <em class="italic">Z</em> basis. This means our basis states have been set on the <em class="italic">Z</em>-axis of the qubit with the states <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1401"/> and <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1402"/>, referring to the positive and negative ends of the <em class="italic">Z</em>-axis on the Bloch sphere, respectively.</p>
    <p class="normal">There are, of course, other basis states that we can transition to if needed. One example is the <em class="italic">X</em>-axis of the qubit, where the basis states there are <img src="img/B18420_04_008.png" alt="" width="25" height="25"/><a id="_idIndexMarker1403"/> and <img src="img/B18420_04_012.png" alt="" width="25" height="25"/><a id="_idIndexMarker1404"/>, which refer to the positive and negative ends of the <em class="italic">X</em>-axis on the Bloch sphere, respectively. QFT would transform between these two basis states. The QFT is used by many quantum algorithms, including Shor’s, as it has been shown to have improvements over the classical implementation of a discrete Fourier transform.</p>
    <p class="normal">In this section, we will work through a simple example of a QFT algorithm to extend our understanding of it when we see it used in many other quantum algorithms.</p>
    <p class="normal">We’ll begin by applying QFT to a simple three-qubit quantum state.</p>
    <h3 id="_idParaDest-205" class="heading-3">Understanding the QFT algorithm</h3>
    <p class="normal">Before getting into the details, let’s first get an understanding of what each axis represents. As you recall from the Bloch sphere, one of the visual representations of a qubit, it is made up of three axes, <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em>. Rotations around the <em class="keystroke">X</em> and <em class="italic">Y</em> axes are what we <a id="_idIndexMarker1405"/>use to adjust the amplitude of the qubit, that is, down along the longitude of the Bloch sphere (the North Pole to the South Pole). Rotation around the <em class="italic">Z</em>-axis is what we use to adjust the phase of the qubit, that is, around the latitude of the Bloch sphere.</p>
    <p class="normal">Each axis is a basis state, named by the axis, i.e. <em class="italic">X</em>-basis, <em class="italic">Y</em>-basis, and <em class="italic">Z</em>-basis. In quantum, the <em class="italic">Z</em>-axis is generally referred to as the computational basis and either the <em class="italic">X-</em> and <em class="italic">Y</em>-axis can be the Fourier basis. In this example, we will set the <em class="italic">X</em>-basis as the Fourier basis. The QFT transform is generally a transformation from one basis to another, in this case, from the computational (<em class="italic">Z</em>) basis to the Fourier (<em class="italic">X</em>) basis.</p>
    <p class="normal">To transform our quantum function from one basis state to another, we need to apply QFT, as follows:</p>
    <p class="center"><img src="img/B18420_12_007.png" alt="" width="215" height="35"/><a id="_idIndexMarker1406"/></p>
    <p class="normal">In the preceding equation, <em class="italic">Z – basis</em> refers to the basis states on the <em class="italic">Z</em>-axis, <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1407"/> and <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1408"/>, and <em class="italic">X – basis</em> refers to the basis states (often referred to as the phase states because rotation around them refers to rotations around the <em class="italic">Z</em>-axis) on the <em class="italic">X</em>-axis, <img src="img/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1409"/> and <img src="img/B18420_09_052.png" alt="" width="25" height="25"/><a id="_idIndexMarker1410"/>. The Qiskit documentation (<a href="https://docs.quantum.ibm.com/">https://docs.quantum.ibm.com/</a>) refers to the Fourier basis with a tilde (<em class="italic">~</em>), where <em class="italic">QFT</em> is the QFT Transform applied to the state <img src="img/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker1411"/>, given as follows:</p>
    <p class="center"><img src="img/B18420_12_013.png" alt="" width="113" height="25"/><a id="_idIndexMarker1412"/></p>
    <p class="normal">This can be equated, where the transformation is represented by the QFT between the amplitudes of <em class="italic">x</em><sub class="subscript">j</sub> and <em class="italic">y</em><sub class="subscript">k</sub>, as follows:</p>
    <p class="center"><img src="img/B18420_12_014.png" alt="" width="204" height="71"/><a id="_idIndexMarker1413"/></p>
    <p class="normal">Now, let’s see how we can implement QFT in a quantum circuit.</p>
    <h3 id="_idParaDest-206" class="heading-3">Implementing the QFT algorithm</h3>
    <p class="normal">Let’s begin by deriving our implementation based on an input state <img src="img/B18420_12_015.png" alt="" width="27" height="25"/><a id="_idIndexMarker1414"/>,.</p>
    <p class="normal">An alternative <a id="_idIndexMarker1415"/>is to apply it sequentially to the following formula as we move from qubit to qubit. For this example, we will operate as follows; given a state <img src="img/B18420_12_016.png" alt="" width="206" height="25"/><a id="_idIndexMarker1416"/>, we will apply a Hadamard gate where we add the phase based on the state <img src="img/B18420_12_015.png" alt="" width="27" height="25"/><a id="_idIndexMarker1417"/>, where each value, j<sub class="subscript">i</sub>, is appended to the phase, as follows:</p>
    <p class="center"><img src="img/B18420_12_018.png" alt="" width="726" height="59"/><a id="_idIndexMarker1418"/></p>
    <p class="normal">In the following exercise, we will implement the QFT of <img src="img/B18420_12_019.png" alt="" width="98" height="25"/><a id="_idIndexMarker1419"/>, where <img src="img/B18420_12_020.png" alt="" width="167" height="25"/><a id="_idIndexMarker1420"/>. It’s important to note that the fractional parts of the exponents are binary, not decimal:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by opening a new Jupyter notebook and import some common objects and run our helper file:
        <pre class="programlisting code-one"><code class="hljs-code"># Importing standard Qiskit libraries
from qiskit import QuantumCircuit, transpile
from qiskit.transpiler.preset_passmanagers import
             generate_preset_pass_manager
from qiskit.visualization import *
from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Estimator, Session, Options
service = QiskitRuntimeService(channel="ibm_quantum")
</code></pre>
      </li>
      <li class="numberedList">Next, we’ll create a quantum circuit where the width is equal to the length of our state value, <code class="inlineCode">'110'</code>:
        <pre class="programlisting code-one"><code class="hljs-code"># Initialize the 3-qubit quantum circuit
# Set the state '110'
s = '110'
num_qubits = len(s)
qc = QuantumCircuit(num_qubits)
</code></pre>
      </li>
      <li class="numberedList">Now that we have created our quantum circuit, let’s initialize the state, <em class="italic">s</em>, to <img src="img/B18420_12_021.png" alt="" width="44" height="25"/><a id="_idIndexMarker1421"/>. Since we write from the least significant position, we will reverse <code class="inlineCode">s</code> accordingly as well:
        <pre class="programlisting code-one"><code class="hljs-code"># Set reverse ordering
s = s[::-1]
# Construct the state 110
for idx in range(num_qubits):
    if s[idx] == '1':
        qc.x(idx)   
qc.barrier()
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The <a id="_idIndexMarker1422"/>preceding code will initialize and render our circuit as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_12_01.png" alt="Figure 14.5 – Initializing the state, s, to |110 " width="315" height="233"/></figure>
    <p class="packt_figref">Figure 12.1: Initializing the state, s, to <img src="img/B18420_12_021.png" alt="" width="44" height="25"/><a id="_idIndexMarker1423"/></p>
    <ol>
      <li class="numberedList" value="4">Now that we have prepared our state, we can begin transforming it using QFT.</li>
    </ol>
    <p class="normal-one">Let’s review our transformation equation with our state <img src="img/B18420_12_021.png" alt="" width="44" height="25"/><a id="_idIndexMarker1424"/>:</p>
    <p class="center"><img src="img/B18420_12_024.png" alt="" width="581" height="54"/><a id="_idIndexMarker1425"/></p>
    <p class="normal-one">This states that for each qubit where we apply a Hadamard gate, we will need to include rotations while traversing from the qubit down to the least significant qubit—hence, <img src="img/B18420_12_025.png" alt="" width="65" height="25"/><a id="_idIndexMarker1426"/>. As we traverse down, the qubit states decrease by each degree. This means each of the controlled phase rotations, <strong class="keyWord">Control Rotation</strong> (<strong class="keyWord">CROT</strong>), is based on the following matrix representation:</p>
    <p class="center"><img src="img/B18420_12_026.png" alt="" width="223" height="88"/><a id="_idIndexMarker1427"/></p>
    <p class="normal-one">In <a id="_idIndexMarker1428"/>the preceding equation, CROT(q)k is the CU<sub class="subscript">1</sub> gate, and the parameter <em class="italic">q</em> is set as follows:</p>
    <p class="center"><img src="img/B18420_12_027.png" alt="" width="83" height="42"/><a id="_idIndexMarker1429"/></p>
    <p class="normal-one">Therefore, we’ll start with the most significant qubit, <em class="italic">q</em><sub class="subscript-italic" style="font-style: italic;">2</sub>, from our state <img src="img/B18420_05_035.png" alt="" width="27" height="25"/><a id="_idIndexMarker1430"/>, as follows.</p>
    <ol>
      <li class="numberedList" value="5">Starting at the most significant qubit, we’ll add a Hadamard gate to the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"># Import the value pi for our rotations
from numpy import pi
# Always start from the most significant qubit,
# in this case it's q2.
# Step 1, add a Hadamard gate
qc.h(2)
</code></pre>
      </li>
      <li class="numberedList">Now that we have our first step, the next step is to add CROT(<img src="img/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker1431"/>) gates starting at <em class="italic">k=2</em>, which is the index of the most significant qubit position, q<sub class="subscript">2</sub>, and our parameter <img src="img/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker1432"/> starts at the following:</li>
    </ol>
    <p class="center"><img src="img/B18420_12_031.png" alt="" width="202" height="42"/><a id="_idIndexMarker1433"/></p>
    <p class="normal-one">We add the CROT gates from most significant to least significant, starting at <img src="img/B18420_07_009.png" alt="" width="31" height="25"/><a id="_idIndexMarker1434"/>, and doubling the denominator of the parameter as we move down each qubit:</p>
    <pre class="programlisting code-one"><code class="hljs-code"># Step 2, add CROT gates from most significant qubit
qc.cp(pi/2, 1, 2)
</code></pre>
    <ol>
      <li class="numberedList" value="7">We then repeat this as we traverse from the current qubit down to the next qubit—in this case, <em class="keystroke">q</em><sub class="subscript-italic" style="font-style: italic;">0</sub>:
        <pre class="programlisting code-one"><code class="hljs-code"># Step 3, add another CROT from 2 to the next qubit down,
# while doubling the phase denominator
qc.cp(pi/4, 0, 2)
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As we <a id="_idIndexMarker1435"/>are traversing down, the denominator on the parameter is doubling in size as well, such that the next parameter <img src="img/B18420_06_162.png" alt="" width="10" height="25"/><a id="_idIndexMarker1436"/> is as follows (note that all qubits are initialized to the state <img src="img/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker1437"/>:</p>
    <p class="center"><img src="img/B18420_12_035.png" alt="" width="115" height="42"/><a id="_idIndexMarker1438"/></p>
    <p class="normal-one">This renders the following circuit, which now includes the Hadamard gate and the two CROT gates:</p>
    <figure class="mediaobject"><img src="img/B18420_12_02.png" alt="" width="761" height="292"/></figure>
    <p class="packt_figref">Figure 12.2: The first set of transformations starting from the most significant qubit</p>
    <ol>
      <li class="numberedList" value="8">That completes the first level, which dealt with the most significant qubit. We will now move down to the next qubit (the second most significant qubit) and repeat the process of adding a Hadamard gate, followed by CROT(q) gates, where the phase rotations get smaller as we traverse down each qubit. Let’s continue to the next qubit:
        <pre class="programlisting code-one"><code class="hljs-code"># Now that we finished from 2 down to 0
# We'll drop to the next least significant qubit and
# start again,
# Step 1, add a Hadamard gate
qc.h(1)
</code></pre>
      </li>
      <li class="numberedList">This is <a id="_idIndexMarker1439"/>the same as <em class="italic">step 4</em> of adding a Hadamard gate; now, we apply the control rotation gate in the same manner as we did earlier and then draw the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"># Step 2, add Control Rotation (CROT) gates from most
# significant towards
# least significant starting a pi/2, and doubling the
# denominator
# as you go down each qubit.
qc.cp(pi/2, 0, 1)
# Draw the circuit
qc.draw(output='mpl')
# Now that we finished from 1 down to 0
# We'll drop to the next least significant qubit and
# start again.
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will complete the second transformation, which will render the following circuit, which starts with a Hadamard gate and then appends the CROT gates afterward:</p>
    <figure class="mediaobject"><img src="img/B18420_12_03.png" alt="A screenshot of a computer  Description automatically generated with low confidence" width="759" height="216"/></figure>
    <p class="packt_figref">Figure 12.3: The next transformation set starting at the next qubit down</p>
    <ol>
      <li class="numberedList" value="10">Next, we will run our transformation on the last qubit, and then draw the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"># Step 1, add a Hadamard gate
qc.h(0)
# Since we are at the least significant qubit,
# we are done!
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Since <a id="_idIndexMarker1440"/>this is the last qubit and the least significant qubit, it has no lower levels, so we complete the CROT phase of the QFT. This renders the following circuit so far:</p>
    <figure class="mediaobject"><img src="img/B18420_12_04.png" alt="A screenshot of a graph  Description automatically generated with medium confidence" width="758" height="201"/></figure>
    <p class="packt_figref">Figure 12.4: The final transformation of our QFT circuit</p>
    <ol>
      <li class="numberedList" value="11">Finally, once we have set all the rotations, we need to apply swap gates to reverse our results. We need to do this to complete the QFT and set the values in the proper order. The swap is performed from the outermost qubits moving inward until you reach the last two qubits in the middle (if the total number of qubits is even), or until you reach the last two pairs with a single qubit in the middle (if the total number of qubits is odd).</li>
    </ol>
    <p class="normal-one">To simplify this, we can create a function that will swap the outer qubits and work its way toward the middle. In this case, since we only have three qubits, we will only swap the outer two qubits, as follows:</p>
    <pre class="programlisting code-one"><code class="hljs-code"># Define a function which will add the swap gates to the
# outer pair of qubits
def add_swap_gates(qc_swaps, qubits):
    for qubit in range(qubits//2):
        qc_swaps.swap(qubit, qubits-qubit-1)
    return qc_swaps
</code></pre>
    <ol>
      <li class="numberedList" value="12">Now, we <a id="_idIndexMarker1441"/>can run our quantum circuit through the <code class="inlineCode">add_swap_gates</code> function and complete the circuit:
        <pre class="programlisting code-one"><code class="hljs-code">qft_circuit = add_swap_gates(qc, num_qubits)
qft_circuit.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render our QFT circuit, which encodes our <code class="inlineCode">'110'</code> value, as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_12_05.png" alt="A screenshot of a graph  Description automatically generated with medium confidence" width="759" height="184"/></figure>
    <p class="packt_figref">Figure 12.5: The QFT circuit that encodes ‘110’</p>
    <ol>
      <li class="numberedList" value="13">Let’s include some helper functions, similar to the functions we created in the previous chapter, that will run on either simulators or quantum systems. This time, we will include an option to select the number of shots.
        <pre class="programlisting code-one"><code class="hljs-code"># Run on a local Sampler
def run_on_sampler(circuit, shots):
    from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
    from qiskit_ibm_runtime import SamplerV2 as Sampler
    from qiskit_ibm_runtime.fake_provider import FakeManilaV2
    # Run the sampler job locally using FakeManilaV2
    fake_manila = FakeManilaV2()
    pass_manager = generate_preset_pass_manager(backend=fake_manila, optimization_level=1)
    transpiled_qc = pass_manager.run(circuit)
    # To ensure we get fixed results, set seed
    options = {"simulator": {"seed_simulator": 10258}}
    sampler = Sampler(mode=fake_manila, options=options)
     
    result = sampler.run([transpiled_qc], shots=shots).result()[0]
    return result
# Run on the least busy quantum computer
def run_on_qc(circuit, shots):
    # At the time of this writing we are using the latest version of 
    # the Sampler primitive (V2), please review the documentation to follow updates if you are using a previous version.
    from qiskit_ibm_runtime import SamplerV2 as Sampler2
    # Assign least busy device to backend
    backend = 
                    service.least_busy(min_num_qubits=circuit.num_qubits,
             simulator=False, operational=True)
    #Print the least busy device
    print('The least busy device: {}'.format(backend))
    result = {}
    
   transpiler = generate_preset_pass_manager(backend=backend, optimization_level=3) 
   transpiled_qc = transpiler.run(circuit)
   sampler = Sampler2(backend)
   job = sampler.run([transpiled_qc], shots=shots)
   job_result = job.result()
   
   # Extract the results
   result = job_result[0]
   return result
</code></pre>
      </li>
      <li class="numberedList">To visualize <a id="_idIndexMarker1442"/>our QFT results, we can execute the preceding circuit using the state vector simulator to see our final QFT encoding for each qubit:
        <pre class="programlisting code-one"><code class="hljs-code"># Get the state vector simulator to view our final QFT
# state
from qiskit.quantum_info import Statevector
statevector = Statevector(qft_circuit)
plot_bloch_multivector(statevector)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code results in the following encoding for each qubit:</p>
    <figure class="mediaobject"><img src="img/B18420_12_06.png" alt="Figure 14.10 – A Bloch sphere representation of the '110' QFT encoded value " width="631" height="193"/></figure>
    <p class="packt_figref">Figure 12.6: A Bloch sphere representation of the ‘110’ QFT encoded value</p>
    <div><p class="normal">Note that q<sub class="subscript">0</sub> (q<sub class="subscript">2</sub> before the swap) has rotated <img src="img/B18420_12_036.png" alt="" width="40" height="25"/><a id="_idIndexMarker1443"/> (which is a Hadamard (H) plus a <img src="img/B18420_12_037.png" alt="" width="33" height="25"/><a id="_idIndexMarker1444"/> rotation), q<sub class="subscript">1</sub> has rotated <img src="img/B18420_12_038.png" alt="" width="33" height="25"/><a id="_idIndexMarker1445"/>(H), and <em class="italic">q</em><sub class="subscript-italic" style="font-style: italic;">2</sub> (q<sub class="subscript">0</sub> before the swap) has rotated 0, mainly due to q<sub class="subscript">0</sub> having a value of 0 before the swap because it was initialized to <img src="img/B18420_07_007.png" alt="" width="21" height="25"/><a id="_idIndexMarker1446"/>.</p>
    </div>
    <p class="normal">Note <a id="_idIndexMarker1447"/>that each qubit is in a superposition state and varies by phase based on the <code class="inlineCode">'110'</code> encoded value. We can also represent this using the <code class="inlineCode">qsphere</code> object, which will have the same information, only represented in a single sphere object:</p>
    <pre class="programlisting code"><code class="hljs-code">plot_state_qsphere(statevector)
</code></pre>
    <p class="normal">In the following diagram, we can see that the information is encoded into the QSphere and has its encoded representation in the phase and state vector indicated by the color wheel and QSphere, respectively:</p>
    <figure class="mediaobject"><img src="img/B18420_12_07.png" alt="Chart, radar chart  Description automatically generated" width="394" height="409"/></figure>
    <p class="packt_figref">Figure 12.7: A QSphere representation of the QFT representation of the ‘110’ state</p>
    <div><p class="normal">Note <a id="_idIndexMarker1448"/>that the colors indicate the phase of each state specified in the results where, at the time of this writing, green indicates <img src="img/B18420_12_036.png" alt="" width="40" height="25"/><a id="_idIndexMarker1449"/>-degree phase rotation for rotation states ‘000’ and ‘100’.</p>
    </div>
    <p class="normal">Congratulations! You have just completed encoding your first QFT! This is an algorithm that you will see in many other algorithms that depend on periodic functionality.</p>
    <p class="normal">In this section, we learned about the QFT algorithm and implemented it as well. One thing we <a id="_idIndexMarker1450"/>have not covered, but which is important to mention, is that the QFT also has an inverse function called the <strong class="keyWord">Inverse Quantum Fourier Transform</strong> (<strong class="keyWord">IQFT</strong>). This is quite simply the reverse of the QFT and in essence transforms the quantum state from the quantum Fourier basis back to the computational basis. This is done, as described, by reversing the functionality which was performed <a id="_idIndexMarker1451"/>when transforming the QFT which includes reverse rotations. That is to say, if we rotated a qubit <img src="img/B18420_12_041.png" alt="" width="31" height="25"/><a id="_idIndexMarker1452"/>, then when performing an IQFT, we would rotate the qubit by the same angle, only this time in the opposite direction, i.e. <img src="img/B18420_12_042.png" alt="" width="46" height="25"/><a id="_idIndexMarker1453"/>.</p>
    <p class="normal">With an understanding of the basis of state transformation, you are now able to leverage this in many periodic functions and algorithms, such as estimating eigenvalues or unitary matrices and factoring discrete logarithms.</p>
    <p class="normal">Next, we will look at one of the more famous search algorithms: <strong class="keyWord">Grover’s algorithm</strong>.</p>
    <h1 id="_idParaDest-207" class="heading-1">Learning about Grover’s search algorithm</h1>
    <p class="normal">Search algorithms are unique in that they can be leveraged by various algorithms to find information, whether in a data repository or a list of values, such as features in an image. The advantage <a id="_idIndexMarker1454"/>with quantum, of course, is in the potential for speeding up the search. <strong class="keyWord">Grover’s algorithm</strong> is one such example. It uses a well-known technique that allows the use of interference to amplify certain states in our quantum circuit in a way that will increase the amplitude of the value we are searching for and decrease those that we are not. Let’s start, as always, by describing the problem, where each state is analogous to an entry in an unordered list.</p>
    <h2 id="_idParaDest-208" class="heading-2">Understanding the problem</h2>
    <p class="normal">The problem <a id="_idIndexMarker1455"/>here is also very simple: we are given a set of states where all states are set to 0, except one state which is set to 1. We wish to identify which one of those states is set to 1.</p>
    <p class="normal">Classically, this can be done in, in the best case, 1 step, if the first value is set. In the worst case, it would take <em class="italic">N</em> steps, where <em class="italic">N</em> is the total number of states and the last state is set. This means that on average, it will take <em class="italic">N/2</em> steps to find the value as we would need to check each value individually.</p>
    <p class="normal">Clearly, this is not ideal if our set is a very large list. We need to find a better way to find our value. This is where, in 1996, Lov Grover came in and discovered a way to solve this problem with his now-famous quantum algorithm. We’ll step through the implementation of Grover’s algorithm as we try to search for a value in a three-qubit circuit.</p>
    <p class="normal">To describe <a id="_idIndexMarker1456"/>this problem using functions, we can state the following, given a function:</p>
    <p class="center"><img src="img/B18420_12_043.png" alt="" width="127" height="25"/><a id="_idIndexMarker1457"/></p>
    <p class="normal">From the preceding equation, <img src="img/B18420_12_044.png" alt="" width="69" height="25"/><a id="_idIndexMarker1458"/> for all cases of <em class="italic">x</em> except for a specific case, <em class="italic">x*</em>, such that <img src="img/B18420_12_045.png" alt="" width="77" height="25"/><a id="_idIndexMarker1459"/>. Find the value of <em class="italic">x*</em>. Since we will be working with qubits, let’s select a value <em class="italic">N</em>, such that <em class="italic">N</em> = 2<sup class="superscript">n</sup>.</p>
    <p class="normal">Now that we have defined our problem, let’s step through Grover’s search algorithm.</p>
    <h2 id="_idParaDest-209" class="heading-2">Understanding Grover’s search algorithm</h2>
    <p class="normal">Grover’s algorithm is similar to the Deutsch-Jozsa and Bernstein-Vazirani algorithms in that it too <a id="_idIndexMarker1460"/>leverages an oracle. However, note that the example given here illustrates a very simple oracle where we know the tagged state beforehand. This is done for demonstration purposes here; however, in real-world applications, the oracle will not only be more complex, but we will also have no idea which state will be tagged.</p>
    <p class="normal">Another similarity between Deutsch-Josza and Grover’s algorithm is that Grover’s also leverages interference in a way that it will increase the amplitude of the state we are searching for while decreasing all other states, which in turn increases the speed by <img src="img/B18420_12_046.png" alt="" width="27" height="29"/><a id="_idIndexMarker1461"/>, where <em class="italic">N</em> is the number of states to search. This means that rather than iterating through each value within N, we take an exponential speedup, similar to what we did with Deutsch-Josza.</p>
    <p class="normal">We’ll begin by explaining Grover’s search process in order to obtain an understanding of how it works. For a deeper description of the mathematics behind this, I recommend the book <em class="italic">Dancing with Qubits</em> by Robert S. Sutor, which covers this in greater detail.</p>
    <p class="normal">Grover’s search algorithm can be broken down into two main components—perhaps three, if you count initializing all qubits into superposition and adding measurements at the end—but that is something that most quantum algorithms do, so we’ll just stick to the two <a id="_idIndexMarker1462"/>main points. The first is referred to as <strong class="keyWord">Grover’s oracle</strong>, and the second is the <strong class="keyWord">Grover diffusion operator</strong>.</p>
    <p class="normal">In this <a id="_idIndexMarker1463"/>example, we will describe a two-qubit system that, when <a id="_idIndexMarker1464"/>placed in superposition by applying a Hadamard gate to each qubit, provides four possible states—<strong class="keyWord">00</strong>, <strong class="keyWord">01</strong>, <strong class="keyWord">10</strong>, and <strong class="keyWord">11</strong>—as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_12_08.png" alt="A graph with numbers and lines  Description automatically generated with medium confidence" width="825" height="571"/></figure>
    <p class="packt_figref">Figure 12.8: Two qubits in a superposition state</p>
    <p class="normal">When in this state, the average equals the probability amplitude, which in this case is <strong class="keyWord">0.25</strong>, as indicated by the dotted line across the top of each state.</p>
    <p class="normal">For this example, we’ll say the state that we wish to search for is the state <code class="inlineCode">'10'</code>.</p>
    <p class="normal">The first component is the <strong class="keyWord">oracle</strong>, <em class="italic">U</em><sub class="subscript">f</sub>. This is where we generally tag the value we are searching for. By tagging, I mean we will signal that the state that we are searching for will be identified by simply changing the sign of the state from positive to negative. The transition would be as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_12_09.png" alt="A graph with blue squares  Description automatically generated" width="825" height="571"/></figure>
    <p class="packt_figref">Figure 12.9: Changing the sign of the state to negative</p>
    <p class="normal">Now that we <a id="_idIndexMarker1465"/>have changed the sign, we can’t, unfortunately, just measure and go at this point—mainly because, as we know, the probability amplitudes are squared, so our results would all still be equal, which does not provide us with any new information about what we are searching for. However, since we are working with amplitudes, we can leverage interference here by increasing the amplitude <a id="_idIndexMarker1466"/>of the state we tagged and decreasing the amplitude of the other states. <em class="italic">How do we do this?</em> By incorporating the second component of Grover’s search, the <strong class="keyWord">diffusion operator</strong>.</p>
    <p class="normal">The second component of Grover’s algorithm is the <strong class="keyWord">Grover diffusion operator</strong>. Here, we will be performing a mathematical step known as <em class="italic">inversion about the mean</em>. What this does is invert the distance between the average and the peak of each state. This is analogous to <a id="_idIndexMarker1467"/>having each state flip reflectively about the average mean. Visually, the transition will be as follows:</p>
    <figure class="mediaobject"><img src="img/B18420_12_10.png" alt="A graph with blue squares and numbers  Description automatically generated" width="825" height="571"/></figure>
    <p class="packt_figref">Figure 12.10: Inversion about the mean amplifies the states constructively and destructively</p>
    <p class="normal">As we can see from the results of performing the inversion about the mean, the amplification of the tagged state is now significantly higher than the other states. If we were to now take a measurement, we would see that the result with the higher probability is the state we are searching for. Keep in mind, of course, that this is all done with a single query to our quantum circuit!</p>
    <p class="normal">One thing to note is that when the number of states, <em class="italic">N</em>, is large, this means we will need to repeat the diffusion operator steps (and not the oracle constructor steps) multiple times, which is what constructs and destructs the amplitudes. The number of times to optimize the results is <img src="img/B18420_12_047.png" alt="" width="35" height="29"/><a id="_idIndexMarker1468"/>, where <em class="italic">n</em> is the number of qubits.</p>
    <p class="normal">Let’s implement Grover’s search algorithm next.</p>
    <h2 id="_idParaDest-210" class="heading-2">Implementing Grover’s search algorithm</h2>
    <p class="normal">As usual, we’ll explain each step described in the previous section while we work through <a id="_idIndexMarker1469"/>the algorithm step by step. To start, create a new Qiskit notebook for this example and work through the following:</p>
    <ol>
      <li class="numberedList" value="1">We’ll begin by declaring the value we want to set. Let’s set the value to <code class="inlineCode">110</code>. This way, we can use a three-qubit circuit to implement Grover’s algorithm and place all the qubits in superposition by adding a Hadamard gate to each qubit:
        <pre class="programlisting code-one"><code class="hljs-code"># Set the state we wish to search
N = '110'
num_qubits = len(N)
# Create the quantum circuit
qc = QuantumCircuit(num_qubits)
# Set all qubits in superposition
qc.h(range(num_qubits))
qc.barrier()
#Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render our initialized circuit:</p>
    <figure class="mediaobject"><img src="img/B18420_12_11.png" alt="Figure 14.15 – Initialized quantum circuit in superposition " width="266" height="259"/></figure>
    <p class="packt_figref">Figure 12.11: Initialized quantum circuit in superposition</p>
    <ol>
      <li class="numberedList" value="2">Next, we want to encode the state that we want to search—in this case, it is the state <img src="img/B18420_12_048.png" alt="" width="44" height="25"/><a id="_idIndexMarker1470"/>. Here, we will reverse the state and encode <code class="inlineCode">N</code> in the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"># Reverse the state so it's in proper qubit ordering
N = N[::-1]
# Encode N into our circuit
for idx in range(num_qubits):
    if N[idx] == '0':
        qc.x(idx)
qc.barrier()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">For each <a id="_idIndexMarker1471"/>step, we will add a barrier so that we can see the process rendered:</p>
    <figure class="mediaobject"><img src="img/B18420_12_12.png" alt="Figure 14.16 – Encoding our state '110', we mark the '0' qubits in the state with an X gate " width="410" height="223"/></figure>
    <p class="packt_figref">Figure 12.12: Encoding our state ‘110’, we mark the ‘0’ qubits in the state with an X gate</p>
    <ol>
      <li class="numberedList" value="3">Next, we will create Grover’s oracle. What we will do here is first set the most significant qubit in a superposition state, followed by a CNOT gate where the target is the most significant qubit, and the source is all the other qubits. Then, place another Hadamard gate on the most significant qubit to complete the oracle. This will negate the state that we set in the previous source cell, <img src="img/B18420_12_021.png" alt="" width="44" height="25"/><a id="_idIndexMarker1472"/>:
        <pre class="programlisting code-one"><code class="hljs-code"># Create the Grover oracle for our 3-qubit quantum circuit
qc.h(2)
qc.ccx(0, 1, 2)
qc.h(2)
qc.barrier()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code renders the following circuit, which we see sets the two CNOT gates in our oracle surrounded by <strong class="keyWord">H</strong> gates on the most significant qubit:</p>
    <figure class="mediaobject"><img src="img/B18420_12_13.png" alt="Figure 14.17 – Applying Grover's oracle to the circuit " width="643" height="203"/></figure>
    <p class="packt_figref">Figure 12.13: Applying Grover’s oracle to the circuit</p>
    <ol>
      <li class="numberedList" value="4">Now, we <a id="_idIndexMarker1473"/>want to reset the state that we are searching in the circuit so that it returns to the superposition value:
        <pre class="programlisting code-one"><code class="hljs-code"># Reset the value after the oracle
for idx in range(num_qubits):
    if N[idx] == '0':
        qc.x(idx)
qc.barrier()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code completes Grover’s oracle, which we described earlier as the first component of Grover’s search algorithm:</p>
    <figure class="mediaobject"><img src="img/B18420_12_14.png" alt="Figure 14.18 – The first component of Grover's search algorithm " width="660" height="173"/></figure>
    <p class="packt_figref">Figure 12.14: The first component of Grover’s search algorithm</p>
    <ol>
      <li class="numberedList" value="5">Next, we will implement the second component, the Grover diffusion operator. We start by applying all the qubits in a superposition state:
        <pre class="programlisting code-one"><code class="hljs-code"># Set all qubits in superposition
qc.h(range(num_qubits))
qc.x(range(num_qubits))
qc.barrier()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This renders <a id="_idIndexMarker1474"/>the following superposition state, followed by Grover’s oracle:</p>
    <figure class="mediaobject"><img src="img/B18420_12_15.png" alt="Chart, box and whisker chart  Description automatically generated" width="759" height="176"/></figure>
    <p class="packt_figref">Figure 12.15: The first step in the Grover diffusion operator: apply H gates to all qubits</p>
    <ol>
      <li class="numberedList" value="6">Next, we will flip all the 0-state qubits to their negative phase. Here, the most significant qubit is set as the target of the two CNOT gates:
        <pre class="programlisting code-one"><code class="hljs-code"># Apply another oracle, same as the previous
qc.h(2)
qc.ccx(0, 1, 2)
qc.h(2)
qc.barrier()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This renders the next step in the diffusion operator—that is, inversion about the mean:</p>
    <figure class="mediaobject"><img src="img/B18420_12_16.png" alt="Figure 14.20 – The second step of the diffusion operator to invert about the mean " width="758" height="119"/></figure>
    <p class="packt_figref">Figure 12.16: The second step of the diffusion operator: to invert about the mean</p>
    <ol>
      <li class="numberedList" value="7">Finally, we wrap <a id="_idIndexMarker1475"/>up the Grover diffusion operator by applying the first step in reverse. Since we applied a set of H gates across all qubits, followed by a set of X gates, also across all qubits, we will reverse this in the following manner. Apply X gates across all qubits, then apply H gates across all qubits:
        <pre class="programlisting code-one"><code class="hljs-code"># Reapply the X rotations on all qubits
qc.x(range(num_qubits))
qc.barrier()
# Reapply Hadamard gates to all qubits
qc.h(range(num_qubits))
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code completes the Grover diffusion operator component of the quantum circuit:</p>
    <figure class="mediaobject"><img src="img/B18420_12_17.png" alt="Figure 14.21 – The complete Grover's algorithm circuit " width="760" height="104"/></figure>
    <p class="packt_figref">Figure 12.17: The complete Grover’s algorithm circuit</p>
    <p class="normal-one">To determine the ideal number of times to repeat the diffusion operator, <code class="inlineCode">n</code>, we simply need to compute n as follows,</p>
    <p class="normal-one"><img src="img/B18420_12_050.png" alt="" width="129" height="29"/><a id="_idIndexMarker1476"/></p>
    <p class="normal-one">where N is the number of (log N) qubits N=4 for two qubits; In this example, we should add a second diffusion operator to bring the error down from 3% to 1%.</p>
    <ol>
      <li class="numberedList" value="8">Now, we’ll just add measurement operators and prepare to run the circuit on the backend, but first on a local simulator on your device:
        <pre class="programlisting code-one"><code class="hljs-code"># Add measurement operators
qc.measure_all()
# Draw the circuit
qc.draw(output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The <a id="_idIndexMarker1477"/>preceding code will prepare the following quantum circuit to run on either a simulator or quantum computer:</p>
    <figure class="mediaobject"><img src="img/B18420_12_18.png" alt="Figure 14.22 – The complete quantum circuit ready to run on a simulator or quantum system " width="759" height="104"/></figure>
    <p class="packt_figref">Figure 12.18: The complete quantum circuit ready to run on a simulator or quantum system</p>
    <ol>
      <li class="numberedList" value="9">We’ll start by running the function we created to execute our circuit using the Sampler primitive:
        <pre class="programlisting code-one"><code class="hljs-code"># Run on the sampler
result = run_on_sampler(qc, shots=4000)
counts = result.data.meas.get_counts()
# Print and plot results
print(counts)
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">After executing the circuit, this will print and plot our results as follows:</p>
    <pre class="programlisting code-one"><code class="hljs-code">{'010': 274, '110': 2237, '000': 198, '100': 499, '101': 175, '111': 238, '001': 191, '011': 188}
</code></pre>
    <p class="normal-one">In the following figure, we can see that the state we are searching has the higher probability, a quasi-probability of 0.559%, whereas all the other states have a significantly lower probability of around 0.05%:</p>
    <figure class="mediaobject"><img src="img/B18420_12_19.png" alt="Figure 14.23 – Results of executing Grover's search of state 110 on a quantum simulator " width="743" height="516"/></figure>
    <p class="packt_figref">Figure 12.19: Results of executing Grover’s search of state 110 on a Sampler</p>
    <p class="normal-one">Success! As expected, our Grover’s algorithm implementation has found the state within a single query.</p>
    <ol>
      <li class="numberedList" value="10">Now, let’s <a id="_idIndexMarker1478"/>try it on a quantum device. We’ll select the quantum computer that is the least busy and operational and has the number of qubits necessary to run our quantum circuit.
        <pre class="programlisting code-one"><code class="hljs-code"># Execute the circuit on the least busy quantum computer
backend = service.least_busy(min_num_qubits = num_qubits,
                             simulator = False,                    
                             operational = True)
print("Set backend: ", backend)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will print out the least busy quantum computer and assign it to the <code class="inlineCode">backend</code> variable.</p>
    <ol>
      <li class="numberedList" value="11">We can now execute this as we did previously with the simulator, then print and plot the results:
        <pre class="programlisting code-one"><code class="hljs-code"># Run the circuit on the backend
shots = 1000
results = run_on_qc(qc, shots)
counts = results.data.meas.get_counts()
# Print results
print(counts)
</code></pre>
      </li>
      <li class="numberedList">Once <a id="_idIndexMarker1479"/>completed, you should see something similar to the following output:
        <pre class="programlisting code-one"><code class="hljs-code">The least busy device: &lt;IBMBackend('ibm_osaka')&gt;
{'000': 85, '100': 52, '111': 219, '010': 61, '110': 373, '001': 73, '011': 71, '101': 66}
</code></pre>
      </li>
      <li class="numberedList">We can now plot the quasi distribution of the results on a graph using the following:
        <pre class="programlisting code-one"><code class="hljs-code"># Plot results
plot_distribution(counts)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will display the following output:</p>
    <p class="normal-one"> <img src="img/B18420_12_20.png" alt="A graph with numbers and a bar  Description automatically generated" width="649" height="471"/></p>
    <p class="packt_figref">Figure 12.20: Probability distribution</p>
    <p class="normal-one">This, of course, depends on the device itself as each system is different from one another. However, the results should be clear that the state with the highest probability is the state that we are searching for—in this case, <img src="img/B18420_12_021.png" alt="" width="44" height="25"/><a id="_idIndexMarker1480"/>.</p>
    <p class="normal">As we can see here, the result with the highest probability is the state we are searching for, and the <a id="_idIndexMarker1481"/>other states have a lower probability. We can see enough of a difference between each state to observe that the Grover’s search algorithm that we implemented does indeed identify the state we are searching for. You might also want to try this with a larger value N, just so you can observe the results.</p>
    <p class="normal">Congratulations! You have successfully implemented a variety of quantum algorithms, which are <a id="_idIndexMarker1482"/>foundational to understanding how quantum computers are different in how they solve problems compared to classical systems and how they have the potential to solve real-world problems.</p>
    <h1 id="_idParaDest-211" class="heading-1">Summary</h1>
    <p class="normal">There are many algorithms that implement many of the techniques we covered in this and the previous chapter on quantum algorithms, many of which you will see used in other algorithms, such as the <strong class="keyWord">quantum amplitude estimation</strong> and <strong class="keyWord">variational quantum eigensolver</strong> algorithms, and so on.</p>
    <p class="normal">I do strongly suggest trying variations of these algorithms yourself to get a better feel and understanding of how they work.</p>
    <p class="normal">In the next and final chapter, we will look at the features that are built into Qiskit, which allow you as a researcher or developer to leverage them to create your own quantum algorithms. You will gain the skills to integrate these algorithms into your existing research or applications without having to worry about developing circuits, mitigating against noise, or any of the other components that make up an algorithm in Qiskit. This book has already done the heavy lifting for you, so you can simply implement the algorithm and process the results as you see fit.</p>
    <h1 id="_idParaDest-212" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">What other problems can you solve using periodic functions?</li>
      <li class="numberedList">Implement QFT on a five-qubit state—for example, <code class="inlineCode">'10110'</code>.</li>
      <li class="numberedList">Using Grover’s algorithm, find the following states: <code class="inlineCode">'101'</code>, <code class="inlineCode">'001'</code>, and <code class="inlineCode">'010'</code>.</li>
      <li class="numberedList">How many iterations of Grover’s diffusion operator would you need to run to find the state <img src="img/B18420_12_052.png" alt="" width="67" height="25"/><a id="_idIndexMarker1483"/>?</li>
      <li class="numberedList">Rerun the Grover’s search example. Only repeat Grover’s diffusion operator twice and note the difference in the result. What do you see that is different? What would you expect to change if you ran it more than three times?</li>
    </ol>
    <h1 id="_idParaDest-213" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_12.xhtml">https://packt.link/3FyN1</a></p>
    <p class="normal"><img src="img/QR_Code2617625996838265933.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>