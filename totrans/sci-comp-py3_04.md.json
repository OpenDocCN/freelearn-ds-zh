["```py\nv = array([1.,2.,3.])\n```", "```py\n# two vectors with three components\nv1 = array([1., 2., 3.])\nv2 = array([2, 0, 1.])\n\n# scalar multiplications/divisions\n2*v1 # array([2., 4., 6.])\nv1/2 # array([0.5, 1., 1.5])\n\n# linear combinations\n3*v1 # array([ 3., 6., 9.])\n3*v1 + 2*v2 # array([ 7., 6., 11.])\n\n# norm\nfrom scipy.linalg import norm\nnorm(v1) # 3.7416573867739413\n# scalar product\ndot(v1, v2) # 5.\nv1 @ v2 # 5 ; alternative formulation\n```", "```py\n# elementwise operations:\nv1 * v2 # array([2., 0., 3.])\nv2 / v1 # array([2.,0.,.333333])\nv1 - v2 # array([-1., 2., 2.])\nv1 + v2 # array([ 3., 2., 4.])\n```", "```py\ncos(v1) # cosine, elementwise: array([ 0.5403,\n                                 -0.4161, -0.9899])\n```", "```py\nM = array([[1.,2],[0.,1]])\n```", "```py\nR = array([[1.,2.,1.]]) # notice the double brackets: \n                        # this is a matrix\nshape(R)                # (1,3): this is a row matrix\n```", "```py\nC = array([1., 2., 1.]).reshape(3, 1)\nshape(C) # (3,1): this is a column matrix\n```", "```py\nv = array([1., 2., 3])\nM = array([[1., 2],[3., 4]])\n\nv[0] # works as for lists\nv[1:] # array([2., 3.])\n\nM[0, 0] # 1.\nM[1:] # returns the matrix array([[3., 4]])\nM[1] # returns the vector array([3., 4.])\n\n# access\nv[0] # 1.\nv[0] = 10\n\n# slices\nv[:2] # array([10., 2.])\nv[:2] = [0, 1] # now v == array([0., 1., 3.])\nv[:2] = [1, 2, 3] # error!\n```", "```py\ndot(M, v) # matrix vector multiplication; returns a vector\nM @ v # alternative formulation\n```", "```py\ndot(v, w) # scalar product; the result is a scalar\nv @ w # alternative formulation\n```", "```py\ndot(M, N) # results in a matrix\nM @ N # alternative formulation\n```", "```py\nfrom scipy.linalg import solve\nx = solve(A, b)\n```", "```py\nfrom scipy.linalg import solve\nA = array([[1., 2.], [3., 4.]])\nb = array([1., 4.])\nx = solve(A, b)\nallclose(dot(A, x), b) # True\nallclose(A @ x, b) # alternative formulation\n```", "```py\nangle = pi/3\nM = array([[cos(angle), -sin(angle)], \n           [sin(angle), cos(angle)]])\nv = array([1., 0.])\ny = dot(M, v)\n```", "```py\nA = array([[1, 2, 3], [3, 4, 6]])\nA.shape   # (2, 3)\nA.dtype   # dtype('int64')\nA.strides # (24, 8)\n```", "```py\nV = array([1., 2., 1.], dtype=float)\n```", "```py\nV = array([1., 2., 1.], dtype=complex)\n```", "```py\nV = array([1, 2]) # [1, 2] is a list of integers\nV.dtype # int\nV = array([1., 2]) # [1., 2] mix float/integer\nV.dtype # float\nV = array([1\\. + 0j, 2.]) # mix float/complex\nV.dtype # complex\n```", "```py\na = array([1, 2, 3])\na[0] = 0.5\na # now: array([0, 2, 3])\n```", "```py\n # the identity matrix in 2D\n Id = array([[1., 0.], [0., 1.]])\n # Python allows this:\n Id = array([[1., 0.],\n             [0., 1.]])\n # which is more readable\n```", "```py\nM = array([[1., 2.],[3., 4.]])\nM[0, 0] # first row, first column: 1.\nM[-1, 0] # last row, first column: 3.\n```", "```py\nv = array([1., 2., 3.])\nv1 = v[:2] # v1 is array([1., 2.])\nv1[0] = 0\\. # if v1 is changed ...\nv # ... v is changed too: array([0., 2., 3.])\n```", "```py\nM[1, 3] = 2.0 # scalar\n```", "```py\nM[2, :] = [1., 2., 3.] # vector\n```", "```py\nM[1:3, :] = array([[1., 2., 3.],[-1.,-2., -3.]])\n```", "```py\nI = identity(3)\n```", "```py\nI = array([[ 1., 0., 0.],\n           [ 0., 1., 0.],\n           [ 0., 0., 1.]])\n```", "```py\nM = identity(3)\nshape(M) # (3, 3)\n```", "```py\nv = array([1., 2., 1., 4.])\nshape(v) # (4,) <- singleton (1-tuple)\n```", "```py\nM = array([[1.,2.]])\nshape(M) # (1,2)\nM.shape # (1,2)\n```", "```py\nshape(1.) # ()\nshape([1,2]) # (2,)\nshape([[1,2]]) # (1,2)\n```", "```py\nndim(A) # 2\nA.ndim # 2\n```", "```py\nT = zeros((2,2,3)) # tensor of shape (2,2,3); three dimensions\nndim(T) # 3\nlen(shape(T)) # 3\n```", "```py\nv = array([0,1,2,3,4,5])\nM = v.reshape(2,3)\nshape(M) # returns (2,3)\nM[0,0] = 10 # now v[0] is 10\n```", "```py\n ValueError: total size of new array must be unchanged.\n```", "```py\nv = array([1, 2, 3, 4, 5, 6, 7, 8])\nM = v.reshape(2, -1)\nshape(M) # returns (2, 4)\nM = v.reshape(-1, 2)\nshape(M) # returns (4,2 )\nM = v.reshape(3,- 1) # returns error\n```", "```py\nA = ...\nshape(A) # 3,4\n\nB = A.T # A transpose\nshape(B) # 4,3\n```", "```py\nA= array([[ 1., 2.],[ 3., 4.]])\nB=A.T\nA[1,1]=5.\nB[1,1] # 5\n```", "```py\nv = array([1., 2., 3.])\nv.T # exactly the same vector!\n```", "```py\nv.reshape(-1, 1) # column matrix containing v\nv.reshape(1, -1) # row matrix containing v\n```", "```py\nconcatenate((a1, a2, ...), axis = 0)\n```", "```py\n# v is supposed to have an even length.\ndef symp(v):\n    n = len(v) // 2 # use the integer division //\n    return hstack([v[-n:], -v[:n]])\n```", "```py\ncos(pi) # -1\ncos(array([[0, pi/2, pi]])) # array([[1, 0, -1]])\n```", "```py\n2 * array([2, 4]) # array([4, 8])\narray([1, 2]) * array([1, 8]) # array([1, 16])\narray([1, 2])**2 # array([1, 4])\n2**array([1, 2]) # array([1, 4])\narray([1, 2])**array([1, 2]) # array([1, 4])\n```", "```py\ndef const(x):\n    return 1\nconst(array([0, 2])) # returns 1 instead of array([1, 1])\n```", "```py\ndef heaviside(x):\n    if x >= 0:\n        return 1.\n    else: \n        return 0.\n\nheaviside(array([-1, 2])) # error\n```", "```py\nvheaviside = vectorize(heaviside)\nvheaviside(array([-1, 2])) # array([0, 1]) as expected\n```", "```py\nxvals = linspace(-1, 1, 100)\nplot(xvals, vectorize(heaviside)(xvals))\naxis([-1.5, 1.5, -0.5, 1.5])\n```", "```py\nsum(A) # 36\n```", "```py\nsum(A, axis=0) # array([ 6, 8, 10, 12])\n```", "```py\nA.sum(axis=1) # array([10, 26])\n```", "```py\nimport scipy.linalg as sl\n[LU,piv] = sl.lu_factor(A)\n```", "```py\nimport scipy.linalg as sl\nxi = sl.lu_solve((LU, piv), bi)\n```", "```py\nimport scipy.linalg as sl \n[U1, Sigma_1, VT] = sl.svd(A, full_matrices = False,\n                              compute_uv = True) \nxast = dot(VT.T, dot(U1.T, b) / Sigma_1)\nr = dot(A, xast) - b # computes the residual\nnr = sl.norm(r, 2) # computes the Euclidean norm of r\n```"]