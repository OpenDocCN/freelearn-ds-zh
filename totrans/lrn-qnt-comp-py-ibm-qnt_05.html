<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer283" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-80" class="chapterTitle">Understanding the Qubit</h1>
    <p class="normal">We are all very familiar with the classical bit, or just the bit, with respect to current computer hardware systems. It is the fundamental unit used to compute everything from simple mathematical problems, such as addition and multiplication, to more complex algorithms that involve a large collection of information.</p>
    <p class="normal">Quantum computers have a similar<a id="_idIndexMarker329"/> fundamental unit called a <strong class="keyWord">quantum bit,</strong> or <strong class="keyWord">qubit</strong>, as it is commonly referred to. In this chapter, we will describe what a qubit is, both from a mathematical (computational) and a hardware perspective, to help you understand how they are used to calculate information. We will cover the differences between qubits and bits, particularly regarding how calculations are defined. This chapter will then transition from single to multi-qubit states and talk about the advantages of multi-qubit states.</p>
    <p class="normal">We will also provide an overview of the hardware implementation of a qubit and how qubits are used to compute information. Since we will be using the Qiskit Runtime service to run our experiments, you will be using the superconducting qubit systems that are available to you. The descriptions and calculations are hardware independent; much of the information we will cover will apply to most of the other available quantum hardware systems.</p>
    <p class="normal">Finally, we will discuss how quantum systems read, manipulate, and control the flow of information to and from a qubit from a classical system.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Comparing classical and quantum bits</li>
      <li class="bulletList">Visualizing the state vector of a qubit</li>
      <li class="bulletList">Visualizing the state vectors of multiple qubits</li>
      <li class="bulletList">Implementing qubits on a superconducting system</li>
    </ul>
    <h1 id="_idParaDest-81" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, some basic knowledge of computer architecture, basic linear algebra, and binary logic might come in handy. Knowledge of how bits are used to calculate will be useful but is not a hard requirement as the focus will be primarily on the qubit. Here is the source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-82" class="heading-1">Comparing classical and quantum bits</h1>
    <p class="normal">In this section, we will compare and review the building blocks of a classical bit and a few of the operations that are performed on them via classical gates. We will then learn about the fundamental unit of a <a id="_idIndexMarker330"/>quantum computer, the qubit, and <a id="_idIndexMarker331"/>how it is similar to the bit, yet due to its quantum computational principles, which we learned about in the previous chapter, has a larger computational space than the bit.</p>
    <h2 id="_idParaDest-83" class="heading-2">Reviewing the classical bit</h2>
    <p class="normal">Before we delve into<a id="_idIndexMarker332"/> what a quantum bit is and how it is used, let’s take a brief moment to refresh our memories about the classical bit. Just as the quantum bit is the fundamental building block of quantum algorithms, the bit has the same role in classical computational systems.</p>
    <p class="normal">In computational systems, the bit is used to define a logical state, often referenced as either on or off, true or false, or the most commonly used option, 1 or 0. The transition between states can be applied physically either after it’s triggered by an operation, such as the result of an <strong class="keyWord">AND gate</strong>, or as <a id="_idIndexMarker333"/>a result of some input from an external entity, such as reading from an external data source. It is usually represented using transistors, which detect voltage differences and usually contain a threshold that determines whether the transistor is in a low (0) or high (1) state. The voltage thresholds, usually referred to as <strong class="keyWord">Transistor-Transistor Logic</strong> (<strong class="keyWord">TTL</strong>) voltage, are<a id="_idIndexMarker334"/> generally between 0 and 0.5 volts to indicate low and between 2 and 5 volts to indicate high.</p>
    <p class="normal">The following diagram illustrates the simple process of a NOT operation being conducted on a bit. The bit is first initialized or set to a state, either 0 or 1. Then, an operation is performed on the bit and, depending on the result of the operation, the bit’s state will either change or remain the same. The information is then available to be read and/or stored. In this <a id="_idIndexMarker335"/>example, the NOT operation would change the state from 0 to 1 or vice versa:</p>
    <figure class="mediaobject"><img src="../Images/B18420_05_01.png" alt="Figure 5.1 – NOT operation of a bit " width="414" height="177"/></figure>
    <p class="packt_figref">Figure 5.1: NOT operation of a bit</p>
    <p class="normal">The implementation of a bit can be in various forms: flip flops, TTL, and so on. The information can be stored by writing the value to a persistent data repository to be read later. Calculations using bits are<a id="_idIndexMarker336"/> usually done using a <strong class="keyWord">bitstring</strong>, which is a set of individual bits combined to represent a string of 1s and 0s, usually noted as follows:</p>
    <p class="center"><img src="../Images/B18420_05_001.png" alt="" width="88" height="25"/><a id="_idIndexMarker337"/></p>
    <p class="normal">This indicates that <em class="italic">x</em> is a bitstring of 4 bits, where each bit can be either <code class="inlineCode">1</code> or <code class="inlineCode">0</code>; for example, <code class="inlineCode">0010</code> or <code class="inlineCode">1101</code>.</p>
    <p class="normal">Calculations using bits are generally done using binary logic. For example, let’s say we wanted to add two numbers; say, 2 and 3. We would simply assign the values 2 and 3 to a variable, which is stored in binary. Then, we would add the two numbers using binary addition and carry the values, which will result in 5, illustrated as follows. Please create a new notebook and enter the following:</p>
    <pre class="programlisting code"><code class="hljs-code">%run helper_file_1.0.ipynb
<span class="hljs-comment">#Adding two binary numbers</span>
two = 0b010
three = 0b011
answer = two + three
<span class="hljs-built_in">print</span>(bin(answer))
</code></pre>
    <p class="normal">Running the preceding code snippet in a new notebook would result in the binary value of 5, which is <code class="inlineCode">0b101</code>. The code reads the binary values of <code class="inlineCode">2</code> and <code class="inlineCode">3</code> and returns the result as a binary called <code class="inlineCode">answer</code>, which is printed as a binary using the <code class="inlineCode">bin()</code> function. In order to obtain the results of adding two numbers together, classical systems use Modulo 2 arithmetic, which is the result of using logic gates, in this case, an <strong class="keyWord">XOR</strong> gate. When <strong class="keyWord">XORing</strong> two input <a id="_idIndexMarker338"/>bits, that is, <img src="../Images/B18420_05_002.png" alt="" width="194" height="25"/><a id="_idIndexMarker339"/>, the input values <a id="_idIndexMarker340"/>can also be written as two binary numbers, <em class="italic">x</em><sub class="subscript">1</sub> and <em class="italic">x</em><sub class="subscript">2</sub>; that is, <img src="../Images/B18420_05_003.png" alt="" width="71" height="25"/><a id="_idIndexMarker341"/>. Note<a id="_idIndexMarker342"/> that the result will work for the following input values of x<sub class="subscript">1</sub> and <em class="italic">x</em><sub class="subscript">2</sub>: <code class="inlineCode">0+0</code>, <code class="inlineCode">0+1</code>, and <code class="inlineCode">1+0</code>. However, when the input values of <em class="italic">x</em><sub class="subscript">1</sub> and <em class="italic">x</em><sub class="subscript">2</sub> are <code class="inlineCode">1+1</code>, we will need a second qubit to carry the value, hence the result for <code class="inlineCode">1+1</code> will be <code class="inlineCode">10</code>.</p>
    <p class="normal"><em class="italic">So, why did we go through such a simple example?</em> The point was not to bore you with a simple binary calculation; the idea was to provide a refresher about the mechanics of what happens at the gate level when computing on a classical system. This way, when describing the quantum system, it will help you compare and contrast the differences regarding how information is created, calculated, and stored. With that, we’ll move on to the next section and describe what a qubit is.</p>
    <h2 id="_idParaDest-84" class="heading-2">Understanding the qubit</h2>
    <p class="normal">Similar to the bit, which we described previously, the qubit is the fundamental unit in quantum information science. The <a id="_idIndexMarker343"/>qubit is similar to the bit in that it can represent the same two states, namely 0 and 1, although a qubit represents a quantum state. The value of the qubit can be read. By read, we mean we can measure the results, which we covered in <em class="chapterRef">Chapter 4</em>, <em class="italic">Understanding Basic Quantum Computing Principles</em>.</p>
    <p class="normal">They can also be manipulated to derive calculations based on operations performed on each qubit. Recall that the state of a bit can be represented by either a 0 or a 1. A qubit can also be represented as a complex linear combination of 0 and 1. In order to prevent confusion and to differentiate between a bit and a qubit, we will use <strong class="keyWord">Dirac notation</strong>, <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker344"/> and <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker345"/>, to represent the quantum version of the aforementioned 0 and 1 states, respectively. Let’s start by visualizing a few things to help us see the difference between the two states.</p>
    <p class="normal">To begin, the state of a qubit is generally represented as an array or a vector that describes the computational basis states of the qubit, which, in a <strong class="keyWord">Hilbert space</strong>, is often denoted as <img src="../Images/B18420_05_006.png" alt="" width="25" height="25"/><a id="_idIndexMarker346"/>.</p>
    <div class="note">
      <p class="normal">A Hilbert space is, in essence, a vector space of all possible real and complex numbers. Hilbert spaces are often applied in the context of infinite-dimensional vector spaces, whereas Euclidean space, for example, refers to a finite-dimensional linear space with an inner product.</p>
    </div>
    <p class="normal">The quantum state can be <a id="_idIndexMarker347"/>presented as two basis vectors that are orthogonal to each other, as follows:</p>
    <p class="center"><img src="../Images/B18420_05_007.png" alt="" width="73" height="42"/><a id="_idIndexMarker348"/></p>
    <p class="normal">The second vector is given as follows:</p>
    <p class="center"><img src="../Images/B18420_05_008.png" alt="" width="73" height="40"/><a id="_idIndexMarker349"/></p>
    <p class="normal">As we can see, bits and qubits are similar in that they can represent two basis states, in this case, 0 and 1. Where the qubits differ from classical bits is that a qubit is always in a linear combination of basis states, which is to say that they are always in a superposition of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker350"/> and <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker351"/>. More formally, this is represented in the following format:</p>
    <p class="center"><img src="../Images/B18420_05_011.png" alt="" width="173" height="25"/><a id="_idIndexMarker352"/></p>
    <p class="normal">From the previous equation, we can say that <img src="../Images/B18420_05_017.png" alt="" width="13" height="25"/><a id="_idIndexMarker353"/> and <img src="../Images/B18420_05_018.png" alt="" width="10" height="25"/><a id="_idIndexMarker354"/> are complex in that the sum of their magnitudes is equal to 1 and each squared coefficient represents the probability amplitude, which represents the probability of measuring a <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker355"/> or a <img src="../Images/B18420_05_005.png" alt="" width="23" height="25"/><a id="_idIndexMarker356"/>, of the corresponding basis state:</p>
    <p class="center"><img src="../Images/B18420_05_014.png" alt="" width="127" height="25"/><a id="_idIndexMarker357"/></p>
    <p class="normal">Another thing to know about quantum mechanics is that we cannot obtain the values of <img src="../Images/B18420_05_017.png" alt="" width="13" height="25"/><a id="_idIndexMarker358"/> and <img src="../Images/B18420_05_018.png" alt="" width="10" height="25"/><a id="_idIndexMarker359"/>, even when measuring the qubit. Measuring a qubit requires a qubit to collapse into one of the basis states of 0 or 1.</p>
    <p class="normal"><img src="../Images/B18420_05_017.png" alt="" width="13" height="25"/><a id="_idIndexMarker360"/> and <img src="../Images/B18420_05_018.png" alt="" width="10" height="25"/><a id="_idIndexMarker361"/> merely provide some probabilistic information as to whether the results would be one or the other, but this is not a certainty. This is one of the mysteries of quantum mechanics. For now, you can conceptualize measuring a qubit as similar to observing or collapsing a spinning coin to reveal whether it is heads or tails. Once it’s been measured, or collapsed, you are not able to have the coin <em class="italic">continue</em> spinning without restarting the experiment, so all information is lost. You would have to repeat the full operation of spinning the coin again.</p>
    <p class="normal">Visualizing the qubit states can be done using a simple two-dimensional plane, where the <em class="italic">x</em> axis is used to denote the <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker362"/> state and the <em class="italic">y</em> axis is used to denote the <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker363"/> state. Therefore, the vector can be used to represent the probability of each state, which should total 1.</p>
    <p class="normal">In this section, we <a id="_idIndexMarker364"/>covered the differences between bits and qubits. In the next section, we will learn how to visualize qubits and their states using state vectors.</p>
    <h1 id="_idParaDest-85" class="heading-1">Visualizing the state vector of a qubit</h1>
    <p class="normal">Another visual representation of a qubit and its states is the <strong class="keyWord">Bloch sphere</strong>, named after the physicist Felix Bloch. The<a id="_idIndexMarker365"/> Bloch sphere is an ordinary three-dimensional sphere that’s generally used as a geometrical representation of the<a id="_idIndexMarker366"/> qubit. By this, we mean the sphere can represent a qubit’s state as a point anywhere on the surface of the Bloch sphere. As described in the previous chapter, the basis states are represented by the north and south poles.</p>
    <p class="normal">Conventionally, the north pole of the Bloch sphere represents the <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker367"/> state, while the south pole represents the <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker368"/> state. Any point on the surface of the Bloch sphere can represent the linear combination of states as a unit vector from the center (origin) to the surface of the Bloch sphere.</p>
    <p class="normal">Since we have the quantum mechanical constraint that the total probability of the vector must equal 1, we get the following formula:</p>
    <p class="center"><img src="../Images/B18420_05_023.png" alt="" width="77" height="25"/><a id="_idIndexMarker369"/></p>
    <p class="normal">The vector can then only rotate around the <img src="../Images/B18420_05_024.png" alt="" width="44" height="25"/><a id="_idIndexMarker370"/> and <img src="../Images/B18420_05_025.png" alt="" width="42" height="25"/><a id="_idIndexMarker371"/> axes of the Bloch sphere by using the following representation:</p>
    <p class="center"><img src="../Images/B18420_05_026.png" alt="" width="427" height="25"/><a id="_idIndexMarker372"/></p>
    <p class="normal">Here, <img src="../Images/B18420_05_027.png" alt="" width="10" height="25"/><a id="_idIndexMarker373"/> (representing the amplitude of the qubit) and <img src="../Images/B18420_05_028.png" alt="" width="15" height="25"/><a id="_idIndexMarker374"/> (representing the phase of the qubit) have the values (limits) <img src="../Images/B18420_05_029.png" alt="" width="83" height="25"/><a id="_idIndexMarker375"/> and <img src="../Images/B18420_05_030.png" alt="" width="85" height="25"/><a id="_idIndexMarker376"/>. What this illustrates is that any point on the sphere is unique as long as the values of <img src="../Images/B18420_05_027.png" alt="" width="10" height="25"/><a id="_idIndexMarker377"/> and <img src="../Images/B18420_05_028.png" alt="" width="15" height="25"/><a id="_idIndexMarker378"/> are themselves unique, where <img src="../Images/B18420_05_027.png" alt="" width="10" height="25"/><a id="_idIndexMarker379"/> represents the colatitude to the <em class="italic">z</em> axis and <img src="../Images/B18420_05_028.png" alt="" width="15" height="25"/><a id="_idIndexMarker380"/> represents the longitude from the <em class="italic">x</em> axis. The quantum state <img src="../Images/B18420_05_035.png" alt="" width="27" height="25"/><a id="_idIndexMarker381"/> is set from the initial state <img src="../Images/B18420_05_004.png" alt="" width="23" height="25"/><a id="_idIndexMarker382"/> after the rotations of <img src="../Images/B18420_05_027.png" alt="" width="10" height="25"/><a id="_idIndexMarker383"/> and <img src="../Images/B18420_05_028.png" alt="" width="15" height="25"/><a id="_idIndexMarker384"/> have been applied, as illustrated in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_05_02.png" alt="Diagram  Description automatically generated" width="457" height="420"/></figure>
    <p class="packt_figref">Figure 5.2: Qubit Bloch sphere</p>
    <p class="packt_figref">(image source: https://commons.wikimedia.org/wiki/File: Sphere_bloch.jpg)</p>
    <p class="normal">To continue describing a<a id="_idIndexMarker385"/> qubit, we will use visuals to help illustrate <a id="_idIndexMarker386"/>some key concepts that can be seen on the Bloch sphere. This will also help provide further hands-on exercises for you.</p>
    <h2 id="_idParaDest-86" class="heading-2">Visualizing the representation of a qubit</h2>
    <p class="normal">In this section, we will <a id="_idIndexMarker387"/>visualize the representation of a qubit state using two visualization plotters, the <strong class="keyWord">Bloch sphere</strong> and the <strong class="keyWord">qsphere</strong>. We will begin by creating the <a id="_idIndexMarker388"/>Bloch sphere of a qubit in the initial state of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker389"/> so that we can visualize the state vector and phase of a qubit:</p>
    <ol>
      <li class="numberedList" value="1">Create a new notebook and we’ll start as we would with all our notebooks by loading our helper file first. Note, of course, if you wish to reuse the notebook from earlier, you can do so and skip this step:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Load the helper file</span>
%run helper_file_1.0.ipynb
</code></pre>
      </li>
      <li class="numberedList">Next, we will create a simple circuit with just a single qubit and use the visualization tools we imported to visualize the qubit state. We’ll import the first one in its initial state of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker390"/>.</li>
    </ol>
    <p class="normal-one">The following snippet will create the quantum circuit with a single qubit, and then we will get the state vector simulator from our backend. We will be using the state vector simulator to obtain the state information about the circuit once it has<a id="_idIndexMarker391"/> finished, whereas the <strong class="keyWord">qasm</strong> simulator returns count information. Finally, we will execute our circuit and get the state vector results:</p>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment">#Create a simple circuit with just one qubit</span>
qc = QuantumCircuit(<span class="hljs-number">1</span>)
</code></pre>
    <ol>
      <li class="numberedList" value="3">Next, we will run our circuit on the state vector simulator and view the results on the Bloch sphere by passing the <code class="inlineCode">statevectorResult</code> object into the argument of the <code class="inlineCode">plot_bloch_multivector</code> function:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Get the state vector result from the circuit</span>
stateVectorResult = Statevector(qc)
print('state vector results', stateVectorResult)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">After the preceding cell has finished executing, you should have the state vector results printed out on your console as follows.</p>
    <pre class="programlisting con-one"><code class="hljs-con">state vector results:  Statevector([1.+0.j, 0.+0.j],
            dims=(2,))
</code></pre>
    <p class="normal-one">Next, we will display first on a Bloch sphere using the <code class="inlineCode">Statevector</code> objects <code class="inlineCode">draw</code> function. This function is very similar to that of the visualization method we used before, except, in this case, we can include an argument describing which sphere to use to display the state vector information. In this example, we are using <code class="inlineCode">bloch</code> to indicate a Bloch sphere; we’ll be using this going forward to simplify when bouncing between Bloch sphere and qsphere. Note that we should expect to see our state vector in the initial state of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker392"/> since we have not performed any operations on the qubit.</p>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Display the Bloch sphere</span>
stateVectorResult.draw('bloch')
</code></pre>
    <p class="normal-one">The output that you will see from the preceding function is the Bloch sphere with the qubit state pointed to the north pole or to the <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker393"/> state, illustrated as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_05_03.png" alt="Figure 5.3 – Qubit Bloch sphere state vector initialized to  " width="300" height="320"/></figure>
    <p class="packt_figref">Figure 5.3: Qubit Bloch sphere state vector initialized to <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker394"/></p>
    <ol>
      <li class="numberedList" value="4">Next, we will display the state vector results on the qsphere. In this visualization, you will <a id="_idIndexMarker395"/>see the state vector in the same state as the Bloch sphere shown in the preceding diagram:
        <pre class="programlisting code-one"><code class="hljs-code">stateVectorResult.draw('qsphere')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">You will also see that it includes the phase of the state vector represented by the color-shaded sphere at the bottom right, as shown in the following output:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_05_04.png" alt="A picture containing diagram  Description automatically generated" width="530" height="580"/></figure>
    <p class="packt_figref">Figure 5.4: Qubit state vector initialized to <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker396"/> with phase = 0</p>
    <p class="normal-one">From the preceding diagram, note that the state vector at the surface of the qsphere is pointed toward the north pole, indicating it is in the state <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker397"/>. It is also shaded in blue to indicate the phase of the qubit; in this case, since we did not shift the phase, it is set to the default phase of <em class="italic">0</em> (blue, as described in the legend wheel at the bottom right of the qsphere).</p>
    <div class="note-one">
      <p class="normal">Note that all images are available in color at the following address: [ADD COLOR IMAGE PACK URL]</p>
    </div>
    <p class="normal-one">This is to indicate the phase of the state vector. The color chart at the bottom right of the preceding diagram is a reference to the phase of the state vector, which is currently <em class="italic">0</em>.</p>
    <ol>
      <li class="numberedList" value="5">Now that we are<a id="_idIndexMarker398"/> familiar with the state vector of a qubit, let’s take it out for a spin. We’ll start by flipping the vector from the initial state of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker399"/> to the state of <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker400"/> using the NOT gate and then rerun our state vector and plot the results:
        <pre class="programlisting code-one"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">1</span>)
qc.x(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Run circuit using state vector and display results</span>
stateVectorResult = Statevector(qc)
stateVectorResult.draw('qsphere')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">As you can see, we are now at the <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker401"/> state with the phase still at <strong class="keyWord">0</strong>, as illustrated in the following diagram:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_05_05.png" alt="Diagram  Description automatically generated with low confidence" width="564" height="557"/></figure>
    <p class="packt_figref">Figure 5.5: Qubit state vector set to <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker402"/> with phase = 0</p>
    <ol>
      <li class="numberedList" value="6">Next, we will place the qubit into superposition by adding a Hadamard gate and executing the circuit again. We’ll create a new circuit and include a Hadamard gate, as <a id="_idIndexMarker403"/>shown in the following code snippet, followed by executing the circuit and plotting the Bloch sphere of the state vector results, which indicates the position of the state vector. In this case, it is on the equator:
        <pre class="programlisting code-one"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">1</span>)
qc.h(<span class="hljs-number">0</span>)
<span class="hljs-comment">#Run the circuit using the state vector and display results</span>
stateVectorResult = Statevector(qc)
stateVectorResult.draw('bloch')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Note that the state vector is a precise linear combination of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker404"/> and <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker405"/>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_05_06.png" alt="Figure 5.6 – Bloch sphere superposition representation, a linear combination of  and  " width="299" height="350"/></figure>
    <p class="packt_figref">Figure 5.6: Bloch sphere superposition representation, a linear combination of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker406"/> and <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker407"/></p>
    <p class="normal-one">Let’s see what this<a id="_idIndexMarker408"/> looks like on the qsphere by plotting the state vector results.</p>
    <ol>
      <li class="numberedList" value="7">Plot the state vector results on the qsphere:
        <pre class="programlisting code-one"><code class="hljs-code">stateVectorResult.draw('qsphere')
</code></pre>
      </li>
    </ol>
    <p class="normal">You can see the output of the previous code snippet in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B18420_05_07.png" alt="Chart  Description automatically generated" width="462" height="498"/></figure>
    <p class="packt_figref">Figure 5.7: Qubit state vector set to a linear combination of <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker409"/> and <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker410"/>, superposition</p>
    <p class="normal">The results might seem a little confusing. You may be asking yourself why there are two vectors when we only have one qubit and why they are based on the Bloch sphere result. <em class="italic">Shouldn’t we only see one?</em> Well, the difference is that the qsphere visualizes something that the Bloch sphere does not; that is, the visual representation of the amplitude of each possible state. If you look at the size of the ball on the surface of the previous outcome of the qsphere when we executed either the <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker411"/> or <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker412"/> state, the diameter of the ball was much larger than the two on the surface of the preceding diagram. This is because the amplitude is equal for both <img src="../Images/B18420_04_006.png" alt="" width="23" height="25"/><a id="_idIndexMarker413"/> and <img src="../Images/B18420_02_003.png" alt="" width="23" height="25"/><a id="_idIndexMarker414"/>, so the size is split between the two, whereas in the previous examples, the amplitude was purely in one of the two states.</p>
    <p class="normal">In this section, we learned that the qubit could represent itself as a bit by using the two basis states of 0 and 1. We also <a id="_idIndexMarker415"/>saw that it can be represented as a linear combination of the two basis states, that is, the amplitude (longitudinal) and phase (latitudinal).</p>
    <p class="normal">It is by leveraging these features that quantum algorithms can provide the potential for optimizing computational solutions much more than using classical bits. We also saw how to visualize the state of a qubit using two Qiskit visualization functions, the Bloch sphere and the qsphere, which provide information such as amplitude and phase.</p>
    <p class="normal">In the next section, we will look at how multiple qubits are presented and how to visualize and plot both their real and imaginary components.</p>
    <h1 id="_idParaDest-87" class="heading-1">Visualizing the state vectors of multiple qubits</h1>
    <p class="normal">So far, we’ve learned the <a id="_idIndexMarker416"/>various ways to represent a qubit, both as a vector <img src="../Images/B18420_05_065.png" alt="" width="25" height="25"/><a id="_idIndexMarker417"/> and visually on a Bloch sphere. We did something similar with the qsphere. In this section, we will learn how to represent multiple qubits and how to <a id="_idIndexMarker418"/>represent them in their general state. We will start by making a slight update to the notation. A single qubit is presented as the following vector:</p>
    <p class="center"><img src="../Images/B18420_05_060.png" alt="" width="225" height="42"/><a id="_idIndexMarker419"/></p>
    <p class="normal">We can therefore represent two qubits similarly, in the following form:</p>
    <p class="center"><img src="../Images/B18420_05_061.png" alt="" width="454" height="83"/><a id="_idIndexMarker420"/></p>
    <p class="normal">From the preceding equation, you can see that the state <img src="../Images/B18420_05_065.png" alt="" width="25" height="25"/><a id="_idIndexMarker421"/> is used to represent multiple qubits, versus <img src="../Images/B18420_05_065.png" alt="" width="25" height="25"/><a id="_idIndexMarker422"/> for single qubits. The difference is case sensitive: lowercase for single qubits and uppercase for multiple qubits. The probability amplitudes, along with the constraint by the normalization of 1, can therefore be represented as follows:</p>
    <p class="center"><img src="../Images/B18420_05_064.png" alt="" width="338" height="25"/><a id="_idIndexMarker423"/></p>
    <p class="normal">Let’s look at an example <a id="_idIndexMarker424"/>that comprises two qubits, the first one in the state <img src="../Images/B18420_05_065.png" alt="" width="25" height="25"/><a id="_idIndexMarker425"/>, as follows:</p>
    <p class="center"><img src="../Images/B18420_05_066.png" alt="" width="190" height="25"/><a id="_idIndexMarker426"/></p>
    <p class="normal">The other qubit, in the state <img src="../Images/B18420_05_067.png" alt="" width="23" height="25"/><a id="_idIndexMarker427"/>, is as follows:</p>
    <p class="center"><img src="../Images/B18420_05_068.png" alt="" width="190" height="25"/><a id="_idIndexMarker428"/></p>
    <p class="normal">Combining the two<a id="_idIndexMarker429"/> entails taking the <strong class="keyWord">tensor product</strong>, which is used to<a id="_idIndexMarker430"/> describe systems of multiple subsystems, of the two qubit states illustrated with the symbol <img src="../Images/B18420_05_069.png" alt="" width="19" height="25"/><a id="_idIndexMarker431"/>, as follows:</p>
    <p class="center"><img src="../Images/B18420_05_070.png" alt="" width="446" height="25"/><a id="_idIndexMarker432"/></p>
    <p class="normal">Multiplying across, we will get the following:</p>
    <p class="center"><img src="../Images/B18420_05_071.png" alt="" width="439" height="26"/><a id="_idIndexMarker433"/></p>
    <p class="normal">This results in the amplitude vectors, as follows:</p>
    <p class="center"><img src="../Images/B18420_05_072.png" alt="" width="142" height="109"/><a id="_idIndexMarker434"/></p>
    <p class="normal">Finally, another way to state multi-qubits by their tensor product is by representing them by their product state. Here, the product state of <em class="italic">n</em> qubits is a vector of size 2<sup class="superscript">n</sup>. We’ll use the same two-vector example described previously. The first is the <em class="italic">00</em> state:</p>
    <p class="center"><img src="../Images/B18420_05_073.png" alt="" width="208" height="90"/><a id="_idIndexMarker435"/></p>
    <p class="normal">The <em class="italic">01</em> state is as follows:</p>
    <p class="center"><img src="../Images/B18420_05_074.png" alt="" width="215" height="90"/><a id="_idIndexMarker436"/></p>
    <p class="normal">The <em class="italic">10</em> state is as follows:</p>
    <p class="center"><img src="../Images/B18420_05_075.png" alt="" width="208" height="90"/><a id="_idIndexMarker437"/></p>
    <p class="normal">Lastly, the <em class="italic">11</em> state is as follows:</p>
    <p class="center"><img src="../Images/B18420_05_076.png" alt="" width="208" height="90"/><a id="_idIndexMarker438"/></p>
    <p class="normal">The main takeaway from the previous equations is that we can describe two qubits individually as two <em class="italic">2 x 1</em> column vectors. However, when we want to represent the joint state of the full system, we<a id="_idIndexMarker439"/> represent them as a tensor product, which produces the <em class="italic">4 x 1</em> column vector illustrated previously. This is the mathematical representation of the quantum state, also referred to<a id="_idIndexMarker440"/> as the computational basis state of a two-qubit system.</p>
    <p class="normal">In the next section, we’ll briefly discuss the implementation of qubits on the IQP systems and also discuss other technologies that are used to implement qubits.</p>
    <h1 id="_idParaDest-88" class="heading-1">Implementing qubits on a superconducting system</h1>
    <p class="normal">At the beginning of this chapter, we learned that classical bits can be implemented by various platforms that <a id="_idIndexMarker441"/>detect differences between voltages or the phase of a current, or by the state of a flip flop. Just as a bit has different platforms<a id="_idIndexMarker442"/> that are used for their implementation, so do qubits.</p>
    <p class="normal">Some of the <a id="_idIndexMarker443"/>more common qubit <a id="_idIndexMarker444"/>platforms are <strong class="keyWord">neutral atoms</strong>, <strong class="keyWord">Quantum dots</strong>, <strong class="keyWord">Nitrogen-vacancy</strong> (<strong class="keyWord">NV</strong>) centers within diamond, <strong class="keyWord">trapped ions</strong>, and <strong class="keyWord">superconducting qubits</strong>. Out of these platforms, it is the<a id="_idIndexMarker445"/> superconducting qubits that are used<a id="_idIndexMarker446"/> on the quantum devices hosted on the IQP. So, in this section, we<a id="_idIndexMarker447"/> will cover this platform.</p>
    <div class="note">
      <p class="normal">If you want to learn more about the other platforms, you can review the book <em class="italic">Quantum Computation and Quantum Information</em> by Michael Nielsen and Isaac Chuang, which covers a lot of these in some detail.</p>
    </div>
    <p class="normal">A superconductor is a material made up of a combination of niobium and aluminum that has no electrical resistance, but this can only typically be achieved at very low temperatures, usually around 20 milli-Kelvin. The electrons along the superconductors are therefore used as the basic charge carriers that comprise a pair of electrons, more commonly referred to as <strong class="keyWord">Cooper pairs</strong>. This is<a id="_idIndexMarker448"/> different from other conductors, which generally use single <a id="_idIndexMarker449"/>electrons. Talking about the specifics of the quantum mechanics or superconducting behavior of the Cooper pairs is beyond the scope of this book. However, you can find various references in <em class="chapterRef">Appendix A</em> if you are interested. For now, we can think of superconductors as one of the components of the superconducting circuit that makes up the qubit.</p>
    <p class="normal">Now that we have covered how to visualize the state of a qubit using the state vector simulator and display it on both a Bloch sphere and a qsphere, we can move on to the next chapter, which describes all the qubit gate operators and what effects they have on each other.</p>
    <h1 id="_idParaDest-89" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned the difference between bits and qubits and how they are represented, both mathematically and visually. You also saw the difference between how single and multi-qubit systems are represented, including their mathematical representations, as well as how they are constructed and operated on. We also covered how to visualize the qubit as a Bloch sphere and a qsphere.</p>
    <p class="normal">You now have the skills to represent the vector states of single and multiple qubits. You also understand the difference between representing multiple qubits as separate entities and as part of a complete system by using the tensor products of the qubits. This will help you to implement and operate the qubits on IBM Quantum systems.</p>
    <p class="normal">In the next chapter, we will cover how to perform operations on single and multiple qubits and how those operations are triggered on the qubits of the real devices.</p>
    <h1 id="_idParaDest-90" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">Which would provide visual information about the phase of a qubit—the Bloch sphere or the qsphere?</li>
      <li class="numberedList">Can you visualize multiple qubits on the Bloch sphere? If not, then describe why you wouldn’t.</li>
      <li class="numberedList">Write out the tensor product of three qubit states in all their forms.</li>
      <li class="numberedList">What is the probability amplitude of a three-qubit system?</li>
    </ol>
    <h1 id="_idParaDest-91" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://packt.link/3FyN1"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code2617625996838265933.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>