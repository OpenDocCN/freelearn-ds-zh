- en: Chapter 4. Creating QGIS Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started with
    QGIS"), *Getting Started with QGIS*, we took a brief look at how QGIS Python plugins
    are organized. In this chapter, we will use this knowledge to create two plugins:
    a simple "Hello World" style plugin, so you can understand the process, and a
    much more sophisticated and useful plugin that displays information about a clicked-on
    geometry. In the process, we will learn how plugins work, how to create and distribute
    plugins, what plugins will allow us to do, and some of the possibilities and limitations
    involved in implementing your mapping applications as QGIS plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can delve into the plugin development process, there are three things
    you will need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the **Qt developer tools** from the Qt developer website ([http://qt-project.org](http://qt-project.org)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Python bindings for Qt, called **PyQt**, from [http://www.riverbankcomputing.co.uk/software/pyqt](http://www.riverbankcomputing.co.uk/software/pyqt).
    While we won't be using the Python bindings directly, there are two command-line
    tools included with PyQt that we will need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: QGIS is currently based on PyQt4\. Make sure you install Version 4 of the Qt
    Developer tools and the PyQt bindings so that you get the compatible version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PyQt is available as an installer for MS Windows and in source code form for
    Linux. For Mac OS X users, a binary installer is available at [http://sourceforge.net/projects/pyqtx](http://sourceforge.net/projects/pyqtx).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should install and enable the **Plugin Reloader** plugin for QGIS. This
    makes it much easier to develop and test your plugins. To do this, you will need
    to turn on experimental plugin support by selecting the **Manage and Install Plugins…**
    item from the **Plugins** menu, clicking on the **Settings** tab, and then turning
    on the **Show also experimental plugins** checkbox. You can then see the experimental
    plugins, including the Plugin Reloader. Select this plugin and then click on the
    **Install Plugin** button to install it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Plugin Reloader adds buttons to the QGIS toolbar that you can click on
    in order to reload your plugin:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Getting ready](img/00036.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: This allows you to make changes to your plugin and see the result right away.
    Without the Plugin Reloader, you would have to quit and restart QGIS for your
    changes to take effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Understanding the QGIS plugin architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with QGIS"), *Getting Started with QGIS*, QGIS plugins are stored as Python packages
    in the `~/.qgis2/python/plugins` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on your operating system and the version of QGIS you're using, the
    `.qgis2` directory might be named `.qgis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin''s package includes a number of Python modules and other files.
    At a minimum, the plugin package must include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__.py`: This is a package initialization module that contains the **class
    factory** function, which creates and initializes the plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata.txt`: This is a text file that contains information about the plugin,
    including the plugin''s version number, the name of the plugin, and the plugin''s
    author.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, most plugins will include:'
  prefs: []
  type: TYPE_NORMAL
- en: A separate Python module that contains a class definition for the plugin. The
    plugin class implements a number of specially named methods that get called to
    start up and shut down the plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more user-interface template files with the extension `.ui`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiled version of each user-interface template in the form of a Python
    module with the same name as that of the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `resources.qrc` file, which is an XML format file that lists the various images
    and other resources used by the plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiled version of the resources file, in the form of a Python module named
    `resources.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various `.ui` template files are created using **Qt Designer**, which is
    a part of the standard Qt installation. The command-line tools to convert the
    `.qrc` and `.ui` files into Python modules are part of PyQt.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it starts up, QGIS looks through the various Python packages it finds
    in the `~/.qgis2/python/plugins` directory. For each package, it attempts to call
    the top-level function named `ClassFactory()` in the plugin''s `__init__.py` file.
    This function should import and return an instance of the plugin''s object, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, you should change the name of `myPlugin` (and `MyPlugin`) to something
    more meaningful when you write a real plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it''s usual to define the plugin in a separate module, you can create
    it directly within the `__init__.py` module if you prefer. The important thing
    is to define a class that provides the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__(iface)`: This initializes the plugin object. Note that this should
    accept the `iface` variable passed to the class factory and store it in an instance
    variable for later use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initGui()`: This initializes the plugin''s user interface. This would typically
    involve adding the plugin to the QGIS menus and toolbar, and setting up the signal
    handlers to respond to various events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unload()`: This removes the plugin''s user-interface elements. This would
    normally include removing the plugin from the QGIS menus and toolbar, and disconnecting
    the signal handlers defined in the plugin''s `initGui()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__init__(iface)` method is called by your class factory function to initialize
    the plugin object itself. The `initGui()` method is then called by QGIS when the
    program starts up, or when the user installs the plugin. Finally, the `unload()`
    method is called by QGIS when the user uninstalls the plugin or when QGIS shuts
    down.
  prefs: []
  type: TYPE_NORMAL
- en: A plugin doesn't usually run right away when QGIS starts up. Instead, it installs
    various menu and toolbar items, which the user can then select to perform various
    actions. For example, a simple plugin may have just one menu item and one toolbar
    item, and when the user selects one of these, the plugin performs its one and
    only action. More sophisticated plugins might have a range of menu and toolbar
    items, each one performing a different action.
  prefs: []
  type: TYPE_NORMAL
- en: Many plugins add their menu items to the **Plugins** menu using the `iface.addPluginToMenu()`
    method. This creates a submenu within the **Plugins** menu for the plugin's menu
    items, making it easy for the user to see which menu items have been provided
    by a given plugin. Alternatively, the plugin might choose to add its menu items
    to one of the existing submenus within the **Vector**, **Raster**, or **Database**
    menu, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, the plugin might add icons or widgets to the plugin toolbar,
    or to one of the other toolbars if it prefers. A plugin might also add a whole
    new toolbar to the QGIS window if it wants to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how plugins are structured and used, let's create a very
    simple "Hello World" style plugin to see what's involved in making one. While
    there are various tools such as the **Plugin Builder** plugin, which will create
    the various files for you, we're going to eschew them in favor of creating our
    plugin manually. This will make the process clearer and avoid the situation where
    your code just magically works without knowing why or how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `~/.qgis2/python/plugins` directory and create a subdirectory named
    `testPlugin`. In this directory, create a file named `metadata.txt` and enter
    the following values into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the minimum metadata you need to enter for a plugin. Obviously, you
    can change these values if you want. Now, create a package initialization file,
    `__init__.py`, and enter the following into that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re going to define a class named `TestPlugin` that represents
    our plugin object, and implement it in a module named `testPlugin.py`. Let''s
    create this module now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created a Qt `QAction` object for our menu item, named it
    `Run`, and added it to the **Plugin** menu in a submenu named "Test Plugin". We
    then connected that action to our `onRun()` method, which simply displays a message
    to the user stating that the plugin is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all we need for a very minimal plugin. Let''s test it out. Start QGIS
    and choose the **Manage and Install Plugins…** item from the **Plugins** menu.
    The QGIS **Plugin Manager** window will appear, and if you scroll down, you should
    see your plugin listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple plugin](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the checkbox, the plugin will be activated. If you then look
    in the **Plugins** menu, you should see your plugin listed, and if you select
    the **Run** item from your plugin's submenu, the "Running" message box should
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your plugin isn''t working, or if it isn''t listed in the Plugin Manager
    window, you might have made a mistake in your code. If the plugin can''t be loaded
    for some reason, a window will appear, giving you the Python traceback when you
    attempt to install or reload the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple plugin](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This window will also appear if your plugin's code generates an exception while
    it is running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there''s a problem with your plugin that prevents it from even being loaded
    (for example, a mistake in the `metadata.txt` file), you might need to check the
    **Log Messages** panel to see the error. You can show this panel by selecting
    it from the **Panels** submenu in the **View** menu; make sure you click on the
    **Plugins** tab to see the log messages associated with your plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple plugin](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add one more feature to our test plugin: a toolbar item, which, when
    clicked on, also calls the `onRun()` method. Find a suitable PNG format image
    that is 24 x 24 pixels (the default size for a QGIS toolbar icon), and save that
    image into your plugin''s directory under the name `icon.png`. Then, change your
    `initGui()` method to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The changed lines have been highlighted. As you can see, we've added an icon
    to our `QAction` object, and then also called the `addToolBarIcon()` method to
    add our action to the Plugins toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also have to add one extra line to our `unload()` method to remove the
    toolbar icon when the plugin is unloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one last thing we need to do before our toolbar icon will work; we
    need to tell QGIS that the `icon.png` file is a **resource** used by our plugin.
    This is done through the `resources.qrc` file. Create this file now, placing it
    into your plugin''s directory, and edit it using your favorite text editor, so
    that it contains the following XML format text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'QGIS can''t use this file directly; it has to be compiled into a `resources.py`
    module using the **pyrcc4** command-line tool. This tool is installed as part
    of PyQt; once you''ve created your `resources.qrc` file, use the following command
    to compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on where PyQt installed it, you might need to include the path to
    the `pyrcc4` command. If you run this command from a directory other than the
    plugin directory, you will also need to include the path to the `resources.qrc`
    and `resource.py` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add the following to the top of our `testPlugin.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This makes the compiled resources available for our plugin to use. When you
    reload your plugin, an icon should appear in the QGIS toolbar, and if you click
    on that icon, the "Running" message box should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this plugin is very basic, we''ve actually learned a lot: how to create
    and install a plugin, how a plugin can add itself to the QGIS user interface,
    how plugins interact with the user, how errors in a plugin are handled, and how
    to deal with images and other plugin resources. Let''s take a closer look now
    at the processes typically used to develop and distribute plugins, before going
    on to create a plugin that actually does something useful.'
  prefs: []
  type: TYPE_NORMAL
- en: The plugin development process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a plugin by hand, directly storing the necessary
    files in the hidden `~/.qgis2` directory. This isn't a particularly robust way
    of building plugins. In this section, we will look at some of the best practices
    for developing and distributing plugins, as well as some of the things you need
    to be aware of when creating your own plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Plugin Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QGIS provides a plugin called **Plugin Builder** that you can use to create
    your new plugin from a standard template. Plugin Builder is a sophisticated and
    useful tool for creating plugins, but it does make some assumptions about the
    way your plugin will be structured and what it will do. For this reason, we deliberately
    didn't use the Plugin Builder for our example plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on the Plugin Builder can be found at [http://geoapt.net/pluginbuilder](http://geoapt.net/pluginbuilder).
    You can install the Plugin Builder directly from within QGIS, using the **Manage
    and Install Plugins...** item from the **Plugins** menu. Once installed, you simply
    click on the Plugin Builder''s icon in the toolbar, and you will be prompted to
    fill in various details about your new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Plugin Builder](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After filling in the information, you will be prompted to select the directory
    in which your plugin's source code is stored. The Plugin Builder will then create
    the necessary files for you.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you whether to use Plugin Builder or not, and whether or not to
    use all the features it provides. For example, the Plugin Builder provides a *make*
    target to create the HTML format help files for your plugin, using Sphynx. If
    you prefer to create your help files in a different way, or don't want to create
    help files at all, you can simply ignore this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the problems with using Plugin Builder is the complexity of the generated
    plugin. Right from the outset, your plugin will include:'
  prefs: []
  type: TYPE_NORMAL
- en: Help files, both in reStructuredText and in HTML format, as well as directories
    for holding images and HTML templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Makefile to automate the plugin building process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python script for uploading the plugin to the QGIS plugin repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `pylintrc` file, allowing you to check your plugin's Python source files using
    the Pylint code-analysis system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two separate README files, one in HTML and another in plain text format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various shell scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A range of standard unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI template and Python code that displays a dialog box when the plugin is
    run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this leads to a rather complex directory structure, with lots of files
    that may or may not be relevant to you. You can certainly remove the various files
    and directories you don't need, but this can be risky if you don't know what the
    files and directories are for.
  prefs: []
  type: TYPE_NORMAL
- en: Due to all this complexity, we won't be using Plugin Builder in this book. Instead,
    we'll create our plugins manually, only adding the files and directories you need
    so that you can understand what everything does.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the build process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our example plugin, we had to create the `resources.qrc` file and then compile
    this file into a `resources.py` file using the `pyrcc4` command-line tool. Whenever
    we made a change to the `resources.qrc` file, we had to remember to recompile
    it. The same thing applies to any user-interface template (`.ui`) files in our
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually running the compiler each time you make a change is poor programming
    practice. Instead, you should use a **Makefile** to automate the process. We won''t
    go into the details of how to use *make* here (there are complete books on this
    topic), but we will use it to compile all the necessary files with a single command.
    We will also store the plugin''s source files in a different directory, and use
    *make* to compile and copy all the necessary files into the `~/.qgis2` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating the build process](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This ensures that the various files in the running plugin are all consistent—you
    can't forget to compile a template, or break the running plugin by running an
    updated Python source file before a template has been recompiled. Keeping your
    source files separate from your running code is also an excellent programming
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using *make* in this way, you end up with a highly productive process for
    developing and testing your plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating the build process](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A typical Makefile for building and running QGIS plugins looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The top portion of the Makefile sets five variables that tell *make* about
    your plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PLUGINNAME` is, of course, the name of your plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PY_FILES` is a list of the Python source files that make up your plugin''s
    source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXTRAS` is a list of additional files that should be included with your plugin.
    You would typically include the `metadata.txt` file and any additional images
    or other files used by your plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UI_FILES` is a list of the UI templates that need to be compiled for your
    plugin to work. Note that you have to use the `.py` suffix for each template file,
    as you''re telling *make* which file you want to have recompiled when the corresponding
    `.ui` file is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESOURCE_FILES` is a list of the resource files used by your application.
    Once again, you have to use the `.py` suffix for each resource file rather than
    the `.qrc` version of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, you would only have to change the values of these five variables
    to set up your Makefile. However, if the `pyrcc4` or `pyuic4` command-line tools
    are in a nonstandard location, or if QGIS uses a directory other than `~/.qgis2/python/plugins`
    for its Python plugins, then you will have to modify the other parts of the Makefile
    so that it works with your particular development setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it has been set up, the Makefile provides three **make targets** that
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`make compile` (or just `make`) will compile your plugin''s `.ui` and `.qrc`
    files into the corresponding `.py` modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make deploy` will compile the `.ui` and `.qrc` files, and then copy all the
    necessary files into the QGIS plugin directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make clean` will remove the `.py` version of your `.ui` and `.qrc` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `make deploy` and then click on the Plugin Reloader tool in QGIS
    to run the latest version of your plugin so you can test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin help files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'QGIS allows you to include an HTML-formatted help file for your plugin. This
    file will be displayed using the built-in QGIS help browser if your plugin calls
    the `qgis.utils.showPluginHelp()` function. This function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The various parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`packageName`: This is the name of the Python package where the help file can
    be found. If a package is specified, QGIS will look for the help files inside
    the given package directory. Otherwise, it will look for the help files in the
    same directory as the Python module that called `showPluginHelp()`. Note that
    it''s quite unusual for a plugin to use this parameter, and you would normally
    just leave it set to `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename`: This is the base name for the HTML help file to display. Note that
    an appropriate suffix (for example, `.html`) will be added to this base name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`section`: This is the name of an optional HTML anchor tag, which the help
    file will be scrolled to when it is opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `filename` parameter is the *base* name for the desired HTML file.
    QGIS allows you to have your help files translated into multiple languages, and
    will automatically choose the appropriate version of the file based on the current
    locale. If a translated version of the help file is not available in the current
    language, then QGIS will fall back to displaying the US English version of the
    help file, and if that's not available, it will use the file named `filename.html`.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to include translated versions of your help files if you want
    (for example, `index-es.html`, `index-de.html`, and `index-fr-ca.html`), but if
    you don't want to have translated help files, a single `index.html` file will
    suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways in which you can organize your plugin''s online help.
    The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You can put all the documentation for your plugin in a single file named `index.html`,
    and then simply call `showPluginHelp()` with no parameters to display that help
    file when the user asks for help.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use a different filename for your help file and supply that name in
    the `filename` parameter when calling `showPluginHelp()`, for example, `showPluginHelp(filename="plugin_help")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're not just limited to having one help file. You can have a whole directory
    of help files, and have the `index.html` file act as a table of contents for the
    plugin's online help. To do this, call `showPluginHelp` with `filename` set to
    something like `os.path.join("help_files", "index")` so that the help file is
    found in a subdirectory rather than the main plugin directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have multiple help files, for example, one for each of your plugin's
    main features, you might choose to display the appropriate help file based on
    which feature the user is using at that time. For example, you might add a **Help**
    button to a complex dialog or window and have that button call `showPluginHelp(filename="my_dialog")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you might put all your documentation into a single file, and use HTML
    anchor tags (for example, `<a id="my_dialog">My Dialog</a>`) to define the various
    sections of your documentation. You will then use the `section` parameter to jump
    directly to that section of your plugin''s documentation, like this: `showPluginHelp(section="my_dialog")`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, while your help file has to end up in HTML format, you might not
    want to write HTML directly. Instead, you can write your documentation using a
    markup language such as Markdown, reStructuredText, or Latex, and then use a documentation
    generator to convert your marked-up files into HTML. This is a perfect example
    of something that can be automated using a Makefile, and indeed, the Plugin Builder's
    default Makefile includes support for using Sphinx to convert reStructuredText
    markup into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit tests are a common programming technique to make sure each part of your
    code works as it should. The following is a very simple example of a unit test
    written in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can run this unit test either directly from the command line, or by adding
    extra code to create a `TestRunner` object that you can then use to run the test.
  prefs: []
  type: TYPE_NORMAL
- en: We're not going to describe the rationale behind unit testing, or how to use
    the `unittest` library to test your Python code. However, it is worth spending
    some time learning how you can write and run unit tests for your QGIS plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you haven't worked with the `unittest` module before, check out [http://docs.python-guide.org/en/latest/writing/tests](http://docs.python-guide.org/en/latest/writing/tests).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is done outside of QGIS itself; that is, the unit tests run as
    an external Python application that loads your plugin and then tests it. Doing
    this isn''t as bad as it sounds; in [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting
    Started with QGIS"), *Getting Started with QGIS*, we looked at a simple external
    application built on top of QGIS, and we can use pretty much the same process
    to write our testing code. Here''s the boilerplate example of an external application,
    copied from [Chapter 1](part0014_split_000.html#page "Chapter 1. Getting Started
    with QGIS"), *Getting Started with QGIS*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will also need to use an appropriate wrapper script, as described in [Chapter
    1](part0014_split_000.html#page "Chapter 1. Getting Started with QGIS"), *Getting
    Started with QGIS*, so that the Python path and other environment variables are
    set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With QGIS unit tests, you have to set up the QGIS environment before the test
    is run, and then shut it down again once the test finishes. This is done by placing
    the appropriate parts of the boilerplate code into the unit test''s `setup()`
    and `tearDown()` methods, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can then import and test your plugin's Python code within the `test_plugin()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can, of course, have multiple `test_XXX()` methods in your test case. The
    PyQGIS library will be initialized before the first test is run, and shut down
    after the last test finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing plugins in this way does reveal a major limitation of this approach:
    there is no `QgisInterface` object available for your plugin to use. This means
    that the parts of the plugin you''re testing can''t interact with the rest of
    the QGIS system via the `iface` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests get around this limitation by creating a fake QGIS environment (including
    a Python implementation of `QgisInterface`), which the plugin can use for testing.
    The plugin is then loaded by adding the plugin''s directory to `sys.path` and
    then calling the plugin''s `ClassFactory()` function with the fake `QgisInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: While it seems complex and might introduce errors that only occur while the
    plugin is being tested, this process is actually very useful. If you want to use
    unit tests, you can either implement your own `QgsInterface` or make use of the
    unit testing framework provided by the Plugin Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to roll your own unit tests, a good starting point is available
    at [http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins](http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are doing unit testing, then you would normally add an extra target
    to your Makefile so you can run the unit tests simply by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Distributing your plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To share your plugin with others, you have to upload it to a plugin repository.
    Let's look at the steps involved in doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, you need to ensure that your plugin adheres to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of your plugin's folder must contain only upper- and lowercase letters,
    digits, underscores, and hyphens, and must not start with a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Your `metadata.txt` file must exist and include the following entries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Metadata entry | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `name` | The name of your plugin. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `qgisMinimumVersion` | The minimum version of QGIS that your plugin will
    run under. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `description` | A brief textual description of your plugin and what it does.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `version` | The version number of your plugin, as a string. Note that you
    can''t upload two copies of a plugin with the same version. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `author` | The name of the plugin''s author. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `email` | The author''s e-mail address. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: If you don't follow these rules, your plugin will be rejected when you attempt
    to upload it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to compress the plugin into a ZIP archive. Note that you should
    compress the folder that contains your plugin, so that the ZIP archive has only
    one entry (the plugin's directory) rather than a collection of individual files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to upload the ZIP archive to a QGIS plugin repository. You
    have two options here:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the official plugin repository at [http://plugins.qgis.org](http://plugins.qgis.org).
    This will make your plugin available to all QGIS users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set up your own plugin repository. This means that only people who know
    about your repository or have access to it (for example, via a VPN) can download
    your plugins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up your own plugin repository isn''t nearly as daunting as it sounds;
    you simply create an XML file that lists the plugins that you want to make available,
    and then upload that XML file and the plugins themselves to a web server. Here
    is what the XML file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `<pyqgis_plugin>` section for each of your repository''s plugins.
    Once this file has been uploaded, the user simply goes to the QGIS Plugin Manager
    window, clicks on the **Settings** tab, and clicks on the **Add** button in the
    **Plugin repositories** section of the window. The user will be asked to enter
    the details of the new repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Distributing your plugin](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The **URL** field should be set to the complete URL for the XML file you uploaded,
    for example `http://my-site.com/qgis_plugins.xml`. Once the repository has been
    added, the plugins listed in the XML file will appear in the Plugin Manager, and
    the user can install them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a useful plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now apply the knowledge we've gained to build a plugin that does something
    useful and interesting. While there are built-in tools in QGIS to query a feature
    and identify the feature's attributes, there is no easy way of getting information
    about the *geometry* associated with a feature. So let's write a plugin that lets
    the user click on a feature and display various statistics about that feature's
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to call our new plugin **Geometry Info**. When the user clicks on
    our plugin's toolbar icon, we will activate a map tool that listens for mouse
    clicks on the map canvas. When the user clicks on the map canvas, we'll find the
    feature that the user clicked on, and calculate and display statistics about that
    feature's geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up the basic template for our plugin. Create a directory
    named `geometryInfo`, put it somewhere convenient, and create an `__init__.py`
    file within that directory. In that file, place the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define the metadata for our plugin. Create the `metadata.txt`
    file and add the following to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need an icon for our plugin. We''re going to use the following icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a useful plugin](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A copy of this icon is available with the sample code that comes with this book,
    though you can create your own icon or find a different one to use somewhere;
    just make sure that the resulting image file is named `icon.png`, and that the
    icon is 24 x 24 pixels. Place this file into your `geometryInfo` directory along
    with the other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next need to define the `resources.qrc` file that tells QGIS about our icon.
    Create this file and put the following text into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a Makefile to automate the process of compiling and
    deploying our plugin. Here''s a suitable Makefile to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You may need to modify the paths in this file to suit your development setup.
    Notice that because our plugin won't have any UI templates, we've removed the
    portions of the Makefile that compile and deploy the template files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created the framework for our plugin, let''s start writing
    the code that does the actual work. The final file we need for our plugin will
    be named `geometryInfo.py`. Create this file and put the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Apart from a few extra `import` statements (which we'll need later on), this
    is almost identical to our earlier example plugin. The `onClick()` method, of
    course, is just a placeholder so we can tell if the plugin is working.
  prefs: []
  type: TYPE_NORMAL
- en: We can now run our plugin by typing `make deploy` in the command line, starting
    up QGIS, and enabling the plugin using the **Manage and Install Plugins...** command,
    just like we did earlier. If all goes well, the plugin's icon should appear in
    the QGIS toolbar, and when you select it, the "Click" message should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to make our toolbar icon *checkable*. That is, when the user
    clicks on our icon, we want to highlight it, activate our map tool, and keep the
    icon highlighted until the user either clicks on the icon again or switches to
    a different tool. To make the toolbar icon checkable, add the following line to
    your `initGui()` method, immediately after the `self.action = QAction(...)` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We then have to respond to the checking and unchecking of our toolbar icon
    by activating and deactivating our map tool. Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is see if the user has unchecked our icon, and if this
    is the case, we deactivate the map tool. Otherwise, we visually highlight the
    icon by calling `self.action.setChecked(True)`, and then activate our map tool.
    In this way, our plugin will act like a mode within QGIS; clicking on the icon
    will activate the map tool, and clicking on it again (or selecting a different
    icon) will deactivate it.
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to implement our map tool. Earlier, we looked at how you can
    use the `QgsMapTool` class to respond to mouse clicks within the map canvas. In
    this case, we'll use a subclass of `QgsMapTool`, called `QgsMapToolIdentify`.
    This class makes it easy to find the feature at a given point. When the user clicks
    on the map canvas, we'll use the `QgsMapToolIdentify.identify()` method to find
    the first clicked-on feature, and then calculate and display various statistics
    about that feature's geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of your `geometryInfo.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines our `QgsMapToolIdentify` subclass. It doesn''t do anything useful
    yet, but it will respond with a simple "Canvas Click" message when the user clicks
    on the map canvas. Now, let''s finish writing our plugin''s `onClick()` method
    to activate and deactivate our map tool as the user clicks on our toolbar icon.
    This is what the `onClick()` method should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to run your plugin by typing `make deploy`, and then
    reload it in QGIS to see how it works. If all goes well, the toolbar icon will
    be highlighted when you click on it, and the "Canvas Click" message should appear
    when you click on the map canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s replace the `GeometryInfoMapTool.canvasReleaseEvent()` method with
    code to identify the feature the user clicked on. Here''s the necessary code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we call `QgsMapToolIdentify.identify()` to see which feature
    the user clicked on. The parameters we're using tell the method to only return
    the top-most vector feature at the point where the user clicked; the `identify()`
    method can also return all features at a given point or the pixel value if the
    user clicked on a raster layer, but in our case, we only want the top-most vector
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've found the clicked-on feature, we identify which map layer the feature
    is on, and extract the feature's geometry. With this information, we can analyze
    the geometry and display the calculated statistics, which is the whole purpose
    of our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `QGSGeometry` object can represent a point, a line, a polygon, a number of
    points, a number of lines, a number of polygons, or a collection of different
    types of geometries. To analyze the statistics for any `QGSGeometry` object, we
    have to be ready to handle all these different types of geometries. Fortunately,
    the basic logic is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: If the geometry has multiple parts, we split the geometry into its component
    parts, and process each part in turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For point geometries, we count the number of points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For line geometries, we count the number of lines and calculate their total
    length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For polygon geometries, we count the number of polygons and calculate their
    total area and perimeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add two methods to our `GeometryInfoMapTool` class to analyze a geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `add()` method is just a helper method that adds a number to a dictionary
    entry if it exists, and creates that entry if it doesn't. This allows us to use
    the `info` dictionary to store the results as we calculate them.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `analyzeGeometry()` method makes use of a `QgsDistanceArea`
    object to calculate the lengths and areas of a geometry. Note that our `analyzeGeometry()`
    method is recursive; if a geometry has multiple parts, each subgeometry might
    also have multiple parts, so we call `analyzeGeometry()` recursively on each part
    to allow these nested geometries to be handled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call `analyzeGeometry()` on a given `QGSGeometry`, the results of the
    analysis will be stored in the `info` dictionary. Let''s add some code to the
    end of our `canvasReleaseEvent()` method to analyze the clicked-on geometry and
    display the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now do a `make deploy` and reload the plugin, you should be able to
    click on a feature and display information about that feature''s geometry. The
    plugin''s output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a useful plugin](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is certainly telling us something useful, but it's not very readable. Let's
    look at how we can improve the way we display the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, notice that the area and perimeter values are not particularly useful;
    the `QgsDistanceArea` object returns lengths and areas in meters, but for most
    geometries, these values are too precise and too big. Let''s make it more readable
    by converting the calculated lengths and areas into a whole number of kilometers.
    To do this, make the following highlighted changes to your `analyzeGeometry()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're simply dividing the calculated lengths by a thousand to
    get the length in kilometers, and dividing the calculated area by a million to
    get the area in square kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing we want to do is display those calculated statistics in a more
    friendly way. To do this, replace the `QMessageBox.information()` call at the
    end of your `canvasReleaseEvent()` method with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Your plugin will now display the statistics in a more readable format, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a useful plugin](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We've now completed our plugin, and can use it to display information about
    any geometry within QGIS. More importantly, we've learned how to create a complete
    and useful QGIS plugin, and you can build on this knowledge to create your own
    plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Possibilities and limitations of plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, it''s quite possible to write a plugin that acts as a sophisticated
    mapping tool integrated directly into the QGIS user interface, interacting with
    the map canvas and responding in various ways to the user''s actions. Some of
    the other things you can do with a QGIS plugin include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own subclass of `QgsMapCanvasItem`, so your plugin can draw items
    directly onto the QGIS map canvas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom map layer by subclassing `QgsPluginLayer`. This allows your
    plugin to act as a completely separate map layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using signal handlers to intercept standard QGIS actions, for example, redrawing
    the canvas and executing your own code when a signal is sent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating map layers programmatically, setting up the data provider, and creating
    custom symbols and renderers to control how the map data is displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the QGIS Map Composer tools to combine rendered map layers, labels, legends,
    tables, and so on, mimicking the layout of a paper map. The resulting map view
    can be displayed in a window, printed, or saved to disk as an image or a PDF file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are, however, some limitations on what a QGIS plugin is able to do:'
  prefs: []
  type: TYPE_NORMAL
- en: By its very nature, a plugin sits inside the running QGIS application. Your
    plugin runs alongside all the other plugins that the user has installed, and shares
    the same user interface and menu structure. This means that you can't implement
    turnkey mapping applications as QGIS plugins. The full complexity of QGIS is shown
    to the user, which can be daunting for the user who might be looking for a custom
    application that performs just one task. In this situation, it might be better
    to write your code as an external application that uses the PyQGIS library, rather
    than attempt to write it as a plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the plugin runs within QGIS itself, there are many points of contact between
    the plugin code and the QGIS environment. As QGIS is constantly evolving, this
    means that a plugin can stop working when a new version of QGIS is released. This
    is far more likely to happen with a plugin than with code written as an external
    application using the PyQGIS library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the plugin uses the Python interpreter built into QGIS itself, you can't
    make use of third-party Python libraries that aren't included in QGIS's Python
    interpreter. While you can get around this for pure Python libraries (by including
    the Python source code as part of your plugin), if the library you want makes
    use of extensions written in C, you simply won't be able to use that library in
    your plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately, it is up to you to decide if plugins are a suitable way of implementing
    your mapping application. For some applications, they are ideal; they are certainly
    a lot easier to develop and distribute than external applications, and if your
    application is aimed at people who are already using QGIS, then the plugin scheme
    is a logical approach to take. In other situations, an external application built
    on top of PyQGIS might be more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the topic of QGIS plugin programming. We created
    two separate plugins, a simple one to get started with, and a more complex and
    useful plugin that displays information about a clicked-on feature's geometry.
    We also looked at the QGIS plugin architecture, the plugin development process,
    and some of the possibilities and limitations of QGIS plugins. Along the way,
    we learned about the tools needed to develop QGIS plugins, discovered that plugins
    are simply Python packages with certain special files in them, and saw how the
    PyQt command-line tools can be used to compile user-interface templates and resource
    description files into Python modules so that they can be used within a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how your plugin is integrated into the QGIS user interface
    using icons and menu items, how to run your plugin, and what happens when your
    plugin crashes. We also looked briefly at the Plugin Builder, and how it can be
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at how to use a Makefile to automate plugin compilation and
    deployment, and the typical write-make-reload-test cycle used to develop plugins.
    We saw how to write and use HTML help files within your plugin, how unit tests
    can be used for QGIS plugins, and how to distribute your plugin, both to the official
    QGIS plugin repository and to a repository that you set up yourself.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that there are many things you can do with plugins, including drawing
    into the map canvas, creating custom layers, intercepting QGIS actions, programmatically
    creating map layers, and composing complex maps. At the same time, we saw that
    there are some constraints in what a QGIS plugin can do, including the need to
    share the QGIS user interface with all other plugins, the inability to create
    turnkey mapping applications, compatibility issues, and difficulties in using
    some third-party Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the process of using the PyQGIS libraries
    within your own external Python programs. This gets around many of the limitations
    of a QGIS Plugin, at the cost of some additional complexity.
  prefs: []
  type: TYPE_NORMAL
