- en: GeoDjango
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django Python web framework was made available in 2005 and has been steadily
    supported and improved throughout the years. One major improvement was additional
    support for spatial data types and queries. This effort produced GeoDjango, allowing
    Django to support geospatial database models and web views that utilize geospatial
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: GeoDjango is now a standard Django component, which can be activated using a
    specific configuration. In December 2017, Django 2 was released as the new long-term
    support version. It currently supports Python 3.4, 3.5, and 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration of Django and GeoDjango
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django admin panel functionality, including map editing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load shapefiles into database tables using LayerMapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeoDjango queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django URL patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Django and GeoDjango
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django, compared to Flask, is a batteries-included framework. It includes modules
    that allow for database backend support, without requiring a separate database
    code package (unlike Flask, which relies on SQLAlchemy). Django also includes
    an admin panel that allows for easy data editing and management through a web
    interface. This means fewer modules are installed and more code is included to
    handle database interactions and web processing.
  prefs: []
  type: TYPE_NORMAL
- en: There are some major differences between Flask and Django. Django separates
    URLs from views and models in a more structured manner than Flask. Django also
    uses Python classes for databases tables, but it has built-in database support.
    For geospatial databases, no extra module is required. Django also supports geometry
    columns in a wider range of databases, though PostgreSQL and PostGIS are used
    the most often.
  prefs: []
  type: TYPE_NORMAL
- en: Like many Python 3 modules, Django development is geared towards Linux development
    environments. While it supports Windows installation, it requires a few modifications
    of the environment variables within Windows, requiring administrative control
    of the machine. Administrative-level permissions are required for configurations,
    allowing Django to access **Geospatial Data Abstraction Library** (**GDAL**) and
    **OGR Simple Features **libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Steps from Django to GeoDjango
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within this section, we''ll install Django add GeoDjango configurations, and
    add the required libraries (including the GDAL and OGR) that bring spatial functionality
    to Django. Installing the Django 2 module for Python 3, and configuring the GeoDjango
    components, depends on a number of steps. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `pip` to install Django 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing and enabling a spatial database (if not already installed)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing GDAL/ OGR/PROJ4/GEOS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the Windows environment variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generating a project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening `settings.py`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding `django.contrib.gis` to `INSTALLED_APPS`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring database settings to point to the spatial database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django 2 is hosted in **Python Package Index** (**PyPI**), so use `pip` to install
    it. It can also be downloaded and installed manually. Using `pip` to install Django
    will also install the required dependency, `pytz`. Django will be downloaded from
    PyPI as a wheel and installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Django 2 is a major update which has been recently released, we have
    to ensure that `pip` installs the correct version. With this command, we will
    install Django 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The module will be installed, along with the supporting modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50a55e05-b2b3-4100-bbdb-a0a8feeeb59a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Django 2.0 is used in this chapter. Use the latest version of Django 2 available
    to start a project. Check out Django 2.0 documentation (as well as other Django
    versions) here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.djangoproject.com/](https://www.djangoproject.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using virtual environments, you can specify a specific version of
    Django for each environment. If not, and you have multiple versions of Python
    installed, be sure to use the correct `pip` version to install Django within the
    `Python 3` folder structure.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostGIS and psycopg2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will use PostGIS. Refer to [Chapter 7](4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml), *Geoprocessing
    with Geodatabases*, if you do not have PostGIS installed on your machine as it
    explains how to install the spatial extension add-on to PostgreSQL. Also, ensure
    that the `psycopg2` module is installed by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating the database table is made possible by the `Chapter12_0.py` script,
    which creates a PostgreSQL database called `chapter12` and adds spatial functionality
    to the new database. Adjust the credentials, host, and port (as needed) in the
    connection configuration below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the database server using `psycopg2` and its `connect` function,
    which creates a `connection` class. The class has a `cursor` function that creates
    a `cursor` object, which is able to execute SQL statements. This section creates
    the database for the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the database geospatial, ensure that the PostGIS spatial add-on has
    been installed. Connect to the new database and pass the following SQL statement,
    which adds the spatial functionality tables to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The PostGIS database for this chapter is now created and spatially enabled.
  prefs: []
  type: TYPE_NORMAL
- en: GDAL/OGR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's built-in geospatial support requires the use of code libraries available
    from the **Open Source Geospatial Foundation** (**OSGeo**). The GDAL library,
    which includes OGR, handles vector and raster datasets. It must be installed (see
    [Chapter 5](0b3a2208-3881-479a-83a8-78be85b9c1d6.xhtml), *Vector Data Analysis*,
    and [Chapter 6](a5c9354e-8ea4-45f6-9e69-191375e171c3.xhtml), *Raster Data Processing*,
    for more details on using it for analysis).
  prefs: []
  type: TYPE_NORMAL
- en: If it is not already installed, use the OSGeo4W installer available at: [https://trac.osgeo.org/osgeo4w/](https://trac.osgeo.org/osgeo4w/).
    Select the correct installer for your machine. The installer will also install
    QGIS and GRASS and other open source geospatial programs. Download and run the
    installer and place the output files on your local drive. This file path (for
    example: `C:\OSGeo4w`) will be important when modifying the Windows environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find installation instructions for configuring GeoDjango for Linux and macOS
    from the Django project documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.djangoproject.com/en/2.0/ref/contrib/gis/install/](https://docs.djangoproject.com/en/2.0/ref/contrib/gis/install/).'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Windows environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Editing the system path and other environment variables within Windows requires
    administrative permissions. Here are the steps to edit them for our purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Log into an account with administrative permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Windows Explorer and right-click on the PC icon in the left pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Properties from the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Advanced system settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next menu, click on Environment Variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Path from the system variables and click Edit (or double-click on the
    path value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the file path of the `bin` folder in the `OSGeo4W` folder (for example, `C:\OSGeo4W\bin`) to
    the path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a278951a-3204-4cf5-bd15-c794188c225d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Python 3.6` folder has also been added to the path in this example, as
    well as `Python 2.7`, which is ordered behind `Python 3.6` because of its position
    in the path environment variable value. This means that when Python is passed
    to a command line, the `Python 3.6` executable will be run.
  prefs: []
  type: TYPE_NORMAL
- en: Two other variables that may be required are the GDAL_DATA variable and the
    PROJ_LIB variable. If PostGIS has been installed, it will have created a GDAL_DATA
    variable already, but if it is not present, click the New button underneath the
    system variables box. Add the name of the variable (GDAL_DATA) and the variable
    value (for example, `C:\OSGeo4W64\share\gdal`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the PROJ_LIB variable the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fc8d73c-8589-4663-bf5e-c480a87e6559.png)'
  prefs: []
  type: TYPE_IMG
- en: Click OK to save the new variables, and OK again to get out of the first settings
    dialog. Close the System Properties menu.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project and application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Django is installed, let's create a project. Django has two levels
    that are managed by scripts accepting command-line arguments. These two levels
    are projects and applications. A project can have many applications, and sometimes
    an application has multiple projects as well. This organization allows you to
    reuse of code between related applications, governed by project-level code.
  prefs: []
  type: TYPE_NORMAL
- en: Django uses an administration file, `django-admin.py`, to control the creation
    of projects. It is installed in the `Scripts` folder of the `Python 3` folder.
    I usually copy the `django-admin.py` file into a new project folder, and pass
    the required command-line arguments while working in the project folder, but it
    can also be called from the command line if the `Scripts` folder is included in
    the path environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for your project; something like `C:\Projects`. Copy `django-admin.py`
    into `C:\Projects`.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line argument – startproject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A command-line argument is used with `django-admin.py` to create the project—`startproject`.
    To create a project, open the command prompt and change directories to the folder
    created earlier. We will create projects in this folder by passing `startproject` and
    the name of our new project (`chapter12`) to `django-admin.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c20ecb-1bc4-49bf-b62e-c01e9dff7c98.png)'
  prefs: []
  type: TYPE_IMG
- en: What is created by startproject?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By passing the two arguments to `django-admin.py`, `startproject`, and `chapter12`
    (the name of the project), a folder is created with a number of scripts and subfolders.
    The outer (`root`) folder is called `chapter12`, and it contains an important
    script called `manage.py`, and a folder also called `chapter12`*,* which is the
    project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e667b98-8611-4bef-9690-f6a8f6f0bb7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the project folder are some important scripts, including `settings.py` and `urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0239fb6b-828e-4f0f-ab98-ab98d320a3cd.png)'
  prefs: []
  type: TYPE_IMG
- en: These files are default placeholders, waiting for us to configure our project
    and applications. We will edit `setting.py` and `urls.py` too, with the specifics
    of our project as we go along. The third file, `wsgi.py`, is used for production
    deployment of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an application using manage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the `root` folder, `Projects` folder, and associated scripts have been
    created. Within the `root` folder is the `manage.py` file, which is used for configuration
    and management of the applications and project. In this section, we'll create
    an application using `manage.py` and the command-line argument `startapp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the command prompt, change directories into the `root` folder. Unlike
    `django-admin.py`, we have to run `manage.py` by passing it as an argument to
    the Python executable. In turn, to `manage.py` we pass the argument `startapp`
    and the name of the application, `arenas`. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/117d45fd-a4e0-4e8d-b81e-a9ce0ae91b85.png)'
  prefs: []
  type: TYPE_IMG
- en: What is created by manage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Passing the `startapp arenas` command to `manage.py` created a folder called
    `arenas`. All applications are created within the `root` folder, next to the project
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76d4ed13-91b6-4f08-ac26-912e704f2822.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the folder are auto-generated scripts that we will configure and add
    to later. There is also a folder called `migrations`, which is used by Django
    to store scripts describing edits to the database. The scripts `admin.py`, `models.py`,
    and `views.py` will be used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/114bdd5b-898b-416e-8793-812ed7422a98.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring settings.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the project created and a new application, the next step towards using
    GeoDjango is to configure the `settings.py` script contained in the project folder.
    We'll add the specifics about the database connection (user, password, database
    name, and so on), and adjust the `INSTALLED_APPS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using IDLE or another IDE, open `settings.py` from the `chapter12` project folder.
    Scroll down to the variable called `DATABASES`. This variable, which is set to
    a local SQLite database, will be adjusted to the PostgreSQL database with the
    PostGIS extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following, substituting the `username` and `password` for
    your PostGIS installation (see [Chapter 3](42c1ea5a-7372-4688-bb7f-fc3822248562.xhtml),
    *Introduction to Geospatial Databases*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An empty string can also be used for the `HOST` option to indicate `localhost`.
    If the PostgreSQL installation is on a different machine, adjust the `HOST` option
    to the IP address of the database server. If it is on a different port, adjust
    the `PORT` option.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script, but don't close it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new installed apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within `settings.py`, scroll to the variable `INSTALLED_APPS`. This lists the
    built-in, core applications used to support our application. To it, we'll add
    `django.contrib.gis`, the built-in Django GIS application, and our own new application,
    Arenas.
  prefs: []
  type: TYPE_NORMAL
- en: '`INSTALLED_APPS` is a list and can be edited. Initially, `INSTALLED_APPS` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Save `settings.py` and close the script. Now we've added our custom arenas app
    and Django's GIS library to the installed app package manager, so GeoDjango is
    now configured. Next, we'll use `manage.py` and OGR to read shapefiles and automatically
    generate data models.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application will perform geospatial analysis using the geometry fields
    of database tables. To make this possible, we have to create and populate the
    database tables using shapefiles and a built-in method called `LayerMapping`.
  prefs: []
  type: TYPE_NORMAL
- en: The completed application will need URL pattern matching to link URLs with the
    views that will process the requests and return the response. Templates will be
    used to pass processed data to the browser. Views will be written to be able to
    handle both `POST` and `GET` requests and to redirect to other views.
  prefs: []
  type: TYPE_NORMAL
- en: Now that GeoDjango is configured, the NBA Arenas application can be created
    using the Django project management script called `manage.py`.
  prefs: []
  type: TYPE_NORMAL
- en: manage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The script `manage.py` performs a number of jobs to help set up and manage
    the project. For testing purposes, it can create a local web server (using `runserver`
    as the argument); it manages database schema migrations, generating tables from
    data models (using `makemigration` and `migrate`); it even has a built-in Python
    3 shell (using `shell`) for testing and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e08c8f9-ae5d-484b-b60f-81a06f8a823a.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we'll use `manage.py` to create and populate database tables,
    using shapefiles as the data and schema source.
  prefs: []
  type: TYPE_NORMAL
- en: Generating data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After configuring GeoDjango, a new available function in `manage.py` is available, `ogrinspect`,
    which automatically generates data table models with geometry columns that can
    be placed in `models.py`. By inspecting or reading the shapefile data using OGR,
    Django's built-in functionality creates a Python class data model and a field
    mapping dictionary that maps between the names of shapefile fields and database
    columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, we will use the shapefiles downloaded in [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml),
    *Flask and GeoAlchemy2*. They are also available in the code package. Copy the
    four shapefiles (and all of the associated files) into a folder called `data`
    within the arenas application folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c239832-ff10-469c-af8c-fb7754492ac7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open a command prompt, and change the directory to the project folder. The `data` folder
    with the four shapefiles (`Arenas_NBA.shp`, `US_States.shp`, `US_County_Boundaries.shp`,
    and `Congressional_Districts.shp`) will be inspected to generate data models using
    `manage.py`. The results are copied to `models.py`. From these models, the database
    tables will be generated, and then the tables will be populated using the field
    mapping dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will produce a data model with a geometry column and a `4326` SRID.
    The field mapping dictionary, generated by the `--mapping` option, is a Python
    dictionary that maps between the keys (data model column names) and the values
    (shapefile field names). This is a part of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9dc5556-ddbb-494d-bbb2-a8cd113c170c.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the output, including the `import` line, data model, and the field mapping
    dictionary into `arenas`\`models.py`. Copy the `import` line over the data model
    class definition over the auto-generated `import` line in `models.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying from the command line is easy when the Quick Edit option is turned on
    in the command prompt defaults. Once it is on, select text by dragging the mouse.
    Push *Enter* when the text block has been selected.
  prefs: []
  type: TYPE_NORMAL
- en: Multipolygons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the three other shapefiles with multipolygon geometry types, we'll pass
    the argument—`multi` to `manage.py` and `ogrinspect`. Using this option generates
    a `MultiPolygon` geometry column in the data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command generates a data model from the US States shapefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Copy the output to `models.py`, including both the data model and the field
    mapping dictionary. Repeat the process for the counties and districts shapefiles
    by adjusting the arguments to `manage.py`(that is, the shapefile name and the
    table name), and save `models.py` once the models have been added.
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses a concept of database migrations to record and execute changes to
    the database. These changes include table creation and schema alterations. Now
    that we have generated the data models, we need to migrate the database, which
    involves inspecting `models.py` for changes, calculating the SQL syntax to generate
    the database alterations, and then running the required migrations to make the
    database table columns match their `models.py` code definitions. These migrations
    can also be reverted.
  prefs: []
  type: TYPE_NORMAL
- en: makemigrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the migration, pass `makemigrations` to `manage.py`. This argument
    will start the migration process by inspecting the contents of `models.py`. All
    of the Python class data models will be read, and the corresponding SQL is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A new script has been generated and added to the `migrations` folder. This initial
    database migration script creates a `Migration` class and includes a number of
    migration operations using the `CreateModel` method. Each of these migrations
    creates operations will generate a new (empty) table in the `chapter12` database.
    `Migration` classes also have methods for performing table alterations, when you
    need to add or remove fields.
  prefs: []
  type: TYPE_NORMAL
- en: sqlmigrate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the command `sqlmigrate` to see the SQL statements generated from the `makemigration`
    operation. Pass `sqlmigrate`, the application label (`arenas`), and the migration
    name (`0001`) to `manage.py` to generate the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f0aeaa8-cb7a-41b8-8370-f596c379e116.png)'
  prefs: []
  type: TYPE_IMG
- en: All of the data models have been translated to SQL, with definitions for primary
    keys and field lengths added automatically.
  prefs: []
  type: TYPE_NORMAL
- en: migrate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the migration script generated, we can finally perform the database migration.
    This operation will generate the tables within the database specified in `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the argument `migrate` to `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the operation should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c116e214-f585-4673-8308-7287af23b699.png)'
  prefs: []
  type: TYPE_IMG
- en: The database tables have been created in the database. Open pgAdmin4 (or another
    database GUI tool) to check on the tables within the database, or open psql and
    use the command line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore the Django documentation to explore all of the available arguments
    for `django-admin.py` and `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.djangoproject.com/en/2.0/ref/django-admin/](https://docs.djangoproject.com/en/2.0/ref/django-admin/).'
  prefs: []
  type: TYPE_NORMAL
- en: LayerMapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To populate the database tables created from the shapefiles, Django has a built-in
    concept called `LayerMapping`. By using the field mapping dictionary generated
    by `manage.py`, along with the `LayerMapping` class from `django.contrib.gis.utils`,
    the data contained in the shapefiles can be extracted and loaded into the database
    tables. To instantiate a `LayerMapping` instance, we will pass the data model,
    the associated field mapping, and the location of the shapefile to the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `load.py` and save it inside the Arenas application.
    Add this line to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `models.py` and copy all of the field mapping dictionaries into `load.py`.
    Then, use the `os` module to assign the shapefile path to a variable. Here is
    the dictionary and path variable for `US_County_Boundary.shp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this step for all of the shapefiles, as demonstrated in the `load.py`
    provided in the code package. These path variables and mapping dictionaries are
    required to perform the layer mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Running the layer mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the bottom of `load.py`, create a function called `run` that contains the
    following code. Note that the names of the mappings (for example, `us_states_mapping`)
    will have to match the names of the dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the script, we will use the `manage.py shell` argument to invoke a Python
    shell, and then import the `load.py` file and execute the `run` function inside
    this local shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `run` function is called and executed, the rows of data in the shapefiles
    are imported into the database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b22e3c5-ba3c-43d8-acbd-15607672236b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the function completes successfully, the database tables will be populated.
    We can now explore a very useful feature of Django—the built-in admin panel.
  prefs: []
  type: TYPE_NORMAL
- en: Administrative panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Django framework was developed in a busy newsroom environment, and from
    the beginning, it required a built-in administrative panel that would allow reporters
    and editors to access their stories. This concept has continued to be supported,
    as most websites require an interface for administrative tasks. It's a very useful
    and convenient interface that requires no technical knowledge about the site to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: GeoDjango administrative panel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Websites built with the GeoDjango configuration are no different, and the administrative
    panel for GeoDjango websites even supports the display and editing of geometry
    data. The `OpenLayers` JavaScript library is included in the panel template to
    allow for the data visualizations. It also allows for the normal administrative
    tasks such as editing groups or users and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: admin.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To access the data models stored in `models.py` through the administrative
    panel, the autogenerated script called `admin.py` inside the Arenas application
    must be updated. Open the file in an IDE and add the following lines, copying
    the original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Save the script and close it.
  prefs: []
  type: TYPE_NORMAL
- en: createsuperuser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to create a superuser. This user will be able to access the
    administrative panel. To do this, we will pass the `createsuperuser` argument
    to `manage.py` and follow the instructions as they appear one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The superuser is now available for logging into the administrative panel, using
    the password and username supplied.
  prefs: []
  type: TYPE_NORMAL
- en: runserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the superuser has been created, pass the `runserver` argument to `manage.py`
    to start the local development web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50708041-295e-426d-b330-bec34b8afe33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will make the `localhost` open at port `8000` by default (`http://127.0.0.1:8000`).
    The administrative panel is available at: `http://127.0.0.1:8000/admin`. Open
    a web browser and navigate to the administrative panel URL. Enter the superuser
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/316a4389-9f0b-45c9-a2ae-29affc4fa067.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once they are entered, the administrative panel will list the available models,
    as well as the authentication and authorization section. These models are initially
    shown with an s at the end of their name (pluralizing them by default). This behavior
    can (and should) be overridden, though we won''t focus on that task here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/236269fb-0033-4657-ace3-6bb5732ad665.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the U_s_statess model under ARENAS, and then click on the first object
    in the list of states objects. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/031b3c08-fca8-46a6-8980-b3ab1548b3b1.png)'
  prefs: []
  type: TYPE_IMG
- en: These fields can be edited through this administrative panel, and even the geometry
    of the state (or, in this case, Puerto Rico) can be edited using the `OpenLayers`
    editing plugin included. Click Save after any edits. The data row can also be
    deleted from this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore the complete administrative panel documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.djangoproject.com/en/2.0/ref/contrib/admin/](https://docs.djangoproject.com/en/2.0/ref/contrib/admin/).'
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, within the HTML form section, we designate where the description and
    a drop-down list will go and include a hidden token (CSRF), which is required
    for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: With the models generated and data added to the associated tables, it's time
    to generate some views, which will process our web requests and return the data
    required to complete our request.
  prefs: []
  type: TYPE_NORMAL
- en: To correctly route our requests, we have to first create some URLs that will
    be paired with a view. This will require both project-level and application-level
    configuration. Unlike Flask, URLs are not attached to views using Python decorators.
    Instead, they are contained in separate scripts that will either map to an application
    or a view.
  prefs: []
  type: TYPE_NORMAL
- en: URL patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django URL patterns are very clean and simple and make for nice websites where
    the URLs are short and memorable. To make this possible, there is matching of
    the requested URL with a view (or application-level URL that matches with a view).
    The URLs and their destination are matched inside a list called `urlpatterns`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the project folder (`C:\Projects\chapter12\chapter12`), there is a script
    called `urls.py` just underneath `settings.py`. This script controls project-level
    URL routing. For this application, we'll also add application-level URLs inside
    the `arenas` folder and will point the project-level URL routing to the application
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the project-level `urls.py`, and copy the following code over any existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will redirect the requests to two different URLs in the application-level
    `urls.py` file, where they can be further sorted. Any requests sent to the admin
    URL are handled by the administrative code. The `path` function accepts two required
    parameters: the URL path (for example, `''arenas/''`, which goes to `http://127.0.0.1:8000/arenas`),
    and the view or application-level code that will accept the request. The `include` function
    is used to add the available URLs from the Arenas application into the project
    level URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the application-level URLs, create a script called `urls.py` inside
    the Arenas application folder. Copy the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This time, the function `path` directs requests to views (that will be) inside
    the `views.py` script. Both the base URL and the arena URL are redirected to a
    view. The optional parameter `name` is also included.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a major change in Django URL patterns was introduced in Django 2.0\.
    Earlier Django versions do not use the `path` function but use a similar function
    called `url`. Ensure that you are using the newest version of Django to match
    the code here.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views are at the heart of the application, and in Django take the form of Python
    functions. They accept both `GET` and `POST` web requests, allowing for multiple
    actions, with various responses, to occur inside the same function. Within view
    functions, we design how the request is parsed, how database tables are queried,
    how the query results (**QuerySets** in Django) are processed, and which forms
    and templates are sent to the browser along with the processed data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the URL patterns are in place, we need to write some views that will
    accept and process the web requests sent to the URLs. These views will query the
    database table model classes in `models.py`to find the location data associated
    with each NBA arena included in the `Arenas` class.
  prefs: []
  type: TYPE_NORMAL
- en: Required folders and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to create the necessary folders with files of forms and templates,
    as web responses from the views require a pre-generated template that can display
    the requested data (in this case, the location of the NBA `arena` requested).
  prefs: []
  type: TYPE_NORMAL
- en: forms.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A web form is used in Django to capture user input and submit it to a view.
    To make it possible to select an NBA `arena` name from a drop-down list and have
    the web map zoom to that location, a new script, `forms.py`, must be created.
    Open an IDE and copy the following code into a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This section creates a form class by subclassing from `forms.Form`. It has a
    `name` field, a `description` field, and a `ChoiceField`. The `ChoiceField` will
    create a drop-down list, populated by the IDs and names of the `arenas`. Other
    fields will be added to the `ArenaForm` class within the view and are not defined
    here. This form and its fields will be inserted into the template created in the
    next section. Save this file as `forms.py` into the Arenas application folder.
  prefs: []
  type: TYPE_NORMAL
- en: templates folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy the `templates` folder from the completed code package into the Arenas
    application folder. Inside the `templates` folder is a folder called `arenas`,
    with a template HTML file called `index.html`. This file contains a JavaScript
    portion that generates a web map. On that map, the location of an NBA `arena` is
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Django templates use placeholders (demarcated with a `{{form.field }}` format) that allow
    for data to be passed at runtime into the template, providing the specifics of
    the request. These placeholders are located throughout `index.html`. Django has
    its own built-in template language, which we will use here, and also includes
    Jinja2, which Flask also uses (see [Chapter 11](e483966e-f5c7-47dd-a40c-9b8b6f807107.xhtml),
    *Flask and GeoAlchemy2*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first portion of `index.html` is to highlight is where the `longitude`
    and `latitude` of the current NBA `arena` have been added to the Leaflet JavaScript,
    which centers the map window on that location at zoom level `13`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next portion to highlight is where the `longitude`, `latitude`, and custom
    `popup` about the current NBA `arena` are added to a marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, within the HTML `form` section, we designate where the `description`
    and a drop-down list will go and include a hidden token (CSRF), which is required
    for authentication of the `POST` request. The button is generated by the input
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: All of these placeholders will be populated when the view is processed and data
    is returned to the requesting browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything is finally set to write our views. Open up `views.py` from the Arenas
    application folder within an IDE. Import the required libraries, models, forms,
    and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create two views—`index` and `arena`*, *and one non-view function
    called `queryarena`. These match with the URLs we added to `urls.py`. The return
    from the `index` function is very simple—it will redirect to the function `arena`.
    For the views, a decorator is used to determine the HTTP request methods allowed.
  prefs: []
  type: TYPE_NORMAL
- en: index view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `index` view is a Python function that accepts the request data and redirects
    it to the `arena` view, with a decorator (`require_http_methods`) prior to restricting
    the HTTP requests allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: queryarena function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `arena` function below selects a random `arena` for the initial `GET` request,
    getting data from the database model about the selected NBA `arena`. The queries
    themselves are handled by the `queryarena` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this function, the name of the selected `arena` is accepted as a parameter.
    It is used to query (or `filter`) all of the `Arenas` model objects. This **object-relational
    mapping** (**ORM**) `filter` method requires a field as a parameter; in this case,
    the field is called `name1`. As an example of what the `filter` is doing,  if
    the name of the `arena` is *Oracle Arena*, the `filter` translated to English
    would be *find all NBA arenas with the name Oracle Arena*. The results of the
    `filter` method are returned as a list, so the first result is retrieved from
    the list using zero-indexing. A result is an object representing the data row
    from the `Arenas` class that met the `filter` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once the `arena` object is instantiated, its geometry field is used in a `filter`
    operation. Instead of using a field to `filter`, however, this `filter` uses geospatial
    analysis. Passing `arena.geom` to the `geom__intersects` method (provided by GeoDjango)
    performs an intersect operation to find the state in which the `arena` resides.
    An `if`/`else` conditional checks to ensure that the `arena` is located in the
    United States (for instance, not Toronto's `arena`) to determine the correct value
    to return.
  prefs: []
  type: TYPE_NORMAL
- en: If the `arena` is located inside the United States, the `arena` geometry is
    again used to determine the `county` and congressional `district` that contain
    the `arena`. This time, the geospatial operation is `geom_contains`. The `filters`
    return a `county` object and a `district` object. They are used to generate the
    custom `popup` that will be added to the map marker on the leaflet map. This `popup`
    contains the `longitude` and `latitude` of the `arena`, the name of the `arena`,
    and the name of its `county`, `state`, and the number of the congressional `district`
    within its `state`.
  prefs: []
  type: TYPE_NORMAL
- en: arena view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `arena` view accepts the `request` object and then instantiates an `ArenaForm`
    object to gather the data needed to respond to the `request`. A query of the `Arenas`
    model objects and its `values_list` method creates a Python list that contains
    tuples with the ID and name of every `arena`. The `request` method (either `GET`
    or `POST`) is used in a conditional to determine the appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: If a `GET` request is received (that is, the web page is first opened), a random
    `arena` object is generated and passed to the template, which shows the `arena`
    on the included map. To get a random `arena`, we use the list of `arena` names
    and IDs (values). Once the list is generated, a list comprehension is used to
    generate a new list containing `arena` names.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `random` module and the `#` of names in the list (`length`) generates
    a random `index` that is used to select an `arena` name from the list. This `name`
    is then passed to the `queryarena` function, which populates the `form` with the
    `arena` `name`, location, and the `popup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These values are returned to the browser using the `render` function. This
    function is used to pass `forms` to templates along with the `request`, and knows
    where the `templates` folder is located inside the Arenas application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If a `POST` request is received (that is, an `arena` was selected), an `ArenaForm`
    class is called by passing the `POST` data to the class, and the `form` is validated.
    The ID of the selected `arena` is used as a conditional in a list comprehension,
    allowing us to retrieve the `name` of the `arena`. The `name` is then passed to
    `queryarena`, and the details of its location are queried and added to the `form`
    before it is returned using `render`.
  prefs: []
  type: TYPE_NORMAL
- en: The views are complete and the script can be saved. The next step is to run
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open, the command prompt and change directories to the `root` folder (`C:\Projects\chapter12`).
    Start the local development server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/257c5316-7c47-469e-a9a9-d4858dc1d43a.png)'
  prefs: []
  type: TYPE_IMG
- en: Open a browser and go to: `http://127.0.0.1:8000`. The initial `GET` request
    will be redirected to the `arenas` view and processed, returning a random `arena`.
    Selecting another `arena` from the list and pushing the Find Data button will
    perform a `POST` request and will locate the selected `arena`. Each time an `arena`
    is selected, the text of the `arena` name will change, along with the map location
    and popup displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the results of a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42da4615-1886-44c4-8ac2-9b91e1573145.png)'
  prefs: []
  type: TYPE_IMG
- en: Test the application by selecting different NBA arenas, and for extra credit,
    change the popup message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django, with its batteries-included philosophy, creates complete applications
    with very few outside libraries required. This application performs data management
    and data analysis using only the Django built-in tools and the GDAL/OGR library.
    Enabling the GeoDjango functionality is a relatively seamless experience because
    it is an integral part of the Django project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating web applications with Django allows for a lot of instant functionality,
    including the administrative panel. The `LayerMapping` makes it easy to import
    data from shapefiles. The ORM model makes it easy to perform geospatial filters
    or queries. The templating system makes it easy to add web maps as well as location
    intelligence to a website.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use a Python web framework to create a geospatial
    REST API. This API will accept requests and return JSON encoded data representing
    geospatial features.
  prefs: []
  type: TYPE_NORMAL
