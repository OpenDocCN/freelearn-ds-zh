- en: Raster Data Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Geographic information systems** (**GIS**)are often comprised of points,
    lines, and polygons. These data types are called vector data. There is, however,
    another data type in GIS—rasters. In this chapter, you will learn the basics of
    working with raster data. You will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Geospatial Data Abstraction Library** (**GDAL**) to load and query
    rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GDAL to modify and save rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use GDAL to create rasters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load rasters into PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform queries on rasters using PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing GDAL can be difficult. By using virtual environments and running
    Anaconda, you can simplify this process by using the GUI of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Raster operations using GDAL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GDAL library allows you to read and write both vector and raster data.
    To install GDAL on Windows, you will need the appropriate binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: You can download OSGeo4W, which contains the binaries, at: [https://trac.osgeo.org/osgeo4w/](https://trac.osgeo.org/osgeo4w/)
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have the binaries, you can install `gdal` using `conda`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the following sections, you will learn how to load and work with a `.tif` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GDAL library to load and query rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have `gdal` installed, import it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'GDAL 2 is the most recent version. If you have an older version of `gdal` installed,
    you may need to import it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If this is the case, you may want to look into upgrading your version of `gdal`.
    Once you have `gdal` imported, you can open a raster image. First, let's get an
    image from the web. The Earth Data Analysis Center at the University of New Mexico
    maintains the **Resource Geographic Information System** (**RGIS**). In it, you
    will find New Mexico GIS data. Browse to [http://rgis.unm.edu/](http://rgis.unm.edu/) and
    from the Get Data link, Select `Shaded Relief`, `General`, and `New Mexico`. Then,
    download the `Color Shaded Relief of New Mexico (Georeferenced TIFF)` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you extract the ZIP file, you will have several files. We are only interested
    in `nm_relief_color.tif`. The following code will open TIF using `gdal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code opens TIF. It is very similar to opening any file in Python,
    except you used `gdal.Open` instead of the standard Python library `open`. The
    next line prints the metadata from the TIF, and the output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous metadata gives you some basic information such as dates created
    and revised, the resolution, and pixels per inch. One characteristic of the data
    we are interested in is the projection. To find it, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `GetProjection` method on the TIF, you will see that we didn''t find
    any. The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open this TIF in QGIS, you will get a warning that the CRS is undefined
    and it will default to `epsg:4326`. I know that the image is projected and we
    can find this out by looking at the `nm_relief_color.tif.xml` file. If you scroll
    to the bottom, you will see the values under the XML tag `<cordsysn>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look up the projection at [spatialreference.org](http://spatialreference.org),
    you will find that it is EPSG:26913\. We can use `gdal` to set the projection,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code imports the `osr` library. It then uses the library to create
    a new `SpatialReference`. Next, it imports a known reference using `ImportFromEPSG`
    and passes `26913`. It then uses `SetProjection`, passing the WKT for EPSG:26913\.
    Lastly, it calls `GetProjection` so that we can see that the code worked. The
    results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is the WKT for EPSG:26913.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open QGIS and the TIF will load with no warnings. I can add a copy of the Albuquerque
    streets to it and they will appear exactly where they should. Both sets of data
    are in EPSG:26913\. The following image shows the TIF and the streets in the center
    of New Mexico-Albuquerque:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b0cef82-d52f-4a47-80a9-8d062160a975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tif of NM with Streets shapefile
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added a projection, we can save a new version of the TIF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To see that the new file has the spatial reference, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will output the **well-known text** (**WKT**) for EPSG:26913,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A color raster dataset has three bands—red, green, and blue. You can get each
    of the bands individually using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will return `3`. Unlike an array, the bands are indexed 1-n,
    so a three band raster will have indexes `1`, `2`, and `3`. You can grab a single
    band by passing the index to `GetRasterBand()`, which is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a raster band, you can perform queries on it and you can
    lookup values at positions. To find the value at a specified row and column, you
    can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `values` is an array, so you can lookup values by index notation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will return a value of `216`. In a single band array, this
    would be helpful, but in a colored image, you would most likely want to know the
    color at a location. This would require knowing the value of all three bands.
    You can do that by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code returns the values—`216, 189, 157`. These are the RGB values
    of the pixel. These three values are composited—overlayed on each other, which,
    should be the color shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e90d25aa-315d-4910-aa30-18aaf8f72450.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The color represented by the three bands at [1100,1100]
  prefs: []
  type: TYPE_NORMAL
- en: 'With a band, you have access to several methods for obtaining information about
    the band. You can get the mean and standard deviation of the values, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get the minimum and maximum values from a band, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The result should be `0.0` and `255.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get the description of the band. The following code shows you
    how to get and set the description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The most obvious thing you may want to do with a raster dataset is to view
    the raster in Jupyter Notebook. There are several ways to load images in a Jupyter
    notebook, one being using HTML and an `<img>`. In the following code, you are
    shown how to plot the image using `matplotlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous code imports `numpy` and `matplotlib.pyploy.imshow`.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is a popular library for working with arrays. When dealing with rasters,
    which are arrays, you will benefit from having a strong understanding of the library.
    Packt published several books on NumPy such as *NumPy Cookbook*, *NumPy Beginners
    Guide*, and *Learning NumPy Array,* and thiswould be a good place to start learning
    more.
  prefs: []
  type: TYPE_NORMAL
- en: It then sets plotting an inline for this notebook. The code then reads in the
    TIF as an array. It then makes a `numpy` array from the first band.
  prefs: []
  type: TYPE_NORMAL
- en: Bands are indexed *1*-*n*, but once read in as an array, they become indexed
    at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To isolate the first band, the code reshapes the array using the width and
    height. Using `x.shape`, you can get them both, and if you index, you can get
    each one individually. Lastly, using `imshow`, the code plots the image using
    the color map for `gist_earth`. The image will display in Jupyter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/984bdb86-8302-49b6-bf25-f1854bc4f553.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tif in Jupyter using imshow
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to load a raster and perform basic operations, you will
    learn how to create a raster in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using GDAL to create rasters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to load a raster, perform basic queries,
    modify it, and save it out as a new file. In this section, you will learn how
    to create a raster.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **raster** is an array of values. So to create one, you start by creating
    an array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code creates a `numpy` array with four rows of seven columns.
    Now that you have the array of data, you will need to set some basic properties.
    The following code will assign the values to variables and then you will pass
    them to the raster in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The following code sets the lower-left corner, width, height, and name for the
    raster in the variable `coord`. It then sets the width and height in pixels. Lastly,
    it names the raster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the raster by combining the data and properties.
    The following code will show you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The previous code assigns the `GeoTiff` driver to the variable `d`. Then, it
    uses the driver to create the raster. The create method takes five parameters—the
    `name`, size of `x`, size of `y`, the number of bands, and the data type. To get
    the size of `x` and `y`, you can access `a_raster.shape`, which will return (4,7).
    Indexing `a_raster.shape` will give you `x` and `y` individually.
  prefs: []
  type: TYPE_NORMAL
- en: '`Create()` accepts several data types—starting with `GDT_`. Other data types
    include Unknown, Byte, UInt16, Int16, UInt32, Int32, Float32, Float64, CInt16,
    CInt32, CFloat32, and Cfloat64.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code sets the transformation from map to pixel coordinates using the
    upper-left corner coordinates and the rotation. The rotation is the width and
    height, and if it is a north up image, then the other parameters are 0.
  prefs: []
  type: TYPE_NORMAL
- en: To write the data to a band, the code selects the raster band—in this case,
    you used a single band specified when you called the `Create()` method, so passing `1`
    to `GetRasterBand()` and `WriteArray()` will take the `numpy` array.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will need to assign a spatial reference to the TIF. Create a spatial
    reference and assign it to `outsr`. Then, you can import a spatial reference from
    the EPSG code. Next, set the projection on the TIF by passing the WKT to the `SetProjection()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to `FlushCache()`, which will write the file. If you are done
    with the TIF, you can set `output = None` to clear it. However, you will use it
    again in the following code snippet, so you will skip that step here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove that the code worked, you can check the projection, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output shows that the TIF is in EPSG:4326:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can display the TIF in Jupyter and see if it looks like you expected. The
    following code demonstrates how to plot the `image` and inspect your results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code reads the raster as an array and assigns the width and height.
    It then creates an `image` variable, reshaping the array to the width and height.
    Lastly, it passes the image to `imshow()` and prints the `data` in the last line.
    If everything worked, you will see the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2302d703-eddb-442a-abfa-5c20c786d031.png)'
  prefs: []
  type: TYPE_IMG
- en: The array values and the raster created from them
  prefs: []
  type: TYPE_NORMAL
- en: The following section will teach you how to use PostgreSQL to work with rasters
    as an alternative or in conjunction with `gdal`.
  prefs: []
  type: TYPE_NORMAL
- en: Raster operations using PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first section of this chapter, you were able to load, display, and query
    rasters using `gdal`. In this section, you will learn how to load and query rasters
    using a spatial database—PostgreSQL. As you start to model your data, you will
    most likely hold it in a spatial database. You can leverage your database to perform
    the queries on your rasters.
  prefs: []
  type: TYPE_NORMAL
- en: Loading rasters into PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To load a raster into PostgreSQL, you can use the `raster2pgsql` binary. If
    it is not in your path, you may need to add it. You should be able to find the
    binary in your PostgreSQL install directory on Windows at `\PostgreSQL\10\bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command should be executed from your operating system''s command
    line. It will load the TIF you created earlier in this chapter into an existing
    PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The previous command uses `raster2pgsql` with the `-I` (creates an index), `-C`
    (adds raster constraints), and `-s 4326` (the SRID) parameters. Using the pipe
    operator on Windows, you send the command to `psql`. Psql is run using the `-U`
    `postgres` (username) and `-d pythonspatial` (database) parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you are logged in as the Postgres user, you do not need the `-U`. Without
    it, Windows will try to log in to PostgreSQL using the logged in user account,
    which may not be the same as the PostgreSQL user.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the data loaded in PostgreSQL, the following section will
    show you how you can use Python to query it.
  prefs: []
  type: TYPE_NORMAL
- en: Performing queries on rasters using PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a raster loaded into PostgreSQL, you can query it using Python. The Python
    library for working with PostgreSQL is `psycopg2`. The following code will connect
    to the database where you loaded the TIF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The previous code imports `psycopg2`. It then makes a connection passing the
    database name, username, and password. Lastly, it gets a `cursor` object so that
    you can execute queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the raster in PostgreSQL, you can execute a select all, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code executes a select all statement and prints all the results.
    There are two columns in the table—rid and `rast`. Rid is the unique ID field
    for the raster. If you had tiled it when running `raster2pgsql`, there would be
    more rows. The `rast` column holds the raster data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Querying raster metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using PostgreSQL, you can perform various queries on your data. In this section,
    you will learn how to query the raster for basic metadata and properties. This
    section will present a few of the many PostgreSQL functions that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query the data for a basic text summary. The following code shows you
    how to use the `ST_Summary()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The summary function takes the raster data column as a parameter and returns
    a string containing the size of the raster, the bounding box, the number of bands,
    and if there are no data values in any of the bands. The following is the output
    from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing out the individual pieces of information from `ST_Summary` would be
    difficult. You can retrieve this information in a more machine-readable format
    by using the `ST_Metadata` function. You can use the following code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code queries the raster for the upper-left *X* value, the upper-left
    *Y* value, the width, the height, the scale of *X*, the scale of *Y*, the skew
    of *X*, the skew of *Y*, the SRID, and the number of bands in the raster. The
    output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The output allows you to select individual pieces of metadata by using index
    notation, which is a simpler solution to parsing the string provided by `ST_Summary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query for specific and individual attributes of the raster. To get
    the raster as a single polygon—instead of the two-point box described in the summary—you
    can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code is the WKT for a vector-polygon-of the raster.
    It is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will query the height and width of the raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall from earlier in the chapter, the raster is `4x7`, as shown
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another piece of metadata that may come in handy is the pixel size. The following
    code will show you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ST_PixelWidth` and `ST_PixelHeight`, you will get the output as follows.
    This matches the height and width from when you created the raster earlier in
    the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can query the raster for basic statistical information about the data within
    the cells for a specific band. `ST_SummaryStats` provides basic summary statistics
    for the data values. The following code shows you how to query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous code returns the count, sum, mean, standard deviation,
    min, and max for a raster band. You can pass the raster band by passing it as
    an integer in the second parameter, `ST_SummaryStats(rast,3)`. If you do not specify
    the band, the default is `1`. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also query for a histogram of the values in the raster, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses `ST_Histogram` and passes the raster column and a band.
    You can pass the number of bins as the third parameter or you can let the function
    decide. The result is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The previous output is an array of bins. Each bin contains the minimum value,
    the maximum value, the count, and the percentage.
  prefs: []
  type: TYPE_NORMAL
- en: Queries returning geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous queries returned basic information about the raster and returned
    collections with the data. In PostgreSQL, there are a series of functions that
    return geometries from queries. This section will cover a few of those functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A raster is comprised of a matrix of cells and values. These cells become georeferenced
    pixels in our raster data. Using PostgreSQL, you can query your raster data for
    a specific cell and get the polygon representation of that cell back. The following
    code shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using `ST_PixelAsPolygons`, you can pass the raster column, the column, and
    the row of a cell and get back polygon geometry for that cell. By wrapping the
    query in `ST_AsText`, you get back the WKT representation of the polygon instead
    of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The previous output returned the rid (raster ID) of the pixel. Since you did
    not tile the raster when loading it into PostgreSQL, all the queries will return
    a rid of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The previous query returned a polygon, but you can use functions to return points.
    Using `ST_PixelAsPoints` and `ST_PixelAsCentroids`, you can retrieve a point for
    every pixel in the raster dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ST_PixelAsPoints`, you can retrieve a point geometry representing the
    upper-left corner of each pixel. The query also returns the `x` and `y` of the
    cell and the value. The following code will show you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The previous code has a two-part query. Starting after the `FROM` statement,
    the query selects the pixels as points for band `1`. The first statement performs
    a select on the results and retrieves the point geometry, and the `x`, `y`, and
    value of the cell. `ST_PixelAsPoints`, by default, does not return data for cells
    with no values. You can pass the third parameter as false to return cells with
    no values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous query is an array with a row for each cell. Each
    row contains the `x`,`y`, value, and geometry. The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ST_PixelAsCentroids`, you can get a point that represents the centroid
    of the pixel or cell. The query is identical to the previous example and is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous query is in two parts. It first executes the `ST_PixelAsCentroids`
    function and then selects the `x`,`y`, value, and geometry from that result set.
    The output is shown as follows. Notice that the points are different than in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The previously mentioned functions returned geometry for all of the pixels in
    the raster dataset. Both of these functions have a corresponding function which
    allows you to specify a single pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing the plural from centroids and points will allow you to specify single
    pixels, but will not return the `x`, `y`, and value. The following code shows
    you how to query a single pixel as a centroid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses `ST_PixelAsCentroid` and passes the raster, row, and
    column. The result is a single centroid point geometry for the cell which has
    been specified. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping the query in `ST_AsText` resulted in the output being returned in WKT.
  prefs: []
  type: TYPE_NORMAL
- en: Queries returning values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two previous sections returned information about the raster and geometries
    representing the raster data. This section will show you how to query your raster
    dataset for values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the value of a specific cell, you use `ST_Value`, which is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code passes the raster, the column, and row to `ST_Value`. Optionally,
    you can pass false if you want don''t want to return any data values. The result
    of the previous query is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The output is the value at the given cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to search for all pixels with a given value, you can use `ST_PixelOfValue`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code passes the band and the value to search for. The result of
    this query is an array of all (*x*,*y*) coordinates, where the value is `50`.
    The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For each of the coordinates shown earlier, the value is `50`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the occurrences of every value in the raster, you can query using
    `ST_ValueCount`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code passes the raster column to `ST_ValueCount`. You can specify
    a raster band by passing the band as an integer as the second parameter—`ST_ValueCount(raster,2)`
    would be band `2`. Otherwise, the default is band `1`. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The previous output contains the value and the count in the format of (value,
    count).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also query for the number of times a single value occurs in the data.
    The following code shows you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ST_ValueCount` and passing a search value (`50`), you will receive the
    number of times `50` occurs as a value in the raster, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that `50` occurs `5` times in the raster dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To return all the values in the raster data, you can use `ST_DumpValues`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code passes the raster column and the band. The results are all
    the values in the raster as an array. The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using the previous output, you can query individual cells using standard Python
    indexing notation.
  prefs: []
  type: TYPE_NORMAL
- en: The previous queries returned values from a specified cell or by using a specified
    value. The two queries that are to be followed will return values based on a point
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ST_NearestValue`, you can pass a point and get the closest pixel value
    to that point. If the raster data contained elevation values, you would be querying
    for the known elevation which is closest to the point. The following code shows
    you how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code passes the raster column and a point to `ST_NearestValue`.
    Starting from the inside out, the point parameter used `ST_MakePoint` to make
    a point from coordinates. The function is wrapped in `ST_SetSRID`. `ST_SetSRID`
    takes two parameters—a point and a spatial reference. In this case, the point
    is `ST_MakePoint`, and the spatial reference is ESPG `4326`. The result of the
    previous query is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The value of `51` is the closest value to the point. The coordinates in the
    query are the centroid of the cell (4,3) from the earlier `ST_PixelAsCentroids`
    example. In that example, the value of that point was `51`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve more than one value near a given point, you can use `ST_Neighborhood`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ST_Neighborhood` function takes the raster column, a point, and an `x`,
    `y` distance value. In the previous code, you used `ST_MakePoint` and `ST_SetSRID`
    to create the point. You then passed the point and the distances of `1` and `1`
    for the *x* and *y* distance parameter. This will return a 3x3 neighborhood, as
    shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The previous output shows that the values of the surrounding neighborhood are
    all `255`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can select vector geometry as a raster. When querying a vector
    table which contains Albuquerque Police Area Commands as polygons, the following
    code will extract a single area command as a raster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is a select statement that selects a geometry from the `areacommand` table,
    where the name is `FOOTHILLS`. The geometry portion of the query is where you
    perform the raster conversion.
  prefs: []
  type: TYPE_NORMAL
- en: '`ST_AsRaster` takes a geometry, the scale of `x`, the scale of `y`, and the
    type of pixels. The `ST_AsRaster` function is wrapped in the `ST_AsPNG` function.
    The result is a PNG file in memory view. Using standard Python file operations,
    the code opens a file, `Foothills.png`, in write binary mode, and then writes
    the memory view `c[0][0]` to disk. It then closes the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/600bda3e-5c15-45c0-9034-5f66b81197ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The image showing the foothills as a raster
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use GDAL and PostgreSQL to work with raster
    data.
  prefs: []
  type: TYPE_NORMAL
- en: First, you learned how to use the GDAL to load and query rasters. You also learned
    how to use GDAL to modify and save rasters. Then, you learned how to create your
    own raster data. You learned how to load raster data into PostgreSQL using the
    `raster2pgsql` tool. Once in PostgreSQL, you learned how to query for metadata,
    attributes, values, and geometry. You learned several common functions within
    PostgreSQL for raster data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter only scratched the surface of working with raster data, you
    should have enough knowledge now to know how to learn new techniques and methods
    for working with rasters. In the next chapter, you will learn how to work with
    vector data in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
