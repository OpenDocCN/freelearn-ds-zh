- en: 'Chapter 5: Variational Quantum Eigensolver (VQE) Algorithm'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Not only is the Universe stranger than we think, it is stranger than we can
    think.”
  prefs: []
  type: TYPE_NORMAL
- en: – Werner Heisenberg
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Steepest descent line on a potential energy surface (PES) [authors]
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the history behind the use of the variational method in *Section
    1.1, Understanding the history of quantum chemistry and mechanics*. It is a mathematical
    construct that can be used computationally. Within the context of quantum chemistry,
    the variational method is used to determine the lowest energy associated with
    an eigenvalue, either the ground state or excited states.
  prefs: []
  type: TYPE_NORMAL
- en: The **Variational Quantum Eigensolver** (**VQE**) algorithm was introduced in
    2014 [VQE_1] and is defined using quantum-based hardware. It is the first of several
    **Variational Quantum Algorithms** (**VQAs**) that are currently being explored
    by the scientific industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use **Unitary Coupled Cluster Singles and Doubles** (**UCCSD**) as a starting
    point to determine a trial wave function for the variational method as it is essential
    that the VQE ansatz is close to the true ground state to make the VQE computations
    successful. To get an accurate energy estimate of 1 milli-Hartree (mHA), the ansatz
    for the VQE must be close to the true ground state by less than one in a million
    [Troyer]. In this chapter, we will focus on calculating only the ground state
    and Born-Oppenheimer potential energy surface (BOPES) for the hydrogen (H2) and
    lithium hydride (LiH) molecules, and a macro molecule. We introduced the BOPES
    in *Section 4.1, Born-Oppenheimer approximation*. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 5.1, Variational method*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.2, Example chemical calculations*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A companion Jupyter notebook for this chapter can be downloaded from GitHub
    at [https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious](https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious),
    which has been tested in the Google Colab environment, which is free and runs
    entirely in the cloud, and in the IBM Quantum Lab environment. Please refer to
    [*Appendix B*](B18268_Appendix_B_ePub.xhtml#_idTextAnchor313) *– Leveraging Jupyter
    Notebooks in the Cloud*, for more information. The companion Jupyter notebook
    automatically installs the following list of libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Numerical Python** (**NumPy**) [NumPy], an open-source Python library that
    is used in almost every field of science and engineering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit [Qiskit], an open-source SDK for working with quantum computers at the
    level of pulses, circuits, and application modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit visualization support to enable the use of visualizations and Jupyter
    notebooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qiskit Nature [Qiskit_Nature] [Qiskit_Nat_0], a unique platform to bridge the
    gap between natural sciences and quantum simulations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python-based Simulations of Chemistry Framework** (**PySCF**) [PySCF], an
    open-source collection of electronic structure modules powered by Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quantum Toolbox in Python** (**QuTiP**) [QuTiP], a general framework for
    solving quantum mechanics problems such as systems composed of few-level quantum
    systems and harmonic oscillators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atomic Simulation Environment** (**ASE**) [ASE_0], a set of tools and Python
    modules for setting up, manipulating, running, visualizing, and analyzing atomistic
    simulations. The code is freely available under the GNU LGPL license.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyQMC [PyQMC], a Python module that implements real-space quantum Monte Carlo
    techniques. It is primarily meant to interoperate with PySCF.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: h5py [h5py] package, a Pythonic interface to the HDF5 binary data format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy [SciPy], a Python module that contains a large number of probability distributions,
    summary and frequency statistics, correlation functions and statistical tests,
    masked statistics, kernel density estimation, quasi-Monte Carlo functionality,
    and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing NumPy, Qiskit, QuTiP, and importing various modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit visualization support with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Qiskit Nature with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Install PySCF with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Install QuTiP with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install ASE with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Install PyQMC with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Install h5py with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Install SciPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Import NumPy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Import Matplotlib, a comprehensive library for creating static, animated, and
    interactive visualizations in Python, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the required functions and class methods. The `array_to_latex function()`
    returns a LaTeX representation of a complex array with dimension 1 or 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the Qiskit Nature libraries with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the Qiskit Nature property framework with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `ElectronicEnergy` property with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the `ElectronicIntegrals` property with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the Qiskit Aer state vector simulator and various algorithms with the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the PySCF gto and scf libraries with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the PyQMC API library with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Import h5py with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the ASE libraries, the `Atoms` object, molecular data, and visualizations
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the math libraries with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Import Python''s statistical functions provided by the SciPy package with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Import QuTiP with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Import time and datetime with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Import pandas and os.path with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 5.1\. Variational method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We illustrate the variational method through both classical and hybrid-quantum
    methods. We compare VQE to the variational Monte Carlo method. Further, we also
    compare the results for VQE to the **Quantum Phase Estimation** (**QPE**) algorithm,
    which is not a variational method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 5.1.1, The Rayleigh-Ritz variational theorem*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.1.2, Variational Monte Carlo methods*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.1.3, Quantum Phase Estimation (QPE)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.1.4, Description of the VQE algorithm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.1.1\. The Rayleigh-Ritz variational theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Rayleigh-Ritz variational theorem states that the expectation value of
    the Hamiltonian ![](img/Formula_05_001.png) of a system with respect to the state
    of an arbitrary wave function (![](img/Formula_05_002.png)) is always an upper
    bound to the exact ground state energy ![](img/Formula_05_003.png) of the system
    it describes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![](img/Formula_05_005.png) generally represents time, spatial, and spin
    variables. This formula is not assuming any particular chemical setup nor reference
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now give a proof of this theorem for the general Hamiltonian, which is represented
    by the discretized Hermitian operator ![](img/Formula_05_006.png) [Toulouse].
    Recall that, according to the spectral theorem introduced in *Section 2.3.1, Hermitian
    operator*, ![](img/Formula_05_007.png) must have a set of orthonormal eigenvectors
    ![](img/Formula_05_008.png) with real eigenvalues ![](img/Formula_05_009.png),
    ![](img/Formula_05_010.png) which form an orthonormal basis of the Hilbert space,
    and that ![](img/Formula_05_006.png) has a unique spectral representation in this
    basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can index the orthonormal eigenvectors of ![](img/Formula_05_006.png) in
    increasing order of energy, ![](img/Formula_05_014.png) and decompose any state
    ![](img/Formula_05_015.png) in this basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'with coefficients ![](img/Formula_05_017.png) and the normalization constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Noting that the complex conjugate transpose is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We compute the expectation value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The minimum of this expression ![](img/Formula_05_021.png) is reached for ![](img/Formula_05_022.png)
    and ![](img/Formula_05_023.png) for all ![](img/Formula_05_024.png) that is for
    ![](img/Formula_05_025.png). Hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To find the minimum, one can find the first and second derivative of the expression
    with respect to the parameters of the wave function. This setup for the variational
    theorem holds true for the electronic molecular Hamiltonian (![](img/Formula_05_027.png)).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2\. Variational Monte Carlo methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **variational Monte Carlo** (**VMC**) method is based on the Rayleigh-Ritz
    variational theorem [Chen] [Gorelov] [Toulouse_1] [Cao] [Dagrada] and Monte Carlo
    integration methods [Pease], noting that the expectation value can be rewritten
    in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We separate the integral into a probability distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and an observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which enables us to write the energy in the form of an average:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we apply an approximation to the ![](img/Formula_05_032.png) formula, which
    is called the **Metropolis-Hastings** (**MH**) algorithm [Chen] [Toulouse1]. To
    perform the approximation mathematically, we sample a set of ![](img/Formula_05_033.png)
    points ![](img/Formula_05_034.png) from the probability distribution ![](img/Formula_05_035.png)
    and we evaluate the local energy at each point ![](img/Formula_05_036.png) , hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In practice, we can use a flexible explicitly correlated wave function ![](img/Formula_05_038.png)
  prefs: []
  type: TYPE_NORMAL
- en: We now give an illustration of the MH algorithm with Python code from Ref. [Stephens].
    The MH algorithm is a **Markov chain Monte Carlo** (**MCMC**) method for producing
    samples from a probability distribution that we will call the target probability
    distribution. It works by simulating a Markov chain, whose stationary distribution
    is the target probability distribution. **Markov chain theory** is used to describe
    polymerization type reactions that are prominent in chemistry, chemical engineering,
    and in biology and medicine, such as the **polymerase chain reaction** (**PCR**)
    [Tamir].
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to sample from the following probability distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We implement the MH algorithm with a “random walk” kernel, ![](img/Formula_05_040.png),
    where ![](img/Formula_02_005.png) is the normal distribution, and the following
    acceptance probability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We plot the locations visited by the Markov chain ![](img/Formula_05_043.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.2* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Plot of the locations visited by the Markov chain ![](img/Formula_05_044.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the Freedman–Diaconis rule to select the “right” bin width to be used
    in a histogram [Bushmanov] [Freeman]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We plot the histogram of the Markov chain ![](img/Formula_05_045.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.3* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Histogram of the Markov chain ![](img/Formula_05_046.png)
  prefs: []
  type: TYPE_NORMAL
- en: We see that the histogram of values of the Markov chain ![](img/Formula_05_047.png)
    is a good approximation to the distribution ![](img/Formula_05_048.png) defined
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now define the `run_PySCF()` function, which computes the energy of the
    ground state with the PySCF RHF method and with the `OPTIMIZE` function in the
    PyQMC Python module that implements real-space variational Monte Carlo techniques
    [PyQMC]. It has the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`molecule`, the geometry of the molecule, defined with the Qiskit `Molecule`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyqmc`, set to `True` by default to run the PyQMC Python module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`, set to `True` by default to display intermediate results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the definition of the `run_PySCF()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We now present the code that is contained in this `run_PySCF()` function. First,
    we reset the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we construct a PySCF molecular geometry from the molecule passed as an
    input parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the PySCF RHF method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run the `OPTIMIZE` function in the PyQMC Python module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the content of the HDF5 file, which contains the optimized parameters,
    and if the PyQMC variational Monte Carlo computation converged, then we print
    the energy for each iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we let the `run_PySCF()` function return the following parameters
    to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`conv`, `Boolean`, set to `True` if the PySCF RHF method converged'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`e`, the energy of the ground state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the `return` statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 5.1.3\. Quantum Phase Estimation (QPE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In quantum chemistry, we need very accurate calculations of the total electronic
    energy of each molecule species involved in a chemical reaction [Burg]. The **Quantum
    Phase Estimation** (**QPE**) algorithm has a unique feature that it allows a bounded-error
    simulation of quantum systems, which makes it one of the most promising applications
    of future fault-tolerant quantum computing. Given a unitary operator ![](img/Formula_05_049.png),
    its eigenstate and eigenvalues, ![](img/Formula_05_050.png), the ability to prepare
    a state ![](img/Formula_05_051.png), and the ability to apply ![](img/Formula_05_052.png)
    itself, the QPE algorithm calculates ![](img/Formula_05_053.png), where ![](img/Formula_02_247.png)
    is the number of qubits used to estimate ![](img/Formula_05_055.png) thereby allowing
    measurement of ![](img/Formula_05_055.png) as precisely as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in *Section 2.5, Postulate 5 – Time evolution dynamics*, we saw
    that time evolution dynamics of a quantum system is described by Schrödinger''s
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a time-independent Hamiltonian ![](img/Formula_05_058.png) with initial
    condition ![](img/Formula_05_059.png), the solution is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![](img/Formula_05_061.png) is the unitary time-evolution operator. Further
    recall that any unitary matrix has eigenvalues of the form ![](img/Formula_05_062.png).
    An eigenvalue of ![](img/Formula_05_063.png) is also an eigenvalue of ![](img/Formula_05_064.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now illustrate the use of the Qiskit `PhaseEstimation` class. First, we
    define a function ![](img/Formula_05_065.png), which creates a quantum circuit
    with a single qubit ![](img/Formula_05_066.png) and applies the following unitary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_05_068.png) is the gate we introduced in *Section 3.2.1,
    Single qubit quantum gates*, which has the matrix form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `do_qpe()` function, which illustrates the use of the Qiskit
    Nature `PhaseEstimation` class, and which has three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unitary`, a function that implements a unitary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nqubits`, the number of qubits, by default `3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`, set to `True` by default to display the phase returned by `PhaseEstimation`
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we run a test of accuracy with three qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run a test of accuracy with eight qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We see that we can get an estimate of the phase with a bounded error from the
    true phase by increasing the number of qubits that the `PhaseEstimation` class
    is allowed to use.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.4\. Description of the VQE algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a loop, a classical computer optimizes the parameters of a quantum circuit
    with respect to an objective function, such as finding the ground state of a molecule,
    which is the state with the lowest energy. The parameterized quantum circuit prepares
    a trial quantum state as a trial solution (an ansatz). By repeatedly measuring
    qubits at the output of the quantum circuit, we get the expectation value of the
    energy observable with respect to the trial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The VQE algorithm provides an estimate of the ground state of a given quantum
    system encoded as a Hamiltonian ![](img/Formula_05_070.png), the state of the
    system with the lowest energy ![](img/Formula_05_071.png), for instance, the ground
    state energy of a molecule. It involves an iterative minimization of the expectation
    value ![](img/Formula_05_072.png) of the energy observable with respect to the
    parametrized (![](img/Formula_05_073.png)) trial state ![](img/Formula_05_074.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in *Section 3.1.6, Pauli matrices*, we can decompose the Hamiltonian
    ![](img/Formula_05_006.png) into the weighted sum of ![](img/Formula_05_077.png)
    tensor products ![](img/Formula_05_078.png), where ![](img/Formula_05_079.png)
    with weights ![](img/Formula_05_080.png) and ![](img/Formula_05_081.png) qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hence the expectation value of the energy observable ![](img/Formula_05_083.png)
    can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_084.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We prepare a trial state ![](img/Formula_05_085.png) with the set of parameters
    ![](img/Formula_05_086.png) with a quantum circuit initialized in the state ![](img/Formula_05_087.png),
    and represented by ![](img/Formula_05_088.png), which outputs the state ![](img/Formula_05_089.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'By transposing the complex conjugate, ![](img/Formula_05_090.png), we can rewrite
    the expectation value of the energy observable ![](img/Formula_05_091.png) as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and then by taking the sum out to the front:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_093.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For each ![](img/Formula_05_094.png) we run the quantum circuit ![](img/Formula_05_095.png)
    followed by rotations ![](img/Formula_05_096.png) depending on ![](img/Formula_05_097.png)
    before measuring the qubits in the Z basis so that we effectively measure the
    output state in the basis of the eigenvectors of ![](img/Formula_05_098.png) to
    get the expectation value ![](img/Formula_05_099.png) with respect to the output
    state ![](img/Formula_05_100.png).
  prefs: []
  type: TYPE_NORMAL
- en: On a classical computer, we compute the weighted sum of the expectation values
    ![](img/Formula_05_101.png) with weights ![](img/Formula_02_417.png) to get the
    expectation value ![](img/Formula_05_103.png) with respect to the output state
    ![](img/Formula_05_104.png). We update the set of parameters ![](img/Formula_05_105.png)
    using a classical optimization routine, minimizing the expectation value ![](img/Formula_05_106.png)
    until convergence in the value of the energy or the maximum allowable number of
    iterations is reached. The parameters ![](img/Formula_05_107.png) at convergence
    define approximately the ground state ![](img/Formula_05_108.png) of the quantum
    system encoded into a Hamiltonian ![](img/Formula_05_109.png) with the lowest
    energy ![](img/Formula_05_110.png). The algorithm is summarized in *Figure 5.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – VQE algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Trial wave functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Coupled-Cluster** (**CC**) theory constructs a multi-electron wave function
    (![](img/Formula_05_111.png)) using the exponential cluster operator ![](img/Formula_05_112.png),
    where ![](img/Formula_05_113.png) is the operator for all single excitations,
    ![](img/Formula_05_114.png) is the operator for all double excitations, and so
    on. We start the VQE with the following **unitary Coupled-Cluster** (**UCC**)
    ansatz of the quantum state ![](img/Formula_05_115.png) with variational parameter
    ![](img/Formula_05_116.png) [Panagiotis] [Lolur]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where ![](img/Formula_05_118.png) is the Hartree-Fock ground state. In the
    UCC method restricted to the extension to single and double excitations (UCCSD),
    the operators ![](img/Formula_05_119.png) and ![](img/Formula_05_120.png) can
    be expanded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_121.jpg)![](img/Formula_05_122.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_05_123.png) is the fermionic creation operator introduced in
    *Section 4.3.1, Fermion creation operator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_05_124.png) is the fermionic annihilation operator introduced
    in Section *4.3.2, Fermion annihilation operator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Formula_05_125.png) is the set of parameters for all expansion coefficients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UCCSD ansatz of the quantum state ![](img/Formula_05_126.png) is then mapped
    to qubit operators with the Jordan-Wigner (JW), the Parity, or the Bravyi-Kitaev
    (BK) transformation introduced in *Section 4.7, Fermion to qubit mappings,* resulting
    in an initial qubit state vector for the VQE calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the VQE solver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We set up a noise-free simulation with the Qiskit Aer state vector simulator
    backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we set up solving methods. To learn how to train circuit-based variational
    models, check Ref. [Qiskit_2021_Lab4]. First, we set up the NumPy minimum eigensolver
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the Two-Local circuit [Panagiotis] as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up the VQE using a heuristic ansatz, the Two-Local circuit with the
    default **Sequential Least Squares Programming (SLSQP)** optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we set up a solver with the **Unitary Coupled Cluster** (**UCC**) factory.
    It allows a fast initialization of a VQE initializing the qubits in the Hartree-Fock
    state and using the quantum UCC with singles and doubles (q-UCCSD), a popular
    wave function ansatz [VQE_2] [VQE_3]. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up a callback function, `qnspsa_callback()`, for the `qnspsa_loss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to show some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. Example chemical calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 4*](B18268_04_ePub.xhtml#_idTextAnchor153)*, Molecular
    Hamiltonians*, approximating the PES of nuclear motion occurs due to the use of
    the BO approximation. We can use a semi-empirical method of approximating the
    PES through experimental data and/or computer simulations.
  prefs: []
  type: TYPE_NORMAL
- en: The PES can be compared to a landscape with mountains and valleys. In practice,
    as chemists, we want to find the global minimum (ocean floor) not local minima
    (mountain meadows) of the PES, as seen in *Figure 5.1*. We use the variational
    method, both classical and quantum, to find the global minimum. This can be compared
    to a ball rolling around the landscape. If we give the ball a nudge in some direction,
    generally downward, the ball will wind up in the minimum. We call this gradient
    descent. The gradient descent can be supplied by numerically changing input values
    or by an analytic formula of the wave function that describes the PES.
  prefs: []
  type: TYPE_NORMAL
- en: To state that calculation of determining the PES we guess a trial wave function,
    which can be optimized in the calculation to enable us to find the global minimum
    of the energy. We call this global minimum the lowest energy possible for a given
    eigenvalue.
  prefs: []
  type: TYPE_NORMAL
- en: We present several implementations of solving for the ground state and plotting
    the BOPES of three molecules with the classical PySCF RHF, PyQMC variational Monte
    Carlo, the QPE, and the VQE with Qiskit Nature using the STO-3G basis with the
    PySCF driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Section 5.2.1, Hydrogen molecule*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.2.2, Lithium hydride molecule*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Section 5.2.3, Macro molecule*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `get_particle_number()` function defined in *Section 4.6.1, Constructing
    a fermionic Hamiltonian operator of the hydrogen molecule*, which gets the particle
    number property of a given electronic structure problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `fermion_to_qubit()` function defined in *Section 4.8, Constructing
    a qubit Hamiltonian with Qiskit Nature,* to convert a fermionic operator to a
    qubit operator. It has the following input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f_op`, a fermionic operator obtained as explained in *Section 4.6, Constructing
    a fermionic Hamiltonian with Qiskit Nature*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapper`, either `“Jordan-Wigner”` or `“Parity”` or `“Bravyi-Kitaev”`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`truncate`, an integer to truncate Pauli list by default set to 20 items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two_qubit_reduction`, a Boolean, by default `False`, that determines whether
    to carry out two-qubit reduction when possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z2symmetry_reduction`, by default `None`, that indicates whether a Z2 symmetry
    reduction should be applied to resulting qubit operators that are computed based
    on mathematical symmetries that can be detected in the operator [de Keijzer]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`, set to `True` by default to display the name of the transformation
    and results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qiskit Nature provides a class called `GroundStateEigensolver` to calculate
    the ground state of a molecule. We define the `run_vqe()` function, which has
    the following input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`, a string of characters to be printed, such as `''NumPy exact solver''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f_op`, a fermionic operator obtained as explained in *Section 4, Constructing
    a fermionic Hamiltonian with Qiskit Nature*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qubit_converter`, either `JordanWignerMapper()`, `ParityMapper()`, or `BravyiKitaevMapper()`,
    which is the output of the `fermion_to_qubit()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`solver`, either one of the solvers defined in *Section 5.2.3, Setting up the
    VQE solver*, `numpy_solver`, `vqe_ucc_solver`, or `vqe_tl_solver`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `run_qpe()` function to perform a quantum phase estimation and
    return an eigenvalue of a Hamiltonian as an estimation of the electronic ground
    state energy. It has the following input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`particle_number`, the property returned by the `get_particle_number()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qubit_converter`, either `JordanWignerMapper()`, `ParityMapper()`, or `BravyiKitaevMapper()`,
    which is the output of the `fermion_to_qubit()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qubit_op`, a qubit Hamiltonian operator returned the `fermion_to_qubit()`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_ancillae`, an integer that defaults to `3`, which is the number of ancillae
    qubits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_time_slices`, an integer that defaults to `1`, which is the number of
    `PauliTrotterEvolution` class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`, set to `True` by default to display intermediate results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `plot_energy_landscape()` function to plot the energy as a function
    of atomic separation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `plot_loss()` function, which accepts the following input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loss`, an array of floats, optional, generated by the callback function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`, a character string to be displayed by the `plot_loss()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`, a float to be displayed by the `plot_loss()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define the `solve_ground_state()` function, which solves for a ground
    state. It accepts as input the following parameters, which define the geometry
    of the molecule:'
  prefs: []
  type: TYPE_NORMAL
- en: '`molecule`, the geometry of the molecule, and the output of the `Molecule`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapper`, either `“Jordan-Wigner”` or `“Parity”` or `“Bravyi-Kitaev”`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_electrons`, an integer, optional, number of electrons for the `ActiveSpaceTransformer`.
    Defaults to `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_molecular_orbitals`, an integer, optional, number of electron orbitals
    for `ActiveSpaceTransformer`. Defaults to `2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list of input parameters control the whole process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transformers`, an optional list of transformers. For example, for lithium
    hydride, we will use the following: `transformers=[FreezeCoreTransformer(freeze_core=True,
    remove_orbitals=[4, 3])]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`two_qubit_reduction`, a Boolean, by default `False`. It determines whether
    to carry out two-qubit reduction when possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z2symmetry_reduction`, by default `None`, this indicates whether a Z2 symmetry
    reduction should be applied to resulting qubit operators that are computed based
    on mathematical symmetries that can be detected in the operator [de Keijzer].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name_solver`, the name of the solver, which defaults to `''NumPy exact solver''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`solver`, either one of the solvers defined in Section *5.2.3, Setting up the
    VQE solver*, `numpy_solver`, `vqe_ucc_solver`, or `vqe_tl_solver`. It defaults
    to `NumPyMinimumEigensolver()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plot_bopes`, a Boolean, set to `True` to compute and plot the BOPES of the
    molecule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perturbation_steps`, the points along the degrees of freedom to evaluate,
    in this case a distance in angstroms. It defaults to `np.linspace(-1, 1, 3)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pyqmc`, set to `True` by default to run the PyQMC Python module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n_ancillae`, an integer that defaults to `3` that represents the number of
    ancillae qubits used by the `run_qpe()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_time_slices`, an integer that defaults to `1`, which is number of `PauliTrotterEvolution`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loss`, an optional array of floats that is generated by the callback function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`, a character string to be displayed by the `plot_loss()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`target`, a float to be displayed by the `plot_loss()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`, set to `True` by default to display intermediate results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the definition of the `solve_ground_state()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We now present the code that is contained in the `solve_ground_state()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the electronic structure molecule driver by selecting the PySCF
    driver type and the basis set `sto3g` in which the molecular orbitals are to be
    expanded into. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if both `num_electrons` and `num_molecular_orbitals` are specified, we
    call the `ActiveSpaceTransformer` function to split the computation into a classical
    and a quantum part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an `ElectronicStructureProblem` that produces the list of fermionic
    operators as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use the `second_q_ops()` method [Qiskit_Nat_3], which returns a list
    of second quantized operators: Hamiltonian operator, total particle number operator,
    total angular momentum operator, total magnetization operator, and if available,
    ![](img/Formula_05_045.png), ![](img/Formula_05_128.png), ![](img/Formula_05_129.png)
    dipole operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the particle number property of the molecule by calling the `particle_number()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If the input parameter `show` is set to `True`, we set truncation to `1000`
    with the `set_truncation(1000)` method and then we print the fermionic Hamiltonian
    operator of the molecule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `fermion_to_qubit()` function defined in *Section 4.8, Constructing
    a qubit Hamiltonian with Qiskit Nature,* to convert a fermionic operator to a
    qubit operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we call the `run_PySCF()` function that we defined earlier to run the
    PySCF RHF method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we call the `run_qpe()` function to perform a QPE and return the most
    likely eigenvalue of a Hamiltonian as an estimation of the electronic ground state
    energy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `run_vqe()` function defined earlier to solve for the ground
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `loss` parameter is not an empty array, we call the `plot_loss()` function
    to plot the evolution of the loss as a function of the number of iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, if the `plot_bopes` parameter is set to `True`, we use the `BOPESSampler`
    Python class [Qiskit_Nat_6], which manages the process of varying the geometry
    and repeatedly calling the ground state solver, and then we get and plot the BOPES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we let the `solve_ground_state()` function return the following parameters
    to the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fermionic hamiltonian`, the Fermionic Hamiltonian operator of the molecule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`particle number`, the particle number property of the molecule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qubit_op`, the qubit Hamiltonian operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qubit_converter`, either `JordanWignerMapper()`, `ParityMapper()`, or `BravyiKitaevMapper()`,
    which is the output of the `fermion_to_qubit()` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ground_state`, the ground state of the molecule, if convergence has been achieved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'with the following `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We now illustrate how to use the `solve_ground_state()` function with different
    molecules, different mappers, and different classical solvers.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1\. Hydrogen molecule (H2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We follow the process described in *Section 4.6.1, Constructing a fermionic
    Hamiltonian operator of the hydrogen molecule*. First, we define the geometry
    of the hydrogen molecule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We showed the particle number property of the hydrogen molecule in *Figure 4.9*
    in *Section 4.6.1, Constructing a fermionic Hamiltonian operator of the hydrogen
    molecule,* where we see four **spin orbitals** (**SOs**), one ![](img/Formula_05_130.png)
    electron, and one ![](img/Formula_05_131.png) electron.
  prefs: []
  type: TYPE_NORMAL
- en: We showed the fermionic Hamiltonian operator of the hydrogen molecule in *Figure
    4.13* in *Section 4.6.1, Constructing a fermionic Hamiltonian operator of the
    hydrogen molecule*.
  prefs: []
  type: TYPE_NORMAL
- en: Varying the hydrogen molecule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We specify the type of molecular variation, `Molecule.absolute_stretching`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify that the first atom of the specified atom pair is moved closer to
    the second atom. The numbers refer to the index of the atom in the geometric definition
    list. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We alter the original molecular definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now we proceed with solving for the ground state.
  prefs: []
  type: TYPE_NORMAL
- en: Solving for the ground state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now run VQE using the NumPy exact minimum eigensolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.5* shows the results of the computation by the `run_PySCF()` and
    `run_QPE()`functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Ground-state of the H2 molecule with PySCF RHF, PyQMC Monte Carlo,
    and QPE
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.6* shows the result of the VQE computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Ground-state of the H2 molecule with VQE using the NumPy minimum
    eigensolver
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we run the VQE using the UCC factory ansatz [VQE_2] [VQE_3]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.7* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Ground-state of the H2 molecule with VQE using the UCC factory
    ansatz
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we run the VQE using a heuristic ansatz, the Two-Local circuit with the
    default SLSQP optimizer [Panagiotis]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.8* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Ground-state of the H2 molecule with VQE using the Two-Local circuit
    and SLSQP
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `qnspsa()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code that sets up the VQE using a heuristic ansatz and the QN-SPSA
    optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we call `solve_ground_state()` with the heuristic ansatz and the QN-SPSA
    optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.9* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Ground-state of the H2 molecule with VQE using the Two-Local circuit
    and QN-SPSA
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.10* shows the plot of the loss function of the QN-SPSA optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Plot of the loss function of the VQE using the Two-Local circuit
    and QN-SPSA for the H2 molecule
  prefs: []
  type: TYPE_NORMAL
- en: The table shown in *Figure 5.11* summarizes calculations obtained with the Python
    packages PySCF RHF, PyQMC, and with the Qiskit Nature classes, VQE with NumPy
    exact solver, SLSQP, QN-SPSA, and QPE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Table summarizing the calculations of the ground state energy
    obtained with the H2 molecule
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.11* shows close agreement between the different calculations of the
    electronic ground state and the total ground state energies with the same qubit
    mapper called the `ParityMapper()` with `two_qubit_reduction=True`. The PyQMC
    method gives the lowest total energy -1.162 Ha and is the most accurate. It is
    consistent with the result -1.168 Ha shown in Ref. [Ebomwonyi].'
  prefs: []
  type: TYPE_NORMAL
- en: Computing the BOPES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now compute and plot the BOPES of the hydrogen molecule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.12* shows the plot of the BOPES of the hydrogen molecule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Plot of the BOPES of the hydrogen molecule
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2\. Lithium hydride molecule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We follow the process described in *Section 4.6.2, Constructing a fermionic
    Hamiltonian operator of the lithium hydride molecule*. First, we define the geometry
    of the lithium hydride (LiH) molecule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We showed the particle number property in *Figure 4.17* in *Section 4.6.2, Constructing
    a fermionic Hamiltonian operator of the lithium hydride molecule*, where we see
    six SOs, one ![](img/Formula_05_132.png) electron, and one ![](img/Formula_05_133.png)
    electron. We showed the fermionic Hamiltonian operator of the lithium hydride
    molecule in *Figure 4.20* in *Section 4.6.2, Constructing a fermionic Hamiltonian
    operator of the lithium hydride molecule*.
  prefs: []
  type: TYPE_NORMAL
- en: Varying the lithium hydride molecule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We alter the original molecular definition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Solving for the ground state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We run VQE using the NumPy exact minimum eigensolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.13* shows the result of the computation by the `run_PySCF()` and
    `run_QPE()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Ground state of the LiH molecule with PySCF RHF, PyQMC Monte Carlo,
    and QPE
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.14* shows the result of the VQE computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Ground state of the LiH molecule with VQE using the NumPy minimum
    eigensolver
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the VQE using the Two-Local circuit and SLSQP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.15* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Ground state of the LiH molecule with VQE using the Two-Local
    circuit and SLSQP
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `qnspsa()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code that sets up the VQE using a heuristic ansatz and the QN-SPSA
    optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we call `solve_ground_state()` with the heuristic ansatz and the QN-SPSA
    optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.16* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Ground state of the LiH molecule with VQE using the Two-Local
    circuit and QN-SPSA
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.17* shows the plot of the loss function of the QN-SPSA optimizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Loss function of the VQE using the Two-Local circuit and QN-SPSA
    for the LiH molecule
  prefs: []
  type: TYPE_NORMAL
- en: 'The table shown in *Figure 5.18* summarizes calculations obtained with the
    Python packages PySCF RHF, PyQMC, and with the Qiskit Nature classes, VQE with
    the NumPy exact solver, SLSQP, QN-SPSA, and QPE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Table summarizing the calculations of the ground state energy
    obtained with the LiH molecule
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.18* shows close agreement between the different calculations of the
    electronic ground state and the total ground state energies. The PyQMC method
    gives the lowest total energy -8.102 Ha and is the most accurate. It is consistent
    with the result -8.07 Ha shown in Ref. [Adamowicz_3].'
  prefs: []
  type: TYPE_NORMAL
- en: Computing the BOPES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now compute and plot the BOPES of the lithium hydride molecule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.19* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Plot of the BOPES of the LiH molecule
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.3\. Macro molecule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now explore the HIV use case of the IBM Quantum Challenge Africa 2021, Quantum
    Chemistry for HIV [Africa21]. In their challenge they aimed to determine whether
    a toy model of an anti-retroviral molecule can bind with a toy model of a protease
    molecule. Since the anti-retroviral molecule has many atoms, it is approximated
    by using a single carbon atom. The toy model of the protease molecule is represented
    by a component of the formamide molecule (HCONH2); particularly it is the carbon-oxygen-nitrogen
    part of the formamide molecule. In short, the experiment is to determine whether
    a single carbon atom, can bind to the carbon-oxygen-nitrogen component of the
    formamide molecule. We will get the answer to the question posed by IBM by plotting
    the BOPES of a macro molecule, which is the formamide molecule plus the carbon
    atom.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the macro molecule with the ASE `Atoms` object [ASE_1]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we display a 3D view of the molecule with the ASE viewer X3D for Jupyter
    notebooks [ASE2]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.20* shows the result. The nitrogen atom is depicted on the left side
    in blue, the oxygen atom on the right side in red, the carbon atoms in the middle
    in gray, and the three hydrogen atoms are the smallest ones in light gray. The
    carbon atom on the top is not bound to the other atoms.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Macro molecule
  prefs: []
  type: TYPE_NORMAL
- en: 'We specify the type of molecular variation, `Molecule.absolute_stretching`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We specify which atoms the variation applies to. The numbers refer to the index
    of the atom in the geometric definition list. The single carbon atom is moved
    closer to the nitrogen atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the molecular geometry of the macro molecule with the Qiskit `Molecule`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Now we can solve for the ground state.
  prefs: []
  type: TYPE_NORMAL
- en: Solving for the ground state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We reduce the quantum workload by specifying that certain electrons should
    be treated with a quantum computing algorithm, while the remaining electrons should
    be classically approximated with the Qiskit `ActiveSpaceTransformer` class, which
    takes in two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`num_electrons`, the number of electrons selected from the outermost electrons,
    counting inwards, to be treated with a quantum computing algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_molecular_orbitals`, the number of orbitals to allow those electrons to
    roam over (around the so-called Fermi level). It determines how many qubits are
    needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We print the selection of parameters of the VQE run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run the VQE using the NumPy exact minimum eigensolver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.21* shows the first 20 terms of the fermionic operator of the macro
    molecule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – First 20 terms of the fermionic Hamiltonian operator of the macro
    molecule
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.22* shows the qubit Hamiltonian operator for the outermost two electrons
    of the macro molecule obtained with the parity transformation. Only two qubits
    are needed as expected for a parity mapping of the fermionic Hamiltonian operator
    to the qubit Hamiltonian operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Qubit Hamiltonian operator of the outermost two electrons of the
    macro molecule
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.23* shows the total ground state energy of the molecule computed
    by the PySCF RHF Python package and an estimation of the electronic ground state
    energy of the outermost two electrons of the molecule computed by the Qiskit Nature
    QPE class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Total and electronic ground state energy of the macro molecule
    by PySCF and QPE respectively
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.24* shows the result of VQE computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Ground state of macro molecule using the NumPy exact minimum eigensolver
  prefs: []
  type: TYPE_NORMAL
- en: The electronic ground state energy of the outermost two electrons of the macromolecule
    computed by the QPE, ![](img/Formula_05_134.png) (Hartree), and by the VQE, ![](img/Formula_05_135.png),
    Qiskit Nature classes are in good agreement.
  prefs: []
  type: TYPE_NORMAL
- en: The total ground state energy of the macro molecule computed by the PySCF RHF
    Python package, ![](img/Formula_05_136.png) (Hartree), and by the Qiskit Nature
    VQE class, ![](img/Formula_05_137.png), are in good agreement.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the BOPES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now compute and plot the BOPES of the macro molecule as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 5.25* shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18268_Figure_5.25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Plot of the BOPES of the macro molecule
  prefs: []
  type: TYPE_NORMAL
- en: The plot of the BOPES of the macro molecule shows no clear minimum for any separation.
    We conclude that there is no binding of the single carbon atom to the toy protease
    molecule of formamide.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced classical and hybrid classical-quantum variational
    methods to find the lowest energy eigenvalue for a quantum system and their implementation
    with a classical PyQMC variational Monte Carlo Python package, which interoperates
    with the PySCF, and Qiskit Nature using the STO-3G basis with the Python-based
    PySCF driver.
  prefs: []
  type: TYPE_NORMAL
- en: We have illustrated these methods, solving for the ground state and plotting
    the BOPES of the hydrogen molecule, the lithium hydride molecule, and the macro
    molecule.
  prefs: []
  type: TYPE_NORMAL
- en: The results we obtained with Qiskit Nature VQE and QPE are in good agreement
    with those obtained with the PyQMC and PySCF RHF packages for several combinations
    of fermionic-to-qubit Hamiltonian mappers and classical gradient descent solvers
    and by reducing the quantum workload to the outermost two electrons of the formamide
    molecule. We hope these results will encourage the reader to replay these experiments
    with different choices of solvers and with other molecules.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please test your understanding of the concepts presented in this chapter with
    the corresponding Google Colab notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the variational theorem apply to excited states?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: The Metropolis-Hastings method is a way to approximate integration
    over spatial coordinates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: VQE is only a quantum computing algorithm and does not require
    the use of classical computing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[ASE_0] Atomic Simulation Environment (ASE), [https://wiki.fysik.dtu.dk/ase/index.html](https://wiki.fysik.dtu.dk/ase/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ASE_1] ASE, The Atoms object, [https://wiki.fysik.dtu.dk/ase/ase/atoms.html](https://wiki.fysik.dtu.dk/ase/ase/atoms.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ASE_2] ASE Visualization, [https://wiki.fysik.dtu.dk/ase/ase/visualize/visualize.html#module-ase.visualize](https://wiki.fysik.dtu.dk/ase/ase/visualize/visualize.html#module-ase.visualize)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Adamowicz_3] Tung WC, Pavanello M, Adamowicz L., Very accurate potential energy
    curve of the LiH molecule. TABLE I. Comparison of the convergence of the BO energy,
    in Eh, for the ground state of LiH molecule at R = 3.015 bohrs, J Chem Phys. 2011
    Feb 14;134(6):064117\. doi: 10.1063/1.3554211, [https://doi.org/10.1063/1.3554211](https://doi.org/10.1063/1.3554211)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Africa21] IBM Quantum Challenge Africa 2021, [https://github.com/qiskit-community/ibm-quantum-challenge-africa-2021](https://github.com/qiskit-community/ibm-quantum-challenge-africa-2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Burg] Vera von Burg, Guang Hao Low, Thomas Häner, Damian S. Steiger, Markus
    Reiher, Martin Roetteler, Matthias Troyer, Quantum computing enhanced computational
    catalysis, 3 Mar 2021, 10.1103/PhysRevResearch.3.033055, [https://arxiv.org/abs/2007.14460](https://arxiv.org/abs/2007.14460)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bushmanov] Sergey Bushmanov, How to plot a histogram using Matplotlib in Python
    with a list of data?, Stack Overflow, [https://stackoverflow.com/questions/33203645/how-to-plot-a-histogram-using-matplotlib-in-python-with-a-list-of-data](https://stackoverflow.com/questions/33203645/how-to-plot-a-histogram-using-matplotlib-in-python-with-a-list-of-data)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Cao] Yudong Cao, Jonathan Romero, Jonathan P. Olson, Matthias Degroote, Peter
    D. Johnson, Mária Kieferová, Ian D. Kivlichan, Tim Menke, Borja Peropadre, Nicolas
    P. D. Sawaya, Sukin Sim, Libor Veis, Alán Aspuru-Guzik, Quantum Chemistry in the
    Age of Quantum Computing, Chem. Rev. 2019, 119, 19, 10856–10915, Aug 30, 2019,
    [https://doi.org/10.1021/acs.chemrev.8b00803](https://doi.org/10.1021/acs.chemrev.8b00803)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chen] Sija Chen, Quantum Monte Carlo Methods, Maplesoft, [https://fr.maplesoft.com/Applications/Detail.aspx?id=154748](https://fr.maplesoft.com/Applications/Detail.aspx?id=154748)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dagrada] Mario Dagrada, Improved quantum Monte Carlo simulations: from open
    to extended systems, Materials Science [cond-mat.mtrl-sci]. Université Pierre
    et Marie Curie - Paris VI; Universidad Nacional de San Martín, 2016\. English.
    ⟨NNT: 2016PA066349⟩. ⟨tel-01478313⟩, [https://tel.archives-ouvertes.fr/tel-01478313/document](https://tel.archives-ouvertes.fr/tel-01478313/document)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ebomwonyi] Ebomwonyi, Osarodion, A Quantum Monte Carlo Calculation of the
    Ground State Energy for the Hydrogen Molecule Using the CASINO Code, 2013, Table
    3.1: Comparative analysis of the ground state energies for the hydrogen molecule
    by different researchers, https://www.semanticscholar.org/paper/A-Quantum-Monte-Carlo-Calculation-of-the-Ground-for-Ebomwonyi/5316eb86f39cf4fa0a8fd06d136aac4db1105ad4'
  prefs: []
  type: TYPE_NORMAL
- en: '[Freeman] Freedman–Diaconis rule, Wikipedia, [https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule](https://en.wikipedia.org/wiki/Freedman%E2%80%93Diaconis_rule)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gorelov] Vitaly Gorelov, Quantum Monte Carlo methods for electronic structure
    calculations: application to hydrogen at extreme conditions, 1.4.1 Variational
    Monte Carlo (VMC), [https://tel.archives-ouvertes.fr/tel-03045954/document](https://tel.archives-ouvertes.fr/tel-03045954/document)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Grok] Grok the Bloch Sphere, [https://javafxpert.github.io/grok-bloch/](https://javafxpert.github.io/grok-bloch/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[H5py] Quick Start Guide, [https://docs.h5py.org/en/stable/quick.html](https://docs.h5py.org/en/stable/quick.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_CEO] IBM CEO: Quantum computing will take off ''like a rocket ship'' this
    decade, Fast Company, Sept 28, 2021., [https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade](https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_comp1] Welcome to IBM Quantum Composer, [https://quantum-computing.ibm.com/composer/docs/iqx/](https://quantum-computing.ibm.com/composer/docs/iqx/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[IBM_comp2] IBM Quantum Composer, [https://quantum-computing.ibm.com/composer/files/new](https://quantum-computing.ibm.com/composer/files/new)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Lolur] Lolur, Phalgun, Magnus Rahm, Marcus Skogh, Laura García-Álvarez and
    Göran Wendin, Benchmarking the Variational Quantum Eigensolver through Simulation
    of the Ground State Energy of Prebiotic Molecules on High-Performance Computers,
    arXiv:2010.13578v2 [quant-ph], 5 Jan 2021, [https://arxiv.org/pdf/2010.13578.pdf](https://arxiv.org/pdf/2010.13578.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy] NumPy: the absolute basics for beginners, [https://numpy.org/doc/stable/user/absolute_beginners.html](https://numpy.org/doc/stable/user/absolute_beginners.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Panagiotis] Panagiotis Kl. Barkoutsos, Jerome F. Gonthier, Igor Sokolov, Nikolaj
    Moll, Gian Salis, Andreas Fuhrer, Marc Ganzhorn, Daniel J. Egger, Matthias Troyer,
    Antonio Mezzacapo, Stefan Filipp, Ivano Tavernelli, Quantum algorithms for electronic
    structure calculations: Particle-hole Hamiltonian and optimized wave-function
    expansions, Phys. Rev. A 98, 022322 – Published 20 August 2018, DOI: 10.1103/PhysRevA.98.022322,
    https://link.aps.org/doi/10.1103/PhysRevA.98.022322, [https://arxiv.org/abs/1805.04340](https://arxiv.org/abs/1805.04340)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pease] Christopher Pease, An Overview of Monte Carlo Methods, Towards Data
    Science, [https://towardsdatascience.com/an-overview-of-monte-carlo-methods-675384eb1694](https://towardsdatascience.com/an-overview-of-monte-carlo-methods-675384eb1694)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PyQMC] PyQMC, a python module that implements real-space quantum Monte Carlo
    techniques, [https://github.com/WagnerGroup/pyqmc](https://github.com/WagnerGroup/pyqmc)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PySCF] The Python-based Simulations of Chemistry Framework (PySCF), [https://pyscf.org/](https://pyscf.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit] Qiskit, [https://qiskit.org/](https://qiskit.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_2021_Lab4] Julien Gacon, Lab 4: Introduction to Training Quantum Circuits,
    Qiskit Summer School 2021, [https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits](https://learn.qiskit.org/summer-school/2021/lab4-introduction-training-quantum-circuits)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nat_0] Qiskit_Nature, [https://github.com/Qiskit/qiskit-nature/blob/main/README.md](https://github.com/Qiskit/qiskit-nature/blob/main/README.md)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nat_3] ElectronicStructureProblem.second_q_ops, [https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html](https://qiskit.org/documentation/nature/stubs/qiskit_nature.problems.second_quantization.ElectronicStructureProblem.second_q_ops.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nat_4] QubitConverter, [https://qiskit.org/documentation/nature/stubs/qiskit_nature.converters.second_quantization.QubitConverter.html](https://qiskit.org/documentation/nature/stubs/qiskit_nature.converters.second_quantization.QubitConverter.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nat_5] Qiskit Nature Tutorials, Electronic structure, [https://qiskit.org/documentation/nature/tutorials/01_electronic_structure.html](https://qiskit.org/documentation/nature/tutorials/01_electronic_structure.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nat_6] Qiskit Nature Tutorials, Sampling the potential energy surface,
    [https://qiskit.org/documentation/nature/_modules/qiskit_nature/algorithms/pes_samplers/bopes_sampler.html](https://qiskit.org/documentation/nature/_modules/qiskit_nature/algorithms/pes_samplers/bopes_sampler.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Qiskit_Nature] Introducing Qiskit Nature, Qiskit, Medium, April 6, 2021, [https://medium.com/qiskit/introducing-qiskit-nature-cb9e588bb004](https://medium.com/qiskit/introducing-qiskit-nature-cb9e588bb004)'
  prefs: []
  type: TYPE_NORMAL
- en: '[QuTiP] QuTiP, Plotting on the Bloch Sphere, [https://qutip.org/docs/latest/guide/guide-bloch.html](https://qutip.org/docs/latest/guide/guide-bloch.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[SciPy] Statistical functions (scipy.stats), [https://docs.scipy.org/doc/scipy/getting_started.html](https://docs.scipy.org/doc/scipy/getting_started.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Stephens] Matthew Stephens, The Metropolis Hastings Algorithm, [https://stephens999.github.io/fiveMinuteStats/MH_intro.html](https://stephens999.github.io/fiveMinuteStats/MH_intro.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Toulouse] Julien Toulouse, Introduction to quantum chemistry, Jan 20, 2021,
    [https://www.lct.jussieu.fr/pagesperso/toulouse/enseignement/introduction_qc.pdf](https://www.lct.jussieu.fr/pagesperso/toulouse/enseignement/introduction_qc.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tamir] Abraham Tamir, Applications of Markov Chains in Chemical Engineering,
    Elsevier, 1998, 9780080527390, 0080527396, [https://www.google.fr/books/edition/Applications_of_Markov_Chains_in_Chemica/X0ivOmHYPoYC](https://www.google.fr/books/edition/Applications_of_Markov_Chains_in_Chemica/X0ivOmHYPoYC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Toulouse_1] Julien Toulouse, Quantum Monte Carlo wave functions and their
    optimization for quantum chemistry, CEA Saclay, SPhN Orme des Merisiers, April
    2015, [https://www.lct.jussieu.fr/pagesperso/toulouse/presentations/presentation_saclay_15.pdf](https://www.lct.jussieu.fr/pagesperso/toulouse/presentations/presentation_saclay_15.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Troyer] Matthias Troyer, Matthias Troyer: Achieving Practical Quantum Advantage
    in Chemistry Simulations, QuCQC 2021, [https://www.youtube.com/watch?v=2MsfbPlKgyI](https://www.youtube.com/watch?v=2MsfbPlKgyI)'
  prefs: []
  type: TYPE_NORMAL
- en: '[VQE_1] Peruzzo, A., McClean, J., Shadbolt, P. et al., A variational eigenvalue
    solver on a photonic quantum processor, Nat Commun 5, 4213 (2014), [https://doi.org/10.1038/ncomms5213](https://doi.org/10.1038/ncomms5213)'
  prefs: []
  type: TYPE_NORMAL
- en: '[VQE_2] Qiskit Nature, Ground state solvers, [https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html](https://qiskit.org/documentation/nature/tutorials/03_ground_state_solvers.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[VQE_3] Hardware-efficient variational quantum eigensolver for small molecules
    and quantum magnets, Nature 549, 242–246 (2017), [https://doi.org/10.1038/nature23879](https://doi.org/10.1038/nature23879)'
  prefs: []
  type: TYPE_NORMAL
- en: '[VQE_4] Running VQE on a Statevector Simulator, [https://qiskit.org/textbook/ch-applications/vqe-molecules.html#Running-VQE-on-a-Statevector-Simulator](https://qiskit.org/textbook/ch-applications/vqe-molecules.html#Running-VQE-on-a-Statevector-Simulator)'
  prefs: []
  type: TYPE_NORMAL
