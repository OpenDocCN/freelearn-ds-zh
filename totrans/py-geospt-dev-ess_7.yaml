- en: Chapter 7. Packaging and Distributing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now arrived at the final step in our application development process.
    We have a working application that contains a number of basic GIS features. However,
    so far, it can only be run on our own computer in the very specific development
    environment we have set up. If you want people besides yourself to benefit from
    your application or just to make it easier for you to travel with and use your
    application on multiple computers, you need to package the application so it can
    be more easily installed. In this chapter, we will walk through this final steps
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning an icon to be displayed as the logo of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting your development environment to a self-contained folder structure
    with an executable (`.exe`) file for running your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving your application an installer wizard for a more permanent installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching an application logo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, you have probably noticed that our application is shown with a
    small rather generic-looking red icon in the top left of the window and down by
    the list of open applications. This is the standard Tkinter logo used for all
    Tkinter GUI applications made in Python including the IDLE editor. For your own
    application, you will obviously want your own icon.
  prefs: []
  type: TYPE_NORMAL
- en: The icon image file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you must find or create the icon that you want. Now, in order to assign
    the logo to your application, you need it to be in a `.ico` format, a format that
    contains the same image at multiple different resolutions for optimal display.
    In all likelihood, the image you created or found will be a normal image file
    such as `.png`, `.bmp`, or `.gif`, so we need to convert it. We will do this as
    a one-time process using Python and PIL, since we already have them installed.
  prefs: []
  type: TYPE_NORMAL
- en: Using this PIL approach, there is one small obstacle that we may have to hack
    our way past. The online documentation for py2exe (the package we will be using
    to create an EXE file for our application) warns us that in order to assign an
    icon to the EXE file, it matters in what order the various resolutions of the
    icon file are saved. The sizes must be assigned in order of largest to smallest,
    otherwise it won't work.
  prefs: []
  type: TYPE_NORMAL
- en: We come across an obstacle in PIL, in version 2.8.1 or lower, where it automatically
    orders image sizes in reverse order of smallest to largest behind the scenes,
    regardless of the order you originally specify. Luckily, the PIL/Pillow development
    team were very responsive when I raised the issue, so the problem has already
    been fixed and should no longer be a problem once the next stable version 2.8.2
    is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the new patched PIL version is not out yet, it is still easy to fix on our
    own. Brave as we are, we dive into the internal working files of PIL, located
    in `C:/Python27/Lib/site-packages/PIL`. In the `IcoImagePlugin.py` file, towards
    the top of the script, there is a `_save` function. There you will see that it
    sorts the specified sizes argument from smallest to largest with the following
    code: `sizes = sorted(sizes, key=lambda x: x[0])`. All we have to do is delete
    or comment out that line so that it is entirely up to the user in which order
    the sizes are saved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to convert your chosen logo image. We only need to do this
    once and it is fairly easy, so we do this in the interactive Python Shell window
    instead of the usual file editor. If you are already in the Python IDLE file editor,
    just click on **Run** from the Python Shell in the top menu. Essentially we just
    import PIL, load your chosen image file, and save it to a new file with the `.ico`
    extension. When saving, we give it the sizes argument containing a list of width-height
    tuples with the standard icon resolutions we want to support, in the descending
    order. It makes sense to save this icon image in the `pythongis/app` folder. Run
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the icon file, we can assign it to our application. This is
    done by assigning the icon to Tkinter which will place our icon in the top-left
    corner of our application window and down by the Windows taskbar of active applications.
    We do this in `app/builder.py` in the `run` function, simply by pointing our root
    application window to the path of our icon. The icon file is in the same folder
    as `app/builder.py`, so one may think that a relative path to `logo.ico` will
    suffice, but apparently for this particular task of assigning a GUI icon, Tkinter
    requires a full absolute path. For this, we take advantage of the global `__file__`
    variable, which points to the absolute path of the running script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application now, you should see that the icon appears in the
    top-left corner and at the bottom. Although we have told Tkinter to use the icon
    inside the application itself, this will not affect what the EXE file will look
    like when we browse and view the file in Windows explorer. We will now see how
    this is done as we move onto packaging and creating the EXE file.
  prefs: []
  type: TYPE_NORMAL
- en: The application start up script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we want an EXE file that opens and runs our application, we need a script
    that explicitly defines how to start up our application. Our `guitester.py` script
    that we have used for testing purposes throughout the book does exactly that.
    So we take our testing script and, for the sake of clarity, rename it to `mygisapp.py`
    (or whatever you wish to call your app). The folder location of our main `pythongis`
    folder should then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The application start up script](img/5407OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since all we did was rename our previous `guitester.py` script to `mygisapp.py`,
    the content should remain unchanged and it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Packaging your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the application startup defined, we are now ready for packaging it. Packaging
    our application means that our application becomes self-contained with all the
    necessary files grouped into one folder tree (that are currently spread out across
    numerous locations on your computer), along with an EXE file that the user can
    double-click on to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing py2exe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are numerous libraries in Python for packaging projects, and here we
    choose to use py2exe since it is very easy to install:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [www.py2exe.org](http://www.py2exe.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Download** link at the top, which takes you to [http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/](http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and run the latest version for Python 2.7, which is currently `py2exe-0.6.9.win32-py2.7.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: py2exe is specific to the Windows platform; you have to build on Windows and
    your program can only be used on Windows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another alternative for Windows will be PyInstaller: [http://pythonhosted.org/PyInstaller/](http://pythonhosted.org/PyInstaller/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The equivalent for Mac OS X is py2app: [https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Linux you can use cx_Freeze: [http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing a packaging strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to package an application, so before we go diving in we
    should first understand how py2exe works and plan a packaging strategy accordingly.
    Given a script that the user wants to package, what py2exe does is run through
    the script detecting all import statements recursively and thus which libraries
    must be included in the final package. It then creates a folder called `dist`
    (it also creates one called `build` but that one is irrelevant for us) which becomes
    the distributable folder that contains all the required files and an EXE file
    that runs our application based on our startup script.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial decision is how we choose to bundle our package. We can either bundle
    most of the required files and dependencies into the EXE file itself or a ZIP
    file, or not bundle anything by keeping everything loose in a folder structure.
    At first, bundling may seem like the neatest and best organized choice. Unfortunately,
    py2exe (as with other packaging libraries) often does not correctly detect or
    copy all the necessary files from dependencies (especially the `.dll` and `.pyc`
    files), leading to a startup failure of our application. There are options we
    can specify to help py2exe detect and include everything correctly, but this can
    get tedious for large projects and still might not let us correct every error.
    By leaving everything as files and folders instead of bundling it away, we can
    actually go in and correct some of the mistakes made by py2exe after it has done
    its work.
  prefs: []
  type: TYPE_NORMAL
- en: We get greater control with the non-bundle approach because the EXE file becomes
    like the Python interpreter, and everything in the top level of the `dist` folder
    becomes like Python's `site-packages` folder for importable libraries. This way,
    by manually copying dependencies in full from `site-packages` to the `dist` folder
    they become importable in the same way that they do when Python usually imports
    them from `site-packages`. py2exe will detect and handle correctly our imports
    of built-in Python libraries, but for the more advanced third-party dependencies,
    including our main `pythongis` library, we want to add them ourselves. We can
    put this strategy into practice when we next create the build script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the build script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To package a project, py2exe needs a very simple script of instructions. Save
    this as `setup.py` in the same directory that our main `pythongis` folder is located
    in. Here is the hierarchical directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the build script](img/5407OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We start our `setup.py` file by linking to the `mygisapp.py` startup script
    that should be run by the EXE file, and point to the path of our icon file so
    that the EXE file will look like that when browsing. Under options, we set `skip_archive`
    to `True` following our non-bundle strategy. We also prevent py2exe from trying
    to read and copy two binary files from the `pyagg` package that lead to errors
    that aren't actually necessary because they are only provided for cross-version
    and cross-platform portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you meet other build errors as your application evolves, ignoring such errors
    using `dll_excludes` for the `.dll` and `.pyd` files or excludes for modules or
    packages can be a good way to ignore those, and instead copy-paste the required
    files after building. Following is the code for the procedures we just described,
    as written in the `setup.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `setup` function will build the `dist` folder next to `setup.py` and the
    `pythongis` folder. As we stated previously in our packaging strategy, py2exe
    might not copy all of our third-party libraries correctly if they have an advanced
    layout of files such as the `.dll`, `.pyd`, images, or other data files. Therefore,
    we choose to add some additional code to the script that copies and overwrites
    the more advanced dependencies such `PIL`, `Pyagg`, `Rtree`, and `Shapely` from
    `site-packages` (assuming you did not install them to some other location), as
    well as our entire `pythongis` library, over to the `dist` folder after the build
    process. You must make sure the path to `site-packages` matches your platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `setup.py` script created, you simply run the script to package your
    application. It may take a minute or two for py2exe to copy everything. Once finished,
    there will be a `dist` folder available in the same folder as `setup.py` and `pythongis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the build script](img/5407OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inside the `dist` folder, there will be a `mygisapp.exe` file (assuming that
    was the name of your startup script) that should look like your chosen icon, and
    that when run, should successfully launch your similarly iconified application
    window. While inside the `dist` folder, check to see that py2exe did not accidentally
    include any libraries that you were trying to avoid. For instance, Shapely has
    optional support for and will try to import NumPy when available, which causes
    py2exe to add it to your `dist` folder even if you do not use it. Avoid this by
    adding the unwanted packages to the setup script's excludes option.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the visual C runtime DLL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are doing this on Windows, there is one last crucial step before our
    application is fully standalone. The Python programming environment relies on
    a Microsoft Visual C runtime DLL that was included when we installed Python. However,
    many versions of this DLL exist, so not all computers or users will have the specific
    one that our application needs. py2exe will not include the required DLL by default,
    so it is up to us to include it in our `dist` folder. Including the DLL in your
    installation is a simple matter of copy and paste, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Although we should technically already have the DLL somewhere on our computer,
    I think there is enough variability and pitfalls with finding the correct one
    that it is best to get it by doing a clean install of the (free) Microsoft Visual
    C redistributable program. Download and install the version that your version
    of Python uses, for which 32-bit Python 2.7 is **Microsoft Visual C++ 2008 Redistributable
    Package (x86)**, available from [http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29](http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For an overview of other Python versions and bit architectures and their required
    VC++ and DLL versions, see this excellent post:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version](http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once installed, go to the folder of your new installation, which should be something
    like `C:\Program Files\Microsoft Visual Studio 9.0\VC\redist\x86\`, although this
    may vary depending on your version and bit-architecture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once there, you will find a folder called `Microsoft.VC90.CRT` containing the
    following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.VC90.CRT.manifest`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msvcm90.dll`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msvcp90.dll`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msvcr90.dll`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of the free license, Microsoft requires that you include that entire
    folder with your application, so go ahead and copy it to your `dist` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, your EXE file should always be able to find the required DLLs. If you experience
    trouble or want more information, check out the DLL section of the official py2exe
    tutorial at [http://www.py2exe.org/index.cgi/Tutorial#Step5](http://www.py2exe.org/index.cgi/Tutorial#Step5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now successfully packaged your application and made it portable! Notice
    how the entire application only weighs a mere 30 MB, making it a breeze to upload,
    download, or even email. If you built your application and the package using 32-bit
    Python as recommended, your program should work on any Windows 7 or 8 computer
    (they are essentially the same in the eyes of Python and EXE files). This includes
    both 32-bit and 64-bit Windows, since 64-bit code is backwards-compatible with
    32-bit code. If you used 64-bit Python, it will only work for those who have 64-bit
    Windows, which is not ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you can theoretically slap your `dist` folder on a USB stick
    as a portable GIS application or share it with others by means of a ZIP archive.
    This is fine up to a certain point, but is not the most professional or credible
    way to distribute your application if you are aiming for a wider audience. In
    order to run the application, the user, including yourself, has to locate the
    EXE file far down the long list of oddly named files they don't understand. This
    is just too much of the gory details and manual work that should have come straight
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: More often, people are used to receiving an installer file that guides the user
    to install the program in a more permanent location and that creates the shortcuts
    from them. This not only seems more professional, but also takes care of the more
    advanced steps for the user. As the final step, we will create such an installer
    for our GIS application, using the widely recommended installation software **Inno
    Setup**.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Inno Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Inno Setup, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://www.jrsoftware.org/](http://www.jrsoftware.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Inno Setup** link on the left side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Downloads** link on the left side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the stable heading, download and install the file called `isetup-5.5.5.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up your application's installer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you run the Inno Setup, you will be prompted with a welcome screen where
    you should choose **Create a new script file using the Script Wizard**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up your application''s installer](img/5407OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives you a step-by-step wizard, where you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first screen of the wizard, leave the checkbox unchecked and click on
    **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the second screen, provide the name and version of the application, as well
    as the publisher name and a website if applicable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the third, screen leave the default install locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fourth screen is the most crucial one: you tell the installer the location
    of your EXE file and the location of your entire self-contained `dist` folder
    by clicking on **Add folder** (which you should probably rename to the name of
    your application).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the fifth screen, leave the default start menu options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the sixth screen, you can provide a license text file, and/or some custom
    information text to display at the beginning and end of the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the seventh screen, choose the language of the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the eight screen, set **Custom compiler output folder** to your application
    name (the name of the program folder once installed), **Compiler output base file
    name** (the name of the installer file) to `[your-application-name]_setup`, and
    **Custom Setup icon file** to the icon we created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the ninth screen, click on **Finish** to create the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted to save the setup script, choose **Yes** and save it alongside
    your `setup.py` script, so you can rebuild or modify the installer later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, you should now have a setup file bearing your icon that guides the
    user through installing your newly made GIS application. All of your hard work
    is now neatly wrapped into a single file, and can finally be shared and used by
    a broader audience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you completed the final packaging step of creating your GIS
    application. You gave the application a finishing touch by giving it a logo icon
    to be displayed on the executable file and as part of the application window.
    We then packaged the application in a self-contained folder that can be run on
    any Windows 7 or 8 computer (including both 32- and 64-bit systems, provided you
    used 32-bit Python). Finally, we gave it a professional touch by making an install
    wizard for a more "official" introduction and installation of your application.
    The end users of your application do not need to know Python programming or the
    fact that it was used to make the program. The only thing they need is to run
    your friendly setup file, and they can begin using your application by clicking
    on the newly added shortcuts on their Windows desktop or start menu.
  prefs: []
  type: TYPE_NORMAL
- en: Having completed the steps of making a simple GIS application in Python from
    start to finish, follow on to the last chapter, as we quickly look back at the
    lessons learned, and consider possible paths and tips for you to further extend
    and customize your very own application.
  prefs: []
  type: TYPE_NORMAL
