- en: Chapter 7. Packaging and Distributing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：打包和分发你的应用程序
- en: 'We have now arrived at the final step in our application development process.
    We have a working application that contains a number of basic GIS features. However,
    so far, it can only be run on our own computer in the very specific development
    environment we have set up. If you want people besides yourself to benefit from
    your application or just to make it easier for you to travel with and use your
    application on multiple computers, you need to package the application so it can
    be more easily installed. In this chapter, we will walk through this final steps
    of:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了应用程序开发过程的最后一步。我们有一个包含许多基本 GIS 功能的工作应用程序。然而，到目前为止，它只能在我们的特定开发环境中运行在我们的电脑上。如果你想让你之外的人从你的应用程序中受益，或者只是让你更容易携带和使用你的应用程序在多台电脑上，你需要打包应用程序，以便更容易安装。在本章中，我们将介绍以下最终步骤：
- en: Assigning an icon to be displayed as the logo of our application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个图标作为我们应用程序的标志
- en: Converting your development environment to a self-contained folder structure
    with an executable (`.exe`) file for running your application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的开发环境转换为包含可执行文件（`.exe`）的自包含文件夹结构，以便运行你的应用程序
- en: Giving your application an installer wizard for a more permanent installation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用程序提供一个安装向导以实现更持久的安装
- en: Attaching an application logo
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加应用程序标志
- en: Up until now, you have probably noticed that our application is shown with a
    small rather generic-looking red icon in the top left of the window and down by
    the list of open applications. This is the standard Tkinter logo used for all
    Tkinter GUI applications made in Python including the IDLE editor. For your own
    application, you will obviously want your own icon.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到我们的应用程序在窗口的左上角显示了一个小而相当通用的红色图标，并且在打开的应用程序列表下方。这是 Tkinter GUI 应用程序的标准
    Tkinter 标志，包括 Python 中的 IDLE 编辑器。对于你自己的应用程序，显然你想要自己的图标。
- en: The icon image file
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图标图像文件
- en: First, you must find or create the icon that you want. Now, in order to assign
    the logo to your application, you need it to be in a `.ico` format, a format that
    contains the same image at multiple different resolutions for optimal display.
    In all likelihood, the image you created or found will be a normal image file
    such as `.png`, `.bmp`, or `.gif`, so we need to convert it. We will do this as
    a one-time process using Python and PIL, since we already have them installed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须找到或创建你想要的图标。现在，为了将标志分配给你的应用程序，它需要是 `.ico` 格式，这种格式包含同一图像在不同分辨率下的多个版本，以实现最佳显示。很可能会发现或创建的图像是一个普通的图像文件，例如
    `.png`、`.bmp` 或 `.gif`，因此我们需要将其转换。我们将使用 Python 和 PIL 进行一次性处理，因为我们已经安装了它们。
- en: Using this PIL approach, there is one small obstacle that we may have to hack
    our way past. The online documentation for py2exe (the package we will be using
    to create an EXE file for our application) warns us that in order to assign an
    icon to the EXE file, it matters in what order the various resolutions of the
    icon file are saved. The sizes must be assigned in order of largest to smallest,
    otherwise it won't work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 PIL 方法，我们可能会遇到一个小障碍，我们可能需要通过破解的方式绕过去。py2exe（我们将使用它来为我们的应用程序创建 EXE 文件）的在线文档警告我们，为了将图标分配给
    EXE 文件，图标文件的各个分辨率保存的顺序很重要。大小必须按照从大到小的顺序分配，否则将无法工作。
- en: We come across an obstacle in PIL, in version 2.8.1 or lower, where it automatically
    orders image sizes in reverse order of smallest to largest behind the scenes,
    regardless of the order you originally specify. Luckily, the PIL/Pillow development
    team were very responsive when I raised the issue, so the problem has already
    been fixed and should no longer be a problem once the next stable version 2.8.2
    is released.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PIL 中，我们遇到了一个障碍，在 2.8.1 或更低版本中，它会在幕后自动以从大到小的顺序排列图像大小，而不管你最初指定的顺序如何。幸运的是，当我提出问题时，PIL/Pillow
    开发团队非常响应，所以问题已经得到解决，并且一旦下一个稳定版本 2.8.2 发布，应该不再成为问题。
- en: 'If the new patched PIL version is not out yet, it is still easy to fix on our
    own. Brave as we are, we dive into the internal working files of PIL, located
    in `C:/Python27/Lib/site-packages/PIL`. In the `IcoImagePlugin.py` file, towards
    the top of the script, there is a `_save` function. There you will see that it
    sorts the specified sizes argument from smallest to largest with the following
    code: `sizes = sorted(sizes, key=lambda x: x[0])`. All we have to do is delete
    or comment out that line so that it is entirely up to the user in which order
    the sizes are saved.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '如果新的修补过的PIL版本还没有发布，我们仍然可以自己轻松修复。尽管我们很勇敢，但我们还是深入到PIL的内部工作文件中，这些文件位于`C:/Python27/Lib/site-packages/PIL`。在`IcoImagePlugin.py`文件中，脚本的上部有一个`_save`函数。在那里你会看到它使用以下代码按从小到大的顺序对指定的尺寸参数进行排序：`sizes
    = sorted(sizes, key=lambda x: x[0])`。我们只需要删除或注释掉那行代码，这样用户就可以完全决定保存尺寸的顺序。'
- en: 'Now, we are ready to convert your chosen logo image. We only need to do this
    once and it is fairly easy, so we do this in the interactive Python Shell window
    instead of the usual file editor. If you are already in the Python IDLE file editor,
    just click on **Run** from the Python Shell in the top menu. Essentially we just
    import PIL, load your chosen image file, and save it to a new file with the `.ico`
    extension. When saving, we give it the sizes argument containing a list of width-height
    tuples with the standard icon resolutions we want to support, in the descending
    order. It makes sense to save this icon image in the `pythongis/app` folder. Run
    the following commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好转换你选择的标志图像。我们只需要做一次，而且相当简单，所以我们就在交互式Python Shell窗口中这样做，而不是使用常规的文件编辑器。如果你已经在Python
    IDLE文件编辑器中，只需在顶部菜单中点击**运行**从Python Shell。本质上我们只是导入PIL，加载你选择的图像文件，并将其保存到一个新的`.ico`扩展名的文件中。在保存时，我们给出一个包含我们想要支持的图标分辨率的宽高元组的尺寸参数列表，按降序排列。将此图标图像保存到`pythongis/app`文件夹中是有意义的。运行以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assigning the icon
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配图标
- en: 'Now that we have the icon file, we can assign it to our application. This is
    done by assigning the icon to Tkinter which will place our icon in the top-left
    corner of our application window and down by the Windows taskbar of active applications.
    We do this in `app/builder.py` in the `run` function, simply by pointing our root
    application window to the path of our icon. The icon file is in the same folder
    as `app/builder.py`, so one may think that a relative path to `logo.ico` will
    suffice, but apparently for this particular task of assigning a GUI icon, Tkinter
    requires a full absolute path. For this, we take advantage of the global `__file__`
    variable, which points to the absolute path of the running script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了图标文件，我们可以将其分配给我们的应用程序。这是通过将图标分配给Tkinter来完成的，它将我们的图标放置在应用程序窗口的左上角，并在活动应用程序的Windows任务栏下方。我们在`app/builder.py`文件中的`run`函数中这样做，只需将我们的根应用程序窗口指向图标的路径。图标文件与`app/builder.py`在同一文件夹中，因此有人可能会认为到`logo.ico`的相对路径就足够了，但显然，对于分配GUI图标这个特定任务，Tkinter需要完整的绝对路径。为此，我们利用全局`__file__`变量，它指向运行脚本的绝对路径：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you run the application now, you should see that the icon appears in the
    top-left corner and at the bottom. Although we have told Tkinter to use the icon
    inside the application itself, this will not affect what the EXE file will look
    like when we browse and view the file in Windows explorer. We will now see how
    this is done as we move onto packaging and creating the EXE file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该会看到图标出现在左上角和底部。尽管我们已经告诉Tkinter在应用程序内部使用图标，但这不会影响我们在Windows资源管理器中浏览和查看EXE文件时的外观。我们将如何在接下来的打包和创建EXE文件的过程中看到这一点。
- en: The application start up script
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序启动脚本
- en: 'Since we want an EXE file that opens and runs our application, we need a script
    that explicitly defines how to start up our application. Our `guitester.py` script
    that we have used for testing purposes throughout the book does exactly that.
    So we take our testing script and, for the sake of clarity, rename it to `mygisapp.py`
    (or whatever you wish to call your app). The folder location of our main `pythongis`
    folder should then look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要一个可以打开并运行我们的应用程序的EXE文件，我们需要一个脚本，该脚本明确定义了如何启动我们的应用程序。我们用于本书整个测试目的的`guitester.py`脚本正是这样做的。因此，我们将我们的测试脚本重命名为`mygisapp.py`（或你希望给你的应用程序取的任何名字）。我们的主`pythongis`文件夹的位置应该如下所示：
- en: '![The application start up script](img/5407OS_07_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序启动脚本](img/5407OS_07_01.jpg)'
- en: 'Since all we did was rename our previous `guitester.py` script to `mygisapp.py`,
    the content should remain unchanged and it will look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们所做的只是将之前的 `guitester.py` 脚本重命名为 `mygisapp.py`，内容应该保持不变，它看起来应该是这样的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Packaging your application
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装你的应用程序
- en: With the application startup defined, we are now ready for packaging it. Packaging
    our application means that our application becomes self-contained with all the
    necessary files grouped into one folder tree (that are currently spread out across
    numerous locations on your computer), along with an EXE file that the user can
    double-click on to run the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动定义好后，我们现在就可以准备包装它了。包装我们的应用程序意味着我们的应用程序将包含所有必要的文件，这些文件被分组到一个文件夹树中（目前它们散布在您电脑的多个位置），以及一个用户可以双击以运行应用程序的
    EXE 文件。
- en: Installing py2exe
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 py2exe
- en: 'There are numerous libraries in Python for packaging projects, and here we
    choose to use py2exe since it is very easy to install:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有许多用于包装项目的库，我们选择使用 py2exe，因为它非常容易安装：
- en: Go to [www.py2exe.org](http://www.py2exe.org).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [www.py2exe.org](http://www.py2exe.org)。
- en: Click on the **Download** link at the top, which takes you to [http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/](http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的 **Download** 链接，它将带你去到 [http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/](http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/)。
- en: Download and run the latest version for Python 2.7, which is currently `py2exe-0.6.9.win32-py2.7.exe`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并运行适用于 Python 2.7 的最新版本，目前是 `py2exe-0.6.9.win32-py2.7.exe`。
- en: Note
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: py2exe is specific to the Windows platform; you have to build on Windows and
    your program can only be used on Windows.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: py2exe 是针对 Windows 平台的；你必须在 Windows 上构建，并且你的程序只能在 Windows 上使用。
- en: 'Another alternative for Windows will be PyInstaller: [http://pythonhosted.org/PyInstaller/](http://pythonhosted.org/PyInstaller/).'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Windows 的另一个替代方案将是 PyInstaller：[http://pythonhosted.org/PyInstaller/](http://pythonhosted.org/PyInstaller/)。
- en: 'The equivalent for Mac OS X is py2app: [https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/).'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mac OS X 的对应工具是 py2app：[https://pythonhosted.org/py2app/](https://pythonhosted.org/py2app/)。
- en: 'For Linux you can use cx_Freeze: [http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/).'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Linux，你可以使用 cx_Freeze：[http://cx-freeze.sourceforge.net/](http://cx-freeze.sourceforge.net/)。
- en: Developing a packaging strategy
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定包装策略
- en: There are many ways to package an application, so before we go diving in we
    should first understand how py2exe works and plan a packaging strategy accordingly.
    Given a script that the user wants to package, what py2exe does is run through
    the script detecting all import statements recursively and thus which libraries
    must be included in the final package. It then creates a folder called `dist`
    (it also creates one called `build` but that one is irrelevant for us) which becomes
    the distributable folder that contains all the required files and an EXE file
    that runs our application based on our startup script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 包装应用程序有许多方法，所以在我们深入之前，我们应该首先了解 py2exe 的工作原理并相应地制定一个包装策略。给定一个用户想要包装的脚本，py2exe
    做的是遍历脚本，递归地检测所有导入语句，从而确定哪些库必须包含在最终的包中。然后它创建一个名为 `dist` 的文件夹（它还创建了一个名为 `build`
    的文件夹，但对我们来说那个是不相关的），这个文件夹变成了包含所有必需文件和基于我们的启动脚本的 EXE 文件的发行文件夹。
- en: A crucial decision is how we choose to bundle our package. We can either bundle
    most of the required files and dependencies into the EXE file itself or a ZIP
    file, or not bundle anything by keeping everything loose in a folder structure.
    At first, bundling may seem like the neatest and best organized choice. Unfortunately,
    py2exe (as with other packaging libraries) often does not correctly detect or
    copy all the necessary files from dependencies (especially the `.dll` and `.pyc`
    files), leading to a startup failure of our application. There are options we
    can specify to help py2exe detect and include everything correctly, but this can
    get tedious for large projects and still might not let us correct every error.
    By leaving everything as files and folders instead of bundling it away, we can
    actually go in and correct some of the mistakes made by py2exe after it has done
    its work.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的决定是我们如何选择捆绑我们的包。我们可以将大多数所需的文件和依赖项捆绑到EXE文件本身或ZIP文件中，或者不捆绑任何东西，保持所有内容在文件夹结构中松散。起初，捆绑可能看起来是最整洁和最佳组织的选择。不幸的是，py2exe（与其他打包库一样）通常无法正确检测或复制所有必要的文件（尤其是`.dll`和`.pyc`文件）从依赖项中，导致我们的应用程序启动失败。我们可以指定一些选项来帮助py2exe正确检测和包含所有内容，但对于大型项目来说，这可能会变得繁琐，并且仍然可能无法纠正每个错误。通过将所有内容作为文件和文件夹而不是捆绑起来，我们实际上可以在py2exe完成工作后进入并纠正py2exe犯的一些错误。
- en: We get greater control with the non-bundle approach because the EXE file becomes
    like the Python interpreter, and everything in the top level of the `dist` folder
    becomes like Python's `site-packages` folder for importable libraries. This way,
    by manually copying dependencies in full from `site-packages` to the `dist` folder
    they become importable in the same way that they do when Python usually imports
    them from `site-packages`. py2exe will detect and handle correctly our imports
    of built-in Python libraries, but for the more advanced third-party dependencies,
    including our main `pythongis` library, we want to add them ourselves. We can
    put this strategy into practice when we next create the build script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非捆绑方法，我们可以获得更大的控制权，因为EXE文件变得像Python解释器一样，`dist`文件夹顶层的所有内容都变成了Python的`site-packages`文件夹，用于导入库。这样，通过手动将依赖项完整地从`site-packages`复制到`dist`文件夹，它们就可以以与Python通常从`site-packages`导入它们相同的方式导入。py2exe将检测并正确处理我们的内置Python库的导入，但对于更高级的第三方依赖项，包括我们的主要`pythongis`库，我们希望自行添加。我们可以在创建下一个构建脚本时将这种策略付诸实践。
- en: Creating the build script
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建脚本
- en: 'To package a project, py2exe needs a very simple script of instructions. Save
    this as `setup.py` in the same directory that our main `pythongis` folder is located
    in. Here is the hierarchical directory structure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要打包一个项目，py2exe需要一个非常简单的指令脚本。将其保存为与我们的主`pythongis`文件夹位于同一目录下的`setup.py`。以下是目录结构层次：
- en: '![Creating the build script](img/5407OS_07_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![创建构建脚本](img/5407OS_07_02.jpg)'
- en: We start our `setup.py` file by linking to the `mygisapp.py` startup script
    that should be run by the EXE file, and point to the path of our icon file so
    that the EXE file will look like that when browsing. Under options, we set `skip_archive`
    to `True` following our non-bundle strategy. We also prevent py2exe from trying
    to read and copy two binary files from the `pyagg` package that lead to errors
    that aren't actually necessary because they are only provided for cross-version
    and cross-platform portability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`setup.py`文件开始，通过链接到应由EXE文件运行的`mygisapp.py`启动脚本，并指向我们的图标文件路径，这样当浏览时EXE文件看起来就会是这样。在选项中，我们根据我们的非捆绑策略将`skip_archive`设置为`True`。我们还阻止py2exe尝试从`pyagg`包中读取和复制两个二进制文件，这会导致不必要的错误，因为这些文件只是为了跨版本和跨平台兼容性而提供的。
- en: 'If you meet other build errors as your application evolves, ignoring such errors
    using `dll_excludes` for the `.dll` and `.pyd` files or excludes for modules or
    packages can be a good way to ignore those, and instead copy-paste the required
    files after building. Following is the code for the procedures we just described,
    as written in the `setup.py` script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序演变过程中遇到其他构建错误，可以使用`dll_excludes`忽略`.dll`和`.pyd`文件或模块或包的排除，这可以是一个好的方法来忽略这些错误，并在构建后复制粘贴所需的文件。以下是我们刚才描述的步骤的代码，写在`setup.py`脚本中：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `setup` function will build the `dist` folder next to `setup.py` and the
    `pythongis` folder. As we stated previously in our packaging strategy, py2exe
    might not copy all of our third-party libraries correctly if they have an advanced
    layout of files such as the `.dll`, `.pyd`, images, or other data files. Therefore,
    we choose to add some additional code to the script that copies and overwrites
    the more advanced dependencies such `PIL`, `Pyagg`, `Rtree`, and `Shapely` from
    `site-packages` (assuming you did not install them to some other location), as
    well as our entire `pythongis` library, over to the `dist` folder after the build
    process. You must make sure the path to `site-packages` matches your platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup`函数将在`setup.py`旁边的`dist`文件夹和`pythongis`文件夹中构建。正如我们在包装策略中之前所述，如果第三方库有如`.dll`、`.pyd`、图片或其他数据文件的高级文件布局，py2exe可能无法正确复制所有这些库。因此，我们选择在脚本中添加一些额外的代码，在构建过程之后将更高级的依赖项，如`PIL`、`Pyagg`、`Rtree`和`Shapely`从`site-packages`（假设你没有将它们安装到其他位置）以及我们整个`pythongis`库复制并覆盖到`dist`文件夹中。你必须确保`site-packages`的路径与你的平台匹配。'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the `setup.py` script created, you simply run the script to package your
    application. It may take a minute or two for py2exe to copy everything. Once finished,
    there will be a `dist` folder available in the same folder as `setup.py` and `pythongis`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`setup.py`脚本后，你只需运行脚本以打包你的应用程序。py2exe复制所有内容可能需要一分钟左右。完成后，将在与`setup.py`和`pythongis`相同的文件夹中有一个可用的`dist`文件夹：
- en: '![Creating the build script](img/5407OS_07_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![创建构建脚本](img/5407OS_07_03.jpg)'
- en: Inside the `dist` folder, there will be a `mygisapp.exe` file (assuming that
    was the name of your startup script) that should look like your chosen icon, and
    that when run, should successfully launch your similarly iconified application
    window. While inside the `dist` folder, check to see that py2exe did not accidentally
    include any libraries that you were trying to avoid. For instance, Shapely has
    optional support for and will try to import NumPy when available, which causes
    py2exe to add it to your `dist` folder even if you do not use it. Avoid this by
    adding the unwanted packages to the setup script's excludes option.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dist`文件夹内，将有一个`mygisapp.exe`文件（假设这是你的启动脚本名称），它应该看起来像你选择的图标，并且当运行时，应该成功启动你的类似图标的应用程序窗口。当你在`dist`文件夹内时，检查py2exe是否意外包含了你试图避免的任何库。例如，Shapely有可选的NumPy支持，并且会尝试导入NumPy，这会导致py2exe即使你没有使用它也会将其添加到你的`dist`文件夹中。通过将不想要的包添加到设置脚本中的排除选项来避免这种情况。
- en: Adding the visual C runtime DLL
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Visual C运行时DLL
- en: 'If you are doing this on Windows, there is one last crucial step before our
    application is fully standalone. The Python programming environment relies on
    a Microsoft Visual C runtime DLL that was included when we installed Python. However,
    many versions of this DLL exist, so not all computers or users will have the specific
    one that our application needs. py2exe will not include the required DLL by default,
    so it is up to us to include it in our `dist` folder. Including the DLL in your
    installation is a simple matter of copy and paste, using the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在Windows上操作，在我们应用程序完全独立之前，还有最后一个至关重要的步骤。Python编程环境依赖于我们在安装Python时包含的Microsoft
    Visual C运行时DLL。然而，存在许多版本的此DLL，因此并非所有计算机或用户都会有我们应用程序需要的特定版本。py2exe默认不会包含所需的DLL，因此我们必须将其包含在我们的`dist`文件夹中。在安装中包含DLL是一个简单的复制和粘贴过程，按照以下步骤操作：
- en: Although we should technically already have the DLL somewhere on our computer,
    I think there is enough variability and pitfalls with finding the correct one
    that it is best to get it by doing a clean install of the (free) Microsoft Visual
    C redistributable program. Download and install the version that your version
    of Python uses, for which 32-bit Python 2.7 is **Microsoft Visual C++ 2008 Redistributable
    Package (x86)**, available from [http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29](http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管从技术上讲，我们已经在电脑上某个地方有了DLL文件，但我认为找到正确的一个有足够的变数和陷阱，因此最好是通过干净安装（免费的）Microsoft Visual
    C redistributable程序来获取它。下载并安装Python版本所使用的版本，对于32位Python 2.7，是**Microsoft Visual
    C++ 2008 Redistributable Package (x86**)，可以从[http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29](http://www.microsoft.com/download/en/details.aspx?displaylang=en&id=29)获取。
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For an overview of other Python versions and bit architectures and their required
    VC++ and DLL versions, see this excellent post:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于其他Python版本和位架构及其所需的VC++和DLL版本的概述，请参阅这篇出色的帖子：
- en: '[http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version](http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version](http://stackoverflow.com/questions/9047072/windows-python-version-and-vc-redistributable-version)'
- en: Once installed, go to the folder of your new installation, which should be something
    like `C:\Program Files\Microsoft Visual Studio 9.0\VC\redist\x86\`, although this
    may vary depending on your version and bit-architecture.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，转到新安装的文件夹，它应该是类似于`C:\Program Files\Microsoft Visual Studio 9.0\VC\redist\x86\`的路径，尽管这可能会根据你的版本和位架构而有所不同。
- en: 'Once there, you will find a folder called `Microsoft.VC90.CRT` containing the
    following files:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦到了那里，你将找到一个名为`Microsoft.VC90.CRT`的文件夹，其中包含以下文件：
- en: '`Microsoft.VC90.CRT.manifest`'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.VC90.CRT.manifest`'
- en: '`msvcm90.dll`'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msvcm90.dll`'
- en: '`msvcp90.dll`'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msvcp90.dll`'
- en: '`msvcr90.dll`'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msvcr90.dll`'
- en: As part of the free license, Microsoft requires that you include that entire
    folder with your application, so go ahead and copy it to your `dist` folder.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为免费许可证的一部分，Microsoft要求你将整个文件夹包含在你的应用程序中，所以请将其复制到你的`dist`文件夹中。
- en: Now, your EXE file should always be able to find the required DLLs. If you experience
    trouble or want more information, check out the DLL section of the official py2exe
    tutorial at [http://www.py2exe.org/index.cgi/Tutorial#Step5](http://www.py2exe.org/index.cgi/Tutorial#Step5).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你的EXE文件应该总是能够找到所需的DLLs。如果你遇到麻烦或需要更多信息，请查看官方py2exe教程中的DLL部分，链接为[http://www.py2exe.org/index.cgi/Tutorial#Step5](http://www.py2exe.org/index.cgi/Tutorial#Step5)。
- en: You have now successfully packaged your application and made it portable! Notice
    how the entire application only weighs a mere 30 MB, making it a breeze to upload,
    download, or even email. If you built your application and the package using 32-bit
    Python as recommended, your program should work on any Windows 7 or 8 computer
    (they are essentially the same in the eyes of Python and EXE files). This includes
    both 32-bit and 64-bit Windows, since 64-bit code is backwards-compatible with
    32-bit code. If you used 64-bit Python, it will only work for those who have 64-bit
    Windows, which is not ideal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经成功打包了你的应用程序，并使其变得便携！注意整个应用程序仅重30MB，这使得上传、下载甚至通过电子邮件发送变得轻而易举。如果你使用推荐的32位Python构建了应用程序和包，你的程序应该能在任何Windows
    7或8计算机上运行（在Python和EXE文件的眼中，它们基本上是相同的）。这包括32位和64位Windows，因为64位代码与32位代码向后兼容。如果你使用了64位Python，它将仅适用于那些拥有64位Windows的用户，这并不理想。
- en: Creating an installer
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安装程序
- en: At this point, you can theoretically slap your `dist` folder on a USB stick
    as a portable GIS application or share it with others by means of a ZIP archive.
    This is fine up to a certain point, but is not the most professional or credible
    way to distribute your application if you are aiming for a wider audience. In
    order to run the application, the user, including yourself, has to locate the
    EXE file far down the long list of oddly named files they don't understand. This
    is just too much of the gory details and manual work that should have come straight
    out of the box.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以理论上将你的`dist`文件夹作为一个便携式GIS应用程序放在U盘上，或者通过ZIP存档与他人共享。这在一定程度上是可以的，但如果你希望面向更广泛的受众，这不是分发应用程序最专业或最可信的方式。为了运行应用程序，用户（包括你自己）必须在一个他们不理解的长名单中找到EXE文件。这仅仅是太多应该直接从盒子里出来的血腥细节和手动工作。
- en: More often, people are used to receiving an installer file that guides the user
    to install the program in a more permanent location and that creates the shortcuts
    from them. This not only seems more professional, but also takes care of the more
    advanced steps for the user. As the final step, we will create such an installer
    for our GIS application, using the widely recommended installation software **Inno
    Setup**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，人们习惯于接收一个安装程序文件，该文件指导用户在更永久的位置安装程序，并从他们那里创建快捷方式。这不仅看起来更专业，而且也处理了用户的高级步骤。作为最终步骤，我们将为我们的GIS应用程序创建这样一个安装程序，使用广泛推荐的安装软件**Inno
    Setup**。
- en: Installing Inno Setup
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Inno Setup
- en: 'To install Inno Setup, use the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Inno Setup，请按照以下步骤操作：
- en: Go to [http://www.jrsoftware.org/](http://www.jrsoftware.org/).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[http://www.jrsoftware.org/](http://www.jrsoftware.org/)。
- en: Click on the **Inno Setup** link on the left side.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**Inno Setup**链接。
- en: Click on the **Downloads** link on the left side.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的**下载**链接。
- en: Under the stable heading, download and install the file called `isetup-5.5.5.exe`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在稳定标题下，下载并安装名为`isetup-5.5.5.exe`的文件。
- en: Setting up your application's installer
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序的安装程序
- en: 'Once you run the Inno Setup, you will be prompted with a welcome screen where
    you should choose **Create a new script file using the Script Wizard**, as shown
    in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行Inno Setup，您将看到一个欢迎屏幕，您应该选择**使用脚本向导创建一个新的脚本文件**，如图所示：
- en: '![Setting up your application''s installer](img/5407OS_07_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用程序的安装程序](img/5407OS_07_04.jpg)'
- en: 'This gives you a step-by-step wizard, where you will do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了一个逐步向导，您将执行以下操作：
- en: On the first screen of the wizard, leave the checkbox unchecked and click on
    **Next**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的第一屏，保持复选框未勾选，并点击**下一步**。
- en: On the second screen, provide the name and version of the application, as well
    as the publisher name and a website if applicable.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二屏，提供应用程序的名称和版本，以及出版者名称和适用的网站。
- en: On the third, screen leave the default install locations.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三屏，保留默认的安装位置。
- en: 'The fourth screen is the most crucial one: you tell the installer the location
    of your EXE file and the location of your entire self-contained `dist` folder
    by clicking on **Add folder** (which you should probably rename to the name of
    your application).'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四屏是最关键的一屏：您通过点击**添加文件夹**（您可能需要将其重命名为应用程序的名称）来告诉安装程序您的EXE文件位置以及整个自包含的`dist`文件夹位置。
- en: On the fifth screen, leave the default start menu options.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第五屏，保留默认的开始菜单选项。
- en: On the sixth screen, you can provide a license text file, and/or some custom
    information text to display at the beginning and end of the installation.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第六屏，您可以提供许可证文本文件，以及/或一些自定义信息文本，用于显示在安装的开始和结束部分。
- en: On the seventh screen, choose the language of the installer.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第七屏，选择安装程序的语言。
- en: On the eight screen, set **Custom compiler output folder** to your application
    name (the name of the program folder once installed), **Compiler output base file
    name** (the name of the installer file) to `[your-application-name]_setup`, and
    **Custom Setup icon file** to the icon we created earlier.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第八屏，将**自定义编译器输出文件夹**设置为您的应用程序名称（安装后的程序文件夹名称），将**编译器输出基本文件名**（安装程序文件名称）设置为`[您的应用程序名称]_setup`，并将**自定义安装图标文件**设置为之前创建的图标。
- en: On the ninth screen, click on **Finish** to create the installer.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第九屏，点击**完成**以创建安装程序。
- en: When prompted to save the setup script, choose **Yes** and save it alongside
    your `setup.py` script, so you can rebuild or modify the installer later.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示保存设置脚本时，选择**是**，并将其保存与您的`setup.py`脚本一起，以便您可以在以后重建或修改安装程序。
- en: With this, you should now have a setup file bearing your icon that guides the
    user through installing your newly made GIS application. All of your hard work
    is now neatly wrapped into a single file, and can finally be shared and used by
    a broader audience.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您现在应该有一个带有您图标的应用程序安装文件，它将引导用户安装您新创建的GIS应用程序。您所有的辛勤工作现在都整齐地封装在一个文件中，最终可以与更广泛的受众共享和使用。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you completed the final packaging step of creating your GIS
    application. You gave the application a finishing touch by giving it a logo icon
    to be displayed on the executable file and as part of the application window.
    We then packaged the application in a self-contained folder that can be run on
    any Windows 7 or 8 computer (including both 32- and 64-bit systems, provided you
    used 32-bit Python). Finally, we gave it a professional touch by making an install
    wizard for a more "official" introduction and installation of your application.
    The end users of your application do not need to know Python programming or the
    fact that it was used to make the program. The only thing they need is to run
    your friendly setup file, and they can begin using your application by clicking
    on the newly added shortcuts on their Windows desktop or start menu.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您完成了创建GIS应用程序的最终打包步骤。您通过给应用程序添加一个显示在可执行文件和应用程序窗口中的标志图标来给它一个完美的收尾。然后，我们将应用程序打包在一个自包含的文件夹中，可以在任何Windows
    7或8计算机上运行（包括32位和64位系统，前提是您使用了32位Python）。最后，我们通过创建一个安装向导来给应用程序一个更“官方”的介绍和安装，使其看起来更专业。您的应用程序的最终用户不需要知道Python编程或它被用来制作程序的事实。他们唯一需要的是运行您友好的安装文件，然后他们可以通过点击Windows桌面或开始菜单上新添加的快捷方式来开始使用您的应用程序。
- en: Having completed the steps of making a simple GIS application in Python from
    start to finish, follow on to the last chapter, as we quickly look back at the
    lessons learned, and consider possible paths and tips for you to further extend
    and customize your very own application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了从零开始到结束制作一个简单的Python GIS应用程序的步骤后，继续阅读最后一章，我们将快速回顾所学到的知识，并考虑为你进一步扩展和定制你自己的应用程序的可能路径和建议。
