<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div class="chapter" title="Chapter 5. Editing Map Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Editing Map Data</h1></div></div></div><p>Data has to come from somewhere. In the multi-billion dollar geospatial industry, collecting data is expensive. Features visible from aerial photography need to be plotted, and features not so visible on a workstation need their GPS coordinates collected in the field. Your time is valuable, and data collection won't happen on its own.</p><p>But what if you could get others to do the work for you? What if you could create a website that let other people collect the information? Trained workers could document utility lines, or concerned citizens could report problem locations in town. By using volunteer data collection, you can quickly collect the data you need.</p><p>ArcGIS Server provides not only data visualization on a map, but editing capabilities as well. Services can be created, and applications can be built around them, which allow users to add items to a map, change their shape, edit their attributes, and even delete them. ArcGIS Server also gives the creator of the services control over which of those data changes are allowed.</p><p>In this chapter, we're going to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Look at the data editing capabilities ArcGIS Server provides with the ArcGIS JavaScript API</li><li class="listitem" style="list-style-type: disc">Learn about the editing controls in the API, and how they create a helpful editing experience</li><li class="listitem" style="list-style-type: disc">Create an editing application that uses the tools in the ArcGIS JavaScript API</li></ul></div><div class="section" title="The use cases for webmap editing"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>The use cases for webmap editing</h1></div></div></div><p>A GIS professional doesn't <a id="id445" class="indexterm"/>have to edit all the map data on his own. Trained staff and eager volunteers can assist with data collection and map editing projects that interest them. As the developer, it's up to you to give them the tools they need to collect and update the data. The following are examples of applications which use web map editing that you can create :</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Field <a id="id446" class="indexterm"/>crews updating utility data</li><li class="listitem" style="list-style-type: disc">Public service requests and incident reports</li><li class="listitem" style="list-style-type: disc">Parcel classification reassignments after analysis</li><li class="listitem" style="list-style-type: disc">Volunteer geographic information data collection</li></ul></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Map editing requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Map editing requirements</h1></div></div></div><p>Editing geographic <a id="id447" class="indexterm"/>data using the ArcGIS JavaScript API requires some setup on ArcGIS Server. An editable <span class="strong"><strong>feature service</strong></span> <a id="id448" class="indexterm"/>must be published on ArcGIS Server, which requires an ArcSDE geodatabase. File geodatabases, personal geodatabases, and shapefiles cannot be used to store editable data. ArcGIS Online allows you to upload editable data to ESRI's cloud service, but the data upload and editing process has requirements which are covered in <a class="link" href="ch11.html" title="Chapter 11. The Future of ArcGIS Development">Chapter 11</a>, <span class="emphasis"><em>The Future of ArcGIS Development</em></span>.</p><p>There are a few requirements for setting up an editable map application using ArcGIS Server and its JavaScript API. The geodatabase storing the data should be versioned, if you want to review the data before committing it to your default database. Versioned data also supports undo and redo operations. You may want to publish a read-only map service along with your editable feature service. Finally, some editing operations require a geometry service to handle geometry changes, as you cut, merge, and trim features.</p></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Feature services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Feature services</h1></div></div></div><p>A feature service <a id="id449" class="indexterm"/>provides a web interface between data stored on the server and an application on the browser created to use it. They can be accessed through URL endpoints similar to map services. However, they produce very different results. They can be loaded on a map and queried much like dynamic or tiled services, but there is more. Feature services return graphics instead of tiles. These graphics can be queried, and even edited, if the service allows.</p><div class="section" title="Feature templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Feature templates</h2></div></div></div><p>With ArcGIS Server 10.1, feature services can be published with the added functionality of<a id="id450" class="indexterm"/> <span class="strong"><strong>feature templates</strong></span>. Feature templates give the user preconfigured features to add to the map. Feature templates are created in ArcMap, and define the symbology and predefined attributes. These templates make it easier to edit service data.</p><p>One example of Feature templates can be found on an animal sighting map. The points on the map designate where animal sightings take place. Feature templates could be created to show pictures of each major type of animal (cat, dog, bird, rabbit, deer, and so on). Values in some of the fields could be defined ahead of time. For instance, you could say that all cats are warm-blooded.</p><p>How do you, as <a id="id451" class="indexterm"/>the developer, take advantage of feature templates? Apart from demonstrating what each symbol means, there are template pickers in the ArcGIS JavaScript API's tools that not only show the feature templates, but also let you click on them and add them to your map.</p></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Feature layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Feature layer</h1></div></div></div><p>The feature layer <a id="id452" class="indexterm"/>provides access to graphics within a feature class. The user can thus both query and edit the shapes and attributes of the graphics. We reviewed their REST service profile in <a class="link" href="ch04.html" title="Chapter 4. Finding Peace in REST">Chapter 4</a>, <span class="emphasis"><em>Finding Peace in REST</em></span>. We load feature layers in much the same way we load dynamic and tiled services. However, their options often require more parameters, due to the editable nature of the content.</p><div class="section" title="Feature service modes"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Feature service modes</h2></div></div></div><p>When initializing a feature <a id="id453" class="indexterm"/>layer from a feature service, you have a choice as to how the data is loaded. Do you want to load it all at once? Do you want to load all the features that you can see? Do you only want to load the one you've selected, and not show the rest? In the next sections, we'll review the three feature service modes used to download data to the client browser.</p><div class="section" title="Snapshot mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec68"/>Snapshot mode</h3></div></div></div><p>Sometimes, if there is <a id="id454" class="indexterm"/>not a lot of data, it's better to download it all <a id="id455" class="indexterm"/>at once. That's what snapshot mode does. Snapshot mode downloads feature data based on time definitions and definition expressions, but it is limited by the maximum download limit. The visibility of the data is then determined by time extent.</p><p>Snapshot mode is helpful if there is not a lot of data to download, or if connectivity may be an issue during use. The user can download all the feature data at once, work with it, and then save their changes when connections become favorable again.</p></div><div class="section" title="On demand mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec69"/>On demand mode</h3></div></div></div><p>Sometimes, you're<a id="id456" class="indexterm"/> only interested in downloading the data in<a id="id457" class="indexterm"/> front of you. In that case, on demand mode is the best option. On demand mode only downloads features within the map extent. They too are affected by time definitions and definition expressions. Unlike snapshot mode, data requests are made every time the map extent changes. On demand mode is the default mode for any <code class="literal">FeatureLayer</code>.</p><p>On demand mode is typically used when there is a lot of data in the feature layer, but the user is only expected to view a small portion of it. It's very good for focussed editing tasks. It's not as good <a id="id458" class="indexterm"/>for mobile applications with lots of map navigation and connectivity<a id="id459" class="indexterm"/> issues, since some graphics will fail to load.</p></div><div class="section" title="Selection mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec70"/>Selection mode</h3></div></div></div><p>Loading <a id="id460" class="indexterm"/>features by selection is more constraining <a id="id461" class="indexterm"/>because it only shows those features that have been selected. Feature selection is handled using the feature layer's <code class="literal">selectFeatures()</code> method, in a manner similar to querying from a map service layer. In this case, the graphics returned are considered "selected". Selection methods include clicking on the map and sending a query with specific parameters. This method is very helpful if there are lots of features, and you only want to download specific ones, whether it's by area or attributes.</p></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Editing tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Editing tools</h1></div></div></div><p>The ArcGIS JavaScript API<a id="id462" class="indexterm"/> comes with a set of widgets and modules designed specifically for editing. With the editing widgets, the user can add features to the map, change their shape, edit their attributes, and even delete them, if the services allow. Let's look at some of the tools available in the API.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Why are the editing tools in your application not working? It may be the CSS. Editing widgets are created with Dojo user controls, or dijits. These controls require the Dojo stylesheets, such as <code class="literal">claro.css</code> or <code class="literal">nihilo.css</code>. Without them, buttons stop working, and other unexpected behaviors may arise.</p></div></div><div class="section" title="Edit toolbar"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Edit toolbar</h2></div></div></div><p>The<a id="id463" class="indexterm"/> edit <a id="id464" class="indexterm"/>toolbar, loaded with the <code class="literal">esri/toolbars/edit</code> module, lets the user change the shape, orientation, scale, and position of graphics on a map. We discussed it in <a class="link" href="ch02.html" title="Chapter 2. Digging into the API">Chapter 2</a>, <span class="emphasis"><em>Digging into the API</em></span>, in relation to the other toolbars. Separate controls are required to save the changes made with the edit toolbar. You can see an image of a triangle selected for the edit toolbar here:</p><div class="mediaobject"><img src="graphics/6459_05_01.jpg" alt="Edit toolbar" width="260" height="261"/></div><p>The edit toolbar<a id="id465" class="indexterm"/> requires a map in its constructor. The constructor also needs a number of optional parameters to modify its appearance and behavior. Many of the options depend on the geometry type of the data being manipulated. As of API version 3.13, here <a id="id466" class="indexterm"/>are some of the available options for the edit toolbar:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">allowAddVertices</code> (<code class="literal">boolean</code>): If true, you can add vertices to a polyline or polygon.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allowDeleteVertices</code> (<code class="literal">boolean</code>): If true, you can remove vertices from a polyline or polygon.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ghostLineSymbol</code> (<code class="literal">line symbol</code>): When moving a line or polygon edge, this is the symbol for the line that shows where the new line/edge will go.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ghostVertexSymbol</code> (<code class="literal">marker symbol</code>): If you are allowed to add vertices, this is the symbol that shows where to click to insert a vertex.</li><li class="listitem" style="list-style-type: disc"><code class="literal">textSymbolEditorHolder</code> (<code class="literal">string</code> or <code class="literal">HTML DOMnode</code>): Web page location when you want to add a text symbol editor widget</li><li class="listitem" style="list-style-type: disc"><code class="literal">uniformScaling</code> (<code class="literal">boolean</code>): When true, resizing a polyline or polygon keeps the original ratio of width to height.</li><li class="listitem" style="list-style-type: disc"><code class="literal">vertexSymbol</code> (<code class="literal">marker symbol</code>): When editing polylines and polygons, this is the symbol of the points at each vertex.</li></ul></div><p>You can see an example of loading the edit toolbar in the following snippet:</p><div class="informalexample"><pre class="programlisting">require([…, "esri/toolbars/edit", 
  "esri/symbols/SimpleMarkerSymbol", 
  "esri/symbols/SimpleLineSymbol",  ], 
function ( …, EditToolbar, MarkerSymbol, Linesymbol, …) {

  var editTB = new EditToolbar(map,… {
    allowAddVertices: true,
    allowDeleteVertices: true,
    ghostLineSymbol: new LineSymbol(…),
    ghostMarkerSymbol: new MarkerSymbol(…),
    uniformScaling: false,
    vertexSymbol: new MarkerSymbol(…)
  });

});</pre></div><p>When you want to use the<a id="id467" class="indexterm"/> edit toolbar to edit a feature, you call the <code class="literal">activate()</code> method. The <code class="literal">activate()</code> method requires two arguments, and has the option for a third. Firstly, the<a id="id468" class="indexterm"/> method requires a tool, which is made by joining a combination of the edit toolbar constants with the pipe <code class="literal">|</code> symbol. The constants include <code class="literal">EDIT_TEXT</code>, <code class="literal">EDIT_VERTICES</code>, <code class="literal">MOVE</code>, <code class="literal">ROTATE</code>, and <code class="literal">SCALE</code>. Secondly, the <code class="literal">activate()</code> method requires a graphic to edit. The final optional argument is an object similar to the one used to create the edit toolbar. In the following code snippet, we have a graphic that is added to the map, and a click event is assigned to it that activates the edit toolbar to edit the graphic when it is double-clicked:</p><div class="informalexample"><pre class="programlisting">var editTB = new EditToolbar(…);
  …
map.graphics.add(myGraphic);
dojoOn(myGraphic, "dblclick", function () {
  editTB.activate(EditToolbar.EDIT_VERTICES | EditToolbar.MOVE | EditToolbar.ROTATE | EditToolbar.SCALE, myGraphic);
  dojoOn.once(myGraphic, "dblclick", function () {
    editTB.deactivate();
  });
});</pre></div></div><div class="section" title="Attribute inspector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Attribute inspector</h2></div></div></div><p>Sometimes, you <a id="id469" class="indexterm"/>don't care where things are, you just care about the <a id="id470" class="indexterm"/>content. That's where the attribute inspector comes in. The attachment inspector provides a form with a list of editable fields and the appropriate blanks to edit them. The attachment inspector is bound to a feature layer, and displays the editable values for the selected layer. The fields in the attribute inspector respond to the field types of the attributes. Date fields show a calendar when editing. Fields with coded value domains show a drop-down list instead of a text blank. Below, you can see an example of an attribute inspector loaded in the popup, though it could be added to a separate HTML element.</p><div class="mediaobject"><img src="graphics/6459_05_02.jpg" alt="Attribute inspector" width="397" height="303"/></div><p>When initializing <a id="id471" class="indexterm"/>an attribute inspector, you need to define how the inspector will handle the different fields within the graphic attributes. The attribute inspector constructor accepts an <code class="literal">options</code> object, and either an HTML element or an id string reference to the element. The <code class="literal">options</code> object has one parameter called <code class="literal">layerInfos</code>, which accepts an array of <code class="literal">layerInfo</code> objects. Each <code class="literal">layerInfo</code> object contains one or <a id="id472" class="indexterm"/>more of the following parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">featureLayer</code> (<code class="literal">required</code>): The feature layer to be edited.</li><li class="listitem" style="list-style-type: disc"><code class="literal">userId</code> (<code class="literal">string</code>, <code class="literal">optional</code>): The ArcGIS Server user id connected to the service, should the editing require token authentication. This is not needed if you have used the Identity Manager to handle logins.</li><li class="listitem" style="list-style-type: disc"><code class="literal">showObjectID</code> (<code class="literal">Boolean, optional</code>): Whether you want to see the object id of the feature when it is selected. By default, this value is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">showGlobalID</code> (<code class="literal">Boolean</code>, <code class="literal">optional</code>): Whether you want to see the global id of the feature when it is selected. By default, this value is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">showDeleteButton</code> (<code class="literal">Boolean</code>, <code class="literal">optional</code>): By default, the attribute inspector shows a delete button that lets you delete the selected feature. Setting this to false removes it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">showAttachments</code> (<code class="literal">Boolean</code>, <code class="literal">optional</code>): When set to true, and if the feature layer has attachments, this displays an attachment editor form in the attribute inspector, which lets you view and upload files attached to the feature.</li><li class="listitem" style="list-style-type: disc"><code class="literal">isEditable</code> (<code class="literal">Boolean</code>, <code class="literal">optional</code>): Lets you control whether the feature is editable. This doesn't override whether the features are editable server-side. It's just an extra way to block someone without proper credentials from editing data they shouldn't.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fieldInfos</code> (<code class="literal">Objects []</code>, <code class="literal">optional</code>): Gives the developer granular control over<a id="id473" class="indexterm"/> what fields are editable, and how. This <a id="id474" class="indexterm"/>does not allow the user to edit fields that aren't allowed to be edited, according to the publishing method of the feature layer. If this value is not set, the attribute inspector lists all editable fields. <code class="literal">FieldInfo</code> objects contain the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fieldname</code> (<code class="literal">string</code>): The name of the field to be edited</li><li class="listitem" style="list-style-type: disc"><code class="literal">format</code> (<code class="literal">object</code>, <code class="literal">optional</code>): An object that lets you edit time when editing dates. When set, add the following object: <code class="literal">{time: true}</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isEditable</code> (<code class="literal">Boolean</code>, <code class="literal">optional</code>): When set to false, this disables the user's ability to change the value of that field</li><li class="listitem" style="list-style-type: disc"><code class="literal">stringFieldOption</code> (<code class="literal">string</code>, <code class="literal">optional</code>): When set, the user can edit a <code class="literal">string</code> value either in a single-line textbox, a text area with multiple lines, or a rich-text field that includes additional formatting</li><li class="listitem" style="list-style-type: disc"><code class="literal">label</code> (<code class="literal">string</code>, <code class="literal">optional</code>): When set, this lets you override the name of the field alias from the feature service</li><li class="listitem" style="list-style-type: disc"><code class="literal">tooltip</code> (<code class="literal">string</code>, <code class="literal">optional</code>): When set, this shows a text tool tip when the user begins editing the attribute</li></ul></div></li><li class="listitem" style="list-style-type: disc">You can see an example of an attribute inspector being loaded with a single feature layer here:<div class="informalexample"><pre class="programlisting">var layerInfos = [{
  'featureLayer': bananaStandFL,
  'showAttachments': false,
  'isEditable': true,
  'format': {'time': true },
  'fieldInfos': [
    {'fieldName': 'address', 'isEditable':true, 'tooltip': 'Where is it?', 'label':'Address:'},
    {'fieldName': 'time_open', 'isEditable':true, 'tooltip': 'Time the Banana Stand opens.', 'label':'Open:'},
    {'fieldName': 'time_closed', 'isEditable':true, 'tooltip': 'Time the Banana Stand closes.', 'label':'Closed:'},
    {'fieldName': 'is_money_here', 'isEditable':false, 'label':'Is Money Here:', 'tooltip': 'There\'s money in the Banana Stand.'}
  ]
}];

var attInspector = new AttributeInspector({
  layerInfos: layerInfos
}, "edit-attributes-here");

attInspector.startup();</pre></div></li></ul></div><p>While the<a id="id475" class="indexterm"/> attribute inspector allows you to edit the attributes of graphics on a map, it doesn't provide an immediate way to save the edits. It is up to the developer to determine when changes to attributes are saved to the server. The developer could add a save button, or save whenever the feature is no longer selected.</p></div><div class="section" title="Template picker"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Template picker</h2></div></div></div><p>The <a id="id476" class="indexterm"/><span class="strong"><strong>template picker</strong></span> <a id="id477" class="indexterm"/>lets the user select from a list of feature templates to add features to the map. It displays a grid of feature templates from connected feature layers. These templates include feature names, geometry types, and preset styles. The user can click on any of the template buttons, and then draw them on the map. You can load more than one feature layer, and switch between them with ease. You can see an example in the following screenshot:</p><div class="mediaobject"><img src="graphics/6459_05_03.jpg" alt="Template picker" width="397" height="235"/></div><p>The template picker, like <a id="id478" class="indexterm"/>most dijits, requires a parameter object and, either <a id="id479" class="indexterm"/>an HTML element or a string reference to the element's id, in order to load. In the options, the template picker accepts an array of <code class="literal">featureLayers</code>. It also accepts the number of <code class="literal">rows</code> or <code class="literal">columns</code> it will create. If you don't use <code class="literal">featureLayers</code> with their own feature templates, you can define your own using configured items in the <code class="literal">items</code> array. You can also set the CSS style directly. Finally, you can control whether tooltips show when you hover over the symbols. In the following snippet, you can see an example of a template picker initialized:</p><div class="informalexample"><pre class="programlisting">var widget = new TemplatePicker({
  featureLayers: layers,
  rows: "auto",
  columns: 9,
  showTooltip: true,
  style: "height: 100%; width: 900px;"
}, "templatePickerDiv");</pre></div><p>The preceding code shows a template picker with nine columns with tooltips to show data about the <code class="literal">layers</code> loaded in its <code class="literal">featureLayers</code> attribute. The size is 900 pixels wide, and as tall as it needs to be.</p></div><div class="section" title="Attachment editor"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Attachment editor</h2></div></div></div><p>There's an <a id="id480" class="indexterm"/>old saying that a picture is worth a thousand words. Sometimes, you need that picture to explain what data you're submitting. The <span class="strong"><strong>attachment editor</strong></span> <a id="id481" class="indexterm"/>can help. The attachment editor allows the application to upload a file, usually an image, and connect it to the feature on the map. You can view other attachments, and possibly edit them or delete them, if permissions allow. Attachment editors can be loaded as part of the attribute inspector by setting the <code class="literal">showAttachments</code> property in <a id="id482" class="indexterm"/>the attribute editor options to <code class="literal">true</code>, when constructing the<a id="id483" class="indexterm"/> editor:</p><div class="mediaobject"><img src="graphics/6459_05_04.jpg" alt="Attachment editor" width="410" height="202"/></div></div><div class="section" title="Editor dijit"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Editor dijit</h2></div></div></div><p>The <span class="strong"><strong>editor dijit</strong></span> <a id="id484" class="indexterm"/>provides an all-in-one editing tool to create, update, <a id="id485" class="indexterm"/>and delete map features. The editor dijit includes the template picker, attribute inspector, and an editing toolbar with numerous tools. It lets you draw new features on a map, edit existing features, and also delete features.</p><p>The tools that the editor dijit provides are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Feature selection tools, either to add new selections, add to them further, or to remove from existing selections</li><li class="listitem" style="list-style-type: disc">Feature drawing tools, including a tool to delete features from the map</li><li class="listitem" style="list-style-type: disc">Tools that let you cut, merge, and clip parts of polylines and polygons</li><li class="listitem" style="list-style-type: disc">Undo and redo operations (requires versioned map services)</li></ul></div></div><div class="section" title="Snapping manager"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Snapping manager</h2></div></div></div><p>Here's a <a id="id486" class="indexterm"/>common request you might receive when creating <a id="id487" class="indexterm"/>an editing tool: "I'd like a tool that lets me edit this feature based on the lines of this other feature". You could try to code your own tool to select a feature and go through each phase of the feature. Or, with a few additional settings, you could implement the map's <span class="strong"><strong>snapping manager</strong></span>.</p><p>The snapping manager imitates ArcMap snapping controls in the browser . As your mouse pointer approaches the corner or edge of a graphic feature, perhaps in a <code class="literal">GraphicsLayer</code> or a <code class="literal">FeatureLayer</code>, a new pointer moves over the point on the feature. This shows where you would add a point if you clicked on the map. You can click along a set of points, line vertices, or polygon corners to draw something that lines up perfectly with existing features with this tool.</p><p>When<a id="id488" class="indexterm"/> loading the snapping manager, there are a few important options that need to be set. Every snapping manager requires a map to snap to. It also <a id="id489" class="indexterm"/>requires a graphics layer or a feature layer to load, along with information about its snapping behavior. It should know whether to snap to the edge or vertex of a line or polygon, as well as whether to snap to points of a point feature class. All this information is added in a <code class="literal">layerInfo</code> array in its constructor options, or can be added later by using the <code class="literal">setLayerInfos()</code> method.</p><p>There are other optional configurable items in the snapping manager. You can tell the snapping manager to always snap to a graphic, or whether you want to control snapping by holding down a key on the keyboard while clicking. You can also configure which keyboard key is the <code class="literal">snapKey</code>, by loading that property with the appropriate <code class="literal">dojo/keys</code> constant. Finally, the <code class="literal">tolerance</code> of a snapping manager refers to the maximum number of pixels the pointer should be from the feature before it snaps to it.</p><p>You can see an example of a snapping manager loaded in a JavaScript API in the following code:</p><div class="informalexample"><pre class="programlisting">require([…, "esri/SnappingManager", "dojo/keys", …], 
function (…, SnappingManager, dojoKeys …) {

  var propertyLayer = new FeatureLayer({…});
  var sm = new SnappingManager({
    alwaysSnap: false, // default: false
    map: map,
    snapKey: dojoKeys.CTRL, // default: dojoKeys.copyKey
    tolerance: 10, // default: 15
    layerInfo: [{
      layer: propertyLayer, // this is a featureLayer,
      snapToEdge: false, // default: true
      snapToVertex: true //default: true
    }]
  });
  …
});</pre></div><p>The preceding example <a id="id490" class="indexterm"/>shows a snapping manager that turns on when <a id="id491" class="indexterm"/>the user holds down the <span class="emphasis"><em>Ctrl</em></span> key on a PC (the <span class="emphasis"><em>Command</em></span> key on a Mac). It only snaps to the corners of a line or polygon in the <code class="literal">propertyLayer</code> feature layer. The <code class="literal">tolerance</code> for snapping was set to 10 pixels.</p></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Securing editing services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Securing editing services</h1></div></div></div><p>If you're going to<a id="id492" class="indexterm"/> open up your data to be edited by the public, you need to be prepared for trouble. From bad data input to malicious attacks, you, as a developer, need to account for things going wrong. Luckily, ArcGIS Server and the ArcGIS API for JavaScript can help.</p><div class="section" title="Restricting user input"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Restricting user input</h2></div></div></div><p>I remember a project<a id="id493" class="indexterm"/> where we had to let users search for addresses based on a list provided by another system. The other system had no restrictions on what the user could enter. As a result, the address list was anything but normal. On a given street, there could be fifteen different ways the street name could be listed. Some were all caps, while others had "Rd" instead of "Road" Others were misspelled, one m instead of two, and some had too many spaces between the street name and the suffix. Needless to say, the data was poorly constructed and unstandardized.</p><p>ArcGIS Server provides some tools to help you restrict user input. Implementing coded value domains and ranges in the geodatabase can help reduce bad input. The attribute inspector honors field properties such as length and data type. You can set default values to limit extra user input in the feature service feature templates.</p><p>You can also tie in validation and other controls to make sure the user does not accidently do something like add a phone number to a date column. Dojo comes with user controls such as validation textboxes that limit bad input.</p></div><div class="section" title="Password protected services"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Password protected services</h2></div></div></div><p>ArcGIS Server also offers a better <a id="id494" class="indexterm"/>option when it comes to securing your editing services. If you want to restrict access to editing data, you can demand token-based authentication for map services. A <a id="id495" class="indexterm"/><span class="strong"><strong>token</strong></span> is an encrypted string that contains a user name, an expiration date, and extra information for verification purposes. You need to request a token<a id="id496" class="indexterm"/> from <code class="literal">http://myserver/arcgis/tokens</code>, where myServer refers to your ArcGIS Server web endpoint or web adaptor. You submit the necessary user name and password before having the token added as a cookie on your browser. Tokens are only good for a limited time, which can be adjusted through configurable settings in ArcGIS Server.</p><p>These token-based security measures work with both map services and editable feature services. Without the token, you are not able to see the protected map services in the browser. With it, you can explore secured services, query them, and even edit data in them.</p><div class="section" title="Identity manager"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec71"/>Identity manager</h3></div></div></div><p>The <span class="strong"><strong>identity manager</strong></span> <a id="id497" class="indexterm"/>(<code class="literal">esri/IdentityManager</code>) is used to handle logins and the security of ArcGIS <a id="id498" class="indexterm"/>Server and ArcGIS Online services. The identity manager displays a username and password prompt when you attempt to load token-protected services in the browser. Its user interface uses Dojo UI controls, so loading the appropriate Dojo style sheet is necessary to make the identity manager work properly.</p><p>Now that we've reviewed some of the editing capabilities ArcGIS Server offers, let's apply what we've learned to an application.</p></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="A new mapping application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>A new mapping application</h1></div></div></div><p>So, back to our story and <a id="id499" class="indexterm"/>our mapping application. We're still waiting for word from the Y2K society about the Census map, but we have a new application we've been asked to work on. It seems that the city of Hollister, California has asked us to put an app together for them. Let's find out what they want.</p><p>The city of Hollister wants to create an application that lets citizens report issues in the city. They want citizens to report things like graffiti, sidewalk, curb, and street issues, damaged property, sewer issues, and tree problems, on a map, and also supply additional information. If possible, they want photos of the problems so crews know what to look for.</p><div class="section" title="The file setup"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>The file setup</h2></div></div></div><p>We don't need to<a id="id500" class="indexterm"/> create any custom packages because we're going to use the out-of-the-box ArcGIS JavaScript API editing tools,. Instead, we'll create a simple file setup with a <code class="literal">css</code> and a <code class="literal">js</code> folder, We'll add our custom <code class="literal">style.css</code> style sheet in the <code class="literal">css</code> folder, We'll add our <code class="literal">app.js</code> file in the <code class="literal">js</code> folder. We'll also add a folder named <code class="literal">proxy</code> to handle our proxy service. The file structure should look something like the following:</p><div class="mediaobject"><img src="graphics/6459_05_05.jpg" alt="The file setup" width="155" height="129"/></div></div><div class="section" title="The front page"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>The front page</h2></div></div></div><p>Let's start with the<a id="id501" class="indexterm"/> HTML document. We'll use our basic cookie-cutter site. This time, we'll add Dojo's <code class="literal">claro.css</code> style sheet. We don't need any custom packages, so we can leave those out of the <code class="literal">dojoConfig</code> file. We'd like a long column going down the side of the page, and a header part where we'll put the title for the page layout. We'll load the <code class="literal">BorderContainer</code> with a sidebar design with the taller side columns. We'll add three <code class="literal">ContentPanes</code> for the header, a leading column for the buttons, and a center region for the map.</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
     &lt;head&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge" /&gt;
    &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no" /&gt;
    &lt;title&gt;Incident Reporting App&lt;/title&gt;
    &lt;meta name="description" content=""&gt;
    &lt;meta name="author" content="Ken Doman"&gt;
    <span class="strong"><strong>&lt;link rel="stylesheet" href="http://js.arcgis.com/3.13/dijit/themes/claro/claro.css"&gt;</strong></span>
    &lt;link rel="stylesheet" href="https://js.arcgis.com/3.13/esri/css/esri.css" /&gt;
    <span class="strong"><strong>&lt;link rel="stylesheet" href="./css/style.css" /&gt;</strong></span>
    &lt;script type="text/javascript"&gt;
      <span class="strong"><strong>dojoConfig = {</strong></span>
<span class="strong"><strong>        async: true,</strong></span>
<span class="strong"><strong>        isDebug: true</strong></span>
<span class="strong"><strong>      };</strong></span>
    &lt;/script&gt;
    &lt;script src="https://js.arcgis.com/3.13/"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body class="claro"&gt;
    &lt;div id="mainwindow" 
      data-dojo-type="dijit/layout/BorderContainer" 
      data-dojo-props="design:<span class="strong"><strong>'sidebar'</strong></span>, gutter:false" 
      style="width: 100%; height: 100%; margin: 0;"&gt;
        &lt;div data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'top'"&gt;
          &lt;h1&gt;Incident Reporting App&lt;/h1&gt;
        &lt;/div&gt;
        &lt;div id="map" data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'center'"&gt;&lt;/div&gt;
        <span class="strong"><strong>&lt;div id="editpane" style="width: 130px" data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'leading'"&gt;</strong></span>
<span class="strong"><strong>          &lt;div id="editordiv"&gt;&lt;/div&gt;</strong></span>
<span class="strong"><strong>        &lt;/div&gt;</strong></span>
      &lt;/div&gt;
    &lt;script type="text/javascript" src="js/app.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>We'll add some <a id="id502" class="indexterm"/>basic styling for the HTML and the body on the <code class="literal">style.css</code> page. Let's add the following style:</p><div class="informalexample"><pre class="programlisting">html, body {
  width: 100%;
  height: 100%;
  border: 0;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: Helvetica, Arial, sans-serif;
}

*, *:before, *:after { box-sizing: inherit;}</pre></div><p>We've set the <code class="literal">width</code> and <code class="literal">height</code> of the HTML and <code class="literal">body</code> to <code class="literal">100%</code>, with no border, margin, or padding. We've also changed the font to a common <code class="literal">sans-serif</code> font, such as <code class="literal">Helvetica</code>, <code class="literal">Arial</code>, or just plain <code class="literal">sans-serif</code>. Finally, we set the elements on the page to be sized using border-box <code class="literal">box-sizing</code> which makes it easier to work with sizing boxes on the page.</p></div><div class="section" title="Loading the map"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Loading the map</h2></div></div></div><p>We'll begin writing<a id="id503" class="indexterm"/> the code for our application with the page setup. We have a focus area, which is the city of Hollister. For the sake of an easy life, we'll add the city boundaries as an extent:</p><div class="informalexample"><pre class="programlisting">require([
  "dojo/parser", "esri/map", "esri/graphic", 
  "esri/geometry/Extent", "esri/dijit/editing/Editor",
  "esri/dijit/editing/TemplatePicker", "esri/tasks/query",
  "dijit/layout/BorderContainer", "dijit/layout/ContentPane", 
  "dojo/domReady!"
], function (parser, Map, Graphic, Extent,Editor, TemplatePicker, Query) {

  var maxExtent = new Extent({
    "xmin":-13519092.335425414,
    "ymin":4413224.664902497,
    "xmax":-13507741.43672508,
    "ymax":4421766.502813354,
    "spatialReference":{"wkid":102100}
  }),
    map, selected, updateFeature, attInspector;

  parser.parse();

  map = new Map("map", {
    basemap: "osm",
    extent: maxExtent
  });

});</pre></div><p>In the preceding <a id="id504" class="indexterm"/>code, we've loaded the necessary modules and used the <code class="literal">dojo/parser</code> to parse them. We've added a map with the OpenStreetMap based basemap, and we've created a <code class="literal">maxExtent</code> to simulate the city boundaries.</p><div class="section" title="Adding the map layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec72"/>Adding the map layers</h3></div></div></div><p>Now that we have our <a id="id505" class="indexterm"/>map, we need to add layers to the map. For the sake of this exercise, we're going to use the San Francisco 311 Feature Service provided by ESRI. We're going to load the feature layer in selection mode, so we only affect the features we click on. We're also going to add the complementary dynamic map service, because we can't see the features without it. We will also set the feature layer selection symbol using a simple marker symbol to color the features we click on:</p><div class="informalexample"><pre class="programlisting">require([
  …, 
  "esri/layers/FeatureLayer",
  "esri/layers/ArcGISDynamicMapServiceLayer",
  "esri/symbols/SimpleMarkerSymbol",
…
], function (…, 
  FeatureLayer, ArcGISDynamicMapServiceLayer, 
  MarkerSymbol, … 
) {
  var maxExtent = …,
    map, incidentLayer, visibleIncidentLayer;
  …
  incidentLayer = new FeatureLayer("http://sampleserver3.arcgisonline.com/ArcGIS/rest/services/SanFrancisco/311Incidents/FeatureServer/0", {
    mode: FeatureLayer.MODE_SELECTION,
    outFields: ["req_type","req_date","req_time","address","district", "status"],
    id: "incidentLayer"
  });
  
  visibleIncidentLayer = new ArcGISDynamicMapServiceLayer( "http://sampleserver3.arcgisonline.com/ArcGIS/rest/services/SanFrancisco/311Incidents/MapServer");
  …
  map.addLayers([visibleIncidentLayer, incidentLayer]);</pre></div><p>When the map<a id="id506" class="indexterm"/> layers are added, we can finally interact with them, both as a user and as a developer. We'll add an event listener called <code class="literal">startEditing()</code> to the map's <code class="literal">layers-add-result</code> event. We'll set up the editing events for the feature layer there. We'll add a map click event that draws a feature if something has been selected from the menu on the side of the page. Be sure to add this after the layers are defined, but before they are added to the map.</p><div class="informalexample"><pre class="programlisting">var …, incidentLayer, visibleIncidentLayer, <span class="strong"><strong>selected</strong></span>;

visibleIncidentLayer = …;

<span class="strong"><strong>function startEditing () {</strong></span>
<span class="strong"><strong>  var incidentLayer = map.getLayer("incidentLayer");</strong></span>
<span class="strong"><strong>  // add map click event to create the new editable feature</strong></span>
<span class="strong"><strong>  map.on("click", function(evt) {</strong></span>
<span class="strong"><strong>     // if a feature template has been selected.</strong></span>
<span class="strong"><strong>    if (selected) {</strong></span>
<span class="strong"><strong>      var currentDate = new Date();</strong></span>
<span class="strong"><strong>      var incidentAttributes = {</strong></span>
<span class="strong"><strong>        req_type: selected.template.name,</strong></span>
<span class="strong"><strong>        req_date:(currentDate.getMonth() + 1) + "/" + currenDate.getDate() + "/" + currentDate.getFullYear(),</strong></span>
<span class="strong"><strong>        req_time: currentDate.toLocaleTimeString(),</strong></span>
<span class="strong"><strong>        address: "",</strong></span>
<span class="strong"><strong>        district: "",</strong></span>
<span class="strong"><strong>        status: 1</strong></span>
<span class="strong"><strong>      };</strong></span>
<span class="strong"><strong>      var incidentGraphic = new Graphic(evt.mapPoint, selected.symbol, incidentAttributes);</strong></span>
<span class="strong"><strong>      incidentLayer.applyEdits([incidentGraphic],null,null) </strong></span>
<span class="strong"><strong>    } </strong></span>
<span class="strong"><strong>  });</strong></span>

<span class="strong"><strong>  incidentLayer.setSelectionSymbol(</strong></span>
<span class="strong"><strong>    new MarkerSymbol({color:[255,0,0]})</strong></span>
<span class="strong"><strong>  );</strong></span>

<span class="strong"><strong>  map.infoWindow.on("hide", function() {</strong></span>
<span class="strong"><strong>    incidentLayer.clearSelection();</strong></span>
<span class="strong"><strong>  });</strong></span>
<span class="strong"><strong>}</strong></span>

<span class="strong"><strong>incidentLayer.on("edits-complete", function() {</strong></span>
<span class="strong"><strong>  visibleIncidentLayer.refresh();</strong></span>
<span class="strong"><strong>});</strong></span>

<span class="strong"><strong>map.on("layers-add-result", startEditing);</strong></span>
map.addLayers([visibleIncidentLayer, incidentLayer]);</pre></div><p>In the preceding <a id="id507" class="indexterm"/>code, we've created a <code class="literal">callback</code> function called <code class="literal">startEditing()</code>. This causes the application to add a new graphic to the editable feature layer whenever the map is clicked. Default attributes and a symbol are applied to the editable feature. The editable feature layer clears its selection whenever the popup is hidden. Also, when the edits are complete, the visible layer is refreshed with the new data. The <code class="literal">startEditing()</code> method is assigned to run when a group of layers are added, which causes the layers to be added to the map.</p></div><div class="section" title="Using the proxy"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec73"/>Using the proxy</h3></div></div></div><p>If you try to<a id="id508" class="indexterm"/> load the map right now, you may get an error. If you don't get it now, you might get it when you try to save changes on the map. The reason is that these editing operations often require a proxy application to handle data which is too large to fit in the approximately 2,048 character limit of most browser get requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>You can follow the instructions ESRI provides to set up a <a id="id509" class="indexterm"/>proxy service at <a class="ulink" href="https://developers.arcgis.com/javascript/jshelp/ags_proxy.html">https://developers.arcgis.com/javascript/jshelp/ags_proxy.html</a>.</p></div></div><p>Proxies come in <a id="id510" class="indexterm"/>three varieties, based on your application environment. ESRI provides proxy services in PHP, Java, and .Net. We'll add a reference to the proxy in our application. This example shows how it's done with a .Net based proxy:</p><div class="informalexample"><pre class="programlisting">require([
  …, 
  "esri/config",
  "esri/layers/FeatureLayer",
  "esri/layers/ArcGISDynamicMapServiceLayer",
  "esri/symbols/SimpleMarkerSymbol",
…
], function (…, esriConfig, …) {
  …
  // set up proxy for the featureLayer
  esriConfig.defaults.io.proxyUrl = "./proxy/proxy.ashx";

  incidentLayer = …</pre></div></div><div class="section" title="Finding the user's location"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec74"/>Finding the user's location</h3></div></div></div><p>Our client requested that the app provide the user with the ability to find them on the map, should they be using a mobile device or a laptop on Wi-Fi. We can provide that functionality by adding an ArcGIS dijit called <code class="literal">LocateButton</code>. We load the module in our application, initialize it when the map is ready, and it's good to go. The code to load it should look something like this:</p><div class="informalexample"><pre class="programlisting">require([…, "esri/dijit/LocateButton", …
], function (…, LocateButton, …) {
  …
  function startEditing() {
    // add the Locate button
     var locator = new LocateButton({map: map}, "locatebutton");
  }
  …
});</pre></div><p>If we insert a <code class="literal">&lt;div&gt;</code> with an <code class="literal">id</code> of <code class="literal">locatebutton</code> inside the map <code class="literal">ContentPane</code>, and view the page in our browser, we'll see the locate button above the map, pushing the map down. We'd much rather locate it near the other zoom in and out buttons. We'll add the following styling to the <code class="literal">style.css</code> sheet to achieve that:</p><div class="informalexample"><pre class="programlisting">.LocateButton {
  position: absolute;
  left: 29px;
  top: 120px;
  z-index: 500;
}</pre></div></div></div><div class="section" title="The template picker"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>The template picker</h2></div></div></div><p>For our <a id="id511" class="indexterm"/>application, we're going to use the ArcGIS JavaScript API's template picker to select incident point types to add to the map. We'll load them in the side pane on the page, and make them one column wide to add features. We'll pass that feature template to the <code class="literal">selected</code> variable when the feature template is selected. Finally, we'll load all this when both the map and the feature layers have loaded:</p><div class="informalexample"><pre class="programlisting">  function generateTemplatePicker(layer) {
    console.log("layer", layer);
    var widget = new TemplatePicker({
      featureLayers: [ layer ],
      rows: layer.types.length,
      columns: 1,
      grouping: false,
      style: "width:98%;"
    }, "editordiv");

    widget.startup();

    widget.on("selection-change", function() {
      selected = widget.getSelected();
      console.log("selected", selected);
    });
  }
…
function startEditing () {
  var incidentLayer = map.getLayer("incidentLayer");
  generateTemplatePicker(incidentLayer);
  …</pre></div></div><div class="section" title="The attribute inspector"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>The attribute inspector</h2></div></div></div><p>Now that we <a id="id512" class="indexterm"/>are able to add new features to the map, we need a way to edit the content of those features. To do that, we'll add the attribute inspector. We're going to initialize the attribute inspector and tie it to the map's <code class="literal">infoWindow</code>.</p><div class="informalexample"><pre class="programlisting">require([…,
  "dojo/dom-construct",
  "esri/dijit/AttributeInspector",
  "dijit/form/Button",
  …
], function (…, domConstruct, AttributeInspector, Button, …) {
  var maxExtent = …,
    map, incidentLayer, visibleIncidentLayer, selected, 
    attInspector, updateFeature;
…
function generateAttributeInspector(layer) {
  var layerInfos = [{
    featureLayer: layer,
    showAttachments: true,
    isEditable: true,
  }];

  attInspector = new AttributeInspector({
    layerInfos: layerInfos
  }, domConstruct.create("div", null, document.body));

  attInspector.startup();

  //add a save button next to the delete button
  var saveButton = new Button({ label: "Save", "class": "saveButton"});
  domConstruct.place(saveButton.domNode, attInspector.deleteBtn.domNode, "after");

  saveButton.on("click", function(){
    updateFeature.getLayer().applyEdits(
      null, [updateFeature], null
    );
  });

  attInspector.on("attribute-change", function(evt) {
    //store the updates to apply when the save button is clicked
    updateFeature.attributes[evt.fieldName] = evt.fieldValue;
  });

  attInspector.on("next", function(evt) {
    updateFeature = evt.feature;
    console.log("Next " + updateFeature.attributes.objectid);
  });

  attInspector.on("delete", function(evt){
    evt.feature.getLayer().applyEdits(
      null, null, [updateFeature]
    );
    map.infoWindow.hide();
  });

  if (attInspector.domNode) {
    map.infoWindow.setContent(attInspector.domNode);
    map.infoWindow.resize(350, 240);
  }

}
…
function startEditing () {
  var incidentLayer = map.getLayer("incidentLayer");
  generateTemplatePicker(incidentLayer);
<span class="strong"><strong>  generateAttributeInspector(incidentLayer);</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>We'll need to add a <a id="id513" class="indexterm"/>little positioning style to the save button on the attribute inspector. We'll add this entry to position the save button in the <code class="literal">style.css</code> sheet so that it doesn't overlap the delete button.</p><div class="informalexample"><pre class="programlisting">.saveButton {
  margin: 0 0 0 48px;
}</pre></div><p>Now that the attribute inspector is loaded, we can incorporate it into the click events for both the map layer and the incident layer. We'll create a <code class="literal">showInspector()</code> function that accepts a map click event. It will query the <code class="literal">incidentLayer</code> for any features in that location, and pull up a map <code class="literal">infoWindow</code> with the attribute inspector inside. It will also assign the selected graphic (if any) to:</p><div class="informalexample"><pre class="programlisting">…
  function showInspector(evt) {
     var selectQuery = new Query(),
       point = evt.mapPoint,
       mapScale = map.getScale();

    selectQuery.geometry = evt.mapPoint;

    incidentLayer.selectFeatures(selectQuery, FeatureLayer.SELECTION_NEW, function (features) {
      if (!features.length) {
        map.infoWindow.hide();
        return;
      }

      updateFeature = features[0];

      map.infoWindow.setTitle(updateFeature.getLayer().name);
      map.infoWindow.show(evt.screenPoint, map.getInfoWindowAnchor(evt.screenPoint));
    });
  }
…
function startEditing() {
  …
  map.on("click", function (evt) {
    …
    if (selected) {
      …
      incidentLayer.applyEdits([incidentGraphic],null,null)
        .then(function () {
          showInspector(evt);
        });

    } else {
      showInspector(evt);
    }
  …
  }); 
…
  incidentLayer.on("click", showInspector);</pre></div><p>The result of the <a id="id514" class="indexterm"/>preceding code is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6459_05_06.jpg" alt="The attribute inspector" width="675" height="509"/></div></div><div class="section" title="Securing the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Securing the application</h2></div></div></div><p>Now that we have a working <a id="id515" class="indexterm"/>incident reporting application, it's time to think about how we can secure the application. It's a public application, so the public should be allowed to submit problems. However, we don't want data that doesn't fit our data schema, or our representative boundaries.</p><p>One way we can secure our application from bad input is to restrict the locations where we accept changes. We don't want employee time wasted investigating complaints logged outside the city, state, or even country. We can do this by using the city extent supplied at the beginning of the application. We can test if the clicked point is inside the city extent in the click event, and notify the client if it's not. That should look something like the following:</p><div class="informalexample"><pre class="programlisting">…
map.on("click", function (evt) {
  // if the clicked point isn't inside the maxExtent
  if (!maxExtent.contains(evt.mapPoint)) {
    alert("Sorry, that point is outside our area of interest.");
    return; // disregard the click
  }
…</pre></div><p>Speaking of working with extents, we could also lock the selection buttons when navigating outside the city area. This would alert the user that we aren't accepting complaints outside the city proper. Of course, we should notify the user why they are locked out.</p><p>We'll start by adding blocking content and notifications in the HTML. We'll add two <code class="literal">divs</code> to the page, a <code class="literal">&lt;div&gt;</code> with the id <code class="literal">outsidemessage</code> in the map, and a div with the id <code class="literal">blockerdiv</code> next to the <a id="id516" class="indexterm"/>editor <code class="literal">div</code>. We'll leave the two of them hidden by default, by adding the inline style <code class="literal">display: none</code>. It should look like the following:</p><div class="informalexample"><pre class="programlisting">…
&lt;div id="map" data-dojo-type="dijit/layout/ContentPane" data-dojo-props="region:'center'" &gt;
  &lt;div id="locatebutton"&gt;&lt;/div&gt;
  <span class="strong"><strong>&lt;div id="outsidemessage" style="display:none;"&gt;</strong></span>
<span class="strong"><strong>    &lt;p&gt;Sorry, but you have navigated outside our city. Click on this message to get back to the city.&lt;/p&gt;</strong></span>
<span class="strong"><strong>  &lt;/div&gt;</strong></span>
&lt;/div&gt;
&lt;div id="editpane" style="width: 130px" 
  data-dojo-type="dijit/layout/ContentPane" 
  data-dojo-props="region:'leading'"&gt;
  &lt;div id="editordiv"&gt;&lt;/div&gt;
  <span class="strong"><strong>&lt;div id="blockerdiv" style="display:none;"&gt;&lt;/div&gt;</strong></span>
&lt;/div&gt;</pre></div><p>We'll add the following styling to the <code class="literal">style.css</code> file to style these items. The outside message will be gray block floating in the lower middle portion of the map, with text big enough to read, and with rounded corners (because lots of people like rounded corners). The blocking <code class="literal">div</code> will be positioned directly on top of the template picker buttons. The blocking <code class="literal">div</code> will be light gray, semi-transparent, and cover the entire template picker when visible.</p><div class="informalexample"><pre class="programlisting">#blockerdiv {
  width: 100%;
  background: rgba(188, 188, 188, 0.6);
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  z-index: 500;
}

#outsidemessage {
  position: absolute;
  bottom: 40px;
  left: 50%;
  width: 200px;
  height: auto;
  margin: 0 0 0 -100px;
  background: rgba(255,255,255,0.8);
  padding: 8px;
  z-index: 500;
  border-radius: 8px;
  text-align: center;
  font-weight: bold;
}</pre></div><p>We'll add some code to <a id="id517" class="indexterm"/>our <code class="literal">app.js</code> file to handle the visibility of these two nodes. We can listen for changes in the map's extent. When the map's extent is outside the city extent, and they no longer intersect, both the message div and the blocker div will be made visible (<code class="literal">display: block;</code>). If the user can see some of the extent of the viewing area, the <code class="literal">div</code> objects will be hidden again (<code class="literal">display: none;</code>). It should look like this:</p><div class="informalexample"><pre class="programlisting">require([…, "dojo/dom-style", …
], function (…, domStyle, …) {

function onMapExtentChange (response) {
  if (!response.extent.intersects(maxExtent)) {
     // show these blocks if the map extent is outside the 
    // city extent
     domStyle.set("blockerdiv", "display", "block");
     domStyle.set("outsidemessage", "display", "block");
  } else {
     // hide these blocks if the max Extent is visible within 
    // the view.
     domStyle.set("blockerdiv", "display", "none");
     domStyle.set("outsidemessage", "display", "none");
  }
}

map.on("extent-change", onMapExtentChange);
…</pre></div><p>We'll also add an event handler to the outside message <code class="literal">div</code> that lets the user click to go back to the starting location for the map. We'll load the <code class="literal">dojo/on</code> event to handle the <code class="literal">click</code> event:</p><div class="informalexample"><pre class="programlisting">require([…, "dojo/dom", "dojo/on", …
], function (…, dojoDom, dojoOn, …) {
  …
  dojoOn(dojoDom.byId("outsidemessage"), "click", function () {
    map.setExtent(maxExtent);
  })
  …
});</pre></div><p>Now, when we load our <a id="id518" class="indexterm"/>application and pan our way outside the city limits, the following message should appear:</p><div class="mediaobject"><img src="graphics/6459_05_07.jpg" alt="Securing the application" width="664" height="494"/></div><div class="section" title="Limiting data entry"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec75"/>Limiting data entry</h3></div></div></div><p>As well as <a id="id519" class="indexterm"/>stopping bad user input from clicks, we should also consider stopping bad user input from text editing. We can pull that off by modifying the <code class="literal">layerInfos</code> array assigned to the attribute inspector. We'll start by getting rid of the delete button, since we don't want citizens deleting everybody else's complaints. We'll also modify the <code class="literal">fieldInfos</code> list and set some of the fields to display only when they are edited in the attribute inspector. In this case, we'll leave the <code class="literal">req_type</code>, address, and district tabs open for editing.</p><div class="informalexample"><pre class="programlisting">var layerInfos = [{
      featureLayer: layer,
      showAttachments: true,
      isEditable: true,
      showDeleteButton: false,
      fieldInfos: [
        {'fieldName': 'req_type', 'isEditable':true, 'tooltip': 'What\'s wrong?', 'label':'Status:'},
        {'fieldName': 'req_date', 'isEditable':false, 'tooltip': 'Date incident was reported.', 'label':'Date:'},
        {'fieldName': 'req_time', 'isEditable':false,'label':'Time:'},
        {'fieldName': 'address', 'isEditable':true, 'label':'Address:'},
        {'fieldName': 'district', 'isEditable':true, 'label':'District:'},
        {'fieldName': 'status', 'isEditable':false, 'label':'Status:'}
      ]
    }];</pre></div><p>These are a few <a id="id520" class="indexterm"/>of the simple things we can do to help secure our application against unwanted results, and yet still make the application user-friendly to the general public.</p></div></div></div></div></div>
<div id="book-content"><div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Summary</h1></div></div></div><p>In this chapter, we've examined the tools and processes that ArcGIS Server and the ArcGIS API for JavaScript provide to make web editing possible. We looked at what goes into an editable feature service. We also looked into the various widgets that come with the ArcGIS JavaScript API for adding new features, editing geometries, and editing property attributes. We finished by creating an application that uses the editing tools to create an incident reporting application, with which users can report problems in the city on the map.</p><p>In the next chapter, we'll take the existing data and add a graphical twist.</p></div></div></div></body></html>