["```py\nfrom . import data\nfrom . import loader\nfrom . import saver\n```", "```py\n# import builtins\nimport sys, os, itertools, operator\nfrom collections import OrderedDict\nimport datetime\n\n# import shapely geometry compatibility functions\n# ...and rename them for clarity\nimport shapely\nfrom shapely.geometry import asShape as geojson2shapely\n\n# import rtree for spatial indexing\nimport rtree\n\n# import internal modules\nfrom . import loader\nfrom . import saver\n```", "```py\ndef ID_generator():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\nclass VectorData:\n    def __init__(self, filepath=None, type=None, **kwargs):\n        self.filepath = filepath\n\n        # type is optional and will make the features ensure that all geometries are of that type\n        # if None, type enforcement will be based on first geometry found\n        self.type = type\n\n        if filepath:\n            fields,rows,geometries,crs = loader.from_file(filepath, **kwargs)\n        else:\n            fields,rows,geometries,crs = [],[],[],\"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"\n\n        self.fields = fields\n\n        self._id_generator = ID_generator()\n\n        ids_rows_geoms = itertools.izip(self._id_generator,rows,geometries)\n        featureobjs = (Feature(self,row,geom,id=id) for id,row,geom in ids_rows_geoms )\n        self.features = OrderedDict([ (feat.id,feat) for feat in featureobjs ])\n        self.crs = crs\n\n    def __len__(self):\n        \"\"\"\n        How many features in data.\n        \"\"\"\n        return len(self.features)\n\n    def __iter__(self):\n        \"\"\"\n        Loop through features in order.\n        \"\"\"\n        for feat in self.features.itervalues():\n            yield feat\n\n    def __getitem__(self, i):\n        \"\"\"\n        Get a Feature based on its feature id.\n        \"\"\"\n        if isinstance(i, slice):\n            raise Exception(\"Can only get one feature at a time\")\n        else:\n            return self.features[i]\n\n    def __setitem__(self, i, feature):\n        \"\"\"\n        Set a Feature based on its feature id.\n        \"\"\"\n        if isinstance(i, slice):\n            raise Exception(\"Can only set one feature at a time\")\n        else:\n            self.features[i] = feature\n\n    ### DATA ###\n\n    def add_feature(self, row, geometry):\n        feature = Feature(self, row, geometry)\n        self[feature.id] = feature\n    def copy(self):\n        new = VectorData()\n        new.fields = [field for field in self.fields]\n        featureobjs = (Feature(new, feat.row, feat.geometry) for feat in self )\n        new.features = OrderedDict([ (feat.id,feat) for feat in featureobjs ])\n        if hasattr(self, \"spindex\"): new.spindex = self.spindex.copy()\n        return new\n```", "```py\nclass Feature:\n    def __init__(self, data, row, geometry, id=None):\n        \"geometry must be a geojson dictionary\"\n        self._data = data\n        self.row  = list(row)\n\n        self.geometry = geometry.copy()\n\n        # ensure it is same geometry type as parent\n        geotype = self.geometry[\"type\"]\n        if self._data.type: \n            if \"Point\" in geotype and self._data.type == \"Point\": pass\n            elif \"LineString\" in geotype and self._data.type == \"LineString\": pass\n            elif \"Polygon\" in geotype and self._data.type == \"Polygon\": pass\n            else: raise TypeError(\"Each feature geometry must be of the same type as the file it is attached to\")\n        else: self._data.type = self.geometry[\"type\"].replace(\"Multi\", \"\")\n\n        if id == None: id = next(self._data._id_generator)\n        self.id = id\n\n    def __getitem__(self, i):\n        if isinstance(i, (str,unicode)):\n            i = self._data.fields.index(i)\n        return self.row[i]\n\n    def __setitem__(self, i, setvalue):\n        if isinstance(i, (str,unicode)):\n            i = self._data.fields.index(i)\n        self.row[i] = setvalue\n\n    def get_shapely(self):\n        return geojson2shapely(self.geometry)\n\n    def copy(self):\n        geoj = self.geometry\n        if self._cached_bbox: geoj[\"bbox\"] = self._cached_bbox\n        return Feature(self._data, self.row, geoj) \n```", "```py\n        bbox = geometry.get(\"bbox\")\n        self._cached_bbox = bbox\n```", "```py\n    @property\n    def bbox(self):\n        if not self._cached_bbox:\n            geotype = self.geometry[\"type\"]\n            coords = self.geometry[\"coordinates\"]\n\n            if geotype == \"Point\":\n                x,y = coords\n                bbox = [x,y,x,y]\n            elif geotype in (\"MultiPoint\",\"LineString\"):\n                xs, ys = itertools.izip(*coords)\n                bbox = [min(xs),min(ys),max(xs),max(ys)]\n            elif geotype == \"MultiLineString\":\n                xs = [x for line in coords for x,y in line]\n                ys = [y for line in coords for x,y in line]\n                bbox = [min(xs),min(ys),max(xs),max(ys)]\n            elif geotype == \"Polygon\":\n                exterior = coords[0]\n                xs, ys = itertools.izip(*exterior)\n                bbox = [min(xs),min(ys),max(xs),max(ys)]\n            elif geotype == \"MultiPolygon\":\n                xs = [x for poly in coords for x,y in poly[0]]\n                ys = [y for poly in coords for x,y in poly[0]]\n                bbox = [min(xs),min(ys),max(xs),max(ys)]\n            self._cached_bbox = bbox\n        return self._cached_bbox\n```", "```py\n    @property\n    def bbox(self):\n        xmins, ymins, xmaxs, ymaxs = itertools.izip(*(feat.bbox for feat in self))\n        xmin, xmax = min(xmins), max(xmaxs)\n        ymin, ymax = min(ymins), max(ymaxs)\n        bbox = (xmin, ymin, xmax, ymax)\n        return bbox\n```", "```py\n    def create_spatial_index(self):\n        \"\"\"Allows quick overlap search methods\"\"\"\n        self.spindex = rtree.index.Index()\n        for feat in self:\n            self.spindex.insert(feat.id, feat.bbox)\n```", "```py\n    def quick_overlap(self, bbox):\n        \"\"\"\n        Quickly get features whose bbox overlap the specified bbox via the spatial index.\n        \"\"\"\n        if not hasattr(self, \"spindex\"):\n            raise Exception(\"You need to create the spatial index before you can use this method\")\n        # ensure min,min,max,max pattern\n        xs = bbox[0],bbox[2]\n        ys = bbox[1],bbox[3]\n        bbox = [min(xs),min(ys),max(xs),max(ys)]\n        # return generator over results\n        results = self.spindex.intersection(bbox)\n        return (self[id] for id in results)\n\n    def quick_nearest(self, bbox, n=1):\n        \"\"\"\n        Quickly get n features whose bbox are nearest the specified bbox via the spatial index.\n        \"\"\"\n        if not hasattr(self, \"spindex\"):\n            raise Exception(\"You need to create the spatial index before you can use this method\")\n        # ensure min,min,max,max pattern\n        xs = bbox[0],bbox[2]\n        ys = bbox[1],bbox[3]\n        bbox = [min(xs),min(ys),max(xs),max(ys)]\n        # return generator over results\n        results = self.spindex.nearest(bbox, num_results=n)\n        return (self[id] for id in results)\n```", "```py\n# import builtins\nimport os\n\n# import fileformat modules\nimport shapefile as pyshp\nimport pygeoj\n```", "```py\ndef from_file(filepath, encoding=\"utf8\"):\n\n    def decode(value):\n        if isinstance(value, str): \n            return value.decode(encoding)\n        else: return value\n```", "```py\n    # shapefile\n    if filepath.endswith(\".shp\"):\n        shapereader = pyshp.Reader(filepath)\n\n        # load fields, rows, and geometries\n        fields = [decode(fieldinfo[0]) for fieldinfo in shapereader.fields[1:]]\n        rows = [ [decode(value) for value in record] for record in shapereader.iterRecords()]\n        def getgeoj(obj):\n            geoj = obj.__geo_interface__\n            if hasattr(obj, \"bbox\"): geoj[\"bbox\"] = obj.bbox\n            return geoj\n        geometries = [getgeoj(shape) for shape in shapereader.iterShapes()]\n\n        # load projection string from .prj file if exists\n        if os.path.lexists(filepath[:-4] + \".prj\"):\n            crs = open(filepath[:-4] + \".prj\", \"r\").read()\n        else: crs = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"\n\n        return fields, rows, geometries, crs\n```", "```py\n    # geojson file\n    elif filepath.endswith((\".geojson\",\".json\")):\n        geojfile = pygeoj.load(filepath)\n\n        # load fields, rows, and geometries\n        fields = [decode(field) for field in geojfile.common_attributes]\n        rows = [[decode(feat.properties[field]) for field in fields] for feat in geojfile]\n        geometries = [feat.geometry.__geo_interface__ for feat in geojfile]\n\n        # load projection\n        crs = geojfile.crs\n\n        return fields, rows, geometries, crs \n```", "```py\n    else:\n        raise Exception(\"Could not create vector data from the given filepath: the filetype extension is either missing or not supported\")\n```", "```py\n# import builtins\nimport itertools\n\n# import fileformats\nimport shapefile as pyshp\nimport pygeoj\n```", "```py\ndef to_file(fields, rows, geometries, filepath, encoding=\"utf8\"):\n\n    def encode(value):\n        if isinstance(value, (float,int)):\n            # nrs are kept as nrs\n            return value\n        elif isinstance(value, unicode):\n            # unicode is custom encoded into bytestring\n            return value.encode(encoding)\n        else:\n            # brute force anything else to string representation\n            return bytes(value)\n```", "```py\n    # shapefile\n    if filepath.endswith(\".shp\"):\n        shapewriter = pyshp.Writer()\n\n        # set fields with correct fieldtype\n        for fieldindex,fieldname in enumerate(fields):\n            for row in rows:\n                value = row[fieldindex]\n                if value != \"\":\n                    try:\n                        # make nr fieldtype if content can be made into nr\n                        float(value)\n                        fieldtype = \"N\"\n                        fieldlen = 16\n                        decimals = 8\n                    except:\n                        # but turn to text if any of the cells cannot be made to float bc they are txt\n                        fieldtype = \"C\"\n                        fieldlen = 250\n                        decimals = 0\n                        break\n                else:\n                    # empty value, so just keep assuming nr type\n                    fieldtype = \"N\"\n                    fieldlen = 16\n                    decimals = 8\n            # clean fieldname\n            fieldname = fieldname.replace(\" \",\"_\")[:10]\n            # write field\n            shapewriter.field(fieldname.encode(encoding), fieldtype, fieldlen, decimals)\n\n        # convert geojson to shape\n        def geoj2shape(geoj):\n            # create empty pyshp shape\n            shape = pyshp._Shape()\n            # set shapetype\n            geojtype = geoj[\"type\"]\n            if geojtype == \"Null\":\n                pyshptype = pyshp.NULL\n            elif geojtype == \"Point\":\n                pyshptype = pyshp.POINT\n            elif geojtype == \"LineString\":\n                pyshptype = pyshp.POLYLINE\n            elif geojtype == \"Polygon\":\n                pyshptype = pyshp.POLYGON\n            elif geojtype == \"MultiPoint\":\n                pyshptype = pyshp.MULTIPOINT\n            elif geojtype == \"MultiLineString\":\n                pyshptype = pyshp.POLYLINE\n            elif geojtype == \"MultiPolygon\":\n                pyshptype = pyshp.POLYGON\n            shape.shapeType = pyshptype\n\n            # set points and parts\n            if geojtype == \"Point\":\n                shape.points = [ geoj[\"coordinates\"] ]\n                shape.parts = [0]\n            elif geojtype in (\"MultiPoint\",\"LineString\"):\n                shape.points = geoj[\"coordinates\"]\n                shape.parts = [0]\n            elif geojtype in (\"Polygon\"):\n                points = []\n                parts = []\n                index = 0\n                for ext_or_hole in geoj[\"coordinates\"]:\n                    points.extend(ext_or_hole)\n                    parts.append(index)\n                    index += len(ext_or_hole)\n                shape.points = points\n                shape.parts = parts\n            elif geojtype in (\"MultiLineString\"):\n                points = []\n                parts = []\n                index = 0\n                for linestring in geoj[\"coordinates\"]:\n                    points.extend(linestring)\n                    parts.append(index)\n                    index += len(linestring)\n                shape.points = points\n                shape.parts = parts\n            elif geojtype in (\"MultiPolygon\"):\n                points = []\n                parts = []\n                index = 0\n                for polygon in geoj[\"coordinates\"]:\n                    for ext_or_hole in polygon:\n                        points.extend(ext_or_hole)\n                        parts.append(index)\n                        index += len(ext_or_hole)\n                shape.points = points\n                shape.parts = parts\n            return shape\n\n        # iterate through original shapes\n        for row,geom in itertools.izip(rows, geometries):\n            shape = geoj2shape(geom)\n            shapewriter._shapes.append(shape)\n            shapewriter.record(*[encode(value) for value in row])\n\n        # save\n        shapewriter.save(filepath)\n```", "```py\n    # GeoJSON file\n    elif filepath.endswith((\".geojson\",\".json\")):\n        geojwriter = pygeoj.new()        \n        for row,geom in itertools.izip(rows,geometries):\n            # encode row values\n            row = (encode(value) for value in row)\n            rowdict = dict(zip(fields, row))\n            # add feature\n            geojwriter.add_feature(properties=rowdict,\n                                   geometry=geom)\n\n        # save\n        geojwriter.save(filepath) \n```", "```py\n    else:\n        raise Exception(\"Could not save the vector data to the given filepath: the filetype extension is either missing or not supported\") \n```", "```py\nfrom . import data\nfrom . import loader\nfrom . import saver\n```", "```py\n# import builtins\nimport sys, os, itertools, operator\n\n# import internals\nfrom . import loader\nfrom . import saver\n\n# import PIL as the data container\nimport PIL.Image, PIL.ImageMath\n```", "```py\nclass Cell:\n    def __init__(self, band, col, row):\n        self.band = band\n        self.col, self.row = col, row\n\n    def __repr__(self):\n        return \"Cell(col=%s, row=%s, value=%s)\" %(self.col, self.row, self.value)\n\n    @property\n    def value(self):\n        return self.band.cells[self.col, self.row]\n\nclass Band:\n    def __init__(self, img, cells):\n        self.img = img\n        self.cells = cells\n\n    def __iter__(self):\n        width,height = self.img.size\n        for row in range(height):\n            for col in range(width):\n                yield Cell(self, col, row)\n\n    def get(self, col, row):\n        return Cell(self, col, row)\n\n    def set(self, col, row, value):\n        self.cells[col,row] = value\n\n    def copy(self):\n        img = self.img.copy()\n        cells = img.load()\n        return Band(img, cells)\n\nclass RasterData:\n    def __init__(self, filepath=None, data=None, image=None, **kwargs):\n        self.filepath = filepath\n\n        if filepath:\n            info, bands, crs = loader.from_file(filepath)\n        elif data:\n            info, bands, crs = loader.from_lists(data, **kwargs)\n        elif image:\n            info, bands, crs = loader.from_image(image, **kwargs)\n        else:\n            info, bands, crs = loader.new(**kwargs)\n\n        self.bands = [Band(img,cells) for img,cells in bands]\n\n        self.info = info\n\n        self.crs = crs\n\n        self.update_geotransform()\n\n    def __iter__(self):\n        for band in self.bands:\n            yield band\n\n    @property\n    def width(self):\n        return self.bands[0].img.size[0]\n\n    @property\n    def height(self):\n        return self.bands[0].img.size[1]\n\n    def copy(self):\n        new = RasterData(width=self.width, height=self.height, **self.info)\n        new.bands = [band.copy() for band in self.bands]\n        new._cached_mask = self.mask\n        return new\n```", "```py\n    def cell_to_geo(self, column, row):\n        [xscale, xskew, xoffset, yskew, yscale, yoffset] = self.transform_coeffs\n        x, y = column, row\n        x_coord = x*xscale + y*xskew + xoffset\n        y_coord = x*yskew + y*yscale + yoffset\n        return x_coord, y_coord\n\n    def geo_to_cell(self, x, y, fraction=False):\n        [xscale, xskew, xoffset, yskew, yscale, yoffset] = self.inv_transform_coeffs\n        column = x*xscale + y*xskew + xoffset\n        row = x*yskew + y*yscale + yoffset\n        if not fraction:\n            # round to nearest cell\n            column,row = int(round(column)), int(round(row))\n        return column,row\n\n    @property\n    def bbox(self):\n        # get corner coordinates of raster\n        xleft_coord,ytop_coord = self.cell_to_geo(0,0)\n        xright_coord,ybottom_coord = self.cell_to_geo(self.width, self.height)\n        return [xleft_coord,ytop_coord,xright_coord,ybottom_coord]\n\n    def update_geotransform(self):\n        info = self.info\n\n        # get coefficients needed to convert from raster to geographic space\n        if info.get(\"transform_coeffs\"):\n            [xscale, xskew, xoffset,\n             yskew, yscale, yoffset] = info[\"transform_coeffs\"]\n        else:\n            xcell,ycell = info[\"xy_cell\"]\n            xgeo,ygeo = info[\"xy_geo\"]\n            xoffset,yoffset = xgeo - xcell, ygeo - ycell\n            xscale,yscale = info[\"cellwidth\"], info[\"cellheight\"] \n            xskew,yskew = 0,0\n        self.transform_coeffs = [xscale, xskew, xoffset, yskew, yscale, yoffset]\n\n        # and the inverse coefficients to go from geographic space to raster\n        # taken from Sean Gillies' \"affine.py\"\n        a,b,c,d,e,f = self.transform_coeffs\n        det = a*e - b*d\n        if det != 0:\n            idet = 1 / float(det)\n            ra = e * idet\n            rb = -b * idet\n            rd = -d * idet\n            re = a * idet\n            a,b,c,d,e,f = (ra, rb, -c*ra - f*rb,\n                           rd, re, -c*rd - f*re)\n            self.inv_transform_coeffs = a,b,c,d,e,f\n        else:\n            raise Exception(\"Error with the transform matrix, \\\n                            a raster should not collapse upon itself\")\n\n    def positioned(self, width, height, coordspace_bbox):\n        # GET COORDS OF ALL 4 VIEW SCREEN CORNERS\n        xleft,ytop,xright,ybottom = coordspace_bbox\n        viewcorners = [(xleft,ytop), (xleft,ybottom), (xright,ybottom), (xright,ytop)]\n\n        # FIND PIXEL LOCS OF ALL THESE COORDS ON THE RASTER\n        viewcorners_pixels = [self.geo_to_cell(*point, fraction=True) for point in viewcorners]\n\n        # ON RASTER, PERFORM QUAD TRANSFORM\n        #(FROM VIEW SCREEN COORD CORNERS IN PIXELS TO RASTER COORD CORNERS IN PIXELS)\n        flattened = [xory for point in viewcorners_pixels for xory in point]\n        newraster = self.copy()\n\n        #self.update_mask()\n        mask = self.mask\n\n        # make mask over \n        masktrans = mask.transform((width,height), PIL.Image.QUAD,\n                            flattened, resample=PIL.Image.NEAREST)\n\n        for band in newraster.bands:\n            datatrans = band.img.transform((width,height), PIL.Image.QUAD,\n                                flattened, resample=PIL.Image.NEAREST)\n            trans = PIL.Image.new(datatrans.mode, datatrans.size)\n            trans.paste(datatrans, (0,0), masktrans)\n            # store image and cells\n            band.img = trans\n            band.cells = band.img.load()\n\n        return newraster,masktrans\n```", "```py\n    @property\n    def mask(self):\n        if hasattr(self, \"_cached_mask\"):\n            return self._cached_mask\n\n        else:\n            nodata = self.info.get(\"nodata_value\")\n            if nodata != None:\n                # mask out nodata\n                if self.bands[0].img.mode in (\"F\",\"I\"):\n                    # if 32bit float or int values, need to manually check each cell\n                    mask = PIL.Image.new(\"1\", (self.width, self.height), 1)\n                    px = mask.load()\n                    for col in xrange(self.width):\n                        for row in xrange(self.height):\n                            value = (band.cells[col,row] for band in self.bands)\n                            # mask out only where all bands have nodata value\n                            if all((val == nodata for val in value)):\n                                px[col,row] = 0\n                else:\n                    # use the much faster point method\n                    masks = []\n                    for band in self.bands:\n                        mask = band.img.point(lambda px: 1 if px != nodata else 0, \"1\")\n                        masks.append(mask)\n                    # mask out where all bands have nodata value\n                    masks_namedict = dict([(\"mask%i\"%i, mask) for i,mask in enumerate(masks) ])\n                    expr = \" & \".join(masks_namedict.keys())\n                    mask = PIL.ImageMath.eval(expr, **masks_namedict).convert(\"1\")\n            else:\n                # EVEN IF NO NODATA, NEED TO CREATE ORIGINAL MASK,\n                # TO PREVENT INFINITE OUTSIDE BORDER AFTER GEOTRANSFORM\n                nodata = 0\n                mask = PIL.Image.new(\"1\", self.bands[0].img.size, 1)\n            self._cached_mask = mask\n            return self._cached_mask\n```", "```py\n# import internals\nimport sys, os, itertools, operator\n# import PIL as the image loader\nimport PIL.Image \n```", "```py\ndef from_file(filepath):\n\n    def check_world_file(filepath):\n        worldfilepath = None\n\n        # try to find worldfile\n        dir, filename_and_ext = os.path.split(filepath)\n        filename, extension = os.path.splitext(filename_and_ext)\n        dir_and_filename = os.path.join(dir, filename)\n\n        # first check generic .wld extension\n        if os.path.lexists(dir_and_filename + \".wld\"):\n            worldfilepath = dir_and_filename + \".wld\"\n\n        # if not, check filetype-specific world file extensions\n        else:\n            # get filetype-specific world file extension\n            if extension in (\"tif\",\"tiff\",\"geotiff\"):\n                extension = \".tfw\"\n            else:\n                return None\n            # check if exists\n            if os.path.lexists(dir_and_filename + extension):\n                worldfilepath = dir_and_filename + extension\n\n        # then return contents if file found\n        if worldfilepath:\n            with open(worldfilepath) as worldfile:\n                # note that the params are arranged slightly differently\n                # ...in the world file from the usual affine a,b,c,d,e,f\n                # ...so remember to rearrange their sequence later\n                xscale,yskew,xskew,yscale,xoff,yoff = worldfile.read().split()\n            return [xscale,yskew,xskew,yscale,xoff,yoff]\n```", "```py\n    elif filepath.lower().endswith((\".tif\",\".tiff\",\".geotiff\")):\n        main_img = PIL.Image.open(filepath)\n        raw_tags = dict(main_img.tag.items())\n\n        def process_metadata(raw_tags):\n            # check tag definitions here\n            info = dict()\n            if raw_tags.has_key(1025):\n                # GTRasterTypeGeoKey, aka midpoint pixels vs topleft area pixels\n                if raw_tags.get(1025) == (1,):\n                    # is area\n                    info[\"cell_anchor\"] = \"center\"\n                elif raw_tags.get(1025) == (2,):\n                    # is point\n                    info[\"cell_anchor\"] = \"nw\"\n            if raw_tags.has_key(34264):\n                # ModelTransformationTag, aka 4x4 transform coeffs...\n                a,b,c,d,\n                e,f,g,h,\n                i,j,k,l,\n                m,n,o,p = raw_tags.get(34264)\n                # But we don't want to meddle with 3-D transforms,\n                # ...so for now only get the 2-D affine parameters\n                xscale,xskew,xoff = a,b,d\n                yskew,yscale,yoff = e,f,h\n                info[\"transform_coeffs\"] = xscale,xskew,xoff,yskew,yscale,yoff\n            else:\n                if raw_tags.has_key(33922):\n                    # ModelTiepointTag\n                    x, y, z, geo_x, geo_y, geo_z = raw_tags.get(33922)\n                    info[\"xy_cell\"] = x,y\n                    info[\"xy_geo\"] = geo_x,geo_y\n                if raw_tags.has_key(33550):\n                    # ModelPixelScaleTag\n                    scalex,scaley,scalez = raw_tags.get(33550)\n                    info[\"cellwidth\"] = scalex\n                    info[\"cellheight\"] = -scaley # note: cellheight must be inversed because geotiff has a reversed y- axis (ie 0,0 is in upperleft corner)\n            if raw_tags.get(42113):\n                info[\"nodata_value\"] = eval(raw_tags.get(42113)) # eval from string to nr\n            return info\n\n        def read_crs(raw_tags):\n            crs = dict()\n            if raw_tags.get(34735):\n                # GeoKeyDirectoryTag\n                crs[\"proj_params\"] = raw_tags.get(34735)\n            if raw_tags.get(34737):\n                # GeoAsciiParamsTag\n                crs[\"proj_name\"] = raw_tags.get(34737)\n            return crs          \n\n        # read geotiff metadata tags\n        info = process_metadata(raw_tags)\n\n        # if no geotiff tag info look for world file transform coefficients\n        if len(info) <= 1 and not info.get(\"transform_coeffs\"):\n            transform_coeffs = check_world_file(filepath)\n            if transform_coeffs:\n                # rearrange the world file param sequence to match affine transform\n                [xscale,yskew,xskew,yscale,xoff,yoff] = transform_coeffs\n                info[\"transform_coeffs\"] = [xscale,xskew,xoff,yskew,yscale,yoff]\n            else:\n                raise Exception(\"Couldn't find any geotiff tags or world file needed to position the image in space\")\n\n        # group image bands and pixel access into band tuples\n        bands = []\n        for img in main_img.split():\n            cells = img.load()\n            bands.append((img,cells))\n\n        # read coordinate ref system\n        crs = read_crs(raw_tags)\n\n        return info, bands, crs\n```", "```py\n    else:\n        raise Exception(\"Could not create a raster from the given filepath: the filetype extension is either missing or not supported\")\n```", "```py\n# import builtins\nImport os\n\n# import PIL as the saver\nimport PIL\nimport PIL.TiffImagePlugin\nimport PIL.TiffTags \n```", "```py\ndef to_file(bands, info, filepath):\n    def combine_bands(bands):\n        # saving in image-like format, so combine and prep final image\n        if len(bands) == 1:\n            img = bands[0].img\n            return img\n        elif len(bands) == 3:\n            # merge all images together\n            mode = \"RGB\"\n            bands = [band.img for band in bands]\n            img = PIL.Image.merge(mode, bands)\n            return img\n        elif len(bands) == 4:\n            # merge all images together\n            mode = \"RGBA\"\n            bands = [band.img for band in bands]\n            img = PIL.Image.merge(mode, bands)\n            return img\n        else:\n            # raise error if more than 4 bands, because PIL cannot save such images\n            raise Exception(\"Cannot save more than 4 bands to one file; split and save each band separately\")\n\n    def create_world_file(savepath, geotrans):\n        dir, filename_and_ext = os.path.split(savepath)\n        filename, extension = os.path.splitext(filename_and_ext)\n        world_file_path = os.path.join(dir, filename) + \".wld\"\n        with open(world_file_path, \"w\") as writer:\n            # rearrange transform coefficients and write\n            xscale,xskew,xoff,yskew,yscale,yoff = geotrans\n            writer.writelines([xscale, yskew, xskew, yscale, xoff, yoff])\n```", "```py\n            elif typ in (11, 12):\n                # float value\n                tmap = {11: 'f', 12: 'd'}\n                if not isinstance(value, tuple):\n                    value = (value,)\n                a = array.array(tmap[typ], value)\n                if self.prefix != native_prefix:\n                    a.byteswap()\n                data = a.tostring()\n```", "```py\n    elif filepath.endswith((\".tif\", \".tiff\", \".geotiff\")):\n        # write directly to tag info\n        PIL.TiffImagePlugin.WRITE_LIBTIFF = False\n        tags = PIL.TiffImagePlugin.ImageFileDirectory()\n        if info.get(\"cell_anchor\"):\n            # GTRasterTypeGeoKey, aka midpoint pixels vs topleft area pixels\n            if info.get(\"cell_anchor\") == \"center\":\n                # is area\n                tags[1025] = 1.0\n                tags.tagtype[1025] = 12 #double, only works with PIL patch\n            elif info.get(\"cell_anchor\") == \"nw\":\n                # is point\n                tags[1025] = 2.0\n                tags.tagtype[1025] = 12 #double, only works with PIL patch\n        if info.get(\"transform_coeffs\"):\n            # ModelTransformationTag, aka 4x4 transform coeffs...\n            tags[34264] = tuple(map(float,info.get(\"transform_coeffs\")))\n            tags.tagtype[34264] = 12 #double, only works with PIL patch\n        else:\n            if info.get(\"xy_cell\") and info.get(\"xy_geo\"):\n                # ModelTiepointTag\n                x,y = info[\"xy_cell\"]\n                geo_x,geo_y = info[\"xy_geo\"]\n                tags[33922] = tuple(map(float,[x,y,0,geo_x,geo_y,0]))\n                tags.tagtype[33922] = 12 #double, only works with PIL patch\n            if info.get(\"cellwidth\") and info.get(\"cellheight\"):\n                # ModelPixelScaleTag\n                scalex,scaley = info[\"cellwidth\"],info[\"cellheight\"]\n                tags[33550] = tuple(map(float,[scalex,scaley,0]))\n                tags.tagtype[33550] = 12 #double, only works with PIL patch\n        if info.get(\"nodata_value\"):\n            tags[42113] = bytes(info.get(\"nodata_value\"))\n            tags.tagtype[42113] = 2 #ascii\n\n        # finally save the file using tiffinfo headers\n        img = combine_bands(bands)\n        img.save(filepath, tiffinfo=tags)\n```", "```py\n    else:\n        raise Exception(\"Could not save the raster to the given filepath: the filetype extension is either missing or not supported\") \n```"]