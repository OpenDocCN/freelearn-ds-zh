- en: Chapter 9. Mobile Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile web development has caused quite a stir in the last few years. When Apple
    introduced the iPhone, it didn't support third party plugins such as Flash and
    Silverlight. This challenged web developers to deliver worthwhile web experiences
    on the mobile platform with only HTML, CSS, and JavaScript. Proposed feature enhancements
    such as HTML5, CSS3, and ECMAScript 5 and 6, along with more powerful browsers,
    have improved the mobile browsing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Companies and organizations have taken different approaches to delivering the
    mobile web experience. Some organizations reroute mobile browsers to sites that
    serve mobile content only (with URLs such as `mobile.example.com` or `m.example.com`
    instead of `www.example.com`). Others have used responsive design and mobile first
    strategies to deliver the same content, formatted differently, for phones, tablets,
    and desktop screens. Still others, such as Facebook, have given up on mobile web
    development and focused on mobile apps, using native applications or hybrid web
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes developing for mobile devices different from desktop website development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the ArcGIS compact build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control the mobile user experience with `dojox/mobile` modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile web development is a fast-growing market. In India in 2012, the percentage
    of Internet content served from mobile devices surpassed that of desktop computers.
    In the US, reports show that web traffic from mobile devices accounted for 10
    percent in 2014, and the percentage is increasing.
  prefs: []
  type: TYPE_NORMAL
- en: What are people doing with the mobile Internet? Some are checking their e-mail.
    Others are searching for information, playing games, or keeping in contact with
    others. People want to be connected, entertained, and informed, and they want
    it available when they want them.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile is different
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a website work on a mobile device is vastly different from making it
    work on a desktop machine. There are so many things that were features on a desktop
    browser that are now a hindrance to work with on a mobile device. Let's look at
    both the good and the bad of what makes mobile different.
  prefs: []
  type: TYPE_NORMAL
- en: The good
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even with all the negatives, mobile application development is an exciting field.
    There are a lot of good features available for mobile web applications. Modern
    smartphones offer sensors and tools that would be strange on a desktop, but are
    vital for mobile apps. They bring a world of information to the user, and let
    the user make notes and share things where they are, instead of later that day
    when they boot up their desktop. Let's look at these features in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Access to phone sensors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mobile devices come with a number of sensors built in. These sensors can test
    the device's orientation, acceleration, and even location. Location can be collected
    through a built-in GPS device, cell phone signal triangulation, or based on the
    location of your Wi-Fi signal. Newer sensors within the phone can relay battery
    strength. Also, some third-party hybrid tools provide access to more phone features,
    such as the memory, contact lists, and the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Instant access to the app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users no longer have to write down a URL to pull up at home. Now, they can speak
    it into the browser, or take a picture of a QR Code to access a website. That
    instant access gets more people to use your application right away, cutting the
    risk of forgetting your app's location.
  prefs: []
  type: TYPE_NORMAL
- en: With instant access to the application, users can collect data where they are,
    instead of going home to input information. The user can take a picture of a broken
    fire hydrant, log in to a community issues app, and report the problem to the
    proper authorities. Field workers can collect feature data in the field and check
    it in. Volunteer geographical data collection can be used for citizen science,
    municipal issue tracking, and a host of other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Instant access to the user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike a desktop application that may be used by anybody sitting at a library
    computer kiosk, mobile phones are more likely to have a single user. Application
    usage can be tied in to user profiles to give you a more complete picture of how
    your app is used by different demographics. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: The bad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You spend hours putting together a gorgeous website that looks perfect on your
    monitor. You test your site on three or four different browsers, and like what
    you see. It looks great; it works great. It's bound to be a success.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you run into a friend and want to show them your amazing website, but
    all you have is your smartphone. No problem, you think, as you type in site's
    URL into your phone's browser. What comes up is a usability nightmare. Parts of
    the screen are cut off. Controls don't work like you planned. You can't navigate
    through the menus properly. Overall, it's a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at some of the pain points of mobile web development.
  prefs: []
  type: TYPE_NORMAL
- en: So many screen sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in the old days of the Internet, you only had to worry about a few monitor
    sizes. As long as you made a site that looked good on a 1024x768 monitor, you
    were okay. Some people had the money to afford larger monitors, while some others
    had smaller, but there wasn't a big difference.
  prefs: []
  type: TYPE_NORMAL
- en: Now, smartphones, tablets, and other devices have screens that range from four
    inches corner-to-corner to flat-screen television sizes and, because screen technology
    has improved so much, the smaller screens have a pixel density 1.5, 2, or even
    3 times that of a standard desktop monitor. Websites that were easy to read on
    a desktop become squished and smaller on a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: As the number of screen resolutions increases, so does the number of tests you
    need to perform on your website. Does the site look as good on a three inch wide
    phone as on an HD television? Does it scale well?
  prefs: []
  type: TYPE_NORMAL
- en: Fingertip accuracy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another feature lost when moving from desktop to mobile applications is the
    high accuracy input of a mouse. Whether you use a mouse, a laptop trackpad, or
    a stylus pen with your computer, you have a mouse pointer that provides fine manipulation
    of your content. On mobile devices, you have to account for rather large fingers
    that may click more than one of your cleverly sized buttons. Also, the little
    closeout buttons you created for your site may be too hard to close with some
    of the large fingerprints out there.
  prefs: []
  type: TYPE_NORMAL
- en: Along with losing the accuracy of a mouse pointer, you also lose mouse hover
    events. Everything from simple tooltips to CSS-powered collapsible menus no longer
    work as expected in a mobile browser, because there are no hover events to listen
    to and work with. Your old code from five to ten years ago won't work the same
    in the mobile web era.
  prefs: []
  type: TYPE_NORMAL
- en: Battery life
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dealing with battery life can be another hindrance to mobile development. Repeated
    access to location data and constantly monitoring advertising can drain the battery
    on mobile devices. While this information is handy to have, it comes at a price.
    Remember that not everybody has a full charge on their phone, and not every battery
    will run for hours.
  prefs: []
  type: TYPE_NORMAL
- en: More devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned the multitude of screen sizes before, but that's just the beginning.
    There are a wide variety of devices out there, running Android, iOS, Windows Phone,
    and other operating systems. Each one has a choice of a number of web browsers,
    and even those web browsers may be at different version numbers. With all this,
    support for the latest and greatest web features can be spotty, depending on the
    feature. You'll have to decide what you're willing to support, and what devices
    you're willing to purchase for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at why we should be building mobile applications, let's
    look at the tools we have available through the ArcGIS JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: The ArcGIS compact build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ArcGIS JavaScript API can be loaded as a more compact library for mobile
    browsers. The compact build, as it is called, packs the bare minimum of the libraries
    needed to view map applications in a mobile browser. Other modules can be downloaded
    through Dojo's `require()` statements, but many will not be preloaded with the
    initial library.
  prefs: []
  type: TYPE_NORMAL
- en: Modules included in the compact build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ArcGIS compact build contains all the modules necessary to build a web map
    application. It loads the same as the regular ArcGIS API for JavaScript, using
    `require()` and `define()` statements. It also comes with the most frequently
    used modules, such as `esri/Map` and `esri/layers/ArcGISDynamicMapServiceLayer`,
    to quickly load your maps while using the least bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: What's not included
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all the functionality the ArcGIS JavaScript compact build offers, you'd
    think they must sacrifice something. The first thing that the compact build gives
    up is weight. At 179.54 KB in version 3.13, the library weighs in 107.26 KB under
    its bulkier cousin. The regular build comes with a number of libraries preloaded,
    while the compact build uses `require()` or `define()` statements to request those
    modules separately. With this, you have better control over what library parts
    you send to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Another item sacrificed in the ArcGIS JavaScript API compact build is the reliance
    on the `dijit` namespace. The first thing you'll notice is that the popups are
    replaced with a more simplified versions. Also, if you like the graduated zoom
    slider to zoom your map in and out, you can forget it in the compact build. It
    only supports the **+** and **–** buttons to zoom the map in and out. If you have
    widgets that rely on the `dijit/_Widgetbase` library, those can be downloaded
    separately through `require()` and `define()` statements.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean to you?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ArcGIS JavaScript compact build provides much of the same functionality
    as the regular build does. There are a few differences in some of the controls,
    but they both present the same maps and information. The smaller library size
    is perfect for dropping a map into an existing application, or for using other
    libraries, such as Angular, Knockout, or jQuery, to handle other component interactions.
    If you don't have a dependence on the few features lost by using the compact build,
    it's worth trying.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the ArcGIS JavaScript API compact build, look at the
    ArcGIS JavaScript API documentation at [https://developers.arcgis.com/javascript/jshelp/inside_compactbuild.html](https://developers.arcgis.com/javascript/jshelp/inside_compactbuild.html).
  prefs: []
  type: TYPE_NORMAL
- en: ESRI Leaflet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Leaflet.js` library provides another alternative to the ArcGIS JavaScript
    API. It's a lightweight library that can show maps on a large range of browsers.
    Leaflet works well with any tiled map services, and points, lines, and polygons
    can be added through **geojson**, a popular open-source JSON format for geographical
    data. The library can support different tools and data sources with plugins. There
    is a rich plugin ecosystem for the Leaflet library, with more tools and data source
    plugins developed daily.
  prefs: []
  type: TYPE_NORMAL
- en: 'ESRI has released the ESRI Leaflet plugin so that Leaflet maps can use ArcGIS
    Server Map Services. According to the ESRI Leaflet GitHub page, it supports the
    following map service layers:'
  prefs: []
  type: TYPE_NORMAL
- en: ESRI basemap services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tiled map services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic map services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageServer map services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the `Leaflet.js` library, you can visit [http://leafletjs.com/](http://leafletjs.com/).
    For books on the library, you can check out *Leaflet.js Essentials* by Paul Crickard
    III, or *Interactive Map Designs with Leaflet JavaScript Library How-to* by Jonathan
    Derrough.
  prefs: []
  type: TYPE_NORMAL
- en: Dojox mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't you wish you could create an application that mimics the style of a mobile
    device, while looking like a native app? That's what some of the contributors
    to the Dojo framework thought, and that led to the modules in `dojox/mobile`.
    The modules provide controls that match many of the UI elements in native mobile
    apps, mimicking them in form and function. With the widgets in this library, buttons
    and sliders look like iPhone buttons and sliders on Safari, while appearing as
    native Android buttons and sliders on Android-based browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The `dojox/mobile` modules provide a visual interactive framework that mimics
    native mobile apps. Unlike their `dijit` form counterparts, the `dojox/mobile`
    user controls do not use so many HTML elements, improving the download speed and
    memory usage. The UI elements work well with other `dojox/mobile` controls, from
    the `dojox/mobile/View` that takes up the whole screen, down to the last `dojox/mobile/Button`.
    Let's take a look at a few of them.
  prefs: []
  type: TYPE_NORMAL
- en: Dojox mobile views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dojox/mobile/View` module provides a visual separation between parts of
    the application. Views are full page containers that can be navigated to and from
    by swipes or button presses. These are somewhat analogous to the `dijit/layout/ContentPane`
    in how they organize content.
  prefs: []
  type: TYPE_NORMAL
- en: Related to the `dojox/mobile/View`, the `dojox/mobile/ScrollableView` provides
    extra scrolling functionality in a way mobile users expect. In many mobile devices,
    when the user swipes the screen to scroll down the page, that user expects the
    page will continue to scroll until it slows to a stop. `ScrollableView` implements
    that inertial scrolling down the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As `ScrollableView` scrolling events interfere with panning a map on a touchscreen
    interface, you should not add an interactive map to this view. `ScrollableView`
    is better suited for forms and content that may extend beyond the height of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Working with touch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're used to working with mouse events in JavaScript, touch events can
    be a bit confusing. The `touchstart` and `touchend` events look equivalent to
    the `mousedown` and `mouseup` events.
  prefs: []
  type: TYPE_NORMAL
- en: In current versions of the ArcGIS JavaScript API, many of the touch events are
    already handled by the API modules. When working with the map, you don't need
    to assign a `map.on("touchstart")` event listener on top of a `map.on("click")`
    event listener. The `map.on("click")` event listener handles it for you. The same
    goes for any Dojo widgets and controls. That's one less thing you have to do to
    make your application mobile-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of the map, there are touch events available that make some navigation
    tools obsolete. You can pinch or spread your fingers on the screen to zoom in
    and out respectively. Panning can be controlled by dragging your finger across
    the map. These actions remove the need for zoom in, zoom out, and pan buttons,
    which can free up valuable screen real estate.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript handling of complicated mobile gestures hasn't been as smooth as
    it has been in native applications. Native applications are developed to distinguish
    between a tap and a tap-and-hold, for instance. By default, many JavaScript-based
    applications treat them both as a click.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dojo framework that comes with the ArcGIS JavaScript API has some experimental
    libraries to handle gestures, with the `dojox/gesture` modules. These modules
    allow you to assign events using `dojo/on`, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple gesture definition, `dojox/gesture` modules allow you to define
    tap and swipe events using `dojox/gesture/tap` and `dojox/gesture/swipe` respectively.
    With tap events, you can define single tap, double tap, and tap-and-hold events.
    For swipe events, you can define events at the beginning and end of the swipe
    event. In the following, you can see a code snippet implementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can't find a gesture that does what you want? With the `dojox/gesture/Base`
    module, you can define your own custom gestures. As of now, you have to define
    your own methods to handle gestures such as rotating, pinching, and spreading
    your fingers. At some point, there will be more general support for those gestures,
    but not as of the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you would like to learn more about handling touch and gestures in Dojo applications,
    you can visit [https://dojotoolkit.org/reference-guide/1.10/dojox/gesture.html](https://dojotoolkit.org/reference-guide/1.10/dojox/gesture.html).
  prefs: []
  type: TYPE_NORMAL
- en: Our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our story continues, we receive a call from the city of Hollister, California,
    regarding their incident reporting app. They like the application, and it works
    great for the receptionist who takes phone calls about those issues. Now, they
    want a version that's more mobile-friendly, and they've come to us for help. It's
    time for us to take our knowledge of mobile apps and create a tool they can use
    from a smartphone in the field.
  prefs: []
  type: TYPE_NORMAL
- en: The original incident reporting app was built using typical `dijit/layout` elements,
    where every panel had a place on the screen. Now, we have to consider that there's
    not enough room on a smaller screen for everything. Instead, we need to organize
    each panel into its own separate view. We'll need to control how we navigate between
    these views, and use the appropriate controls that work well with a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the ArcGIS JavaScript API compact build, along with the `dojox/mobile`
    modules, to create a mobile-friendly web application. We'll put the map in one
    view, the incident picker in a second view, and a more detailed reporting form
    in the third view. For all of these, we'll use `dojox/mobile` user interface components,
    along with the ArcGIS JavaScript API editing widgets, to create not just a mobile-friendly,
    but a user-friendly reporting experience as well.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will begin creating the mobile application by loading the ArcGIS compact
    build into the `index.html` file. In the head of the HTML document, we''ll change
    the link to the ArcGIS JavaScript API to load the compact build. We''ll keep the
    `esri.css` file and our own style sheet reference, but we can remove the `claro.css`
    style sheet reference, since our application won''t need it. Our `index.html`
    file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of our application has three actionable parts. There''s a map where
    we place our incidences. There''s also a panel where we select what incident is
    on the map. Finally, there is a form where we fill out more information about
    the incident. We''ll lay those out into different views: `mapview`, `incidentview`,
    and `attributeview`. Inside each view, we''ll add the headings and controls we
    need for our application. It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've added the familiar `data-dojo-type` attributes
    to create the `dojox/mobile/View` modules on the page. Inside each view, we have
    a `dojox/mobile/Heading` module element, to show a heading at the top of the page.
    The heading also doubles up as a sort of a button bar, into which we can put back
    buttons inside. In the `data-dojo-props` attribute of the headings, we define
    a back button with the `back` attribute defining the button text, and the `moveTo`
    attribute defining the view it switches to.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our `app.js` file, we''ll need to modify the `require` statement in order
    to load the appropriate modules for the mobile library. Instead of loading the
    `dijit/layout` modules for setting up the layout, we''ll need to add the `dojox/mobile`
    equivalent. In the `require()` statement in the `app.js` file, modify the code
    to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we replaced the normal `dojo/parser` with a `dojox/mobile/parser`
    equivalent. We've added the `dojox/mobile` base class, the `dojox/mobile/deviceTheme`
    that loads the appropriate theme based on your browser, and `dojox/mobile/compat`
    so that the site can also be seen on older desktop browsers such as Internet Explorer.
    For the elements we want to see out of the `dojox/mobile` library, we've loaded
    the `View`, the `Heading` to view title data, and the `ToolBarButton` to add buttons
    to the heading.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the map on mobile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's focus on making the map work. In our mobile application, we've added the
    map within the `mapview` div. We've set the width and height of the map to `100%`
    in our `style.css` file. The map should load as normal, right?
  prefs: []
  type: TYPE_NORMAL
- en: When we load the map as it is, especially from a larger browser, we find that
    the map doesn't stretch all the way to the bottom. Using our favorite tools for
    examining DOM elements, we find that height of the map div has been set inline
    to `400px`. Where have we seen this before?
  prefs: []
  type: TYPE_NORMAL
- en: 'After examining the DOM elements of features around the map, we see that the
    view''s height hasn''t been set. By default, the `mapview` div''s height depends
    on the height of its content. As its height has not been defined, the map sets
    its height to `400px`. To fix this, we need to manually define the `mapview` div''s
    height in our `style.css` file. We''ll also stop the `mapview` div from scrolling
    by setting its `overflow-y` to `hidden`. This will remove any unsightly scrollbars
    on our map, which may interfere with map navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Fixing the LocateButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `LocateButton`, which uses the browser''s GPS functionality to center the
    map on our location, has moved around. It appears that addition of the `dojox/mobile/Heading`
    and the mobile buttons to zoom in and out have caused our `LocateButton` to be
    displaced. We can use our favorite browser DOM explorer to reposition the Locate
    button to a good spot, and then include it in the `style.css` file to make it
    more permanent. The style for the `LocateButton` should look something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re done, you should have a map that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the LocateButton](img/6459OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with the editor widgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're using the ArcGIS compact build, we don't have access to the popup
    dijit that we used with the attachment editor. We don't have many of the other
    dijit-based modules either. This application may require a bit more work to make
    it mobile-ready.
  prefs: []
  type: TYPE_NORMAL
- en: Template picker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To select from the list of incidents, we chose the `esri/dijit/editing/TemplatePicker`
    module to create buttons to select an incident. Now, we''ll keep using it, but
    we''re looking at it in a different view. The original one presented a vertical
    list of buttons down the side of the page for presenting incidents. Now, we''re
    going to remove those settings and define the template picker more normally. The
    code for initializing the template picker should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To access the picker for our incidents, or to edit a currently selected feature,
    we need to call the `showInspector()` function. If we look over the existing function,
    it attempts to select features in a feature service based on a point around where
    we click. It uses the map's `infoWindow` to show the attribute editor. Now that
    we're using another location to edit the feature attributes, we need to modify
    the `showInspector()` code to handle our new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step in making our `showInspector()` function work on a mobile is
    to tweak the surface area that is selected compared to that if we click on the
    map. Currently, it creates a two pixel wide extent around our click point. We
    can expand it to 10 pixels, because our fingers are wider than a mouse pointer.
    Also, we need to modify the `callback` function after the query succeeds. If there
    are no features in the location clicked on the map, we''ll show the template picker.
    If none is selected, we''ll tell it to go to the attribute inspector instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `goToPicker()` function, we''ll switch from `mapview` to `incidentview`.
    We''ll do this by using the `performTransition()` method provided by `dojox/mobile/View.`
    It accepts up to five arguments: an `id` for another view to see, a number-based
    direction (either `1` or `-1`), a transition style, and an object that defines
    `this` for the `callback` function that rounds out the fifth argument. We''ll
    tell `mapview` to make the transition to `incidentview`, moving from the right
    with a `slide` animation, and we''ll add a `callback` function once the process
    finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we try to run the `goToPicker` function as it is, it goes to `incidentview`,
    but we don't see any incidents. This is due to an interesting feature of some
    dojo widgets. When not visible, the widgets set their widths and heights to `0`,
    effectively becoming invisible. We need to refresh the `TemplatePicker` internal
    grid and clear the template selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user selects a feature from the list, we need something to convey
    our selection to the attribute inspector. We''ll also add a single fire event
    using the `once()` method in the `dojo/on` module, and attach it to the `selection-change`
    event of the `TemplatePicker` widget. From there, we''ll collect the selected
    attributes, the current date, and a few other attributes, and pass them to a function
    that adds the incident to the map. The function should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `addIncident()` function, we''ll add our point location, symbol, and
    attributes into a graphic. From there, we''ll add the graphic feature to the editable
    `incidentLayer`. Once we have completed that, we''ll attempt to select it again
    using the `incidentLayer` layer''s `selectFeatures()` method, then send the result
    to the `goToAttributeInspector()` function. We''ll pass along the name of the
    current view (`incidentview`), as well as the first feature that''s selected.
    It should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If all works correctly, you should be able to access your incident picker with
    `incidentview`, and it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template picker](img/6459OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attribute inspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the map and the template picker have been properly updated for the
    mobile application, it's time to look at the third stage of our incident reporting
    application. Using our previous code, we'll select the incident through the `FeatureLayer`
    selection. We'll then load the attribute inspector and edit the data. Finally,
    we'll save the feature data, including any images, to the feature service.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous desktop application, we loaded the attribute inspector in the
    map popup. However, we don't have the same popup widget we had before in the ArcGIS
    compact build. This one won't be so editable on the map screen. However, we have
    plenty of screen real estate on the attribute view, so we'll load the inspector
    there. Also, note that we'll remove any of the events where the map popup loads
    or changes the attribute inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a location on the page for the attribute inspector
    within the attribute view. In the `index.html` page, within the `attributeview`
    div element, we''ll add a div element with an `id` of `attinspector`. When our
    application loads, it will create an attribute inspector in this location. It
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `app.js` file, we will still use the `generateAttributeInspector()`
    function that is called by the `startEditing()` function when the map is loaded.
    However, the `generateAttributeInspector()` function will need a few changes to
    work with its more permanent surroundings. We will need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize and start up the attribute inspector where the `attinspector` div
    element is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any references to the `infoWindow` property of the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the changes are applied to the `generateAttributeInspector()` function,
    it should look something like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we have made the changes, we can run the application in a browser and check
    out the attribute inspector. After clicking on a troublesome location on our map,
    and identifying the incident with `TemplatePicker`, we should be able to view
    and edit the incident attributes with the attribute inspector.
  prefs: []
  type: TYPE_NORMAL
- en: Trouble in the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oops, we''ve run into a bit of a problem with the application. We tested the
    app by tapping on a spot on the map to report an incident. We selected the incident
    type from the template picker, and it made the selection. After a couple of seconds,
    it switched over to the attribute inspector, and we got the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trouble in the app](img/6459OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The attribute inspector form is very unsightly, and doesn't behave in the way
    it did as a desktop web application. The user controls to edit the feature attributes
    don't work very well. How could this happen?
  prefs: []
  type: TYPE_NORMAL
- en: The issues with the attribute inspector actually lead back to something we did
    at the beginning of this application. We removed the `claro.css` file at the head
    of the web page and, along with it, removed any other `dijit` references. This
    act saved significant bandwidth on our application, but we lost the styling and
    functionality of the user controls in the attribute inspector. Now, it's not going
    to do what we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Rebuilding the attribute inspector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another way, however. We can create our own form for updating the feature
    attributes. We can use form elements from the `dojox/mobile` modules to make our
    own form, instead of using the attribute inspector. Also, on closer inspection,
    the attachment editor portion of the attribute inspector worked well. We can load
    the attachment editor after our custom form, and use it to save images to the
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make the custom form, we''re going to need to load a few `dojox/mobile`
    modules to parse. In the `require()` list in our `app.js` file, we''ll add the
    `dojox/mobile/RoundRect` module to create a rounded body for the form. We''ll
    also use `dojox/mobile/TextBox` for text entry, as well as the combination of
    `dijit/form/DataList` and `dojox/mobile/ComboBox` to create a mobile drop-down
    menu. We''re also going to use `dojox/mobile/Button` to save our changes. Our
    `require` statement should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll modify the attribute view to make the form for editing the incident
    attributes. We''ll use `DataList` and `ComboBox` in `index.html` as a selection
    tool for the incident type. In this way, if the wrong type is selected, the user
    will be able to correct it. Next, we''ll use `Textbox` to record the `Address`
    and `District` attributes. The date, time, and status are read-only at this point,
    since we don''t want the reporter to change the date and time of the incident
    and whether the incident has been opened or closed. Finally, we''ll add a `Save`
    button to the form to save the results. Once we add these to `index.html`, the
    file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to modify our JavaScript to handle the form input and output.
    We''ll create two functions, `setupIncident()` and `saveEdits()`, to load and
    save the data from the incident details form. The `setupIncident()` function will
    accept the feature to be modified as an argument. Also, since `setupIncident()`
    can be called when tapping on an existing incident on the map, or after selecting
    an incident type in `TemplatePicker`, we''ll pass the view name along with the
    feature data so it can move to the incident details view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `saveEdits()` function will collect the values from the form, add those
    values as feature attributes, and save the feature back to the geodatabase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The attachment editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last feature we will be implementing is the addition of photos to the incident
    reports. The previous version used the attachment editor that was part of the
    attribute inspector. Now that we're implementing our own entry form, we need to
    include the attachment editor separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in adding the attachment editor in our application is to add
    the module reference in the `app.js` file `require` statement. According to the
    API documentation, the module to use is in `esri/dijit/editing/AttachmentEditor`.
    We''ll add the reference in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll initialize the attachment editor after the `TemplatePicker` in our `startEditing()`
    function and assign it to the variable `attachmentEditor`. We need the scope of
    the `attachmentEditor` to fit within the whole application since we''ll be connecting
    it with feature data in other functions. You can see the additions highlighted
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we connect our editing form with our data in the `setupIncident()` function,
    we also need to connect the `attachmentEditor` to its data. After we''ve updated
    the editing form with the feature values, we''ll call the `showAttachments()`
    method of the `attachmentEditor`. This method accepts the feature, as well as
    the layer to be edited. The attachment editor will handle how to display existing
    attachments, and how to add new ones. The code changes should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to supply an element to `index.html`, in which we will attach
    the attachment editor widget. At the bottom of the `attributeview` element, underneath
    the editing form, we''ll add a `div` element with the `id` of `attributediv`.
    That portion of our `index.html` page should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the application and begin reporting an incident, you should eventually
    see a form that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The attachment editor](img/6459OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The end result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After modifying our application layout and behavior, we now have a useful mobile
    reporting tool. A citizen could load this page in their browser and report any
    problems they find. City workers could also use this to report incidents. Your
    application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The end result](img/6459OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More work could be done to improve the application. Currently, it requires a
    constant Internet connection to make edits. If your mobile device is in an area
    with bad network coverage, any edits will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined what makes a website mobile. We looked at
    the requirements for a mobile application, in screen real estate, functionality,
    and bandwidth. We looked at the ArcGIS compact build to use on mobile applications.
    We also modified an existing application previously formatted for desktop use,
    and made it mobile-ready.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll investigate how to write testable code using test-driven
    development.
  prefs: []
  type: TYPE_NORMAL
