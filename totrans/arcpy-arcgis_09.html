<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. More ArcPy.Mapping Techniques</h1></div></div></div><p>The ability to control map document cartography, while also running geospatial analyses, increases the power and usefulness of ArcPy. The properties and methods of <code class="literal">arcpy.mapping</code> can be utilized to manipulate layer objects, map scales and data frame extents, or even to set definition queries. By combining automated geospatial analysis with dynamic map production, scripted mapping systems are made possible. This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arcpy.mapping Layer objects</li><li class="listitem" style="list-style-type: disc">Layer object definition queries and extents</li><li class="listitem" style="list-style-type: disc">Arcpy.mapping Data Frame objects</li><li class="listitem" style="list-style-type: disc">Creating dynamically scaled maps</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec45"/>Using arcpy.mapping to control Layer objects</h1></div></div></div><p>
<code class="literal">Arcpy.mapping</code> Layer objects are used to control the properties of layers within map document <a id="id343" class="indexterm"/>data frames. Turning<a id="id344" class="indexterm"/> layer visibility on and off, adding new layers, and adjusting layer order can all be accomplished using Layer object properties.</p><p>Creating Layer objects involves passing parameters to the <code class="literal">arcpy.mapping.ListLayers()</code> method. As discussed in <a class="link" href="ch08.html" title="Chapter 8. Introduction to ArcPy.Mapping">Chapter 8</a>, <em>Introduction to ArcPy.Mapping</em>, when referencing an <code class="literal">arcpy.mapping.MapDocument</code> object, the layers within the map document can be accessed using zero-based indexing. This code will print the list of Layer objects contained within the data frame called Layers in an MXD:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>mxdPath = r'C:\Projects\MXDs\Chapter9\MapDocument1.mxd'</strong>
<strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong>
<strong>dataFrame = arcpy.mapping.ListDataFrames(mxdObject, "Layers")[0]</strong>
<strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong>
<strong>print layersList</strong>
</pre></div><p>The layers within the data frame called <strong>Layers</strong>, have been assigned to the variable <code class="literal">layersList</code> using the <code class="literal">ListLayers()</code> method. Each layer in <code class="literal">layersList</code> can be accessed using zero-based indexing. Once the layers have been accessed within the list and either assigned<a id="id345" class="indexterm"/> to a variable or placed<a id="id346" class="indexterm"/> inside a <code class="literal">for</code> loop, the properties <a id="id347" class="indexterm"/>and methods of the Layer objects can be utilized.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>The second parameter of the <code class="literal">ListLayers</code> method is empty here, but does not have to be. It is a wild card parameter that will limit the returned Layer objects to those that match the pattern of the wild card. For instance, <strong>*Stops</strong> would return all layers with the name <strong>Stops</strong> at the end. Multiple asterisks can be used to find layers with the word at the beginning, middle, or end of the layer name.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec69"/>Layer object methods and properties</h2></div></div></div><p>Layer<a id="id348" class="indexterm"/> object properties and methods can either be read only, meaning<a id="id349" class="indexterm"/> they can be checked but not adjusted, or they are read and write, meaning they can be adjusted within the script. Let's explore a number of these properties and methods, and see how they can be used to control the look and feel of the maps produced from the map document, as well as the data from the script analysis.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Definition queries</h1></div></div></div><p>An important<a id="id350" class="indexterm"/> property of Layer objects is the ability to dynamically set definition queries. A definition query is a SQL statement <code class="literal">where</code> clause that limits the data available for display, query, or other data operations (buffers, intersections, etc.) to only the rows that match the <code class="literal">where</code> clause. Definition queries could be set in an MXD by opening a layer's properties menu and using the Definition Query tab, but here we are concerned with how to add them programmatically. Following is an example of how to do this:</p><div><pre class="programlisting">
<strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong>
<strong>busStops = layersList[0]</strong>
<strong>busStops.definitionQuery = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
</pre></div><p>This valuable property can be utilized to reformat the code from <a class="link" href="ch08.html" title="Chapter 8. Introduction to ArcPy.Mapping">Chapter 8</a>, <em>Introduction to ArcPy.Mapping</em>. Remember the complicated second portion of the <code class="literal">Chapter8_6.py</code> script, where each bus stop along the <code class="literal">71 Inbound</code> line is selected and its geometry is written to another feature class? Instead, we can use Layer objects and definition queries to perform the same type of geometry operation. Let's examine how the first part of that operation (selecting the bus stop geometry and creating a buffer around it) looks when a definition <a id="id351" class="indexterm"/>query is used:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>bufferDist = 400</strong>
<strong>mxdPath = r'C:\Projects\MXDs\Chapter9\MapDocument1.mxd'</strong>
<strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong>
<strong>dataFrame= arcpy.mapping.ListDataFrames(mxdObject, "Layers")[0]</strong>
<strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong>
<strong>busStops = layersList[0]</strong>
<strong>defQuery = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>busStops.definitionQuery = defQuery</strong>
<strong>idList =[]</strong>
<strong>with arcpy.da.SearchCursor(busStops,['OID@']) as cursor:</strong>
<strong>    for row in cursor:</strong>
<strong>        idList.append(row[0])</strong>
<strong>for oid in idList:</strong>
<strong>    newQuery = "OBJECTID = {0}".format(oid)</strong>
<strong>   print newQuery</strong>
<strong>    busStops.definitionQuery = newQuery</strong>
<strong>    with arcpy.da.SearchCursor(busStops,['SHAPE@','STOPID','NAME','BUS_SIGNAG','OID@','SHAPE@XY']) as cursor:</strong>
<strong>        for row in cursor:</strong>
<strong>            stopPointGeometry = row[0]</strong>
<strong>            stopBuffer = stopPointGeometry.buffer(bufferDist)</strong>
</pre></div><p>In this example, the definition query is used to limit the potential results from the <code class="literal">SearchCursor</code> to the bus stop specified by the query. However, this is overly cumbersome and the definition query doesn't add much, as first another <code class="literal">SearchCursor</code> is needed to extract the <code class="literal">ObjectID</code> information from the <code class="literal">busStops</code> layer. This complicates the code when only one <code class="literal">SearchCursor</code> is necessary.</p><p>Definition queries should be used to select the blocks that intersect with the buffer, as this will eliminate the need to use the complicated Search Cursor and Insert Cursor setup that was employed in <a class="link" href="ch08.html" title="Chapter 8. Introduction to ArcPy.Mapping">Chapter 8</a>, <em>Introduction to ArcPy.Mapping</em>. Let's reformulate the code so that definition queries are properly used on the census block Layer object.</p><p>The first step is to add some code that will generate the SQL statement that will be used as<a id="id352" class="indexterm"/> the definition query:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>bufferDist = 400</strong>
<strong>mxdPath = r'C:\Projects\MXDs\Chapter9\MapDocument1.mxd'</strong>
<strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong>
<strong>dataFrame = arcpy.mapping.ListDataFrames(mxdObject, </strong>
<strong>                                         "Layers")[0]</strong>
<strong>layersList = arcpy.mapping.ListLayers(mxdObject,"",dataFrame)</strong>
<strong>busStops = layersList[0]</strong>
<strong>censusBlocks = layersList[3]</strong>
<strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>with arcpy.da.SearchCursor(busStops,['SHAPE@', 'STOPID', 'NAME', 'BUS_SIGNAG','OID@'],sql) as cursor:    </strong>
<strong>    for row in cursor:</strong>
<strong>           bus Query = 'OBJECTID = {0}'.format(row[-1])</strong>
<strong>           busStops.definitionQuery = bus Query</strong>
<strong>        stopPointGeometry = row[0]</strong>
<strong>        stop Buffer = stopPointGeometry. Buffer(bufferDist)</strong>
<strong>        arcpy.SelectLayerByLocation_management(censusBlocks,'intersect',stopBuffer,"","NEW_SELECTION")</strong>
<strong>        blockList = []</strong>
<strong>        with arcpy.da.SearchCursor(censusBlocks,</strong>
<strong>                                   ['OID@']) as bcursor:</strong>
<strong>            for brow in bcursor:</strong>
<strong>                blockList.append(brow[0])</strong>
<strong>        newQuery = 'OBJECTID IN ('for COUNTER, oid in enumerate(blockList):</strong>
<strong>            if COUNTER &lt; len(blockList)-1:</strong>
<strong>                newQuery += str(oid) + ','</strong>
<strong>            else:</strong>
<strong>                newQuery += str(oid)+ ')'</strong>
<strong>        print newQuery</strong>
</pre></div><p>In this section, the code assigns the census blocks layer in the MXD to the variable <code class="literal">censusBlocks</code>. The bus stops <code class="literal">SearchCursor</code> is then created, and the 400 foot buffer is generated for each row to select the census blocks surrounding the bus stop. Once the correct blocks have been selected, a second <code class="literal">SearchCursor</code> is used on the <code class="literal">censusBlocks</code> Layer object to find the <code class="literal">ObjectID</code> (using the <code class="literal">OID@</code> token) of the selected blocks. The <code class="literal">ObjectIDs</code> are then appended to the list called <code class="literal">blockList</code>.</p><p>This list is <a id="id353" class="indexterm"/>then iterated in a <code class="literal">for</code> loop to generate a string SQL statement. Using the initial string assigned to the variable <code class="literal">newQuery</code>, the <code class="literal">for</code> loop will add the <code class="literal">ObjectIDs</code> of each select block to the string to create a valid SQL statement. The <code class="literal">for</code> loop uses the function enumerate to count the number of loops that the <code class="literal">for</code> loop performs; this allows for an <code class="literal">if/then</code> statement to be used. The <code class="literal">if/then</code> statement determines what comes after the <code class="literal">ObjectID</code> in the string, as each <code class="literal">ObjectID</code> must be separated by a comma, except for the final <code class="literal">ObjectID</code>, which must be followed by the closing parenthesis. The <code class="literal">for</code> loop produces a SQL statement similar to this example:</p><div><pre class="programlisting">
<strong>OBJECTID IN (910,1664,1812,1813,2725,6382)</strong>
</pre></div><p>The <code class="literal">print</code> statement at the end is used to demonstrate the results of this section of the code, and also to give that warm fuzzy feeling that comes from seeing the results of the code working. Once we are sure that the code is generating valid SQL statements (closed parenthesis and comma separated <code class="literal">ObjectIDs</code>), the next step is to assign the definition query to the <code class="literal">censusBlocks</code> Layer object and use the result to generate a map of the area.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Controlling the data frame window extent and scale</h1></div></div></div><p>In <a class="link" href="ch08.html" title="Chapter 8. Introduction to ArcPy.Mapping">Chapter 8</a>, <em>Introduction to ArcPy.Mapping</em> we started to explore the properties and methods<a id="id354" class="indexterm"/> of the data frame. Using the <code class="literal">arcpy.Extent</code> object, we were able to set the extent of the data frame to an extent that was <a id="id355" class="indexterm"/>hard-coded into the script. However, this does not always capture the entire extent of large census blocks. Using a combination of definition queries and the data frame extent and scale properties, we can avoid these unwanted results.</p><p>There are two data frame object methods used to shift the data frame window to the area of interest, in this case the selected census blocks. The first, which we are not using here, is <code class="literal">dataFrame.zoomToSelectedFeatures</code>. The second, is to assign the data frame's extent property to the extent of the census block layer after the definition query has been assigned to it.</p><p>I prefer the second method, as it will work even when there is no selected census blocks. Also, as the maps that are produced by this script should not show the selection of the blocks, we will have to add code to explicitly clear the selection once the correct census blocks have been identified:</p><div><pre class="programlisting">
<strong> censusBlocks.definitionQuery = newQuery</strong>
<strong> dataFrame.extent = censusBlocks.getExtent()</strong>
<strong> arcpy.SelectLayerByAttribute_management(censusBlocks,</strong>
<strong>                                         "CLEAR_SELECTION")</strong>
</pre></div><p>The definition query has made it easy to move the data frame window to the area of interest, as the extent rectangle (or envelope) of the layer is now only around the specified <a id="id356" class="indexterm"/>blocks and the <code class="literal">dataFrame</code> extent <a id="id357" class="indexterm"/>property can be set to the extent rectangle. However, this is not always cartographically desirable as it seems better to move the data frame window back from the extent rectangle. To do that, we'll access the data frame the object's scale property.</p><p>The scale property can be set to be a multiplier of the current scale to avoid hard-coding any specific distances when adjusting the data frame extent. When using the scale property, it is important to remember to use the <code class="literal">arcpy.RefreshActiveView()</code> method, as it will refresh the data frame window to the new scale.</p><div><pre class="programlisting">
<strong>dataFrame.scale = dataFrame.scale * 1.1</strong>
<strong>arcpy.RefreshActiveView()</strong>
</pre></div><p>As the data frame extent was set in the few lines before this, the current scale represents the envelope of the selected census blocks. To adjust it, assess the property and apply a multiplier. In this case, the multiplier is 1.1, but it could be any value. This makes the resulting map look better by giving the analysis results some background context.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec70"/>Adding a Layer object</h2></div></div></div><p>The last step<a id="id358" class="indexterm"/> before exporting out the maps is to add the 400 foot buffers created above as a layer to the data frame object. To accomplish this, we need to create a symbolized layer ahead of time and copy its symbology to ensure it looks as desired. This will be added to the <strong>MXD</strong> as a placeholder layer, and assigned to the <code class="literal">bufferLayer</code> variable in the script.</p><div><ol class="orderedlist arabic"><li class="listitem">Open up an <strong>MXD</strong> and add the <strong>bus stop feature class</strong>.</li><li class="listitem">Run the <strong>Buffer Tool</strong> in the <strong>Proximity</strong> toolset in the <strong>Analysis</strong> toolset of the <strong>ArcToolbox</strong>, adding the <strong>bus stop feature class</strong> as the input and setting the buffer size to <strong>400 feet</strong>. After the tool has run, open the properties of the buffer layer and symbolize the layer as desired.</li><li class="listitem">Once the layer has been symbolized, right-click on the layer and select <strong>Save</strong> <strong>As Layer File</strong>.</li><li class="listitem">Save the layer in a folder and close the <strong>MXD</strong>.</li><li class="listitem">Open up the <strong>MapDocument1.mxd </strong>map document and add the layer using the <strong>Add Data</strong> button.</li><li class="listitem">Make sure to change the name to <strong>400 Foot Buffer</strong> and to add it to the legend above the <strong>Population</strong> section.</li><li class="listitem">In the script, assign the buffer layer to the variable <code class="literal">bufferLayer</code>.</li><li class="listitem">Lower<a id="id359" class="indexterm"/> in the script, in the bus stop <code class="literal">SearchCursor</code>, add these lines below where the buffer is generated around the bus stop geometry:<div><pre class="programlisting">
<strong>arcpy.CopyFeatures_management(stopBuffer, r"C:\Projects\Output\400Buffer.shp")   </strong>
<strong>bufferLayer.replaceDataSource(r"C:\Projects\Output","SHAPEFILE_WORKSPACE","400Buffer")</strong>
</pre></div></li></ol></div><p>These two lines copy the buffer generated to disk as a shapefile and then replace the data source of the <code class="literal">bufferLayer</code> Layer object with the newly created buffer. Note that the name of the shapefile does not include the <code class="literal">.shp</code> extension; the <code class="literal">SHAPEFILE_WORKSPACE</code> parameter makes this unnecessary.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>To make sure that each new buffer shapefile can be written  over an existing shapefile, add the following line below the <code class="literal">import arcpy</code> line to make sure that files can be overwritten:</p><div><pre class="programlisting">
<strong>       arcpy.env.overwriteOutput = 1</strong>
</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec71"/>Exporting the maps</h2></div></div></div><p>The final <a id="id360" class="indexterm"/>step of this script is to export the maps of the area surrounding each bus stop. To do this, we will borrow some code from the script <code class="literal">Chapter8_6_AdjustMap.py</code> and add the whole script to a file called <code class="literal">Chapter9.py</code>. This code will identify and adjust the title and subtitle elements, making it possible to customize each resulting PDF:</p><div><pre class="programlisting">
<strong>import arcpy</strong>
<strong>arcpy.env.overwriteOutput = 1</strong>
<strong>bufferDist = 400</strong>
<strong>pdfFolder = r'C:\Projects\PDFs\Chapter9\Map_{0}'</strong>
<strong>mxdPath = r'C:\Projects\MXDs\Chapter9\MapDocument1.mxd'</strong>
<strong>mxdObject = arcpy.mapping.MapDocument(mxdPath)</strong>
<strong>dataFrame = arcpy.mapping.ListDataFrames(mxdObject,"Layers")[0]</strong>
<strong>elements = arcpy.mapping.ListLayoutElements(mxdObject)</strong>
<strong>for el in elements:</strong>
<strong>    if el.type =="TEXT_ELEMENT":</strong>
<strong>        if el.text == 'Title Element':</strong>
<strong>            titleText = el</strong>
<strong>        elif el.text == 'Subtitle Element':</strong>
<strong>            subTitleText = el            </strong>
<strong>layersList = arcpy.mapping.ListLayers(mxdObject,</strong>
<strong>                                      "",dataFrame)</strong>

<strong>busStops = layersList[0]</strong>
<strong>bufferLayer = layersList[2]</strong>
<strong>censusBlocks = layersList[4]</strong>
<strong>sql = "NAME = '71 IB' AND BUS_SIGNAG = 'Ferry Plaza'"</strong>
<strong>with arcpy.da.SearchCursor(busStops,['SHAPE@',</strong>
<strong>                                     'STOPID',</strong>
<strong>                                     'NAME',</strong>
<strong>                                     'BUS_SIGNAG',</strong>
<strong>                                     'OID@'],sql) as cursor:    </strong>
<strong>    for row in cursor:</strong>
<strong>        busQuery = 'OBJECTID = {0}'.format(row[-1])</strong>
<strong>        busStops.definitionQuery = busQuery</strong>
<strong>        stopPointGeometry = row[0]</strong>
<strong>        stopBuffer = stopPointGeometry.buffer(bufferDist)</strong>
<strong>        arcpy.CopyFeatures_management(stopBuffer,r"C:\Projects\Output\400Buffer.shp")</strong>
<strong>        bufferLayer.replaceDataSource(r"C:\Projects\Output",</strong>
<strong>                 "SHAPEFILE_WORKSPACE",</strong>
<strong>              "400Buffer")</strong>
<strong>        arcpy.SelectLayerByLocation_management(censusBlocks,</strong>
<strong>                                               'intersect',</strong>
<strong>                                               stopBuffer,</strong>
<strong>                                               "",</strong>
<strong>                                               "NEW_SELECTION")</strong>
<strong>        blockList = []</strong>
<strong>        with arcpy.da.SearchCursor(censusBlocks,</strong>
<strong>                                   ['OID@']) as bcursor:</strong>
<strong>            for brow in bcursor:</strong>
<strong>                blockList.append(brow[0])</strong>
<strong>        newQuery = 'OBJECTID IN ('</strong>
<strong>        for COUNTER, oid in enumerate(blockList):</strong>
<strong>            if COUNTER &lt; len(blockList)-1:</strong>
<strong>                newQuery += str(oid) + ','</strong>
<strong>            else:</strong>
<strong>                newQuery += str(oid)+ ')'</strong>
<strong>        print newQuery</strong>
<strong>        censusBlocks.definitionQuery = newQuery</strong>
<strong>        dataFrame.extent = censusBlocks.getExtent()</strong>
<strong>        arcpy.SelectLayerByAttribute_management(censusBlocks,</strong>
<strong>                                               "CLEAR_SELECTION")</strong>
<strong>        dataFrame.scale = dataFrame.scale * 1.1</strong>
<strong>        arcpy.RefreshActiveView()</strong>
<strong>        subTitleText.text = "Route {0}".format(row[2])</strong>
<strong>        titleText.text = "Bus Stop {0}".format(row[1])</strong>
<strong>        outPath  = pdfFolder.format( str(row[1])) + '.pdf'</strong>
<strong>        print outPath</strong>
<strong>        arcpy.mapping.ExportToPDF(mxdObject,outPath)</strong>
<strong>        titleText.text = 'Title Element'</strong>
<strong>        subTitleText.text = 'Subtitle Element'</strong>
<strong>        censusBlocks.definitionQuery = ''</strong>
<strong>        busStops.definitionQuery = ''</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we covered the use of layer definition queries, data frame extents and scales, and layer source replacement to ease the production of maps. By using definition queries, the layers can be modified to new extents, making it easier to zoom into the layer extent and to set the scale of the data frame. The definition queries also limit which members of a layer are displayed within the data frame. Layer source replacement was used as a cartographic control, allowing us to pre-generate the style of a layer and adjust the data that it represented dynamically.</p><p>In the next chapter, we will combine the lessons from the last three chapters, allowing us to create a script tool that will run analysis and produce spreadsheets and maps from the analysis results.</p></div></body></html>