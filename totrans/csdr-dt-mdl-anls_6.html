<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Enhancing a Version</h1></div></div></div><p>Traditionally, changes are usually not welcomed and are avoided as much as possible by a relational database developer. However, business changes every day, especially in the present fast-paced era. The <a id="id491" class="indexterm"/>delayed response to business changes of a system using a relational database deteriorates the agility and even threatens the survival of the enterprise. With the advancement of NoSQL and other related technologies, we now have alternatives to embrace such business changes.</p><p>By continuing with the enhancements of the Stock Screener Application developed in <a class="link" href="ch05.html" title="Chapter 5. First-cut Design and Implementation">Chapter 5</a>, <em>First-cut Design and Implementation</em>, the techniques of how to evolve an existing Cassandra data model will be explained in detail. Meanwhile, the techniques of modeling by query will be demonstrated as well. The source code of the Stock Screener Application will then be modified accordingly. By the end of this chapter, a complete technical analysis application on stocks will be developed. You can use it as a foundation to quickly develop your own.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Evolving the data model</h1></div></div></div><p>The<a id="id492" class="indexterm"/> Stock Screener Application created in <a class="link" href="ch05.html" title="Chapter 5. First-cut Design and Implementation">Chapter 5</a>, <em>First-cut Design and Implementation</em>, is good enough to <a id="id493" class="indexterm"/>retrieve and analyze a single stock at one time. However, scanning just a single stock looks very limited in practical use. A slight improvement can be made here; it can handle a bunch of stocks instead of one. This bunch of stocks will be stored as Watch List in the Cassandra database.</p><p>Accordingly, the Stock Screener Application will be modified to analyze the stocks in the Watch List, and therefore it will produce alerts for each of the stocks being watched based on the same screening rule.</p><p>For the produced alerts, saving them in Cassandra will be beneficial for backtesting trading strategies and continuous improvement of the Stock Screener Application. They can be reviewed from time to time without having to review them on the fly.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>Backtesting is a jargon used to refer to testing a trading strategy, investment strategy, or a predictive model using existing historical data. It is also a special type of cross-validation applied to time series data.</p></div></div><p>In addition, when<a id="id494" class="indexterm"/> the number of the stocks in the Watch List grows to a few hundred, it will be difficult for a user of the Stock Screener Application to recall what the stocks are by simply referring to their stock codes. Hence, it would be nice to have the name of the stocks added to the produced alerts to make them more descriptive and user-friendly.</p><p>Finally, we <a id="id495" class="indexterm"/>might have an interest in finding out how many alerts were generated on a particular stock over a specified period of time and how many alerts were generated on a particular date. We will use CQL to write queries to answer these two questions. By doing so, the modeling by query technique can be demonstrated.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec81"/>The enhancement approach</h2></div></div></div><p>The <a id="id496" class="indexterm"/>enhancement approach consists of four change requests in total. First, we will conduct changes in the data model and <a id="id497" class="indexterm"/>then the code will be enhanced to provide the new features. Afterwards, we will test run the enhanced Stock Screener Application again. The parts of the Stock Screener Application that require modifications are highlighted in the following figure.</p><p>It is remarkable<a id="id498" class="indexterm"/> that two new components are added to the Stock Screener Application. The first component, <strong>Watch List</strong>, governs <strong>Data Mapper and Archiver</strong><a id="id499" class="indexterm"/> to collect stock quote data of those stocks in the Watch List from Yahoo! Finance. The second component is<a id="id500" class="indexterm"/> <strong>Query</strong>. It provides two Queries on <strong>Alert List</strong><a id="id501" class="indexterm"/> for backtesting purposes:</p><div><img src="img/8884OS_06_01.jpg" alt="The enhancement approach"/></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec18"/>Watch List</h3></div></div></div><p>
<strong>Watch List</strong> <a id="id502" class="indexterm"/>is a very <a id="id503" class="indexterm"/>simple table that merely stores the stock code of its constituents. It is rather intuitive for a relational database developer to define the stock code as the primary key, isn't it? Nevertheless, remember that in Cassandra, the primary key is used to determine the node that stores the row. As Watch List is expected to not be a very long list, it would be more appropriate to put all of its rows on the same node for faster retrieval. But how can we do that?</p><p>We can create an additional column, say <code class="literal">watch_list_code</code>, for this particular purpose. The new table<a id="id504" class="indexterm"/> is called <code class="literal">watchlist</code> and <a id="id505" class="indexterm"/>will be created in the <code class="literal">packtcdma</code> keyspace. The CQL statement is shown in <code class="literal">chapter06_001.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_001.py

## import Cassandra driver library
from cassandra.cluster import Cluster

## function to create watchlist
def create_watchlist(ss):
    ## create watchlist table if not exists
    ss.execute('CREATE TABLE IF NOT EXISTS watchlist (' + \
               'watch_list_code varchar,' + \
               'symbol varchar,' + \
               'PRIMARY KEY (watch_list_code, symbol))')
    
    ## insert AAPL, AMZN, and GS into watchlist
    ss.execute("INSERT INTO watchlist (watch_list_code, " + \
               "symbol) VALUES ('WS01', 'AAPL')")
    ss.execute("INSERT INTO watchlist (watch_list_code, " + \
               "symbol) VALUES ('WS01', 'AMZN')")
    ss.execute("INSERT INTO watchlist (watch_list_code, " + \
               "symbol) VALUES ('WS01', 'GS')")

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect()

## use packtcdma keyspace
session.set_keyspace('packtcdma')

## create watchlist table
create_watchlist(session)

## close Cassandra connection
cluster.shutdown()</pre></div><p>The <code class="literal">create_watchlist</code> function creates the table. Note that the <code class="literal">watchlist</code> table has a compound primary <a id="id506" class="indexterm"/>key made of <code class="literal">watch_list_code</code> and <code class="literal">symbol</code>. A Watch List called <code class="literal">WS01</code> is also created, which contains three stocks, <code class="literal">AAPL</code>, <code class="literal">AMZN</code>, and <code class="literal">GS</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec19"/>Alert List</h3></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. First-cut Design and Implementation">Chapter 5</a>, <em>First-cut Design and Implementation</em>, <strong>Alert List</strong><a id="id507" class="indexterm"/> is very rudimentary. It is produced by<a id="id508" class="indexterm"/> a Python program and enumerates the date when the close price was above its 10-day SMA, that is, the signal and the close price at that time. Note that there were no stock code and stock name.</p><p>We will create a table called <code class="literal">alertlist</code> to store the alerts with the code and name of the stock. The inclusion of the stock name is to meet the requirement of making the Stock Screener Application more user-friendly. Also, remember that joins are not allowed and denormalization is really the best practice in Cassandra. This means that we do not mind repeatedly storing (duplicating) the stock name in the tables that will be queried. A rule of thumb is <em>one table for one query</em>; as simple as that.</p><p>The <code class="literal">alertlist</code> table is created by the CQL statement, as shown in <code class="literal">chapter06_002.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_002.py

## import Cassandra driver library
from cassandra.cluster import Cluster

## function to create alertlist
def create_alertlist(ss):
    ## execute CQL statement to create alertlist table if not exists
    ss.execute('CREATE TABLE IF NOT EXISTS alertlist (' + \
               'symbol varchar,' + \
               'price_time timestamp,' + \
               'stock_name varchar,' + \
               'signal_price float,' + \
               'PRIMARY KEY (symbol, price_time))')

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect()

## use packtcdma keyspace
session.set_keyspace('packtcdma')

## create alertlist table
create_alertlist(session)

## close Cassandra connection
cluster.shutdown()</pre></div><p>The primary key <a id="id509" class="indexterm"/>is also a compound primary key that consists of <code class="literal">symbol</code> and <code class="literal">price_time</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec20"/>Adding the descriptive stock name</h3></div></div></div><p>Until now, the <code class="literal">packtcdma</code> keyspace<a id="id510" class="indexterm"/> has three tables, which are <code class="literal">alertlist</code>, <code class="literal">quote</code>, and <code class="literal">watchlist</code>. To add the descriptive stock name, one can think of only adding a column of stock name to <code class="literal">alertlist</code> only. As seen in the previous section, this has been done. So, do we need to add a column for <code class="literal">quote</code> and <code class="literal">watchlist</code>?</p><p>It is, in fact, a design decision that depends on whether these two tables will be serving user queries. What a user query means is that the table will be used to retrieve rows for a query raised by a user. If a user wants to know the close price of Apple Inc. on June 30, 2014, it is a user query. On the other hand, if the Stock Screener Application uses a query to retrieve rows for its internal processing, it is not a user query. Therefore, if we want <code class="literal">quote</code> and <code class="literal">watchlist</code> to return rows for user queries, they need the stock name column; otherwise, they do not need it.</p><p>The <code class="literal">watchlist</code> table is only for internal use by the current design, and so it need not have the stock name column. Of course, if in future, the Stock Screener Application allows a user to maintain Watch List, the stock name should also be added to the <code class="literal">watchlist</code> table.</p><p>However, for <code class="literal">quote</code>, it is a bit tricky. As the stock name should be retrieved from the Data Feed Provider, which is Yahoo! Finance in our case, the most suitable time to get it is when the corresponding stock quote data is retrieved. Hence, a new column called <code class="literal">stock_name</code> is added to <code class="literal">quote</code>, as shown in <code class="literal">chapter06_003.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_003.py

## import Cassandra driver library
from cassandra.cluster import Cluster

## function to add stock_name column
def add_stockname_to_quote(ss):
    ## add stock_name to quote
    ss.execute('ALTER TABLE quote ' + \
               'ADD stock_name varchar')

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect()

## use packtcdma keyspace
session.set_keyspace('packtcdma')

## add stock_name column
add_stockname_to_quote(session)

## close Cassandra connection
cluster.shutdown()</pre></div><p>It is quite <a id="id511" class="indexterm"/>self-explanatory. Here, we use the <code class="literal">ALTER TABLE</code> statement to add the <code class="literal">stock_name</code> column of the <code class="literal">varchar</code> data type to <code class="literal">quote</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Queries on alerts</h3></div></div></div><p>As <a id="id512" class="indexterm"/>mentioned <a id="id513" class="indexterm"/>previously, we are interested in two questions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How many alerts were generated on a stock over a specified period of time?</li><li class="listitem" style="list-style-type: disc">How many alerts were generated on a particular date?</li></ul></div><p>For the first question, <code class="literal">alertlist</code> is sufficient to provide an answer. However, <code class="literal">alertlist</code> cannot answer the second question because its primary key is composed of <code class="literal">symbol</code> and <code class="literal">price_time</code>. We need to create another table specifically for that question. This is an example of modeling by query.</p><p>Basically, the structure of the new table for the second question should resemble the structure of <code class="literal">alertlist</code>. We <a id="id514" class="indexterm"/>give<a id="id515" class="indexterm"/> that table a name, <code class="literal">alert_by_date</code>, and create it as shown in <code class="literal">chapter06_004.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_004.py

## import Cassandra driver library
from cassandra.cluster import Cluster

## function to create alert_by_date table
def create_alertbydate(ss):
    ## create alert_by_date table if not exists
    ss.execute('CREATE TABLE IF NOT EXISTS alert_by_date (' + \
               'symbol varchar,' + \
               'price_time timestamp,' + \
               'stock_name varchar,' + \
               'signal_price float,' + \
               'PRIMARY KEY (price_time, symbol))')

## create Cassandra instance
cluster = Cluster()

## establish Cassandra connection, using local default
session = cluster.connect()

## use packtcdma keyspace
session.set_keyspace('packtcdma')

## create alert_by_date table
create_alertbydate(session)

## close Cassandra connection
cluster.shutdown()</pre></div><p>When compared to <code class="literal">alertlist</code> in <code class="literal">chapter06_002.py</code>, <code class="literal">alert_by_date</code> only swaps the order of the columns in the compound primary key. One might think that a secondary index can be created on <code class="literal">alertlist</code> to achieve the same effect. Nonetheless, in Cassandra, a secondary index cannot be created on columns that are already engaged in the primary key. Always be aware of this constraint.</p><p>We now finish the modifications on the data model. It is time for us to enhance the application<a id="id516" class="indexterm"/> logic <a id="id517" class="indexterm"/>in the next section.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Enhancing the code</h1></div></div></div><p>Regarding the <a id="id518" class="indexterm"/>new requirements to be<a id="id519" class="indexterm"/> incorporated into the Stock Screener Application, Watch List is created, and we will continue to implement the code for the remaining changes in this section.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Data Mapper and Archiver</h2></div></div></div><p>Data Mapper and Archiver <a id="id520" class="indexterm"/>are components of the Data Feed Provider module, and its source code file is <code class="literal">chapter05_005.py</code>. Most of the source code can be left intact; we only need to add code to:</p><div><ol class="orderedlist arabic"><li class="listitem">Load Watch List for a Watch List code and retrieve data feed based on that</li><li class="listitem">Retrieve the name of the stocks and store it in the quote table</li></ol></div><p>The modified source code is shown in <code class="literal">chapter06_005.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_005.py

## import Cassandra driver library
from cassandra.cluster import Cluster
from decimal import *

## web is the shorthand alias of pandas.io.data
import pandas.io.data as web
import datetime

## import BeautifulSoup and requests
from bs4 import BeautifulSoup
import requests

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## d: standardized DataFrame containing historical data
## sn: stock name
def insert_quote(ss, sym, d, sn):
    ## CQL to insert data, ? is the placeholder for parameters
    insert_cql = "INSERT INTO quote (" + \
                 "symbol, price_time, open_price, high_price," + \
                 "low_price, close_price, volume, stock_name" + \
                 ") VALUES (?, ?, ?, ?, ?, ?, ?, ?)"
    ## prepare the insert CQL as it will run repeatedly
    insert_stmt = ss.prepare(insert_cql)

    ## set decimal places to 4 digits
    getcontext().prec = 4

    ## loop thru the DataFrame and insert records
    for index, row in d.iterrows():
        ss.execute(insert_stmt, \
                   [sym, index, \
                   Decimal(row['open_price']), \
                   Decimal(row['high_price']), \
                   Decimal(row['low_price']), \
                   Decimal(row['close_price']), \
                   Decimal(row['volume']), \
                   sn])</pre></div><p>Here, we<a id="id521" class="indexterm"/> changed the <code class="literal">INSERT</code> statement to store the stock name into <code class="literal">quote</code> in the <code class="literal">insert_quote</code> function. We then add a function called <code class="literal">load_watchlist</code>:</p><div><pre class="programlisting">## retrieve the historical daily stock quote from Yahoo! Finance
## Parameters
## sym: stock symbol
## sd: start date
## ed: end date
def collect_data(sym, sd, ed):
    ## data is a DataFrame holding the daily stock quote
    data = web.DataReader(sym, 'yahoo', sd, ed)
    return data

## transform received data into standardized format
## Parameter
## d: DataFrame containing Yahoo! Finance stock quote
def transform_yahoo(d):
    ## drop extra column 'Adj Close'
    d1 = d.drop(['Adj Close'], axis=1)

    ## standardize the column names
    ## rename index column to price_date
    d1.index.names=['price_date']

    ## rename the columns to match the respective columns
    d1 = d1.rename(columns={'Open':'open_price', \
                            'High':'high_price', \
                            'Low':'low_price', \
                            'Close':'close_price', \
                            'Volume':'volume'})
    return d1

## function to retrieve watchlist
## ss: Cassandra session
## ws: watchlist code
def load_watchlist(ss, ws):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT symbol FROM watchlist " + \
                 "WHERE watch_list_code=?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [ws])

    ## initialize the stock array
    stw = []

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        stw.append(r.symbol)

    return stw</pre></div><p>Here, the<a id="id522" class="indexterm"/> new function, <code class="literal">load_watchlist</code>, submits a <code class="literal">SELECT</code> query on <code class="literal">watch_list</code> to retrieve the stocks<a id="id523" class="indexterm"/> to be watched of a particular Watch List code; it then returns a list of <code class="literal">symbol</code>:</p><div><pre class="programlisting">## function to retrieve stock name from Yahoo!Finance
## sym: stock symbol
def get_stock_name(sym):
  url = 'http://finance.yahoo.com/q/hp?s=' + sym + \
  '+Historical+Prices'
  r = requests.get(url)
  soup = BeautifulSoup(r.text)
  data = soup.findAll('h2')
  return data[2].text

def testcase001():
    ## create Cassandra instance
    cluster = Cluster()
    
    ## establish Cassandra connection, using local default
    session = cluster.connect('packtcdma')
    
    start_date = datetime.datetime(2012, 1, 1)
    end_date = datetime.datetime(2014, 6, 28)
    
    ## load the watchlist
    stocks_watched = load_watchlist(session, "WS01")
    
    ## iterate the watchlist
    for symbol in stocks_watched:
        ## get stock name
        stock_name = get_stock_name(symbol)
    
        ## collect data
        data = collect_data(symbol, start_date, end_date)
    
        ## transform Yahoo! Finance data
        data = transform_yahoo(data)
    
        ## insert historical data
        insert_quote(session, symbol, data, stock_name)
    
    ## close Cassandra connection
    cluster.shutdown()

testcase001()</pre></div><p>The change here <a id="id524" class="indexterm"/>is a new function named <code class="literal">get_stock_name</code>, which sends a web service request to Yahoo! Finance and extracts the name of the stock from the returned HTML page. We use a Python package called <code class="literal">BeautifulSoup</code> to make the extraction of an element from a HTML page very convenient. The <code class="literal">get_stock_name</code> function then returns the stock name.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>
<code class="literal">BeautifulSoup</code><a id="id525" class="indexterm"/> is a library designed for quick turnaround projects such as screen scraping. It primarily parses any text given to it and finds anything wanted through the tree traversal of the parsed text. More information can be found at <a class="ulink" href="http://www.crummy.com/software/BeautifulSoup/">http://www.crummy.com/software/BeautifulSoup/</a>.</p></div></div><p>A <code class="literal">for</code> loop is used to iterate through the Watch List to retrieve the stock name and the stock quote data. In addition, as we need to store the stock name in the <code class="literal">quote</code> table, the <code class="literal">insert_quote</code> function accepts the stock name as a new parameter and requires a little modification on the <code class="literal">INSERT</code> statement and the <code class="literal">for</code> loop accordingly.</p><p>That is all about the changes on Data Mapper and Archiver.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec22"/>Stock Screener Engine</h3></div></div></div><p>We will use the<a id="id526" class="indexterm"/> source code of Stock Screener Engine in <a class="link" href="ch05.html" title="Chapter 5. First-cut Design and Implementation">Chapter 5</a>, <em>First-cut Design and Implementation</em> to include the enhancements; to do so, we will perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Similar to Data Mapper and Archiver, we will load Watch List for a Watch List code and scan for alerts on each stock.</li><li class="listitem">Retrieve stock quote data with the stock name column from the quote table.</li><li class="listitem">Save the alerts into <code class="literal">alertlist</code>.</li></ol></div><p>The modified source code is shown in <code class="literal">chapter06_006.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_006.py

## import Cassandra driver library
from cassandra.cluster import Cluster

import pandas as pd
import numpy as np
import datetime

## import Cassandra BatchStatement library
from cassandra.query import BatchStatement
from decimal import *

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## sd: start date
## ed: end date
## return a DataFrame of stock quote
def retrieve_data(ss, sym, sd, ed):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT * FROM quote WHERE symbol=? " + \
                 "AND price_time &gt;= ? AND price_time &lt;= ?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [sym, sd, ed])

    ## initialize an index array
    idx = np.asarray([])

    ## initialize an array for columns
    cols = np.asarray([])

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        idx = np.append(idx, [r.price_time])
        cols = np.append(cols, [r.open_price, r.high_price, \
                         r.low_price, r.close_price, \
                         r.volume, r.stock_name])

    ## reshape the 1-D array into a 2-D array for each day
    cols = cols.reshape(idx.shape[0], 6)

    ## convert the arrays into a pandas DataFrame
    df = pd.DataFrame(cols, index=idx, \
                      columns=['open_price', 'high_price', \
                      'low_price', 'close_price', \
                      'volume', 'stock_name'])
    return df</pre></div><p>As we have<a id="id527" class="indexterm"/> included the stock name in the query resultset, we need to modify the <code class="literal">SELECT</code> statement in the <code class="literal">retrieve_data</code> function:</p><div><pre class="programlisting">## function to compute a Simple Moving Average on a DataFrame
## d: DataFrame
## prd: period of SMA
## return a DataFrame with an additional column of SMA
def sma(d, prd):
    d['sma'] = pd.rolling_mean(d.close_price, prd)
    return d

## function to apply screening rule to generate buy signals
## screening rule, Close &gt; 10-Day SMA
## d: DataFrame
## return a DataFrame containing buy signals
def signal_close_higher_than_sma10(d):
    return d[d.close_price &gt; d.sma]

## function to retrieve watchlist
## ss: Cassandra session
## ws: watchlist code
def load_watchlist(ss, ws):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT symbol FROM watchlist " + \
                 "WHERE watch_list_code=?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [ws])

    ## initialize the stock array
    stw = []

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        stw.append(r.symbol)

    return stw

## function to insert historical data into table quote
## ss: Cassandra session
## sym: stock symbol
## d: standardized DataFrame containing historical data
## sn: stock name
def insert_alert(ss, sym, sd, cp, sn):
    ## CQL to insert data, ? is the placeholder for parameters
    insert_cql1 = "INSERT INTO alertlist (" + \
                 "symbol, price_time, signal_price, stock_name" +\
                 ") VALUES (?, ?, ?, ?)"

    ## CQL to insert data, ? is the placeholder for parameters
    insert_cql2 = "INSERT INTO alert_by_date (" + \
                 "symbol, price_time, signal_price, stock_name" +\
                 ") VALUES (?, ?, ?, ?)"

    ## prepare the insert CQL as it will run repeatedly
    insert_stmt1 = ss.prepare(insert_cql1)
    insert_stmt2 = ss.prepare(insert_cql2)

    ## set decimal places to 4 digits
    getcontext().prec = 4

    ## begin a batch
    batch = BatchStatement()
    
    ## add insert statements into the batch
    batch.add(insert_stmt1, [sym, sd, cp, sn])
    batch.add(insert_stmt2, [sym, sd, cp, sn])
    
    ## execute the batch
    ss.execute(batch)

def testcase002():
    ## create Cassandra instance
    cluster = Cluster()
    
    ## establish Cassandra connection, using local default
    session = cluster.connect('packtcdma')
    
    start_date = datetime.datetime(2012, 6, 28)
    end_date = datetime.datetime(2012, 7, 28)
    
    ## load the watch list
    stocks_watched = load_watchlist(session, "WS01")
    
    for symbol in stocks_watched:
        ## retrieve data
        data = retrieve_data(session, symbol, start_date, end_date)
        
        ## compute 10-Day SMA
        data = sma(data, 10)
        
        ## generate the buy-and-hold signals
        alerts = signal_close_higher_than_sma10(data)
        
        ## save the alert list
        for index, r in alerts.iterrows():
            insert_alert(session, symbol, index, \
                         Decimal(r['close_price']), \
                         r['stock_name'])
    
    ## close Cassandra connection
    cluster.shutdown()

testcase002()</pre></div><p>At the bottom <a id="id528" class="indexterm"/>of <code class="literal">chapter06_006.py</code>, the <code class="literal">for</code> loop is responsible for iterating <code class="literal">watchlist</code> loaded by the new <code class="literal">load_watchlist</code> function, which is the same function as in <code class="literal">chapter06_005.py</code> and does not require further explanation. Another <code class="literal">for</code> loop inside saves the scanned alerts into <code class="literal">alertlist</code> by calling the new <code class="literal">insert_alert</code> function.</p><p>Before explaining the <code class="literal">insert_alert</code> function, let us jump to the <code class="literal">retrieve_data</code> function at the top. The <code class="literal">retrieve_data</code> function is modified to return the name of the stock as well and hence the <code class="literal">cols</code> variable now contains six columns. Scroll down a bit to <code class="literal">insert_alert</code>.</p><p>The <code class="literal">insert_alert</code> function, as its name suggests, saves the alert into <code class="literal">alertlist</code> and <code class="literal">alert_by_date</code>. It has two <code class="literal">INSERT</code> statements for these two tables, respectively. The <code class="literal">INSERT</code> statements are <a id="id529" class="indexterm"/>almost identical except for the name of the table. Obviously, they are repeated, and this is what denormalization means. We also apply a new feature of Cassandra 2.0 here, known as <em>batch</em>. A batch combines multiple <strong>data modification language</strong> (<strong>DML</strong>)<a id="id530" class="indexterm"/> statements into a single logical, atomic operation. The Cassandra Python driver from DataStax supports this feature by the <code class="literal">BatchStatement</code> package. We create a batch by calling the <code class="literal">BatchStatement()</code> function, then add the prepared <code class="literal">INSERT</code> statements into the batch, and finally execute it. If either <code class="literal">INSERT</code> statement comes across an error during commit, all DML statements in the batch will not be executed. Therefore, it is analogous to a transaction in a relational database.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec23"/>Queries on Alerts</h3></div></div></div><p>The <a id="id531" class="indexterm"/>last modification to the Stock Screener Application is the enquiry functions on alerts that are useful for backtesting and performance measurement. We write two queries to answer the two questions, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How many alerts were generated on a stock over a specified period of time?</li><li class="listitem" style="list-style-type: disc">How many alerts were generated on a particular date?</li></ul></div><p>As we have used denormalization on the data model, it is very easy to execute. For the first query, see <code class="literal">chapter06_007.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_007.py

## import Cassandra driver library
from cassandra.cluster import Cluster

import pandas as pd
import numpy as np
import datetime

## execute CQL statement to retrieve rows of
## How many alerts were generated on a particular stock over
## a specified period of time?
def alert_over_daterange(ss, sym, sd, ed):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT * FROM alertlist WHERE symbol=? " + \
                 "AND price_time &gt;= ? AND price_time &lt;= ?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [sym, sd, ed])

     ## initialize an index array
    idx = np.asarray([])

    ## initialize an array for columns
    cols = np.asarray([])

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        idx = np.append(idx, [r.price_time])
        cols = np.append(cols, [r.symbol, r.stock_name, \
                         r.signal_price])

    ## reshape the 1-D array into a 2-D array for each day
    cols = cols.reshape(idx.shape[0], 3)

    ## convert the arrays into a pandas DataFrame
    df = pd.DataFrame(cols, index=idx, \
                      columns=['symbol', 'stock_name', \
                      'signal_price'])
    return df

def testcase001():
    ## create Cassandra instance
    cluster = Cluster()
    
    ## establish Cassandra connection, using local default
    session = cluster.connect()
    
    ## use packtcdma keyspace
    session.set_keyspace('packtcdma')

    ## scan buy-and-hold signals for GS
    ## over 1 month since 28-Jun-2012
    symbol = 'GS'
    start_date = datetime.datetime(2012, 6, 28)
    end_date = datetime.datetime(2012, 7, 28)
    
    ## retrieve alerts
    alerts = alert_over_daterange(session, symbol, \
                                  start_date, end_date)
    
    for index, r in alerts.iterrows():
        print index.date(), '\t', \
            r['symbol'], '\t', \
            r['stock_name'], '\t', \
            r['signal_price']
    
    ## close Cassandra connection
    cluster.shutdown()

testcase001()</pre></div><p>A function named <code class="literal">alert_over_daterange</code> is defined to retrieve the rows relevant to the first question. Then it transforms the CQL resultset to a pandas DataFrame.</p><p>Then we can <a id="id532" class="indexterm"/>come up with a query for the second question with reference to the same logic in <code class="literal">chapter06_007.py</code>. The source code is shown in <code class="literal">chapter06_008.py</code>:</p><div><pre class="programlisting"># -*- coding: utf-8 -*-
# program: chapter06_008.py

## import Cassandra driver library
from cassandra.cluster import Cluster

import pandas as pd
import numpy as np
import datetime

## execute CQL statement to retrieve rows of
## How many alerts were generated on a particular stock over
## a specified period of time?
def alert_on_date(ss, dd):
    ## CQL to select data, ? is the placeholder for parameters
    select_cql = "SELECT * FROM alert_by_date WHERE " + \
                 "price_time=?"

    ## prepare select CQL
    select_stmt = ss.prepare(select_cql)

    ## execute the select CQL
    result = ss.execute(select_stmt, [dd])

     ## initialize an index array
    idx = np.asarray([])

    ## initialize an array for columns
    cols = np.asarray([])

    ## loop thru the query resultset to make up the DataFrame
    for r in result:
        idx = np.append(idx, [r.symbol])
        cols = np.append(cols, [r.stock_name, r.price_time, \
                         r.signal_price])

    ## reshape the 1-D array into a 2-D array for each day
    cols = cols.reshape(idx.shape[0], 3)

    ## convert the arrays into a pandas DataFrame
    df = pd.DataFrame(cols, index=idx, \
                      columns=['stock_name', 'price_time', \
                      'signal_price'])
    return df

def testcase001():
    ## create Cassandra instance
    cluster = Cluster()
    
    ## establish Cassandra connection, using local default
    session = cluster.connect()
    
    ## use packtcdma keyspace
    session.set_keyspace('packtcdma')
    
    ## scan buy-and-hold signals for GS over 1 month since 28-Jun-2012
    on_date = datetime.datetime(2012, 7, 13)
    
    ## retrieve alerts
    alerts = alert_on_date(session, on_date)
    
    ## print out alerts
    for index, r in alerts.iterrows():
        print index, '\t', \
              r['stock_name'], '\t', \
              r['signal_price']
    
    ## close Cassandra connection
    cluster.shutdown()

testcase001()</pre></div><p>Once again, denormalization is a <a id="id533" class="indexterm"/>friend of Cassandra. It does not require a foreign key, referential integrity, or table join.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Implementing system changes</h1></div></div></div><p>We can now<a id="id534" class="indexterm"/> implement<a id="id535" class="indexterm"/> the changes to the system one-by-one:</p><div><ol class="orderedlist arabic"><li class="listitem">First we run <code class="literal">chapter06_001.py</code> through to <code class="literal">chapter06_004.py</code> in sequence to make changes to the data model.</li><li class="listitem">Then we execute <code class="literal">chapter06_005.py</code> to retrieve stock quote data for the Watch List. It is worth mentioning that UPSERT is a very nice feature of Cassandra. We do not encounter a duplicate primary key while we insert the same row into a table. It simply updates the row if the row already exists or inserts the row otherwise. It makes the data manipulation logic neat and clean.</li><li class="listitem">Further, we run <code class="literal">chatper06_006.py</code> to store the alerts by scanning over the stock quote data of each stock in the Watch List.</li><li class="listitem">Finally, we <a id="id536" class="indexterm"/>execute <code class="literal">chapter06_007.py</code> and <code class="literal">chapter06_008.py</code> to <a id="id537" class="indexterm"/>enquire <code class="literal">alertlist</code> and <code class="literal">alert_by_date</code>, respectively. Their sample test results are shown in the following figure:<div><img src="img/8884OS_06_02.jpg" alt="Implementing system changes"/></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Summary</h1></div></div></div><p>This chapter extends the Stock Screener Application by a number of enhancements. We made changes to the data model to demonstrate the modeling by query techniques and how denormalization can help us achieve a high-performance application. We also tried the batch feature provided by Cassandra 2.0.</p><p>Note that the source code in this chapter is not housekept and can be refactored somehow. However, because of the limit on the number of pages, it is left as an exercise for the reader.</p><p>The Stock Screener Application is now running on a single node cluster.</p><p>In the next chapter, we will delve into the considerations and procedures of expanding it to a larger cluster, which is quite common in real-life production systems.</p></div></body></html>