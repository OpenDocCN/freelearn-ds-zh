<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Spatial Databases"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Spatial Databases</h1></div></div></div><p>In this chapter, we will look at how you can use a database to store, analyze, and manipulate geospatial data. While spatial databases can be quite complex, and the process of optimizing spatial queries can be challenging, they can be used in a straightforward way without too much fuss and are an important part of the geospatial analyst's toolkit.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn the important concepts you'll need to know before using a spatial database</li><li class="listitem" style="list-style-type: disc">Install the PostgreSQL relational database system onto your computer</li><li class="listitem" style="list-style-type: disc">Install the PostGIS extension to PostgreSQL to support spatial databases</li><li class="listitem" style="list-style-type: disc">Install the <code class="literal">psycopg2</code> database adapter to allow you to access Postgres from your Python programs</li><li class="listitem" style="list-style-type: disc">Learn how to create a spatial database using PostGIS</li><li class="listitem" style="list-style-type: disc">Discover how to import data into your spatial database using Python</li><li class="listitem" style="list-style-type: disc">Learn how to query your spatial database using Python code</li><li class="listitem" style="list-style-type: disc">See how you can manipulate your spatial data from Python</li><li class="listitem" style="list-style-type: disc">Learn how to export data out of a spatial database</li></ul></div><p>Let's start by looking at the concept of spatial databases and how they work.</p><div class="section" title="Spatial database concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Spatial database concepts</h1></div></div></div><p>As mentioned in the previous<a id="id207" class="indexterm"/> chapter, spatial databases are databases which can store and query spatial data. Each record in a spatially-enabled database table has one or more <span class="strong"><strong>geometry fields</strong></span><a id="id208" class="indexterm"/> which position that record somewhere on the Earth's surface. How the geometry field(s) are used will depend on what type of information you are storing in the database table. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A record representing a delivery vehicle might include a Point geometry reflecting the vehicle's current location.</li><li class="listitem" style="list-style-type: disc">A record representing a road might include a LineString geometry representing the shape of the road.</li><li class="listitem" style="list-style-type: disc">A record representing a<a id="id209" class="indexterm"/> forest fire might include a Polygon geometry representing the area affected by the fire.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Some spatial databases allow you to have multiple geometry fields, while others are limited to just one per record.</p></div></div></li></ul></div><p>By itself, a geometry field is simply a database <span class="emphasis"><em>blob</em></span> which can hold the encoded geometry data. The data is usually stored in<a id="id210" class="indexterm"/> <span class="strong"><strong>Well-Known Binary</strong></span> (<span class="strong"><strong>WKB</strong></span>) format. This allows you to store and retrieve geometry data from the database. However, by itself, this isn't very useful—what defines a spatial database is the ability to build a<a id="id211" class="indexterm"/> <span class="strong"><strong>spatial index</strong></span> using the stored geometry values.</p><p>A spatial index is what allows you to search for records in the database based on their position on the Earth's surface. A spatial index does not index the geometry directly. Instead, it calculates the <span class="strong"><strong>bounding box</strong></span> for each geometry, and then indexes that bounding box. The following illustration shows how this works:</p><div class="mediaobject"><img src="images/4102_03_01.jpg" alt="Spatial database concepts"/></div><p>A common task for spatial indexes is to identify the geometry (or geometries) that contain a given point. For example, if the user clicks on a location on a map, you might want to know which country, if any, the user clicked on. This is represented by a spatial database query such as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SELECT * FROM table WHERE ST_Contains(table.geometry, click_point);</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The <code class="literal">ST_Contains</code> function<a id="id212" class="indexterm"/> is an example of a database query function. This function is provided by the PostGIS spatial database. Different spatial databases use different names for their various query functions; all the query functions listed in this chapter come from PostGIS, as that is the database we'll be working with in this book.</p></div></div><p>To perform this query, the <a id="id213" class="indexterm"/>database first uses the spatial index to identify those records that have a bounding box containing the desired point. This process is shown in the following diagram:</p><div class="mediaobject"><img src="images/4102_03_02.jpg" alt="Spatial database concepts"/></div><p>The crosshairs represent the desired point, and the rectangles represent the bounding boxes. As you can see, there are two bounding boxes which contain the desired point. These bounding boxes correspond to the records labeled <code class="literal">France</code> and <code class="literal">Germany</code> in the database. The database uses this information to load each of the matching geometries into memory and checks each one in turn to see if it contains the desired point:</p><div class="mediaobject"><img src="images/4102_03_03.jpg" alt="Spatial database concepts"/></div><p>In this way, the database was able to<a id="id214" class="indexterm"/> determine that the click point was inside Germany.</p><p>Let's review this process, as it is a very important concept. The database <span class="emphasis"><em>first</em></span> identifies the potentially matching records using the bounding boxes stored in the spatial index and <span class="emphasis"><em>then</em></span> loads each potential geometry into memory to check it. This two-step process is surprisingly efficient: by using the bounding boxes in the spatial index, it immediately discards the vast majority of records which are not a potential match. It then performs the relatively time-consuming task of loading the geometry into memory only for the few potential matches, and then checks each of these in turn.</p><p>It is important that you understand this two-step process of performing spatial queries because you have to do certain things to make sure it works. In particular:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You have to ensure that the geometries you want to query against are included in a spatial index.</li><li class="listitem" style="list-style-type: disc">You have to carefully phrase your query so that the database can actually use the index you have set up. If, for example, the database has to transform your geometry from one spatial reference system to another, or perform some sort of spatial manipulation on the data before it can be queried against, then your spatial index will be ignored and the database will revert to performing a sequential scan of all your data. This can be extremely slow, taking hours or even days to complete a single query.</li><li class="listitem" style="list-style-type: disc">If you have an extremely complex geometry with a large bounding box, for example, a detailed outline of the United States, you may find that your queries are still taking a long time to complete. This is because the bounding box covers such a large area of the Earth's surface that it is being included in many queries, and the complexity of the outline means that the query is still taking a long time to process. One way to solve this problem is to split a large and complex geometry into smaller pieces, so the database only has to process one small piece rather than the whole thing.</li></ul></div><p>Despite these potential issues, a spatial <a id="id215" class="indexterm"/>database is a wonderful tool for storing and analyzing geospatial data. Of course, spatial databases are not limited to just searching for records using <code class="literal">ST_Contains()</code>. They can be used for all sorts of spatial queries as seen in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Spatial query function</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ST_Within</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id216" class="indexterm"/>matches the records that have a geometry completely enclosed by a given polygon.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ST_Intersects</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id217" class="indexterm"/> matches the records where the record's geometry intersects with a given geometry.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ST_Crosses</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id218" class="indexterm"/> matches the records where the record's geometry crosses over a given line or polygon.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ST_DWithin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id219" class="indexterm"/> matches the records that are within a given distance of a given location or geometry.</p>
</td></tr></tbody></table></div><p>There are some subtleties in these spatial query functions which you will need to become familiar with—these are described in detail in the PostGIS documentation. However, this table should give you an idea of the power of a spatial database and tell you how a spatial database (using the appropriate spatial indexes) can be a great tool for working with geospatial data, especially when you have many records to process.</p><p>Now that you have some idea of how a spatial database works, let's install one on your computer and then see how we can access it from within your Python programs.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Installing a spatial database"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Installing a spatial database</h1></div></div></div><p>In this book, we are going to <a id="id220" class="indexterm"/>use one of the most popular and powerful<a id="id221" class="indexterm"/> geospatial databases: PostGIS. PostGIS is an extension to the freely available PostgreSQL relational database. To use it in our Python programs, we need to install three separate pieces of software:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The PostgreSQL database server itself</li><li class="listitem" style="list-style-type: disc">The PostGIS extension to PostgreSQL</li><li class="listitem" style="list-style-type: disc">The <code class="literal">psycopg2</code> database adapter for Python<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>PostgreSQL is often referred to simply as<a id="id222" class="indexterm"/> <span class="strong"><strong>Postgres</strong></span>. We will use this more colloquial name regularly throughout this book.</p></div></div></li></ul></div><p>Let's work through the <a id="id223" class="indexterm"/>process of installing each of these pieces of software<a id="id224" class="indexterm"/> in turn.</p><div class="section" title="Installing PostgreSQL"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Installing PostgreSQL</h2></div></div></div><p>PostgreSQL (<a class="ulink" href="http://postgresql.org">http://postgresql.org</a>) is<a id="id225" class="indexterm"/> one of the most powerful open source relational <a id="id226" class="indexterm"/>databases <a id="id227" class="indexterm"/>available. While it <a id="id228" class="indexterm"/>has a reputation for being difficult to set up and use, it's not too tricky, and with prebuilt installers available for every major operating system the setup process is now quite straightforward.</p><p>Let's go ahead and get PostgreSQL installed on your computer. How you do this depends on which operating system you are running:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your computer runs Microsoft Windows<a id="id229" class="indexterm"/>, you can download an installer for PostgreSQL from <a class="ulink" href="http://www.enterprisedb.com/products-services-training/pgdownload">http://www.enterprisedb.com/products-services-training/pgdownload</a>. Select the appropriate installer for your version of Windows (32-bit or 64-bit), and download the installer file. Then simply double-click on the downloaded installer and follow the instructions.</li><li class="listitem" style="list-style-type: disc">If you are running Mac OS X, you can download a working version of PostgreSQL from the <a id="id230" class="indexterm"/>KyngChaos web site, <a class="ulink" href="http://www.kyngchaos.com/software/postgres">http://www.kyngchaos.com/software/postgres</a>. Simply download the disk image, open it, and double-click on the <span class="strong"><strong>PostgreSQL.pkg</strong></span> package file to install PostgreSQL on your computer.</li><li class="listitem" style="list-style-type: disc">If you are using a Linux machine, you can <a id="id231" class="indexterm"/>follow the instructions on the PostgreSQL download page, <a class="ulink" href="http://www.postgresql.org/download">http://www.postgresql.org/download</a>. Choose the appropriate link for the Linux distribution you are using, and you will be presented with the appropriate installation instructions.</li></ul></div><p>Once you have installed PostgreSQL, you can check that it is running by typing the <code class="literal">psql</code> command into a terminal or command-line window. If all going well, you should see the Postgres command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql (9.3.4)</strong></span>
<span class="strong"><strong>Type "help" for help.</strong></span>

<span class="strong"><strong>postgres=#</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If the <code class="literal">psql</code> command complains about user authentication, you may need to specify a user account to use when connecting to Postgres. For example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% psql –U postgres</strong></span>
</pre></div><p>Many Postgres installations have a <code class="literal">postgres</code> user, which you need to select (using the <code class="literal">–U</code> command-line option) when accessing the database. Alternatively, you may need to use <code class="literal">sudo</code> to switch to the root user, or open the command prompt as an administrator if you are running Microsoft Windows.</p></div></div></div><div class="section" title="Installing PostGIS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Installing PostGIS</h2></div></div></div><p>Now that we've installed<a id="id232" class="indexterm"/> Postgres itself, we next need to install the PostGIS spatial database <a id="id233" class="indexterm"/>extension. The main website for PostGIS can be <a id="id234" class="indexterm"/>found at <a class="ulink" href="http://postgis.net">http://postgis.net</a>. You should go to this website, click on the <span class="strong"><strong>Documentation</strong></span> tab, and download the user manual for the latest version of PostGIS. You'll find this manual very helpful, as it explains PostGIS in great detail, including all the various sorts of queries you can make.</p><p>How you install PostGIS depends on which operating system you are running:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your computer is <a id="id235" class="indexterm"/>running MS Windows, you can download an installer for PostGIS from <a class="ulink" href="http://download.osgeo.org/postgis/windows">http://download.osgeo.org/postgis/windows</a>.</li><li class="listitem" style="list-style-type: disc">For Mac OS X<a id="id236" class="indexterm"/>, download and run the PostGIS installer from <a class="ulink" href="http://kyngchaos.com/software/postgres">http://kyngchaos.com/software/postgres</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Note that you will also need to have installed the GDAL Complete package, which you should have already done when working through the previous chapter.</p></div></div></li><li class="listitem" style="list-style-type: disc">If you are using a Linux-based <a id="id237" class="indexterm"/>operating system, follow the instructions on the PostGIS installation page: <a class="ulink" href="http://postgis.net/install">http://postgis.net/install</a>.</li></ul></div><p>To check that PostGIS has been successfully installed, try typing the following sequence of commands into your terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% createdb test_database</strong></span>
<span class="strong"><strong>% psql -d test_database -c "CREATE EXTENSION postgis;"</strong></span>
<span class="strong"><strong>% dropdb test_database</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>You'll need to add a <code class="literal">–U postgres</code> option or use <code class="literal">sudo</code> for each of these commands if you need to run PostgreSQL under a different user account.</p></div></div><p>As you can probably guess, the <code class="literal">createdb</code> command creates a new database. We then use the <code class="literal">psql</code> command to initialize that database with the PostGIS extension, and finally the <code class="literal">dropdb</code> command deletes the database again. If this sequence of commands runs without error, your PostGIS installation (and Postgres itself) is set up and running properly.</p></div><div class="section" title="Installing psycopg2"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Installing psycopg2</h2></div></div></div><p>Now that we've got a spatial<a id="id238" class="indexterm"/> database, let's install the <code class="literal">psycopg2</code> library so we can access it using <a id="id239" class="indexterm"/>Python.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>
<code class="literal">psycopg2</code> is<a id="id240" class="indexterm"/> a standard Python database adapter—that is, it's a library that conforms to the Python Database API specified in PEP 249 (<a class="ulink" href="https://www.python.org/dev/peps/pep-0249">https://www.python.org/dev/peps/pep-0249</a>). We will look at how to use <code class="literal">psycopg2</code> to store and query against spatial data, but if you have not worked with a Python database adapter before, you may want to look at one of the available tutorials on the subject. A good tutorial on the subject can be found at <a class="ulink" href="http://halfcooked.com/presentations/osdc2006/python_databases.html">http://halfcooked.com/presentations/osdc2006/python_databases.html</a>.</p></div></div><p>The website for <code class="literal">psqcopg2</code> can be found at <a class="ulink" href="http://initd.org/psycopg">http://initd.org/psycopg</a>. As usual, how you install this library depends on which operating system you are using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For MS Windows, you can download a double-clickable installer<a id="id241" class="indexterm"/> from <a class="ulink" href="http://www.stickpeople.com/projects/python/win-psycopg">http://www.stickpeople.com/projects/python/win-psycopg</a>.</li><li class="listitem" style="list-style-type: disc">If your computer runs<a id="id242" class="indexterm"/> Mac OS X, a double-clickable installer can be found at <a class="ulink" href="http://www.kyngchaos.com/software/python">http://www.kyngchaos.com/software/python</a>.</li><li class="listitem" style="list-style-type: disc">For a Linux machine, you <a id="id243" class="indexterm"/>will need to install <code class="literal">psycopg2</code> from source. For instructions on how to do this, please refer to <a class="ulink" href="http://initd.org/psycopg/docs/install.html">http://initd.org/psycopg/docs/install.html</a>.</li></ul></div><p>To check that it worked, start up your Python interpreter and type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; import psycopg2</strong></span>
<span class="strong"><strong>&gt;&gt;&gt;</strong></span>
</pre></div><p>If <code class="literal">psycopg2</code> was installed correctly, you should see the Python interpreter prompt reappear with no error message, as shown in this example. If an error message does appear, you may need to follow the troubleshooting instructions on the <code class="literal">psycopg2</code> website.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Accessing PostGIS from Python"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Accessing PostGIS from Python</h1></div></div></div><p>So far, we <a id="id244" class="indexterm"/>have installed some tools and libraries onto your <a id="id245" class="indexterm"/>computer. Now it's time to use those tools and libraries to do something interesting. In the remainder of this chapter, we are going to import the World Borders Dataset into a PostGIS database, which we will call <code class="literal">world_borders</code>, and then use Python to perform various queries against that data. We will also see how we can manipulate that dataset using PostGIS and Python.</p><p>To start with, create a new directory named <code class="literal">world_borders</code> and place it somewhere convenient. You will use this directory to store the various files you create.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Setting up a spatial database"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Setting up a spatial database</h1></div></div></div><p>When accessing <a id="id246" class="indexterm"/>a database using <code class="literal">psycopg2</code>, we first have to specify which database we are going to use. This means that the database must exist before your Python code can use it. To set everything up, we'll use the Postgres command-line utilities. Type the following into your terminal or command-line window:</p><div class="informalexample"><pre class="programlisting">% createdb world_borders</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Don't forget to include the <code class="literal">-U postgres</code> option, or <code class="literal">sudo</code>, if you need to access Postgres under a different user account.</p></div></div><p>This creates the database itself. We next want to enable the PostGIS spatial extension for our database. To do this, enter the following command:</p><div class="informalexample"><pre class="programlisting">% psql -d world_borders -c "CREATE EXTENSION postgis;"</pre></div><p>Now that we've set up the database itself, let's create the table within the database which will hold our spatial data. To do this, we're going to create a Python program called <code class="literal">create_table.py</code>. Go ahead and create this file within your <code class="literal">world_borders</code> directory, and enter the following into the file:</p><div class="informalexample"><pre class="programlisting">import psycopg2</pre></div><p>We now want to open up a connection to the database. To do this, we have to tell <code class="literal">psycopg2</code> which database to use and which user account (and possibly, which password) to use to access that database. This is done by providing keyword parameters to the <code class="literal">psycopg2.connect()</code> function, like this:</p><div class="informalexample"><pre class="programlisting">connection = psycopg2.connect(database="world_borders", user="...", password="...")</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>You'll only need the <code class="literal">user</code> parameter if you needed to supply a <code class="literal">-U</code> command-line argument when running the Postgres command-line tools. You'll also only need the <code class="literal">password</code> if that user account is password-protected.</p></div></div><p>Once we have a database connection, we then set up a <code class="literal">cursor</code> object, which we'll use to issue commands to the database:</p><div class="informalexample"><pre class="programlisting">cursor = connection.cursor()</pre></div><p>The next step may be a bit counter-intuitive: rather than creating the database table, we're going to delete it if it already exists. Doing this lets us run the <code class="literal">create_table.py</code> script multiple times without causing any errors. Here is the relevant code:</p><div class="informalexample"><pre class="programlisting">cursor.execute("DROP TABLE IF EXISTS borders")</pre></div><p>The <code class="literal">execute()</code> statement <a id="id247" class="indexterm"/>tells the cursor to run the given SQL command. In this case, the command is <code class="literal">DROP TABLE IF EXISTS</code>, which tells the database to delete (drop) the table if it already exists.</p><p>We can now create our database table using the following command:</p><div class="informalexample"><pre class="programlisting">cursor.execute("CREATE TABLE borders (" +
                   "id SERIAL PRIMARY KEY," +
                   "name VARCHAR NOT NULL," +
                   "iso_code VARCHAR NOT NULL," +
                   "outline GEOGRAPHY)")</pre></div><p>Notice that we have split this command across multiple lines to make it easier to read. With the exception of the last line, this is a standard SQL database table definition: we're creating a table where each record has a unique <code class="literal">id</code> value automatically allocated by the database, a <code class="literal">name</code> value, and an <code class="literal">iso_code</code> value. In the final line, we create the <code class="literal">outline</code> field and give it a type of <code class="literal">GEOGRAPHY</code>. Geography fields are specific to PostGIS; they are a variant of the <code class="literal">GEOMETRY</code> field type and are designed to work with spatial data that uses unprojected latitude and longitude coordinates.</p><p>Now that we've created our database table, let's set up a spatial index on this data. As we have seen, a spatial index will greatly speed up queries against our database. Let's create a spatial index for our <code class="literal">outline</code> field:</p><div class="informalexample"><pre class="programlisting">cursor.execute("CREATE INDEX border_index ON borders USING GIST(outline)")</pre></div><p>Finally, because Postgres is a transactional database, we need to <span class="emphasis"><em>commit</em></span> the changes we have made, to make them permanent. Here is the necessary code to do this:</p><div class="informalexample"><pre class="programlisting">connection.commit()</pre></div><p>This finishes our <code class="literal">create_table.py</code> program, which should look like the following:</p><div class="informalexample"><pre class="programlisting">import psycopg2

connection = psycopg2.connect(database="world_borders", user="...", password="...")
cursor = connection.cursor()

cursor.execute("DROP TABLE IF EXISTS borders")

cursor.execute("CREATE TABLE borders (" +
                   "id SERIAL PRIMARY KEY," +
                   "name VARCHAR NOT NULL," +
                   "iso_code VARCHAR NOT NULL," +
                   "outline GEOGRAPHY)")

cursor.execute("CREATE INDEX border_index ON borders USING GIST(outline)")
connection.commit()</pre></div><p>If you run this program, your <a id="id248" class="indexterm"/>database table and the associated spatial index will be created. Let's now import the contents of the World Borders Dataset into our newly created table.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Importing spatial data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Importing spatial data</h1></div></div></div><p>Take a copy<a id="id249" class="indexterm"/> of the <code class="literal">TM_WORLD_BORDERS-0.3</code> directory you downloaded earlier, and place it inside your <code class="literal">world_borders</code> directory. Then create another Python script named <code class="literal">import_data.py</code>. This is where you will place the code to import the data into your database.</p><p>We are going to use the OGR library to import the data from the shapefile, and <code class="literal">psycopg2</code> to insert it into the database. So the first two lines in our program should look like the following:</p><div class="informalexample"><pre class="programlisting">import osgeo.ogr
import psycopg2</pre></div><p>We next need to open up a connection to the database. The code to do this is identical to the code that we used in the <code class="literal">create_table.py</code> script:</p><div class="informalexample"><pre class="programlisting">connection = psycopg2.connect(database="world_borders", user="...", password="...")
cursor = connection.cursor()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>Don't forget to adjust the keyword parameters to <code class="literal">psycopg2.connect()</code> to match the user account you need to connect to PostgreSQL.</p></div></div><p>We are now ready to start importing the data from the shapefile. First, though, we are going to delete the existing contents of our database table; this will let us run our <code class="literal">import_data.py</code> program multiple times, wiping out the existing records before adding new ones, so that we start each time with a blank slate:</p><div class="informalexample"><pre class="programlisting">cursor.execute("DELETE FROM borders")</pre></div><p>We are now ready to import the data from the shapefile into the database. Let's start this by opening the shapefile and extracting the information we want from it, one feature at a time:</p><div class="informalexample"><pre class="programlisting">shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3/TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)

for i in range(layer.GetFeatureCount()):
    feature  = layer.GetFeature(i)
    name     = feature.GetField("NAME")
    iso_code = feature.GetField("ISO3")
    geometry = feature.GetGeometryRef()</pre></div><p>This should be <a id="id250" class="indexterm"/>familiar to you, since we worked with OGR to read the contents of a shapefile in the previous chapter. Now that we have the geometry, we can convert it into WKT format, like this:</p><div class="informalexample"><pre class="programlisting">    wkt = geometry.ExportToWkt()</pre></div><p>We now have all the information we need to insert the feature into the database. Here is the code to perform the actual insertion:</p><div class="informalexample"><pre class="programlisting">    cursor.execute("INSERT INTO borders (name, iso_code, outline) VALUES (%s, %s, ST_GeogFromText(%s))", (name, iso_code, wkt))</pre></div><p>There is a lot going on here, so let's take a closer look at this command. We are using <code class="literal">INSERT</code> here, which is a standard SQL command. The <code class="literal">INSERT</code> command has the following basic structure:</p><div class="informalexample"><pre class="programlisting">INSERT INTO table (field, field, ...) VALUES (value, value, ...);</pre></div><p>As you can see, we specify the name of the database table, a list of fields, and the values to store into those fields.</p><p>As a standard Python database adapter, <code class="literal">psycopg2</code> will automatically translate Python values, such as integers, floating point numbers, strings, <code class="literal">datetime</code> objects and the like, into their SQL equivalents. This is where those <code class="literal">%s</code> placeholders come in—we use <code class="literal">%s</code> in our SQL command string at each point where we want to provide a value, and then supply the actual values themselves as the second parameter to the <code class="literal">cursor.execute()</code> command. Consider, for example, the following Postgres command:</p><div class="informalexample"><pre class="programlisting">cursor.execute("INSERT INTO users (name, age) VALUES (%s, %s)", (user_name, user_age))</pre></div><p>This command would insert a record into the <code class="literal">users</code> table, setting the <code class="literal">name</code> field to the value of the <code class="literal">user_name</code> variable, and the <code class="literal">age</code> field to the value of the <code class="literal">user_age</code> variable. This conversion of Python values to SQL string literals is extremely powerful and is one of the major benefits of using a database adapter.</p><p>There is one final complexity in the <code class="literal">INSERT</code> statement we are using to import the shapefile's contents into our <code class="literal">borders</code> table: we are using the <code class="literal">ST_GeogFromText()</code> function to convert our WKT-format string into a geography value before inserting it into the <code class="literal">outline</code> field. We have to do this because OGR and Postgres use different internal representations for geometry data. WKT format strings are the <span class="emphasis"><em>lingua franca</em></span> that converts between these two internal representations.</p><p>After we have finished importing the various features from the shapefile, we have to commit our changes so that they are written to the database:</p><div class="informalexample"><pre class="programlisting">connection.commit()</pre></div><p>Putting all of this<a id="id251" class="indexterm"/> together, here's what our <code class="literal">import_data.py</code> program looks like:</p><div class="informalexample"><pre class="programlisting">import osgeo.ogr
import psycopg2

connection = psycopg2.connect(database="world_borders", user="...", password="...")
cursor = connection.cursor()

cursor.execute("DELETE FROM borders")

shapefile = osgeo.ogr.Open("TM_WORLD_BORDERS-0.3.shp")
layer = shapefile.GetLayer(0)

for i in range(layer.GetFeatureCount()):
    feature = layer.GetFeature(i)
    name = feature.GetField("NAME")
    iso_code = feature.GetField("ISO3")
    geometry = feature.GetGeometryRef()
    wkt = geometry.ExportToWkt()

    cursor.execute("INSERT INTO borders (name, iso_code, outline) VALUES (%s, %s, ST_GeogFromText(%s))", (name, iso_code, wkt))

connection.commit()</pre></div><p>When we run this program, all the records from the World Borders Dataset shapefile should be imported into the database. Notice that it only takes a few seconds to complete—even though we have to convert the outlines from OGR geometries into WKT, and then convert from WKT into PostGIS geography objects, it does not take long to do this.</p><p>If you want, you can <a id="id252" class="indexterm"/>run the <code class="literal">psql</code> command-line client and type commands such as <code class="literal">SELECT id,name,iso_code FROM borders</code> to see the data that you have imported. But of course we really want to use Python to query against our spatial database. Let's do this now.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Querying spatial data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Querying spatial data</h1></div></div></div><p>Let's write another <a id="id253" class="indexterm"/>Python program to perform various queries against the contents of our database. Start by creating another Python file named <code class="literal">query_data.py</code> and place it into the <code class="literal">world_borders</code> directory. We start by importing the <code class="literal">psycopg2</code> library, opening up a connection to our database, and creating a database cursor:</p><div class="informalexample"><pre class="programlisting">import psycopg2
connection = psycopg2.connect(database="world_borders", user="...", password="...")
cursor = connection.cursor()</pre></div><p>This should all be familiar from the <code class="literal">create_table.py</code> program we created earlier.</p><p>Let's now perform a simple (non-spatial) database query, just to see how it works. Add the following to the end of your program:</p><div class="informalexample"><pre class="programlisting">cursor.execute("SELECT id,name FROM borders ORDER BY name")
for row in cursor:
    print row</pre></div><p>When you run your <code class="literal">query_data.py</code> program, you should see a list of the record IDs and associated names, taken from your <code class="literal">borders</code> table:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(1264, 'Afghanistan')</strong></span>
<span class="strong"><strong>(1237, 'Albania')</strong></span>
<span class="strong"><strong>(1235, 'Algeria')</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>Notice that you use <code class="literal">cursor.execute()</code> to execute your query, and then iterate over the cursor to get the matching rows. The value for each row is a tuple containing the fields you requested.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Of course, you can also use <code class="literal">%s</code> to include Python values in your query, for example:</p><div class="informalexample"><pre class="programlisting">cursor.execute("SELECT id FROM borders WHERE name=%s", (country_name,))</pre></div></div></div><p>So far, we have been using the non-spatial aspects of PostgreSQL. Let's now make a spatial query against this data. We're going to ask the database to identify all countries within 1,000 kilometers of Paris. Using the <code class="literal">GEOGRAPHY</code> data type in PostGIS, this is easy to do:</p><div class="informalexample"><pre class="programlisting">lat    = 48.8567
long   = 2.3508
radius = 1000000

cursor.execute("SELECT name FROM borders WHERE ST_DWITHIN(" +
                   "ST_MakePoint(%s, %s), outline, %s)", (long, lat, radius))
for row in cursor:
    print row[0]</pre></div><p>The <code class="literal">ST_DWithin</code> command<a id="id254" class="indexterm"/> identifies the countries that are within <code class="literal">radius</code> meters of the specified point; running the program should return a list of the countries that are within 1,000 kilometers of Paris:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>San Marino</strong></span>
<span class="strong"><strong>Denmark</strong></span>
<span class="strong"><strong>Ireland</strong></span>
<span class="strong"><strong>Austria</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Switzerland</strong></span>
<span class="strong"><strong>United Kingdom</strong></span>
</pre></div><p>This gives you an idea of how powerful PostGIS is, and the types of queries you can make using the <code class="literal">psycopg2</code> database adapter. Make sure you study the <span class="emphasis"><em>PostGIS Reference</em></span> section of the PostGIS manual to learn about the various sorts of spatial queries you can make.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Manipulating spatial data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Manipulating spatial data</h1></div></div></div><p>You are not limited to<a id="id255" class="indexterm"/> just using static data in your spatial analysis. You can also create new geometries and manipulate existing geometries directly within a PostGIS database. While it's easy to create a brand new geometry using functions such as the <code class="literal">ST_GeogFromText()</code> function we used earlier, you can also use the PostGIS geometry editing and geometry processing functions to create new geography values derived from old ones.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>There are some limitations on the functions available when you use the PostGIS <code class="literal">GEOGRAPHY</code> type. PostGIS originally only supported the <code class="literal">GEOMETRY</code> data type, which was designed to only work with spatial data projected onto a flat Cartesian plane. When using the <code class="literal">GEOGRAPHY</code> field, check the PostGIS manual to see which functions are supported.</p></div></div><p>To get an idea of how we can<a id="id256" class="indexterm"/> calculate new spatial values based on our existing data, let's write a program to buffer our outlines, and store them into a new <code class="literal">GEOGRAPHY</code> column in our database table.</p><p>We saw the <code class="literal">buffer()</code> operation in the previous chapter, where we saw that it can often be used to fix an invalid geometry. If you remember, the <code class="literal">buffer()</code> operation constructs a new geometry that includes all points within a certain distance of the existing geometry. The following image shows the outline of the United Kingdom, and the same outline after it has been buffered:</p><div class="mediaobject"><img src="images/4102_03_04.jpg" alt="Manipulating spatial data"/></div><p>Let's write a program to<a id="id257" class="indexterm"/> calculate these buffered outlines. Create a new Python script in your <code class="literal">world_borders</code> directory, and name it <code class="literal">buffer.py</code>. Enter the following into this file:</p><div class="informalexample"><pre class="programlisting">import psycopg2
connection = psycopg2.connect(database="world_borders", user="...", password="...")
cursor = connection.cursor()</pre></div><p>We now want to create a new field to hold the buffered outline. To do this, add the following to the end of your file:</p><div class="informalexample"><pre class="programlisting">try:
    cursor.execute("ALTER TABLE borders ADD COLUMN buffered_outline GEOGRAPHY")
except psycopg2.ProgrammingError:
    connection.rollback()</pre></div><p>The <code class="literal">ALTER TABLE</code> command is a standard Postgres command to change the structure of a database table; in this case, we add a new <code class="literal">GEOGRAPHY</code> column named <code class="literal">buffered_outline</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Notice that we wrapped our <code class="literal">ALTER TABLE</code> command in a <code class="literal">try...except</code> statement. This is because <code class="literal">psycopg2</code> will raise <code class="literal">ProgrammingError</code> if the column already exists. By catching this error, we can run our <code class="literal">buffer.py</code> program multiple times without it failing because the <code class="literal">buffered_outline</code> field has already been added to the table.</p><p>Because of transaction issues with exceptions in <code class="literal">psycopg2</code>, we have to call <code class="literal">connection.rollback()</code> when an exception occurs. This allows the program to continue even though an exception has been raised.</p></div></div><p>Our next task is to calculate the buffered outlines. Using PostGIS, this is very easy:</p><div class="informalexample"><pre class="programlisting">cursor.execute("UPDATE borders SET buffered_outline=ST_Buffer(outline, 1000)")</pre></div><p>In this SQL statement, we are setting the value of the <code class="literal">buffered_outline</code> field to the result of the <code class="literal">ST_Buffer()</code> command. The <code class="literal">ST_Buffer()</code> command accepts a geography value and a distance in meters; it returns a new geography that contains all points that are within the given distance from the existing geography.</p><p>Our final task is to commit the changes we have made to the database:</p><div class="informalexample"><pre class="programlisting">connection.commit()</pre></div><p>This actually completes our <code class="literal">buffer.py</code> program, and if we run it, we will get a buffered version of each outline stored in the <code class="literal">buffered_outline</code> field. However, because this program does not show anything, there's no way of knowing if it actually worked. To get around this, let's add a final spatial query to calculate and display the area of each outline.</p><p>The basic structure of our query will look like the following:</p><div class="informalexample"><pre class="programlisting">cursor.execute("SELECT name, ST_Area(outline), ST_Area(buffered_outline) FROM borders ORDER BY name")
for name, area1, area2 in cursor:
    ...</pre></div><p>The result of the <code class="literal">ST_Area()</code> function is the area of the geography measured in square meters. Because these numbers can be huge, we'll want to convert them into square kilometers for display. However, there is a slight problem: when we buffer a geometry, it can sometimes become invalid because the buffered geometry lies outside the range of valid latitude and longitude values. Even though we only buffered the geographies by a kilometer, any geographies that lie close to the north or south pole, or close to the limits of -180 or +180 degrees of longitude, will have an invalid buffered outline. When we try to calculate the area of these invalid outlines, the result will be a <code class="literal">NaN</code> (Not a Number) value.</p><p>Let's add some code to<a id="id258" class="indexterm"/> check for invalid areas and handle them gracefully; replace the <code class="literal">...</code> line in the previous code listing with the following:</p><div class="informalexample"><pre class="programlisting">    if not math.isnan(area1):
        area1 = int(area1/1000000)
    else:
        area1 = "n/a"
    if not math.isnan(area2):
        area2 = int(area2/1000000)
    else:
        area2 = "n/a"
    print name, area1, area2</pre></div><p>You will also need to add an <code class="literal">import math</code> statement to the top of your program.</p><p>Running this program will take a minute or so to calculate all the buffers, after which the calculated areas will be displayed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Afghanistan 641915 646985</strong></span>
<span class="strong"><strong>Albania 28676 29647</strong></span>
<span class="strong"><strong>Algeria 2317478 2324740</strong></span>
<span class="strong"><strong>American Samoa 229 363</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Zimbabwe 389856 392705</strong></span>
<span class="strong"><strong>Åland Islands 817 1144</strong></span>
</pre></div><p>As you can see, the buffered area is somewhat larger than the original one, which is what you would expect.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Exporting spatial data"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Exporting spatial data</h1></div></div></div><p>Our introduction to<a id="id259" class="indexterm"/> spatial databases is almost complete; the only thing left to examine is how to get spatial data out of PostGIS again, for example to save it back into a shapefile. To extract a spatial value from a <code class="literal">GEOGRAPHY</code> field, use the <code class="literal">ST_AsText()</code> function. For example:</p><div class="informalexample"><pre class="programlisting">cursor.execute("SELECT name,ST_AsText(outline) FROM borders")
for name,wkt in cursor:
    geometry = osgeo.ogr.CreateGeometryFromWkt(wkt)
    ...</pre></div><p>You can then use the OGR geometry to write the spatial data into a shapefile, or do anything else you wish to do with it.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we looked at how spatial databases can be a powerful tool for geospatial data analysis. We covered the important concepts behind spatial databases, and installed PostgreSQL, PostGIS, and <code class="literal">psycopg2</code> onto your computer. We then got our hands dirty by creating a spatial database, importing data into that database, performing spatial queries, manipulating spatial data using PostGIS, and exporting data from a spatial database, all using Python code.</p><p>In the next chapter, we will explore how to use the Mapnik library to produce great-looking maps based on our geospatial data.</p></div></div>
</body></html>