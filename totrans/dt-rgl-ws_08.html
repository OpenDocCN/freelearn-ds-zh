<html><head></head><body><div><div><div></div>
		</div>
		<div><h1 id="_idParaDest-254"><a id="_idTextAnchor262"/>8. RDBMS and SQL</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter will introduce you to the basics of using an RDBMS to query a database using Python and convert data from SQL and then store it in a <code>pandas</code> DataFrame. It will explain the concepts of databases, including their creation, manipulation, and control, and how to transform tables into <code>pandas</code> DataFrames. By the end of this chapter, you will learn some basic SQL commands. This knowledge will make you adept at adding, updating, retrieving, and deleting data from databases; another valuable skill in a budding data wrangling expert's repertoire.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor263"/>Introduction</h1>
			<p>This chapter of our data journey is focused on <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>) and <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>). In the previous chapter, we stored and read data from a file. In this chapter, we will read structured data, design access to the data, and create query interfaces for databases.</p>
			<p>For years, the RDBMS format has been the conventional way to store data. An RDBMS is one of the safest ways to store, manage, and retrieve data. It is backed by a solid mathematical foundation (relational algebra and calculus) and exposes an efficient and intuitive declarative language – SQL – for easy interaction. Almost every language has a rich set of libraries to interact with different RDBMS, and the tricks and methods of using them are well tested and well understood.</p>
			<p>Scaling an RDBMS is a pretty well-understood task, and there is a group of well trained, experienced professionals to do this job (DBAs, or database administrators).</p>
			<p>So, it is understandable that we, as data wrangling professionals or data engineers, will encounter RDBMS at some point. We will need the tools and knowledge acquired from this chapter to deal with RDBMS.</p>
			<p>As we can see in the following chart, the database management system market is big. This chart was produced based on market research that was done by Scalegrid in 2019:</p>
			<div><div><img src="img/B15780_08_01.jpg" alt="Figure 8.1: Commercial database market share released by ScaleGrid in 2019&#13;&#10;" width="1450" height="902"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: Commercial database market share released by ScaleGrid in 2019</p>
			<p>We will learn and play around with some of the basic and fundamental concepts of database and relational database management systems in this chapter. We will start with a refresher of the theoretical concept of a database, and then we will create and operate a database from our Python environment.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor264"/>Refresher of RDBMS and SQL</h1>
			<p>An RDBMS is a piece of software that manages data (represented for the end user in tabular form) on physical hard disks and is built using Codd's relational model. Most of the databases that we encounter today are RDBMS. In recent years, there has been a huge industry shift toward a newer kind of database management system, called NoSQL (MongoDB, CouchDB, Riak, and so on). These systems, while they do follow some of the rules of RDBMS in certain aspects, in most cases they reject or modify them.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor265"/>How Is an RDBMS Structured?</h2>
			<p>The RDBMS structure consists of three main elements, namely the storage engine, the query engine, and log management. Here is a diagram that demonstrates the structure of an RDBMS:</p>
			<div><div><img src="img/B15780_08_02.jpg" alt="Figure 8.2: RDBMS structure&#13;&#10;" width="549" height="427"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: RDBMS structure</p>
			<p>The following are the main concepts of any RDBMS structure:</p>
			<ul>
				<li><strong class="bold">Storage engine:</strong> This is the part of the RDBMS that is responsible for storing data in an efficient way and also retrieving it, when asked for, in an efficient way. As an end user of the RDBMS system (an application developer is considered an end user of an RDBMS), we will never need to interact with this layer directly.</li>
				<li><strong class="bold">Query engine:</strong> This is the part of the RDBMS that allows us to create data objects (tables, views, and so on), manipulate them (create and delete columns, create/delete/update rows, and so on), and query them (read rows) using a simple, yet powerful, language.</li>
				<li><strong class="bold">Log management:</strong> This part of the RDBMS is responsible for creating and maintaining the logs. If you are wondering why the log is such an important thing, then you should look into how replication and partitions are handled in a modern RDBMS (such as PostgreSQL) using something called the <strong class="bold">Write Ahead Log</strong> (or <strong class="bold">WAL</strong> for short).</li>
			</ul>
			<p>We will focus on the query engine in this chapter.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor266"/>SQL</h2>
			<p><strong class="bold">SQL</strong> (pronounced <em class="italic">sequel</em>), as it is commonly known, is a domain-specific language that was originally designed based on E.F. Codd's relational model and is widely used in today's databases to define, insert, manipulate, and retrieve data from them. It can be further sub-divided into four smaller sub-languages, namely <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>), <strong class="bold">Data Manipulation Language</strong> (<strong class="bold">DML</strong>), <strong class="bold">Data Query Language</strong> (<strong class="bold">DQL</strong>), and <strong class="bold">Data Control Language</strong> (<strong class="bold">DCL</strong>). There are several advantages of using SQL, some of which are as follows:</p>
			<ul>
				<li>It is based on a solid mathematical framework and thus it is easy to understand.</li>
				<li>It is a declarative language, which means that we actually never tell it how to do its job. We almost always tell it what to do. This frees us from the big burden of writing custom code for data management. We can be more focused on the actual query problem we are trying to solve, instead of bothering about how to create and maintain a data store.</li>
				<li>It gives you a fast and readable way to deal with data.</li>
				<li>SQL gives you out-of-the-box ways to get multiple pieces of data with a single query.</li>
			</ul>
			<p>The main areas of focus for the following topic will be DDL, DML, and DQL. The DCL part is more for database administrators. Let's discuss them briefly:</p>
			<ul>
				<li><code>CREATE TABLE</code>, <code>DROP TABLE</code>, and <code>ALTER TABLE</code>. <p class="callout-heading">Note</p><p class="callout">Notice the use of uppercase letters. This is not a requirement, and you may use lowercase letters, but it is a widely followed convention, and we will use it in this book.</p></li>
				<li><code>INSERT INTO</code>, <code>DELETE FROM</code>, or <code>UPDATE</code>.</li>
				<li><code>SELECT</code> command. We will also see and use the concepts of the primary key, foreign key, index, joins, and so on.</li>
			</ul>
			<p>Once you define and insert data in a database, it can be represented as follows:</p>
			<div><div><img src="img/B15780_08_03.jpg" alt="Figure 8.3: Table displaying sample data&#13;&#10;" width="725" height="319"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Table displaying sample data</p>
			<p>Another thing to remember about an RDBMS is relations. Generally, in a table, we have one or more columns that will have unique values for each row in the table. We call them <strong class="bold">primary keys</strong> for the table. We should be aware that we will encounter unique values across the rows, which are not primary keys. The main difference between them and primary keys is the fact that a primary key cannot be null.</p>
			<p>By using the primary key of one table and mentioning it as a foreign key in another table, we can establish relations between two tables. A certain table can be related to any finite number of tables. </p>
			<p>The relations can be <code>1:1</code>, which means that each row of the second table is uniquely related to one row of the first table, or <code>1:N</code>, <code>N:1</code>, or <code>N: M</code>. An example of relations is as follows:</p>
			<div><div><img src="img/B15780_08_04.jpg" alt="Figure 8.4: Diagram showing relations&#13;&#10;" width="694" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Diagram showing relations</p>
			<p>With this brief refresher, we are now ready to jump into hands-on exercises and write some SQL to store and retrieve data.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor267"/>Using an RDBMS (MySQL/PostgreSQL/SQLite)</h2>
			<p>In this topic, we will focus on how to write some basic SQL commands, as well as how to connect to a database from Python and use it effectively within Python. The database we will choose here is SQLite. There are other databases, such as Oracle, MySQL, PostgreSQL, and DB2. The main tricks that you are going to learn here will not change depending on the database you are using. However, for different databases, you will need to install different third-party Python libraries (such as Psycopg2 for PostgreSQL). The reason they all behave the same way (apart for some small details) is the fact that they all adhere to PEP249 (commonly known as Python DB API 2).</p>
			<p>This is a good standardization and saves us a lot of headaches while porting from one RDBMS to another. If you already have some experience with databases, then you will notice that we will not be using any server address, username, password, or other credentials to connect to a database. This is because these fields are not mandatory in sqlite3, unlike in PostgreSQL or MySQL. The main database engine of SQLite is embedded.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most of the industry-standard projects that are written in Python and use some kind of RDBMS as the data store most often rely on an <strong class="bold">Object Relational Mapper </strong>(<strong class="bold">ORM</strong>). An ORM is a high-level library in Python that makes many tasks easier when dealing with an RDBMS. It also exposes a more Pythonic API than writing raw SQL inside Python code.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor268"/>Exercise 8.01: Connecting to a Database in SQLite</h2>
			<p>In this exercise, we will look into the first step toward using an RDBMS in Python code. We are going to connect to a database, <code>lesson.db</code>. We will then close the connection safely. Let's perform the following steps:</p>
			<ol>
				<li>Import the <code>sqlite3</code> library from Python by using the following command:<pre>import sqlite3</pre></li>
				<li>Use the <code>connect</code> function to connect to a database:<pre>conn = sqlite3.connect("../lesson.db")</pre></li>
				<li>Close the connection, as follows:<pre>conn.close()</pre><p>This <code>conn</code> object is the main connection object, and we will need it to get a second type of object in the future once we want to interact with the database. We need to be careful about closing any open connection to our database.</p></li>
				<li>Use the same <code>with</code> statement from Python, just like we did for files, and connect to the database, as follows:<pre>with sqlite3.connect("../lesson.db") as conn:
    pass</pre></li>
			</ol>
			<p>In this exercise, we have connected to a database using Python.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YMWrBD">https://packt.live/2YMWrBD</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3df6q87">https://packt.live/3df6q87</a>.</p>
			<p>In the next exercise, we will see the best way to create a table and put data into it using Python.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor269"/>DDL and DML Commands in SQLite</h2>
			<p>To create a table in SQL, use the <code>CREATE TABLE</code> SQL clause. This will require the table name and the table definition. The table name is a unique identifier for the database engine to find and use the table for all future transactions. It can be anything (any alphanumeric string), as long as it is unique. We add the table definition in the form of (<code>column_name_1 data_type</code>, <code>column_name_2 data type</code>, <code>…</code> ). For our purpose, we will use the text and integer data types, but usually, a standard database engine supports many more data types, such as float, double, date time, and Boolean. We will also need to specify a primary key. A primary key is a unique, non-null identifier that's used to uniquely identify a row in a table. In our case, we use email as a primary key. A primary key can be an integer or text.</p>
			<p>The last thing you need to know is that unless you call a commit on the series of operations you just performed (together, we formally call them a transaction), nothing will actually be performed and reflected in the database. This property is called atomicity. In fact, for a database to be industry-standard (to be useable in real life), it needs to follow the <strong class="bold">Atomicity, Consistency, Isolation, Durability</strong> (<strong class="bold">ACID</strong>) properties.</p>
			<p>As the name suggests, <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>) is the way to communicate with the database engine in advance to define what the data will look like. The database engine creates a table object based on the definition provided and prepares it.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor270"/>Exercise 8.02: Using DDL and DML Commands in SQLite</h2>
			<p>In this exercise, we will connect with the <code>lesson.db</code> database and then create a <code>user</code> table. Then, we will insert data into the table using the DDL and DML commands. Let's perform the following steps:</p>
			<ol>
				<li value="1">Use SQLite's <code>connect</code> function to connect to the <code>lesson.db</code> database. Create a <code>cursor</code> object by calling <code>conn.cursor()</code>. The <code>cursor</code> object acts as a medium by which to communicate with the database: <pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()</pre></li>
				<li>Create a table in Python, as follows:<pre>cursor.execute("CREATE TABLE IF NOT EXISTS \
                user (email text, first_name  text, \
                      last_name text, address text, age integer, \
                      PRIMARY KEY (email))")</pre></li>
				<li>Insert rows into the database that you created, as follows:<pre>cursor.execute("INSERT INTO user VALUES \
               ('bob@example.com', 'Bob', 'Codd', \
                '123  Fantasy lane, Fantasy City', 31)") 
cursor.execute("INSERT INTO user VALUES \
               ('tom@web.com', 'Tom', 'Fake', \
                '456 Fantasy lane, Fantasy City', 39)")</pre></li>
				<li>Commit to the database:<pre>conn.commit()</pre></li>
			</ol>
			<p>This will create the table and write two rows to it with data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YeniaH">https://packt.live/2YeniaH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2BogE8J">https://packt.live/2BogE8J</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the next section, we will read back the data that we just stored. </p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor271"/>Reading Data from a Database in SQLite</h2>
			<p>In the preceding exercise, we created a table and stored data in it. Now, we will learn how to read the data that's stored in this database.</p>
			<p>The <code>SELECT</code> clause is immensely powerful, and it is really important for a data practitioner to master <code>SELECT</code> and everything related to it (such as conditions, joins, and group-by).</p>
			<p>The <code>*</code> after <code>SELECT</code> tells the engine to select all of the columns from the table. This is a useful shorthand. We have not mentioned any condition for the selection (such as above a certain age, first name starting with a certain sequence of letters, and so on). We are practically telling the database engine to select all the rows and all the columns from the table. It is time-consuming and less effective if we have a huge table. Hence, we would want to use the <code>LIMIT</code> clause to limit the number of rows we want.</p>
			<p>You can use the <code>SELECT</code> clause in SQL to retrieve data, as follows:</p>
			<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user')
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<pre>('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)
('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)</pre>
			<p>The syntax to use the <code>SELECT</code> clause with <code>LIMIT</code> is as follows:</p>
			<pre>SELECT * FROM &lt;table_name&gt; LIMIT 50;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">This syntax is sample code and will not work on Jupyter Notebooks.</p>
			<p>This will select all the columns, but only the first <code>50</code> rows from the table. </p>
			<p>Now that we have seen how to connect, write, and read basic data to a database, we will be venturing into more advanced operations in the coming exercises, with the sorting of data being the next one.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor272"/>Exercise 8.03: Sorting Values That Are Present in the Database</h2>
			<p>In this exercise, we will use the <code>ORDER BY</code> clause to sort the rows of the <code>user</code> table with respect to the <code>age</code> column in both descending and ascending order. Let's perform the following steps:</p>
			<ol>
				<li value="1">Connect to the <code>lesson.db</code> database and sort <code>lesson.db</code> by age in descending order, as follows:<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><pre>('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)
('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)</pre></li>
				<li>Sort the <code>lesson.db</code> database by age in ascending order, as follows:<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user ORDER BY age')
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><pre>('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)
('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)</pre></li>
			</ol>
			<p>Notice that we don't need to specify the order as <code>ASC</code> in order to sort it in ascending order.</p>
			<p>In this exercise, we have seen how to sort data. Sorting is one of the most important operations you will often need to do.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37I7Iap">https://packt.live/37I7Iap</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YOu4D5">https://packt.live/2YOu4D5</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the coming exercise, we will see how to update the structure of an already defined table. </p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor273"/>The ALTER Command</h2>
			<p><code>ALTER</code> is a command that is used by a RDBMS to add a new column to an already existing table, or to change the data type of a column, whereas the <code>UPDATE</code> command is used to update the value of one or more columns in one or several rows of a database. We will examine them in the following section to check out their use. </p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor274"/>Exercise 8.04: Altering the Structure of a Table and Updating the New Fields</h2>
			<p>In this exercise, we are going to add a column, <code>gender</code>, using the <code>ALTER</code> command in the <code>user</code> table. Then, by using the <code>UPDATE</code> command, we will set the value of the <code>gender</code> column. Let's perform the following steps:</p>
			<ol>
				<li value="1">Establish a connection with the database by using the following command:<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()</pre></li>
				<li>Add another column in the <code>user</code> table and fill it with null values by using the following command:<pre>cursor.execute("ALTER TABLE user ADD COLUMN gender text")
conn.commit()</pre></li>
				<li>Update all of the values of gender so that they are <code>M</code> by using the following command:<pre>cursor.execute("UPDATE user SET gender='M'")
conn.commit()</pre></li>
				<li>To check the altered table, execute the following command:<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    rows = cursor.execute('SELECT * FROM user ORDER BY age')
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><pre>('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 
 31, 'M')
('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 
 39, 'M')</pre></li>
			</ol>
			<p>We have to be cautious when using <code>UPDATE</code>, because using <code>UPDATE</code> without selective clauses (such as <code>WHERE</code>) affects the entire table.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/312BtBL">https://packt.live/312BtBL</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ddIYbh">https://packt.live/3ddIYbh</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor275"/>The GROUP BY clause</h2>
			<p>We will learn about a concept that we have already learned about in pandas. This is called the <code>GROUP BY</code> clause. The <code>GROUP BY</code> clause is a technique that's used to retrieve distinct values from the database and place them in individual buckets. The following diagram explains how the <code>GROUP BY</code> clause works:</p>
			<div><div><img src="img/B15780_08_05.jpg" alt="Figure 8.5: Illustration of the GROUP BY clause on a table&#13;&#10;" width="1665" height="1071"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Illustration of the GROUP BY clause on a table</p>
			<p>In the preceding diagram, we can see that the <code>col3</code> column has only two unique values across all rows, <code>A</code> and <code>B</code>. The command that's used to check the total number of rows belonging to each group is as follows:</p>
			<pre>SELECT count(*), col3 FROM &lt;tablename&gt; GROUP BY col3</pre>
			<p>Let's go through the following exercise to practice the <code>GroupBy</code> clause.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor276"/>Exercise 8.05: Grouping Values in Tables</h2>
			<p>In this exercise, we will use the <code>GROUP BY</code> clause to select the columns grouped by <code>gender</code>. We'll add users whose genders are male and female to the table and group them based on gender. Let's perform the following steps to do so:</p>
			<ol>
				<li value="1">Establish the connection with the database by using the following command:<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()</pre></li>
				<li>Add a female user to the table:<pre>cursor.execute("INSERT INTO user VALUES ('shelly@www.com', 'Shelly',\
                                         'Milar',\
                                         '123, Ocean View Lane',\
                                         39, 'F')")
conn.commit()
cursor = conn.cursor()
rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')
for row in rows:
    print(row)
('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 
  39, 'M')
('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', 
  39, 'F')
('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 
  31, 'M')</pre></li>
				<li>Run the following code to see the count by each <code>gender</code>:<pre>rows = cursor.execute("SELECT COUNT(*), "\
                      "gender FROM user GROUP BY gender")
for row in rows:
    print(row)</pre><p>The output is as follows:</p><pre>(1, 'F')
(2, 'M')</pre><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fEzV4N">https://packt.live/3fEzV4N</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2N8kS7l">https://packt.live/2N8kS7l</a>.</p></li>
			</ol>
			<p>We have seen by now how to connect to a database, create a table, and insert values in it. We have also looked into topics such as reading values from a table, sorting them, and grouping them by common values. These are all very essential skills to have when dealing with databases. However, we have not looked into the "<em class="italic">Relational</em>" part of an RDBMS. This is what is coming up next.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor277"/>Relation Mapping in Databases</h1>
			<p>We have been working with a single table and altering it, as well as reading back the data. However, the real power of an RDBMS comes from the handling of relationships among different objects (tables). In this section, we are going to create a new table called comments and link it with the user table in a <code>1: N</code> relationship. This means that one user can have multiple comments. The way we are going to do this is by adding the user table's primary key as a foreign key in the comments table. This will create a <code>1: N</code> relationship.</p>
			<p>When we link two tables, we need to specify to the database engine what should be done if the parent row is deleted, which has many children in the other table. As we can see in the following diagram, we are asking what happens at the place of the question marks when we delete <code>row1</code> of the user table:</p>
			<div><div><img src="img/B15780_08_06.jpg" alt="Figure 8.6: Illustration of relations&#13;&#10;" width="1557" height="344"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Illustration of relations</p>
			<p>In a non-RDBMS situation, this situation can quickly become difficult and messy to manage and maintain. However, with an RDBMS, all we have to tell the database engine, in very precise ways, is what to do when a situation like this occurs. The database engine will do the rest for us. We use <code>ON DELETE</code> to tell the engine what we do with all the rows of a table when the parent row gets deleted. The following code illustrates these concepts:</p>
			<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
    CREATE TABLE comments ( \
         user_id text, \
         comments text, \
         FOREIGN KEY (user_id) REFERENCES user (email) \
         ON DELETE CASCADE ON UPDATE NO ACTION \
    )
    """
    cursor.execute(sql)
    conn.commit()</pre>
			<p>The <code>ON DELETE</code> <code>CASCADE</code> line informs the database engine that we want to delete all the children rows when the parent gets deleted. We will cover deleting values in detail in a later exercise. We can also define actions for <code>UPDATE</code>. In this case, there is nothing to do on <code>UPDATE</code>.</p>
			<p>The <code>FOREIGN KEY</code> modifier modifies a column definition (<code>user_id</code>, in this case) and marks it as a foreign key, which is related to the primary key (email, in this case) of another table. A foreign key is a link between two tables. We define a primary key in one table and then define the same values as foreign keys to another table, thereby creating a link between them.</p>
			<p>You may notice the strange looking <code>cursor.execute("PRAGMA foreign_keys = 1")</code> line in the code. It is there just because SQLite does not use the normal foreign key features by default. It is this line that enables that feature. It is typical to SQLite and we won't need it for any other databases.</p>
			<p>Hence, we have covered the idea of relations between two tables. One table can be related to any number of tables. And there are different types of relationships such as <code>1:1</code>, <code>1:n</code>, and <code>n:n</code>. Readers are encouraged to look into these in detail. </p>
			<p>In the next section, we will insert rows in the newly created table.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor278"/>Adding Rows in the comments Table</h2>
			<p>We have created a table called <code>comments</code>. In this section, we will dynamically generate an <code>INSERT</code> query, as follows:</p>
			<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = "INSERT INTO comments VALUES ('{}', '{}')"
    rows = cursor.execute('SELECT * FROM user ORDER BY age')
    for row in rows:
        email = row[0]
        print("Going to create rows for {}".format(email))
        name = row[1] + " " + row[2]
        for i in range(10):
            comment = "This is comment {} by {}".format(i, name)
            conn.cursor().execute(sql.format(email, comment))
            conn.commit()</pre>
			<p>Pay attention to how we dynamically generate the insert query so that we can insert 10 comments for each user.</p>
			<p>We have inserted some rows in the new table and we have established a relationship between this one and the one before. Up next is one of the most important concepts of databases – joins. They help us to write concise queries to retrieve data from several linked tables.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor279"/>Joins</h1>
			<p>Now, we will learn how to exploit the relationship we just built. This means that if we have the primary key from one table, we can recover all the data needed from that table and also all the linked rows from the child table. To achieve this, we will use something called a join.</p>
			<p>A join is basically a way to retrieve linked rows from two tables using any kind of primary key – foreign key relation that they have. There are many types of join, including <code>INNER</code>, <code>LEFT</code> <code>OUTER</code>, <code>RIGHT</code> <code>OUTER</code>, <code>FULL</code> <code>OUTER</code>, and <code>CROSS</code>. They are used in different situations. However, most of the time, in simple <code>1: N</code> relations, we end up using an <code>INNER</code> join. In <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Data Wrangling with Python</em>, we learned about sets. We can view an <code>INNER</code> join as an intersection of two sets. The following diagram illustrate the concepts:</p>
			<div><div><img src="img/B15780_08_07.jpg" alt="Figure 8.7: A diagram representing the intersection join&#13;&#10;" width="1665" height="517"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: A diagram representing the intersection join</p>
			<p>Here, <code>A</code> represents one table, and <code>B</code> represents another. The meaning of having common members is to have a relationship between them. It takes all of the rows of <code>A</code> and compares them with all of the rows of B to find the matching rows that satisfy the join predicate. This can quickly become a complex and time-consuming operation. Joins can be very expensive operations. Usually, we use some kind of where clause, after we specify the join, to shorten the scope of rows that are fetched from table <code>A</code> or <code>B</code> to perform the matching.</p>
			<p>In our case, our first table, user, has three entries, with the primary key being email. We can make use of this in our query to get comments just from Bob:</p>
			<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
    SELECT * FROM comments \
    JOIN user ON comments.user_id = user.email \
    WHERE user.email='bob@example.com' \
    """
    rows = cursor.execute(sql)
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<pre>('bob@example.com', 'This is comment 0 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 1 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 2 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 3 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 4 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 5 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 6 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 7 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 8 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')
('bob@example.com', 'This is comment 9 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</pre>
			<p>The preceding output of the <code>JOIN</code> query, showing that we have jointly read data from two tables at the same time, is restricting our query scope to a particular email.</p>
			<p>We have just looked into one of the most important operations of all, joins. We will cover some other aspects of the same in the coming section.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor280"/>Retrieving Specific Columns from a JOIN Query</h1>
			<p>In the previous exercise, we saw that we can use a <code>JOIN</code> to fetch the related rows from two tables. However, if we look at the results, we will see that it returned all the columns, thus combining both tables. This is not very concise. What about if we only want to see the emails and the related comments, and not all the data?</p>
			<p>There is some nice shorthand code that lets us do this:</p>
			<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    sql = """
    SELECT comments.* FROM comments \
    JOIN user ON comments.user_id = user.email \
    WHERE user.email='bob@example.com' \
    """
    rows = cursor.execute(sql)
    for row in rows:
        print(row)</pre>
			<p>Just by changing the <code>SELECT</code> statement, we made our final result appear as follows, where only columns from the <code>comments</code> table are present:</p>
			<pre>('bob@example.com', 'This is comment 0 by Bob Codd')
('bob@example.com', 'This is comment 1 by Bob Codd')
('bob@example.com', 'This is comment 2 by Bob Codd')
('bob@example.com', 'This is comment 3 by Bob Codd')
('bob@example.com', 'This is comment 4 by Bob Codd')
('bob@example.com', 'This is comment 5 by Bob Codd')
('bob@example.com', 'This is comment 6 by Bob Codd')
('bob@example.com', 'This is comment 7 by Bob Codd')
('bob@example.com', 'This is comment 8 by Bob Codd')
('bob@example.com', 'This is comment 9 by Bob Codd')</pre>
			<p>We have now looked at joins. They are very useful, and you will end up using them often while dealing with databases in real life. Up next is a detailed look into deleting rows.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor281"/>Deleting Rows from Tables</h2>
			<p>This will be done by using the <code>DELETE</code> command. As the name suggests, this command helps to delete rows from a table. It is an irreversible process, meaning once deleted, we cannot restore those rows. So be very careful when running this command as it can have a destructive effect on the data. Please keep in mind that it has to almost always be run accompanied by a <code>WHERE</code> clause so that we delete just a part of the data and not everything.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor282"/>Exercise 8.06: Deleting Rows from Tables</h2>
			<p>In this exercise, we will be working with two tables, <code>user</code> and <code>comments</code>, which are a part of the <code>lesson.db</code> database. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The GitHub version of this exercise begins with the previous 4 examples that we just saw, starting off with creation of the <code>comments</code> table. You may ignore those steps if you have executed them already.</p>
			<p>We will delete a row from the <code>user</code> table and observe the effects it will have on the comments table. Include all the steps mentioned previously. Let's perform the following steps:</p>
			<ol>
				<li value="1">To delete a row from a table, we use the <code>DELETE</code> clause in SQL. To run delete on the user table, we are going to use the following code:<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    cursor.execute("DELETE FROM user "\
                   "WHERE email='bob@example.com'")
    conn.commit()</pre></li>
				<li>Perform the <code>SELECT</code> operation on the user table:<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    rows = cursor.execute("SELECT * FROM user")
    for row in rows:
        print(row)</pre><p>The output is as follows:</p><pre>('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 
  39, 'M')
('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', 
  39, 'F')</pre><p>Observe that the user <code>Bob</code> has been deleted.</p><p>Now, moving on to the <code>comments</code> table, we have to remember that we had mentioned <code>ON DELETE</code> <code>CASCADE</code> while creating the table. The database engine knows that if a row is deleted from the parent table (<code>user</code>), all the related rows from the child tables (<code>comments</code>) will have to be deleted.</p></li>
				<li>Perform a <code>SELECT</code> operation on the <code>comments</code> table by using the following command:<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    rows = cursor.execute("SELECT * FROM comments")
    for row in rows:
        print(row)</pre><p>The output (partially shown) is as follows:</p><pre>('tom@web.com', 'This is comment 0 by Tom Fake')
('tom@web.com', 'This is comment 1 by Tom Fake')
('tom@web.com', 'This is comment 2 by Tom Fake')
('tom@web.com', 'This is comment 3 by Tom Fake')
('tom@web.com', 'This is comment 4 by Tom Fake')
('tom@web.com', 'This is comment 5 by Tom Fake')
('tom@web.com', 'This is comment 6 by Tom Fake')
('tom@web.com', 'This is comment 7 by Tom Fake')
('tom@web.com', 'This is comment 8 by Tom Fake')
('tom@web.com', 'This is comment 9 by Tom Fake')</pre></li>
			</ol>
			<p>We can see that all of the rows related to <code>Bob</code> are deleted from the <code>comments</code> table.</p>
			<p>We have observed the <code>DELETE</code> command and also learned how to use it safely.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YeutzP">https://packt.live/2YeutzP</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fArsQb">https://packt.live/3fArsQb</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the following section, we will see how to update a specific value in a table.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor283"/>Updating Specific Values in a Table</h2>
			<p>In this example, we will see how we can update rows in a table. Without <code>WHERE</code>, updating is often a bad idea. The reason is that we may end up updating rows that we did not intend to.</p>
			<p>We can combine <code>UPDATE</code> with <code>WHERE</code> to selectively update the first name of the user with the email address tom@web.com, as shown in the following code:</p>
			<pre>with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()
    cursor.execute("PRAGMA foreign_keys = 1")
    cursor.execute("UPDATE user set first_name='Chris' "\
                   "where email='tom@web.com'")
    conn.commit()
    rows = cursor.execute("SELECT * FROM user")
    for row in rows:
        print(row)</pre>
			<p>The output is as follows:</p>
			<div><div><img src="img/B15780_08_08.jpg" alt="Figure 8.8: Output of the update query, showing the newly updated first name&#13;&#10;" width="1356" height="94"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: Output of the update query, showing the newly updated first name</p>
			<p>So far, we have covered a lot of concepts related to databases. We have learned a set of skills that are important for dealing with database-level operations. In the next section, we will combine two worlds; the world of databases and the world of pandas. </p>
			<p>We have looked into many fundamental aspects of storing and querying data from a database, but as a data wrangling expert, we need our data to be packed and presented as a DataFrame so that we can perform quick and convenient operations on them.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor284"/>Exercise 8.07: RDBMS and DataFrames</h2>
			<p>In this exercise, we will connect to the <code>lesson.db</code> database and join the two tables, <code>user</code> and <code>comments</code>. We will create an empty <code>data</code> list and then add the rows of this joined table in <code>data</code>. Next, we will store the content of <code>data</code> in a <code>pandas</code> DataFrame. To complete this exercise, let's perform the following steps:</p>
			<ol>
				<li value="1">Import pandas using the following code:<pre>import pandas as pd</pre></li>
				<li>Create a columns list with email, first name, last name, age, gender, and comments as column names. Also, create an empty <code>data</code> list:<pre>columns = ["Email", "First Name", "Last Name", \
           "Age", "Gender", "Comments"]
data = []</pre></li>
				<li>Connect to <code>lesson.db</code> using SQLite and obtain a cursor, as follows:<pre>import sqlite3
with sqlite3.connect("../lesson.db") as conn:
    cursor = conn.cursor()</pre></li>
				<li>Use the <code>execute</code> method from the cursor to set <code>PRAGMA foreign_keys = 1</code>:<pre>cursor.execute("PRAGMA foreign_keys = 1")</pre></li>
				<li>Create a <code>sql</code> variable that will contain the <code>SELECT</code> command and use the join command to join the databases:<pre>sql = """
    SELECT user.email, user.first_name, user.last_name, \
    user.age, user.gender, comments.comments FROM comments \
    JOIN user ON comments.user_id = user.email \
    WHERE user.email = 'tom@web.com' \
     """</pre></li>
				<li>Use the execute method of <code>cursor</code> to execute the <code>sql</code> command:<pre>rows = cursor.execute(sql)</pre></li>
				<li>Append the rows to the data list:<pre>for row in rows:
    data.append(row)</pre></li>
				<li>Create a DataFrame using the data list and print out the result:<pre>df = pd.DataFrame(data, columns=columns)
df</pre><p>The output will be:</p><div><img src="img/B15780_08_09.jpg" alt="Figure 8.9: Output of the dataframe&#13;&#10;" width="1048" height="562"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.9: Output of the dataframe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YPSdZX">https://packt.live/2YPSdZX</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37HZaAi">https://packt.live/37HZaAi</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>This ends our journey into the world of databases. It was a basic introduction. Nonetheless, we managed to cover a wide range of essential topics. DBMS and related fields are a mature stream in computer science and are still under active development and research. We strongly encourage the reader to read more about it. </p>
			<h2 id="_idParaDest-277">Activity <a id="_idTextAnchor285"/>8.01: Retrieving Data Accurately from Databases</h2>
			<p>The goal of this activity is to fetch data and retrieve information from two tables, <code>persons</code> and <code>pets</code>, which are a part of the <code>petsdb</code> database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find the <code>petsdb</code> database at <a href="https://packt.live/3dcH0rx">https://packt.live/3dcH0rx</a>.</p>
			<p>The <code>persons</code> table is defined as follows:</p>
			<div><div><img src="img/B15780_08_10.jpg" alt="Figure 8.10: The persons table&#13;&#10;" width="1170" height="389"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: The persons table</p>
			<p>The <code>persons</code> table has the following columns:</p>
			<ul>
				<li><code>first_name</code>: The first name of the person</li>
				<li><code>last_name</code>: The last name of the person (can be <code>null</code>)</li>
				<li><code>age</code>: The age of the person</li>
				<li><code>city</code>: The city where they are from</li>
				<li><code>zip_code</code>: The zip code of the city</li>
			</ul>
			<p>As we can see, the <code>id</code> column in the <code>persons</code> table (which is an integer) serves as the primary key for that table and as a foreign key for the <code>pets</code> table, which is linked via the <code>owner_id</code> column.</p>
			<p>The <code>pets</code> table is defined as follows:</p>
			<div><div><img src="img/B15780_08_11.jpg" alt="Figure 8.11: The pets table&#13;&#10;" width="1378" height="459"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: The pets table</p>
			<p>The pets table has the following columns:</p>
			<ul>
				<li><code>pet_name</code>: The name of the pet.</li>
				<li><code>pet_type</code>: What type of pet it is, for example, <code>cat</code> or <code>dog</code>. Due to a lack of further information, we do not know which number represents what, but it is an integer and can be <code>null</code>.</li>
				<li><code>treatment_done</code>: This is also an integer column, and <code>0</code> here represents <code>No</code>, whereas <code>1</code> represents <code>Yes</code>.</li>
			</ul>
			<p>In this activity, you will first connect to the <code>petsdb</code> database and check whether the connection has been successful. You will then create and execute a few SQL commands to answer the following questions:</p>
			<ol>
				<li value="1">What is the count of people belonging to different age groups in the <code>persons</code> table?</li>
				<li>Which age group has the maximum number of people?</li>
				<li>How many people do not have a last name?</li>
				<li>How many people have more than one pet?</li>
				<li>How many pets have received treatment?</li>
				<li>How many pets have received treatment, and the type of pet is known?</li>
				<li>How many pets are from the city called east port?</li>
				<li>How many pets are from the city called east port, and who received treatment?</li>
			</ol>
			<p>The output should be as follows:</p>
			<p>Answer to question 1 (the following is partial output):</p>
			<div><div><img src="img/B15780_08_12.jpg" alt="Figure 8.12: Partial output of the count of people belonging to different age groups &#13;&#10;from the persons table&#13;&#10;" width="944" height="763"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Partial output of the count of people belonging to different age groups from the persons table</p>
			<p>Answer to question 2:</p>
			<pre>Highest number of people is 5 and came from 73 age group</pre>
			<p>Answer to question 3:</p>
			<pre>(60,)</pre>
			<p>Answer to question 4:</p>
			<pre>43 people has more than one pet</pre>
			<p>Answer to question 5:</p>
			<pre>(36,)</pre>
			<p>Answer to question 6:</p>
			<pre>(16,)</pre>
			<p>Answer to question 7:</p>
			<pre>(49,)</pre>
			<p>Answer to question 8:</p>
			<pre>(11,)</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor327">this link</a>.</p>
			<p>In this activity, we have applied all the skills we learned in this chapter concerning databases. </p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor286"/>Summary</h1>
			<p>We have come to the end of the database chapter. We have learned how to connect to SQLite using Python. We have brushed up on the basics of relational databases and how to open and close a database. We then learned how to export this relational database into Python DataFrames.</p>
			<p>In the next chapter, we will be performing data wrangling on datasets that are used in business use cases. We will use different types of datasets and then clean and process the data in a meaningful way. We will be able to apply all the skills and tricks we have learned so far in this book to process data and get valuable insights from them.</p>
		</div>
		<div><div></div>
		</div>
	</div></body></html>