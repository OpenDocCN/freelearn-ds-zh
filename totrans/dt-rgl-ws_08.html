<html><head></head><body><div id="sbo-rt-content"><div>
			<div id="_idContainer250" class="Content">
			</div>
		</div>
		<div id="_idContainer251" class="Content">
			<h1 id="_idParaDest-254"><a id="_idTextAnchor262"/>8. RDBMS and SQL</h1>
		</div>
		<div id="_idContainer264" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will introduce you to the basics of using an RDBMS to query a database using Python and convert data from SQL and then store it in a <strong class="source-inline">pandas</strong> DataFrame. It will explain the concepts of databases, including their creation, manipulation, and control, and how to transform tables into <strong class="source-inline">pandas</strong> DataFrames. By the end of this chapter, you will learn some basic SQL commands. This knowledge will make you adept at adding, updating, retrieving, and deleting data from databases; another valuable skill in a budding data wrangling expert's repertoire.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor263"/>Introduction</h1>
			<p>This chapter of our data journey is focused on <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>) and <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>). In the previous chapter, we stored and read data from a file. In this chapter, we will read structured data, design access to the data, and create query interfaces for databases.</p>
			<p>For years, the RDBMS format has been the conventional way to store data. An RDBMS is one of the safest ways to store, manage, and retrieve data. It is backed by a solid mathematical foundation (relational algebra and calculus) and exposes an efficient and intuitive declarative language – SQL – for easy interaction. Almost every language has a rich set of libraries to interact with different RDBMS, and the tricks and methods of using them are well tested and well understood.</p>
			<p>Scaling an RDBMS is a pretty well-understood task, and there is a group of well trained, experienced professionals to do this job (DBAs, or database administrators).</p>
			<p>So, it is understandable that we, as data wrangling professionals or data engineers, will encounter RDBMS at some point. We will need the tools and knowledge acquired from this chapter to deal with RDBMS.</p>
			<p>As we can see in the following chart, the database management system market is big. This chart was produced based on market research that was done by Scalegrid in 2019:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="Images/B15780_08_01.jpg" alt="Figure 8.1: Commercial database market share released by ScaleGrid in 2019&#13;&#10;" width="1450" height="902"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: Commercial database market share released by ScaleGrid in 2019</p>
			<p>We will learn and play around with some of the basic and fundamental concepts of database and relational database management systems in this chapter. We will start with a refresher of the theoretical concept of a database, and then we will create and operate a database from our Python environment.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor264"/>Refresher of RDBMS and SQL</h1>
			<p>An RDBMS is a piece of software that manages data (represented for the end user in tabular form) on physical hard disks and is built using Codd's relational model. Most of the databases that we encounter today are RDBMS. In recent years, there has been a huge industry shift toward a newer kind of database management system, called NoSQL (MongoDB, CouchDB, Riak, and so on). These systems, while they do follow some of the rules of RDBMS in certain aspects, in most cases they reject or modify them.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor265"/>How Is an RDBMS Structured?</h2>
			<p>The RDBMS structure consists of three main elements, namely the storage engine, the query engine, and log management. Here is a diagram that demonstrates the structure of an RDBMS:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="Images/B15780_08_02.jpg" alt="Figure 8.2: RDBMS structure&#13;&#10;" width="549" height="427"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: RDBMS structure</p>
			<p>The following are the main concepts of any RDBMS structure:</p>
			<ul>
				<li><strong class="bold">Storage engine:</strong> This is the part of the RDBMS that is responsible for storing data in an efficient way and also retrieving it, when asked for, in an efficient way. As an end user of the RDBMS system (an application developer is considered an end user of an RDBMS), we will never need to interact with this layer directly.</li>
				<li><strong class="bold">Query engine:</strong> This is the part of the RDBMS that allows us to create data objects (tables, views, and so on), manipulate them (create and delete columns, create/delete/update rows, and so on), and query them (read rows) using a simple, yet powerful, language.</li>
				<li><strong class="bold">Log management:</strong> This part of the RDBMS is responsible for creating and maintaining the logs. If you are wondering why the log is such an important thing, then you should look into how replication and partitions are handled in a modern RDBMS (such as PostgreSQL) using something called the <strong class="bold">Write Ahead Log</strong> (or <strong class="bold">WAL</strong> for short).</li>
			</ul>
			<p>We will focus on the query engine in this chapter.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor266"/>SQL</h2>
			<p><strong class="bold">SQL</strong> (pronounced <em class="italic">sequel</em>), as it is commonly known, is a domain-specific language that was originally designed based on E.F. Codd's relational model and is widely used in today's databases to define, insert, manipulate, and retrieve data from them. It can be further sub-divided into four smaller sub-languages, namely <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>), <strong class="bold">Data Manipulation Language</strong> (<strong class="bold">DML</strong>), <strong class="bold">Data Query Language</strong> (<strong class="bold">DQL</strong>), and <strong class="bold">Data Control Language</strong> (<strong class="bold">DCL</strong>). There are several advantages of using SQL, some of which are as follows:</p>
			<ul>
				<li>It is based on a solid mathematical framework and thus it is easy to understand.</li>
				<li>It is a declarative language, which means that we actually never tell it how to do its job. We almost always tell it what to do. This frees us from the big burden of writing custom code for data management. We can be more focused on the actual query problem we are trying to solve, instead of bothering about how to create and maintain a data store.</li>
				<li>It gives you a fast and readable way to deal with data.</li>
				<li>SQL gives you out-of-the-box ways to get multiple pieces of data with a single query.</li>
			</ul>
			<p>The main areas of focus for the following topic will be DDL, DML, and DQL. The DCL part is more for database administrators. Let's discuss them briefly:</p>
			<ul>
				<li><strong class="bold">DDL</strong>: This is how we define our data structure in SQL. As an RDBMS is mainly designed and built with structured data in mind, we have to tell an RDBMS engine beforehand what our data is going to look like. We can update this definition at a later point in time, but an initial statement is a must. This is where we will write statements such as <strong class="source-inline">CREATE TABLE</strong>, <strong class="source-inline">DROP TABLE</strong>, and <strong class="source-inline">ALTER TABLE</strong>. <p class="callout-heading">Note</p><p class="callout">Notice the use of uppercase letters. This is not a requirement, and you may use lowercase letters, but it is a widely followed convention, and we will use it in this book.</p></li>
				<li><strong class="bold">DML</strong>: DML is the part of SQL that lets us insert, delete, or update a certain data point (a row) in a previously defined data object (a table). This is the part of SQL that contains statements such as <strong class="source-inline">INSERT INTO</strong>, <strong class="source-inline">DELETE FROM</strong>, or <strong class="source-inline">UPDATE</strong>.</li>
				<li><strong class="bold">DQL</strong>: With DQL, we enable ourselves to query the data stored in an RDBMS, which was defined by DDL and inserted using DML. It gives us enormous power and flexibility to not only query data out of a single object (table), but also to extract relevant data from all the related objects using queries. The frequently used query that's used to retrieve data is the <strong class="source-inline">SELECT</strong> command. We will also see and use the concepts of the primary key, foreign key, index, joins, and so on.</li>
			</ul>
			<p>Once you define and insert data in a database, it can be represented as follows:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="Images/B15780_08_03.jpg" alt="Figure 8.3: Table displaying sample data&#13;&#10;" width="725" height="319"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Table displaying sample data</p>
			<p>Another thing to remember about an RDBMS is relations. Generally, in a table, we have one or more columns that will have unique values for each row in the table. We call them <strong class="bold">primary keys</strong> for the table. We should be aware that we will encounter unique values across the rows, which are not primary keys. The main difference between them and primary keys is the fact that a primary key cannot be null.</p>
			<p>By using the primary key of one table and mentioning it as a foreign key in another table, we can establish relations between two tables. A certain table can be related to any finite number of tables. </p>
			<p>The relations can be <strong class="source-inline">1:1</strong>, which means that each row of the second table is uniquely related to one row of the first table, or <strong class="source-inline">1:N</strong>, <strong class="source-inline">N:1</strong>, or <strong class="source-inline">N: M</strong>. An example of relations is as follows:</p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="Images/B15780_08_04.jpg" alt="Figure 8.4: Diagram showing relations&#13;&#10;" width="694" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Diagram showing relations</p>
			<p>With this brief refresher, we are now ready to jump into hands-on exercises and write some SQL to store and retrieve data.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor267"/>Using an RDBMS (MySQL/PostgreSQL/SQLite)</h2>
			<p>In this topic, we will focus on how to write some basic SQL commands, as well as how to connect to a database from Python and use it effectively within Python. The database we will choose here is SQLite. There are other databases, such as Oracle, MySQL, PostgreSQL, and DB2. The main tricks that you are going to learn here will not change depending on the database you are using. However, for different databases, you will need to install different third-party Python libraries (such as Psycopg2 for PostgreSQL). The reason they all behave the same way (apart for some small details) is the fact that they all adhere to PEP249 (commonly known as Python DB API 2).</p>
			<p>This is a good standardization and saves us a lot of headaches while porting from one RDBMS to another. If you already have some experience with databases, then you will notice that we will not be using any server address, username, password, or other credentials to connect to a database. This is because these fields are not mandatory in sqlite3, unlike in PostgreSQL or MySQL. The main database engine of SQLite is embedded.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Most of the industry-standard projects that are written in Python and use some kind of RDBMS as the data store most often rely on an <strong class="bold">Object Relational Mapper </strong>(<strong class="bold">ORM</strong>). An ORM is a high-level library in Python that makes many tasks easier when dealing with an RDBMS. It also exposes a more Pythonic API than writing raw SQL inside Python code.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor268"/>Exercise 8.01: Connecting to a Database in SQLite</h2>
			<p>In this exercise, we will look into the first step toward using an RDBMS in Python code. We are going to connect to a database, <strong class="source-inline">lesson.db</strong>. We will then close the connection safely. Let's perform the following steps:</p>
			<ol>
				<li>Import the <strong class="source-inline">sqlite3</strong> library from Python by using the following command:<p class="source-code">import sqlite3</p></li>
				<li>Use the <strong class="source-inline">connect</strong> function to connect to a database:<p class="source-code">conn = sqlite3.connect("../lesson.db")</p></li>
				<li>Close the connection, as follows:<p class="source-code">conn.close()</p><p>This <strong class="source-inline">conn</strong> object is the main connection object, and we will need it to get a second type of object in the future once we want to interact with the database. We need to be careful about closing any open connection to our database.</p></li>
				<li>Use the same <strong class="source-inline">with</strong> statement from Python, just like we did for files, and connect to the database, as follows:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    pass</p></li>
			</ol>
			<p>In this exercise, we have connected to a database using Python.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YMWrBD">https://packt.live/2YMWrBD</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3df6q87">https://packt.live/3df6q87</a>.</p>
			<p>In the next exercise, we will see the best way to create a table and put data into it using Python.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor269"/>DDL and DML Commands in SQLite</h2>
			<p>To create a table in SQL, use the <strong class="source-inline">CREATE TABLE</strong> SQL clause. This will require the table name and the table definition. The table name is a unique identifier for the database engine to find and use the table for all future transactions. It can be anything (any alphanumeric string), as long as it is unique. We add the table definition in the form of (<strong class="source-inline">column_name_1 data_type</strong>, <strong class="source-inline">column_name_2 data type</strong>, <strong class="source-inline">…</strong> ). For our purpose, we will use the text and integer data types, but usually, a standard database engine supports many more data types, such as float, double, date time, and Boolean. We will also need to specify a primary key. A primary key is a unique, non-null identifier that's used to uniquely identify a row in a table. In our case, we use email as a primary key. A primary key can be an integer or text.</p>
			<p>The last thing you need to know is that unless you call a commit on the series of operations you just performed (together, we formally call them a transaction), nothing will actually be performed and reflected in the database. This property is called atomicity. In fact, for a database to be industry-standard (to be useable in real life), it needs to follow the <strong class="bold">Atomicity, Consistency, Isolation, Durability</strong> (<strong class="bold">ACID</strong>) properties.</p>
			<p>As the name suggests, <strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>) is the way to communicate with the database engine in advance to define what the data will look like. The database engine creates a table object based on the definition provided and prepares it.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor270"/>Exercise 8.02: Using DDL and DML Commands in SQLite</h2>
			<p>In this exercise, we will connect with the <strong class="source-inline">lesson.db</strong> database and then create a <strong class="source-inline">user</strong> table. Then, we will insert data into the table using the DDL and DML commands. Let's perform the following steps:</p>
			<ol>
				<li value="1">Use SQLite's <strong class="source-inline">connect</strong> function to connect to the <strong class="source-inline">lesson.db</strong> database. Create a <strong class="source-inline">cursor</strong> object by calling <strong class="source-inline">conn.cursor()</strong>. The <strong class="source-inline">cursor</strong> object acts as a medium by which to communicate with the database: <p class="source-code">import sqlite3</p><p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p></li>
				<li>Create a table in Python, as follows:<p class="source-code">cursor.execute("CREATE TABLE IF NOT EXISTS \</p><p class="source-code">                user (email text, first_name  text, \</p><p class="source-code">                      last_name text, address text, age integer, \</p><p class="source-code">                      PRIMARY KEY (email))")</p></li>
				<li>Insert rows into the database that you created, as follows:<p class="source-code">cursor.execute("INSERT INTO user VALUES \</p><p class="source-code">               ('bob@example.com', 'Bob', 'Codd', \</p><p class="source-code">                '123  Fantasy lane, Fantasy City', 31)") </p><p class="source-code">cursor.execute("INSERT INTO user VALUES \</p><p class="source-code">               ('tom@web.com', 'Tom', 'Fake', \</p><p class="source-code">                '456 Fantasy lane, Fantasy City', 39)")</p></li>
				<li>Commit to the database:<p class="source-code">conn.commit()</p></li>
			</ol>
			<p>This will create the table and write two rows to it with data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YeniaH">https://packt.live/2YeniaH</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2BogE8J">https://packt.live/2BogE8J</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the next section, we will read back the data that we just stored. </p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor271"/>Reading Data from a Database in SQLite</h2>
			<p>In the preceding exercise, we created a table and stored data in it. Now, we will learn how to read the data that's stored in this database.</p>
			<p>The <strong class="source-inline">SELECT</strong> clause is immensely powerful, and it is really important for a data practitioner to master <strong class="source-inline">SELECT</strong> and everything related to it (such as conditions, joins, and group-by).</p>
			<p>The <strong class="source-inline">*</strong> after <strong class="source-inline">SELECT</strong> tells the engine to select all of the columns from the table. This is a useful shorthand. We have not mentioned any condition for the selection (such as above a certain age, first name starting with a certain sequence of letters, and so on). We are practically telling the database engine to select all the rows and all the columns from the table. It is time-consuming and less effective if we have a huge table. Hence, we would want to use the <strong class="source-inline">LIMIT</strong> clause to limit the number of rows we want.</p>
			<p>You can use the <strong class="source-inline">SELECT</strong> clause in SQL to retrieve data, as follows:</p>
			<p class="source-code">import sqlite3</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    rows = cursor.execute('SELECT * FROM user')</p>
			<p class="source-code">    for row in rows:</p>
			<p class="source-code">        print(row)</p>
			<p>The output is as follows:</p>
			<p class="source-code">('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)</p>
			<p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)</p>
			<p>The syntax to use the <strong class="source-inline">SELECT</strong> clause with <strong class="source-inline">LIMIT</strong> is as follows:</p>
			<p class="source-code">SELECT * FROM &lt;table_name&gt; LIMIT 50;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This syntax is sample code and will not work on Jupyter Notebooks.</p>
			<p>This will select all the columns, but only the first <strong class="source-inline">50</strong> rows from the table. </p>
			<p>Now that we have seen how to connect, write, and read basic data to a database, we will be venturing into more advanced operations in the coming exercises, with the sorting of data being the next one.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor272"/>Exercise 8.03: Sorting Values That Are Present in the Database</h2>
			<p>In this exercise, we will use the <strong class="source-inline">ORDER BY</strong> clause to sort the rows of the <strong class="source-inline">user</strong> table with respect to the <strong class="source-inline">age</strong> column in both descending and ascending order. Let's perform the following steps:</p>
			<ol>
				<li value="1">Connect to the <strong class="source-inline">lesson.db</strong> database and sort <strong class="source-inline">lesson.db</strong> by age in descending order, as follows:<p class="source-code">import sqlite3</p><p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')</p><p class="source-code">    for row in rows:</p><p class="source-code">        print(row)</p><p>The output is as follows:</p><p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)</p><p class="source-code">('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)</p></li>
				<li>Sort the <strong class="source-inline">lesson.db</strong> database by age in ascending order, as follows:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    rows = cursor.execute('SELECT * FROM user ORDER BY age')</p><p class="source-code">    for row in rows:</p><p class="source-code">        print(row)</p><p>The output is as follows:</p><p class="source-code">('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31)</p><p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', 39)</p></li>
			</ol>
			<p>Notice that we don't need to specify the order as <strong class="source-inline">ASC</strong> in order to sort it in ascending order.</p>
			<p>In this exercise, we have seen how to sort data. Sorting is one of the most important operations you will often need to do.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/37I7Iap">https://packt.live/37I7Iap</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/2YOu4D5">https://packt.live/2YOu4D5</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the coming exercise, we will see how to update the structure of an already defined table. </p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor273"/>The ALTER Command</h2>
			<p><strong class="source-inline">ALTER</strong> is a command that is used by a RDBMS to add a new column to an already existing table, or to change the data type of a column, whereas the <strong class="source-inline">UPDATE</strong> command is used to update the value of one or more columns in one or several rows of a database. We will examine them in the following section to check out their use. </p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor274"/>Exercise 8.04: Altering the Structure of a Table and Updating the New Fields</h2>
			<p>In this exercise, we are going to add a column, <strong class="source-inline">gender</strong>, using the <strong class="source-inline">ALTER</strong> command in the <strong class="source-inline">user</strong> table. Then, by using the <strong class="source-inline">UPDATE</strong> command, we will set the value of the <strong class="source-inline">gender</strong> column. Let's perform the following steps:</p>
			<ol>
				<li value="1">Establish a connection with the database by using the following command:<p class="source-code">import sqlite3</p><p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p></li>
				<li>Add another column in the <strong class="source-inline">user</strong> table and fill it with null values by using the following command:<p class="source-code">cursor.execute("ALTER TABLE user ADD COLUMN gender text")</p><p class="source-code">conn.commit()</p></li>
				<li>Update all of the values of gender so that they are <strong class="source-inline">M</strong> by using the following command:<p class="source-code">cursor.execute("UPDATE user SET gender='M'")</p><p class="source-code">conn.commit()</p></li>
				<li>To check the altered table, execute the following command:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    rows = cursor.execute('SELECT * FROM user ORDER BY age')</p><p class="source-code">    for row in rows:</p><p class="source-code">        print(row)</p><p>The output is as follows:</p><p class="source-code">('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', </p><p class="source-code"> 31, 'M')</p><p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', </p><p class="source-code"> 39, 'M')</p></li>
			</ol>
			<p>We have to be cautious when using <strong class="source-inline">UPDATE</strong>, because using <strong class="source-inline">UPDATE</strong> without selective clauses (such as <strong class="source-inline">WHERE</strong>) affects the entire table.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/312BtBL">https://packt.live/312BtBL</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3ddIYbh">https://packt.live/3ddIYbh</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor275"/>The GROUP BY clause</h2>
			<p>We will learn about a concept that we have already learned about in pandas. This is called the <strong class="source-inline">GROUP BY</strong> clause. The <strong class="source-inline">GROUP BY</strong> clause is a technique that's used to retrieve distinct values from the database and place them in individual buckets. The following diagram explains how the <strong class="source-inline">GROUP BY</strong> clause works:</p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="Images/B15780_08_05.jpg" alt="Figure 8.5: Illustration of the GROUP BY clause on a table&#13;&#10;" width="1665" height="1071"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Illustration of the GROUP BY clause on a table</p>
			<p>In the preceding diagram, we can see that the <strong class="source-inline">col3</strong> column has only two unique values across all rows, <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong>. The command that's used to check the total number of rows belonging to each group is as follows:</p>
			<p class="source-code">SELECT count(*), col3 FROM &lt;tablename&gt; GROUP BY col3</p>
			<p>Let's go through the following exercise to practice the <strong class="source-inline">GroupBy</strong> clause.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor276"/>Exercise 8.05: Grouping Values in Tables</h2>
			<p>In this exercise, we will use the <strong class="source-inline">GROUP BY</strong> clause to select the columns grouped by <strong class="source-inline">gender</strong>. We'll add users whose genders are male and female to the table and group them based on gender. Let's perform the following steps to do so:</p>
			<ol>
				<li value="1">Establish the connection with the database by using the following command:<p class="source-code">import sqlite3</p><p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p></li>
				<li>Add a female user to the table:<p class="source-code">cursor.execute("INSERT INTO user VALUES ('shelly@www.com', 'Shelly',\</p><p class="source-code">                                         'Milar',\</p><p class="source-code">                                         '123, Ocean View Lane',\</p><p class="source-code">                                         39, 'F')")</p><p class="source-code">conn.commit()</p><p class="source-code">cursor = conn.cursor()</p><p class="source-code">rows = cursor.execute('SELECT * FROM user ORDER BY age DESC')</p><p class="source-code">for row in rows:</p><p class="source-code">    print(row)</p><p class="callout-heading">Note</p><p class="callout">The aforementioned code block must be run in a single cell in Jupyter Notebook.</p><p>The output is as follows:</p><p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', </p><p class="source-code">  39, 'M')</p><p class="source-code">('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', </p><p class="source-code">  39, 'F')</p><p class="source-code">('bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', </p><p class="source-code">  31, 'M')</p></li>
				<li>Run the following code to see the count by each <strong class="source-inline">gender</strong>:<p class="source-code">rows = cursor.execute("SELECT COUNT(*), "\</p><p class="source-code">                      "gender FROM user GROUP BY gender")</p><p class="source-code">for row in rows:</p><p class="source-code">    print(row)</p><p>The output is as follows:</p><p class="source-code">(1, 'F')</p><p class="source-code">(2, 'M')</p><p class="callout-heading">Note</p><p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/3fEzV4N">https://packt.live/3fEzV4N</a>.</p><p class="callout">You can also run this example online at <a href="https://packt.live/2N8kS7l">https://packt.live/2N8kS7l</a>.</p></li>
			</ol>
			<p>We have seen by now how to connect to a database, create a table, and insert values in it. We have also looked into topics such as reading values from a table, sorting them, and grouping them by common values. These are all very essential skills to have when dealing with databases. However, we have not looked into the "<em class="italic">Relational</em>" part of an RDBMS. This is what is coming up next.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor277"/>Relation Mapping in Databases</h1>
			<p>We have been working with a single table and altering it, as well as reading back the data. However, the real power of an RDBMS comes from the handling of relationships among different objects (tables). In this section, we are going to create a new table called comments and link it with the user table in a <strong class="source-inline">1: N</strong> relationship. This means that one user can have multiple comments. The way we are going to do this is by adding the user table's primary key as a foreign key in the comments table. This will create a <strong class="source-inline">1: N</strong> relationship.</p>
			<p>When we link two tables, we need to specify to the database engine what should be done if the parent row is deleted, which has many children in the other table. As we can see in the following diagram, we are asking what happens at the place of the question marks when we delete <strong class="source-inline">row1</strong> of the user table:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="Images/B15780_08_06.jpg" alt="Figure 8.6: Illustration of relations&#13;&#10;" width="1557" height="344"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Illustration of relations</p>
			<p>In a non-RDBMS situation, this situation can quickly become difficult and messy to manage and maintain. However, with an RDBMS, all we have to tell the database engine, in very precise ways, is what to do when a situation like this occurs. The database engine will do the rest for us. We use <strong class="source-inline">ON DELETE</strong> to tell the engine what we do with all the rows of a table when the parent row gets deleted. The following code illustrates these concepts:</p>
			<p class="source-code">import sqlite3</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="source-code">    sql = """</p>
			<p class="source-code">    CREATE TABLE comments ( \</p>
			<p class="source-code">         user_id text, \</p>
			<p class="source-code">         comments text, \</p>
			<p class="source-code">         FOREIGN KEY (user_id) REFERENCES user (email) \</p>
			<p class="source-code">         ON DELETE CASCADE ON UPDATE NO ACTION \</p>
			<p class="source-code">    )</p>
			<p class="source-code">    """</p>
			<p class="source-code">    cursor.execute(sql)</p>
			<p class="source-code">    conn.commit()</p>
			<p>The <strong class="source-inline">ON DELETE</strong> <strong class="source-inline">CASCADE</strong> line informs the database engine that we want to delete all the children rows when the parent gets deleted. We will cover deleting values in detail in a later exercise. We can also define actions for <strong class="source-inline">UPDATE</strong>. In this case, there is nothing to do on <strong class="source-inline">UPDATE</strong>.</p>
			<p>The <strong class="source-inline">FOREIGN KEY</strong> modifier modifies a column definition (<strong class="source-inline">user_id</strong>, in this case) and marks it as a foreign key, which is related to the primary key (email, in this case) of another table. A foreign key is a link between two tables. We define a primary key in one table and then define the same values as foreign keys to another table, thereby creating a link between them.</p>
			<p>You may notice the strange looking <strong class="source-inline">cursor.execute("PRAGMA foreign_keys = 1")</strong> line in the code. It is there just because SQLite does not use the normal foreign key features by default. It is this line that enables that feature. It is typical to SQLite and we won't need it for any other databases.</p>
			<p>Hence, we have covered the idea of relations between two tables. One table can be related to any number of tables. And there are different types of relationships such as <strong class="source-inline">1:1</strong>, <strong class="source-inline">1:n</strong>, and <strong class="source-inline">n:n</strong>. Readers are encouraged to look into these in detail. </p>
			<p>In the next section, we will insert rows in the newly created table.</p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor278"/>Adding Rows in the comments Table</h2>
			<p>We have created a table called <strong class="source-inline">comments</strong>. In this section, we will dynamically generate an <strong class="source-inline">INSERT</strong> query, as follows:</p>
			<p class="source-code">import sqlite3</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="source-code">    sql = "INSERT INTO comments VALUES ('{}', '{}')"</p>
			<p class="source-code">    rows = cursor.execute('SELECT * FROM user ORDER BY age')</p>
			<p class="source-code">    for row in rows:</p>
			<p class="source-code">        email = row[0]</p>
			<p class="source-code">        print("Going to create rows for {}".format(email))</p>
			<p class="source-code">        name = row[1] + " " + row[2]</p>
			<p class="source-code">        for i in range(10):</p>
			<p class="source-code">            comment = "This is comment {} by {}".format(i, name)</p>
			<p class="source-code">            conn.cursor().execute(sql.format(email, comment))</p>
			<p class="source-code">            conn.commit()</p>
			<p>Pay attention to how we dynamically generate the insert query so that we can insert 10 comments for each user.</p>
			<p>We have inserted some rows in the new table and we have established a relationship between this one and the one before. Up next is one of the most important concepts of databases – joins. They help us to write concise queries to retrieve data from several linked tables.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor279"/>Joins</h1>
			<p>Now, we will learn how to exploit the relationship we just built. This means that if we have the primary key from one table, we can recover all the data needed from that table and also all the linked rows from the child table. To achieve this, we will use something called a join.</p>
			<p>A join is basically a way to retrieve linked rows from two tables using any kind of primary key – foreign key relation that they have. There are many types of join, including <strong class="source-inline">INNER</strong>, <strong class="source-inline">LEFT</strong> <strong class="source-inline">OUTER</strong>, <strong class="source-inline">RIGHT</strong> <strong class="source-inline">OUTER</strong>, <strong class="source-inline">FULL</strong> <strong class="source-inline">OUTER</strong>, and <strong class="source-inline">CROSS</strong>. They are used in different situations. However, most of the time, in simple <strong class="source-inline">1: N</strong> relations, we end up using an <strong class="source-inline">INNER</strong> join. In <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Data Wrangling with Python</em>, we learned about sets. We can view an <strong class="source-inline">INNER</strong> join as an intersection of two sets. The following diagram illustrate the concepts:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="Images/B15780_08_07.jpg" alt="Figure 8.7: A diagram representing the intersection join&#13;&#10;" width="1665" height="517"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: A diagram representing the intersection join</p>
			<p>Here, <strong class="source-inline">A</strong> represents one table, and <strong class="source-inline">B</strong> represents another. The meaning of having common members is to have a relationship between them. It takes all of the rows of <strong class="source-inline">A</strong> and compares them with all of the rows of B to find the matching rows that satisfy the join predicate. This can quickly become a complex and time-consuming operation. Joins can be very expensive operations. Usually, we use some kind of where clause, after we specify the join, to shorten the scope of rows that are fetched from table <strong class="source-inline">A</strong> or <strong class="source-inline">B</strong> to perform the matching.</p>
			<p>In our case, our first table, user, has three entries, with the primary key being email. We can make use of this in our query to get comments just from Bob:</p>
			<p class="source-code">import sqlite3</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="source-code">    sql = """</p>
			<p class="source-code">    SELECT * FROM comments \</p>
			<p class="source-code">    JOIN user ON comments.user_id = user.email \</p>
			<p class="source-code">    WHERE user.email='bob@example.com' \</p>
			<p class="source-code">    """</p>
			<p class="source-code">    rows = cursor.execute(sql)</p>
			<p class="source-code">    for row in rows:</p>
			<p class="source-code">        print(row)</p>
			<p>The output is as follows:</p>
			<p class="source-code">('bob@example.com', 'This is comment 0 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 1 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 2 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 3 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 4 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 5 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 6 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 7 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 8 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p class="source-code">('bob@example.com', 'This is comment 9 by Bob Codd', 'bob@example.com', 'Bob', 'Codd', '123 Fantasy lane, Fantasy City', 31, 'M')</p>
			<p>The preceding output of the <strong class="source-inline">JOIN</strong> query, showing that we have jointly read data from two tables at the same time, is restricting our query scope to a particular email.</p>
			<p>We have just looked into one of the most important operations of all, joins. We will cover some other aspects of the same in the coming section.</p>
			<h1 id="_idParaDest-272"><a id="_idTextAnchor280"/>Retrieving Specific Columns from a JOIN Query</h1>
			<p>In the previous exercise, we saw that we can use a <strong class="source-inline">JOIN</strong> to fetch the related rows from two tables. However, if we look at the results, we will see that it returned all the columns, thus combining both tables. This is not very concise. What about if we only want to see the emails and the related comments, and not all the data?</p>
			<p>There is some nice shorthand code that lets us do this:</p>
			<p class="source-code">import sqlite3</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="source-code">    sql = """</p>
			<p class="source-code">    SELECT comments.* FROM comments \</p>
			<p class="source-code">    JOIN user ON comments.user_id = user.email \</p>
			<p class="source-code">    WHERE user.email='bob@example.com' \</p>
			<p class="source-code">    """</p>
			<p class="source-code">    rows = cursor.execute(sql)</p>
			<p class="source-code">    for row in rows:</p>
			<p class="source-code">        print(row)</p>
			<p>Just by changing the <strong class="source-inline">SELECT</strong> statement, we made our final result appear as follows, where only columns from the <strong class="source-inline">comments</strong> table are present:</p>
			<p class="source-code">('bob@example.com', 'This is comment 0 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 1 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 2 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 3 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 4 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 5 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 6 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 7 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 8 by Bob Codd')</p>
			<p class="source-code">('bob@example.com', 'This is comment 9 by Bob Codd')</p>
			<p>We have now looked at joins. They are very useful, and you will end up using them often while dealing with databases in real life. Up next is a detailed look into deleting rows.</p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor281"/>Deleting Rows from Tables</h2>
			<p>This will be done by using the <strong class="source-inline">DELETE</strong> command. As the name suggests, this command helps to delete rows from a table. It is an irreversible process, meaning once deleted, we cannot restore those rows. So be very careful when running this command as it can have a destructive effect on the data. Please keep in mind that it has to almost always be run accompanied by a <strong class="source-inline">WHERE</strong> clause so that we delete just a part of the data and not everything.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor282"/>Exercise 8.06: Deleting Rows from Tables</h2>
			<p>In this exercise, we will be working with two tables, <strong class="source-inline">user</strong> and <strong class="source-inline">comments</strong>, which are a part of the <strong class="source-inline">lesson.db</strong> database. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The GitHub version of this exercise begins with the previous 4 examples that we just saw, starting off with creation of the <strong class="source-inline">comments</strong> table. You may ignore those steps if you have executed them already.</p>
			<p>We will delete a row from the <strong class="source-inline">user</strong> table and observe the effects it will have on the comments table. Include all the steps mentioned previously. Let's perform the following steps:</p>
			<ol>
				<li value="1">To delete a row from a table, we use the <strong class="source-inline">DELETE</strong> clause in SQL. To run delete on the user table, we are going to use the following code:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="source-code">    cursor.execute("DELETE FROM user "\</p><p class="source-code">                   "WHERE email='bob@example.com'")</p><p class="source-code">    conn.commit()</p></li>
				<li>Perform the <strong class="source-inline">SELECT</strong> operation on the user table:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="source-code">    rows = cursor.execute("SELECT * FROM user")</p><p class="source-code">    for row in rows:</p><p class="source-code">        print(row)</p><p>The output is as follows:</p><p class="source-code">('tom@web.com', 'Tom', 'Fake', '456 Fantasy lane, Fantasy City', </p><p class="source-code">  39, 'M')</p><p class="source-code">('shelly@www.com', 'Shelly', 'Milar', '123, Ocean View Lane', </p><p class="source-code">  39, 'F')</p><p>Observe that the user <strong class="source-inline">Bob</strong> has been deleted.</p><p>Now, moving on to the <strong class="source-inline">comments</strong> table, we have to remember that we had mentioned <strong class="source-inline">ON DELETE</strong> <strong class="source-inline">CASCADE</strong> while creating the table. The database engine knows that if a row is deleted from the parent table (<strong class="source-inline">user</strong>), all the related rows from the child tables (<strong class="source-inline">comments</strong>) will have to be deleted.</p></li>
				<li>Perform a <strong class="source-inline">SELECT</strong> operation on the <strong class="source-inline">comments</strong> table by using the following command:<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p><p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p><p class="source-code">    rows = cursor.execute("SELECT * FROM comments")</p><p class="source-code">    for row in rows:</p><p class="source-code">        print(row)</p><p>The output (partially shown) is as follows:</p><p class="source-code">('tom@web.com', 'This is comment 0 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 1 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 2 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 3 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 4 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 5 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 6 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 7 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 8 by Tom Fake')</p><p class="source-code">('tom@web.com', 'This is comment 9 by Tom Fake')</p></li>
			</ol>
			<p>We can see that all of the rows related to <strong class="source-inline">Bob</strong> are deleted from the <strong class="source-inline">comments</strong> table.</p>
			<p>We have observed the <strong class="source-inline">DELETE</strong> command and also learned how to use it safely.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YeutzP">https://packt.live/2YeutzP</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/3fArsQb">https://packt.live/3fArsQb</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>In the following section, we will see how to update a specific value in a table.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor283"/>Updating Specific Values in a Table</h2>
			<p>In this example, we will see how we can update rows in a table. Without <strong class="source-inline">WHERE</strong>, updating is often a bad idea. The reason is that we may end up updating rows that we did not intend to.</p>
			<p>We can combine <strong class="source-inline">UPDATE</strong> with <strong class="source-inline">WHERE</strong> to selectively update the first name of the user with the email address tom@web.com, as shown in the following code:</p>
			<p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p>
			<p class="source-code">    cursor = conn.cursor()</p>
			<p class="source-code">    cursor.execute("PRAGMA foreign_keys = 1")</p>
			<p class="source-code">    cursor.execute("UPDATE user set first_name='Chris' "\</p>
			<p class="source-code">                   "where email='tom@web.com'")</p>
			<p class="source-code">    conn.commit()</p>
			<p class="source-code">    rows = cursor.execute("SELECT * FROM user")</p>
			<p class="source-code">    for row in rows:</p>
			<p class="source-code">        print(row)</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="Images/B15780_08_08.jpg" alt="Figure 8.8: Output of the update query, showing the newly updated first name&#13;&#10;" width="1356" height="94"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: Output of the update query, showing the newly updated first name</p>
			<p>So far, we have covered a lot of concepts related to databases. We have learned a set of skills that are important for dealing with database-level operations. In the next section, we will combine two worlds; the world of databases and the world of pandas. </p>
			<p>We have looked into many fundamental aspects of storing and querying data from a database, but as a data wrangling expert, we need our data to be packed and presented as a DataFrame so that we can perform quick and convenient operations on them.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor284"/>Exercise 8.07: RDBMS and DataFrames</h2>
			<p>In this exercise, we will connect to the <strong class="source-inline">lesson.db</strong> database and join the two tables, <strong class="source-inline">user</strong> and <strong class="source-inline">comments</strong>. We will create an empty <strong class="source-inline">data</strong> list and then add the rows of this joined table in <strong class="source-inline">data</strong>. Next, we will store the content of <strong class="source-inline">data</strong> in a <strong class="source-inline">pandas</strong> DataFrame. To complete this exercise, let's perform the following steps:</p>
			<ol>
				<li value="1">Import pandas using the following code:<p class="source-code">import pandas as pd</p></li>
				<li>Create a columns list with email, first name, last name, age, gender, and comments as column names. Also, create an empty <strong class="source-inline">data</strong> list:<p class="source-code">columns = ["Email", "First Name", "Last Name", \</p><p class="source-code">           "Age", "Gender", "Comments"]</p><p class="source-code">data = []</p></li>
				<li>Connect to <strong class="source-inline">lesson.db</strong> using SQLite and obtain a cursor, as follows:<p class="source-code">import sqlite3</p><p class="source-code">with sqlite3.connect("../lesson.db") as conn:</p><p class="source-code">    cursor = conn.cursor()</p></li>
				<li>Use the <strong class="source-inline">execute</strong> method from the cursor to set <strong class="source-inline">PRAGMA foreign_keys = 1</strong>:<p class="source-code">cursor.execute("PRAGMA foreign_keys = 1")</p></li>
				<li>Create a <strong class="source-inline">sql</strong> variable that will contain the <strong class="source-inline">SELECT</strong> command and use the join command to join the databases:<p class="source-code">sql = """</p><p class="source-code">    SELECT user.email, user.first_name, user.last_name, \</p><p class="source-code">    user.age, user.gender, comments.comments FROM comments \</p><p class="source-code">    JOIN user ON comments.user_id = user.email \</p><p class="source-code">    WHERE user.email = 'tom@web.com' \</p><p class="source-code">     """</p></li>
				<li>Use the execute method of <strong class="source-inline">cursor</strong> to execute the <strong class="source-inline">sql</strong> command:<p class="source-code">rows = cursor.execute(sql)</p></li>
				<li>Append the rows to the data list:<p class="source-code">for row in rows:</p><p class="source-code">    data.append(row)</p></li>
				<li>Create a DataFrame using the data list and print out the result:<p class="source-code">df = pd.DataFrame(data, columns=columns)</p><p class="source-code">df</p><p>The output will be:</p><div id="_idContainer260" class="IMG---Figure"><img src="Images/B15780_08_09.jpg" alt="Figure 8.9: Output of the dataframe&#13;&#10;" width="1048" height="562"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.9: Output of the dataframe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To access the source code for this specific section, please refer to <a href="https://packt.live/2YPSdZX">https://packt.live/2YPSdZX</a>.</p>
			<p class="callout">You can also run this example online at <a href="https://packt.live/37HZaAi">https://packt.live/37HZaAi</a>.</p>
			<p class="callout">You must execute the entire Notebook in order to get the desired result.</p>
			<p>This ends our journey into the world of databases. It was a basic introduction. Nonetheless, we managed to cover a wide range of essential topics. DBMS and related fields are a mature stream in computer science and are still under active development and research. We strongly encourage the reader to read more about it. </p>
			<h2 id="_idParaDest-277">Activity <a id="_idTextAnchor285"/>8.01: Retrieving Data Accurately from Databases</h2>
			<p>The goal of this activity is to fetch data and retrieve information from two tables, <strong class="source-inline">persons</strong> and <strong class="source-inline">pets</strong>, which are a part of the <strong class="source-inline">petsdb</strong> database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find the <strong class="source-inline">petsdb</strong> database at <a href="https://packt.live/3dcH0rx">https://packt.live/3dcH0rx</a>.</p>
			<p>The <strong class="source-inline">persons</strong> table is defined as follows:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="Images/B15780_08_10.jpg" alt="Figure 8.10: The persons table&#13;&#10;" width="1170" height="389"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: The persons table</p>
			<p>The <strong class="source-inline">persons</strong> table has the following columns:</p>
			<ul>
				<li><strong class="source-inline">first_name</strong>: The first name of the person</li>
				<li><strong class="source-inline">last_name</strong>: The last name of the person (can be <strong class="source-inline">null</strong>)</li>
				<li><strong class="source-inline">age</strong>: The age of the person</li>
				<li><strong class="source-inline">city</strong>: The city where they are from</li>
				<li><strong class="source-inline">zip_code</strong>: The zip code of the city</li>
			</ul>
			<p>As we can see, the <strong class="source-inline">id</strong> column in the <strong class="source-inline">persons</strong> table (which is an integer) serves as the primary key for that table and as a foreign key for the <strong class="source-inline">pets</strong> table, which is linked via the <strong class="source-inline">owner_id</strong> column.</p>
			<p>The <strong class="source-inline">pets</strong> table is defined as follows:</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="Images/B15780_08_11.jpg" alt="Figure 8.11: The pets table&#13;&#10;" width="1378" height="459"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: The pets table</p>
			<p>The pets table has the following columns:</p>
			<ul>
				<li><strong class="source-inline">pet_name</strong>: The name of the pet.</li>
				<li><strong class="source-inline">pet_type</strong>: What type of pet it is, for example, <strong class="source-inline">cat</strong> or <strong class="source-inline">dog</strong>. Due to a lack of further information, we do not know which number represents what, but it is an integer and can be <strong class="source-inline">null</strong>.</li>
				<li><strong class="source-inline">treatment_done</strong>: This is also an integer column, and <strong class="source-inline">0</strong> here represents <strong class="source-inline">No</strong>, whereas <strong class="source-inline">1</strong> represents <strong class="source-inline">Yes</strong>.</li>
			</ul>
			<p>In this activity, you will first connect to the <strong class="source-inline">petsdb</strong> database and check whether the connection has been successful. You will then create and execute a few SQL commands to answer the following questions:</p>
			<ol>
				<li value="1">What is the count of people belonging to different age groups in the <strong class="source-inline">persons</strong> table?</li>
				<li>Which age group has the maximum number of people?</li>
				<li>How many people do not have a last name?</li>
				<li>How many people have more than one pet?</li>
				<li>How many pets have received treatment?</li>
				<li>How many pets have received treatment, and the type of pet is known?</li>
				<li>How many pets are from the city called east port?</li>
				<li>How many pets are from the city called east port, and who received treatment?</li>
			</ol>
			<p>The output should be as follows:</p>
			<p>Answer to question 1 (the following is partial output):</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="Images/B15780_08_12.jpg" alt="Figure 8.12: Partial output of the count of people belonging to different age groups &#13;&#10;from the persons table&#13;&#10;" width="944" height="763"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Partial output of the count of people belonging to different age groups from the persons table</p>
			<p>Answer to question 2:</p>
			<p class="source-code">Highest number of people is 5 and came from 73 age group</p>
			<p>Answer to question 3:</p>
			<p class="source-code">(60,)</p>
			<p>Answer to question 4:</p>
			<p class="source-code">43 people has more than one pet</p>
			<p>Answer to question 5:</p>
			<p class="source-code">(36,)</p>
			<p>Answer to question 6:</p>
			<p class="source-code">(16,)</p>
			<p>Answer to question 7:</p>
			<p class="source-code">(49,)</p>
			<p>Answer to question 8:</p>
			<p class="source-code">(11,)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15780_Solution_Final_RK.xhtml#_idTextAnchor327">this link</a>.</p>
			<p>In this activity, we have applied all the skills we learned in this chapter concerning databases. </p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor286"/>Summary</h1>
			<p>We have come to the end of the database chapter. We have learned how to connect to SQLite using Python. We have brushed up on the basics of relational databases and how to open and close a database. We then learned how to export this relational database into Python DataFrames.</p>
			<p>In the next chapter, we will be performing data wrangling on datasets that are used in business use cases. We will use different types of datasets and then clean and process the data in a meaningful way. We will be able to apply all the skills and tricks we have learned so far in this book to process data and get valuable insights from them.</p>
		</div>
		<div>
			<div id="_idContainer265" class="Content">
			</div>
		</div>
	</div></body></html>