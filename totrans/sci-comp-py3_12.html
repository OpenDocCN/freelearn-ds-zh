<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Input and Output</h1></div></div></div><p>In this chapter, we will cover some options for handling data files. Depending on the data and the desired format, there are several options for reading and writing. We will show some of the most useful alternatives.</p><div><div><div><div><h1 class="title"><a id="ch12lvl1sec92"/>File handling</h1></div></div></div><p>File I/O (input and output) is essential in a number of scenarios. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with measured or scanned data. Measurements are stored in files that need to be read to be analyzed.</li><li class="listitem" style="list-style-type: disc">Interacting with other programs. Save results to files so that they can be imported in other applications, and vice-versa.</li><li class="listitem" style="list-style-type: disc">Storing information for future reference or comparisons.</li><li class="listitem" style="list-style-type: disc">Sharing data and results with others, possibly on other platforms using other software.</li></ul></div><p>In this section, we will cover how to handle file I/O in Python.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec118"/>Interacting with files</h2></div></div></div><p>In Python, an object of type <code class="literal">file</code> represents the contents of a physical file stored on disk. A new <code class="literal">file</code> object may be created using the following syntax:</p><pre class="programlisting">myfile = open('measurement.dat','r') # creating a new file object from an existing file</pre><p>The contents of the file may be accessed, for instance, with this:</p><pre class="programlisting">print(myfile.read())</pre><p>Usage of file objects requires some care. The problem is that a file has to be closed before it can be reread or used by other applications, which is done using the following syntax:</p><pre class="programlisting">myfile.close() # closes the file object</pre><p>It is, however, not that simple because an exception might be triggered before the call to <code class="literal">close</code> is executed, which will skip the closing code (consider the following example). A simple way to make sure that a file will be properly closed is to use context managers. This construction, using the <code class="literal">with</code> keyword, is explained in more detail in section <em>Exception</em> in <a class="link" href="ch10.html" title="Chapter 10. Error Handling">Chapter 10</a>, <em>Error Handling</em>. Here is how it is used with files:</p><pre class="programlisting">with open('measurement.dat','r') as myfile: &#13;
     ... # use myfile here</pre><p>This ensures that the file is closed when one exits the <code class="literal">with</code> block, even if an exception is raised inside the block. The command works with context manager objects. We recommend that you read more on context managers in section <em>Exception</em> in <a class="link" href="ch10.html" title="Chapter 10. Error Handling">Chapter 10</a>, <em>Error Handling</em>. Here is an example showing why the <code class="literal">with</code> construct is desirable:</p><pre class="programlisting">myfile = open(name,'w')&#13;
myfile.write('some data')&#13;
a = 1/0&#13;
myfile.write('other data')&#13;
myfile.close()</pre><p>An exception is raised before the file is closed. The file remains open, and there is no guarantee of what data is written in the file or when it is written. Hence, the proper way to achieve the same result is this:</p><pre class="programlisting">with open(name,'w') as myfile:&#13;
    myfile.write('some data')&#13;
    a = 1/0&#13;
    myfile.write('other data')</pre><p>In that case, the file is cleanly closed just after the exception (here, <code class="literal">ZeroDivisionError</code>) is raised. Notice also that there is no need to close the file explicitly.</p></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec119"/>Files are iterable</h2></div></div></div><p>A file is, in particular, iterable (refer to section <em>Iterators</em> of <a class="link" href="ch09.html" title="Chapter 9. Iterating">Chapter 9</a>, <em>Iterating</em>). Files iterate their lines:</p><pre class="programlisting">with open(name,'r') as myfile:&#13;
    for line in myfile:&#13;
        data = line.split(';')&#13;
        print('time {} sec temperature {} C'.format(data[0],data[1]))</pre><p>The lines of the file are returned as strings. The string method <code class="literal">split</code> is a possible tool to convert the string to a list of strings. For example:</p><pre class="programlisting">data = 'aa;bb;cc;dd;ee;ff;gg'&#13;
data.split(';') # ['aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg']&#13;
&#13;
data = 'aa bb cc dd ee ff gg'&#13;
data.split(' ') # ['aa', 'bb', 'cc', 'dd', 'ee', 'ff', 'gg']</pre><p>Since the <code class="literal">myfile</code> object is iterable, we can also do a direct extraction into a list, as follows:</p><pre class="programlisting">data = list(myfile)</pre></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec120"/>File modes</h2></div></div></div><p>As you can see in these examples of file handling, the <code class="literal">open</code> function takes at least two arguments. The first is obviously the filename, and the second is a string describing the way in which the file will be used. There are several such modes for opening files; the basic ones are:</p><pre class="programlisting">with open('file1.dat','r') as ...  # read only&#13;
with open('file2.dat','r+') as ...  # read/write&#13;
with open('file3.dat','rb') as ...  # read in byte mode  &#13;
with open('file4.dat','a') as ...  # append (write to the end of the file)&#13;
with open('file5.dat','w') as ... # (over-)write the file&#13;
with open('file6.dat','wb') as ... # (over-)write the file in byte mode</pre><p>The <code class="literal">'r'</code>, <code class="literal">'r+'</code>, and <code class="literal">'a'</code> modes require that the file exists, whereas <code class="literal">'w'</code> will create a new file if no file with that name exists. Reading and writing with <code class="literal">'r'</code> and <code class="literal">'w'</code> is most common, as you saw in previous examples.</p><p>Consider an example of opening a file and adding data at the end of the file without modifying what is already there using the append <code class="literal">'a'</code> mode. Note the line break,<code class="literal">\n</code> :</p><pre class="programlisting">with open('file3.dat','a') as myfile:&#13;
    myfile.write('something new\n')</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec93"/>NumPy methods</h1></div></div></div><p>NumPy has built-in methods for reading and writing NumPy array data to text files. These are <code class="literal">numpy.loadtxt</code> and <code class="literal">numpy.savetxt</code>.</p><div><div><div><div><h2 class="title"><a id="ch12lvl2sec121"/>savetxt</h2></div></div></div><p>Writing an array to a text file is simple:</p><pre class="programlisting">savetxt(filename,data)</pre><p>There are two useful parameters given as strings, <code class="literal">fmt</code> and <code class="literal">delimiter</code>, which control the format and the delimiter between columns. The defaults are space for the delimiter and <code class="literal">%.18e</code> for the format, which corresponds to the exponential format with all digits. The formatting parameters are used as follows:</p><pre class="programlisting">x = range(100) # 100 integers&#13;
savetxt('test.txt',x,delimiter=',')   # use comma instead of space&#13;
savetxt('test.txt',x,fmt='%d') # integer format instead of float with e</pre></div><div><div><div><div><h2 class="title"><a id="ch12lvl2sec122"/> loadtxt</h2></div></div></div><p>Reading to an array from a text file is done with the help of the following syntax:</p><pre class="programlisting">filename = 'test.txt'&#13;
data = loadtxt(filename)</pre><p>Due to the fact that each row in an array must have the same length, each row in the text file must have the same number of elements. Similar to <code class="literal">savetxt</code>, the default values are <code class="literal">float</code> and the delimiter is <code class="literal">space</code>. These can be set using the <code class="literal">dtype</code> and <code class="literal">delimiter</code> parameters. Another useful parameter is <code class="literal">comments</code>, which can be used to mark what symbol is used for comments in the data file. An example for using the formatting parameters is as follows:</p><pre class="programlisting">data = loadtxt('test.txt',delimiter=';')    # data separated by semicolons&#13;
data = loadtxt('test.txt',dtype=int,comments='#') # read to integer type, &#13;
                                               #comments in file begin with a hash character</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec94"/>Pickling</h1></div></div></div><p>The read and write methods you just saw convert data to strings before writing. Complex types (such as objects and classes) cannot be written this way. With Python’s pickle module, you can save any object and also multiple objects to file.</p><p>Data can be saved in plaintext (ASCII) format or using a slightly more efficient binary format. There are two main methods: <code class="literal">dump</code>, which saves a pickled representation of a Python object to a file, and <code class="literal">load</code>, which retrieves a pickled object from the file. The basic usage is like this:</p><pre class="programlisting">import pickle&#13;
with open('file.dat','wb') as myfile:&#13;
    a = random.rand(20,20)&#13;
    b = 'hello world'&#13;
    pickle.dump(a,myfile)    # first call: first object&#13;
    pickle.dump(b,myfile)    # second call: second object&#13;
&#13;
&#13;
import pickle&#13;
with open('file.dat','rb') as myfile:&#13;
    numbers = pickle.load(myfile) # restores the array&#13;
    text = pickle.load(myfile)    # restores the string</pre><p>Note the order in which the two objects are returned. Besides the two main methods, it is sometimes useful to serialize a Python object to a string instead of a file. This is done with <code class="literal">dumps</code> and <code class="literal">load</code>. Consider an example for serializing an array and a dictionary:</p><pre class="programlisting">a = [1,2,3,4]&#13;
pickle.dumps(a) # returns a bytes object&#13;
b = {'a':1,'b':2}&#13;
pickle.dumps(b) # returns a bytes object</pre><p>A good example of using <code class="literal">dumps</code> is when you need to write Python objects or NumPy arrays to a database. These usually have support for storing strings, which makes it easy to write and read complex data and objects without any special modules. Besides the pickle module, there is also an optimized version called <code class="literal">cPickle</code>. It is written in C and is an option if you need fast reading and writing. The data produced by pickle and <em>cPickle</em> is identical and can be interchanged.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec95"/>Shelves</h1></div></div></div><p>Objects in dictionaries can be accessed by keys. There is a similar way to access particular data in a file by first assigning it a key. This is possible by using the module shelve:</p><pre class="programlisting">from contextlib import closing&#13;
import shelve as sv&#13;
# opens a data file (creates it before if necessary)&#13;
with closing(sv.open('datafile')) as data:&#13;
    A = array([[1,2,3],[4,5,6]])     &#13;
    data['my_matrix'] = A  # here we created a key</pre><p>In the section <em>File handling</em>, we saw that the built-in <code class="literal">open</code> command generates a context manager, and we saw why this is important for handling external resources, such as files. In contrast to this command, <code class="literal">sv.open</code> does not create a context manager by itself. The <code class="literal">closing</code> command from the <code class="literal">contextlib</code> module is needed to transform it into an appropriate context manager. Consider the following example of restoring the file:</p><pre class="programlisting">from contextlib import closing&#13;
import shelve as sv&#13;
with closing(sv.open('datafile')) as data: # opens a data file&#13;
    A = data['my_matrix']  # here we used the key&#13;
    ...</pre><p>A shelve object has all dictionary methods, for example, keys and values, and can be used in the same way as a dictionary. Note that changes are only written in the file after the <code class="literal">close</code> or <code class="literal">sync</code> method has been called.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec96"/>Reading and writing Matlab data files</h1></div></div></div><p>SciPy has the ability to read and write data in Matlab’s <code class="literal">.mat</code> file format using the module. The commands are <code class="literal">loadmat</code> and <code class="literal">savemat</code>. To load data, use the following syntax:</p><pre class="programlisting">import scipy.io&#13;
data = scipy.io.loadmat('datafile.mat')</pre><p>The variable data now contains a dictionary, with keys corresponding to the variable names saved in the <code class="literal">.mat</code> file. The variables are in NumPy array format. Saving to <code class="literal">.mat</code> files involves creating a dictionary with all the variables you want to save (variable name and value). The command is then <code class="literal">savemat</code>:</p><pre class="programlisting">data = {}&#13;
data['x'] = x&#13;
data['y'] = y&#13;
scipy.io.savemat('datafile.mat',data)</pre><p>This saves the NumPy arrays <code class="literal">x</code> and <code class="literal">y</code> with the same names when read into Matlab.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec97"/>Reading and writing images</h1></div></div></div><p>SciPy comes with some basic functions for handling images. The module function will read images to NumPy arrays. The function will save an array as an image. The following will read a <em>JPEG</em> image to an array, print the shape and type, then create a new array with a resized image, and write the new image to file:</p><pre class="programlisting">import scipy.misc as sm&#13;
&#13;
# read image to array&#13;
im = sm.imread("test.jpg") &#13;
print(im.shape)   # (128, 128, 3)&#13;
print(im.dtype)   # uint8&#13;
&#13;
# resize image&#13;
im_small = sm.imresize(im, (64,64))&#13;
print(im_small.shape)   # (64, 64, 3)&#13;
&#13;
# write result to new image file&#13;
sm.imsave("test_small.jpg", im_small)</pre><p>Note the data type. Images are almost always stored with pixel values in the range <em>0...255</em>  as 8-bit unsigned integers. The third shape value shows how many color channels the image has. In this case, <em>3</em> means it is a color image with values stored in this order: red <code class="literal">im[0]</code>, green <code class="literal">im[1]</code>, blue <code class="literal">im[2]</code>. A gray scale image would only have one channel.</p><p>For working with images, the SciPy module <code class="literal">scipy.misc</code> contains many useful basic image processing functions such as filtering, transforms, and measurements.</p></div>
<div><div><div><div><h1 class="title"><a id="ch12lvl1sec98"/>Summary</h1></div></div></div><p>File handling is inevitable when dealing with measurements and other sources of a larger amount of data. Also communication with other programs and tools is done via file handling.</p><p>You learned to see a file as a Python object like others with important methods such as <code class="literal">readlines</code> and <code class="literal">write</code>. We showed how files can be protected by special attributes, which may allow only read or only write access.</p><p>The way you write to a file often influences the speed of the process. We saw how data is stored by pickling or by using the <code class="literal">shelve</code> method.</p></div></body></html>