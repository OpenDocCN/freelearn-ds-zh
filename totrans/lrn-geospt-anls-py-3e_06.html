<html><head></head><body><div><h1 class="header-title">Geospatial Python Toolbox</h1>
                
            
            
                
<p>The first three chapters of this book covered the history of geospatial analysis, the types of geospatial data that are used by analysts, and the major software and libraries found within the geospatial industry. We used some simple Python examples here and there to illustrate certain points, but we mainly focused on the field of geospatial analysis, independent of any specific technology. Starting here, we will be using Python to conquer geospatial analysis and we will continue with that approach for the rest of this book. This chapter explains the software you will need in your toolbox to do just about anything you want in the geospatial field.</p>
<p>We'll discover the Python libraries that are used to access the different types of data that were found in the vector data and raster data sections of <a href="a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml">Chapter 2</a>, <em>Learning Geospatial Data</em>. Some of these libraries are pure Python, as well as some of the bindings to the different software packages that we looked at in <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Installing third-party Python modules</li>
<li>Python virtual environment</li>
<li>Conda</li>
<li>Docker</li>
<li>Python networking libraries for acquiring data</li>
<li>Python tag-based parsers</li>
<li>Python JSON libraries</li>
<li>OGR</li>
<li>PyShp</li>
<li>DBFPY</li>
<li>Shapely</li>
<li>GDAL</li>
<li>Fiona</li>
<li>NumPy</li>
<li>GeoPandas</li>
<li>Python Imaging Library (PIL)</li>
<li>PNGCanvas</li>
<li>ReportLab</li>
<li>GeoPDF</li>
<li>Python NetCDF libraries</li>
<li>Python HDF libraries</li>
<li>OSMnx </li>
<li>Spatial indexing libraries</li>
<li>Jupyter</li>
<li>Conda</li>
</ul>
<p>We will examine pure Python solutions whenever possible. Python is a very capable programming language, but some operations, particularly in remote sensing, are too computationally intensive and therefore are impractical when it comes to using pure Python or other interpreted languages. Fortunately, every aspect of geospatial analysis can be addressed in some way through Python, even if it is binding to a highly efficient C/C++/other compiled-language library.</p>
<p>We will avoid using broad scientific libraries that cover other domains beyond geospatial analysis to keep the solutions as simple as possible. There are many reasons to use Python for geospatial analysis, but one of the strongest arguments is its portability.</p>
<p>Furthermore, Python has been ported to Java as the Jython distribution and to the .NET <strong>Common Language Runtime</strong> (<strong>CLR</strong>) as IronPython. Python also has versions such as Stackless Python for massively concurrent programs. There are versions of Python that are designed to run on cluster computers for distributed processing. Python is also available on many hosted application servers that do not allow you to install custom executables, such as the Google App Engine platform, which has a Python API.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<ul>
<li>Python 3.6 or higher</li>
<li>RAM: Minimum 6 GB (Windows), 8 GB (macOS) recommended 8 GB</li>
<li>Storage: Minimum 7200 RPM SATA with 20 GB of available space; recommended SSD with 40 GB of available space</li>
<li class="mce-root">Processor: Minimum Intel Core i3 2.5 GHz; recommended Intel Core i5</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing third-party Python modules</h1>
                
            
            
                
<p>Modules written in pure Python (using the standard library) will mostly run on any of the 20 platforms that the Python (<a href="https://www.python.org/">https://www.python.org/</a>) website mentions. Each time you add a third-party module that relies on bindings to external libraries in other languages, you reduce Python's inherent portability. You also add a layer of complexity to fundamentally change the code by adding another language into the mix. Pure Python keeps things simple. Also, Python bindings to external libraries tend to be automatically or semi-automatically generated.</p>
<p>These automatically generated bindings are very generic and esoteric, and they simply connect Python to a C/C++ API using the method names from that API, instead of following the best practices for Python. There are, of course, notable exceptions to this approach that are driven by project requirements which may include speed, unique library features, or frequently updated libraries where an automatically generated interface is preferable.</p>
<p>We'll make a distinction between modules that are included as a part of Python's standard library and modules that must be installed. In Python, the <kbd>words</kbd> module and library are used interchangeably. To install libraries, you either get them from the <strong>Python Package Index </strong>(<strong>PyPI</strong>) or in the case of a lot of geospatial modules, you download a specialized installer.</p>
<p>PyPI acts as the official software repository for libraries and offers some easy-to-use setup programs that simplify installing packages. You can use the <kbd>easy_install</kbd> program, which is especially good on Windows or the <kbd>pip</kbd> program that's more commonly found on Linux and Unix systems. Once it's installed, you can then install third-party packages by running the following code:</p>
<pre><strong>easy_install &lt;package name&gt;</strong></pre>
<p>For installing <kbd>pip</kbd>, run the following code:</p>
<pre><strong>pip install &lt;package name&gt;</strong></pre>
<p>This book will provide links and installation instructions for open source packages that are not available on the PyPI. You can manually install third-party Python modules by downloading the Python source code and putting it in your current working directory, or you can put it in your Python <kbd>site-packages</kbd> directory. These two directories are available in Python's search path when you try to import a module. If you put a module in your current working directory, it'll only be available when you start Python from that directory.</p>
<p>If you put it in your <kbd>site-packages</kbd> directory, it'll be available every time you start Python. The <kbd>site-packages</kbd> directory is specifically meant for third-party modules. To locate the <kbd>site-packages</kbd> directory for your installation, you need to ask Python's <kbd>sys</kbd> module. The <kbd>sys</kbd> module has a <kbd>path</kbd> attribute that has a list of all the directories in Python's search path. The <kbd>site-packages</kbd> directory should be the last one. You can locate it by specifying an index of <kbd>-1</kbd>, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; import sys</strong><br/><strong>&gt;&gt;&gt; sys.path[-1]</strong><br/><strong>'C:\\Python34\\lib\\site-packages'</strong></pre>
<p>If that call doesn't return the <kbd>site-packages</kbd> path, just look at the entire list to locate it, as shown in the following code:</p>
<pre><strong>&gt;&gt; sys.path</strong><br/><strong>['', 'C:\\WINDOWS\\system32\\python34.zip', 'C:\\Python34\\DLLs',</strong><br/><strong>'C:\\Python34\\lib', 'C:\\Python34\\lib\\plat-win</strong><br/><strong>', 'C:\\Python34\\lib\\lib-tk', 'C:\\Python34',</strong><br/><strong>'C:\\Python34\\lib\\site-packages']</strong></pre>
<p>These installation methods will be used in the rest of this book. You can find the latest Python version, the source code for your platform installation, and compilation instructions at <a href="http://python.org/download/">http://python.org/download/</a>.</p>
<p>The Python <kbd>virtualenv</kbd> module allows you to easily create an isolated copy of Python for a specific project without affecting your main Python installation or other projects. Using this module, you can have different projects with different versions of the same library. Once you have a working code base, you can keep it isolated from changes to the modules you used or even Python itself. The <kbd>virtualenv</kbd> module is simple to use and can be used for any example in this book; however, explicit instructions on its use are not included.</p>
<p>To get started with <kbd>virtualenv</kbd>, follow this simple guide: <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Python virtualenv</h1>
                
            
            
                
<p class="mce-root">Python geospatial analysis requires that we use a variety of modules with many dependencies. These modules often build on each other using specific versions of C or C++ libraries. You often run into version conflicts as you add Python modules to your system. Sometimes, when you upgrade a particular module, it might break your existing Python program due to changes in the API – or maybe you are running both Python 2 and Python 3 to take advantage of libraries written for each version. What you need is a way to safely install new modules without corrupting a working system or code. The solution to that issue is to use Python virtual environments through the <kbd>virtualenv</kbd> module.</p>
<p class="mce-root">The Python <kbd>virtualenv</kbd> module creates isolated, individual Python environments for each project so that you can avoid conflicting modules polluting your main Python installation. You can switch a particular environment on and off by activating it or deactivating it. The <kbd>virtualenv</kbd> module is efficient in that it doesn't actually copy your entire system Python installation each time you create an environment. Let's get started:</p>
<ol>
<li class="mce-root">Installing <kbd>virtualenv</kbd> is as simple as running the following code:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>pip install virtualenv</strong></pre>
<ol start="2">
<li class="mce-root">Then, create a directory for your virtual Python environments. Name it whatever you want:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>mkdir geospatial_projects</strong></pre>
<ol start="3">
<li class="mce-root">Now, you can create your first virtual environment using the following command:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>virtualenv geospatial_projects/project1</strong></pre>
<ol start="4">
<li class="mce-root">Then, after entering the following command, you can activate the environment:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>source geospatial_projects/project1/bin/activate</strong></pre>
<ol start="5">
<li class="mce-root">Now, when you run any Python commands in that directory, it will use the isolated virtual environment. When you're done, you can deactivate that environment with the following simple command:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>deactivate</strong></pre>
<p>This is how you install, activate for use, and deactivate the <kbd>virtualenv</kbd> module. There's one other environment you should know about, however. We'll examine that next.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Conda</h1>
                
            
            
                
<p>It's also worth mentioning Conda here, which is an open source, cross-platform package management system that can also create and manage environments similar to <kbd>virtualenv</kbd>. Conda makes it easy to install complex packages, including geospatial ones. It also works with other languages besides Python, including R, Node.js, and Java.  </p>
<p>Conda is available here: <a href="https://docs.conda.io/en/latest/">https://docs.conda.io/en/latest/</a>.</p>
<p>Now, let's check out how to install GDAL so that we can start processing geospatial data.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Installing GDAL</h1>
                
            
            
                
<p>The <strong>Geospatial Data Abstraction Library</strong> (<strong>GDAL</strong>), which includes OGR, is critical to many of the examples in this book and is also one of the more complicated Python setups. For these reasons, we'll discuss it separately here. The latest GDAL bindings are available on PyPI; however, the installation requires a few more steps because of additional resources that are needed by the GDAL library.</p>
<p>There are three ways to install GDAL for use with Python. You can use any one of them:</p>
<ul>
<li>Compile it from the source code.</li>
<li>Install it as part of a larger software package.</li>
<li>Install a binary distribution and then the Python bindings.</li>
</ul>
<p>If you have experience with compiling C libraries as well as the required compiler software, then the first option gives you the most control. However, it is not recommended if you just want to get going as quickly as possible, because even experienced software developers can find compiling GDAL and the associated Python bindings challenging. Instructions for compiling GDAL on leading platforms can be found at <a href="http://trac.osgeo.org/gdal/wiki/BuildHints">http://trac.osgeo.org/gdal/wiki/BuildHints</a>. There are also basic build instructions on the PyPI GDAL page; have a look at <a href="https://pypi.python.org/pypi/GDAL">https://pypi.python.org/pypi/GDAL</a>.</p>
<p>The second option is by far the quickest and easiest. The <strong>Open Source Geospatial Foundation</strong> (<strong>OSGeo</strong>) distributes an installer called OSGeo4W, which installs all of the top open source geospatial packages on Windows at the click of a button. OSGeo4W can be found at <a href="http://trac.osgeo.org/osgeo4w/">http://trac.osgeo.org/osgeo4w/</a>.</p>
<p>While these packages are the easiest to work with, they come with their own version of Python. If you already have Python installed, then having another Python distribution just to use certain libraries may be problematic. In that case, the third option may be for you.</p>
<p>The third option installs a pre-compiled binary specific to your Python version. This method is the best compromise between ease of installation and customization. The catch is that you must make sure the binary distributions and the corresponding Python bindings are compatible with each other, your Python version, and in many cases your operating system configuration.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Windows</h1>
                
            
            
                
<p>The installation of GDAL for Python on Windows becomes easier and easier each year. To install GDAL on Windows, you must check whether you are running the 32-bit or 64-bit version of Python:</p>
<ol>
<li>To do so, just start your Python interpreter at a Command Prompt, as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600</strong><br/><strong>32 bit (Intel)] on win32</strong><br/><strong>Type "help", "copyright", "credits" or "license" for more</strong><br/><strong>information.</strong></pre>
<ol start="2">
<li>Based on this instance, we can see that Python is version 3.4.2 for <kbd>win32</kbd>, which means it is the 32-bit version. Once you have this information, go to the following URL: <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal">http://www.lfd.uci.edu/~gohlke/pythonlibs/#gdal</a>.</li>
<li>This web page contains Python Windows binaries and bindings for nearly every open source scientific library. On that web page, in the GDAL section, find the release that matches your version of Python. The release names use the abbreviation <kbd>cp</kbd> for C Python, followed by the major Python version number and either <kbd>win32</kbd> for 32-bit Windows or <kbd>win_amd64</kbd> for 64-bit Windows.</li>
</ol>
<p>In the previous example, we would download the file named <kbd>GDAL-1.11.3-cp34-none-win32.whl</kbd>.</p>
<ol start="4">
<li>This download package is in the newer Python <kbd>pip</kbd> wheel format. To install it, simply open a Command Prompt and type in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>pip install GDAL-1.11.3-cp34-none-win32.whl</strong></pre>
<ol start="5">
<li>Once the package has been installed, open your Python interpreter and run the following commands to verify that GDAL is installed by checking its version:</li>
</ol>
<pre style="padding-left: 60px"><strong>Python 3.4.2 (v3.4.2:ab2c023a9432, Oct 6 2014, 22:15:05) [MSC v.1600 32 bit (Intel)] on win32</strong><br/><strong>Type "help", "copyright", "credits" or "license" for more information.</strong><br/><strong>&gt;&gt;&gt; from osgeo import gdal</strong><br/><strong>&gt;&gt;&gt; gdal.__version__</strong><br/><strong>1.11.3</strong></pre>
<p>Now, GDAL should return its version as <kbd>1.11.3</kbd>.</p>
<p>If you have trouble installing modules using <kbd>easy_install</kbd> or <kbd>pip</kbd> and PyPI, try to download and install the wheel package from the same site as the GDAL example.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Linux</h1>
                
            
            
                
<p>GDAL installation on Linux varies widely by distribution. The following <a href="https://gdal.org">https://gdal.org</a> binaries web page lists the installation instructions for several distributions: <a href="http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries">http://trac.osgeo.org/gdal/wiki/DownloadingGdalBinaries</a>. Let's get started:</p>
<ol>
<li>Typically, your package manager will install both GDAL and Python bindings. For example, on Ubuntu, to install GDAL, you need to run the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo apt-get install gdal-bin</strong></pre>
<ol start="2">
<li>Then, to install the Python bindings, you can run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo apt-get install python3-gdal</strong></pre>
<ol start="3">
<li>Most Linux distributions are set up to compile software already, and their instructions are much simpler than those on Windows.</li>
<li>Depending on the installation, you may have to import <kbd>gdal</kbd> and <kbd>ogr</kbd> as part of the <kbd>osgeo</kbd> package, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; from osgeo import gdal</strong><br/><strong>&gt;&gt;&gt; from osgeo import ogr</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">macOS X</h1>
                
            
            
                
<p>To install GDAL on macOS X, you can also use the Homebrew package management system, which is available at <a href="http://brew.sh/">http://brew.sh/</a>.</p>
<p>Alternatively, you can use the MacPorts package management system, which is available at <a href="https://www.macports.org/">https://www.macports.org/</a>.</p>
<p>Both of these systems are well-documented and contain GDAL packages for Python 3. You only really need them for libraries that require a properly compiled binary written in C that has a lot of dependencies and includes many of the scientific and geospatial libraries.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Python networking libraries for acquiring data</h1>
                
            
            
                
<p>The vast majority of geospatial data sharing is accomplished via the internet, and Python is well equipped when it comes to networking libraries for almost any protocol. Automated data downloads are often an important step in automating a geospatial process. Data is typically retrieved from a website's <strong>Uniform Resource Locator</strong> (<strong>URL</strong>) or <strong>File Transfer Protocol</strong> (<strong>FTP</strong>) server and, because geospatial datasets often contain multiple files, data is often distributed as ZIP files.</p>
<p>A nice feature of Python is its concept of a file-like object. Most Python libraries that read and write data use a standard set of methods that allow you to access data from different types of resources, as if you were writing a simple file on disk. The networking modules in the Python standard library use this convention as well. The benefit of this approach is that it allows you to pass file-like objects to other libraries and methods, which recognize the convention without a lot of setup for different types of data that are distributed in different ways.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The Python urllib module</h1>
                
            
            
                
<p>The Python <kbd>urllib</kbd> package is designed for simple access to any file with a URL address. The <kbd>urllib</kbd> package in Python 3 consists of several modules that handle different parts of managing web requests and responses. These modules implement some of Python's file-like object conventions, starting with its <kbd>open()</kbd> method. When you call <kbd>open()</kbd>, it prepares a connection to the resource but does not access any data. Sometimes, you just want to grab a file and save it to disk, instead of accessing it in memory. This function is available through the <kbd>urllib.request.retrieve()</kbd> method.</p>
<p>The following example uses the <kbd>urllib.request.retrieve()</kbd> method to download the zipped shapefile named <kbd>hancock.zip</kbd>, which is used in other examples. We define the URL and the local filename as variables. The URL is passed as an argument, as well as the filename we want to use, to save it to our local machine, which, in this case, is just <kbd>hancock.zip</kbd>:</p>
<pre><strong>&gt;&gt;&gt; import urllib.request</strong><br/><strong>&gt;&gt;&gt; import urllib.parse</strong><br/><strong>&gt;&gt;&gt; import urllib.error</strong><br/><strong>&gt;&gt;&gt; url = "https://github.com/GeospatialPython/</strong><br/><strong>Learn/raw/master/hancock.zip"</strong><br/><strong>&gt;&gt;&gt; fileName = "hancock.zip"</strong><br/><strong>&gt;&gt;&gt; urllib.request.urlretrieve(url, fileName)</strong><br/><strong>('hancock.zip', &lt;httplib.HTTPMessage instance at 0x00CAD378&gt;)</strong></pre>
<p>The message from the underlying <kbd>httplib</kbd> module confirms that the file was downloaded to the current directory. The URL and filename could have been passed to the <kbd>retrieve()</kbd> method directly as strings as well. If you specify just the filename, the download saves to the current working directory. You can also specify a fully qualified pathname to save it somewhere else. You can also specify a callback function as a third argument, which will receive download status information for the file so that you can create a simple download status indicator or perform some other action.</p>
<p>The <kbd>urllib.request.urlopen()</kbd> method allows you to access an online resource with more precision and control. As we mentioned previously, it implements most of the Python file-like object methods with the exception of the <kbd>seek()</kbd> method, which allows you to jump to arbitrary locations within a file. You can read a file online one line at a time, read all the lines as a list, read a specified number of bytes, or iterate through each line of the file. All of these functions are performed in memory, so you don't have to store the data on disk. This ability is useful for accessing frequently updated data online that you may want to process without saving to disk.</p>
<p>In the following example, we demonstrate this concept by accessing the <strong>United States Geological Survey</strong> (<strong>USGS</strong>) earthquake feed to view all of the earthquakes in the world that have occurred within the last hour. This data is distributed as a <strong>Comma-Separated Value</strong> (<strong>CSV</strong>) file, which we can read line by line like a text file. CSV files are similar to spreadsheets and can be opened in a text editor or spreadsheet program:</p>
<ol>
<li>First, you need to open the URL and read the header with the column names in the file.</li>
</ol>
<ol start="2">
<li>Then, you need to read the first line, which contains a record of a recent earthquake, as shown in the following lines of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; url = "http://earthquake.usgs.gov/earthquakes/feed/v1.0/</strong><br/><strong>summary/all_hour.csv"</strong><br/><strong>&gt;&gt;&gt; earthquakes = urllib.request.urlopen(url)</strong><br/><strong>&gt;&gt;&gt; earthquakes.readline()</strong><br/><strong>'time,latitude,longitude,depth,mag,magType,nst,gap,dmin,rms,net,</strong><br/><strong>id,updated,place</strong><br/><strong>\n'</strong><br/><strong>&gt;&gt;&gt; earthquakes.readline()</strong><br/><strong>'2013-06-14T14:37:57.000Z,64.8405,-147.6478,13.1,0.6,Ml,</strong><br/><strong>6,180,0.09701805,0.2,ak,</strong><br/><strong>ak10739050,2013-06-14T14:39:09.442Z,"3km E of Fairbanks,</strong><br/><strong>Alaska"\n'</strong></pre>
<ol start="3">
<li>We can also iterate through this file, which is a memory-efficient way to read through large files.</li>
<li>If you are running this example in the Python interpreter, you will need to press the <em>Enter</em> or <em>return</em> key twice to execute the loop. This action is necessary because it signals to the interpreter that you are done building the loop. In the following example, we abbreviate the output:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; for record in earthquakes: print(record)</strong><br/><strong>2013-06-14T14:30:40.000Z,62.0828,-145.2995,22.5,1.6,</strong><br/><strong>Ml,8,108,0.08174669,0.86,ak,</strong><br/><strong>ak10739046,2013-06-14T14:37:02.318Z,"13km ESE of Glennallen,</strong><br/><strong>Alaska"</strong><br/><strong>...</strong><br/><strong>2013-06-14T13:42:46.300Z,38.8162,-122.8148,3.5,0.6,</strong><br/><strong>Md,,126,0.00898315,0.07,nc,nc</strong><br/><strong>72008115,2013-06-14T13:53:11.592Z,"6km NW of The Geysers,</strong><br/><strong>California"</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">The Python requests module</h1>
                
            
            
                
<p>The <kbd>urllib</kbd> module has been around for a long time. Another third-party module has been developed to make common HTTP requests even easier. The <kbd>requests</kbd> module has the following features:</p>
<ul>
<li>Keep-alive and connection pooling</li>
<li>International domains and URLs</li>
<li>Sessions with cookie persistence</li>
<li>Browser-style SSL verification</li>
<li>Automatic content decoding</li>
<li>Basic/digest authentication</li>
<li>Elegant key/value cookies</li>
<li>Automatic decompression</li>
<li>Unicode response bodies</li>
<li>HTTP(S) proxy Support</li>
<li>Multipart file uploads</li>
<li>Streaming downloads</li>
<li>Connection timeouts</li>
<li>Chunked requests</li>
<li><kbd>.netrc</kbd> support</li>
</ul>
<p class="mce-root">In the following example, we'll download the same ZIP file we downloaded with the <kbd>urllib</kbd> module, except this time using the <kbd>requests</kbd> module. First, we need to install the <kbd>requests</kbd> module:</p>
<pre><strong>pip install requests</strong></pre>
<p>Then, we can import it:</p>
<pre><strong>import requests</strong></pre>
<p>Then, we can set up our variables for the URL and the output filename:</p>
<pre><strong>url = "https://github.com/GeospatialPython/Learning/raw/master/hancock.zip"</strong><br/><strong>fileName = "hancock.zip"</strong></pre>
<p>Retrieving the ZIP file is as simple as using the <kbd>requests</kbd> module's <kbd>get()</kbd> method:</p>
<pre><strong>r = requests.get(url)</strong></pre>
<p>Now, we can get the content from the <kbd>.zip</kbd> file and write it to our output file:</p>
<pre><strong>with open(fileName, 'wb') as f:</strong><br/><strong>    f.write(r.content)</strong></pre>
<p>The <kbd>requests</kbd> module has many more advanced features that are just as easy to use as this example. Now that we know how to get information via the HTTP protocol, let's examine the FTP protocol which is often used to access geospatial data from online archives.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">FTP</h1>
                
            
            
                
<p>FTP allows you to browse an online directory and download data using FTP client software. Until around 2004, when geospatial web services became very common, FTP was one of the most common ways to distribute geospatial data. FTP is less common now, but you occasionally encounter it when you're searching for data. Once again Python's batteries-included standard library has a reasonable FTP module called <kbd>ftplib</kbd> with a main class called <kbd>FTP()</kbd>.</p>
<p>In the following example, we will do the following:</p>
<ol>
<li>We will access an FTP server hosted by the US <strong>National Oceanic and Atmospheric Administration</strong> (<strong>NOAA</strong>) to access a text file containing data from the <strong>Deep-ocean Assessment and Reporting of Tsunamis</strong> (<strong>DART</strong>) buoy network that's used to watch for tsunamis around the world. This particular buoy is off the coast of Peru.</li>
<li>We'll define the server and the directory path, and then we will access the server. All FTP servers require a username and password. Most public servers have a user called anonymous with the password as anonymous, just like this one does.</li>
<li>Using Python's <kbd>ftplib</kbd>, you can just call the <kbd>login()</kbd> method without any arguments to log in as the default anonymous user. Otherwise, you can add the username and password as string arguments.</li>
<li>Once we're logged in, we'll change to the directory containing the DART datafile.</li>
<li>To download the file, we'll open up a local file called out and pass its <kbd>write()</kbd> method as a callback function to the <kbd>ftplib.ftp.retrbinary()</kbd> method, which simultaneously downloads the file and writes it to our local file.</li>
<li>Once the file has been downloaded, we can close it to save it.</li>
<li>Then, we'll read the file and look for the line containing the latitude and longitude of the buoy to make sure that the data was downloaded successfully, as shown in the following lines of code:</li>
</ol>
<pre style="padding-left: 60px">import ftplib<br/><br/>server = "ftp.ngdc.noaa.gov"<br/>dir = "hazards/DART/20070815_peru"<br/>fileName = "21415_from_20070727_08_55_15_tides.txt"<br/>ftp = ftplib.FTP(server)<br/>ftp.login()<br/>ftp.cwd(dir)<br/><br/>with open(fileName, "wb") as out:<br/>    ftp.retrbinary("RETR " + fileName, out.write)<br/><br/>with open(fileName) as dart:<br/> for line in dart:<br/>     if "LAT, " in line:<br/>     print(line)<br/>     break</pre>
<p>The output is:</p>
<pre class="p1"><strong> LAT,   LON      50.1663    171.8360</strong></pre>
<p>In this example, we opened the local file in binary write mode, and we used the <kbd>retrbinary() ftplib</kbd> method, as opposed to <kbd>retrlines()</kbd>, which uses ASCII mode. The binary mode works for both ASCII and binary files, so it's always a safer bet. In fact, in Python, the binary read and write modes for a file are only required on Windows.</p>
<p>If you are just downloading a simple file from an FTP server, many FTP servers have a web interface as well. In that case, you could use <kbd>urllib</kbd> to read the file. FTP URLs use the following format to access data:</p>
<pre>ftp://username:password@server/directory/file</pre>
<p>This format is insecure for password-protected directories because you are transmitting your login information over the internet. But for anonymous FTP servers, there is no additional security risk. To demonstrate this, the following example accesses the same file that we just saw but by using <kbd>urllib</kbd> instead of <kbd>ftplib</kbd>:</p>
<pre><strong>&gt;&gt;&gt; dart = urllib.request.urlopen("ftp://" + server + "/" + dir +</strong><br/><strong>"/" + fileName)</strong><br/><strong>&gt;&gt;&gt; for line in dart:</strong><br/><strong>... line = str(line, encoding="utf8")</strong><br/><strong>... if "LAT," in line:</strong><br/><strong>... print(line)</strong><br/><strong>... break</strong><br/><strong>...</strong><br/><strong>LAT, LON 50.1663 171.8360</strong></pre>
<p>Now that we can download files, let's learn how to decompress them.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ZIP and TAR files</h1>
                
            
            
                
<p>Geospatial datasets often consist of multiple files. For this reason, they are often distributed as ZIP or TAR file archives. These formats can also compress data, but their ability to bundle multiple files is the primary reason they are used for geospatial data. While the TAR format doesn't contain a compression algorithm, it incorporates gzip compression and offers it as a program option. Python has standard modules for reading and writing both ZIP and TAR archives. These modules are called <kbd>zipfile</kbd> and <kbd>tarfile</kbd>, respectively.</p>
<p>The following example extracts the <kbd>hancock.shp</kbd>, <kbd>hancock.shx</kbd>, and <kbd>hancock.dbf</kbd> files contained in the <kbd>hancock.zip</kbd> file we downloaded using <kbd>urllib</kbd> for use in the previous examples. This example assumes that the ZIP file is in the current directory:</p>
<pre><strong>&gt;&gt;&gt; import zipfile</strong><br/><strong>&gt;&gt;&gt; zip = open("hancock.zip", "rb")</strong><br/><strong>&gt;&gt;&gt; zipShape = zipfile.ZipFile(zip)</strong><br/><strong>&gt;&gt;&gt; shpName, shxName, dbfName = zipShape.namelist()</strong><br/><strong>&gt;&gt;&gt; shpFile = open(shpName, "wb")</strong><br/><strong>&gt;&gt;&gt; shxFile = open(shxName, "wb")</strong><br/><strong>&gt;&gt;&gt; dbfFile = open(dbfName, "wb")</strong><br/><strong>&gt;&gt;&gt; shpFile.write(zipShape.read(shpName))</strong><br/><strong>&gt;&gt;&gt; shxFile.write(zipShape.read(shxName))</strong><br/><strong>&gt;&gt;&gt; dbfFile.write(zipShape.read(dbfName))</strong><br/><strong>&gt;&gt;&gt; shpFile.close()</strong><br/><strong>&gt;&gt;&gt; shxFile.close()</strong><br/><strong>&gt;&gt;&gt; dbfFile.close()</strong></pre>
<p>This example is more verbose than necessary for clarity. We can shorten this example and make it more robust by using a <kbd>for</kbd> loop around the <kbd>zipfile.namelist()</kbd> method without explicitly defining the different files as variables. This method is a more flexible and Pythonic approach, and could be used on ZIP archives with unknown contents, as shown in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; import zipfile</strong><br/><strong>&gt;&gt;&gt; zip = open("hancock.zip", "rb")</strong><br/><strong>&gt;&gt;&gt; zipShape = zipfile.ZipFile(zip)</strong><br/><strong>&gt;&gt;&gt; for fileName in zipShape.namelist():</strong><br/><strong>... out = open(fileName, "wb")</strong><br/><strong>... out.write(zipShape.read(fileName))</strong><br/><strong>... out.close()</strong><br/><strong>&gt;&gt;&gt;</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now that you understand the basics of the <kbd>zipfile</kbd> module, let's take the files we just unzipped and create a TAR archive with them. In this example, when we open the TAR archive for writing, we specify the write mode as <kbd>w:gz</kbd> for gzipped compression. We also specify the file extension as <kbd>tar.gz</kbd> to reflect this mode, as shown in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; import tarfile</strong><br/><strong>&gt;&gt;&gt; tar = tarfile.open("hancock.tar.gz", "w:gz")</strong><br/><strong>&gt;&gt;&gt; tar.add("hancock.shp")</strong><br/><strong>&gt;&gt;&gt; tar.add("hancock.shx")</strong><br/><strong>&gt;&gt;&gt; tar.add("hancock.dbf")</strong><br/><strong>&gt;&gt;&gt; tar.close()</strong></pre>
<p>We can extract the files using the simple <kbd>tarfile.extractall()</kbd> method. First, we open the file using the <kbd>tarfile.open()</kbd> method and then extract it, as shown in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; tar = tarfile.open("hancock.tar.gz", "r:gz")</strong><br/><strong>&gt;&gt;&gt; tar.extractall()</strong><br/><strong>&gt;&gt;&gt; tar.close()</strong></pre>
<p>We'll work on one more example by combining elements we've learned in this chapter as well as the elements in the vector data section of <a href="a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml">Chapter 2</a>, <em>Learning Geospatial Data</em>. We'll read the bounding box coordinates from the <kbd>hancock.zip</kbd> file without ever saving it to disk. We'll use the power of Python's file-like object convention to pass around the data. Then, we'll use Python's <kbd>struct</kbd> module to read the bounding box, like we did in <a href="a7a60707-fb99-41d3-959c-7ed43a469c55.xhtml">Chapter 2</a>, <em>Learning Geospatial Data</em>.</p>
<p>In this case, we read the unzipped <kbd>.shp</kbd> file into a variable and access the data using Python array slicing by specifying the starting and ending indexes of the data separated by a colon (<kbd>:</kbd>). We are able to use list slicing because Python allows you to treat strings as lists. In this example, we also use Python's <kbd>StringIO</kbd> module to temporarily store data in memory in a file-like object that implements various methods, including the <kbd>seek()</kbd> method, which is absent from most Python networking modules, as shown in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; import urllib.request</strong><br/><strong>&gt;&gt;&gt; import urllib.parse</strong><br/><strong>&gt;&gt;&gt; import urllib.error</strong><br/><strong>&gt;&gt;&gt; import zipfile</strong><br/><strong>&gt;&gt;&gt; import io</strong><br/><strong>&gt;&gt;&gt; import struct</strong><br/><strong>&gt;&gt;&gt; url =</strong><br/><strong>"https://github.com/GeospatialPython/Learn/raw/master/hancock.zip"</strong><br/><strong>&gt;&gt;&gt; cloudshape = urllib.request.urlopen(url)</strong><br/><strong>&gt;&gt;&gt; memoryshape = io.BytesIO(cloudshape.read())</strong><br/><strong>&gt;&gt;&gt; zipshape = zipfile.ZipFile(memoryshape)</strong><br/><strong>&gt;&gt;&gt; cloudshp = zipshape.read("hancock.shp")</strong><br/><strong># Access Python string as an array</strong><br/><strong>&gt;&gt;&gt; struct.unpack("&lt;dddd", cloudshp[36:68])</strong><br/><strong>(-89.6904544701547, 30.173943486533133, -89.32227546981174,</strong><br/><strong>30.6483914869749)</strong></pre>
<p>As you can see from the examples so far, Python's standard library packs a lot of punch. Most of the time, you don't have to download a third-party library just to access a file online.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Python markup and tag-based parsers</h1>
                
            
            
                
<p>Tag-based data, particularly different XML dialects, have become a very popular way to distribute geospatial data. Formats that are both machine and human-readable are generally easy to work with, though they sacrifice storage efficiency for usability. These formats can become unmanageable for very large datasets but work very well in most cases.</p>
<p>While most formats are some form of XML (such as KML or GML), there is a notable exception. The <strong>Well-Known Text</strong> (<strong>WKT</strong>) format is fairly common but uses external markers and square brackets (<kbd>[]</kbd>) to surround data instead of tags in angled brackets around data like XML does.</p>
<p>Python has standard library support for XML, as well as some excellent third-party libraries available. Proper XML formats all follow the same structure, so you can use a generic XML library to read it. Because XML is text-based, it is often easy to write it as a string instead of using an XML library. The vast majority of applications that output XML do so in this way.</p>
<p>The primary advantage of using XML libraries for writing XML is that your output is usually validated. It is very easy to create an error while creating your own XML format. A single missing quotation mark can derail an XML parser and throw an error for somebody trying to read your data. When these errors happen, they virtually render your dataset useless. You will find that this problem is very common among XML-based geospatial data. What you'll discover is that some parsers are more forgiving with incorrect XML than others. Often, reliability is more important than speed or memory efficiency.</p>
<p>The analysis that's available at <a href="http://lxml.de/performance.html">http://lxml.de/performance.html</a> provides benchmarks for memory and speed among the different Python XML parsers.<a href="http://lxml.de/performance.html%20"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">The minidom module</h1>
                
            
            
                
<p>The Python <kbd>minidom</kbd> module is a very old and simple to use XML parser. It is part of Python's built-in set of XML tools in the XML package. It can parse XML files or XML that's been fed in as a string. The <kbd>minidom</kbd> module is best for small to medium-sized XML documents of less than about 20 MB before speed begins to decrease.</p>
<p>To demonstrate the <kbd>minidom</kbd> module, we'll use a sample KML file, which is a part of Google's KML documentation that you can download. The data that's available at the following link represents time-stamped point locations that have been transferred from a GPS device: <a href="https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml">https://github.com/GeospatialPython/Learn/raw/master/time-stamp-point.kml</a>. Let's get started:</p>
<ol>
<li>First, we'll parse this data by reading it in from the file and creating a <kbd>minidom</kbd> parser object. The file contains a series of <kbd>&lt;Placemark&gt;</kbd> tags, which contain a point and a timestamp at which that point was collected. So, we'll get a list of all of the <kbd>Placemarks</kbd> in the file, and we can count them by checking the length of that list, as shown in the following lines of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; from xml.dom import minidom</strong><br/><strong>&gt;&gt;&gt; kml = minidom.parse("time-stamp-point.kml")</strong><br/><strong>&gt;&gt;&gt; Placemarks = kml.getElementsByTagName("Placemark")</strong><br/><strong>&gt;&gt;&gt; len(Placemarks)</strong><br/><strong>361</strong></pre>
<ol start="2">
<li>As you can see, we retrieved all <kbd>Placemarks</kbd>, which totaled <kbd>361</kbd>. Now, let's take a look at the first <kbd>Placemark</kbd> element in the list:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; Placemarks[0]</strong><br/><strong>&lt;DOM Element: Placemark at 0x2045a30&gt;</strong></pre>
<p style="padding-left: 60px">Each <kbd>&lt;Placemark&gt;</kbd> tag is now a DOM element data type. To really see what that element is, we call the <kbd>toxml()</kbd> method, as follows:</p>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; Placemarks[0].toxml()</strong><br/><strong>u'&lt;Placemark&gt;\n &lt;TimeStamp&gt;\n \&lt;when&gt;2007-01-14T21:05:02Z&lt;/when&gt;\n</strong><br/><strong>&lt;/TimeStamp&gt;\n &lt;styleUrl&gt;#paddle-a&lt;/styleUrl&gt;\n &lt;Point&gt;\n</strong><br/><strong>&lt;coordinates&gt;-122.536226,37.86047,0&lt;/coordinates&gt;\n</strong><br/><strong>&lt;/Point&gt;\n &lt;/Placemark&gt;'</strong></pre>
<ol start="3">
<li>The <kbd>toxml()</kbd> function outputs everything contained in the <kbd>Placemark</kbd> tag as a string object. If we want to print this information to a text file, we can call the <kbd>toprettyxml()</kbd> method, which would add additional indentation to make the XML more readable.</li>
</ol>
<ol start="4">
<li>Now, what if we want to grab just the coordinates from this placemark? The coordinates are buried inside the <kbd>coordinates</kbd> tag, which is contained in the <kbd>point</kbd> tag and nested inside the <kbd>Placemark</kbd> tag. Each element of a <kbd>minidom</kbd> object is called a <strong>node</strong>. Nested nodes are called children or child nodes. The child nodes include more than just tags – they can also include whitespace separating tags, as well as the data inside the tags. So, we can drill down to the <kbd>coordinates</kbd> tag using the tag name, but then we'll need to access the <kbd>data</kbd> node. All the <kbd>minidom</kbd> elements have <kbd>childNodeslist</kbd>, as well as a <kbd>firstChild()</kbd> method to access the first node.</li>
<li>We'll combine these methods to get to the <kbd>data</kbd> attribute of the first coordinate's <kbd>data</kbd> node, which we reference using index <kbd>0</kbd> in the list of coordinate stags:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; coordinates =</strong><br/><strong>Placemarks[0].getElementsByTagName("coordinates")</strong><br/><strong>&gt;&gt;&gt; point = coordinates[0].firstChild.data</strong><br/><strong>&gt;&gt;&gt; point</strong><br/><strong>u'-122.536226,37.86047,0'</strong></pre>
<p>If you're new to Python, you'll notice that the text output in these examples is tagged with the letter <kbd>u</kbd>. This markup is how Python denotes Unicode strings that support internationalization to multiple languages with different character sets. Python 3.4.3 changes this convention slightly and leaves Unicode strings unmarked while marking UTF-8 strings with a <kbd>b</kbd>.</p>
<ol start="6">
<li>We can go a little further and convert this <kbd>point</kbd> string into usable data by splitting the string and converting the resulting strings into Python float types, as shown here:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; x,y,z = point.split(",")</strong><br/><strong>&gt;&gt;&gt; x</strong><br/><strong>u'-122.536226'</strong><br/><strong>&gt;&gt;&gt; y</strong><br/><strong>u'37.86047'</strong><br/><strong>&gt;&gt;&gt; z</strong><br/><strong>u'0'</strong><br/><strong>&gt;&gt;&gt; x = float(x)</strong><br/><strong>&gt;&gt;&gt; y = float(y)</strong><br/><strong>&gt;&gt;&gt; z = float(z)</strong><br/><strong>&gt;&gt;&gt; x,y,z</strong><br/><strong>(-122.536226, 37.86047, 0.0)</strong></pre>
<ol start="7">
<li>Using Python list comprehension, we can perform this operation in a single step, as you can see in the following lines of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; x,y,z = [float(c) for c in point.split(",")]</strong><br/><strong>&gt;&gt;&gt; x,y,z</strong><br/><strong>(-122.536226, 37.86047, 0.0)</strong></pre>
<p>This example scratches the surface of what the <kbd>minidom</kbd> library can do. For a great tutorial on this library, have a look at the following tutorial: <a href="https://www.edureka.co/blog/python-xml-parser-tutorial/">https://www.edureka.co/blog/python-xml-parser-tutorial/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">ElementTree</h1>
                
            
            
                
<p>The <kbd>minidom</kbd> module is pure Python, easy to work with, and has been around since Python 2.0. However, Python 2.5 added a more efficient yet high-level XML parser to the standard library called <kbd>ElementTree</kbd>. <kbd>ElementTree</kbd> is interesting because it has been implemented in multiple versions.</p>
<p>There is a pure Python version and a faster version written in C called <kbd>cElementTree</kbd>. You should use <kbd>cElementTree</kbd> wherever possible, but it's possible that you may be on a platform that doesn't include the C-based version. When you import <kbd>cElementTree</kbd>, you can test to see if it's available and fall back to the pure Python version if necessary:</p>
<pre>try:<br/>    import xml.etree.cElementTree as ET<br/>except ImportError:<br/>    import xml.etree.ElementTree as ET</pre>
<p>One of the great features of <kbd>ElementTree</kbd> is its implementation of a subset of the XPath query language. XPath is short for XML Path and allows you to search an XML document using a path-style syntax. If you work with XML frequently, learning XPath is essential. You can learn more about XPath at the following link: <a href="https://www.w3schools.com/xml/xpath_intro.asp">https://www.w3schools.com/xml/xpath_intro.asp</a>.</p>
<p>One catch with this feature is that if the document specifies a namespace, as most XML documents do, you must insert that namespace into queries. <kbd>ElementTree</kbd> does not automatically handle the namespace for you. Your options are to manually specify it or try to extract it using string parsing from the root element's tag name.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We'll repeat the <kbd>minidomXML</kbd> parsing example using <kbd>ElementTree</kbd>:</p>
<ol>
<li>First, we'll parse the document and then we'll manually define the KML namespace; later, we'll use an XPath expression and the <kbd>find()</kbd> method to find the first <kbd>Placemark</kbd> element.</li>
<li>Finally, we'll find the coordinates and the child node and then grab the text containing the latitude and longitude.</li>
</ol>
<p>In both cases, we could have searched directly for the <kbd>coordinates</kbd> tag. But, by grabbing the <kbd>Placemark</kbd> element, it gives us the option of grabbing the corresponding timestamp child element later, if we so choose, as shown in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; tree = ET.ElementTree(file="time-stamp-point.kml")</strong><br/><strong>&gt;&gt;&gt; ns = "{http://www.opengis.net/kml/2.2}"</strong><br/><strong>&gt;&gt;&gt; placemark = tree.find(".//%sPlacemark" % ns)</strong><br/><strong>&gt;&gt;&gt; coordinates =</strong><br/><strong>placemark.find("./{}Point/{}coordinates".format(ns, ns))</strong><br/><strong>&gt;&gt;&gt; coordinates.text</strong><br/><strong>'-122.536226,37.86047,0'</strong></pre>
<p>In this example, notice that we used the Python string formatting syntax, which is based on the string formatting concept found in C. When we defined the XPath expression for the placemark variable, we used the <kbd>%</kbd> placeholder to specify the insertion of a string. Then, after the string, we used the <kbd>%</kbd> operator followed by a variable name to insert the <kbd>ns</kbd> namespace variable where the placeholder is. In the <kbd>coordinates</kbd> variable, we used the <kbd>ns</kbd> variable twice, so we specified a tuple containing <kbd>ns</kbd> twice after the string.</p>
<p>String formatting is a simple yet extremely powerful and useful tool in Python that's worth learning. You can find more information in Python's documentation online at the following link: <a href="https://docs.python.org/3.4/library/string.html">https://docs.python.org/3.4/library/string.html</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building XML using ElementTree and Minidom</h1>
                
            
            
                
<p>Most of the time, XML can be built by concatenating strings, as you can see in the following command:</p>
<pre><strong>xml = "&lt;?xml version="1.0" encoding="utf-8"?&gt;"</strong><br/><strong>xml += "&lt;kml &gt;"</strong><br/><strong>xml += " &lt;Placemark&gt;"</strong><br/><strong>xml += " &lt;name&gt;Office&lt;/name&gt;"</strong><br/><strong>xml += " &lt;description&gt;Office Building&lt;/description&gt;"</strong><br/><strong>xml += " &lt;Point&gt;"</strong><br/><strong>xml += " &lt;coordinates&gt;"</strong><br/><strong>xml += " -122.087461,37.422069"</strong><br/><strong>xml += " &lt;/coordinates&gt;"</strong><br/><strong>xml += " &lt;/Point&gt;"</strong><br/><strong>xml += " &lt;/Placemark&gt;"</strong><br/><strong>xml += "&lt;/kml&gt;"</strong></pre>
<p>However, this method can be quite prone to typos, which creates invalid XML documents. A safer way is to use an XML library. Let's build this simple KML document using <kbd>ElementTree</kbd>:</p>
<ol>
<li>We'll define the <kbd>rootKML</kbd> element and assign it a namespace.</li>
<li>Then, we'll systematically append sub elements to the root, wrap the elements as an <kbd>ElementTree</kbd> object, declare the XML encoding, and write it out to a file called <kbd>placemark.xml</kbd>, as shown in the following lines of code:</li>
</ol>
<pre style="padding-left: 60px"><strong>&gt;&gt;&gt; root = ET.Element("kml")</strong><br/><strong>&gt;&gt;&gt; root.attrib["xmlns"] = "http://www.opengis.net/kml/2.2"</strong><br/><strong>&gt;&gt;&gt; placemark = ET.SubElement(root, "Placemark")</strong><br/><strong>&gt;&gt;&gt; office = ET.SubElement(placemark, "name")</strong><br/><strong>&gt;&gt;&gt; office.text = "Office"</strong><br/><strong>&gt;&gt;&gt; point = ET.SubElement(placemark, "Point")</strong><br/><strong>&gt;&gt;&gt; coordinates = ET.SubElement(point, "coordinates")</strong><br/><strong>&gt;&gt;&gt; coordinates.text = "-122.087461,37.422069, 37.422069"</strong><br/><strong>&gt;&gt;&gt; tree = ET.ElementTree(root)</strong><br/><strong>&gt;&gt;&gt; tree.write("placemark.kml",</strong><br/><strong>xml_declaration=True,encoding='utf-8',method="xml")</strong></pre>
<p>The output is identical to the previous string building example, except that <kbd>ElementTree</kbd> does not indent the tags but rather writes it as one long string. The <kbd>minidom</kbd> module has a similar interface, which is documented in the book <em>Dive Into Python</em>, by Mark Pilgrim, which was referenced in the <kbd>minidom</kbd> example that we just saw.</p>
<p>XML parsers such as <kbd>minidom</kbd> and <kbd>ElementTree</kbd> work very well on perfectly formatted XML documents. Unfortunately, the vast majority of XML documents out there don't follow these rules and contain formatting errors or invalid characters. You'll find that you are often forced to work with this data and must resort to extraordinary string parsing techniques to get the small subset of data you actually need. But thanks to Python and Beautiful Soup, you can elegantly work with bad and even terrible tag-based data.</p>
<p>Beautiful Soup is a module that was specifically designed to robustly handle broken XML. It is oriented toward HTML, which is notorious for incorrect formatting but works with other XML dialects too. Beautiful Soup is available on PyPI, so use either <kbd>easy_install</kbd> or <kbd>pip</kbd> to install it, as you can see in the following command:</p>
<pre><strong>easy_install beautifulsoup4</strong></pre>
<p>Alternatively, you can execute the following command:</p>
<pre><strong>pip install beautifulsoup4</strong></pre>
<p>Then, to use it, you simply import it:</p>
<pre><strong>&gt;&gt;&gt; from bs4 import BeautifulSoup</strong></pre>
<p>To try it out, we'll use a <strong>GPS Exchange Format</strong> (<strong>GPX</strong>) tracking file from a smartphone application, which has a glitch and exports slightly broken data. You can download this sample file from <a href="https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx">https://raw.githubusercontent.com/GeospatialPython/Learn/master/broken_data.gpx</a>.</p>
<p>This 2,347-line data file is in pristine condition except that it is missing a closing <kbd>&lt;/trkseg&gt;</kbd> tag, which should be located at the very end of the file, just before the closing <kbd>&lt;/trk&gt;</kbd> tag. This error was caused by a data export function in the source program. This defect is most likely a result of the original developer manually generating the GPX XML on export and forgetting the line of code that adds this closing tag. Watch what happens if we try to parse this file with <kbd>minidom</kbd>:</p>
<pre><strong>&gt;&gt;&gt; gpx = minidom.parse("broken_data.gpx")</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>File "C:\Python34\lib\xml\dom\minidom.py", line 1914, in parse</strong><br/><strong>return expatbuilder.parse(file)</strong><br/><strong>File "C:\Python34\lib\xml\dom\expatbuilder.py", line 924, in</strong><br/><strong>parse</strong><br/><strong>result = builder.parseFile(fp)</strong><br/><strong>File "C:\Python34\lib\xml\dom\expatbuilder.py", line 207, in</strong><br/><strong>parseFile</strong><br/><strong>parser.Parse(buffer, 0)</strong><br/><strong>xml.parsers.expat.ExpatError: mismatched tag: line 2346, column 2</strong></pre>
<p>As you can see from the last line in the error message, the underlying XML parser in <kbd>minidom</kbd> knows exactly what the problem is – a <kbd>mismatched</kbd> tag right at the end of the file. However, it refused to do anything more than report the error. You must have perfectly formed XML or none at all to avoid this.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, let's try the more sophisticated and efficient <kbd>ElementTree</kbd> module with the same data:</p>
<pre><strong>&gt;&gt;&gt; ET.ElementTree(file="broken_data.gpx")</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>File "C:\Python34\lib\xml\etree\ElementTree.py", line 611, in</strong><br/><strong>__init__</strong><br/><strong>self.parse(file)</strong><br/><strong>File "C:\Python34\lib\xml\etree\ElementTree.py", line 653, in</strong><br/><strong>parse</strong><br/><strong>parser.feed(data)</strong><br/><strong>File "C:\Python34\lib\xml\etree\ElementTree.py", line 1624, in</strong><br/><strong>feed</strong><br/><strong>self._raiseerror(v)</strong><br/><strong>File "C:\Python34\lib\xml\etree\ElementTree.py", line 1488, in</strong><br/><strong>_raiseerror</strong><br/><strong>raise err</strong><br/><strong>xml.etree.ElementTree.ParseError: mismatched tag: line 2346,</strong><br/><strong>column 2</strong></pre>
<p>As you can see, different parsers face the same problem. Poorly formed XML is an all too common reality in geospatial analysis, and every XML parser assumes that all the XML in the world is perfect, except for one. Enter Beautiful Soup. This library shreds bad XML into usable data without a second thought, and it can handle far worse defects than missing tags. It will work despite missing punctuation or other syntax and will give you the best data it can. It was originally developed for parsing HTML, which is notoriously horrible for being poorly formed, but it works fairly well with XML as well, as shown here:</p>
<pre><strong>&gt;&gt;&gt; from bs4 import BeautifulSoup</strong><br/><strong>&gt;&gt;&gt; gpx = open("broken_data.gpx")</strong><br/><strong>&gt;&gt;&gt; soup = BeautifulSoup(gpx.read(), features="xml")</strong><br/><strong>&gt;&gt;&gt;</strong></pre>
<p>No complaints from Beautiful Soup! Just to make sure the data is actually usable, let's try and access some of the data. One of the fantastic features of Beautiful Soup is that it turns tags into attributes of the parse tree. If there are multiple tags with the same name, it grabs the first one. Our sample data file has hundreds of <kbd>&lt;trkpt&gt;</kbd> tags. Let's access the first one:</p>
<pre><strong>&gt;&gt;&gt; soup.trkpt</strong><br/><strong>&lt;trkpt lat="30.307267000" lon="-89.332444000"&gt;</strong><br/><strong>&lt;ele&gt;10.7&lt;/ele&gt;&lt;time&gt;2013-05-16T04:39:46Z&lt;/time&gt;&lt;/trkpt&gt;</strong></pre>
<p class="mce-root"/>
<p>We're now certain that the data has been parsed correctly and that we can access it. If we want to access all of the <kbd>&lt;trkpt&gt;</kbd> tags, we can use the <kbd>findAll()</kbd> method to grab them and then use the built-in Python <kbd>len()</kbd> function to count them, as shown here:</p>
<pre><strong>&gt;&gt;&gt; tracks = soup.findAll("trkpt")</strong><br/><strong>&gt;&gt;&gt; len(tracks)</strong><br/><strong>2321</strong></pre>
<p>If we write the parsed data back out to a file, Beautiful Soup outputs the corrected version. We'll save the fixed data as a new GPX file using Beautiful Soup module's <kbd>prettify()</kbd> method to format the XML with nice indentation, as you can see in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; fixed = open("fixed_data.gpx", "w")</strong><br/><strong>&gt;&gt;&gt; fixed.write(soup.prettify())</strong><br/><strong>&gt;&gt;&gt; fixed.close()</strong></pre>
<p>Beautiful Soup is a very rich library with many more features. To explore it further, visit the Beautiful Soup documentation online at <a href="http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html">http://www.crummy.com/software/BeautifulSoup/bs4/documentation.html</a>.</p>
<div><p>While <kbd>minidom</kbd>, <kbd>ElementTree</kbd>, and <kbd>cElementTree</kbd> come with the Python standard library, there is an even more powerful and popular XML library for Python called <kbd>lxml</kbd>. The <kbd>lxml</kbd> module provides a Pythonic interface to the <kbd>libxml2</kbd> and <kbd>libxslt</kbd> C libraries using the <kbd>ElementTree</kbd> API. An even better fact is that <kbd>lxml</kbd> also works with Beautiful Soup to parse bad tag-based data. On some installations, <kbd>beautifulsoup4</kbd> may require <kbd>lxml.</kbd> The <kbd>lxml</kbd> module is available via PyPI but requires some additional steps for the C libraries. More information is available on the <kbd>lxml</kbd> home page at the following link: <a href="http://lxml.de/">http://lxml.de/</a>.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Well-Known Text (WKT)</h1>
                
            
            
                
<p>The WKT format has been around for years and is a simple text-based format for representing geometries and spatial reference systems. It is primarily used as a data exchange format by systems that implement the OGC Simple Features for SQL specification. Take a look at the following sample WKT representation of a polygon:</p>
<pre>POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Currently, the best way to read and write WKT is by using the Shapely library. Shapely provides a very Python-oriented or Pythonic interface to the <strong>Geometry Engine - Open Source</strong> (<strong>GEOS</strong>) library we described in <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>.</p>
<p>You can install Shapely using either <kbd>easy_install</kbd> or <kbd>pip</kbd>. You can also use the wheel from the site we mentioned in the previous section. Shapely has a WKT module which can load and export this data. Let's use Shapely to load the previous polygon sample and then verify that it has been loaded as a polygon object by calculating its area:</p>
<pre><strong>&gt;&gt;&gt; import shapely.wkt</strong><br/><strong>&gt;&gt;&gt; wktPoly = "POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,</strong><br/><strong>1 1))"</strong><br/><strong>&gt;&gt;&gt; poly = shapely.wkt.loads(wktPoly)</strong><br/><strong>&gt;&gt;&gt; poly.area</strong><br/><strong>15.0</strong></pre>
<p>We can convert any Shapely geometry back into a WKT by simply calling its <kbd>wkt</kbd> attribute, as shown here:</p>
<pre><strong>&gt;&gt;&gt; poly.wkt</strong><br/><strong>'POLYGON ((0.0 0.0, 4.0 0.0, 4.0 4.0, 0.0 4.0, 0.0 0.0), (1.0 1.0,</strong><br/><strong>2.0 1.0, 2.0 2.0, 1.0 2.0, 1.0 1.0))'</strong></pre>
<p>Shapely can also handle the WKT binary counterpart called W<strong>ell-Known Binary</strong> (<strong>WKB</strong>), which is used to store WKT strings as binary objects in databases. Shapely loads WKB using its <kbd>wkb</kbd> module in the same way as the <kbd>wkt</kbd> module, and it can convert geometries by calling that object's <kbd>wkb</kbd> attribute.</p>
<p>Shapely is the most Pythonic way to work with WKT data, but you can also use the Python bindings to the OGR library, which we installed earlier in this chapter.</p>
<p>For this example, we'll use a shapefile with one simple polygon, which can be downloaded as a ZIP file. It is available at the following link: <a href="https://github.com/GeospatialPython/Learn/raw/master/polygon.zip">https://github.com/GeospatialPython/Learn/raw/master/polygon.zip</a>.</p>
<p>In the following example, we'll open the <kbd>polygon.shp</kbd> file from the shapefile dataset, call the required <kbd>GetLayer()</kbd> method, get the first (and only) feature, and then export it to WKT:</p>
<pre><strong>&gt;&gt;&gt; from osgeo import ogr</strong><br/><strong>&gt;&gt;&gt; shape = ogr.Open("polygon.shp")</strong><br/><strong>&gt;&gt;&gt; layer = shape.GetLayer()</strong><br/><strong>&gt;&gt;&gt; feature = layer.GetNextFeature()</strong><br/><strong>&gt;&gt;&gt; geom = feature.GetGeometryRef()</strong><br/><strong>&gt;&gt;&gt; wkt = geom.ExportToWkt()</strong><br/><strong>&gt;&gt;&gt; wkt</strong><br/><strong>' POLYGON ((-99.904679362176353 51.698147686745074,</strong><br/><strong>-75.010398603076666 46.56036851832075,-75.010398603076666</strong><br/><strong>46.56036851832075,-75.010398603076666 46.56036851832075,</strong><br/><strong>-76.975736557742451 23.246272688996914,-76.975736557742451</strong><br/><strong>23.246272688996914,-76.975736557742451 23.246272688996914,</strong><br/><strong>-114.31715769639194 26.220870210283724,-114.31715769639194</strong><br/><strong>26.220870210283724,-99.904679362176353 51.698147686745074))'</strong></pre>
<p>Note that with OGR, you would have to read access each feature and export it individually, since the <kbd>ExporttoWkt()</kbd> method is at the feature level. We can now turn around and read a WKT string using the <kbd>wkt</kbd> variable containing the export. We'll import it back into <kbd>ogr</kbd> and get the bounding box, also known as an envelope, of the polygon, as you can see here:</p>
<pre><strong>&gt;&gt;&gt; poly = ogr.CreateGeometryFromWkt(wkt)</strong><br/><strong>&gt;&gt;&gt; poly.GetEnvelope()</strong><br/><strong>(-114.31715769639194, -75.01039860307667, 23.246272688996914,</strong><br/><strong>51.698147686745074)</strong></pre>
<p>Shapely and OGR are used for reading and writing valid WKT strings. Of course, just like XML, which is also text, you could manipulate small amounts of WKT as strings in a pinch.  Next, we'll look at a modern text format that is becoming very common in the geospatial world.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Python JSON libraries</h1>
                
            
            
                
<p><strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) is rapidly becoming the number one data exchange format across a lot of fields. The lightweight syntax and its similarity to existing data structures in both the JavaScript that Python borrows some data structures from, as well as JavaScript itself, make it a perfect match for Python.</p>
<p>The following GeoJSON sample document contains a single point:</p>
<pre>{<br/>    "type": "Feature",<br/>    "id": "OpenLayers.Feature.Vector_314",<br/>    "properties": {},<br/>    "geometry": {<br/>        "type": "Point",<br/>        "coordinates": [<br/>            97.03125,<br/>            39.7265625<br/>        ]<br/>    },<br/>    "crs": {<br/>        "type": "name",<br/>        "properties": {<br/>            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"<br/>        }<br/>    }<br/>}</pre>
<p>This sample is just a simple point with new attributes, which would be stored in the properties data structure of the geometry. In the preceding example, the ID, coordinates, and CRS information would change depending on your particular dataset. </p>
<p>Let's modify this sample GeoJSON document using Python. First, we'll compact the sample document into a single string to make it easier to handle:</p>
<pre><strong>&gt;&gt;&gt; jsdata = """{<br/>    "type": "Feature",<br/>   "id": "OpenLayers.Feature.Vector_314",<br/>  "properties": {},<br/>    "geometry": {<br/>        "type": "Point",<br/>        "coordinates": [<br/>           97.03125,<br/>           39.7265625<br/>       ]<br/>    },<br/>    "crs": {<br/>        "type": "name",<br/>        "properties": {<br/>            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"<br/>        }<br/>    }<br/>}"""</strong></pre>
<p>Now, we can use the GeoJSON <kbd>jsdata</kbd> string variable we created in the preceding code, in the following examples.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The json module</h1>
                
            
            
                
<p>GeoJSON looks very similar to a nested set of Python's dictionaries and lists. Just for fun, let's just try and use Python's <kbd>eval()</kbd> function to parse it as Python code:</p>
<pre><strong>&gt;&gt;&gt; point = eval(jsdata)</strong><br/><strong>&gt;&gt;&gt; point["geometry"]</strong><br/><strong>{'type': 'Point', 'coordinates': [97.03125, 39.7265625]}</strong></pre>
<p class="mce-root"/>
<p>Wow! That worked! We turned that random GeoJSON string into native Python data in one easy step. Keep in mind that the JSON data format is based on JavaScript syntax, which happens to be similar to Python. Also, as you get deeper into GeoJSON data and work with larger data, you'll find that JSON allows characters that Python does not. Using Python's <kbd>eval()</kbd> function is considered very insecure as well. But as far as keeping things simple is concerned, note that it doesn't get any simpler than that!</p>
<p>Thanks to Python's drive toward simplicity, the more advanced method doesn't get much more complicated. Let's use Python's <kbd>json</kbd> module, which is part of the standard library, to turn the same string into Python the right way:</p>
<pre><strong>&gt;&gt;&gt; import json</strong><br/><strong>&gt;&gt;&gt; json.loads(jsdata)</strong><br/><strong>{u'geometry': {u'type': u'Point', u'coordinates': [97.03125,</strong><br/><strong>39.7265625]}, u'crs</strong><strong>': {u'type': u'name', u'properties': {u'name':</strong><br/><strong>u'urn:ogc:def:crs:OGC:1.3:CRS84'}</strong><strong>}, u'type': u'Feature', u'id': u'OpenLayers.Feature.Vector_314',</strong><br/><strong>u'properties':</strong><br/><strong>{}}</strong></pre>
<p>As a side note, in the previous example, the CRS84 property is a synonym for the common WGS84 coordinate system. The <kbd>json</kbd> module adds some nice features such as safer parsing and conversion of strings into Unicode. We can export Python data structures to JSON in almost the same way:</p>
<pre><strong>&gt;&gt;&gt; pydata = json.loads(jsdata)</strong><br/><strong>&gt;&gt;&gt; json.dumps(pydata)</strong><br/><strong>'{"geometry": {"type": "Point", "coordinates": [97.03125,</strong><br/><strong>39.7265625]}, "crs": {</strong><strong>"type": "name", "properties": {"name":</strong><br/><strong>"urn:ogc:def:crs:OGC:1.3:CRS84"}}, "type" </strong><strong>: "Feature", "id": "OpenLayers.Feature.Vector_314", "properties":</strong><br/><strong>{}}'</strong></pre>
<p>When you dump data, it comes out as one long string that's difficult to read. There's a way we can print the data so it is easier to read: by passing the <kbd>dumps()</kbd> method an indent value:</p>
<pre class="p1">print(json.dumps(pydata, indent=4))<br/><br/>{<br/>    "type": "Feature",<br/>    "id":<br/>    "OpenLayers.Feature.Vector_314",<br/>    "properties": {},<br/>    "geometry": {<br/>        "type": "Point",<br/>        "coordinates": [<br/>            97.03125,<br/>            39.7265625<br/>        ]<br/>    },<br/>    "crs": {<br/>        "type": "name",<br/>        "properties": {           <br/>                 "name": "urn:ogc:def:crs:OGC:1.3:CRS84"<br/>        }<br/>   }<br/>}</pre>
<p>Now that we understand <kbd>json</kbd> module, let's look at the geospatial version called <kbd>geojson</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The geojson module</h1>
                
            
            
                
<p>We could happily go on reading and writing GeoJSON data using the <kbd>json</kbd> module forever, but there's an even better way. The <kbd>geojson</kbd> module that's available on PyPI offers some distinct advantages. For starters, it knows the requirements of the GeoJSON specification, which can save a lot of typing. Let's create a simple point using this module and export it to GeoJSON:</p>
<pre><strong>&gt;&gt;&gt; import geojson</strong><br/><strong>&gt;&gt;&gt; p = geojson.Point([-92, 37])</strong></pre>
<p>This time, when we dump the JSON data for viewing, we'll add an indent argument with a value of <kbd>4</kbd> so that we get nicely indented JSON data that's easier to read:</p>
<pre><strong>&gt;&gt;&gt; geojs = geojson.dumps(p, indent=4)</strong><br/><strong>&gt;&gt;&gt; geojs</strong></pre>
<p>Our output is as follows:</p>
<pre class="p1">{<br/>    "type": "Point",<br/>    "coordinates": [<br/>        -92,<br/>        37<br/>    ]<br/>}<br/>POINT (-92 37)</pre>
<p>Notice that the <kbd>geojson</kbd> module has an interface for different data types and saves us from setting the type and coordinates attributes manually. Now, imagine if you had a geographic object with hundreds of features. You could programmatically build this data structure instead of building a very large string.</p>
<p>The <kbd>geojson</kbd> module is also the reference implementation for the Python <kbd>geo_interface</kbd> convention. This interface allows cooperating programs to exchange data seamlessly and in a Pythonic way without the programmer explicitly exporting and importing GeoJSON strings. So, if we wanted to feed the point we created with the <kbd>geojson</kbd> module to the Shapely module, we could perform the following command, which reads the <kbd>geojson</kbd> module's point object straight into Shapely, after which we'll export it as WKT:</p>
<pre><strong>&gt;&gt;&gt; from shapely.geometry import asShape</strong><br/><strong>&gt;&gt;&gt; point = asShape(p)</strong><br/><strong>&gt;&gt;&gt; point.wkt</strong><br/><strong>'POINT (-92.0000000000000000 37.0000000000000000)'</strong><br/></pre>
<p>More and more geospatial Python libraries are implementing both the <kbd>geojson</kbd> and <kbd>geo_interface</kbd> functionality, including PyShp, Fiona, Karta, and ArcGIS. Third-party implementations exist for QGIS. </p>
<p>GeoJSON is a simple text format that is human and computer-readable. Now, we'll look at some binary vector formats.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">OGR</h1>
                
            
            
                
<p>We touched on OGR as a way to handle WKT strings, but its real power is as a universal vector library. This book strives for pure Python solutions, but no single library even comes close to the variety of formats that OGR can process.</p>
<p>Let's read a sample point shapefile using the OGR Python API. The sample shapefile can be downloaded as a ZIP file here: <a href="https://github.com/GeospatialPython/Learn/raw/master/point.zip">https://github.com/GeospatialPython/Learn/raw/master/point.zip</a>.</p>
<p>This point shapefile has five points with single digit, positive coordinates. The attributes list the order in which the points were created, making it useful for testing. This simple example will read in the point shapefile and loop through each feature; then, it will print the <em>x</em> and <em>y</em> values of each point, plus the value of the first attribute field:</p>
<pre><strong>&gt;&gt;&gt; import ogr</strong><br/><strong>&gt;&gt;&gt; shp = ogr.Open("point.shp")</strong><br/><strong>&gt;&gt;&gt; layer = shp.GetLayer()</strong><br/><strong>&gt;&gt;&gt; for feature in layer:</strong><br/><strong>... geometry = feature.GetGeometryRef()</strong><br/><strong>... print(geometry.GetX(), geometry.GetY(),</strong><br/><strong>feature.GetField("FIRST_FLD"))</strong><br/><strong>...</strong><br/><strong>1.0 1.0 First</strong><br/><strong>3.0 1.0 Second</strong><br/><strong>4.0 3.0 Third</strong><br/><strong>2.0 2.0 Fourth</strong><br/><strong>0.0 0.0 Appended</strong></pre>
<p>This example is simple, but OGR can become quite verbose as your script becomes more complex. Next, we'll look at a simpler way to deal with shapefiles.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">PyShp</h1>
                
            
            
                
<p>PyShp is a simple, pure Python library that reads and writes shapefiles. It doesn't perform any geometry operations and only uses Python's standard library. It's contained in a single file that's easy to move around, squeeze onto small embedded platforms, and modify. It is also compatible with Python 3. It also implements <kbd>__geo_interface__</kbd>. The PyShp module is available on PyPI.</p>
<p>Let's repeat the previous OGR example with PyShp:</p>
<pre><strong>&gt;&gt;&gt; import shapefile</strong><br/><strong>&gt;&gt;&gt; shp = shapefile.Reader("point.shp")</strong><br/><strong>&gt;&gt;&gt; for feature in shp.shapeRecords():</strong><br/><strong>... point = feature.shape.points[0]</strong><br/><strong>... rec = feature.record[0]</strong><br/><strong>... print(point[0], point[1], rec)</strong><br/><strong>...</strong><br/><strong>1.0 1.0 First</strong><br/><strong>3.0 1.0 Second</strong><br/><strong>4.0 3.0 Third</strong><br/><strong>2.0 2.0 Fourth</strong><br/><strong>0.0 0.0 Appended<br/></strong>//</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">dbfpy</h1>
                
            
            
                
<p>Both OGR and PyShp read and write the <kbd>.dbf</kbd> files because they are part of the shapefile specification. The <kbd>.dbf</kbd> files contain the attributes and fields for the shapefiles. However, both libraries have very basic <kbd>.dbf</kbd> support. Occasionally, you will need to do some heavy-duty DBF work. The <kbd>dbfpy3</kbd> module is a pure Python module dedicated to working with <kbd>.dbf</kbd> files. It is currently hosted on GitHub. You can force <kbd>easy_install</kbd> to find the download by specifying the download file:</p>
<pre><strong>easy_install -f</strong><br/><strong> https://github.com/GeospatialPython/dbfpy3/archive/master.zip</strong></pre>
<p>If you are using <kbd>pip</kbd> to install packages, use the following command:</p>
<pre><strong>pip install</strong><br/><strong> https://github.com/GeospatialPython/dbfpy3/archive/master.zip</strong></pre>
<p>The following shapefile has over 600 <kbd>.dbf</kbd> records representing US Census Bureau tracts, which make it a good sample for trying out <kbd>dbfpy</kbd>: <a href="https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip">https://github.com/GeospatialPython/Learn/raw/master/GIS_CensusTract.zip</a>.</p>
<p>Let's open up the <kbd>.dbf</kbd> file of this shapefile and look at the first record:</p>
<pre><strong>&gt;&gt;&gt; from dbfpy3 import dbf</strong><br/><strong>&gt;&gt;&gt; db = dbf.Dbf("GIS_CensusTract_poly.dbf")</strong><br/><strong>&gt;&gt;&gt; db[0]</strong><br/><strong>GEODB_OID: 4029 (&lt;type 'int'&gt;)</strong><br/><strong>OBJECTID: 4029 (&lt;type 'int'&gt;)</strong><br/><strong>PERMANE0: 61be9239-8f3b-4876-8c4c-0908078bc597 (&lt;type 'str'&gt;)</strong><br/><strong>SOURCE_1: NA (&lt;type 'str'&gt;)</strong><br/><strong>SOURCE_2: 20006 (&lt;type 'str'&gt;)</strong><br/><strong>SOURCE_3: Census Tracts (&lt;type 'str'&gt;)</strong><br/><strong>SOURCE_4: Census Bureau (&lt;type 'str'&gt;)</strong><br/><strong>DATA_SE5: 5 (&lt;type 'str'&gt;)</strong><br/><strong>DISTRIB6: E4 (&lt;type 'str'&gt;)</strong><br/><strong>LOADDATE: 2007-03-13 (&lt;type 'datetime.date'&gt;)</strong><br/><strong>QUALITY: 2 (&lt;type 'str'&gt;)</strong><br/><strong>SCALE: 1 (&lt;type 'str'&gt;)</strong><br/><strong>FCODE: 1734 (&lt;type 'str'&gt;)</strong><br/><strong>STCO_FI7: 22071 (&lt;type 'str'&gt;)</strong><br/><strong>STATE_NAME: 22 (&lt;type 'str'&gt;)</strong><br/><strong>COUNTY_8: 71 (&lt;type 'str'&gt;)</strong><br/><strong>CENSUST9: 22071001734 (&lt;type 'str'&gt;)</strong><br/><strong>POPULAT10: 1760 (&lt;type 'int'&gt;)</strong><br/><strong>AREASQKM: 264.52661934 (&lt;type 'float'&gt;)</strong><br/><strong>GNIS_ID: NA (&lt;type 'str'&gt;)</strong><br/><strong>POPULAT11: 1665 (&lt;type 'int'&gt;)</strong><br/><strong>DB2GSE_12: 264526619.341 (&lt;type 'float'&gt;)</strong><br/><strong>DB2GSE_13: 87406.406192 (&lt;type 'float'&gt;)</strong></pre>
<p>The module quickly and easily gives us both the column names and data values together, as opposed to handling them as separate lists, so that they're easier to manage. Now, let's increment the population field contained in <kbd>POPULAT10</kbd> by <kbd>1</kbd>:</p>
<pre><strong>&gt;&gt;&gt; rec = db[0]</strong><br/><strong>&gt;&gt;&gt; field = rec["POPULAT10"]</strong><br/><strong>&gt;&gt;&gt; rec["POPULAT10"] = field + 1</strong><br/><strong>&gt;&gt;&gt; rec.store()</strong><br/><strong>&gt;&gt;&gt; del rec</strong><br/><strong>&gt;&gt;&gt; db[0]["POPULAT10"]</strong><br/><strong>1761</strong></pre>
<p>Keep in mind that both OGR and PyShp can do this same procedure, but <kbd>dbfp3y</kbd> makes it a little easier if you are only making a lot of changes to the .dbf files.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Shapely</h1>
                
            
            
                
<p>Shapely was mentioned in the <strong>Well-Known Text</strong> (<strong>WKT</strong>) section for its import and exportability. However, its true purpose is as a generic geometry library. Shapely is a high-level, Pythonic interface to the GEOS library for geometric operations. In fact, Shapely intentionally avoids reading or writing files. It relies completely on data import and export from other modules and maintains focus on geometry manipulation.</p>
<p>Let's do a quick Shapely demonstration in which we'll define a single WKT polygon and then import it into Shapely. Then, we'll measure the area. Our computational geometry will consist of buffering that polygon by a measure of five arbitrary units, which will return a new, bigger polygon for which we'll measure the area:</p>
<pre><strong>&gt;&gt;&gt; from shapely import wkt, geometry</strong><br/><strong>&gt;&gt;&gt; wktPoly = "POLYGON((0 0,4 0,4 4,0 4,0 0))"</strong><br/><strong>&gt;&gt;&gt; poly = wkt.loads(wktPoly)</strong><br/><strong>&gt;&gt;&gt; poly.area</strong><br/><strong>16.0</strong><br/><strong>&gt;&gt;&gt; buf = poly.buffer(5.0)</strong><br/><strong>&gt;&gt;&gt; buf.area</strong><br/><strong>174.41371226364848</strong></pre>
<p>We can then perform a difference in the area of the buffer and the original polygon area, as shown here:</p>
<pre><strong>&gt;&gt;&gt; buf.difference(poly).area</strong><br/><strong>158.413712264</strong></pre>
<p>If you can't have pure Python, a Pythonic API as clean as Shapely that packs such a punch is certainly the next best thing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Fiona</h1>
                
            
            
                
<p>The Fiona library provides a simple Python API around the OGR library for data access and nothing more. This approach makes it easy to use and is less verbose than OGR while using Python. Fiona outputs GeoJSON by default. You can find a wheel file for Fiona at <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona">http://www.lfd.uci.edu/~gohlke/pythonlibs/#fiona</a>.</p>
<p>As an example, we'll use the <kbd>GIS_CensusTract_poly.shp</kbd> file from the <kbd>dbfpy</kbd> example we looked at earlier in this chapter.</p>
<p>First, we'll import <kbd>fiona</kbd> and Python's <kbd>pprint</kbd> module to format the output. Then, we'll open the shapefile and check its driver type:</p>
<pre><strong>&gt;&gt;&gt; import fiona</strong><br/><strong>&gt;&gt;&gt; from pprint import pprint</strong><br/><strong>&gt;&gt;&gt; f = fiona.open("GIS_CensusTract_poly.shp")</strong><br/><strong>&gt;&gt;&gt; f.driver</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">ESRI shapefile</h1>
                
            
            
                
<p>Next, we'll check its coordinate reference system and get the data bounding box, as shown here:</p>
<pre><strong>&gt;&gt;&gt; f.crs</strong><br/><strong>{'init': 'epsg:4269'}</strong><br/><strong>&gt;&gt;&gt; f.bounds</strong><br/><strong>(-89.8744162216216, 30.161122135135138, -89.1383837783784,</strong><br/><strong>30.661213864864862)</strong></pre>
<p class="mce-root"/>
<p>Now, we'll view the data schema as <kbd>geojson</kbd> and format it using the <kbd>pprint</kbd> module, as you can see in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; pprint(f.schema)</strong><br/><strong>{'geometry': 'Polygon',</strong><br/><strong>'properties': {'GEODB_OID': 'float:11',</strong><br/><strong>'OBJECTID': 'float:11',</strong><br/><strong>'PERMANE0': 'str:40',</strong><br/><strong>'SOURCE_1': 'str:40',</strong><br/><strong>'SOURCE_2': 'str:40',</strong><br/><strong>'SOURCE_3': 'str:100',</strong><br/><strong>'SOURCE_4': 'str:130',</strong><br/><strong>'DATA_SE5': 'str:46',</strong><br/><strong>'DISTRIB6': 'str:188',</strong><br/><strong>'LOADDATE': 'date',</strong><br/><strong>'QUALITY': 'str:35',</strong><br/><strong>'SCALE': 'str:52',</strong><br/><strong>'FCODE': 'str:38',</strong><br/><strong>'STCO_FI7': 'str:5',</strong><br/><strong>'STATE_NAME': 'str:140',</strong><br/><strong>'COUNTY_8': 'str:60',</strong><br/><strong>'CENSUST9': 'str:20',</strong><br/><strong>'POPULAT10': 'float:11',</strong><br/><strong>'AREASQKM': 'float:31.15',</strong><br/><strong>'GNIS_ID': 'str:10',</strong><br/><strong>'POPULAT11': 'float:11',</strong><br/><strong>'DB2GSE_12': 'float:31.15',</strong><br/><strong>'DB2GSE_13': 'float:31.15'}}</strong></pre>
<p>Next, let's get a count of the number of features:</p>
<pre><strong>&gt;&gt;&gt; len(f)</strong><br/><strong>45</strong></pre>
<p>Finally, we'll print one of the records as formatted GeoJSON, as shown here:</p>
<pre><strong>pprint(f[1])</strong><br/><strong>{'geometry': {'coordinates': [[[(-89.86412366375093,</strong><br/><strong>30.661213864864862), (-89.86418691770497, 30.660764012731285),</strong><br/><strong>(-89.86443391770518, 30.659652012730202),</strong><br/><strong>...</strong><br/><strong>'type': 'MultiPolygon'},</strong><br/><strong>'id': '1',</strong><br/><strong>'properties': {'GEODB_OID': 4360.0,</strong><br/><strong>'OBJECTID': 4360.0,</strong><br/><strong>'PERMANE0': '9a914eef-9249-44cf-a05f-af4b48876c59',</strong><br/><strong>'SOURCE_1': 'NA',</strong><br/><strong>'SOURCE_2': '20006',</strong><br/><strong>...</strong><br/><strong>'DB2GSE_12': 351242560.967882,</strong><br/><strong>'DB2GSE_13': 101775.283967268},</strong><br/><strong>'type': 'Feature'}</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">GDAL</h1>
                
            
            
                
<p>GDAL is the dominant geospatial library for raster data. Its raster capability is so significant that it is a part of virtually every geospatial toolkit in any language, and Python is no exception to this. To see the basics of how GDAL works in Python, download the following sample raster satellite image as a ZIP file and unzip it: <a href="https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip">https://github.com/GeospatialPython/Learn/raw/master/SatImage.zip</a>. Let's open this image and see how many bands it has and how many pixels are present along each axis:</p>
<pre><strong>&gt;&gt;&gt; from osgeo import gdal</strong><br/><strong>&gt;&gt;&gt; raster = gdal.Open("SatImage.tif")</strong><br/><strong>&gt;&gt;&gt; raster.RasterCount</strong><br/><strong>3</strong><br/><strong>&gt;&gt;&gt; raster.RasterXSize</strong><br/><strong>2592</strong><br/><strong>&gt;&gt;&gt; raster.RasterYSize</strong><br/><strong>2693</strong></pre>
<p>By viewing it in OpenEV, we can see that the following image has three bands, 2,592 columns of pixels, and 2,693 rows of pixels:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1831299e-4500-49f1-8ef2-f8ee35f21442.png" style="width:25.58em;height:29.25em;" width="622" height="712"/></p>
<p>GDAL is an extremely fast geospatial raster reader and writer within Python. It can also reproject images quite well in addition to being able to do a few other tricks. However, the true value of GDAL comes from its interaction with the next Python module, which we'll examine now.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">NumPy</h1>
                
            
            
                
<p>NumPy is an extremely fast, multidimensional Python array processor designed specifically for Python and scientific computing but is written in C. It is available via PyPI or as a wheel file (available at <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy">http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy</a>) and can be installed with ease. In addition to its amazing speed, the magic of NumPy includes its interaction with other libraries. NumPy can exchange data with GDAL, Shapely, the <strong>Python Imaging Library</strong> (<strong>PIL</strong>), and many other scientific computing Python libraries in other fields.</p>
<p>As a quick example of NumPy's ability, we'll combine it with GDAL to read in our sample satellite image and then create a histogram of it. The interface between GDAL and NumPy is a GDAL module called <kbd>gdal_array</kbd>, which has NumPy as a dependency. Numeric is the legacy name of the NumPy module. The <kbd>gdal_array</kbd> module imports NumPy. </p>
<p>In the following example, we'll use <kbd>gdal_array</kbd>, which imports NumPy, to read the image in as an array, grab the first band, and save it as a JPEG image:</p>
<pre><strong>&gt;&gt;&gt; from osgeo import gdal_array</strong><br/><strong>&gt;&gt;&gt; srcArray = gdal_array.LoadFile("SatImage.tif")</strong><br/><strong>&gt;&gt;&gt; band1 = srcArray[0]</strong><br/><strong>&gt;&gt;&gt; gdal_array.SaveArray(band1, "band1.jpg", format="JPEG")</strong></pre>
<p>This operation gives us the following grayscale image in OpenEV:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9e69e56e-1fcd-4829-9bbd-e3f7e5e1e51e.png" style="width:27.92em;height:31.75em;" width="625" height="711"/></p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">PIL</h1>
                
            
            
                
<p>PIL was originally developed for remote sensing but has evolved as a general image editing library for Python. Like NumPy, it is written in C for speed but is designed specifically for Python. In addition to image creation and processing, it also has a useful raster drawing module. PIL is also available via PyPI; however, in Python 3, you may want to use the Pillow module, which is an upgraded version of PIL. As you'll see in the following example, we can use a Python try statement to import PIL using two possible variations, depending on how you installed it.</p>
<p>In this example, we'll combine PyShp and PIL to rasterize the <kbd>hancock</kbd> shapefile from the previous examples and save it as an image. We'll use a world to pixel coordinate transformation similar to our SimpleGIS from <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>. We'll create an image to use as a canvas in PIL, and then we'll use the PIL <kbd>ImageDraw</kbd> module to render the polygon. Finally, we'll save it as a PNG image, as you can see in the following lines of code:</p>
<pre><strong>&gt;&gt;&gt; try:</strong><br/><strong>&gt;&gt;&gt; import Image</strong><br/><strong>&gt;&gt;&gt; import ImageDraw</strong><br/><strong>&gt;&gt;&gt; except:</strong><br/><strong>&gt;&gt;&gt; from PIL import Image</strong><br/><strong>&gt;&gt;&gt; from PIL import ImageDraw</strong><br/><strong>&gt;&gt;&gt; import shapefile</strong><br/><strong>&gt;&gt;&gt; r = shapefile.Reader("hancock.shp")</strong><br/><strong>&gt;&gt;&gt; xdist = r.bbox[2] - r.bbox[0]</strong><br/><strong>&gt;&gt;&gt; ydist = r.bbox[3] - r.bbox[1]</strong><br/><strong>&gt;&gt;&gt; iwidth = 400</strong><br/><strong>&gt;&gt;&gt; iheight = 600</strong><br/><strong>&gt;&gt;&gt; xratio = iwidth/xdist</strong><br/><strong>&gt;&gt;&gt; yratio = iheight/ydist</strong><br/><strong>&gt;&gt;&gt; pixels = []</strong><br/><strong>&gt;&gt;&gt; for x,y in r.shapes()[0].points:</strong><br/><strong>... px = int(iwidth - ((r.bbox[2] - x) * xratio))</strong><br/><strong>... py = int((r.bbox[3] - y) * yratio)</strong><br/><strong>... pixels.append((px,py))</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; img = Image.new("RGB", (iwidth, iheight), "white")</strong><br/><strong>&gt;&gt;&gt; draw = ImageDraw.Draw(img)</strong><br/><strong>&gt;&gt;&gt; draw.polygon(pixels, outline="rgb(203, 196, 190)",</strong><br/><strong>fill="rgb(198, 204, 189)")</strong><br/><strong>&gt;&gt;&gt; img.save("hancock.png")</strong></pre>
<p>This example creates the following image:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/fe5e5ae1-a9ff-4c7e-b9e1-fa1da206b56b.png" style="width:18.00em;height:26.58em;" width="420" height="620"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">PNGCanvas</h1>
                
            
            
                
<p>Sometimes, you may find that PIL is overkill for your purposes, or you are not allowed to install PIL because you do not have administrative rights to the machine that you're using to install Python modules that have been created and compiled in C. In those cases, you can usually get away with the lightweight pure Python PNGCanvas module. You can install it using <kbd>easy_install</kbd> or pip.</p>
<p>Using this module, we can repeat the raster shapefile example we performed using PIL but in pure Python, as you can see here:</p>
<pre><strong>&gt;&gt;&gt; import shapefile</strong><br/><strong>&gt;&gt;&gt; import pngcanvas</strong><br/><strong>&gt;&gt;&gt; r = shapefile.Reader("hancock.shp")</strong><br/><strong>&gt;&gt;&gt; xdist = r.bbox[2] - r.bbox[0]</strong><br/><strong>&gt;&gt;&gt; ydist = r.bbox[3] - r.bbox[1]</strong><br/><strong>&gt;&gt;&gt; iwidth = 400</strong><br/><strong>&gt;&gt;&gt; iheight = 600</strong><br/><strong>&gt;&gt;&gt; xratio = iwidth/xdist</strong><br/><strong>&gt;&gt;&gt; yratio = iheight/ydist</strong><br/><strong>&gt;&gt;&gt; pixels = []</strong><br/><strong>&gt;&gt;&gt; for x,y in r.shapes()[0].points:</strong><br/><strong>... px = int(iwidth - ((r.bbox[2] - x) * xratio))</strong><br/><strong>... py = int((r.bbox[3] - y) * yratio)</strong><br/><strong>... pixels.append([px,py])</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; c = pngcanvas.PNGCanvas(iwidth,iheight)</strong><br/><strong>&gt;&gt;&gt; c.polyline(pixels)</strong><br/><strong>&gt;&gt;&gt; f = open("hancock_pngcvs.png", "wb")</strong><br/><strong>&gt;&gt;&gt; f.write(c.dump())</strong><br/><strong>&gt;&gt;&gt; f.close()</strong></pre>
<p>This example gives us a simple outline as PNGCanvas does not have a built-in fill method:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a5135eda-4450-4838-8565-64ba2695193f.png" style="width:17.25em;height:25.50em;" width="420" height="620"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">GeoPandas</h1>
                
            
            
                
<p>Pandas is a high-performance Python data analysis library that can handle large datasets that are tabular (similar to a database), ordered/unordered, labeled matrices, or unlabeled statistical data. GeoPandas is simply a geospatial extension to Pandas that builds upon Shapely, Fiona, PyProj, Matplotlib, and Descartes, all of which must be installed. It allows you to easily perform operations in Python, which would otherwise require a spatial database such as PostGIS. You can download a wheel file for GeoPandas from <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda">http://www.lfd.uci.edu/~gohlke/pythonlibs/#panda</a>.</p>
<p>The following script opens a shapefile and dumps it into GeoJSON. Then, it creates a map with <kbd>matplotlib</kbd>:</p>
<pre><strong>&gt;&gt;&gt; import geopandas</strong><br/><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong><br/><strong>&gt;&gt;&gt; gdf = geopandas.GeoDataFrame</strong><br/><strong>&gt;&gt;&gt; census = gdf.from_file("GIS_CensusTract_poly.shp")</strong><br/><strong>&gt;&gt;&gt; census.plot()</strong><br/><strong>&gt;&gt;&gt; plt.show()</strong></pre>
<p>The following image is the resulting map plot of the previous commands:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/930444cb-0f37-407e-875f-dc4c5398b1ff.png" style="width:36.58em;height:27.92em;" width="1125" height="855"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">PyMySQL</h1>
                
            
            
                
<p>The popular MySQL (available at <a href="http://dev.mysql.com/downloads">http://dev.mysql.com/downloads</a>) database is gradually evolving spatial functions. It has support for OGC geometries and a few spatial functions. It also has a pure Python API available in the PyMySQL library. The limited spatial functions use planar geometry and bounding rectangles as opposed to spherical geometry and shapes. The latest development release of MySQL contains some additional functions that improve this capability.</p>
<p>In the following example, we'll create a database in MySQL called <kbd>spatial_db</kbd>. Then, we'll add a table called <kbd>PLACES</kbd> with a geometry column. Next, we'll add two cities as point locations. Finally, we'll calculate the distance using MySQL's <kbd>ST_Distance</kbd> function and then convert the result from degrees into miles.</p>
<p>First, we will import our <kbd>mysql</kbd> library and set up the database connection:</p>
<pre># Import the python mysql library<br/>import pymysql<br/># Establish a database connection on our local<br/># machine as the root database user.<br/>conn = pymysql.connect(host='localhost', port=3306,<br/>user='root', passwd='', db='mysql')</pre>
<p>Next, we get the database cursor:</p>
<pre># Get the database cursor needed to change<br/># the database<br/>cur = conn.cursor()</pre>
<p>Now, we check if the database already exists, and drop it if it does:</p>
<pre># If the database already exists, delete<br/># it and recreate it either way.<br/>cur.execute("DROP DATABASE IF EXISTS spatial_db")<br/>cur.execute("CREATE DATABASE spatial_db")<br/># Close the cursor and the connection<br/>cur.close()<br/>conn.close()</pre>
<p>Now, we set up a new connection and get a cursor:</p>
<pre># Set up a new connection and cursor<br/>conn = pymysql.connect(host='localhost', port=3306,<br/>user='root', passwd='', db='spatial_db')<br/>cur = conn.cursor()</pre>
<p>Next, we can create our new table and add our fields:</p>
<pre># Create our geospatial table<br/>cur.execute("CREATE TABLE PLACES (id int NOT NULL<br/># Add name and location fields. The location<br/># field is spatially enabled to hold GIS data<br/>AUTO_INCREMENT PRIMARY KEY, Name varchar(50) NOT NULL, location<br/>Geometry NOT NULL)")</pre>
<p>With the fields added, we are ready to insert records for the location of some cities:</p>
<pre># Insert a name and location for the city of<br/># New Orleans<br/>cur.execute("INSERT INTO PLACES (name, location) VALUES ('NEW<br/>ORLEANS', GeomFromText('POINT(30.03 90.03)'))")<br/># Insert a name and location for the city of<br/># Memphis.<br/>cur.execute("INSERT INTO PLACES (name, location) VALUES<br/>('MEMPHIS', GeomFromText('POINT(35.05 90.00)'))")</pre>
<p>Then, we can commit changes to the database:</p>
<pre># Commit the changes to the database<br/>conn.commit()</pre>
<p>Now, we can query the database! First, we'll get a list of all of the point locations:</p>
<pre># Now let's read the data. Select all of<br/># the point locations from the database.<br/>cur.execute("SELECT AsText(location) FROM PLACES")</pre>
<p>Now, we'll extract the two points from the query results:</p>
<pre># We know there's only two points, so we'll<br/># just parse them.<br/>p1, p2 = [p[0] for p in cur.fetchall()]</pre>
<p>Before we can measure the distance, we need to convert the point listings into geospatial geometries:</p>
<pre># Now we'll convert the data<br/># to geometries to measure the distance<br/># between the two cities<br/>cur.execute("SET @p1 = ST_GeomFromText('{}')".format(p1))<br/>cur.execute("SET @p2 = ST_GeomFromText('{}')".format(p2))</pre>
<p class="mce-root"/>
<p>Finally, we can use the <kbd>Distance</kbd> stored procedure to measure the distance between the two geometries:</p>
<pre># Now we do the measurement function which<br/># is also a database query.<br/>cur.execute("SELECT ST_Distance(@p1, @p2)")<br/>d = float(cur.fetchone()[0])<br/># Print the distance as a formatted<br/># string object.<br/>print("{:.2f} miles from New Orleans to Memphis".format(d *<br/>70))<br/>cur.close()<br/>conn.close()</pre>
<p>The output is as follows: </p>
<pre><strong>351.41 miles from New Orleans to Memphis</strong></pre>
<div><p class="mce-root">There are other spatial database options available, including PostGIS and SpatiaLite; however, Python 3 support for these spatial engines is developmental at best. You can access PostGIS and MySQL through the OGR library; however, MySQL support is limited.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">PyFPDF</h1>
                
            
            
                
<p>The pure Python PyFPDF library is a lightweight way to create PDFs, including maps. Because the PDF format is a widely used standard, PDFs are commonly used to distribute maps. You can install it via PyPI as <kbd>fpdf</kbd>. The official name of the software is PyFPDF because it is a part of the PHP language module called <kbd>fpdf</kbd>. This module uses a concept called a cell to lay items out at specific locations on a page. As a quick example, we'll import the <kbd>hancock.png</kbd> image we created from the PIL example into a PDF called <kbd>map.pdf</kbd> to create a simple PDF map. The map will have the header text at the top that says Hancock County Boundary, followed by the map image:</p>
<pre><strong>&gt;&gt;&gt; import fpdf</strong><br/><strong>&gt;&gt;&gt; # PDF constructor:</strong><br/><strong>&gt;&gt;&gt; # Portrait, millimeter units, A4 page size</strong><br/><strong>&gt;&gt;&gt; pdf=fpdf.FPDF("P", "mm", "A4")</strong><br/><strong>&gt;&gt;&gt; # create a new page</strong><br/><strong>&gt;&gt;&gt; pdf.add_page()</strong><br/><strong>&gt;&gt;&gt; # Set font: arial, bold, size 20</strong><br/><strong>&gt;&gt;&gt; pdf.set_font('Arial','B',20)</strong><br/><strong>&gt;&gt;&gt; # Layout cell: 160 x 25mm, title, no border, centered</strong><br/><strong>&gt;&gt;&gt; pdf.cell(160,25,'Hancock County Boundary', \</strong><br/><strong>&gt;&gt;&gt; border=0, align="C")</strong><br/><strong>&gt;&gt;&gt; # Write the image specifying the size</strong><br/><strong>&gt;&gt;&gt; pdf.image("hancock.png",25,50,110,160)</strong><br/><strong>&gt;&gt;&gt; # Save the file: filename, F = to file System</strong><br/><strong>&gt;&gt;&gt; pdf.output('map.pdf','F')</strong></pre>
<p>If you open the PDF file named <kbd>map.pdf</kbd> in Adobe Acrobat Reader or another PDF reader such as Sumatra PDF, you'll see that the image is now centered on an A4 page. Geospatial products are often included as part of larger reports, and the PyFPDF module simplifies automatically generating reports as PDFs.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Geospatial PDF</h1>
                
            
            
                
<p class="mce-root">The <strong>Portable Document Format</strong>, or <strong>PDF</strong>, is a file format for storing and presenting digitally-formatted text and images in a cross-platform and application-independent way. PDF is a widely used document format that has also been extended to store geospatial information.</p>
<p class="mce-root">The PDF specification, starting with version 1.7, includes extensions for geospatial PDFs that map portions of the document to a physical space, also known as georeferencing. You can create points, lines, or polygons as geospatial geometries, which can also have attributes.</p>
<p class="mce-root">There are two methods for encoding geospatial information within a PDF. A company named TerraGo created a specification that has been adopted by the Open Geospatial Consortium as a best practice which is not a standard. That format is known as <strong>GeoPDF</strong>. The extensions that were proposed by Adobe Systems, which created the PDF specification known as ISO 32000, are currently being incorporated into the 2.0 version of the specification.</p>
<p class="mce-root">The geospatial PDF products by TerraGo conform to the OGC best practice document and the Adobe PDF extension. But TerraGo goes beyond those features to include layers and other GIS functionality. However, you must use TerraGo's plugins for Adobe Acrobat or other software to access that functionality. At a minimum, TerraGo supports the features that are needed to at least display in any PDF software.</p>
<p class="mce-root">In Python, there is a library called <kbd>geopdf</kbd> which has nothing to do with TerraGo but does support the OGC best practice. This library was originally developed by Tyler Garner of Prominent Edge (<a href="https://prominentedge.com/">https://prominentedge.com/</a>) for Python 2. It has been ported to Python 3.</p>
<p class="mce-root">Installing <kbd>geopdf</kbd> from GitHub is as simple as running the following:</p>
<pre class="mce-root"><strong>pip install https://github.com/GeospatialPython/geopdf-py3/archive/master.zip</strong></pre>
<p class="mce-root">The following example recreates the map we created in <a href="6b5bd08a-170c-4471-a3f3-d79d5b91f017.xhtml">Chapter 1</a>, <em>Learning about Geospatial Analysis with Python</em>, in the <em>Simple GIS</em> section as a geospatial PDF. The <kbd>geopdf</kbd> library relies on the Python ReportLab PDF library. The steps we will need to execute are as follows:</p>
<ol>
<li class="mce-root">Create a PDF drawing canvas.</li>
<li class="mce-root">Draw a rectangle for the state of Colorado.</li>
<li class="mce-root">Set up a function to convert map coordinates into screen coordinates.</li>
<li class="mce-root">Draw and label the cities and populations.</li>
<li class="mce-root">Register the corners of the state as geospatial PDF coordinates that georeference the entire map.</li>
</ol>
<p>The Python code's comments explain what's happening in each step:</p>
<pre class="mce-root"># Import the geopdf library<br/>from geopdf import GeoCanvas<br/># Import the necessary Reportlab modules<br/>from reportlab.pdfbase.pdfdoc import PDFString, PDFArray<br/># Create a canvas with a name for our pdf.<br/>canvas = GeoCanvas('SimpleGIS.pdf')<br/># Draw a rectangle to represent the State boundary<br/>canvas.rect(100, 400, 400, 250, stroke=1)<br/># DATA MODEL<br/># All layers will have a name, 1+ points, and population count<br/>NAME = 0<br/>POINTS = 1<br/>POP = 2<br/># Create the state layer<br/>state = ["COLORADO", [[-109, 37], [-109, 41], [-102, 41], [-102, 37]], 5187582]<br/># Cities layer list<br/># city = [name, [point], population]<br/>cities = []<br/># Add Denver<br/>cities.append(["DENVER", [-104.98, 39.74], 634265])<br/># Add Boulder<br/>cities.append(["BOULDER", [-105.27, 40.02], 98889])<br/># Add Durango<br/>cities.append(["DURANGO", [-107.88, 37.28], 17069])<br/># MAP GRAPHICS RENDERING<br/>map_width = 400<br/>map_height = 250<br/># State Bounding Box<br/># Use Python min/max function to get state bounding box<br/>minx = 180<br/>maxx = -180<br/>miny = 90<br/>maxy = -90<br/>for x, y in state[POINTS]:<br/>    if x &lt; minx:<br/>        minx = x<br/>    elif x &gt; maxx:<br/>        maxx = x<br/>    if y &lt; miny:<br/>        miny = y<br/>    elif y &gt; maxy:<br/>        maxy = y<br/># Get earth distance on each axis<br/>dist_x = maxx - minx<br/>dist_y = maxy - miny<br/># Scaling ratio each axis<br/># to map points from world to screen<br/>x_ratio = map_width / dist_x<br/>y_ratio = map_height / dist_y<br/>def convert(point):<br/>    """Convert lat/lon to screen coordinates"""<br/>    lon = point[0]<br/>    lat = point[1]<br/>    x = map_width - ((maxx - lon) * x_ratio)<br/>    y = map_height - ((maxy - lat) * y_ratio)<br/>    # Python turtle graphics start in the middle of   <br/>    # the screen so we must offset the points so they     <br/>    # are centered<br/>    x = x + 100<br/>    y = y + 400<br/>    return [x, y]<br/><br/># Set up our map labels<br/>canvas.setFont("Helvetica", 20)<br/>canvas.drawString(250, 500, "COLORADO")<br/><br/># Use smaller text for cities<br/>canvas.setFont("Helvetica", 8)<br/><br/># Draw points and label the cities<br/>for city in cities:<br/>pixel = convert(city[POINTS])<br/>print(pixel)<br/><br/># Place a point for the city<br/>canvas.circle(pixel[0], pixel[1], 5, stroke=1, fill=1)  <br/><br/># Label the city<br/>canvas.drawString(pixel[0] + 10, pixel[1], city[NAME] + ", Population: " + str(city[POP]))<br/><br/># A series of registration point pairs (pixel x, <br/># pixel y, x, y) to spatially enable the PDF. We only <br/># need to do the state boundary.<br/># The cities will be contained with in it.<br/>registration = PDFArray([<br/>PDFArray(map(PDFString, ['100', '400', '{}'.format(minx), '{}'.format(maxy)])),<br/>PDFArray(map(PDFString, ['500', '400', '{}'.format(maxx), '{}'.format(maxy)])),<br/>PDFArray(map(PDFString, ['100', '150', '{}'.format(minx), '{}'.format(miny)])),<br/>PDFArray(map(PDFString, ['500', '150', '{}'.format(maxx), '{}'.format(miny)]))<br/>])<br/># Add the map registration<br/>canvas.addGeo(Registration=registration)<br/># Save our geopdf<br/>canvas.save()</pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Rasterio</h1>
                
            
            
                
<p class="mce-root">The GDAL library we introduced earlier in this chapter is extremely powerful, but it wasn't designed for Python. The <kbd>rasterio</kbd> library solves that problem by wrapping GDAL in a very simple, clean Pythonic API for raster data operations.</p>
<p class="mce-root">This example uses the satellite image from the GDAL example in this chapter. We'll open the image and get some metadata, like the following </p>
<pre class="mce-root"><strong>&gt;&gt;&gt; import rasterio</strong><br/><strong>&gt;&gt;&gt; ds = rasterio.open("SatImage.tif")</strong><br/><strong>&gt;&gt;&gt; ds.name</strong><br/><strong>'SatImage.tif'</strong><br/><strong>&gt;&gt;&gt; ds.count</strong><br/><strong>3</strong><br/><strong>&gt;&gt;&gt; ds.width</strong><br/><strong>2592</strong><br/><strong>&gt;&gt;&gt; ds.height</strong><br/><strong>2693</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">OSMnx</h1>
                
            
            
                
<p class="mce-root">The <kbd>osmnx</kbd> library combines <strong>Open Street Map</strong> (<strong>OSM</strong>) and the powerful NetworkX library to manage street networks used for routing. This library has dozens of dependencies which it rolls up to do all of the complex steps of downloading, analyzing, and visualizing street networks.</p>
<p class="mce-root">You can try to install <kbd>osmnx</kbd> using <kbd>pip</kbd>:</p>
<pre class="mce-root"><strong>pip install osmnx</strong></pre>
<p class="mce-root">However, you may run into some installation issues due to the dependencies. In that case, it's easier to use the Conda system, which we'll introduce later in this chapter.</p>
<p class="mce-root">The following example uses <kbd>osmnx</kbd> to download street data from OSM for a city, creates a street network from it, and calculates some basic statistics:</p>
<pre class="mce-root"><strong>&gt;&gt;&gt; import osmnx as ox</strong><br/><strong>&gt;&gt;&gt; G = ox.graph_from_place('Bay Saint Louis, MS , USA', network_type='drive')</strong><br/><strong>&gt;&gt;&gt; stats = ox.basic_stats(G)</strong><br/><strong>&gt;&gt;&gt; stats["street_length_avg"]</strong><br/><strong>172.1468804611654</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Jupyter</h1>
                
            
            
                
<p class="mce-root">The Jupyter project is something you should be aware of when working with geospatial or other scientific data. The Jupyter Notebook app creates and displays notebook documents in a web browser that are human-readable and machine-executable code and data. It's great for sharing tutorials for software and has become very common in the geospatial Python world.</p>
<p class="mce-root">You can find a good introduction for Jupyter Notebooks and Python here: <a href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html">https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/what_is_jupyter.html</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Conda</h1>
                
            
            
                
<p class="mce-root">Conda is an open source package management system that makes installing and updating complex libraries easier. It works with several languages, including Python. Conda is very useful for setting up libraries and testing them so that we can try out new things in a development environment. It's usually better to custom configure production environments, but Conda is a great way to prototype new ideas.</p>
<p class="mce-root">You can get started with Conda at <a href="https://conda.io/en/latest/">https://conda.io/en/latest/</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we surveyed the Python-specific tools for geospatial analysis. Many of these tools included bindings to the libraries we discussed in <a href="a5e439d1-e7fd-46b4-8fd3-8f811bfe73e4.xhtml">Chapter 3</a>, <em>The Geospatial Technology Landscape</em>, for best-of-breed solutions for specific operations such as GDAL's raster access functions. We also included pure Python libraries as much as possible and will continue to include pure Python algorithms as we work through the upcoming chapters.</p>
<p>In the next chapter, we'll begin applying all of these tools for GIS analysis.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The following links will allow you to explore the topics in this chapter further. The first link is about the XPath query language, which we used to filter XML elements using Elementree. The second link is the documentation for the Python string library, which will be critical throughout this book for manipulating data. Third, we have the <kbd>lxml</kbd> library, one of the more powerful and fast XML libraries. Finally, we have Conda, which provides a comprehensive, easy-to-use framework for scientific operations in Python, including geospatial technology:</p>
<ul>
<li>For more information on XPath, check out the following link: <a href="http://www.w3schools.com/xsl/xpath_intro.asp">http://www.w3schools.com/xsl/xpath_intro.asp</a></li>
<li>For more details on the Python <kbd>string</kbd> module, check out the following link: <a href="https://docs.python.org/3.4/library/string.html">https://docs.python.org/3.4/library/string.html</a></li>
<li>The documentation on LXML can be found at the following link: <a href="http://lxml.de/">http://lxml.de/</a></li>
<li>You can learn more about Conda at the following link: <a href="https://conda.io/en/latest/">https://conda.io/en/latest/</a></li>
</ul>


            

            
        
    </div>



  </body></html>