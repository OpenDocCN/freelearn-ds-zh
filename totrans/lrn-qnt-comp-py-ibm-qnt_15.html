<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer989" class="Basic-Text-Frame">
    <h1 id="_idParaDest-228" class="chapterTitle">Appendix B: Assessments</h1>
    <h1 id="_idParaDest-229" class="heading-1">Chapter 1 – Exploring the IBM Quantum Tools</h1>
    <h2 id="_idParaDest-230" class="heading-2">Question 1</h2>
    <p class="normal">Which Application contains your API token?</p>
    <h2 id="_idParaDest-231" class="heading-2">Answer</h2>
    <p class="normal">There are two places to obtain your API token. The first is the <strong class="keyWord">Account settings</strong> view, where the API token is available and where you can regenerate a different token if needed. The other is on the main dashboard.</p>
    <h2 id="_idParaDest-232" class="heading-2">Question 2</h2>
    <p class="normal">Which device in your resources list has the fewest qubits?</p>
    <h2 id="_idParaDest-233" class="heading-2">Answer</h2>
    <p class="normal">The availability of the device with the fewest qubits will vary based on the quantum devices available. However, at the time of writing, there are systems with no less than 127 qubits. The next systems will be of sizes 133 qubits and higher. This is due to the recent shift to the IBM Quantum Platform to provide quantum utility systems (over 100 qubits).</p>
    <h2 id="_idParaDest-234" class="heading-2">Question 3</h2>
    <p class="normal">Which Application would provide you a qubit map of a quantum system?</p>
    <h2 id="_idParaDest-235" class="heading-2">Answer</h2>
    <p class="normal">The<strong class="keyWord"> IBM Quantum Platform</strong> provides the <strong class="screenText">Compute Resources</strong> application view, which displays all available quantum systems.</p>
    <h1 id="_idParaDest-236" class="heading-1">Chapter 2 – Creating Quantum Circuits with IBM Quantum Composer</h1>
    <h2 id="_idParaDest-237" class="heading-2">Question 1</h2>
    <p class="normal">From the Composer, where would you find the time it took to run your circuit on a quantum computer?</p>
    <h2 id="_idParaDest-238" class="heading-2">Answer</h2>
    <p class="normal">You would find it in the <strong class="screenText">Status Timeline</strong> view of the <strong class="screenText">Composer Jobs</strong> view.</p>
    <h2 id="_idParaDest-239" class="heading-2">Question 2</h2>
    <p class="normal">How would you remove or add a qubit to your circuit on the composer?</p>
    <h2 id="_idParaDest-240" class="heading-2">Answer</h2>
    <p class="normal">You would click on a qubit and select either the <strong class="screenText">+</strong> or the trashcan icon to add or remove a qubit from the circuit, respectively.</p>
    <h2 id="_idParaDest-241" class="heading-2">Question 3</h2>
    <p class="normal">On which view would you specify which quantum system to run your circuit?</p>
    <h2 id="_idParaDest-242" class="heading-2">Answer</h2>
    <p class="normal">You would use the <strong class="screenText">Setup and run</strong> view, which is accessible from the <strong class="screenText">Composer</strong> view, to select the system.</p>
    <h2 id="_idParaDest-243" class="heading-2">Question 4</h2>
    <p class="normal">Which sphere would be ideal to view the quantum state of three qubits in a single sphere?</p>
    <h2 id="_idParaDest-244" class="heading-2">Answer</h2>
    <p class="normal">You would use the qsphere to represent multiple quantum states in a single sphere.</p>
    <h1 id="_idParaDest-245" class="heading-1">Chapter 3 – Introducing and Installing Qiskit</h1>
    <h2 id="_idParaDest-246" class="heading-2">Question 1</h2>
    <p class="normal">In your own words, describe the difference between a kernel developer and an application developer.</p>
    <h2 id="_idParaDest-247" class="heading-2">Answer</h2>
    <p class="normal">In general, the kernel developer can be seen as a developer that creates the specific circuit for a quantum system. It is analogous to a classical assembly developer. An application developer would integrate a quantum algorithm into a classical application or workflow.</p>
    <h2 id="_idParaDest-248" class="heading-2">Question 2</h2>
    <p class="normal">If you wanted to obtain the unitary matrix of a circuit, which simulator would provide the unitary matrix result?</p>
    <h2 id="_idParaDest-249" class="heading-2">Answer</h2>
    <p class="normal">The unitary simulator from the Qiskit Aer library.</p>
    <h2 id="_idParaDest-250" class="heading-2">Question 3</h2>
    <p class="normal">Can you name and describe in your own words each of the five simulator categories that are provided by Aer?</p>
    <h2 id="_idParaDest-251" class="heading-2">Answer</h2>
    <p class="normal">The details of each are described in the chapter; this question is to check that you have an intuitive understanding of each simulator. For example, a state vector simulator does not need a measurement as it only computes the final state of the circuit.</p>
    <h2 id="_idParaDest-252" class="heading-2">Question 4</h2>
    <p class="normal">Which module would you need to import to plot a histogram?</p>
    <h2 id="_idParaDest-253" class="heading-2">Answer</h2>
    <p class="normal">The Qiskit Visualization module.</p>
    <h1 id="_idParaDest-254" class="heading-1">Chapter 4 – Understanding Basic Quantum Computing Principles</h1>
    <h2 id="_idParaDest-255" class="heading-2">Question 1</h2>
    <p class="normal">How would you create a circuit that entangles two qubits where each qubit is different (that is, <strong class="keyWord">01</strong>, <strong class="keyWord">10</strong>)?</p>
    <h2 id="_idParaDest-256" class="heading-2">Answer</h2>
    <p class="normal">We can use the following code to create a circuit that entangles two qubits:</p>
    <pre class="programlisting code"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
qc.h(<span class="hljs-number">0</span>)
qc.x(<span class="hljs-number">1</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
qc.measure([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])
qc.draw()
</code></pre>
    <h2 id="_idParaDest-257" class="heading-2">Question 2</h2>
    <p class="normal">Create a circuit with a multi-qubit gate, such as a controlled-Hadamard gate.</p>
    <h2 id="_idParaDest-258" class="heading-2">Answer</h2>
    <p class="normal">The circuit will just need to be ensured to have two qubits and include a controlled Hadamard gate (<strong class="screenText">ch</strong>). In the following example, the first qubit is the control and the second qubit is the target. We add a Hadamard gate to the control qubit to ensure we will get either a <code class="inlineCode">0</code> or <code class="inlineCode">1</code>; otherwise, the control will never be set:</p>
    <pre class="programlisting code"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
qc.h(<span class="hljs-number">0</span>)
qc.ch(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
qc.draw()
</code></pre>
    <h2 id="_idParaDest-259" class="heading-2">Question 3</h2>
    <p class="normal">Create all 4 Bell states in a circuit.</p>
    <h2 id="_idParaDest-260" class="heading-2">Answer</h2>
    <p class="normal">The circuit will just need to have two qubits and include a controlled-X gate (<code class="inlineCode">cx</code>), where the first argument is the control and the second is the target. In the following example, the first qubit is the control and the second qubit is the target. We add a Hadamard gate to the control qubit to ensure we will get either a <code class="inlineCode">0</code> or <code class="inlineCode">1</code>; otherwise, the control will never be set:</p>
    <pre class="programlisting gen"><code class="hljs">qc = QuantumCircuit(2,2)
qc.h(0)
qc.cx(0,1)
qc.draw()
</code></pre>
    <p class="normal">Subsequent circuits will just alter the direction of the <strong class="keyWord">cx</strong> gate’s control and target, and ensure that the Hadamard gate is on the same qubit as the control.</p>
    <h2 id="_idParaDest-261" class="heading-2">Question 4</h2>
    <p class="normal">What are the three quantum computation principles?</p>
    <h2 id="_idParaDest-262" class="heading-2">Answer</h2>
    <p class="normal">The three quantum computation principles are superposition, interference, and entanglement. Superposition and interference are described in classical physics, and entanglement is described in quantum physics.</p>
    <h1 id="_idParaDest-263" class="heading-1">Chapter 5 – Understanding the Qubit</h1>
    <h2 id="_idParaDest-264" class="heading-2">Question 1</h2>
    <p class="normal">Which would provide visual information about the phase of a qubit—the Bloch sphere or the qsphere?</p>
    <h2 id="_idParaDest-265" class="heading-2">Answer</h2>
    <p class="normal">Both do. The Qiskit sphere (q-sphere) includes a checkbox to visualize the phase information. The Bloch sphere illustrates the phase by the position of the vector when it is out of phase, which is to say it is rotated about the <em class="italic">z</em> axis.</p>
    <h2 id="_idParaDest-266" class="heading-2">Question 2</h2>
    <p class="normal">Can you visualize multiple qubits on the Bloch sphere? If not, then describe why you wouldn’t.</p>
    <h2 id="_idParaDest-267" class="heading-2">Answer</h2>
    <p class="normal">No, we can’t visualize multi-qubits on the Bloch sphere as we can on the qsphere. The Bloch sphere is generally leveraged to illustrate a single qubit vector position for a given state, whereas the qsphere includes the phase. To represent multiple qubits using the Bloch sphere, you will need to have one Bloch sphere for each qubit.</p>
    <h2 id="_idParaDest-268" class="heading-2">Question 3</h2>
    <p class="normal">Write out the tensor product of three-qubit states in all forms.</p>
    <h2 id="_idParaDest-269" class="heading-2">Answer</h2>
    <p class="normal">The resulting basis states for a three-qubit system are <img src="../Images/B18420_15_001.png" alt="" width="365" height="22"/> <a id="_idIndexMarker1527"/>.</p>
    <h2 id="_idParaDest-270" class="heading-2">Question 4</h2>
    <p class="normal">What is the probability amplitude of a three-qubit system?</p>
    <h2 id="_idParaDest-271" class="heading-2">Answer</h2>
    <p class="normal">The amplitude of a three-qubit system is <img src="../Images/B18420_15_002.png" alt="" width="27" height="35"/><a id="_idIndexMarker1528"/>, where <em class="italic">n</em> is the number of qubits, which results in <img src="../Images/B18420_15_003.png" alt="" width="69" height="35"/><a id="_idIndexMarker1529"/>.</p>
    <h1 id="_idParaDest-272" class="heading-1">Chapter 6 – Understanding Quantum Logic Gates</h1>
    <h2 id="_idParaDest-273" class="heading-2">Question 1</h2>
    <p class="normal">For the multi-qubit gates, try flipping the Source and Target. Do you see a difference when you decompose the circuit?</p>
    <h2 id="_idParaDest-274" class="heading-2">Answer</h2>
    <p class="normal">No, there is no difference that can be seen, only that the source is now assigned to the opposite qubits.</p>
    <h2 id="_idParaDest-275" class="heading-2">Question 2</h2>
    <p class="normal">Decompose all the gates for both single- and multi-qubit circuits. What do you notice about how the universal gates are constructed?</p>
    <h2 id="_idParaDest-276" class="heading-2">Answer</h2>
    <p class="normal">The single gates are now displayed by their respective basis gate, including rotation values, if any. Multi-qubit gates, such as the Toffoli gate, are also broken down into specific gates that are used to construct the operation of the Toffoli gate between the assigned qubits.</p>
    <h2 id="_idParaDest-277" class="heading-2">Question 3</h2>
    <p class="normal">Implement the Toffoli gate where the target is the center qubit of a three-qubit circuit.</p>
    <h2 id="_idParaDest-278" class="heading-2">Answer</h2>
    <p class="normal">Use the following code to implement the Toffoli gate where the target is the center qubit of a three-qubit circuit:</p>
    <pre class="programlisting code"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">3</span>)
qc.ccx(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)
qc.draw()
</code></pre>
    <h2 id="_idParaDest-279" class="heading-2">Question 4</h2>
    <p class="normal">Decompose the Toffoli gate. How many gates in total are used to construct it?</p>
    <h2 id="_idParaDest-280" class="heading-2">Answer</h2>
    <p class="normal">When decomposing the Toffoli gate down to Hadamard, T, T dagger, and CX gates, there are a total of 15 gates, and it runs 11 operations deep. It’s good to note that the depth might change if a more efficient way of composing the Toffoli gate is developed.</p>
    <h2 id="_idParaDest-281" class="heading-2">Question 5</h2>
    <p class="normal">Apply the Toffoli gate along with a Hadamard gate to a state vector simulator and compare the results to that from the Sampler primitive. What differences do you see and why?</p>
    <h2 id="_idParaDest-282" class="heading-2">Answer</h2>
    <p class="normal">The Sampler primitive, since it runs 1024 shots by default, will produce a result of approximately 50% <code class="inlineCode">000</code> and 50% <code class="inlineCode">001</code>, assuming placement of the Hadamard gate is in the first qubit. On the other hand, the state vector simulator, which only runs a single shot, will either result in the state <code class="inlineCode">000</code> or <code class="inlineCode">001</code>; the results of which will vary depending on the qubit in which you placed the Hadamard gate.</p>
    <h2 id="_idParaDest-283" class="heading-2">Question 6</h2>
    <p class="normal">If you wanted to sort three qubits in the opposite direction, which gates would you use and in which order?</p>
    <h2 id="_idParaDest-284" class="heading-2">Answer</h2>
    <p class="normal">You can use the <code class="inlineCode">swap</code> gate to switch the value of each qubit from one qubit to another (for an example of two qubits):</p>
    <pre class="programlisting code"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">2</span>)
qc.x(<span class="hljs-number">0</span>)
<span class="hljs-comment"># current state is '01'</span>
qc.swap(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
<span class="hljs-comment"># current state is reversed, '10'</span>
</code></pre>
    <h1 id="_idParaDest-285" class="heading-1">Chapter 7 – Programming with Qiskit</h1>
    <h2 id="_idParaDest-286" class="heading-2">Question 1</h2>
    <p class="normal">Construct a random quantum circuit with a width of <code class="inlineCode">4</code> and a depth of <code class="inlineCode">9</code>.</p>
    <h2 id="_idParaDest-287" class="heading-2">Answer</h2>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> qiskit.circuit.random <span class="hljs-keyword">import</span> random_circuit
<span class="hljs-comment">#Circuit with a width = 4, a depth = 9</span>
qc = random_circuit(<span class="hljs-number">4</span>, <span class="hljs-number">9</span>, measure=<span class="hljs-literal">True</span>)
</code></pre>
    <h2 id="_idParaDest-288" class="heading-2">Question 2</h2>
    <p class="normal">Create another random quantum circuit with the same width as the circuit you created in <em class="italic">Question 1</em> and concatenate it so that it is added before the random quantum circuit you created.</p>
    <h2 id="_idParaDest-289" class="heading-2">Answer</h2>
    <pre class="programlisting code"><code class="hljs-code">qc1 = random_circuit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)
qc_combined = qc.compose(qc1, [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], front=<span class="hljs-keyword">True</span>)
</code></pre>
    <h2 id="_idParaDest-290" class="heading-2">Question 3</h2>
    <p class="normal">Print the circuit properties of the concatenated quantum circuit from <em class="italic">Question 3</em> and specify the total number of operators, not including any measurement operators.</p>
    <h2 id="_idParaDest-291" class="heading-2">Answer</h2>
    <pre class="programlisting gen"><code class="hljs">qc_combined.draw()
qc_combined.count_ops()
</code></pre>
    <h2 id="_idParaDest-292" class="heading-2">Question 4</h2>
    <p class="normal">Create a circuit with a parameterized R<sub class="subscript">Y</sub> gate that would rotate by an angle of <img src="../Images/B18420_07_009.png" alt="" width="31" height="25"/><a id="_idIndexMarker1530"/>.</p>
    <h2 id="_idParaDest-293" class="heading-2">Answer</h2>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> qiskit.circuit <span class="hljs-keyword">import</span> Parameter
param_theta = Parameter(<span class="hljs-string">'Ɵ'</span>)
qc = QuantumCircuit(<span class="hljs-number">2</span>)
qc.rz(param_theta,<span class="hljs-number">0</span>)
qc = qc.assign_parameters({param_theta: np.pi/<span class="hljs-number">2</span>})
qc.draw()
</code></pre>
    <h1 id="_idParaDest-294" class="heading-1">Chapter 8 – Optimizing and Visualizing Quantum Circuits</h1>
    <h2 id="_idParaDest-295" class="heading-2">Question 1</h2>
    <p class="normal">Can you name two components of the transpiler?</p>
    <h2 id="_idParaDest-296" class="heading-2">Answer</h2>
    <p class="normal"><strong class="keyWord">Pass</strong> and <strong class="keyWord">PassManager</strong>.</p>
    <h2 id="_idParaDest-297" class="heading-2">Question 2</h2>
    <p class="normal">Which component allows you to specify the passes to use?</p>
    <h2 id="_idParaDest-298" class="heading-2">Answer</h2>
    <p class="normal"><strong class="keyWord">PassManager</strong> is used to specify which passes are used and which passes can communicate with other passes.</p>
    <h2 id="_idParaDest-299" class="heading-2">Question 3</h2>
    <p class="normal">What is the default <code class="inlineCode">optimization_level</code> value when running the transpile() function?</p>
    <h2 id="_idParaDest-300" class="heading-2">Answer</h2>
    <p class="normal">Optimization level 1.</p>
    <h2 id="_idParaDest-301" class="heading-2">Question 4</h2>
    <p class="normal">Name the three Layout Selection Passes.</p>
    <h2 id="_idParaDest-302" class="heading-2">Answer</h2>
    <p class="normal">Trivial, Dense, and Sabre.</p>
    <h1 id="_idParaDest-303" class="heading-1">Chapter 9 – Simulating Quantum Systems and Noise Models</h1>
    <h2 id="_idParaDest-304" class="heading-2">Question 1</h2>
    <p class="normal">Can you list all the simulators found in the Qiskit Aer module?</p>
    <h2 id="_idParaDest-305" class="heading-2">Answer</h2>
    <p class="normal">The list of simulators can be generated using the <code class="inlineCode">Aer.backends()</code> function.</p>
    <h2 id="_idParaDest-306" class="heading-2">Question 2</h2>
    <p class="normal">Create a qsphere representation of a qubit on the negative <em class="italic">Y</em> axis, creating the state <img src="../Images/B18420_15_005.png" alt="" width="50" height="38"/><a id="_idIndexMarker1531"/>, using only a single Hadamard gate along with the phase gates.</p>
    <h2 id="_idParaDest-307" class="heading-2">Answer</h2>
    <p class="normal">In order to accomplish this, you will need to set the qubit in a superposition state. This can be done using the Hadamard gate (H), which will place the qubit in the state <img src="../Images/B18420_15_006.png" alt="" width="46" height="38"/><a id="_idIndexMarker1532"/>. After that, we will have to run a phase shift from the <img src="../Images/B18420_09_050.png" alt="" width="25" height="25"/><a id="_idIndexMarker1533"/> state to the <img src="../Images/B18420_15_008.png" alt="" width="50" height="38"/><a id="_idIndexMarker1534"/> state, which would mean we need a phase gate to shift the state by a phase of <img src="../Images/B18420_15_009.png" alt="" width="46" height="25"/><a id="_idIndexMarker1535"/>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">qc = QuantumCircuit(<span class="hljs-number">1</span>)
qc.h(<span class="hljs-number">0</span>)
qc.sdg(<span class="hljs-number">0</span>)
simulator = Aer.get_backend(<span class="hljs-string">'</span><span class="hljs-string">statevector_simulator'</span>)
transpiled_qc = transpile(qc, backend=simulator)
result = simulator.run(transpiled_qc).result()
statevector = result.get_statevector(transpiled_qc)
statevector
</code></pre>
    <h2 id="_idParaDest-308" class="heading-2">Question 3</h2>
    <p class="normal">When initializing a set of qubits in a circuit, what must the total probability across all states be?</p>
    <h2 id="_idParaDest-309" class="heading-2">Answer</h2>
    <p class="normal">The sum of the squares of the total <code class="inlineCode">param</code> values in the <code class="inlineCode">initialize</code> function argument must add up to 1, as in the following example, where <img src="../Images/B18420_09_022.png" alt="" width="19" height="35"/><a id="_idIndexMarker1536"/> is set twice. So, if you take the sum of the squares, it will be equal to 1:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
qc = QuantumCircuit(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)
init_qubits = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
qc.initialize([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>] / np.sqrt(<span class="hljs-number">2</span>), init_qubits)
</code></pre>
    <h2 id="_idParaDest-310" class="heading-2">Question 4</h2>
    <p class="normal">Can you use the qsphere to visualize both the phase and probability information of a qubit?</p>
    <h2 id="_idParaDest-311" class="heading-2">Answer</h2>
    <p class="normal">Yes, the phase is given by the color of the state vectors and the probability is visualized by the size of the tips of the state vectors. The larger the diameter, the higher the probability.</p>
    <h2 id="_idParaDest-312" class="heading-2">Question 5</h2>
    <p class="normal">What would happen if you set the depolarization error values close to 1?</p>
    <h2 id="_idParaDest-313" class="heading-2">Answer</h2>
    <p class="normal">This will set the <img src="../Images/B18420_15_011.png" alt="" width="10" height="25"/><a id="_idIndexMarker1537"/> value to <code class="inlineCode">1</code>, therefore completely depolarizing the channel.</p>
    <h2 id="_idParaDest-314" class="heading-2">Question 6</h2>
    <p class="normal">If you applied a readout error equally to all qubits, what results would you expect and why?</p>
    <h2 id="_idParaDest-315" class="heading-2">Answer</h2>
    <p class="normal">When running on a simulator, rather than resulting in an ideal condition (no errors), you will instead see errors, where the significance of the errors is based on the set <code class="inlineCode">ReadoutError()</code> parameters.</p>
    <h1 id="_idParaDest-316" class="heading-1">Chapter 10 – Suppressing and Mitigating Quantum Noise</h1>
    <h2 id="_idParaDest-317" class="heading-2">Question 1</h2>
    <p class="normal">List the three main error mitigation techniques used by the Qiskit Runtime service.</p>
    <h2 id="_idParaDest-318" class="heading-2">Answer</h2>
    <p class="normal">Minimal mitigation, medium mitigation, and heavy mitigation.</p>
    <h2 id="_idParaDest-319" class="heading-2">Question 2</h2>
    <p class="normal">Which resilience levels are used for error mitigation?</p>
    <h2 id="_idParaDest-320" class="heading-2">Answer</h2>
    <p class="normal">Levels 0 through 2, where level 1 is the default.</p>
    <h2 id="_idParaDest-321" class="heading-2">Question 3</h2>
    <p class="normal">What other reversible gates could you use to fill in the idle time of a qubit using Dynamical Decoupling?</p>
    <h2 id="_idParaDest-322" class="heading-2">Answer</h2>
    <p class="normal">Any reversible gate, <code class="inlineCode">XGate</code> or <code class="inlineCode">YGate</code>, for example.</p>
    <h2 id="_idParaDest-323" class="heading-2">Question 4</h2>
    <p class="normal">Which type of noise contributes to amplitude dampening of a qubit?</p>
    <h2 id="_idParaDest-324" class="heading-2">Answer</h2>
    <p class="normal">Decoherence.</p>
    <h2 id="_idParaDest-325" class="heading-2">Question 5</h2>
    <p class="normal">Which type of noises contribute to dephasing of a qubit?</p>
    <h2 id="_idParaDest-326" class="heading-2">Answer</h2>
    <p class="normal">White noise, pink noise, and flux noise.</p>
    <h1 id="_idParaDest-327" class="heading-1">Chapter 11 – Understanding Quantum Algorithms</h1>
    <h2 id="_idParaDest-328" class="heading-2">Question 1</h2>
    <p class="normal">Which algorithm would you use to determine whether an <em class="italic">n</em>-bit string is balanced?</p>
    <h2 id="_idParaDest-329" class="heading-2">Answer</h2>
    <p class="normal">The Deutsch-Jozsa algorithm can be used to determine whether a function is constant or balanced.</p>
    <h2 id="_idParaDest-330" class="heading-2">Question 2</h2>
    <p class="normal">Implement the <strong class="keyWord">Bernstein-Vazirani</strong> algorithm to find the state <code class="inlineCode">170</code>.</p>
    <h2 id="_idParaDest-331" class="heading-2">Answer</h2>
    <p class="normal">To create the circuit, you need the binary representation of 170. Then, after applying a Hadamard gate to all the qubits, except the ancilla qubit, to which you will first apply a NOT gate followed by a Hadamard gate, apply a CX gate to each qubit that is represented by the binary value for 170, which is represented by the value <code class="inlineCode">10101010</code>. So, you would apply a CX gate to each of the odd qubits, where the control of each CX gate should be set to qubit <code class="inlineCode">1</code>, <code class="inlineCode">3</code>, <code class="inlineCode">5</code>, and <code class="inlineCode">7</code> and the target of each CX gate is the ancilla qubit. Then, apply a Hadamard gate followed by a measurement operator to all qubits except the ancilla qubit.</p>
    <h2 id="_idParaDest-332" class="heading-2">Question 3</h2>
    <p class="normal">How many oracle functions are there?</p>
    <h2 id="_idParaDest-333" class="heading-2">Answer</h2>
    <p class="normal">In general, most algorithms have one oracle function; however, there are some algorithms that require more than one, or multiple runs of a function, such as the Grover algorithm, which repeats the oracle and diffusion operator function based on the number of qubits of the circuit.</p>
    <h1 id="_idParaDest-334" class="heading-1">Chapter 12 – Applying Quantum Algorithms</h1>
    <h2 id="_idParaDest-335" class="heading-2">Question 1</h2>
    <p class="normal">What other problems can you solve using periodic functions?</p>
    <h2 id="_idParaDest-336" class="heading-2">Answer</h2>
    <p class="normal">The <strong class="keyWord">Quantum Fourier transform</strong> (<strong class="keyWord">QFT</strong>) is one of the more popular algorithms to solve periodic functions.</p>
    <h2 id="_idParaDest-337" class="heading-2">Question 2</h2>
    <p class="normal">Implement QFT on a 5-qubit state—for example: ‘10110’.</p>
    <h2 id="_idParaDest-338" class="heading-2">Answer</h2>
    <p class="normal">Using the same example in the book, simply extend another <strong class="keyWord">swap</strong> gate repetition by adding another qubit.</p>
    <h2 id="_idParaDest-339" class="heading-2">Question 3</h2>
    <p class="normal">Using Grover’s algorithm, find the following states, ‘101’, ‘001’, and ‘010’.</p>
    <h2 id="_idParaDest-340" class="heading-2">Answer</h2>
    <p class="normal">Simply change the numerical value on the argument to the values above, then observe the change in the circuit’s oracle representing each of the three values. Since all are 3 qubits in length, the repetition will be the same for each value (just once).</p>
    <h2 id="_idParaDest-341" class="heading-2">Question 4</h2>
    <p class="normal">How many iterations of Grover’s diffusion operator would you need to run to find the state <img src="../Images/B18420_15_012.png" alt="" width="63" height="23"/><a id="_idIndexMarker1538"/>?</p>
    <h2 id="_idParaDest-342" class="heading-2">Answer</h2>
    <p class="normal">Use the following to determine the number of times to repeat the function, <img src="../Images/B18420_15_013.png" alt="" width="79" height="29"/><a id="_idIndexMarker1539"/>, where N is the number of qubits. Here, N=4.</p>
    <h2 id="_idParaDest-343" class="heading-2">Question 5</h2>
    <p class="normal">Rerun the Grover’s search example. Only repeat Grover’s diffusion operator twice and note the difference in the result. What do you see that is different? What would you expect to change if you ran it more than three times?</p>
    <h2 id="_idParaDest-344" class="heading-2">Answer</h2>
    <p class="normal">The amplitude difference between the value we are searching for and the other values will vary differently, either increasingly or decreasingly.</p>
    <h1 id="_idParaDest-345" class="heading-1">Chapter 13 – Understanding Quantum Utility and Qiskit Patterns</h1>
    <h2 id="_idParaDest-346" class="heading-2">Question 1</h2>
    <p class="normal">What are the four steps of Qiskit Patterns?</p>
    <h2 id="_idParaDest-347" class="heading-2">Answer</h2>
    <p class="normal">Map, optimize, execute, and post-process.</p>
    <h2 id="_idParaDest-348" class="heading-2">Question 2</h2>
    <p class="normal">Which Qiskit Pattern handles mapping a quantum circuit to the hardware?</p>
    <h2 id="_idParaDest-349" class="heading-2">Answer</h2>
    <p class="normal">The optimization step handles mapping the circuit to the hardware.</p>
    <h2 id="_idParaDest-350" class="heading-2">Question 3</h2>
    <p class="normal">When encoding your problem to a quantum state, which Qiskit Pattern step are you on?</p>
    <h2 id="_idParaDest-351" class="heading-2">Answer</h2>
    <p class="normal">You are mapping the input values of your classical data into a quantum state.</p>
    <h2 id="_idParaDest-352" class="heading-2">Question 4</h2>
    <p class="normal">Why did we use a Sampler and not an Estimator primitive for the Grover example?</p>
    <h2 id="_idParaDest-353" class="heading-2">Answer</h2>
    <p class="normal">We did not have to use any observables to solve Grover’s algorithm. Simply returning the quasi-distribution of the results provided the answer.</p>
    <h1 id="_idParaDest-354" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Appendix_B.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code2617625996838265934.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>