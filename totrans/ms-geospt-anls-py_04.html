<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data Types, Storage, and Conversion</h1>
                </header>
            
            <article>
                
<p>This chapter will focus on the many different data types that exist within GIS and will provide an overview of the major data types in GIS and how to use the previously covered Python code libraries to read and write geospatial data. Apart from reading and writing different geospatial data types, you'll learn how to use these libraries to perform file conversion between different data types and how to download data from geospatial databases and remote sources.</p>
<p>The following vector and raster data types will be covered in this chapter:</p>
<ul>
<li>Shapefiles</li>
<li>GeoJSON</li>
<li>KML</li>
<li>GeoPackages</li>
<li>GeoTIFF</li>
</ul>
<p>The following file actions will also be covered, using Python geospatial data libraries covered in <a href="757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml" target="_blank">Chapter 2</a>, <em>Introduction to Geospatial Code Libraries</em>:</p>
<ul>
<li>Opening existing files</li>
<li>Reading and displaying different attributes (spatial and non-spatial)</li>
<li>Creating and writing new geospatial data in different formats</li>
<li>Converting one file format to another</li>
<li>Downloading geospatial data</li>
</ul>
<p>We'll provide an overview of the most used GIS data types before we head over to write some code for reading and writing them. Next, we will use some examples to explain how to use various Python libraries for reading, writing, downloading, and converting geospatial data. We'll start with an explanation of what geospatial data represents and the difference between vector and raster data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Raster and vector data</h1>
                </header>
            
            <article>
                
<p>Before diving into some of the most used GIS data types, a little background is required about what type of information geographical data represents. Earlier in this book, the distinction between raster and vector data was mentioned. All GIS data is comprised of one or the other, but a combination of both vectors and rasters is also possible. When deciding on which data type to use, consider the scale and type of geographical information represented by the data, which in turn determines what Python data libraries to use. As is illustrated in the following examples, the choice for a certain Python library can also depend on personal preference, and there may be various ways to do the same task.</p>
<p>In the geospatial world, raster data comes in the form of aerial imagery or satellite data, where each pixel has an associated value that corresponds to a different color or shade. Raster data is used for large continuous areas, such as differentiating between different temperature zones across various parts of the world. Other popular applications are elevation, vegetation, and precipitation mapping.</p>
<p>Rasters can also be used as input for creating vector maps, where, for example, objects such as roads and buildings can be distinguished (an example being the standard map view when navigating to Google Maps). Vector data itself consists of points, lines, and polygons to distinguish features in a geographical space, such as administrative boundaries. These are built up from individual points that have spatial relationships with each other that are described in an associated data model. Vectors maintain the same sharpness the more you zoom-in, while raster data will look more coarse-grained.</p>
<p>Now that you know what geographical data represents, let's discuss the most used geospatial data formats for vector and raster data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shapefiles</h1>
                </header>
            
            <article>
                
<p>The shapefile is probably the most often-used data format for geographical vector data today. This file format was developed by Esri, based on a mostly open specification for data interoperability among Esri and other GIS software products. Although many other file formats have been introduced in an attempt to replace the shapefile, it remains a widely-used file format. These days, many third-party programming modules in Python exist for reading and writing shapefiles.</p>
<p>Although the name <em>shapefile</em> might suggest that there's only one file associated with it, a single shapefile requires in fact at least three files that need to be stored in the same directory in order to work correctly:</p>
<ul>
<li>A <kbd>.shp</kbd> file with the feature geometry itself</li>
<li>A <kbd>.shx</kbd> file featuring a positional index of the feature geometry to allow seeking forwards and backwards quickly</li>
<li>A <kbd>.dbf</kbd> file with columnar attributes for each shape</li>
</ul>
<p>Shapefiles have their own structure. The main file (<kbd>.shp</kbd>) contains the geometry data, consisting of a single fixed-length header, followed by one or more variable-length records.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GeoJSON</h1>
                </header>
            
            <article>
                
<p>GeoJSON is a JSON-based file format that has become popular in a short time. GeoJSON uses the <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) open data standard for storing geographical features as key-value pairs. The files are easily readable, can be created using a simple text editor, and are now common in spatial databases, open data platforms, as well as commercial GIS software. You would use GeoJSON for various types of geospatial vector data, such as points, lines, and polygons. <span>GeoJSON uses either <kbd>.json</kbd> or <kbd>.geojson</kbd> as the filename extension. This means that a filename doesn't have to be <kbd>.geojson</kbd> in order to be a GeoJSON file. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">KML</h1>
                </header>
            
            <article>
                
<p><strong>Keyhole Markup Language</strong> (<strong>KML</strong>), referring to the company that developed the format. It can be used to store geographic data which can be visualized using a host of applications such as <span>Google Earth, Esri ArcGIS Explorer, Adobe Photoshop, and AutoCAD</span>. KML is based on XML, using a tag-based structure with nested elements and attributes. KML files are often distributed in KMZ files, which are zipped KML files with a <kbd>.kmz</kbd> extension. For its reference system, KML uses longitude, latitude, and altitude coordinates, defined by the <strong>World Geodetic System of 1984</strong> (<strong>WGS84</strong>). </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">GeoPackage</h1>
                </header>
            
            <article>
                
<p>An <span><strong>Open Geospatial Consortium</strong> (</span><strong>OGC</strong>) <strong>GeoPackage</strong> (<strong>GPKG</strong>) is an open data format for geographic information systems that support both vector and raster data. The format was defined by OGC and published in 2014, after which it has seen wide support from various government, commercial, and open source organizations. The GeoPackage data format was developed with the mobile user in mind—it was designed to be as efficient as possible, with all information contained in a single file. This makes it easy to rapidly share them on cloud storage and USB drives, and it is used in mobile applications that are disconnected. A GeoPackage file is built up as an extended SQLite 3 database file (<kbd>*.gpkg</kbd>) that combines data and metadata tables.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Raster data formats</h1>
                </header>
            
            <article>
                
<p>These are some of the most popular raster data formats used for geographical information today:</p>
<ul>
<li><strong>ECW</strong> (<strong>Enhanced Compressed Wavelet</strong>): ECW is a compressed image format typically for aerial and satellite imagery. This GIS file type is known for its high compression ratios while still maintaining quality contrast in images.</li>
<li><strong>Esri grid</strong>: A file format for adding attribute data to a raster file. Esri grid files are available as integer and floating point grids.</li>
<li><strong>GeoTIFF</strong> (<strong>Geographic Tagged Image File Format</strong>): An industry image standard file for GIS and satellite remote sensing applications. Almost all GIS and image processing software packages have GeoTIFF compatibility.</li>
<li><strong>JPEG 2000</strong>: An open source compressed raster format that allows both lossy and lossless compression. JPEG 2000 typically have a JP2 file extension. JPEG 2000 can achieve a compression ratio of 20:1, which is similar to the MrSID format.</li>
<li><strong>MrSID</strong> (<strong>Multi-Resolution Seamless Image Database</strong>): A compressed wavelet format that allows for both lossy and lossless compression. LizardTech's proprietary MrSID format is commonly used for orthoimages in need of compression. MrSID images have an extension of SID and are accompanied with a world file with the file extension SDW.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading and writing vector data with GeoPandas</h1>
                </header>
            
            <article>
                
<p>It's time for some hands-on exercises. We'll start with reading and writing some vector data in the form of GeoJSON using the GeoPandas library, which is the application used to demonstrate all examples is Jupyter Notebook, which comes preinstalled with Anaconda3. If you've installed all geospatial Python libraries from <a href="757a81a6-cc47-4f08-88d2-b50480eb32e6.xhtml" target="_blank">Chapter 2</a>, <em>Introduction to Geospatial Code Libraries,</em> you're good to go. If not, do this first. You might decide to create virtual environments for different combinations of Python libraries because of different dependencies and versioning. Open up a new Jupyter Notebook and a browser window and head over to <a href="http://www.naturalearthdata.com/downloads/">http://www.naturalearthdata.com/downloads/</a> and download the Natural Earth quick start kit at a convenient location. We'll examine some of that data for the rest of this chapter, along with some other geographical data files.</p>
<p>First, type the following code in a Jupyter Notebook with access to the GeoPandas library and run the following code:</p>
<pre>In: import geopandas as gpd<br/>    df = gpd.read_file(r'C:\data\gdal\NE\10m_cultural<br/>    \ne_10m_admin_0_boundary_lines_land.shp')<br/>    df.head()</pre>
<p>The output looks as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b3c8a0ac-845c-4349-a7af-7395f808a1aa.png" width="1089" height="333"/></div>
<p>The code does the following—the first line imports the GeoPandas library and shortens its name, saving space whenever we reference it later. The second line reads the data on disk, in this case, a shapefile with land boundary lines. It is assigned to a dataframe variable, which refers to a <kbd>pandas</kbd> dataframe, namely a 2D object comparable to an Excel table with rows and columns. The data structures of GeoPandas mimic are subclasses from those of <kbd>pandas</kbd> and are named differently—the <kbd>pandas</kbd> dataframe in GeoPandas is called a <strong>GeoDataFrame</strong>. The third line prints the attribute table, which is limited to the first five rows. After running the code, a separate cell's output will list the attribute data from the referenced shapefile. You'll notice that the FID column has no name and that a <kbd>geometry</kbd> column has been added as the last column.</p>
<p>This is not the only command to read data, as you can also read data from a PostGIS database, by using the <kbd>read_postgis()</kbd> command. Next, we'll plot the data inside our Jupyter Notebook:</p>
<pre>In: %matplotlib inline<br/>    df.plot(color='black')</pre>
<p>The output of the previous code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6b2011c9-8607-462d-8870-bce357d8173a.jpg" width="381" height="183"/></div>
<p>The first line is a so-called magic command, only to be used inside a Jupyter Notebook, and tells it to use the plotting capabilities of the <kbd>matplotlib</kbd> library inside a cell of the Jupyter Notebook app. This way, you can plot map data directly as opposed to working with an IDE. The second line states that we want the dataframe plotted, in <kbd>black</kbd> (the default color is blue). The output resembles a world map with only land borders, which are visible as black lines.</p>
<p>Next, we'll investigate some of the attributes of GeoPandas data objects:</p>
<pre>In: df.geom_type.head()<br/><br/>Out: 0 LineString<br/>     1 LineString<br/>     2 MultiLineString<br/>     3 LineString<br/>     4 LineString<br/>     dtype: object</pre>
<p>This tells us that the first five entries in our attribute table are made of line strings and multiline strings. For printing all entries, use the same line of code, without <kbd>.head()</kbd>:</p>
<pre>In: df.crs<br/><br/>Out: {'init': 'epsg:4326'}</pre>
<p>The <kbd>crs</kbd> attribute refers to the <strong>coordinate reference system</strong> (<strong>CRS</strong>) of the dataframe, in this case, <kbd>epsg:4326</kbd>, a code defined by the <strong>International Association of Oil and Gas Producers</strong> (<strong>IOGP</strong>). Go to <a href="http://www.spatialreference.org">www.spatialreference.org</a> for more information on EPSG. The CRS offers essential information about your spatial dataset. EPSG 4326 is also known as WGS 1984, a standard coordinate system for the Earth.</p>
<p>You can change the CRS as follows to a Mercator projection, showing a more vertically stretched image:</p>
<pre>In: merc = df.to_crs({'init': 'epsg:3395'})<br/>    merc.plot(color='black')</pre>
<p>The output of the previous code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1773eda6-d8f6-4636-9e34-fd21623b077d.jpg" style="width:28.50em;height:18.33em;" width="390" height="251"/></div>
<p>Suppose we want to convert the shapefile data of our dataframe into <kbd>json</kbd>. GeoPandas does this in one line of code, and the output is listed in a new cell:</p>
<pre>In: df.to_json()</pre>
<p>This previous command converted the data to a new format but did not write it to a new file. Writing your dataframe to a new <kbd>geojson</kbd> file can be done like this:</p>
<pre>In: df.to_file(driver='GeoJSON',filename=r'C:\data\world.geojson')</pre>
<p>Don't be confused by JSON file extensions—a JSON file with spatial data is a GeoJSON file, even though there's also a separate <kbd>.geojson</kbd> file extension.</p>
<p>For file conversion, GeoPandas relies on the Fiona library. To list all available <kbd>drivers</kbd> (a software component that lets the operating system and a device communicate with each other), use the following command:</p>
<pre>In: import fiona; fiona.supported_drivers</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading and writing vector data with OGR</h1>
                </header>
            
            <article>
                
<p>Now, let's turn to OGR for reading and writing a vector so that you can compare both OGR and GeoPandas functionality for performing the same kind of tasks. To follow the instructions that are mentioned as we proceed, you can download the MTBS wildfire data from: <a href="https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/fod_pt_shapefile/mtbs_fod_pts_data.zip">https://edcintl.cr.usgs.gov/downloads/sciweb1/shared/MTBS_Fire/data/composite_data/fod_pt_shapefile/mtbs_fod_pts_data.zip</a> and store them on your PC. The file that will be analyzed here is the <kbd>mtbs_fod_pts_20170501</kbd> shapefile's attribute table, which has 20,340 rows and 30 columns.</p>
<p>We'll start with the <kbd>ogrinfo</kbd> command which works in a terminal window and can be used for describing vector data. These are not Python commands, but we'll include them here as you can easily run them in a Jupyter Notebook with a simple prefix (adding an exclamation mark before the used command). Take, for instance, the following command, which is similar to the Fiona driver command:</p>
<pre>In: !ogrinfo –-formats</pre>
<p>This command lists the available formats that <kbd>ogrinfo</kbd> can access, by using the general option <kbd>--formats</kbd>. The results also tells us whether GDAL/OGR can only read/open the format, or whether it can also write new layers in that format. As you can see from the output, there are many supported file formats with OGR. Looking at Esri shapefiles in the list, the addition of (rw+v) means OGR supports read, write, update (meaning create), and virtual formats for Esri shapefiles:</p>
<pre>In: !ogrinfo -so "pts" mtbs_fod_pts_20170501</pre>
<p>The previous command lists the summary information about all the layers in a data source, which in this case is all the shapefiles in the folder called <kbd>"pts"</kbd>. The addition of <kbd>-so</kbd> stands for summary option. You can see that this command lists similar information as we saw with GeoPandas, such as the CRS. The same line of code, but without the <kbd>-so</kbd> addition will print all features and attributes, and takes some time to process. This is comparable to creating a GeoDataFrame in GeoPandas, but all attribute info is printed per feature on a new line instead of preserving the tabular form:</p>
<pre>In: !ogrinfo "pts" mtbs_fod_pts_20170501</pre>
<p>If we want to convert this shapefile into a GeoJSON file, we will use the following command:</p>
<pre>In: !ogr2ogr -f "GeoJSON" "C:\data\output.json"                                 <br/>    "C:\data\mtbs_fod_pts_data\mtbs_fod_pts_20170501.shp"</pre>
<p>The <kbd>-f</kbd> prefix stands for the format, followed by the output driver name, the output file name, and the location and the input file. You might receive error warnings doing file conversions, for example when a bad feature is encountered, but an output file will be written anyway.</p>
<p>OGR has also read and write capabilities for KML files. Download this KML sample file (<a href="https://developers.google.com/kml/documentation/KML_Samples.kml">https://developers.google.com/kml/documentation/KML_Samples.kml</a>) with the following code and run the following code to read its contents:</p>
<pre>In:   !ogrinfo "C:\Users\UserName\Downloads\KML_Samples.kml" -summary<br/><br/>Out:  Had to open data source read-only.INFO: Open of                              <br/>      `C:\Users\UserName\Downloads\KML_Samples.kml' using driver             <br/>     `KML' successful.<br/>        1: Placemarks (3D Point)<br/>        2: Highlighted Icon (3D Point)<br/>        3: Paths (3D Line String)<br/>        4: Google Campus (3D Polygon)<br/>        5: Extruded Polygon (3D Polygon)<br/>        6: Absolute and Relative (3D Polygon)</pre>
<p>For a more Pythonic approach for OGR, let's see some examples of how you can read and write data with OGR.</p>
<p>The following code lists all 30 field names of our wildfire shapefile using OGR:</p>
<pre>In: from osgeo import ogr<br/>    source = ogr.Open(r"C:\data\mtbs_fod_pts_data\<br/>    mtbs_fod_pts_20170501.shp")<br/>    layer = source.GetLayer()<br/>    schema = []<br/>    ldefn = layer.GetLayerDefn()<br/>    for n in range(ldefn.GetFieldCount()):<br/>        fdefn = ldefn.GetFieldDefn(n)<br/>        schema.append(fdefn.name)<br/>    print(schema)<br/><br/>Out: ['FIRE_ID', 'FIRENAME', 'ASMNT_TYPE', 'PRE_ID', 'POST_ID', 'ND_T',      <br/>    'IG_T', 'LOW_T',<br/>    'MOD_T', 'HIGH_T', 'FIRE_YEAR', 'FIRE_MON', 'FIRE_DAY', 'LAT',          <br/>    'LONG', 'WRS_PATH',<br/>    'WRS_ROW', 'P_ACRES', 'R_ACRES', 'STATE', 'ADMIN', 'MTBS_ZONE',      <br/>    'GACC', <br/>    'HUC4_CODE','HUC4_NAME', 'Version', 'RevCode', 'RelDate',              <br/>    'Fire_Type']</pre>
<p>As you can see from the preceding code, this is a little more involved than using GeoPandas, where you can directly load all attribute data into one GeoDataFrame using little code. With OGR, you need to iterate over the individual features which need to be referenced from a layer definition and appended to an empty list. But first, you need to use the <kbd>GetLayer</kbd> function— this is because OGR has its own data model that does not adapt itself automatically to the file format it reads.</p>
<p>Now that we have all the field names, we can iterate over the individual features, for instance, for the state field:</p>
<pre>In: from osgeo import ogr<br/>  import os<br/>  shapefile = r"C:\data\mtbs_fod_pts_data\mtbs_fod_pts_20170501.shp"<br/>  driver = ogr.GetDriverByName("ESRI Shapefile")<br/>  dataSource = driver.Open(shapefile, 0)<br/>  layer = dataSource.GetLayer()<br/>  for feature in layer:<br/>      print(feature.GetField("STATE"))</pre>
<p>Judging from the output of the last cell, there are apparently many features, but exactly how many? The total feature count can be printed as follows:</p>
<pre>In: import os<br/>    from osgeo import ogr<br/>    daShapefile = r"C:\data\mtbs_fod_pts_data\<br/>    mtbs_fod_pts_20170501.shp"<br/>    driver = ogr.GetDriverByName("ESRI Shapefile")<br/>    dataSource = driver.Open(daShapefile, 0)<br/>    layer = dataSource.GetLayer()<br/>    featureCount = layer.GetFeatureCount()<br/>    print("Number of features in %s: %d" %                                    <br/>    (os.path.basename(daShapefile), featureCount))<br/><br/>Out: Number of features in mtbs_fod_pts_20170501.shp: 20340</pre>
<p>As we've seen previously, the CRS is essential information about your spatial data. You can print this information in two ways—from the layer and the geometry of the layer. In the following code, two spatial reference variables will print the same output, as it should be (only the output of the first option is listed here to save space):</p>
<pre>In: from osgeo import ogr, osr<br/>   driver = ogr.GetDriverByName('ESRI Shapefile')<br/>    dataset = driver.Open(r"C:\data\mtbs_fod_pts_data\<br/>    mtbs_fod_pts_20170501.shp")<br/>    # Option 1: from Layer<br/>    layer = dataset.GetLayer()<br/>    spatialRef = layer.GetSpatialRef()<br/>    print(spatialRef)<br/>    # Option 2: from Geometry<br/>    feature = layer.GetNextFeature()<br/>    geom = feature.GetGeometryRef()<br/>    spatialRef2 = geom.GetSpatialReference()<br/>    print(spatialRef2)<br/><br/>Out: GEOGCS["GCS_North_American_1983",                                                       <br/>     DATUM["North_American_Datum_1983",                                             <br/>     SPHEROID["GRS_1980",6378137.0,298.257222101]],                                   <br/>     PRIMEM["Greenwich",0.0],<br/>     UNIT["Degree",0.0174532925199433]]</pre>
<p>We can check if we're dealing with points and print the <em>x</em> and <em>y</em> values of all individual features as well as their centroids as follows:</p>
<pre>In: from osgeo import ogr<br/>    import os<br/>    shapefile = r"C:\data\mtbs_fod_pts_data\mtbs_fod_pts_20170501.shp"<br/>    driver = ogr.GetDriverByName("ESRI Shapefile")<br/>    dataSource = driver.Open(shapefile, 0)<br/>    layer = dataSource.GetLayer()<br/>    for feature in layer:<br/>        geom = feature.GetGeometryRef()                                    <br/>    print(geom.Centroid().ExportToWkt())</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading and writing raster data with Rasterio</h1>
                </header>
            
            <article>
                
<p>After covering how to read and write various vector data formats in Python, we'll now do the same for raster data. We'll start with the Rasterio library and have a look at how we can read and write raster data. Open up a new Jupyter Notebook where you have access to the Rasterio library and type the following code:</p>
<pre>In: import rasterio    <br/>    dataset = rasterio.open(r"C:\data\gdal\NE\50m_raster\NE1_50M_SR_W<br/>    \NE1_50M_SR_W.tif")</pre>
<p>This imports the <kbd>rasterio</kbd> library and opens a GeoTIFF file. We can now perform some simple data description commands, such as printing the number of image bands.</p>
<div class="packt_infobox">Raster images contain either a single or multiple bands. All bands are contained in a single file, with each band covering the same area. When the image is read by your computer, these bands are overlayed on top of each other so that you'll see one single image. Each band contains a 2D array with rows and columns of data. Each data cell of each array contains a numeric value that corresponds to a color value (or elevation value, which is also possible). If a raster image has multiple bands, each band corresponds to a segment of the electromagnetic spectrum that was collected by a sensor. Users can display one or multiple bands, combining different bands together to make their own color composites. <a href="399c3041-569f-400a-83f0-e13020a177cf.xhtml" target="_blank">Chapter 9</a>, <em>ArcGIS API for Python and ArcGIS Online</em> features some examples of these color composites when discussing displaying raster data using the ArcGIS API for Python.</div>
<p>In this case, there are three different bands:</p>
<pre>In: dataset.count<br/>Out: 3</pre>
<p>A <kbd>dataset</kbd> band is an array of values representing the partial distribution of a single variable in a 2D space. The number of columns is returned by the <kbd>width</kbd> attribute:</p>
<pre>In: dataset.width<br/>Out: 10800</pre>
<p>The number of rows is returned by the <kbd>height</kbd> attribute:</p>
<pre>In:  dataset.height<br/>Out: 5400</pre>
<p>The following code returns the spatial bounding box in meters, so you can calculate the area it covers:</p>
<pre>In:  dataset.bounds<br/>Out: BoundingBox(left=-179.99999999999997, bottom=-89.99999999998201,<br/>     right=179.99999999996405, top=90.0)</pre>
<p>The CRS of the dataset can be printed as follows:</p>
<pre>In:  dataset.crs<br/>Out: CRS({'init': 'epsg:4326'})</pre>
<p>You can access and return a NumPy ndarray with the raster array for a raster band as follows:</p>
<pre>In:   band1 = dataset.read(1)<br/>      band1<br/>Out:  array([[124, 124, 124, ..., 124, 124, 124], ...</pre>
<p>If you want to visualize the image, use the following code:</p>
<pre>In: %matplotlib inline<br/>    from matplotlib import pyplot<br/>    pyplot.imshow(dataset.read(1))<br/>    pyplot.show()</pre>
<div>The output map will look like this:</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/3a5807c2-e0b5-4e62-9d69-be725f7b2100.png" style="width:29.08em;height:15.25em;" width="397" height="207"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading and writing raster data using GDAL</h1>
                </header>
            
            <article>
                
<p>Here are some commands for reading and writing raster data with GDAL:</p>
<pre>In: !gdalinfo --formats</pre>
<p>This command lists all supported file formats in GDAL. For a summary including the CRS, use <kbd>!gdalinfo</kbd> without any prefixes:</p>
<pre>In: !gdalinfo "C:\data\gdal\NE\50m_raster\NE1_50M_SR_W<br/>    \NE1_50M_SR_W.tif"<br/><br/>Out: Driver: GTiff/GeoTIFF<br/>     Files: C:\data\gdal\NE\50m_raster\NE1_50M_SR_W\NE1_50M_SR_W.tif
     Size is 10800, 5400
     Coordinate System is:
     GEOGCS["WGS 84",
     DATUM["WGS_1984", ...</pre>
<p>You can convert a GeoTIFF to a JPEG file as follows:</p>
<pre>In: !gdal_translate -of JPEG <br/>    "C:\data\gdal\NE\50m_raster\NE1_50M_SR_W\NE1_50M_SR_W.tif" <br/>    NE1_50M_SR_W.jpg<br/><br/>Out: Input file size is 10800, 5400
     0...10...20...30...40...50...60...70...80...90...100 - done.</pre>
<p>The output, <kbd>NE1_50M_SR_W.jpg</kbd>, will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5f0da7fa-655a-491f-a105-2227c3c45978.jpg" style="width:32.50em;height:16.33em;" width="1950" height="975"/></div>
<p>Now, let's open a GeoPackage using GDAL. GeoPackages can be either vector or raster-based, but in this case, we'll open a raster-based one, which becomes clear from the following output. For reading and writing GeoPackages, we need GDAL version 2.2.2, so the following example won't work for lower version numbers. Download the following GeoPackage file (<a href="http://www.geopackage.org/data/gdal_sample_v1.2_no_extensions.gpkg">http://www.geopackage.org/data/gdal_sample_v1.2_no_extensions.gpkg</a>) and reference it as follows:</p>
<pre>In: !gdalinfo                                                             <br/>    "C:\Users\UserName\Downloads\gdal_sample_v1.2_no_extensions.gpkg"<br/><br/>Out: Driver: GPKG/GeoPackageFiles:<br/>     C:\Users\UserName\Downloads\gdal_sample_v1.2_no_extensions.gpkg<br/>    Size is 512, 512<br/>    Coordinate System is''<br/>   ...</pre>
<p> </p>
<p>The GDAL <span><strong>Web Map Service</strong> (</span><strong>WMS</strong>) driver allows for interacting with online web mapping services. You can use it to download various geospatial datasets, subsets, or information about available datasets directly from a command prompt (or in this case, a Jupyter Notebook) without using a browser to navigate to a website and download data manually. There are many different options, so refer to the online documentation for more information. The following example requires GDAL version 2.0 or higher. The following command uses the URL of a <strong>REpresentational State Transfer</strong> (<strong>REST</strong>) definition for an ArcGIS MapServer and returns the information about the requested image service, such as the amount of bands, band names, CRS, corner coordinates, and more:</p>
<pre>In: !gdalinfo http://server.arcgisonline.com/ArcGIS/rest/services/<br/>    World_Imagery/MapServer?f=json&amp;pretty=true</pre>
<p>Note that you added some information to the URL of the image service, in this case, <kbd>f=json&amp;pretty=true</kbd>. This means the requested file format by the user is <kbd>pretty json</kbd>, which is a nicely formatted <kbd>json</kbd> that is easier to read for humans.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter provided an overview of major data types in GIS. After explaining the difference between vector and raster data, the following vector and raster data types were covered—Esri shapefiles, GeoJSON, KML, GeoPackages, and GeoTIFF files. Next, we explained how to use some of the earlier described Python code libraries to read and write geospatial data. The following geospatial Python libraries for reading and writing raster and vector data were covered in particular—GeoPandas, OGR, GDAL, and Rasterio. Apart from reading and writing different geospatial data types, you learned how to use these libraries to perform file conversion between different data types and how to upload and download data from geospatial databases and remote sources.</p>
<p>The next chapter will cover geospatial analysis and processing. Python libraries covered are OGR, Shapely and GeoPandas. The reader will learn how to use these libraries and write scripts for geospatial analysis, using real-world examples.</p>
<p> </p>


            </article>

            
        </section>
    </div>



  </body></html>