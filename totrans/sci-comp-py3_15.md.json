["```py\nfrom scipy.integrate import quad\nquad(lambda x : 1/(x**2+x+1),a=0, b=4)   \n```", "```py\nfrom sympy import *\ninit_printing()\n```", "```py\nx = symbols('x')\nf = Lambda(x, 1/(x**2 + x + 1))\n```", "```py\nintegrate(f(x),x)    \n```", "```py\npf = Lambda(x, integrate(f(x),x))\ndiff(pf(x),x)    \n```", "```py\nsimplify(diff(pf(x),x))    \n```", "```py\npf(4) - pf(0)     \n```", "```py\n(pf(4)-pf(0)).evalf() # returns 0.9896614396123\n```", "```py\nx, y, mass, torque = symbols('x y mass torque')\n```", "```py\nsymbol_list=[symbols(l) for l in 'x y mass torque'.split()]\n```", "```py\n x, y, mass, torque = symbol_list\n```", "```py\nrow_index=symbols('i',integer=True)\nprint(row_index**2)  # returns i**2\n```", "```py\nintegervariables = symbols('i:l', integer=True)\ndimensions = symbols('m:n', integer=True)\nrealvariables = symbols('x:z', real=True)\n```", "```py\nA = symbols('A1:3(1:4)')\n```", "```py\n1/3  # returns 0.3333333333333333\nsympify(1)/sympify(3)  # returns '1/3'\n```", "```py\nf, g = symbols('f g', cls=Function)\n```", "```py\nf = Function('f')\ng = Function('g')\n```", "```py\nx = symbols('x')\nf, g = symbols('f g', cls=Function)\ndiff(f(x*g(x)),x)\n```", "```py\nx = symbols('x:3')\nf(*x)\n```", "```py\n [diff(f(*x),xx) for xx in x]\n```", "```py\n[f(*x).diff(xx) for xx in x]\n```", "```py\nx = symbols('x')\nf(x).series(x,0,n=4)\n```", "```py\nx = symbols('x')\nsimplify(cos(x)**2 + sin(x)**2)  # returns 1\n```", "```py\natan(x).diff(x) - 1./(x**2+1)  # returns 0\n```", "```py\nimport scipy as sp\nimport sympy as sym\n# working with numbers\nx=3\ny=sp.sin(x)\n# working with symbols\nx=sym.symbols('x')\ny=sym.sin(x)   \n```", "```py\nC,rho,A,v=symbols('C rho A v')\n# C drag coefficient, A coss-sectional area, rho density\n# v speed\nf_drag = Lambda(v,-Rational(1,2)*C*rho*A*v**2)\n```", "```py\nx = symbols('x')\nf_drag(2)\nf_drag(x/3)\n```", "```py\nt=Lambda((x,y),sin(x) + cos(2*y))\n```", "```py\nt(pi,pi/2)  # returns -1\n```", "```py\np=(pi,pi/2)\nt(*p)   # returns -1\n```", "```py\nF=Lambda((x,y),Matrix([sin(x) + cos(2*y), sin(x)*cos(y)]))\n```", "```py\nF(x,y).jacobian((x,y))\n```", "```py\nx=symbols('x:2')\nF=Lambda(x,Matrix([sin(x[0]) + cos(2*x[1]),sin(x[0])*cos(x[1])]))  \nF(*x).jacobian(x)\n```", "```py\nphi=symbols('phi')\nrotation=Matrix([[cos(phi), -sin(phi)],\n                 [sin(phi), cos(phi)]])\n```", "```py\nsimplify(rotation.T*rotation -eye(2))  # returns a 2 x 2 zero matrix\n```", "```py\nsimplify(rotation.T - rotation.inv())\n```", "```py\nM = Matrix(3,3, symbols('M:3(:3)'))\n```", "```py\nMatrix(number of rows,number of colums, function)\n```", "```py\ndef toeplitz(n):\n    a = symbols('a:'+str(2*n))\n    f = lambda i,j: a[i-j+n-1]\n    return Matrix(n,n,f)\n```", "```py\na=symbols('a')\nM[0,2]=0  # changes one element\nM[1,:]=Matrix(1,3,[1,2,3]) # changes an entire row\n```", "```py\nA = Matrix(3,3,symbols('A1:4(1:4)'))\nb = Matrix(3,1,symbols('b1:4'))\nx = A.LUsolve(b)\n\n```", "```py\nsimplify(x)\n```", "```py\nx, a = symbols('x a')\nb = x + a\n```", "```py\nx, a = symbols('x a')\nb = x + a\nc = b.subs(x,0)   \nd = c.subs(a,2*a)  \nprint(c, d)   # returns (a, 2a)\n```", "```py\nb.subs(x,0)\nb.subs({x:0})  # a dictionary as argument\n```", "```py\nb.subs({x:0, a:2*a})  # several substitutions in one\n```", "```py\nx, a, y = symbols('x a y')\nb = x + a\nb.subs({a:a*y, x:2*x, y:a/y})\nb.subs({y:a/y, a:a*y, x:2*x})\n```", "```py\n b.subs([(y,a/y), (a,a*y), (x,2*x)]) \n```", "```py\nn, alpha = symbols('n alpha')\nb = cos(n*alpha)\nb.subs(cos(n*alpha), 2*cos(alpha)*cos((n-1)*alpha)-cos((n-2)*alpha))\n```", "```py\na2 = symbols('a2')\nT.subs(a2,0)\n```", "```py\nsymbs = [symbols('a'+str(i)) for i in range(19) if i < 3 or i > 5]\nsubstitutions=list(zip(symbs,len(symbs)*[0]))\nT.subs(substitutions)\n```", "```py\npi.evalf()   # returns 3.14159265358979\n```", "```py\npi.evalf(30)   # returns  3.14159265358979323846264338328\n```", "```py\nx = sp.Rational(1,2)\nxns=[x]\n\nfor i in range(1,9):\n    x = (x - sp.atan(x)*(1+x**2)).evalf(3000)\n    xns.append(x)\n```", "```py\n# Test for cubic convergence\nprint(array(abs(diff(xns[1:]))/abs(diff(xns[:-1]))**3,dtype=float64))\n```", "```py\n[ 0.41041618, 0.65747717, 0.6666665,  0.66666667, 0.66666667, 0.66666667, 0.66666667]\n```", "```py\nt=symbols('t')\nx=[0,t,1]\n# The Vandermonde Matrix\nV = Matrix([[0, 0, 1], [t**2, t, 1], [1, 1,1]])\ny = Matrix([0,1,-1])  # the data vector\na = simplify(V.LUsolve(y)) # the coefficients\n# the leading coefficient as a function of the parameter\na2 = Lambda(t,a[0])\n```", "```py\nleading_coefficient = lambdify(t,a2(t))\n```", "```py\nt_list= linspace(-0.4,1.4,200)\nax=subplot(111)\nlc_list = [leading_coefficient(t) for t in  t_list]\nax.plot(t_list, lc_list)\nax.axis([-.4,1.4,-15,10])\n```"]