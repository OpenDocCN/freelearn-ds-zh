- en: Chapter 12. Error Handling and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the default Python error message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python exception handling structures (try/except/finally)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving tool messages with GetMessages()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering tool messages by severity level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning individual messages with GetMessage()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for and responding to specific error messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various messages are returned during the execution of ArcGIS geoprocessing tools
    and functions. These messages can be informational in nature or indicate warning
    or error conditions that can result in the tool not creating the expected output
    or in outright failure of the tool to execute. These messages do not appear as
    message boxes. Instead, you will need to retrieve them using various ArcPy functions.
    To this point in the book, we have ignored the existence of these messages, warnings,
    and errors. This is mainly due to the fact that I wanted you to concentrate on
    learning some basic concepts, without adding the extra layer of code complexity
    that is necessary for creating robust geoprocessing scripts that can handle error
    situations gracefully. That being said, it's now time that you learn how to create
    the geoprocessing and Python exception handling structures that will enable you
    to create versatile geoprocessing scripts. These scripts can handle messages that
    indicate warnings, errors, and general information, which are generated while
    your script is running. These code details will help make your scripts more flexible
    and less error prone. You've already used the basic `try` and `except` blocks
    to perform some basic error handling. But, in this chapter, we'll go into more
    detail about why and how these structures are used.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the default Python error message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Python will generate an error message anytime it encounters a problem
    in your script. These error messages will not always be very informative to the
    end user running the script. However, it is valuable to take a look at these raw
    messages. In later recipes, we'll use Python error handling structures to get
    a cleaner look at the errors and respond as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create and run a script that intentionally contains
    error conditions. We will not include any geoprocessing or Python exception handling
    techniques in the script. We're intentionally doing this, because I want you to
    see the error information returned by Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps below to see a raw Python error message that is generated
    when an error occurs while a tool is being executed in a script:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a new script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script to `c:\ArcpyBook\Ch12\ErrorHandling.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `arcpy` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `Buffer` tool. The `Buffer` tool requires a buffer distance be entered
    as one of its parameters. In this code block, we have intentionally left out the
    distance parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the script. You should see the following error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What you see in the output error message isn't terribly informative. If you
    are a fairly experienced programmer, you'll generally be able to make out what
    the problem is. In this case we did not include a buffer distance. However, in
    many cases, the returned error message will not give you much information that
    you can use to resolve the problem. Errors in your code are simply a fact of life
    in programming. However, how your code responds to these errors, also called exceptions,
    is very important. You should plan to handle errors gracefully through the use
    of Python error handling structures, which examine `arcpy` generated exceptions
    and act accordingly. Without these structures in place, your scripts will fail
    immediately, frustrating your users in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Python exception handling structures (try/except/finally)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has built-in exception handling structures that allow you to capture
    error messages that are generated. Using this error information, you can then
    display a more appropriate message to the end user and respond to the situation
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions are unusual or error conditions that occur in your code. Exception
    statements in Python enable you to trap and handle errors in your code, allowing
    you to gracefully recover from error conditions. In addition to error handling,
    exceptions can be used for a variety of other things including event notification
    and special-case handling.
  prefs: []
  type: TYPE_NORMAL
- en: Python exceptions occur in two ways. Exceptions in Python can either be intercepted
    or triggered. When an error condition occurs in your code, Python automatically
    triggers an exception, which may or may not be handled by your code. It is up
    to you as a programmer to catch an automatically triggered exception. Exceptions
    can also be triggered manually by your code. In this case, you would also provide
    an exception handling routine to catch these manually triggered exceptions. You
    can manually trigger an exception by using the `raise` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The `try`/`except` statement is a complete, compound Python statement used to
    handle exceptions. This variety of `try` statement starts with a `try` header
    line followed by a block of indented statements, then one or more optional `except`
    clauses that name exceptions to be caught, and an optional `else` clause at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: The `try`/`except`/`else` statement works as follows. Once inside a `try` statement,
    Python marks the fact that you are in a `try` block and knows that any exception
    condition that occurs within this block will be forwarded to the various `except`
    statements for handling.
  prefs: []
  type: TYPE_NORMAL
- en: Each statement inside the `try` block is executed. Assuming that no exception
    conditions occur, the code pointer will then jump to the `else` statement and
    execute the code block contained within the `else` statement before moving to
    the next line of code below the `try` block. If an exception occurs inside the
    `try` block, Python searches for a matching exception code. If a matching exception
    is found, the code block inside the `except` block is executed. The code then
    picks up below the full `try` statement. The `else` statements are not executed
    in this case. If a matching exception header is not found, Python will propagate
    the exception to a `try` statement above this code block. In the event that no
    matching `except` header is found, the exception comes out of the top level of
    the process. This results in an unhandled exception and you wind up with the type
    of error message that we saw in our first recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to add in some basic Python exception handling structures.
    There are several variations of the `try`/`except`/`else`/`finally` exception
    handling structure. In this recipe, we'll start with a very simple `try`/`except`
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps below to add Python error handling structures to a script:'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter your script to include a `try`/`except` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and run the script. You should see the simple message `Error`. That's not
    any more helpful than the output we received in our first recipe. In fact, it's
    even less useful. However, the point of this recipe is simply to introduce you
    to the `try`/`except` error handling structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an extremely simple structure. The `try` block indicates that everything
    indented under the `try` statement will be subject to exception handling. If an
    exception of any type is found, control of the code processing jumps to the `except`
    section and prints the error message(s), which in this case is simply `Error`.
    Now, as I mentioned, this is hardly informative to your users, but hopefully it
    gives you a basic idea of how `try`/`except` blocks work, and as a programmer
    you will better understand any errors reported by your users. In the next recipe,
    you'll learn how to add tool-generated messages to this structure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other type of `try` statement is the `try`/`finally` statement, which allows
    for finalization actions. When a `finally` clause is used in a `try` statement,
    its block of statements always run at the very end, whether an error condition
    occurs or not. The `try`/`finally` statement works as follows. If an exception
    occurs, Python runs the `try` block, then the `finally` block, and then execution
    continues past the entire `try` statement. If an exception does not occur during
    execution, Python runs the `try` block, then the `finally` block, and then execution
    is passed back to a higher level `try` statement. This is useful when you want
    to make sure an action takes place after a code block runs regardless of whether
    or not an error condition occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving tool messages with GetMessages()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ArcPy includes a `GetMessages()` function that you can use to retrieve messages
    generated when an ArcGIS tool is executing. Messages can include informational
    messages, such as the start and ends times of a tool execution as well as warnings
    and errors, which can result in something less than the desired result or complete
    failure of the tool to execute to completion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the execution of a tool, various messages are generated. These messages
    include informational messages, such as the start and end times of a tool execution,
    parameter values passed to the tool, and progress information. In addition, warnings
    and errors can also be generated by the tool. These messages can be read by your
    Python script, and your code can be designed to appropriately handle any warnings
    or errors that have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: ArcPy stores the messages from the last tool that was executed and you can retrieve
    these messages using the `GetMessages()` function, which returns a single string
    containing all messages from the tool that was last executed. You can filter this
    string by severity to return only certain types of messages, such as warnings
    or errors. The first message will always include the name of the tool executed,
    and the last message is the start and end time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will add a line of code to the `except` statement, which
    will print more descriptive information about the current tool run.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow these steps to learn how to add a `GetMessages()` function to your script
    that generates a list of messages from the tool last executed.
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter your script to include the `GetMessages()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. This time, the error message should be much more informative.
    Also notice that there are other types of messages that are generated including
    the start and end times of the script''s execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GetMessages()` function returns all the messages generated by the last
    tool that was run. I want to emphasize that it only returns messages from the
    last tool that was run. Keep this in mind if you have a script with multiple tools
    that are being run. Historical tool run messages are not accessible through this
    function. However, there is a `Result` object that you can use if you need to
    retrieve historical tool run messages.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering tool messages by severity level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the last recipe, all tools generate a number of messages that
    can be classified as information, warning, or error messages. The `GetMessages()`
    method accepts a parameter that allows you to filter the messages that are returned.
    For example, you may not be interested in the informative or warning messages
    in your script. However, you are certainly interested in error messages as they
    indicate a fatal error that will not allow a tool to successfully execute. Using
    `GetMessages()`, you can filter the returned message to only error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages are classified into one of the three types, which are indicated by
    a severity level. **Informational messages** provide descriptive information concerning
    things such as a tools progress, start and end times of the tool, output data
    characteristics, and much more. The severity level of an informational message
    is indicated by a value of `0`. **Warning messages** are generated when a problem
    has occurred during execution that may affect the output. Warnings are indicated
    with a severity level of `1` and don't normally stop a tool from running. The
    last type of message is an **error message**, which is indicated with a numeric
    value of `2`. These indicate fatal events that prevent a tool from running. Multiple
    messages may be generated during the execution of a tool, and these are stored
    in a list. More information about message severity levels is provided in the following
    image. In this recipe, you will learn how to filter the messages generated by
    the `GetMessages()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4445OT_Chapter_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering the messages returned by a tool is really quite simple. You simply
    provide the severity level you'd like to return as a parameter to the `GetMessages()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the `GetMessages()` function so that you pass in a value of `2` as the
    only parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned, the `GetMessages()` method can accept an integer argument of
    `0`, `1`, or `2`. Passing a value of `0` indicates that all messages should be
    returned, while passing a value of `1` indicates that you wish to see warnings.
    In our case, we have passed a value of `2`, which indicates that we only want
    to see error messages. Therefore, you won't see any of the other information messages,
    such as the start and end times of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for and responding to specific error messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All errors and warnings generate a specific error code. It is possible to check
    for specific error codes in your scripts and perform some type of action based
    on these errors. This can make your scripts even more versatile.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All errors and warnings generated by a geoprocessing tool contain both a six
    digit code and a description.Your script can test for specific error codes and
    respond accordingly.You can get a listing of all the available error messages
    and codes in the ArcGIS Desktop help system by going to **Geoprocessing** | **Tool
    errors and warnings**.This is illustrated in the following screenshot.All errors
    will have a unique page that briefly describes the error by code number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready…](img/4445_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to write a code that responds to specific error
    code generated by the execution of a geoprocessing tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the ArcGIS Desktop help system by going to **Start** | **Programs** | **ArcGIS**
    | **ArcGIS for Desktop Help**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to **Geoprocessing** | **Tool errors and warnings** | **Tool errors 1-10000**
    |**Tool errors and warnings: 701-800**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select **000735: <value>: Value is required**.This error indicates that a parameter
    required by the tool has not been provided.You’ll recall from running this script
    that we have not provided the buffer distance and that the error message generated,
    as a result, contains the error code that we are viewing in the help system.In
    the following code, you will find the full text of the error message.Notice the
    error code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In your script, alter the `except` statement, so that it appears as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script.You should see various messages printed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What you’ve done in this code block is use the `arcpy.GetReturnCode()` function
    to return the error code generated by the tool.Then, an `if` statement is used
    to test if the error code contains the value `735`, which is the code that indicates
    that a required parameter has not been provided to the tool.You then provided
    a default value for the buffer distance and called the `Buffer` tool again; providing
    the default buffer value this time.
  prefs: []
  type: TYPE_NORMAL
- en: Returning individual messages with GetMessage()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `GetMessages()` returns a list containing all messages from the last tool
    run, you can also get individual messages from the string using `GetMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we have been returning all messages generated by the tool.
    However, you can return individual messages to your user through the `GetMessage()`
    method, which takes an integer as a parameter indicating the particular message
    you''d like to retrieve. Each message generated by the tool is placed into a message
    list or array. We discussed list objects earlier in the book, so you''ll remember
    that this is just a collection of some type of object. Just as a reminder: lists
    are zero-based, meaning that the first item in the list is located at position
    `0`. For example, `GetMessage(0)` would return the first message in the list,
    while `GetMessage(1)` would return the second message in the list. The first message
    will always be the tool being executed along with any parameters. The second message
    returns the start time of the script, while the last message returns the end time
    of the script.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If necessary, open the `c:\ArcpyBook\Ch12\ErrorHandling.py` file in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the `except` block as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We haven''t covered the `GetMessageCount()` function yet. This function returns
    the number of messages returned by the tool. Remember that our list of messages
    is zero-based, so we have to subtract one from the `GetMessageCount()`function
    to arrive at the last message in the list. Otherwise, we''d be attempting to access
    a message that does not exist. In this script, we have accessed the start and
    end times of the script. The second message is always the start time for the script,
    while the last message will always be the end time of the script. This concept
    is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Total message count is `6`, but the last message is number `5`. This is because
    the count starts with `0`. This is why you need to subtract `1` as stated previously.
    In this case, the start and end times are the same, because the script contains
    an error. However, it does illustrate how to access the individual messages generated
    by the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Automating Python Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Python scripts from the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sys.argv[] to capture command-line input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Python scripts to batch files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling batch files to run at prescribed times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python geoprocessing scripts can be executed either outside ArcGIS as a standalone
    script or inside ArcGIS as a script tool. Both methods have their advantages and
    disadvantages. Up to this point in the book, all our scripts have been run either
    inside ArcGIS as a script tool, or from a Python development environment such
    as IDLE, or the Python Window in ArcGIS. However, Python scripts can also be executed
    from the Windows operating system command line. The command line is a window that
    you can use to type in commands rather than the usual point-and-click approach
    provided by Windows. This method of running Python scripts is useful for scheduling
    the execution of a script. There are a number of reasons why you might want to
    schedule your scripts. Many geoprocessing scripts take a long time to fully execute
    and need to be scheduled to run during non-working hours on a regular basis. Additionally,
    some scripts need to be executed on a routine basis (every day, week, month, and
    so on), and should be scheduled for efficiency. In this chapter, you will learn
    how to execute scripts from the command line, place scripts inside batch files,
    and schedule the execution of scripts at prescribed times. Please keep in mind
    that any scripts run from the command line will still need access to an ArcGIS
    Desktop license in order to use the `arcpy` module.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python scripts from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point in the book, all your Python scripts have been run as either
    script tools in ArcGIS or from a Python development environment. The Windows command
    prompt provides yet another way of executing your Python scripts. The command
    prompt is used primarily to execute scripts that will be run as a part of a batch
    file and/or as scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of advantages to running Python geoprocessing scripts from
    the command prompt. These scripts can be scheduled to batch process your data
    during off hours for more efficient processing, and they are easier to debug due
    to the built-in Python error handling and debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the Windows command prompt to execute
    a Python script. You will need administrative rights to complete this recipe,
    so you may need to contact your information technology support group to make this
    change.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to run a script from the Windows command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, go to **Start** | **All Programs** | **Accessories** | **Command
    Prompt** to display a window similar to the following screenshot:![How to do it…](img/4445_A1_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The window will display the current directory. Your directory will differ to
    some degree. Let's change to the directory for this appendix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type `cd c:\ArcpyBook\Appendix1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type dir to see a listing of the files and sub-directories. You should see only
    a single Python file called `ListFields.py`:![How to do it…](img/4445_A1_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will want to make sure that the Python interpreter can be run from anywhere
    in your directory structure. Go to **Start** | **All Programs** | **Accessories**
    | **System Tools** | **Control Panel**.![How to do it…](img/4445_A1_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **System and Security**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Advanced system settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **System Properties** dialog box, select the **Advanced** tab and then
    the **Environment Variables** button as shown in the following screenshot:![How
    to do it…](img/4445_A1_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the **Path** system variable seen in the screenshot below and click on
    **Edit**.![How to do it…](img/4445_A1_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Examine the entire text string for the directory `c:\Python27\ArcGIS10.1`. If
    the text string isn't found, add it to the end. Make sure that you add a semi-colon
    before adding the path. Now, when you type `python` in the command prompt, it
    will look through each of the directories in the **Path** system variable, checking
    for an executable called `python.exe`.![How to do it…](img/4445_A1_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **Edit System Variable** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **Environment Variables** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OK** to dismiss the **System Properties** dialog box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the command prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `python ListFields.py`. This will run the `ListFields.py` script. After
    a brief delay, you should see the following output:![How to do it…](img/4445_A1_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ListFields.py` script provided for you in this recipe is a simple script
    that lists the attribute fields for the `Burglaries_2009.shp` file. The workspace
    and shapefile name are hardcoded in the script. Typing `python` followed by the
    name of the script, which is `ListFields.py` in this case, triggered the execution
    of a script using the Python interpreter. As I mentioned, the workspace and shapefile
    name were hardcoded in this script. In the next recipe, you will learn how to
    pass in arguments to the script, so that you can remove the hardcoding and make
    your script more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Using sys.argv[ ] to capture command-line input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of hardcoding your scripts with paths to specific datasets, you can
    make your scripts more flexible by allowing them to accept input in the form of
    parameters from the command prompt. These input parameters can be captured using
    Python's `sys.argv[]` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s `sys.argv[]` object allows you to capture input parameters from the
    command line when a script is executed. An example is useful for illustrating
    how this works. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/4445_A1_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each word must be separated by a space. These words are stored in a zero-based
    list object called `sys.argv[]`. With `sys.argv[]`, the first item in the list,
    referenced by index `0`, stores the name of the script. In this case, it would
    be `ListFields.py`. Each successive word is referenced by the next integer. Therefore,
    the first parameter (`c:\ArcpyBook\data`) will be stored in `sys.argv[1]`, and
    the second parameter (`Burglaries.shp`) will be stored in `sys.argv[2]`. Each
    of the arguments in the `sys.argv[]` object can be accessed and used inside your
    geoprocessing script. In this recipe, you're going to update the `ListFields.py`
    script to accept input parameters from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python script that can accept input parameters
    from the command prompt using `sys.argv[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `C:\ArcpyBook\Appendix1\ListFields.py` in IDLE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `sys` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to hold the workspace that will be passed into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to hold the feature class that will be passed into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the lines of code that set the workspace and call the `ListFields()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your completed script should appear as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, open the command prompt and navigate to `c:\ArcpyBook\Appendix1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the command line, type the following and press on the *Enter* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again you should see the output detailing the attribute fields for the
    `Burglaries_2009.shp` file. The difference is that your script no longer has a
    hardcoded workspace and feature class name. You now have a more flexible script
    capable of listing the attribute fields for any feature class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sys` module contains a list of objects called `argv[]`, which is used to
    store the input parameters for the command-line execution of a Python script.
    The first item stored in the list is always the name of the script. So, in this
    case, `sys.argv[0]` contains the word `ListFields.py`. Two parameters are passed
    into the script, including the workspace and a feature class. These are stored
    in `sys.argv[1]` and `sys.argv[2]` respectively. These values are then assigned
    to variables and used in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Python scripts to batch files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scheduling your Python scripts to run at prescribed times will require that
    you create a batch file containing one or more scripts and/or operating system
    commands. These batch files can then be added to the Windows Scheduler to run
    at a specific time interval.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Batch files are text files containing command-line sequences for running Python
    scripts or performing operating system commands. They have a file extension of
    `.bat`, which Windows recognizes as an executable file. Since batch files simply
    contain command-line sequences, they can be written with any text editor, though
    it is recommended that you use a basic text editor such as Notepad, so that you
    can avoid the inclusion of invisible special characters, which are sometimes inserted
    by programs such as Microsoft Word. In this recipe, you will create a simple batch
    file that navigates to the directory containing your `ListFields.py` script and
    executes it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a batch file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a notepad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of text to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file to your desktop as `ListFields.bat`. Make sure you change the
    **Save as Type** drop-down list to **All Files**, or else you'll wind up with
    a file called `ListFields.bat.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Windows, navigate to your desktop and double-click on `ListFields.bat` to
    execute the sequence of commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A command prompt will be displayed during execution. After the commands have
    been executed, the command prompt will automatically close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows treats a batch file as an executable, so double-clicking on the file
    will automatically execute the sequence of commands contained within the file
    in a new command prompt window. All `print` statements will be written to the
    window. After the commands have been executed, the command prompt will automatically
    close. In the event that you need to keep track of the output, you can write the
    statements to an output log file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Batch files can contain variables, loops, comments, and conditional logic. This
    functionality is beyond the scope of this recipe. However, if you'll be writing
    and running many scripts for your organization, it's worthwhile to spend some
    time learning more about batch files. Batch files have been around for a long
    time, so there is no shortage of information about these files on the Web. For
    more information about batch files, please consult the Wikipedia page for this
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling batch files to run at prescribed times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once created, your batch files can then be scheduled to run at prescribed times
    using the Windows Scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many geoprocessing scripts are time-intensive and best run after hours when
    they can take full advantage of system resources and free up your time to concentrate
    on other tasks. In this recipe, you will learn how to use the Windows Scheduler
    to schedule the execution of your batch files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to schedule a batch file with the Windows Scheduler:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Windows Scheduler by going to **Start** | **Programs** | **Accessories**
    | **System Tools** | **Control Panel** | **Administrative Tools**. Select **Task
    Scheduler**. The scheduler should appear, as shown in the following screenshot:![How
    to do it...](img/4445_A1_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Action** menu item and then **Create Basic Task** to display the
    **Create Basic Task Wizard** dialog box, as shown in the next screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your task a name. In this case, we will call `it List Fields from a Feature
    Class`. Click on **Next**:![How to do it...](img/4445_A1_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a trigger for when the task should be executed. This can, and often will
    be, a time-based trigger, but there can also be other types of triggers such as
    a user login or computer start. In this case, let's just select **Daily**. Click
    on **Next**:![How to do it...](img/4445_A1_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a start date/time as well as a recurrence interval. In the following
    screenshot, I have selected the date as `12/3/2012`, with time as `1:00:00 AM`,
    and a recurrence interval of 1 day. So, every day at 1:00 AM, this task will be
    executed. Click on **Next**:![How to do it...](img/4445_A1_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Start a program** as the action:![How to do it...](img/4445_A1_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to your script and add the parameters. Click on **Next**:![How to do
    it...](img/4445_A1_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish** to add a task to the scheduler:![How to do it...](img/4445_A1_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tasks should now be displayed in the list of active tasks:![How to do it...](img/4445_A1_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Windows Task Scheduler keeps track of all the active tasks and handles the
    execution of these tasks when the prescribed trigger is fired. In this recipe,
    we have scheduled our task to execute each day at 1:00 AM. At that time, the batch
    file we created will be triggered and the arguments we specified when creating
    the task will be passed into the script. Using the scheduler to automatically
    execute geoprocessing tasks after hours without the need for GIS staff to interact
    with the scripts gives you more flexibility and increases your efficiency. You
    might also want to consider logging the errors in your Python scripts to a log
    file, for more information about specific problems.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B. Five Things Every GIS Programmer Should Know How to Do with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a delimited text file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ZIP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to write scripts that perform general purpose
    tasks with Python. Tasks, such as reading and writing delimited text files, sending
    e-mails, interacting with FTP servers, creating `.zip` files, and reading and
    writing JSON and XML files. Every GIS programmer should know how to write Python
    scripts that incorporate this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a delimited text file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File handling with Python is a very important topic for GIS programmers. Text
    files are often used as an interchange format for exchanging data between systems.
    They are simple, cross-platform, and easy to process. Comma-and tab-delimited
    text files are among the most commonly used formats for text files, so we'll take
    an extensive look at the Python tools available for processing these files. A
    common task for GIS programmers is to read comma-delimited text files containing
    x and y coordinates along with other attribute information. This information is
    then converted into GIS data formats, such as shapefiles or geodatabases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Python's built-in file processing functionality, you must first open
    the file. Once open, data within the file is processed using functions provided
    by Python, and finally the file is closed. Always remember to close the file when
    you're done.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to open, read, process, and close a comma-delimited
    text file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Python script that reads a comma-delimited text
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your `c:\ArcpyBook\data` folder, you will find a file called `N_America.A2007275.txt`.
    Open this file in a text editor. It should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file contains wildfire incident data derived from a satellite sensor from
    a single day in 2007\. Each row contains latitude and longitude information for
    the fire along with additional information, including the date and time, the satellite
    type, confidence value, and others. In this recipe, you are going to pull out
    only the latitude, longitude, and confidence value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\ReadDelimitedTextFile.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the Python `open()` function to open the file for reading:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the content of the text file into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `for` loop to iterate all the rows that have been read into the `lstFires`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `split()` function to split the values into a list using a comma as
    the delimiter. The list will be assigned to a variable called `lstValues`. Make
    sure that you indent this line of code inside the `for` loop you just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the index values that reference latitude, longitude, and confidence values,
    create new variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the values of each with the `print` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python's `open()` function creates a file object, which serves as a link to
    a file residing on your computer. You must call the `open()` function on a file
    before reading or writing data in a file. The first parameter for the `open()`
    function is a path to the file you'd like to open. The second parameter of the
    `open()` function corresponds to a mode, which is typically read (`r`), write
    (`w`), or append (`a`). A value of `r` indicates that you'd like to open the file
    for read-only operations, while a value of `w` indicates you'd like to open the
    file for write operations. If the file you open in write mode already exists,
    it will overwrite any existing data in the file, so be careful using this mode.
    Append mode (`a`) will open a file for write operations, but instead of overwriting
    any existing data, it will append data to the end of the file. So, in this recipe,
    we have opened the `N_America.A2007275.txt` file in read-only mode.
  prefs: []
  type: TYPE_NORMAL
- en: The `readlines()` function then reads the entire contents of the file into a
    Python list, which can then be iterated. This list is stored in a variable called
    `lstFires`. Each row in the text file will be a unique value in the list. Since
    this function reads the entire file into a list, you need to use this method with
    caution, as large files can cause significant performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `for` loop, which is used to loop through each of the values in
    `lstFires`, the `split()` function is used to create a list object from a line
    of text that is delimited in some way. Our file is comma-delimited, so we can
    use `split(",")`. You can also split based on other delimiters such as tabs, spaces,
    or any other delimiter. This new list object created by `split()` is stored in
    a variable called `lstValues`. This variable contains each of the wildfire values.
    This is illustrated in the following screenshot. You''ll notice that latitude
    is located in the first position, longitude is located in the second position,
    and so on. Lists are zero based:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4445_A2_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the index values (which reference latitude, longitude, and confidence
    values), we create new variables called `latitude`, `longitude`, and `confid`.
    Finally, we print each of the values. A more robust geoprocessing script might
    write this information into a feature class using an `InsertCursor` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as is the case with reading files, there are a number of methods that you
    can use to write data to a file. The `write()` function is probably the easiest
    to use. It takes a single string argument and writes it to a file. The `writelines()`
    function can be used to write the contents of a list structure to a file. Before
    writing data to a text file, you will need to open the file in either a write
    or append mode.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There will be occasions when you may need to send an e-mail from a Python script.
    An example might be an alert for the successful completion or error in a long-running
    geoprocessing operation. On these and other occasions, sending an e-mail can be
    helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sending an e-mail through a Python script will require that you have access
    to a mail server. This can be a public e-mail service, such as Yahoo, Gmail, or
    others. It can also use outgoing mail servers configured with applications, such
    as Microsoft Outlook. In either case, you'll need to know the host name and port
    of the e-mail server. The Python `smtplib` module is used to create connections
    to the mail server and to send e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `email` module contains a `Message` class that represents e-mail
    messages. Each message contains both headers and a body. This class can't be used
    to send e-mails; it just handles its object representation. In this recipe, you'll
    learn how to use the `smtp` class to send e-mails containing an attachment through
    your script. The `Message` class can parse a stream of characters or a file containing
    an e-mail using either the `message_from_file()` or `message_from_string()` functions.
    Both will create a new `Message` object. The body of the mail can be obtained
    by calling `Message.getpayload()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using the Google Mail service for this exercise. If you already have
    a Gmail account, then simply provide your username and password as the values
    for these variables. If you don't have a Gmail account, you'll need to create
    one or use a different mail service to complete this exercise; Gmail accounts
    are free.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a script that can send emails:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\SendEmail.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to send e-mails with attachments, you''re going to need to import
    the `smtplib` module along with the `os` module, and several classes from the
    e-mail module. Add the following `import` statements to your script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the following variables and assign your Gmail username and password
    as the values. Do keep in mind that this method of e-mailing from your Python
    script can invite problems, as it requires that you include your username and
    password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new Python function called `mail()`. This function will accept four
    parameters: `to`, `subject`, `text`, and `attach`. Each of these parameters should
    be self-explanatory. Create a new `MIMEMultipart` object and assign the `from`,
    `to`, and `subject` keys. You can also attach the text of the e-mail to this new
    `msg` object using `MIMEMultipart.attach()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach the file to the e-mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new SMTP object that references the Google Mail service, passes in
    the username and password to connect to the mail services, sends the e-mail, and
    closes the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `mail()` function, passing in the recipient of the e-mail, a subject
    for the e-mail, the text of the e-mail, and the attachment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and run the script. For testing, I used my personal Yahoo account as the
    recipient. You'll notice that my inbox has a new message from my Gmail account;
    also notice the attachment:![How to do it…](img/4445_A2_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first parameter passed into the `mail()` function is the e-mail address
    that will receive the e-mail. This can be any valid e-mail address, but you'll
    want to supply a mail account that you can actually check, so that you can make
    sure your script runs correctly. The second parameter is just the subject line
    of the e-mail. The third parameter is the text of the e-mail. The final parameter
    is the name of a file that will be attached to the e-mail. Here, I've simply defined
    that the `bc_pop1996.csv` file should be attached. You can use any file you have
    access to, but you may want to just use this file for testing.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `MIMEMultipart` object inside the `mail()` function, and
    assign the `from`, `to`, and `subject` keys. You can also attach the text of the
    e-mail to this new `msg` object using `MIMEMultipart.attach()`. The `bc_pop1996.csv`
    file is then attached to the e-mail using a `MIMEBase` object and attached to
    the e-mail using `msg.attach(part)`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've examined how a basic text e-mail can be sent. However,
    we want to send a more complex e-mail message that contains text and an attachment.
    This requires the use of MIME messages, which provides the functionality to handle
    multi-part e-mails. MIME messages need boundaries between the multiple parts,
    along with extra headers to specify the content being sent. The `MIMEBase` class
    is an abstract subclass of `Message` and enables this type of an e-mail to be
    sent. Because it is an abstract class, you can't create actual instances of this
    class. Instead, you use one of the subclasses, such as `MIMEText`. The last step
    of the `mail()` function is to create a new SMTP object that references the Google
    Mail service, passes in the username and password to connect to the mail services,
    sends the e-mail, and closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving files from an FTP server for processing is a very common operation
    for GIS programmers and can be automated with a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting to an FTP server and downloading a file is accomplished through the
    `ftplib` module. A connection to an FTP server is created through the FTP object,
    which accepts a host, username, and password to create the connection. Once a
    connection has been opened, you can then search for and download files.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will connect to the National Interagency Fire Center Incident
    FTP site and download a Google Earth format file for a wildfire in Alaska.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a script that connects to an FTP server and downloads
    a file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a file called `c:\ArcpyBook\Appendix2\ftp.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll be connecting to an FTP server at the NIFC. Visit their website at [http://ftpinfo.nifc.gov/](http://ftpinfo.nifc.gov/)
    for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `ftplib`, `os`, and so`c`ket modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following variables that define the URL, directory, and filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to create a connection. If there is a connection
    error, a message will be generated. If the connection was successful, a success
    message will be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to anonymously log in to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code block to change to the directory specified in our `DIRN`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `FTP.retrbinary()` function to retrieve the KMZ file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you disconnect from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. If everything is successful, you should see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check your `c:\ArcpyBook\Appendix2` directory for the file. By default, FTP
    will download files to the current working directory:![How to do it…](img/4445_A2_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to an FTP server, you need to know the URL. You also need to know
    the directory and filename for the file that will be downloaded. In this script,
    we have hardcoded this information, so that you can focus on implementing the
    FTP-specific functionality. Using this information we then created a connection
    to the NIFC FTP server. This is done through the `ftplib.FTP()` function, which
    accepts a URL to the host.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous logins are accepted by the `nifc.gov` server, so we connect to the
    server in this manner. Keep in mind that if a server does not accept anonymous
    connections, you'll need to obtain a username/password. Once logged in, the script
    then changes directories from the root of the FTP server to the path defined in
    the `DIRN` variable. This was accomplished with the `cwd(<path>)` function. The
    `kmz` file was retrieved using the `retrbinary()` function. Finally, you will
    want to close your connection to the FTP server when you're done. This is done
    with the `quit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of additional FTP-related methods that you can use to perform
    various actions. Generally, these can be divided into directory-level operations
    and file-level operations. Directory-level methods include the `dir()` method
    to obtain a list of files in a directory, `mkd()` to create a new directory, `pwd()`
    to get the current working directory, and `cwd()` to change the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `ftplib` module also includes various methods for working with files. You
    can upload and download files in binary or plain text format. The `retrbinary()`
    and `storbinary()` methods are used to retrieve and store binary files, respectively.
    Plain text files can be retrieved and stored using `retrlines()` and `storlines()`.
  prefs: []
  type: TYPE_NORMAL
- en: There are several others methods on the FTP class that you should be aware of.
    Deleting a file can be done with the `delete()` method, while renaming a file
    can be accomplished with `rename()`. You can also send commands to the FTP server
    through the `sendcmd()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ZIP files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GIS often requires the use of large files that will be compressed into a `.zip`
    format for ease of sharing. Python includes a module that you can use to decompress
    and compress files in this format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Zip is a common compression and archive format and is implemented in Python
    through the `zipfile` module. The `ZipFile` class can be used to create, read,
    and write `.zip` files. To create a new `.zip` file, simply provide the filename
    along with a mode such as `w`, which indicates that you want to write data to
    the file. In the following code example, we are creating a `.zip` file called
    `datafile.zip`. The second parameter, `w`, indicates that a new file will be created.
    A new file will be created or an existing file with the same name will be truncated
    in the write mode. An optional compression parameter can also be used when creating
    the file. This value can be set to either `ZIP_STORED` or `ZIP_DEFLATED`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you will use Python to create file, add files, and apply compression
    to a `.zip`. You'll be archiving all the shapefiles located in the `c:\ArcpyBook\data`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a script that build a `.zip` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IDLE and create a script called `c:\ArcpyBook\Appendix2\CreateZipfile.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `zipfile` and `os` modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `.zip` file called `shapefiles.zip` in write mode and add a compression
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll use the `os.listdir()` function to create a list of files in the
    data directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through a list of all the files and write to the `.zip` file, if the file
    ends with `shp`, `dbf`, or `shx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out a list of all the files that were added to the zip archive. You can
    use the ZipFile.namelist() function to create a list of files in the archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `.zip` archive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire script should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Windows Explorer, you should be able to see the output `.zip` file as shown
    in the following screenshot. Note the size of the archive. This file was created
    without compression:![How to do it…](img/4445_A2_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''re going to create a compressed version of the `.zip` file to see
    the difference. Make the following changes to the line of code that creates the
    `.zip` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and re-run the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take a look at the size of the new `shapefiles2.zip` file that you just created.
    Note the decreased size of the file due to compression:![How to do it…](img/4445_A2_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you created a new `.zip` file called `shapefiles.zip` in write
    mode. In the first iteration of this script, you didn't compress the contents
    of the file. However, in the second iteration, you did by using the `DEFLATED`
    parameter passed into the constructor for the `ZipFile` object. The script then
    obtained a list of files in the data directory and looped through each of the
    files. Each file that has an extension of `.shp`, `.dbf`, or `.shx` is then written
    to the archive file using the `write()` function. Finally, the names of each of
    the files written to the archive is printed to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The contents of an existing file stored in a ZIP archive can be read using the
    `read()` method. The file should first be opened in a read mode, and then you
    can call the `read()` method passing in a parameter that represents the filename
    that should be read. The contents of the file can then be printed to the screen,
    written to another file, or stored as a list or dictionary variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XML files were designed as a way to transport and store data. They are platform
    independent, since the data is stored in a plain text file. Although similar to
    HTML, XML differs in that HTML is designed for display purposes, whereas XML data
    is designed for data. XML files are sometimes used as an interchange format for
    GIS data going between various software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML documents have a tree-like structure composed of a root element, child
    elements, and element attributes. Elements are also called **nodes** . All XML
    files contain a **root** element. This root element is the parent to all other
    elements or child nodes. The following code example illustrates the structure
    of an XML document. Unlike HTML files, XML files are case sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Python provides several programming modules that you can use to process XML
    files. The module that you use should be determined by the module that is right
    for the job. Don't try to force a single module to do everything. Each module
    has specific functions that they are good at performing. In this recipe, you will
    learn how to read data from an XML file using the `nodes` and `element` attributes
    that are a part of the document.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways that you can access nodes within an XML document.
    Perhaps, the easiest way to do so is to find nodes by tag name and then walk the
    tree containing a list of the child nodes. Before doing so, you'll want to parse
    the XML document with the `minidom.parse()` method. Once parsed, you can then
    use the `childNodes` attribute to obtain a list of all child nodes starting at
    the root of the tree. Finally, you can search the nodes by tag name with the `getElementsByTagName(tag)`
    function, which accepts a tag name as an argument. This will return a list of
    all child nodes associated with the tag.
  prefs: []
  type: TYPE_NORMAL
- en: You can also determine if a node contains an attribute by calling `hasAttribute(name)`,
    which will return a `true`/`false` value. Once you've determined that an attribute
    exists, a call to `getAttribute(name)` will obtain the value for the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will parse an XML file and pull out values associated
    with a particular element (node) and attribute. We'll be loading an XML file containing
    wildfire data. In this file, we'll be looking for the `<fire>` node and the `address`
    attribute from each of these nodes. The addresses will be printed out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open IDLE and create a script called `c:\ArcpyBook\Appendix2\XMLAccessElementAttribute.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `WitchFireResidenceDestroyed.xml` file will be used. The file is located
    in your `c:\ArcpyBook\Appendix2` folder. You can see a sample of its contents
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import `minidom` from `xml.dom`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse the XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list of nodes from the XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a list of all the `<fire>` nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through the list of elements, test for the existence of the `address`
    attribute, and print the value of the attribute if it exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the script. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loading an XML document into your script is probably the most basic thing you
    can do with XML files. You can use the `xml.dom` module to do this through the
    use of the `minidom` object. The `minidom` object has a method called `parse()`,
    which accepts a path to an XML document and creates a **document object model**
    (**DOM**) tree object from the `WitchFireResidenceDestroyed.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `childNodes` property of the DOM tree generates a list of all nodes in the
    XML file. You can then access each of the nodes using the `getElementsByTagName()`
    method. The final step is to loop through each of the `<fire>` nodes contained
    within the `eList` variable. For each node, we then check for the `address` attribute
    with the `hasAttribute()` method, and if it exists we call the `getAttribute()`
    function and print the address to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be times when you will need to search an XML document for a specific
    text string. This requires the use of the `xml.parsers.expat` module. You'll need
    to define a search class derived from the basic `expat` class and then create
    an object from this class. Once created, you can call the `parse()` method on
    the search object to search for data. Finally, you can then search the nodes by
    tag name with the `getElementsByTagName(tag)` function, which accepts a tag name
    as an argument. This will return a list of all child nodes associated with the
    tag.
  prefs: []
  type: TYPE_NORMAL
