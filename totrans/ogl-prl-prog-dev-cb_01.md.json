["```py\n    __kernel void vector_multiplication(__global int* a, \n                                        __global int* b,\n                                        __global int* c) {\n    int threadId = get_global_id(0); // OpenCL function\n    c[i] = a[i] * b[i];\n    }\n    ```", "```py\n#include <stdio.h>\n#include <stdlib.h>\n\n#ifdef APPLE\n#include <OpenCL/cl.h>\n#else\n#include <CL/cl.h>\n#endif\n\nvoid displayPlatformInfo(cl_platform_id id,\n                         cl_platform_info param_name,\n                         const char* paramNameAsStr) {\n    cl_int error = 0;\n    size_t paramSize = 0;\n\n    error = clGetPlatformInfo( id, param_name, 0, NULL,\n                               &paramSize );\n    char* moreInfo = (char*)alloca( sizeof(char) * paramSize);\n    error = clGetPlatformInfo( id, param_name, paramSize,\n                               moreInfo, NULL );\n    if (error != CL_SUCCESS ) {\n        perror(\"Unable to find any OpenCL platform\n                information\");\n        return;\n    }\n    printf(\"%s: %s\\n\", paramNameAsStr, moreInfo);\n}\n\nint main() {\n   /* OpenCL 1.2 data structures */\n   cl_platform_id* platforms;\n   /* OpenCL 1.1 scalar data types */\n   cl_uint numOfPlatforms;\n   cl_int  error;\n\n   /* \n      Get the number of platforms \n      Remember that for each vendor's SDK installed on the\n      Computer, the number of available platform also\n      increased. \n    */\n   error = clGetPlatformIDs(0, NULL, &numOfPlatforms);\n   if(error < 0) {      \n      perror(\"Unable to find any OpenCL platforms\");\n      exit(1);\n   }\n   // Allocate memory for the number of installed platforms.\n   // alloca(...) occupies some stack space but is\n   // automatically freed on return\n   platforms = (cl_platform_id*) alloca(sizeof(cl_platform_id)\n               * numOfPlatforms);\n   printf(\"Number of OpenCL platforms found: %d\\n\",\n           numOfPlatforms);\n\n   // We invoke the API 'clPlatformInfo' twice for each\n   // parameter we're trying to extract\n   // and we use the return value to create temporary data\n   // structures (on the stack) to store\n   // the returned information on the second invocation.\n   for(cl_uint i = 0; i < numOfPlatforms; ++i) {\n        displayPlatformInfo( platforms[i], \n                             CL_PLATFORM_PROFILE,\n                             \"CL_PLATFORM_PROFILE\" );\n\n        displayPlatformInfo( platforms[i], \n                             CL_PLATFORM_VERSION,\n                             \"CL_PLATFORM_VERSION\" );\n\n        displayPlatformInfo( platforms[i], \n                             CL_PLATFORM_NAME,   \n                             \"CL_PLATFORM_NAME\" );\n\n        displayPlatformInfo( platforms[i], \n                             CL_PLATFORM_VENDOR, \n                             \"CL_PLATFORM_VENDOR\" );\n\n        displayPlatformInfo( platforms[i], \n                             CL_PLATFORM_EXTENSIONS,\n                             \"CL_PLATFORM_EXTENSIONS\" );\n   }\n   return 0;\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o platform_details platform_details.c –framework OpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nCL_PLATFORM_PROFILE: FULL_PROFILE\nCL_PLATFORM_VERSION: OpenCL 1.0 (Dec 23 2010 17:30:26)\nCL_PLATFORM_NAME: Apple\nCL_PLATFORM_VENDOR: Apple\nCL_PLATFORM_EXTENSIONS:\n```", "```py\n| #include <stdlib.h>\n| #include <stdio.h> \n```", "```py\n| #ifdef APPLE\n| #include <OpenCL/cl.h>\n| #else\n| #include <CL/cl.h>\n| #endif\n```", "```py\n/* C-function prototype */\nvoid displayDeviceDetails(cl_device_id id, cl_device_info param_name, const char* paramNameAsStr) ; \n\n…\nvoid displayDeviceInfo(cl_platform_id id, \n                       cl_device_type dev_type) {\n    /* OpenCL 1.1 device types */\n\n    cl_int error = 0;\n    cl_uint numOfDevices = 0;\n\n    /* Determine how many devices are connected to your\n       platform */\n    error = clGetDeviceIDs(id, dev_type, 0, NULL,\n                           &numOfDevices);\n    if (error != CL_SUCCESS ) { \n        perror(\"Unable to obtain any OpenCL compliant device\n                info\");\n        exit(1);\n    }\n\n    cl_device_id* devices = (cl_device_id*)\n                  alloca(sizeof(cl_device_id) * numOfDevices);\n\n    /* Load the information about your devices into the \n       variable 'devices'\n    */\n    error = clGetDeviceIDs(id, dev_type, numOfDevices, devices,\n                           NULL);\n    if (error != CL_SUCCESS ) { \n        perror(\"Unable to obtain any OpenCL compliant device\n                info\");\n        exit(1);\n    }\n\n    printf(\"Number of detected OpenCL devices:\n            %d\\n\",numOfDevices);\n\n    /* \n      We attempt to retrieve some information about the\n      devices. \n    */\n\n    for(int i = 0; i < numOfDevices; ++ i ) {\n        displayDeviceDetails( devices[i], CL_DEVICE_TYPE, \"CL_DEVICE_TYPE\" );\n        displayDeviceDetails( devices[i], CL_DEVICE_VENDOR_ID, \"CL_DEVICE_VENDOR_ID\" );\n        displayDeviceDetails( devices[i], CL_DEVICE_MAX_COMPUTE_UNITS, \"CL_DEVICE_MAX_COMPUTE_UNITS\" );\n        displayDeviceDetails( devices[i], CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, \"CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS\" );\n        displayDeviceDetails( devices[i], CL_DEVICE_MAX_WORK_ITEM_SIZES, \"CL_DEVICE_MAX_WORK_ITEM_SIZES\" );\n        displayDeviceDetails( devices[i], CL_DEVICE_MAX_WORK_GROUP_SIZE, \"CL_DEVICE_MAX_WORK_GROUP_SIZE\" );\n    }\n}\n\nvoid displayDeviceDetails(cl_device_id id,\n                          cl_device_info param_name, \n                          const char* paramNameAsStr) {\n  cl_int error = 0;\n  size_t paramSize = 0;\n\n  error = clGetDeviceInfo( id, param_name, 0, NULL, &paramSize );\n  if (error != CL_SUCCESS ) {\n    perror(\"Unable to obtain device info for param\\n\");\n    return;\n  }\n\n  /* \n    The cl_device_info are preprocessor directives defined in cl.h\n  */\n\n  switch (param_name) {\n    case CL_DEVICE_TYPE: {\n            cl_device_type* devType = (cl_device_type*)\n                        alloca(sizeof(cl_device_type) * paramSize);\n            error = clGetDeviceInfo( id, param_name, paramSize, devType, NULL );\n\n            if (error != CL_SUCCESS ) {\n                perror(\"Unable to obtain device info for param\\n\");\n                return;\n            }\n\n            switch (*devType) {\n              case CL_DEVICE_TYPE_CPU : \n                   printf(\"CPU detected\\n\");break;\n              case CL_DEVICE_TYPE_GPU : \n                   printf(\"GPU detected\\n\");break;\n              case CL_DEVICE_TYPE_DEFAULT : \n                   printf(\"default detected\\n\");break;\n            }\n            }break;\n\n     // omitted code – refer to source \"device_details.c\"\n   } //end of switch\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o device_details device_details.c   -framework OpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nCL_PLATFORM_PROFILE: FULL_PROFILE\nCL_PLATFORM_VERSION: OpenCL 1.0 (Dec 23 2010 17:30:26)\nCL_PLATFORM_NAME: Apple\nCL_PLATFORM_VENDOR: Apple\nCL_PLATFORM_EXTENSIONS: \nNumber of detected OpenCL devices: 2\nGPU detected\n  VENDOR ID: 0x1022600\n  Maximum number of parallel compute units: 6\n  Maximum dimensions for global/local work-item IDs: 3\n  Maximum number of work-items in each dimension: 512\n  Maximum number of work-items in a work-group: 512\nCPU detected\n  VENDOR ID: 0x1020400\n  Maximum number of parallel compute units: 4\n  Maximum dimensions for global/local work-item IDs: 3\n  Maximum number of work-items in each dimension: 1\n  Maximum number of work-items in a work-group: 1\n```", "```py\nvoid displayDeviceDetails(cl_device_id id,\n                          cl_device_info param_name, \n                          const char* paramNameAsStr) {\n\n  cl_int error = 0;\n  size_t paramSize = 0;\n\n  error = clGetDeviceInfo( id, param_name, 0, NULL, &paramSize );\n  if (error != CL_SUCCESS ) {\n    perror(\"Unable to obtain device info for param\\n\");\n    return;\n  }\n  /* the cl_device_info are preprocessor directives defined in cl.h\n  */\n  switch (param_name) {\n    // code omitted – refer to \"device_extensions.c\"\n    case CL_DEVICE_EXTENSIONS : {\n  size_t* ret = (size_t*) alloc(sizeof(size_t) * paramSize);\n           error = clGetDeviceInfo( id, param_name, paramSize, ret, NULL );\n           char* extension_info = (char*)malloc(sizeof(char) * (*ret));\n           error = clGetDeviceInfo( id, CL_DEVICE_EXTENSIONS, sizeof(extension_info), extension_info, NULL);\n           printf(\"\\tSupported extensions: %s\\n\",\n                  extension_info);\n           }break;\n  } //end of switch\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o device_extensions device_extensions.c   -framework OpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nCL_PLATFORM_PROFILE: FULL_PROFILE\nCL_PLATFORM_VERSION: OpenCL 1.0 (Dec 23 2010 17:30:26)\nCL_PLATFORM_NAME: Apple\nCL_PLATFORM_VENDOR: Apple\nCL_PLATFORM_EXTENSIONS: \nNumber of detected OpenCL devices: 2\nGPU detected\n  VENDOR ID: 0x1022600\n  Maximum number of parallel compute units: 6\n  Maximum dimensions for global/local work-item IDs: 3\n  Maximum number of work-items in each dimension: ( 512 512 64  )\n  Maximum number of work-items in a work-group: 512\n  Supported extensions: cl_khr_byte_addressable_store cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_APPLE_gl_sharing cl_APPLE_SetMemObjectDestructor cl_APPLE_ContextLoggingFunctions cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics \nCPU detected\n  VENDOR ID: 0x1020400\n  Maximum number of parallel compute units: 4\n  Maximum dimensions for global/local work-item IDs: 3\n  Maximum number of work-items in each dimension: ( 1 1 1  )\n  Maximum number of work-items in a work-group: 1\n  Supported extensions: cl_khr_fp64 cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_byte_addressable_store cl_APPLE_gl_sharing cl_APPLE_SetMemObjectDestructor cl_APPLE_ContextLoggingFunctions\n```", "```py\nvoid createAndReleaseContext(cl_platform_id id, \n                             cl_device_type dev_type) {\n    /* OpenCL 1.1 scalar types */\n    cl_int error = 0;\n    cl_uint numOfDevices = 0;\n\n /* Determine how many devices are connected to your platform */\n    error = clGetDeviceIDs(id, dev_type, 0, NULL, &numOfDevices);\n    if (error != CL_SUCCESS ) { \n        perror(\"Unable to obtain any OpenCL compliant device info\");\n        exit(1);\n    }\n    cl_device_id* devices = (cl_device_id*)\n                     alloca(sizeof(cl_device_id) * numOfDevices);\n\n    /* \n     Load the information about your devices into the variable\n     'devices'\n    */\n\n    error = clGetDeviceIDs(id, dev_type, numOfDevices, devices, NULL);\n    if (error != CL_SUCCESS ) { \n        perror(\"Unable to obtain any OpenCL compliant device info\");\n        exit(1);\n    }\n\n    printf(\"Number of detected OpenCL devices: %d\\n\",\n            numOfDevices);\n\n    /* \n       We attempt to create contexts for each device we find,\n       report it and release the context. Once a context is\n       created, its context is implicitly\n       retained and so you don't have to invoke\n      'clRetainContext'\n     */\n\n    for(int i = 0; i < numOfDevices; ++ i ) {\n        cl_context context = clCreateContext(NULL, 1,\n                                             &devices[i],\n                                             NULL, NULL,\n                                             &error); \n        cl_uint ref_cnt = 0;\n        if (error != CL_SUCCESS) {\n            perror(\"Can't create a context\");\n            exit(1);\n        }\n\n        error = clGetContextInfo(context,\n                                 CL_CONTEXT_REFERENCE_COUNT,\n                                 sizeof(ref_cnt), &ref_cnt,\n                                 NULL);\n\n        if (error != CL_SUCCESS) {\n            perror(\"Can't obtain context information\");\n            exit(1);\n        }\n        printf(\"Reference count of device is %d\\n\", ref_cnt);\n        // Release the context\n        clReleaseContext(context);\n    }\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o context_details context_details.c   -framework OpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nNumber of detected OpenCL devices: 2\nReference count of device is 1\nReference count of device is 1\n```", "```py\ncl_program clCreateProgramWithSource(cl_context context,\n                                     cl_uint count,\n                                     const char** strings,\n                                     const size_t* lengths,\n                                     cl_int* errcode_ret)\n```", "```py\ncl_program clCreateProgramWithBinary(cl_context context,\n                                     cl_uint num_devices,\n                                     const cl_device_id* device_list,\n                                     const size_t* lengths,\n                                     const unsigned char** binaries,\n                                     cl_int* binary_status,\n                                     cl_int* errcode_ret)\n```", "```py\nint main(int argc, char** argv) {\n   // code omitted – refer to \"build_opencl_program.c\"\n   ...\n   // Search for a CPU/GPU device through the installed\n   // platform. Build a OpenCL program and do not run it.\n   for(cl_uint i = 0; i < numOfPlatforms; i++ ) {\n       // Get the GPU device\n       error = clGetDeviceIDs(platforms[i], \n                              CL_DEVICE_TYPE_GPU, 1,\n                              &device, NULL);\n       if(error != CL_SUCCESS) {\n          // Otherwise, get the CPU\n          error = clGetDeviceIDs(platforms[i],\n                                 CL_DEVICE_TYPE_CPU,\n                                 1, &device, NULL);\n       }\n        if(error != CL_SUCCESS) {\n            perror(\"Can't locate any OpenCL compliant device\");\n            exit(1);\n        }\n        /* Create a context */\n        context = clCreateContext(NULL, 1, &device, NULL, NULL,\n                                  &error);\n        if(error != CL_SUCCESS) {\n            perror(\"Can't create a valid OpenCL context\");\n            exit(1);\n        }\n\n        /* Load the two source files into temporary \n           datastores */\n        const char *file_names[] = {\"simple.cl\",\n                                    \"simple_2.cl\"};\n        const int NUMBER_OF_FILES = 2;\n        char* buffer[NUMBER_OF_FILES];\n        size_t sizes[NUMBER_OF_FILES];\n        loadProgramSource(file_names, NUMBER_OF_FILES, buffer,\n                          sizes);\n\n        /* Create the OpenCL program object */\n        program = clCreateProgramWithSource(context,\n                                            NUMBER_OF_FILES,\n                                            (const\n                                             char**)buffer,\n                                            sizes, &error);      \n      if(error != CL_SUCCESS) {\n        perror(\"Can't create the OpenCL program object\");\n        exit(1);   \n      }\n\n        /* \n         Build OpenCL program object and dump the error\n         message, if any\n        */\n        char *program_log;\n        const char options[] = \"-cl-finite-math-only \\\n                                -cl-no-signed-zeros\";  \n        size_t log_size;\n        error = clBuildProgram(program, 1, &device, options,\n                               NULL,NULL);\t\t\n        // Uncomment the line below, comment the line above;\n        // build the program to use build options dynamically\n        // error = clBuildProgram(program, 1, &device, argv[1],\n        // NULL, NULL);    \n\n      if(error != CL_SUCCESS) {\n        // If there's an error whilst building the program,\n            // dump the log\n        clGetProgramBuildInfo(program, device,\n                                  CL_PROGRAM_BUILD_LOG, 0,\n                                  NULL,\n                                  &log_size);\n        program_log = (char*) malloc(log_size+1);\n        program_log[log_size] = '\\0';\n        clGetProgramBuildInfo(program, device,\n                                  CL_PROGRAM_BUILD_LOG, \n                                  log_size+1, program_log,\n                                  NULL);\n        printf(\"\\n=== ERROR ===\\n\\n%s\\n=============\\n\",\n                   program_log);\n        free(program_log);\n        exit(1);\n      }\n\n        /* Clean up */\n        for(i=0; i< NUMBER_OF_FILES; i++) { free(buffer[i]); }\n        clReleaseProgram(program);\n        clReleaseContext(context);\n   }\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o build_opencl_program build_opencl_program.c   -framework OpenCL\n\n```", "```py\nconst char options[] = \"-cl-nosigned-zeros –cl-finite-math-only\";\nerror = clBuildProgram(program, 1, &device, options, NULL, NULL);\n```", "```py\nerror = clBuildProgram(program, 1, &device, argv[1], NULL, NULL);\n```", "```py\n./build_opencl_program -D\"-cl-finite-math-only -cl-no-signed-zeros\"\n\n```", "```py\nconst char *file_names[] = {\"simple.cl\",\n                            \"simple_2.cl\"};\n```", "```py\n__kernel void simpleAdd(__global float *a,\n                        __global float *b,\n                        __global float *c) {\n\n  int gid = get_global_id(0);\n   c[gid] = a[gid] + b[gid];\n}\n```", "```py\ncl_kernel clCreateKernel(cl_program program,\n                         const char* kernel_name,\n                         cl_int* errcode_ret) \n```", "```py\ncl_int clCreateKernelsInProgram(cl_program program,\n                                cl_uint num_kernels,\n                                cl_kernel* kernels,\n                                cl_uint* num_kernels_ret)\n```", "```py\n        /* \n         Query the program as to how many kernels were detected \n         */\n        cl_uint numOfKernels;\n        error = clCreateKernelsInProgram(program, 0, NULL,\n                                         &numOfKernels);\n        if (error != CL_SUCCESS) {\n            perror(\"Unable to retrieve kernel count from\n                    program\");\n            exit(1);\n        }\n        cl_kernel* kernels = (cl_kernel*)\n                             alloca(sizeof(cl_kernel) *\n                                                 numOfKernels);\n        error = clCreateKernelsInProgram(program, numOfKernels,\n                                         kernels, NULL);\n\n        for(cl_uint i = 0; i < numOfKernels; i++) {\n            char kernelName[32];\n            cl_uint argCnt;\n            clGetKernelInfo(kernels[i],\n                            CL_KERNEL_FUNCTION_NAME,\n                            sizeof(kernelName), \n                            kernelName, NULL);\n            clGetKernelInfo(kernels[i], CL_KERNEL_NUM_ARGS,\n                            sizeof(argCnt), &argCnt, NULL);\n            printf(\"Kernel name: %s with arity: %d\\n\",\n                    kernelName,\n                    argCnt);\n        }\n        /* Release the kernels */\n        for(cl_uint i = 0; I < numOfKernels; i++) \n            clReleaseKernel(kernels[i]);\n```", "```py\nNumber of OpenCL platforms found: 1\nKernel name: simpleAdd with arity: 3\nKernel name: simpleAdd_2 with arity: 3\n\n```", "```py\n__kernel void hello(__global char* data) {              \n} \n```", "```py\ncl_kernel* kernels = (cl_kernel*) alloca(sizeof(cl_kernel) *\n                                         numOfKernels);\nerror = clCreateKernelsInProgram(program, numOfKernels,\n                                 kernels, NULL);\nfor(cl_uint i = 0; i < numOfKernels; i++) {\n    char kernelName[32];\n    cl_uint argCnt;\n    clGetKernelInfo(kernels[i], CL_KERNEL_FUNCTION_NAME,\n                    sizeof(kernelName), kernelName, NULL);\n    clGetKernelInfo(kernels[i], CL_KERNEL_NUM_ARGS,\n                    sizeof(argCnt),\n                    &argCnt, NULL);\n    printf(\"Kernel name: %s with arity: %d\\n\", kernelName,\n            argCnt);\n    printf(\"About to create command queue and enqueue this\n            kernel...\\n\");\n\n    /* Create a command queue */\n    cl_command_queue cQ = clCreateCommandQueue(context, \n                                               device,\n                                               0,\n                                               &error);\n    if (error != CL_SUCCESS) { \n        perror(\"Unable to create command-queue\");\n        exit(1);\n    }\n    /* Create a OpenCL buffer object */\n   cl_mem strObj = clCreateBuffer(context,CL_MEM_READ_ONLY |\n                                          CL_MEM_COPY_HOST_PTR,\n                                          sizeof(char) * 11,\n                                          \"dummy value\", NULL);\n\n   /* \n     Let OpenCL know that the kernel is suppose to receive an\n     Argument\n   */\n   error = clSetKernelArg(kernels[i], \n                          0, \n                          sizeof(cl_mem), \n                          &strObj);\n   if (error != CL_SUCCESS) { \n       perror(\"Unable to create buffer object\");\n       exit(1);\n   }\n   /* Enqueue the kernel to the command queue */\n   error = clEnqueueTask(cQ, kernels[i], 0, NULL, NULL);\n\n   if (error != CL_SUCCESS) { \n       perror(\"Unable to enqueue task to command-queue\");\n       exit(1);\n   }\n   printf(\"Task has been enqueued successfully!\\n\");\n   /* Release the command queue */\n   clReleaseCommandQueue(cQ);\n}\n/* Clean up */\nfor(cl_uint i = 0; i < numOfKernels; i++) {\n    clReleaseKernel(kernels[i]);\n}\n```", "```py\ngcc -std=c99 -Wall -DUNIX -g -DDEBUG -DAPPLE -arch i386 -o kernel_queue kernel_queue.c   -framework OpenCL\n\n```", "```py\nNumber of OpenCL platforms found: 1\nKernel name: hello with arity: 1\nAbout to create command queue and enqueue this kernel...\nTask has been enqueued successfully!\n\n```"]