["```py\nfor(int i = 0; i  < n; ++i ) { ... }\n```", "```py\n#pragma unroll <unroll-factor>\n#pragma unroll 10\nfor(int i = 0; i < n; ++i) { ... }\n```", "```py\n//\n// This kernel loads 64-elements using a single thread/work-item\n// into its __private memory space and writes it back out\n__kernel void wideDataTransfer(__global float* in,__global float* out) {\n    size_t id = get_global_id(0);\n    size_t offsetA = id ;\n    size_t offsetB = (id+1);\n    size_t offsetC = (id+2);\n    size_t offsetD = (id+3);\n\n    // each work-item loads 64-elements\n    float16 A = vload16(offsetA, in);\n    float16 B = vload16(offsetB, in);\n    float16 C = vload16(offsetC, in);\n    float16 D = vload16(offsetD, in);\n\n    vstore16(A, offsetA, out);\n    vstore16(B, offsetB, out);\n    vstore16(C, offsetC, out);\n    vstore16(D, offsetD, out);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o VectorStore vector_store.c –framework OpenCL\n\n```", "```py\nCheck passed!\n\n```", "```py\n__kernel void wideDataTransfer(__global float* in, __global float* out) {\n  size_t id = get_group_id(0) * get_local_size(0) +get_local_id(0);\n  size_t STRIDE = 16;\n  size_t offsetA = id;\n  prefetch(in + (id*64), 64);\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  float16 A = vload16(offsetA, in);\n  float a[16]; \n  a[0] = A.s0;\n  a[1] = A.s1;\n  a[2] = A.s2;\n  a[3] = A.s3;\n  a[4] = A.s4;\n  a[5] = A.s5;\n  a[6] = A.s6;\n  a[7] = A.s7;\n  a[8] = A.s8;\n  a[9] = A.s9;\n  a[10] = A.sa;\n  a[11] = A.sb;\n  a[12] = A.sc;\n  a[13] = A.sd;\n  a[14] = A.se;\n  a[15] = A.sf;\n  for( int i = 0; i < 16; ++i ) {\n    out[offsetA*STRIDE+i] = a[i];\n  }\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o VectorLoad vector_load.c –framework OpenCL\n\n```", "```py\nCheck passed!\n\n```", "```py\nprefetch(in +(id*64), 64);\n```", "```py\nout[offset*STRIDE + i] = A; // 'A' is a vector of 16 floats\n```", "```py\n__kernel void MatVecMultUsingDotFn(__global float4* matrix,__global float4* vector, __global float* result) {\n    int i = get_global_id(0);\n    result[i] = dot(matrix[i], vector[0]);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o MatVecMult matvecmult.c –framework OpenCL\n\n```", "```py\nCheck passed!\n\n```", "```py\n__kernel void MatVecMult(const __global float* M,const __global float* V, uint width, uint height,__global float* W) {\n    // Row index\n    uint y = get_global_id(0);\n    if (y < height) {\n       // Row pointer\n       const __global float* row = M + y * width;\n       // Compute dot product\n       float dotProduct = 0;\n      for (int x = 0; x < width; ++x)\n        dotProduct += row[x] * V[x];\n    // Write result to global memory\n    W[y] = dotProduct;\n    }\n}\n```", "```py\nint atomic_add(volatile __global int*p, int val)\nunsigned int atomic_add(volatile __global uint*p, uint val)\n```", "```py\n#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\n__kernel void par_min(__global uint4* src,__global uint * globalMin, __local  uint * localMin,int numOfItems) {\n    uint count = ( numOfItems / 4) / get_global_size(0);\n    uint index = get_global_id(0) * count;\n    uint stride = 1;\n    uint partialMin = (uint) -1;\n    for(int i = 0; i < count; ++i,index += stride) {\n      partialMin = min(partialMin, src[index].x);\n      partialMin = min(partialMin, src[index].y);\n      partialMin = min(partialMin, src[index].z);\n      partialMin = min(partialMin, src[index].w);\n    }\n    if(get_local_id(0) == 0) localMin[0] = (uint) -1;\n      barrier(CLK_LOCAL_MEM_FENCE);\n    atomic_min(localMin, partialMin);\n    barrier(CLK_LOCAL_MEM_FENCE);\n    if (get_local_id(0) == 0)\n      globalMin[ get_group_id[0] ] = localMin[0];\n}\n__kernel void reduce(__global uint4* src,__global uint * globalMin) {\n    atom_min(globalMin, globalMin[get_global_id(0)]);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o ParallelMin par_min.c –framework OpenCL\n\n```", "```py\nCheck passed!\n\n```", "```py\n__kernel void mad_test(__global float* a, __global float* b, __global float* c, __global float* result) {\n  float temp = mad(a, b, c);\n  result[get_global_id(0)] = temp;\n}\n__kernel void fma_test(__global float* a, __global float* b,__global float* c, __global float* result) {\n  float temp = fma(a, b, c);\n  result[get_global_id(0)] = temp;\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o FmaMadCmp fma_mad_cmp.c –framework OpenCL\n\n```", "```py\nCheck passed!\n\n```", "```py\n*sin2 + cos2 = 1*\n\n```", "```py\n__kernel void find_unit_circles(__global float16* a,__global float16* b, __global float16* result) {\n    uint id = get_global_id(0);\n    float16 x = a[id];\n    float16 y = b[id];\n    float16 tresult = sin(x) * sin(x) + cos(y) * cos(y);\n    result[id] = tresult;\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o SimpleTrigo simple_trigo.c –framework OpenCL\n\n```", "```py\nFind Unit Circle:\nUnit circle with x=1, y=1\n\n```", "```py\n__kernel void rounding_demo(__global float *mod_input, __global float *mod_output, __global float4 *round_input,__global float4 *round_output) {\n    mod_output[1] = remainder(mod_input[0], mod_input[1]);\n    round_output[0] = rint(*round_input);\n    round_output[1] = round(*round_input);\n    round_output[2] = ceil(*round_input);\n    round_output[3] = floor(*round_input);\n    round_output[4] = trunc(*round_input);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o SimpleRounding simple_rounding.c –framework OpenCL\n\n```", "```py\nInput: -4.5f, -1.5f, 1.5f, 4.5f\nRint:\nRound:\nCeil:\nFloor:\nTrunc:\n\n```", "```py\ngentype floor(gentype x);\n// gentype can be float,float2,float3,float4,float8,float16\n```", "```py\ngentype ceil(gentype x);\n// gentype can be float,float2,float3,float4,float8,float16\n```", "```py\ngentype rint(gentype x);\n// gentype can be float,float2,float3,float4,float8,float16\n```", "```py\ngentype trunc(gentype x);\n// gentype can be float,float2,float3,float4,float8,float16\n```", "```py\ngentype round(gentype x);\n// gentype can be float,float2,float3,float4,float8,float16\n```", "```py\nInput: -4.5, 1.5, 1.5, 4.5\nRint:  -4.0, -2.0, 2.0, 4.0\nRound: -5.0, -2.0, 2.0, 5.0\nCeil:  -4.0, -1.0, 2.0, 5.0\nFloor: -5.0, -2.0, 1.0, 4.0\nTrunc: -4.0, -1.0, 1.0, 4.0\n\n```", "```py\ngentypeN shuffle(gentypeM x, ugentypeN mask);\ngentypeN shuffle(gentypeM x, gentypeM y, ugentypeN mask);\n```", "```py\nuint4 mask = {0,2,4,6};\nuint4 elements = {0,1,2,3,4,5,6};\nuint4 result = shuffle(elements, mask);\n// result = {0,2,4,6};\n```", "```py\n#define ITERATIONS 6\n#define DATA_SIZE 1024\nsrandom(41L);\n  for(int iter = 0; iter < ITERATIONS; ++iter) {\n    for(int i = 0; i < DATA_SIZE; ++i) {\n      mask[i] = random() % DATA_SIZE;\n      // kernel is invoked\n    }// end of inner-for-loop\n   }//end of out-for-loop\n```", "```py\n__kernel void simple_shuffle(__global float8* a,__global float8* b, __constant uint16 mask,__global float16* result) {\n    uint id = get_global_id(0);\n    float8 in1 = a[id];\n    float8 in2 = b[id];\n    result[id] = shuffle2(in1, in2, mask);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o SimpleShuffle simple_shuffle.c –framework OpenCL\n\n```", "```py\nShuffle: -4.5f, -1.5f, 1.5f, 4.5f\n\n```", "```py\n(predicate_is_true? eval_expr_if_true : eval_expr_if_false)\n```", "```py\nif (x == 1) r = 0.5;\nif (x == 2) r = 1.0;\n```", "```py\nr = select(r, 0.5, isequal(x, 1));\nr = select(r, 1.0, isequal(x, 2));\n```", "```py\n__kernel void filter_by_selection(__global float8* a,__global float8* b, __global float8* result) {\n    uint8 mask = (uint8)(0,-1,0,-1,0,-1,0,-1);\n    uint id = get_global_id(0);\n    float8 in1 = a[id];\n    float8 in2 = b[id];\n    result[id] = select(in1, in2, mask);\n}\n```", "```py\ngcc –std=c99 –Wall –DUNIX –g –DDEBUG –DAPPLE –arch i386 –o SelectFilter simple_select.c –framework OpenCL\n\n```", "```py\nselect: -4.5f, -1.5f, 1.5f, 4.5f\n\n```"]