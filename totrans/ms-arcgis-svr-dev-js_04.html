<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Finding Peace in REST</h1></div></div></div><p>We've spent a few chapters discussing and building applications using the ArcGIS API for JavaScript. We've used different API tools to communicate with ArcGIS Server about its map services. But how does the API communicate with ArcGIS Server?</p><p>In this chapter, we'll focus on ArcGIS Server. We'll look at how it implements a REST interface. We'll review the <a id="id353" class="indexterm"/>ArcGIS REST API, outlined at <a class="ulink" href="http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/">http://resources.arcgis.com/en/help/arcgis-rest-api/#/The_ArcGIS_REST_API/02r300000054000000/</a>. This describes the file structure and the format of the data that passes between the server and the browser. Finally, we'll extend the application from the previous chapter by changing the popup highlighted symbols.</p><p>What is REST? REST <a id="id354" class="indexterm"/>stands for <strong>Representational State Transfer</strong>. It's a software architecture that focuses on the interface between server and client using a hypermedia environment. It limits the actions that can be performed between the client and the server, but provides enough user information and documentation for the user to navigate amongst data and states.</p><p>In our discussion of ArcGIS Server and REST in this chapter, we'll cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Handling REST endpoints and data formats</li><li class="listitem" style="list-style-type: disc">The hierarchy of ESRI REST Services, as seen through a browser</li><li class="listitem" style="list-style-type: disc">Common REST data in JSON format</li><li class="listitem" style="list-style-type: disc">How to use ArcGIS REST Services and JSON as defined in the REST API Requirements for a REST service</li></ul></div><p>REST is a methodology based around web pages. A website presents a state (the URL), data transfer (HTML page, CSS, and JavaScript), and a well-documented way to navigate between the different states (links). While understanding a website to be RESTful is well and good, what makes ArcGIS Server so RESTful?</p><p>In order for a web service to be <a id="id355" class="indexterm"/>considered RESTful, it must meet the following requirements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Client-Server</strong>: The roles of the client and server are clearly defined. The client doesn't care if the server contains one or one million records, and the server does not depend on a particular UI for the client. As long as the interface between the client and server remains the same, the client and server code can be changed independently.</li><li class="listitem" style="list-style-type: disc"><strong>Stateless</strong>: The client handles the state of the application, whereas the server does not have to keep up with it. The client has all it needs to make a request, including the necessary parameters and security tokens.</li><li class="listitem" style="list-style-type: disc"><strong>Cacheable</strong>: Sometimes client applications cache data for faster performance because the World Wide Web delivers data asynchronously. The server needs to tell the client which requests can be cached and for how long.</li><li class="listitem" style="list-style-type: disc"><strong>Layered system</strong>: The server-side application can be placed behind a load balancer, a secure system, or a proxy, with no noticeable effect on the client-side application.</li><li class="listitem" style="list-style-type: disc"><strong>Code on demand (optional)</strong>: The server can provide code for the client to run. Examples include Java applets or JavaScript scripts. Not all REST services do this.</li><li class="listitem" style="list-style-type: disc"><strong>Uniform interface</strong>: With a REST service, the server provides a uniform interface through which the client can interact with the data. The uniform interface can be broken down further into four principles.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Information requests that include the identification of the resource. This includes everything from the data source to the output type.</li><li class="listitem" style="list-style-type: disc">The client has enough information from a request to manipulate or delete data.</li><li class="listitem" style="list-style-type: disc">Messages from the server contain instructions about how to use them.</li><li class="listitem" style="list-style-type: disc">A state is handled by the client using hypermedia (web pages, query parameters, and session states).</li></ul></div></li></ul></div><p>If you look into the ArcGIS Server implementation, you'll see that it meets these criteria. Therefore, it's considered RESTful.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Looking at a map server</h1></div></div></div><p>ArcGIS Server <a id="id356" class="indexterm"/>provides web access to its map service contents. To access the content, you need to know the ArcGIS Server name and the site name. By default, ArcGIS Server is reached through port <code class="literal">6080</code>. It can also be reached through port <code class="literal">80</code> if it has been configured and licensed to deliver web content. REST Service endpoints can be reached through your browser with this address:</p><div><pre class="programlisting">http://&lt;GIS Server Name&gt;:6080/&lt;site name&gt;/rest/services</pre></div><p>Where <code class="literal">GIS Server Name</code> refers to the ArcGIS Server machine, and <code class="literal">site name</code> refers to the ArcGIS Server instance which, by default, is <code class="literal">arcgis</code>, the port number is optional if ArcGIS Server has been set up to deliver traffic on port <code class="literal">80</code>. This is the default port for Internet traffic.</p><p>When there <a id="id357" class="indexterm"/>are multiple GIS Servers, often handling a large load of traffic or complicated services, a web adaptor may be installed. The web adaptor routes traffic to multiple ArcGIS Servers, based on service requests, load balancing, and other related issues. The web adaptor also provides a layer of security, whereby ArcGIS Server machine names are not directly exposed to the outside world. To access the REST service through the web adaptor, use the following URL.</p><div><pre class="programlisting">http://&lt;web server name&gt;/&lt;web adaptor name&gt;/rest/services</pre></div><p>As long as ArcGIS Server is accessible from our computer, we can access information in the web browser. By default, the service data is presented as HTML. From there we can see the properties of the REST service, and follow links to other services and actions on the server. This lets developers review and test map services, independent of any application they create.</p><p>ArcGIS REST services provide a great way to view and interact with service data using HTML, which is good for presentation. Almost all of our applications will interact with the REST service through server requests. ArcGIS Server can therefore communicate through REST using another data format called JSON.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Working with JSON</h1></div></div></div><p>
<strong>JavaScript Object Notation (JSON)</strong> provides<a id="id358" class="indexterm"/> a structured data format for loosely defined data structures. A JSON object is built with other JSON objects, including strings, numbers, other objects, and arrays. Any data is allowed, as long as everything is self-contained and there is no sloppy formatting with missing brackets and braces.</p><p>There are a <a id="id359" class="indexterm"/>number of ways to test for valid JSON. Visit <a class="ulink" href="http://jsonlint.com">http://jsonlint.com</a>, where <a id="id360" class="indexterm"/>you can copy and paste your JSON and submit it for validation. It will point out missing or broken formatting issues, as well as how to resolve them.</p><p>As you read through the examples in this book you'll see that JSON isn't always formatted in the same way, especially with JSON object key fields (or property names). JSON validators require that all string items are enclosed in quotes. Single or double quotes will work, as long as you put the same marks at the end of a string as those at the beginning. This includes both JSON object key fields. JavaScript interpreters in a browser are more flexible, key fields do not have to be enclosed by quotes. It all depends on how you're testing the JSON.</p><p>Before JSON <a id="id361" class="indexterm"/>was developed, data was passed from server to client in a format called <a id="id362" class="indexterm"/><strong>Extensible Markup Language (XML)</strong>. XML is a document markup language that shows data in a format both humans and machines can read. The XML format can be read and parsed by a number of programming languages.</p><p>There are two main reasons why JSON is the preferred data format for web applications when compared to XML. First, JSON data can be consumed immediately by JavaScript applications. XML requires extra steps to parse the data into a usable object. Secondly, JSON data takes up less space. Let's explore that by comparing two snippets of data. The following snippet is written in XML:</p><div><pre class="programlisting">&lt;mountain&gt;
  &lt;name&gt;Mount Everest&lt;/name&gt;
  &lt;elevation&gt;29029&lt;/elevation&gt;
  &lt;elevationUnit&gt;ft&lt;/elevationUnit&gt;
  &lt;mountainRange&gt;Himalaya&lt;/mountainRange&gt;
  &lt;dateOfFirstAscent&gt;May 29, 1953&lt;/dateOfFirstAscent&gt;
  &lt;ascendedBy&gt;
    &lt;person&gt;
      &lt;firstName&gt;Tenzing&lt;/firstName&gt;
      &lt;lastName&gt;Norgay&lt;/lastName&gt;
    &lt;/person&gt;
    &lt;person&gt;
      &lt;firstName&gt;Edmund&lt;/firstName&gt;
      &lt;lastName&gt;Hillary&lt;/lastName&gt;
    &lt;/person&gt;
  &lt;/ascendedBy&gt;
&lt;/mountain&gt;</pre></div><p>Now, here's the same data written in JSON:</p><div><pre class="programlisting">{
  "type": "mountain",
  "name": "Mount Everest",
  "elevation": 29029,
  "elevationUnit": "ft",
  "mountainRange": "Himilaya",
  "dateOfFirstAscent": "May 29, 1953",
  "ascendedBy": [
    {
      "type": "person",
      "firstName": "Tenzing",
      "lastName": "Norgay"
    },
    {
      "type": "person",
      "firstName": "Edmund",
      "lastName": "Hillary"
    }
  ]
}</pre></div><p>The same data in <a id="id363" class="indexterm"/>JSON counts 62 characters less than that in XML. If we take out the line breaks and extra spaces, or <strong>minimize</strong> the data, the JSON data is 93 characters shorter than the minimized XML. With bandwidth at a premium, especially for mobile browsers, you can see why JSON is the preferred format for data transmission.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>JSON and PJSON formatting</h2></div></div></div><p>JSON comes <a id="id364" class="indexterm"/>in two flavors. The default JSON is minimized, with all the extra spaces and line returns removed. Pretty JSON, or PJSON for short, contains line breaks and spacing to show the structure and hierarchy of the data. The previous Mount Everest example shows what PJSON looks like. While PJSON is easier to read, and therefore easier to troubleshoot for errors, the minimized JSON is much smaller. In the example, the <a id="id365" class="indexterm"/>PJSON has 397 characters, while the minimized version has only 277 characters, a 30 percent decrease in size.</p><p>When viewing ArcGIS REST service data, you can change the format of the data by adding an <code class="literal">f</code> query parameter to the REST Service URL. It should look like the following URL:</p><div><pre class="programlisting">http://&lt;GIS web service&gt;/arcgis/rest/services/?f=&lt;format&gt;</pre></div><p>Here, you can set <code class="literal">f=JSON</code> to receive the raw JSON data, or <code class="literal">f=PJSON</code> to receive the human-readable pretty JSON (or padded JSON, if you prefer). Some browsers, such as Google Chrome and Mozilla Firefox, offer third party extensions that reformat raw JSON data into PJSON without making the request.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Service levels</h1></div></div></div><p>Let's start by<a id="id366" class="indexterm"/> viewing the sample <a id="id367" class="indexterm"/>ArcGIS Server services at <a class="ulink" href="http://sampleserver6.arcgisonline.com/arcgis/rest/services">http://sampleserver6.arcgisonline.com/arcgis/rest/services</a>. When we request the page as HTML, we notice a few things. First, the version of ArcGIS Server is shown (version 10.21 at the time of writing). The version number is important because many features and bits of information may not be present in older versions. Secondly, we see a list of links pointing to folders. These are map services grouped in any way the publisher chooses. We also see a list of map service links below the folder lists. Finally, at the bottom of<a id="id368" class="indexterm"/> the page, we see supported interfaces. In this site, we can see the REST interface that we're familiar with. The other interfaces will not be covered in this book. Here's a picture of the service:</p><div><img src="img/6459OT_04_01.jpg" alt="Service levels" width="428" height="546"/></div><p>If we change the format of the REST Service request in our browser to Pretty JSON, by adding <code class="literal">?f=pjson</code> to the end of the URL, we can see roughly how the ArcGIS JavaScript API would see this location:</p><div><img src="img/6459OT_04_02.jpg" alt="Service levels" width="329" height="565"/></div><p>Here, the JSON <a id="id369" class="indexterm"/>object returned includes the numeric <code class="literal">currentVersion</code>, an array of folder names, and an array of services objects. The service JSON objects contain a name and a type attribute, which tells you what kind of service you're dealing with, and gives you the components you need to construct the URL link to those services. This format is as follows:</p><div><pre class="programlisting">http://&lt;server&gt;/arcgis/rest/services/&lt;service.name&gt;/&lt;service.type&gt;</pre></div><p>If we follow the link to our census map service, we can see more details.</p></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Map services</h1></div></div></div><p>A map service <a id="id370" class="indexterm"/>gives applications access to map data published with ArcGIS Server. It contains information about the map layout, format, contents, and other items necessary to properly render the map with the various ArcGIS API's. The map service URL is formatted as follows:</p><div><pre class="programlisting">http://&lt;ArcGIS Server REST Services&gt;/&lt;mapName&gt;/MapServer
or
http://&lt;ArcGIS Server REST Services&gt;/&lt;folder&gt;/&lt;mapName&gt;/MapServer</pre></div><p>When you navigate to a map service using your browser, you're presented with a lot of information about the map service. The HTML provides links to view the data in different applications, including the ArcGIS JavaScript API and ArcMap. Google Earth is also available if the map service is published to serve data in that format. The HTML for the map service also provides a lot of metadata to help you understand <a id="id371" class="indexterm"/>what it's offering. These <a id="id372" class="indexterm"/>properties include the <a id="id373" class="indexterm"/><strong>Description</strong>, <strong>Service Description</strong>, <strong>Copyright Text</strong>, and <a id="id374" class="indexterm"/>the <strong>Document Info</strong>.</p><p>Some of the map service properties can be difficult to understand without some context. We'll review some of the important ones. Remember that properties in this list show how they are listed in the HTML. When shown in JSON, these items are camel-cased (first letter lowercase, no spaces, and capital letters to start each new word after the first).</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Spatial reference</strong>: How the layout of <a id="id375" class="indexterm"/>the map compares with the real world, which we'll discuss a little later.</li><li class="listitem" style="list-style-type: disc"><strong>Single fused map cache</strong>: Lets<a id="id376" class="indexterm"/> you know whether the map data has been cached, or if it is dynamic. You can load the layer by using either <code class="literal">ArcGISTiledMapServiceLayer</code> or <code class="literal">ArcGISDynamicMapServiceLayer</code>, respectively.</li><li class="listitem" style="list-style-type: disc"><strong>Initial extent</strong>/<strong>full extent</strong>: When you first load the map with the ArcGIS JavaScript API, the initial extent<a id="id377" class="indexterm"/> describes the bounding box of the area you see the first time. The <a id="id378" class="indexterm"/>full extent is the expected full area of the map service, which may be much wider than all the data.</li><li class="listitem" style="list-style-type: disc"><strong>Supported image format types</strong>: When<a id="id379" class="indexterm"/> ArcGIS Server draws the map layers as tiles, these are the image formats that can be returned. <code class="literal">PNG32</code> is recommended if your data has a lot of semi-transparencies and colors, while PNG8 works well with very simple symbols.</li><li class="listitem" style="list-style-type: disc"><strong>Supports dynamic layers</strong>: If true, the <a id="id380" class="indexterm"/>developer can change the symbology and layer definitions when displaying the map service.</li><li class="listitem" style="list-style-type: disc"><strong>Max record count</strong>: When<a id="id381" class="indexterm"/> submitting a query, identify or some other search, this is the maximum number of results that can be returned by the map service. This information can only be changed by server-side changes to the map service.</li></ul></div><p>Finally, the<a id="id382" class="indexterm"/> Map Service HTML provides links to a number of related REST Service endpoints. Most of these links extend the existing URL and provide more information about the map service. As a bare minimum, the following should be present:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Legend</strong>: Displays<a id="id383" class="indexterm"/> the symbology of the layers in the map service.</li><li class="listitem" style="list-style-type: disc"><strong>Export map</strong>: This<a id="id384" class="indexterm"/> feature lets you download an image showing an area of the map that fits within a specific bounding box. You can specify parameters.</li><li class="listitem" style="list-style-type: disc"><strong>Identify</strong>: This <a id="id385" class="indexterm"/>lets you identify features within all layers of a map service, based on the geometry passed in. This functionality is used by <code class="literal">IdentifyTask</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Find</strong>: This lets<a id="id386" class="indexterm"/> the user search for features based on the presence of a line of text passed to it. This functionality is implemented by <code class="literal">FindTask</code>.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Map service layers</h2></div></div></div><p>When <a id="id387" class="indexterm"/>exploring the layers of a map service, it helps to know what to look for. Map services list the basic contents of their layers within an array of objects in their layer properties.</p><p>All layer objects have the same format, with the same properties. Each layer object has a numeric <code class="literal">id</code> property that refers to the layer's zero-based position in the list. Layer objects also have a <code class="literal">name</code> property that comes from how the layer was named in the map service. These layers also have a <code class="literal">minScale</code> and <code class="literal">maxScale</code> property, showing the range within which the layer is visible (with a 0 value meaning there is no <code class="literal">minScale</code> or <code class="literal">maxScale</code> limitation). When determining visibility, the layer object also contains a Boolean <code class="literal">defaultVisibility</code> property that describes whether the layer is initially visible when the map service loads.</p><p>Map service layer objects also contain information about their layer hierarchy. Each map layer object contains a <code class="literal">parentLayerId</code> and a <code class="literal">subLayerIds</code> property. The <code class="literal">parentLayerId</code> is a number that refers to the index of the parent group layer for the specific layer. A parent layer <code class="literal">id</code> of <code class="literal">-1</code> means the layer in question has no parent layer. The <code class="literal">subLayerIds</code> are an integer array of the indexes where you can find the <code class="literal">sublayers</code> for the particular parent layer. If a layer has no sublayers, the <code class="literal">subLayerIds</code> will be a <code class="literal">null</code> value, instead of an empty list. You can see an example of map service layers in the following code:</p><div><pre class="programlisting">layers: [
  {
    "id" : 0, 
    "name" : "Pet Lovers", 
    "parentLayerId" : -1, 
    "defaultVisibility" : true, 
    "subLayerIds" : [1, 2], 
    "minScale" : 16000
    "maxScale" : 0
  },
  {
    "id" : 1, 
    "name" : "Dog Lovers", 
    "parentLayerId" : 0, 
    "defaultVisibility" : true, 
    "subLayerIds" : null, 
    "minScale" : 16000
    "maxScale" : 0
  },
  {
    "id" : 2, 
    "name" : "Cat Lovers", 
    "parentLayerId" : 0, 
    "defaultVisibility" : true, 
    "subLayerIds" : null, 
    "minScale" : 16000
    "maxScale" : 0
  }
],
      …</pre></div><p>In the <a id="id388" class="indexterm"/>preceding snippet, the map service has three layers. The <code class="literal">Pet Lovers</code> layer is actually a <code class="literal">parentLayer</code>, and corresponds to a group layer assigned in an ArcMap <code class="literal">.mxd</code> file. There are two layers in <code class="literal">parentLayer</code>: <code class="literal">Dog Lovers</code> and <code class="literal">Cat Lovers</code>. All layers are visible by default, and the layers do not appear until the map is at a scale lower than 1:16,000, according to <code class="literal">minScale</code>. The <code class="literal">maxScale</code> property is set to zero, meaning there is no maximum scale where the layer turns off again.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Feature services</h1></div></div></div><p>Feature services<a id="id389" class="indexterm"/> are similar to map services, but provide more functionality. Their content can be edited, if the database and map settings support those operations. They display their feature symbology without the need of a legend service. Their symbology can also be modified client-side, by changing their renderer. The URL of a feature service is similar to a map service, except that it ends with <code class="literal">FeatureServer</code>, as shown in the following:</p><div><pre class="programlisting">http://&lt;GIS-web- server&gt;/arcgis/rest/services/&lt;folder&gt;/&lt;mapname&gt;/FeatureServer</pre></div><p>The feature service<a id="id390" class="indexterm"/> differs first and foremost in its capabilities. Apart from allowing you to query data, feature service capabilities allow the user to create, update, and/or delete records. Those familiar with CRUD operations will recognize those words as the C, U, and D in CRUD (the R stands for read, which is what happens when you query for results). The capabilities include editing if create, update, or delete are allowed. Also, if the feature service supports file attachments to data, such as photos, the capabilities will include the word "upload".</p><p>There are other feature service <a id="id391" class="indexterm"/>properties that may help you learn more about the service. They include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Has Versioned Data</strong>: Lets <a id="id392" class="indexterm"/>you know that the geodatabase has versioning enabled, which allows edits to be undone/redone.</li><li class="listitem" style="list-style-type: disc"><strong>Supports Disconnected Editing</strong>: Data can <a id="id393" class="indexterm"/>be checked out and edited in an environment without an Internet connection. When the application connects to the Internet again, the data can be checked back in.</li><li class="listitem" style="list-style-type: disc"><strong>Sync Enabled</strong>: If this<a id="id394" class="indexterm"/> is true, feature data can be synced between the geodatabase the data comes from, and another geodatabase (a topic for another book).</li><li class="listitem" style="list-style-type: disc"><strong>Allow Geometry Updates</strong>: If <a id="id395" class="indexterm"/>editing is allowed, this lets the API know if the feature geometries can be edited or not. Due to certain permissions, the application might only allow for updates to the feature attributes, while the geometries remain unchanged.</li><li class="listitem" style="list-style-type: disc"><strong>Enable Z Defaults</strong>: If the <a id="id396" class="indexterm"/>data contains height data (<code class="literal">z</code>), default values are assigned in the map service.</li></ul></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Layer level</h1></div></div></div><p>Map services and <a id="id397" class="indexterm"/>feature services are made up of layers. These layers group together geographic features with the same geometry type and the same sets of properties. Layers are referred to by their numerical index in the list. The layer index starts at <code class="literal">0</code> for the bottom layer, and goes up one for each additional layer. The URL might look something like this for the first layer in a map service:</p><div><pre class="programlisting">http://&lt;GIS-web- server&gt;/arcgis/rest/services/&lt;folder&gt;/&lt;mapname&gt;/MapServer/0</pre></div><p>Map layers offer <a id="id398" class="indexterm"/>a whole host of data to help you understand what you're viewing. The layer's <code class="literal">name</code> property comes either from its name in the <code class="literal">.mxd</code> file, or from the layer in the Table of contents, if the file is unsaved. The map layer also provides a description, and copyright data. The display field property tells the map service what to use when labeling features, if labeling is turned on.</p><p>Map layers also<a id="id399" class="indexterm"/> provide important data that you can use in your application. The <code class="literal">type</code> parameter tells you the geometry of the layer, whether it's a point, line, or polygon. Default visibility lets you know if the layer was originally visible or not when the map service began. Minimum scale and maximum scale affect visibility, depending on your zoom level. The map service also lets you know if the layers have attachments, can be modified with different renderers, and how many results can be returned from a query.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Fields</h2></div></div></div><p>A map service <a id="id400" class="indexterm"/>layer provides information about its attribute by means of the field property. The field property is an array of field objects with similar formats. All fields have a type, a name, and an alias attribute. The type refers to the data type of the field, whether it's a string or an integer, or something else. A current list of supported types can be found at <a class="ulink" href="http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/">http://resources.arcgis.com/en/help/arcgis-rest-api/#/field/02r300000051000000/</a>. The name attribute is the field name for the property, as found in the geodatabase. Field names don't contain spaces or special characters.</p><p>The <code class="literal">alias</code> field is a string that shows the field <code class="literal">name</code> for presentation purposes. Unlike the <code class="literal">field</code> name, the <code class="literal">alias</code> can have spaces or other special characters. If no <code class="literal">alias</code> is assigned in the geodatabase or the map service, the <code class="literal">alias</code> field is the same as the field <code class="literal">name</code>. For instance, when creating the map service with ArcMap, you might have some data for a block with a field name <code class="literal">NUMB_HSES</code>. If you want to show the values for this property in a chart, the field name may look rough and a little confusing. You can then add an alias to the <code class="literal">NUMB_HSES</code> field by calling it <code class="literal">Number of Houses</code>. That <code class="literal">alias</code> provides a much better description for the field:</p><div><pre class="programlisting">{
  "type": "esriFieldTypeInteger",
  "name" "NUMB_HSES",
  "alias": "Number of Houses"
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Domains</h2></div></div></div><p>Field objects <a id="id401" class="indexterm"/>may also have domain attributes assigned to them. Domains are limitations on field values imposed at the geodatabase level. Domains are uniquely created in the geodatabase, and can be assigned to feature classes and table fields. Domains make it easier to input the correct values by restricting what can be entered. Instead of allowing users to mistype street names in a report service, for instance, you might provide a field with a domain containing all the correctly typed street names. The user can then select from the list, rather than have to guess how to spell the street name.</p><p>The ArcGIS REST API supports two varieties of domains: ranges and coded values. Ranges, as the name implies, set a minimum and maximum numeric value for a feature attribute. One example of a range might be an average user rating for restaurants. The restaurant might get somewhere between one and five stars, so you wouldn't want a restaurant to accidently get a value of <code class="literal">6</code> or a value of less than <code class="literal">1</code>. You can see an example of a rating field with that range domain in this snippet:</p><div><pre class="programlisting">{
  "type": "esriFieldTypeInteger",
  "name": "RATING",
  "alias": "Rating",
  "domain": {
    "type": "range",
    "name": "Star Rating",
    "range": [1, 5]
  }
}</pre></div><p>A coded value domain provides a list of code and value pairs to use as legitimate property values. The coded value list contains items with a name and a code. The code is the value stored in the geodatabase. The name is the text representation of the coded value. They're useful in that users are forced to select a valid value, instead of mistyping a correct value.</p><p>In the following example, we can see a field with a coded value domain. The field contains state abbreviations, but the domain allows the user to see entire state names:</p><div><pre class="programlisting">{
  "type": "esriFieldTypeString",
  "name": "STATE",
  "alias": "State",
  "length": 2,
  "domain": {
    "type": "codedValue",
    "name": "State Abbreviation Codes",
    "codedValues": [
      {"name": "Alabama", "code": "AL"},
      {"name": "Alaska", "code": "AK"},
      {"name": "Wisconsin", "code": "WI"},
      {"name": "Wyoming", "code": "WY"}
    ]
  }
}</pre></div><p>In the preceding <a id="id402" class="indexterm"/>example, state names are stored in two letter code form. The domain provides a full name reference table with the full names of the states. If you were to send queries for features using this field, you would use the code values. Querying for all features where <code class="literal">STATE = 'Alaska'</code> would yield no results, while a query where <code class="literal">STATE = 'AK'</code> may give you results.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Note that the code and the value don't have to be of the same type. You can have numeric codes for, say, water line part numbers, and coded values to show their descriptive names.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Related tables</h1></div></div></div><p>Tables<a id="id403" class="indexterm"/> with non-geographic data can be published in a map service. These tables may provide data related to map features, such as comments on campground locations or the sales history of a property. These tables can be searched and queried like features. Relationships between map layers and tables can also be published and searched.</p><p>Layers and tables can be joined, either by using geodatabase relationship classes, or ad-hoc relationship assignments in ArcMap. When published with ArcMap, those relationships are preserved in ArcGIS Server. The connection between related features and tables is stored within the <code class="literal">relationships</code> property of the layer and table. A developer can query related data, based on a selection in the parent feature class.</p><p>Relationship objects have the same general format. Each relationship object contains a numerical <code class="literal">id</code> and <code class="literal">relatedTableId</code>. The <code class="literal">relatedTableId</code> is linked to the <code class="literal">RelationshipQuery</code> object to query for related results. The role describes whether the current layer or table is the origin or the destination of the relationship. Cardinality describes whether a single origin object has one or several destinations related to it.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>When querying for results, results return much faster if you start with the origin and use <code class="literal">RelationshipQuery</code> on the destination tables. Starting with the destination tables may take significantly longer.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Common JSON objects</h1></div></div></div><p>The <a id="id404" class="indexterm"/>ArcGIS REST API defines the formats for JSON data objects commonly used by the system. The ArcGIS API for JavaScript uses this format to communicate with the server. When you look at the network traffic in your browser's developer console, you'll see these common JSON objects in both the requests and responses. Let's look more closely at two of these JSON object definitions: geometries and symbols.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Geometries</h2></div></div></div><p>Geometry<a id="id405" class="indexterm"/> JSON is a common data format used for ArcGIS Server processes. It makes sense, since finding geographic locations relies on geometry. Geometries come in a variety of shapes and sizes.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>Spatial reference</h3></div></div></div><p>As<a id="id406" class="indexterm"/> mentioned in previous chapters, spatial reference refers to the calculations that represent the earth on a map, either as a spheroid (almost a sphere), or as a 2-dimensional representation of a land surface. Instead of documenting all the possible factors that go into calculating a spatial reference, a general format is followed, either by using an assigned <a id="id407" class="indexterm"/><strong>well-known ID</strong> (<strong>WKID</strong>), or <a id="id408" class="indexterm"/><strong>well-known text</strong> (<strong>WKT</strong>).</p><p>For spatial references with well-known ids, the spatial reference JSON is made up of one required parameter (WKID), and three optional parameters. The WKID is a numerical reference to the <a id="id409" class="indexterm"/>spatial reference, which can be searched at <a class="ulink" href="http://www.spatialreference.org">http://www.spatialreference.org</a>. Common values include <code class="literal">wkid 4326</code>, which stands for WGS84, and is typically used for latitude and longitude. Optional spatial reference object parameters include the latest WKID or <code class="literal">latestWkid</code>, a vertical coordinate system WKID or <code class="literal">vcs Wkid</code>, and the latest vertical coordinate system WKID or <code class="literal">latest vcs Wkid</code>. The last two are used for features with three-dimensional points, including height.</p><p>Spatial references can also be defined using strings, in the case of the well-known text. The well-known text details the necessary items used to flatten the map mathematically.</p><p>We will not be calculating anything with spatial references. For our applications, we'll use them either for data comparison, or as parameters for service requests. Let's say we need the latitude and longitude coordinates for the results of a query, but the data isn't in a decimal degree latitude/longitude spatial reference. We can query the data, but set the <code class="literal">query.outSpatialReference</code> to <code class="literal">wkid 4326</code>, and ArcGIS Server performs the necessary calculations to give us the results in the format we need.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>Points</h3></div></div></div><p>Points are<a id="id410" class="indexterm"/> the <a id="id411" class="indexterm"/>simplest geometry, and therefore the simplest to explain. They have three required parameters, an <code class="literal">x</code> value, a <code class="literal">y</code> value, and a <code class="literal">spatialReference</code> value. The <code class="literal">x</code> value refers to the longitude, or easting value, depending on the coordinate system. The <code class="literal">y</code> value refers to the latitude or the northing value. Points may also have an optional <code class="literal">z</code> value to describe the height, and an optional <code class="literal">m</code> value to describe the slope. You can see an example of a point REST object in the following:</p><div><pre class="programlisting">// a two-dimensional point
{x: -95.25, y: 38.09, spatialReference: {wkid: 4326}}

// a three-dimensional point
{x: -38.93, y: -45.08, z: 28.9, spatialReference: {wkid: 4326}} </pre></div><p>In the preceding example, the point has an <code class="literal">x</code> and <code class="literal">y</code> value, plus a spatial reference. As we learned in the previous section, a well-known <code class="literal">id</code> of <code class="literal">4326</code> means the <code class="literal">x</code> and <code class="literal">y</code> values are longitude and latitude. In the second example, a <code class="literal">z</code> value was added, indicating a height.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec56"/>Multipoints</h3></div></div></div><p>Multipoints, as<a id="id412" class="indexterm"/> you may recall from previous chapters, define a <a id="id413" class="indexterm"/>cluster of points. The points share the same spatial reference (<code class="literal">spatialReference</code>). Multipoints define points by using a <code class="literal">points</code> property, which is a two dimensional array of points. The lowest array contains the <code class="literal">x</code>, <code class="literal">y</code>, and possibly <code class="literal">z</code> (height) and <code class="literal">m</code> (slope) values. If the points contain <code class="literal">z</code> and/or <code class="literal">m</code> values, the multipoint JSON will also have true values for its <code class="literal">hasZ</code> and <code class="literal">hasM</code> properties:</p><div><pre class="programlisting">// a two-dimensional multipoint
{
  "points": [[12.831, 48.132], [19.813, 49.908], [-90.10, 83.132]],
  "spatialReference": {wkid: 4326}
}</pre></div><p>This example shows three points grouped together as a multipoint, with locations defined using latitude and longitude coordinates (wkid 4326).</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec57"/>Polylines</h3></div></div></div><p>Polylines<a id="id414" class="indexterm"/> can be either one line, or a group of lines, that describe<a id="id415" class="indexterm"/> the same linear feature on a map. The polylines JSON is made up of a spatial reference and a three-dimensional array of points in its <code class="literal">paths</code> property. The lowest level of the polyline paths array contains the <code class="literal">x</code>, <code class="literal">y</code>, and possibly <code class="literal">z</code> and <code class="literal">m</code> coordinates for a point on the line. If <code class="literal">z</code> and <code class="literal">m</code> values are present, the polyline JSON object has its <code class="literal">hasZ</code> and <code class="literal">hasM</code> values set to true, respectively.</p><p>A polyline may contain more than one line. For instance, if part of a railroad line is abandoned, the railroad still owns the lines on either side of that section. The two good sections would <a id="id416" class="indexterm"/>still be considered a polyline. This is why the polyline contains<a id="id417" class="indexterm"/> three levels of arrays. The preceding code symbolizes a single line with a string of latitudinal and longitudinal coordinates:</p><div><pre class="programlisting">// a two dimensional path.
{
  "paths": [[[43.234,-28.093], [44.234,-32.232], [43.239,-33.298], [49.802,-35.099]]],
  "spatialReference": {wkid: 4326}
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec58"/>Polygons</h3></div></div></div><p>Polygons <a id="id418" class="indexterm"/>provide <a id="id419" class="indexterm"/>a solid shape to areas. A polygon JSON is made up of a spatial reference and a <code class="literal">rings</code> parameter. The rings parameter contains a triple array with one or more lists of points, where the last point is the same as the first point. In this way, the polygon closes in on itself and provides an interior and an exterior. The points within the polygon rings can contain <code class="literal">z</code> values for height. In that case, the polygon would have the optional <code class="literal">hasZ</code> property set to true.</p><p>A polygon JSON can contain more than one closed loop of points, and these polygons are called <a id="id420" class="indexterm"/><strong>multipart polygons</strong>. An example of this would be a plot of land that has a road built down the middle of it. If the road no longer belongs to the owner, the owner still retains ownership of the two halves of the property divided by the road. Since the land used to be as one, it is still treated as one unit, but with two parts. The following JSON code illustrates a multipart polygon. The polygon has two <code class="literal">rings</code>, each with three points:</p><div><pre class="programlisting">// a two dimensional polygon with two rings.
{
  "rings": [[[-85.032,18.098], [-85.352,18.423], [-85.243,18.438], [-85.032,18.098]], [[85.042,18.098], [84.995,18.008], [85.123,18.900], [85.042,18.098]]],
  spatialReference: {wkid: 4326}
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec59"/>Envelopes</h3></div></div></div><p>Envelopes, also <a id="id421" class="indexterm"/>known as extents, are the bounding boxes that <a id="id422" class="indexterm"/>represents the minimum and maximum <code class="literal">x</code> and <code class="literal">y</code> values for items on the map. The following example shows an area between <code class="literal">42.902</code> degrees and <code class="literal">53.923</code> degrees longitude, and <code class="literal">-23.180</code> degrees and <code class="literal">-18.45</code> degrees latitude:</p><div><pre class="programlisting">{
  "xmin": 42.902, "xmax": 53.923, "ymin": -23.180, "ymax": -18.45,
  "spatialReference": {wkid: 4326}
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Symbols</h2></div></div></div><p>The <a id="id423" class="indexterm"/>symbol JSON contains the minimum amount <a id="id424" class="indexterm"/>of data necessary to describe the properties of the symbols. As we learned in previous chapters, a graphics symbol describes the appearance of the graphic, affecting the color, line thickness, and transparency, among other features. Different geometry types have corresponding symbol types to demonstrate their features. We're going to look at how the ArcGIS REST API describes the different symbol types, and how to use them in our application.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec60"/>Color</h3></div></div></div><p>Colors<a id="id425" class="indexterm"/> are <a id="id426" class="indexterm"/>defined in ArcGIS REST services as three to four element arrays with integer values from 0 to 255. The first three values stand for the red, green, and blue color values, respectively. Higher numbers mean lighter colors, and lower numbers mean darker colors, with <code class="literal">[0, 0, 0]</code> representing the color black.</p><p>The fourth value refers to the alpha, or the opacity of the color. A value of 255 is completely opaque while a value of 0 is completely transparent, and a value somewhere in between is somewhat see-through. If the fourth value is left out, it is considered to be completely opaque (255). This description differs from the <code class="literal">esri/Color</code> description of opacity, which defines the value as a decimal value between <code class="literal">0.0</code> and <code class="literal">1.0</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec61"/>Simple line symbol</h3></div></div></div><p>As for <a id="id427" class="indexterm"/>symbols, we start with the simple line symbol <a id="id428" class="indexterm"/>because it is used by all the other symbols. The line consists of four basic properties: a <code class="literal">type</code>, a <code class="literal">style</code>, a <code class="literal">width</code>, and a <code class="literal">color</code>. The type, <code class="literal">esriSLS</code>, is always the same for a simple line symbol. The <code class="literal">width</code> describes a pixel width for the line, and <code class="literal">color</code> describes the numeric RGB value described in the previous color section. <code class="literal">style</code> is one of several string constants prefixed by <code class="literal">esriSLS</code>. The choices include <code class="literal">Solid</code>, <code class="literal">Dash</code>, <code class="literal">Dot</code>, <code class="literal">DashDot</code>, <code class="literal">DashDashDot</code>, and <code class="literal">Null</code>. You can see an example of a JSON simple line symbol definition in the following snippet:</p><div><pre class="programlisting">{
  type: "esriSLS",
  style: "esriSLSDash",
  width: 3,
  color: [123,98,74,255]
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec62"/>Simple marker symbol</h3></div></div></div><p>The<a id="id429" class="indexterm"/> simple marker symbol describes the style of a simple<a id="id430" class="indexterm"/> point and is made up of the following properties: a <code class="literal">type</code>, <code class="literal">style</code>, <code class="literal">color</code>, <code class="literal">size</code>, <code class="literal">angle</code>, <code class="literal">xoffset</code>, <code class="literal">yoffset</code>, and <code class="literal">outline</code>. The <code class="literal">type</code> is always <code class="literal">esriSMS</code> for these symbols. Styles are defined in a similar way to the simple line symbol, except that all styles are prefixed with <code class="literal">esriSMS</code>. The style can be chosen from a <code class="literal">Circle</code>, <code class="literal">Cross</code>, <code class="literal">Diamond</code>, <code class="literal">Square</code>, <code class="literal">X</code>, or <code class="literal">Triangle</code>. <code class="literal">Angle</code> defines the rotation of the symbol, while <code class="literal">xoffset</code> and <code class="literal">yoffset</code> describe how far the drawn point is away from the real point. <code class="literal">Size</code> is numeric, and measures the pixel size of the graphic. Finally, <code class="literal">outline</code> accepts a simple line symbol definition to describe the border of the point graphic:</p><div><pre class="programlisting">{
  type: "esriSMS",
  style: "esriSMSCircle",
  color: [255,255,255,50],
  size: 10,
  angle: 0,
  xoffset: 0,
  yoffset: 0,
  outline: {
    width: 1,
    color: [0,0,0]
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec63"/>Simple fill symbols</h3></div></div></div><p>Simple<a id="id431" class="indexterm"/> fill symbols <a id="id432" class="indexterm"/>can be described by the following properties: <code class="literal">type</code>, <code class="literal">style</code>, <code class="literal">color</code>, and <code class="literal">outline</code>. <code class="literal">Type</code> is always <code class="literal">esriSFS</code>, and all styles start in the same way. Styles consist of <code class="literal">Solid</code>, <code class="literal">Null</code>, and various other ways to describe lines drawn within the graphic. <code class="literal">Outline</code>, like the simple marker symbol, uses the simple line symbol to describe the border of the polygon. Look at the following code for an example of a JSON description:</p><div><pre class="programlisting">{
  type: "esriSFS",
  style: "esriSFSSolid",
  color: [123, 99, 212, 120],
  outline: {
    type: "esriSLS",
    style: "esriSLSDashDot",
    width: 3,
    color: [123, 99, 212]
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec64"/>Picture marker symbol</h3></div></div></div><p>The <a id="id433" class="indexterm"/>picture marker symbol<a id="id434" class="indexterm"/> describes a point symbol with a picture graphic. The symbol JSON for this includes unique properties such as <code class="literal">url</code>, <code class="literal">imageData</code>, <code class="literal">contentType</code>, <code class="literal">width</code>, and <code class="literal">height</code>, as well as properties common to the simple marker symbol (type, <code class="literal">angle</code>, <code class="literal">xoffset</code>, and <code class="literal">yoffset</code>). The URL links to the image you want to see with the features. <code class="literal">Width</code> and <code class="literal">height</code> describe how large you want the image to be in pixels. <code class="literal">ContentType</code> refers to the file extension, such as <code class="literal">image/png</code> for a <code class="literal">.png</code> file. Finally, <code class="literal">imageData</code> is populated by the <code class="literal">base64</code> string that can be translated into an image file. Refer to the following example:</p><div><pre class="programlisting">{
  type: "esriPMS",
  url: "images/Cranston.jpg",
  imageData: "iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAA…",
  contentType: "image/jpg",
  width: 24,
  height: 24,
  angle: 0,
  xoffset: 0,
  yoffset: 0
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec65"/>Picture fill symbol</h3></div></div></div><p>The <a id="id435" class="indexterm"/>picture fill symbol<a id="id436" class="indexterm"/> can be added to a polygon to show an image tiled inside the shape. The picture fill symbol has many of the same parameters as the picture marker symbol, including <code class="literal">url</code>, <code class="literal">imageData</code>, <code class="literal">contentType</code>, <code class="literal">width</code>, <code class="literal">height</code>, <code class="literal">angle</code>, <code class="literal">xoffset</code>, and <code class="literal">yoffset</code>. It requires the line symbol JSON for the outline. It accepts its own numeric <code class="literal">xscale</code> and <code class="literal">yscale</code> parameters, which shrink or stretch the images shown within the feature. You can see an example of a picture fill symbol JSON here:</p><div><pre class="programlisting">{
  type: "esriPFS",
  url: "images/foliage.png",
  imageData: "iVBORwoadfLKJFDSFKJLKEWIUnjnKUHWkunUWNkJNiuN…",
  contentType: "image/png",
  outline: {
    type: "esriSLS",
    style: "esriSLSSolid",
    width: 3,
    color: [16, 243, 53]
  },
  width: 32,
  height: 32,
  angle: 0,
  xoffset: 0,
  yoffset: 0,
  xscale: 1,
  yscale: 1
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec66"/>Text symbol</h3></div></div></div><p>The <a id="id437" class="indexterm"/>text symbol<a id="id438" class="indexterm"/> JSON describe the formatting used to create custom text labels on the map. The text symbol JSON looks very different to the other symbols because it is also concerned with things such as fonts, boldness, and italics. However, the text symbol does have certain properties in common with the other symbols such as <code class="literal">color</code>, <code class="literal">angle</code>, <code class="literal">xoffset</code>, and <code class="literal">yoffset</code>.</p><p>The text symbol has some unique properties that need to be addressed. Vertical and horizontal alignment position the text in relation to the point because text symbols are typically placed around label points. Halo size and color, introduced in ArcGIS Server 10.1, describe the color outline around the text, to make it more readable against a busy aerial background. The font parameters are so numerous they require their own object to describe the CSS styling of the labels. You can see an example of a text symbol here:</p><div><pre class="programlisting">{
  "type": "esriTS",
  "color": [158,38,12,255],
  "backgroundColor": [0,0,0,0],
  "borderLineSize": 1,
  "borderLineColor": [158,38,12,255],
  "haloSize": 2,
  "haloColor": [255,255,128,255],
  "verticalAlignment": "bottom",
  "horizontalAlignment": "center",
  "rightToLeft": false,
  "angle": 0,
  "xoffset": 0,
  "yoffset": 0,
  "kerning": true,
  "font": {
    "family": "Georgia",
    "size": 14,
    "style": "normal",
    "weight": "bold",
    "decoration": "none"
  }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec67"/>Uses</h3></div></div></div><p>While <a id="id439" class="indexterm"/>you will seldom see symbol JSON passed between the server and client, all of the symbol constructors in the ArcGIS JavaScript API can accept JSON objects to define the symbols. The developer can thus stash the symbol style in a configuration file until it's needed. The developer can also construct the JSON object with a different color palette and line defining widget before it is assigned as a symbol.</p><p>Assigning symbols with JSON is much easier than the previous methods of defining a simple symbol. The older ways included symbol constructors containing a long list of arguments. Some constructors could possibly contain nested constructors. Another way of constructing symbols include creating a base symbol, and then assigning the necessary attributes with assignment methods. Let's take a look at an example of the older way:</p><div><pre class="programlisting">require(["esri/symbols/SimpleFillSymbol", "esri/symbols/SimpleLineSymbol","esri/Color", …], 
function (SimpleFillSymbol, SimpleLineSymbol, esriColor, …) {
  …
  var lineSymbol = new SimpleLineSymbol()
    .setColor(new esriColor([255,128, 128, 0.8]))
    .setWidth(3)
    .setStyle(SimpleLineSymbol.STYLE_DASHDOTDOT);
  var fillSymbol = new SimpleFillSymbol()
    .setOutline(lineSymbol)
    .setColor(new esriColor([64,255,64,0.4]));
  …
});</pre></div><p>Here, a base symbol is constructed and additional methods are called to assign colors, line width, and line style. Compare this to the same symbol declaration using JSON:</p><div><pre class="programlisting">require(["esri/symbols/SimpleFillSymbol", …], 
function (SimpleFillSymbol, …) {
  …
  var fillSymbol = new SimpleFillSymbol({
    style: "esriSFSSolid",
    color: [64,255,64,102],
    outline: { 
      color: [255,128,128,204], 
      width: 3,
      style: "esriSLSDashDotDot"
    }
     });
  …
});</pre></div><p>While the JSON code takes up an extra line of code, it's more compact and easier to read. Also, this <a id="id440" class="indexterm"/>symbol assignment doesn't require the client to load two extra modules just to assign a color and a line style. It's all included in a single construction call.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>When constructing symbols using JSON, you don't have to add every single JSON attribute defined in the symbol. When the symbols are constructed, the attributes of the JSON object are mixed into a default symbol. That means that, if you construct a line symbol using the following code, instead of a 1 pixel wide black line, you'll create a 1 pixel wide green line.</p><div><pre class="programlisting">Var symbol = new SimpleLineSymbol({color: [0,255,0]});</pre></div></div></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Back to our application</h1></div></div></div><p>Now that we have an idea of how to work with JSON data, we can improve our Year 2000 Census map. We've come a long way in styling our application but the default highlight color for the map's <code class="literal">infoWindow</code> clashes with the rest of the site.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>How about that InfoWindow</h2></div></div></div><p>Our <a id="id441" class="indexterm"/>clients at the Y2K Society just responded with feedback on the site. They liked the color palette for the page. Unfortunately, they complained that, when they clicked on the map, the cyan-colored highlight symbol on the map's popup clashed with the site. One user even claimed it gave him a headache to stare at it too long. This problem is fixable, and there are things we can do to make the client happy.</p><p>Let's look at the application we wrote in the previous chapter. If you haven't seen the application in <a class="link" href="ch03.html" title="Chapter 3. The Dojo Widget System">Chapter 3</a>, <em>The Dojo Widget System</em>, there are code samples included with this book. We created a widget using the Dojo framework to interact with the map and reveal the census data for the year 2000. We will modify the widget so that it can modify the map properties for us.</p><p>Open the <code class="literal">Census.js</code> file in your favorite text editor. If you look it over, you'll see where we construct the Census widget, then use the <code class="literal">show()</code> and <code class="literal">hide()</code> functions to toggle map clickability. We would like to modify the symbols for the map's <code class="literal">infowindow</code> but, where do we begin?</p><p>We could change the map's <code class="literal">infowindow</code> properties in the constructor, but that could lead to problems. If you remember, in <a class="link" href="ch02.html" title="Chapter 2. Digging into the API">Chapter 2</a>, <em>Digging into the API</em>, we talked about how changing map settings before it finishes loading causes an error and possibly stops the application. We'll have to check if the map is loaded before we make any changes to its <code class="literal">infowindow</code>. If it hasn't loaded, we'll assign an event listener to the map's load event. If it has loaded, we'll go ahead and run the event listener. We'll call <code class="literal">_onMapLoad()</code> event listener, as you can see in the following code:</p><div><pre class="programlisting">…
this.map = options.map || null;
this.domNode = srcRefNode;

<strong>if (this.map.loaded) {</strong>
<strong>  this._onMapLoad();</strong>
<strong>} else {</strong>
<strong>  this.map.on("load", lang.hitch(this, this._onMapLoad));</strong>
<strong>}</strong>
<strong>…</strong>
</pre></div><p>A line below <a id="id442" class="indexterm"/>the <code class="literal">Census</code> dijit <code class="literal">constructor()</code> method, we'll add the new <code class="literal">_onMapLoad()</code> method. We know that the map has loaded there, and that means the <code class="literal">infoWindow</code> object should be ready as well. We'll modify the <code class="literal">infoWindow</code> object's <code class="literal">markerSymbol</code> and <code class="literal">fillSymbol</code> properties with our own symbology. Now, we haven't added modules for the <code class="literal">SimpleMarkerSymbol</code> and <code class="literal">SimpleFillSymbol</code> yet, so we'll add the references to those in our define statement:</p><div><pre class="programlisting">define([
  …
  "esri/InfoTemplate",
  <strong>"esri/symbols/SimpleMarkerSymbol",</strong>
<strong>  "esri/symbols/SimpleFillSymbol"</strong>
], function (

  InfoTemplate, <strong>MarkerSymbol, FillSymbol</strong>
) {
  …
    <strong>_onMapLoad: function () {</strong>
<strong>      // change the infoWindow symbol</strong>
<strong>      this.map.infoWindow.markerSymbol = new MarkerSymbol({});</strong>

<strong>     this.map.infoWindow.fillSymbol = new FillSymbol({});</strong>
<strong>    },</strong>

});</pre></div><p>So, we know that symbol constructors can accept JSON objects to create the symbols. Let's fill in the properties in the objects we'll pass into the symbols. We'll pick some colors based on the application's color palette. We'll also adjust the fill symbol's interior transparency, so that the user can see what's underneath. Remember that, when defining a color, the four numbers represent red, green, blue, and opacity values, ranging from a full 255, to an empty 0. Also, you don't have to pass every single symbol JSON property, if you don't mind that it uses a default value instead.</p><div><pre class="programlisting">this.map.infoWindow.markerSymbol = new MarkerSymbol({
  style: "esriSMSDiamond",
  color: [255,200,30],
  size: 12,
  outline: {
    width: 1,
    color: [111,98,34]
  }
});

this.map.infoWindow.fillSymbol = new FillSymbol({
  style: "esriSFSSolid",
  color: [255,250,169,128],
  outline: {
    width: 2,
    color: [111,98,34]
  }
});</pre></div><p>We can <a id="id443" class="indexterm"/>then save and reload our application in the browser. If we've typed everything in correctly, the map should load with no errors. When we click on the <strong>Census</strong> button, the floating widget should load in the corner, and when we zoom in and click on an area, we should see new yellow diamonds when points are selected, and polygons highlighted in colors similar to the application. Our clients will hopefully be pleased with our color choices.</p><div><img src="img/6459OT_04_03.jpg" alt="How about that InfoWindow" width="514" height="523"/></div><p>The<a id="id444" class="indexterm"/> preceding image shows the <strong>Census Block Points</strong> with the golden rod-colored diamond. Each selected point will show the same graphic. You can see a picture of one of the states in the following. Note that the fill color is semi-transparent, allowing the user to read the content underneath:</p><div><img src="img/6459OT_04_04.jpg" alt="How about that InfoWindow" width="535" height="522"/></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec50"/>Summary</h1></div></div></div><p>We have explored the different parts of the REST Service endpoints for ArcGIS Server, the primary data source for our ArcGIS JavaScript API-based applications. We've learned what it means for a service to be RESTful, and how that applies to ArcGIS Server. We've explored the organization of ArcGIS Server map services. We've learnt about what information is available when viewing REST Services in a web browser, and with JSON requests. We learned about the ArcGIS REST API, how data is formatted for requests, and how it is consumed, both by ArcGIS Server and by the ArcGIS JavaScript API. Finally, we applied some of our knowledge to improve our application.</p><p>With your understanding of how data is handled client-side and server-side, you will be able to implement many of the powerful features that ArcGIS Server offers for web-based applications. In the next chapter, we'll look into one of those powerful features: editing map data.</p></div></div></div></body></html>