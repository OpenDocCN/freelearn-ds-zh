- en: Chapter 6. Transition with Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Animating a single element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating multiple elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tweening
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transition chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transition filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to transitional events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing custom interpolator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with timer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A picture is worth a thousand words."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This age-old wisdom is arguably one of the most important cornerstones of data
    visualization. Animation on the other hand is generated using a series of still
    images in quick succession. Human eye-and-brain complex, through positive afterimage,
    phi phenomenon, and beta movement is able to create an illusion of continuous
    imagery. As Rick Parent put it perfectly in his brilliant work *Computer Animation
    Algorithms and Techniques*:'
  prefs: []
  type: TYPE_NORMAL
- en: Images can quickly convey a large amount of information because the human visual
    system is a sophisticated information processor. It follows, then, that moving
    images have the potential to convey even more information in a short time. Indeed,
    the human visual system has evolved to provide for survival in an ever-changing
    world; it is designed to notice and interpret movement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -Parent R. 2012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is indeed the main goal of animation used in data visualization projects.
    In this chapter, we will focus on the mechanics of **D3 transition**, covering
    topics from the basics to more advanced ones, such as custom interpolation and
    timer-based transition. Mastering transition is not only going to add many bells
    and whistles to your otherwise dry visualization, but will also provide a powerful
    toolset to your visualization and otherwise hard-to-visualize attributes, such
    as trending and differences.
  prefs: []
  type: TYPE_NORMAL
- en: What is Transition?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: D3 transition offers the ability to create computer animation with HTML and
    SVG elements on a web page. D3 transition implements an animation called **Interpolation-based
    Animation**. Computer's are especially well equipped for value interpolation,
    and therefore, most of the computer animations are interpolation-based. As its
    name suggests, the foundation for such animation capability is value interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, we have already covered D3 interpolators and interpolation functions
    in detail in [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"), *Tipping
    the Scales*. Transition is built on top of interpolation and scales to provide
    the ability to change values over time, which produces animation. Each transition
    can be defined using a start and end value (also called **key frames** in animation),
    while different algorithms and interpolators will fill in the intermediate values
    frame-by-frame (also called "in-betweening" or simply "tweening"). At the first
    glance, if you are not already familiar with animation algorithms and techniques,
    this seems to be a somewhat less controlled way of creating an animation. However,
    it is quite the opposite in reality; interpolation-based transitions can provide
    direct and specific expectations about the motion produced down to each and every
    frame, thus offering tremendous control to the animator with simplicity. In fact,
    D3 transition API is so well-designed that, in most cases, only a couple of lines
    of code are enough to implement animations you need in a data visualization project.
    Now, let's get our hands dirty and try out some transitions to further improve
    our understanding on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a single element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will first take a look at the simplest case of transition—interpolating
    attributes on a single element over time to produce a simple animation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code necessary to perform this simple transition is extremely short; good
    news for any animator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces a moving, shrinking, and color-changing square, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Single element transition
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be surprised to see that the extra code we have added to enable this
    animation is only on line `C` and `D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First on line `C`, we call the `d3.selection.transition` function to define
    a transition. Then, the `transition` function returns a transition-bound selection
    that still represents the same element(s) in the current selection. But now, it
    is equipped with additional functions and allows further customization of the
    transitional behavior. Line `C` returns a transition-bound selection of the `div`
    element we created on line `A`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `D`, we set the duration of the transition to `5000` milliseconds using
    the `duration()` function. This function also returns the current transition-bound
    selection, thus allowing function chaining. As we have mentioned at the start
    of this chapter, interpolation-based animations usually only require specifying
    the start and end values while letting interpolators and algorithms fill the intermediate
    values over time. D3 transition treats all values set before calling the `transition`
    function as start values, with values set after the `transition` function call
    as end values. Hence in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `background-color` style defined on line `B` is treated as the start value
    for transition. All styles set in the following lines are treated as end values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you might be asking, *why these start and end values are not
    symmetric?*. D3 transition does not require every interpolated value to have explicit
    start and end values. If the start value is missing, then it will try to use the
    computed style, and if the end value is missing then the value will be treated
    as a constant. Once the transition starts, D3 will automatically pick the most
    suitable registered interpolator for each value. In our example, an RGB color
    interpolator will be used in line `E`, while a string interpolator—which internally
    uses number interpolators to interpolate embedded numbers—will be used for the
    rest of the style values. Here we will list the interpolated style values with
    their start and end values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background-color`: The start value `#e9967a` is greater than end value `#add8e6`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`margin-left`: The start value is a computed style and is greater than end
    value `600px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: The start value is a computed style and it''s greater than the end
    value `100px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: The start value is a computed style and greater than the end value
    `100px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating multiple elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A more elaborate data visualization requires animating multiple elements instead
    of a single element, as demonstrated in the previous recipe. More importantly,
    these transitions often need to be driven by data and coordinated with other elements
    within the same visualization. In this recipe, we will see how a data-driven multielement
    transition can be created to generate a moving bar chart. New bars are added over
    time while the chart shifts from right to left with a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As expected, this recipe is slightly larger than the previous one, however,
    not by that much. Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates a sliding bar chart in your web browser, as shown
    in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sliding bar chart
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the surface, this example seems to be quite complex with complicated effects.
    Every second a new bar needs to be created and animated while the rest of the
    bars need to slide over precisely. The beauty of D3 set-oriented functional API
    is that it works exactly the same way no matter how many elements you are manipulating;
    therefore, once you understand the mechanics, you will realize this recipe is
    not so much different than the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First step, we created a data-bound selection for a number of vertical bars
    (on line `A`), which can then be used in a classic enter-update-exit D3 pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing we have not touched so far is the second parameter in the `d3.selection.data`
    function. Here, we know that this function is called an **object-identity function**.
    The purpose of using this function is to provide object constancy. What it means
    in simple terms is that we want the binding between data and visual element to
    be stable. In order to achieve object constancy, each datum needs to have a unique
    identifier. Once the ID is provided, D3 will ensure if a `div` element is bound
    to `{id: 3, value: 45}`. Then, the next time when the update selection is computed,
    the same `div` element will be used for the datum with the same `id`, though this
    time the value might get changed, for example, `{id: 3, value: 12}`. Object constancy
    is crucial in this recipe; without object constancy, the sliding effect will not
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are interested to know more about object constancy, please check this
    excellent writing by Mike Bostock, the creator of D3 at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://bost.ocks.org/mike/constancy/](http://bost.ocks.org/mike/constancy/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to create these vertical bars with the `d3.selection.enter`
    function and compute the `left` position for each bar based on the index number
    (see line `B`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another point worth mentioning here is that in the `enter` section, we have
    not called transition yet, which means any value we specify here will be used
    as the start value in a transition. If you notice on line `C`, bar `height` is
    set to `0px`. This enables the animation of bars growing from zero height to the
    target `height`. At the same time, the same logic is applied to the `left` position
    of the bar (see line `B`) and was set to `barLeft(i+1)`, thus enabling the sliding
    transition we desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After completing the `enter` section, now we can take care of the `update`
    section, where the transition is defined. First of all, we want to introduce transition
    for all updates, therefore, we invoke the `transition` function before any style
    change is applied (see line `D`). Once the transition-bound selection is created,
    we applied the following style transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"top"`: `chartHeight + "px" > chartHeight - barHeight(d)+"px"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"left"`: `barLeft(i+1) + "px" > barLeft(i) + "px"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"height"`: `"0px" > barHeight(d) + "px"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The aforementioned three style transitions are all you need to do to handle
    new bars as well as every existing bar and their sliding effect. Finally, the
    last case we need to handle here is the `exit` case, when a bar is no longer needed.
    So, we want to keep the number of bars constant on the page. This is handled in
    the `exit` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So far in this book, prior to this chapter, we have always called the `remove()`
    function immediately after the `d3.selection.exit` function. This immediately
    removes the elements that are no longer needed. In fact, the `exit()` function
    also returns a selection, and therefore, can be animated before calling the `remove()`
    function. This is exactly what we did here, starting a transition on line `E`
    using the `exit` selection; then we animated the left value with the following
    transition change:'
  prefs: []
  type: TYPE_NORMAL
- en: '`left`: `barLeft(i) + "px" > barLeft(i-1) + "px"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are always removing the left-most bar, this transition moves the bar
    left and out of the SVG canvas, then removes it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `exit` transition is not necessarily limited to simple transitions, such
    as the one we have shown in this recipe. In some visualization, it could be as
    elaborate as the `update` transition.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `render` function is in place with the defined transition, all that
    is left is to simply update the data and re-render our bar chart every second
    using the `setInterval` function. Now this completes our example.
  prefs: []
  type: TYPE_NORMAL
- en: Using ease
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transition can be thought of as a function of time. It is a function that maps
    time progression into numeric value progression, which then results in object
    motion (if the numeric value is used for positioning) or morphing (if the value
    is used to describe other visual attributes). Time always travels at a constant
    pace; in other words time progression is uniform (unless you are doing visualization
    near a black hole of course), however, the resulting value progression does not
    need to be uniform. **Easing** is a standard technique to provide flexibility
    and control to this kind of mapping. When a transition generates a uniform value
    progression, it is called **linear** **easing**. D3 provides support for different
    types of easing capabilities, and in this recipe, we will explore different built-in
    D3 easing functions, as well as how to implement custom easing functions with
    D3 transition.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code example, we will demonstrate how transition easing can
    be customized on an element-by-element basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces a set of moving boxes with different easing effects.
    The following screenshot is captured at the time the easing effect takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different easing effects
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we have shown a number of different built-in D3 ease functions
    and their effects on transition. Let''s take a look at how it is done. First,
    we have created an array to store different ease modes we want to demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While all the built-in ease functions are defined simply using their name, the
    last element of this array is a custom easing function (**quadric easing**). Then
    afterwards, a set of `div` elements created using this data array and a transition
    with different easing functions was created for each of the `div` element, respectively,
    moving them from `("left", "500px")` to `("left", "10px")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might be asking, *Why did we not just specify easing using
    a function as we normally would have done for any other D3 attributes?*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that it does not work on the `ease()` function. What we have shown
    on line `D` is a workaround of this limitation, though in real-world projects
    it is fairly rare that you will need to customize easing behavior on a per-element
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is not possible to customize the easing function per-element or
    per-attribute;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: D3 Wiki (2013, August)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to get around this limitation is by using custom tweening, which
    we will cover in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen on line `D`, specifying different ease function for D3 transition is
    very straight forward; all you need to do is call the `ease()` function on a transition-bound
    selection. If the pass-in parameter is a string, then D3 will try to find the
    matching function using the name; if not found it will default to **linear**.
    On top of named built-in ease functions, D3 also provides ease mode modifiers
    that you can combine with any ease function to achieve additional effects, for
    example, **sin-out** or **quad-out-in**. Available ease mode modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**in**: default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**out**: reversed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**in-out**: reflected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**out-in**: reversed and reflected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default ease effect used by D3 is **cubic-in-out**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the list of supported D3 ease functions please refer to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease)'
  prefs: []
  type: TYPE_NORMAL
- en: When a custom ease function is used, the function is expected to take the current
    parametric time value as its parameter in the range of `[0, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we have implemented a simple quadric easing function, which
    is actually available as a built-in D3 ease function, and is named as **quad**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on easing and Penner''s equations (most of the modern
    JavaScript framework implementations including D3 and jQuery) check out the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.robertpenner.com/easing/](http://www.robertpenner.com/easing/)'
  prefs: []
  type: TYPE_NORMAL
- en: Using tweening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tween** comes from the word "inbetween", which is a common practice performed
    in traditional animation where after key frames were created by the master animator,
    less experienced animators were used to generate frames in between the key frames.
    This phrase is borrowed in modern computer-generated animation and it refers to
    the technique or algorithm controlling how the "inbetween" frames are generated.
    In this recipe, we will examine how the D3 transition supports tweening.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code example, we will create a custom tweening function to
    animate a button label through nine discrete integral numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates two buttons morphing at a very different rate,
    and the following screenshot is taken while this process is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tweening
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, the first button was created using simple transition with linear
    easing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The transition changes the button''s width from `"150px"` to `"400px"`, while
    changing its value from `"0"` to `"9"`. As expected, this transition simply relies
    on continuous linear interpolation of these values using D3 string interpolator.
    In comparison, the second button has the effect of changing these values in chunks.
    Moving from 1 to 2, then to 3, and so on up to 9\. This is achieved using D3 tweening
    support with `attrTween` and `styleTween` functions. Let''s first take a look
    at how the button value tweening works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we can see that instead of setting the end value
    for the value attribute as we have done in the case of the first button, we use
    `attrTween` function and offered a tweening function `valueTween`, which is implemented
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In D3, a tween function is expected to be a factory function, which constructs
    the actual function that will be used to perform the tweening. In this case, we
    have defined a `quantize` scale that maps the domain `[0, 1]` to a discrete integral
    range of `[1, 9]`, on line `C`. The actual tweening function defined on line `D`
    simply interpolates the parametric time value using the quantize scale which generates
    the jumping integer effect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quantize scales are a variant of linear scale with a discrete range rather
    than continuous. For more information on quantize scales, please visit the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize](https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize)'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point we have touched upon all three concepts related to transition:
    ease, tween, and interpolation. Typically, D3 transition is defined and driven
    through all the three levels shown in the following sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/2162OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Drivers of transition
  prefs: []
  type: TYPE_NORMAL
- en: As we have shown through multiple recipes, D3 transition supports customization
    in all three levels. This gives us tremendous flexibility to customize the transition
    behavior exactly the way we want.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though custom tween is usually implemented using interpolation, there is no
    limit to what you can do in your own tween function. It is entirely possible to
    generate custom tween without using D3 interpolator at all.
  prefs: []
  type: TYPE_NORMAL
- en: We used linear easing in this recipe to highlight the effect of tweening, however,
    D3 fully supports **eased tweening**, meaning that you can combine any of the
    ease functions we have demonstrated in the previous recipe with your custom tween
    to generate even more complex transition effects.
  prefs: []
  type: TYPE_NORMAL
- en: Using transition chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first four recipes in this chapter are focused on single transition controls
    in D3, including custom easing and tweening functions. However, sometimes regardless
    of how much easing or tweening you do, a single transition is just not enough,
    for instance, you want to simulate teleporting a `div` element by first squeezing
    the `div` element into a beam, then passing the beam to a different position on
    the web page, and finally restoring the `div` to its original size. In this recipe,
    we will see exactly how this type of transition can be achieved using **transition
    chaining**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our simple teleportation transition code is surprisingly short:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code performs a `div` teleportation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DIV teleportation via transition chaining
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This simple teleportation effect was achieved by chaining a few transitions
    together. In D3, when transitions are chained, they are guaranteed to be executed
    only after the previous transition reaches its completion state. Now, let''s see
    how this is done in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first transition was defined and initiated on line `A` (compression), then
    on line `B` a second transition (beaming) was created, and finally the third transition
    is chained on line `C` (restoration). Transition chaining is a powerful yet simple
    technique to orchestrate a complex transition effect by stitching simple transitions
    together. Finally in this recipe, we have also shown a basic example on re-usable
    composite transition effect by wrapping the teleportation transition in a function
    and then applying it on a selection using the `d3.selection.call` function (see
    line `D`). Re-usable transition effect is essential to following the DRY (Don't
    Repeat Yourself) principle, especially when the animation in your visualization
    becomes more elaborate.
  prefs: []
  type: TYPE_NORMAL
- en: Using transition filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under some circumstances, you might find it necessary to selectively apply transition
    to a subset of a certain selection. In this recipe, we will explore this effect
    using data-driven transition filtering techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will move a set of `div` elements (or boxes) across the
    web page from right to left. After moving all the boxes to the left, we selectively
    move only the boxes that are marked with **Cat** back, so they won''t fight each
    other. Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the page looks like after the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transition filtering
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial setup of this recipe is quite simple, since we want to keep the
    plumbing as minimal as possible which will help you focus on the core of the technique.
    We have a data array containing interlaced strings of `"Cat"` and `"Dog"`. Then
    a set of `div` boxes are created for the data and a transition was created (see
    line `A`) to move all the boxes across the web page to the left-hand side. So
    far, it is a simple example of a multi-element transition with no surprises yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then on line `B`, `d3.selection.filter` function is used to generate a subselection
    containing only the "cat" boxes. Remember, D3 transition is still a selection
    (transition-bound selection), therefore, the `d3.selection.filter` function works
    exactly the same way as on a regular selection. Once the subselection is generated
    by the `filter` function, we can apply a secondary transition (see line `C`) to
    this subselection alone. The `filter` function returns a transition-bound subselection;
    therefore, the second transition created on line `C` is actually generating a
    transition chain. It will only be triggered after the first transition reaches
    its completion. By using combinations of transition chaining and filtering we
    can generate some really interesting data-driven animations; it is a useful tool
    to have in any data visualizer's toolset.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For recipes on D3 data-driven selection filtering, please see the *Filtering
    with data* recipe [Chapter 3](ch03.html "Chapter 3. Dealing with Data"), *Dealing
    with Data*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read about API doc for the `selection.filter` function at [https://github.com/mbostock/d3/wiki/Selections#wiki-filter](https://github.com/mbostock/d3/wiki/Selections#wiki-filter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to transitional events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transition chaining gives you the ability to trigger secondary transitions after
    the initial transition reaches its completion state; however, sometimes you might
    need to trigger certain action other than a transition, or maybe do something
    else during the transition. This is what transition event listeners are designed
    for, they are the topic of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will demonstrate how to display different captions on an
    animated `div` element based on its transition state. Obviously, this example
    can easily be extended to perform more meaningful tasks using the same technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces the following visual output where a box appears
    with **waiting** label; it moves to the right with the label changed to **transitioning**
    and when it''s done, it stops moving and changes its label to **done**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transition event handling
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we constructed a single `div` element with a simple horizontal-movement
    transition, which, when initiated, also changes the label based on what transition
    state it is in. Let''s first take a look at how we manage to display the **waiting**
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The **waiting** label is set on line `A` before the transition is defined on
    line `B`, however, we also specified a delay for the transition thus showing the
    **waiting** label before the transition is initiated. Next, let''s find out how
    we were able to display the **transitioning** label during the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is achieved by calling the `each()` function and selecting its first parameter
    set as `"start"` event name with an event listener function passed in as the second
    parameter. The `this` reference of the event listener function points to the current
    selected element, hence, can be wrapped by D3 and further manipulated. The transition
    `"end"` event is handled in an identical manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that the event name is passed into the `each()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom interpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"), *Tipping the Scales*,
    we explored how custom interpolators can be implemented in D3\. In this recipe,
    we will demonstrate how this technique can be combined with D3 transition to generate
    special transition effects by leveraging custom interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe builds on top of what we have discussed in the *Implementing a custom
    interpolator* recipe in [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"),
    *Tipping the Scales*. If you are not familiar with the concept of custom interpolation,
    please review the related recipe before proceeding with this one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the code of the `custom-interpolator-transition.html` file and
    see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates one ticking box that starts from **a** and finishes
    at **z**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transition with custom interpolation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First thing we did in this recipe is register a custom interpolator that is
    identical to the alphabet interpolator we discussed in [Chapter 4](ch04.html "Chapter 4. Tipping
    the Scales"), *Tipping the Scales*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the custom interpolator is registered, the transition part has pretty
    much no custom logic at all. Since it''s based on the value that needs to be interpolated
    and transitioned upon, D3 will automatically pick the correct interpolator to
    perform the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code snippet, the start value is `"a"`, defined
    on line `B`. Afterwards, a standard D3 transition is created on line `C` and finally
    all we had to do is set the end value to `"z"` on line `D`, then D3 and our custom
    interpolator takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Working with timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter we have discussed various topics on D3 transition. At
    this point you might be asking the question, *What is powering D3 transition that
    is generating the animated frames?*
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore a low-level D3 timer function that you can leverage
    to create your own custom animation from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will create a custom animation that does not rely on D3
    transition or interpolation at all; essentially a custom animation created from
    scratch. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code generates a box where a timer is set to **0**, and by clicking
    on **Start** the timer increases until it reaches **100** and stops, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2162OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom timer-based animation
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we have constructed a custom animation that moves integer
    from 0 to 100\. For such a simple animation, of course we could have accomplished
    it using D3 transition and tweening. However, a simple example like this avoids
    any distraction from the technique itself. Additionally, even in this simple example,
    the timer-based solution is arguably simpler and more flexible than a typical
    transition-based solution. The power house of this animation lies in the `countup`
    function (see line `A`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we have shown in this example, the key to understanding this recipe lies
    in the `d3.timer` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `d3.timer(function, [delay], [mark])` starts a custom timer function and
    invokes the given function repeatedly, until the function returns `true`. There
    is no way to stop the timer once it is started, so the programmer must make sure
    the function eventually returns `true`. Optionally, you can also specify a **delay**
    as well as a **mark**. The delay starts from the mark and when the mark is not
    specified, `Date.now` will be used as the mark. The following illustration shows
    the temporal relationship we discussed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2162OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our implementation, the custom `timer` function increases button caption
    by one, every time it is called (see line `D`) and returns `true` when the value
    reaches `100`, and therefore the the timer is terminated (see line `C`).
  prefs: []
  type: TYPE_NORMAL
- en: Internally, D3 transition uses the same timer function to generate its animation.
    At this point, you might be asking what is the difference between using `d3.timer`
    and using animation frame directly. The answer is that the `d3.timer` actually
    uses animation frame if the browser supports it, otherwise, it is smart enough
    to fall back to use the `setTimeout` function, thus freeing you from worrying
    about browser's support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information on `d3.timer`, please visit its API at the following link:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
