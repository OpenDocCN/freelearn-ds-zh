- en: Chapter 6. Transition with Style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 风格化的过渡
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Animating a single element
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画单个元素
- en: Animating multiple elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画多个元素
- en: Using ease
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓动函数
- en: Using tweening
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓动
- en: Using transition chaining
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过渡链
- en: Using transition filter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用过渡过滤器
- en: Listening to transitional events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 听取过渡事件
- en: Implementing custom interpolator
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义插值器
- en: Working with timer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '"A picture is worth a thousand words."'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"一张图片胜过千言万语。"'
- en: 'This age-old wisdom is arguably one of the most important cornerstones of data
    visualization. Animation on the other hand is generated using a series of still
    images in quick succession. Human eye-and-brain complex, through positive afterimage,
    phi phenomenon, and beta movement is able to create an illusion of continuous
    imagery. As Rick Parent put it perfectly in his brilliant work *Computer Animation
    Algorithms and Techniques*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这句古老的智慧可以说是数据可视化最重要的基石之一。另一方面，动画是通过一系列快速连续的静态图像生成的。人类的眼睛和大脑通过正后像、Phi 现象和 beta
    运动，能够创造出连续图像的错觉。正如 Rick Parent 在其杰出的作品《计算机动画算法和技术》中完美地表达的那样：
- en: Images can quickly convey a large amount of information because the human visual
    system is a sophisticated information processor. It follows, then, that moving
    images have the potential to convey even more information in a short time. Indeed,
    the human visual system has evolved to provide for survival in an ever-changing
    world; it is designed to notice and interpret movement.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图片可以迅速传达大量信息，因为人类的视觉系统是一个复杂的信息处理器。因此，动态图像在短时间内传达更多信息具有潜力。事实上，人类的视觉系统已经进化，以适应不断变化的世界；它被设计用来注意和解释运动。
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -Parent R. 2012
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '- 父亲 R. 2012'
- en: This is indeed the main goal of animation used in data visualization projects.
    In this chapter, we will focus on the mechanics of **D3 transition**, covering
    topics from the basics to more advanced ones, such as custom interpolation and
    timer-based transition. Mastering transition is not only going to add many bells
    and whistles to your otherwise dry visualization, but will also provide a powerful
    toolset to your visualization and otherwise hard-to-visualize attributes, such
    as trending and differences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是数据可视化项目中使用动画的主要目标。在本章中，我们将重点关注 **D3 过渡** 的机制，涵盖从基础知识到更高级的主题，例如自定义插值和基于计时器的过渡。掌握过渡不仅将为你的可视化增添许多亮点，还将为你提供一套强大的工具集，用于可视化那些难以可视化的属性，如趋势和差异。
- en: What is Transition?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是过渡？
- en: D3 transition offers the ability to create computer animation with HTML and
    SVG elements on a web page. D3 transition implements an animation called **Interpolation-based
    Animation**. Computer's are especially well equipped for value interpolation,
    and therefore, most of the computer animations are interpolation-based. As its
    name suggests, the foundation for such animation capability is value interpolation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: D3 过渡提供了在网页上使用 HTML 和 SVG 元素创建计算机动画的能力。D3 过渡实现了一种称为 **基于插值的动画** 的动画。计算机特别擅长值插值，因此，大多数计算机动画都是基于插值的。正如其名称所暗示的，这种动画能力的基础是值插值。
- en: If you recall, we have already covered D3 interpolators and interpolation functions
    in detail in [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"), *Tipping
    the Scales*. Transition is built on top of interpolation and scales to provide
    the ability to change values over time, which produces animation. Each transition
    can be defined using a start and end value (also called **key frames** in animation),
    while different algorithms and interpolators will fill in the intermediate values
    frame-by-frame (also called "in-betweening" or simply "tweening"). At the first
    glance, if you are not already familiar with animation algorithms and techniques,
    this seems to be a somewhat less controlled way of creating an animation. However,
    it is quite the opposite in reality; interpolation-based transitions can provide
    direct and specific expectations about the motion produced down to each and every
    frame, thus offering tremendous control to the animator with simplicity. In fact,
    D3 transition API is so well-designed that, in most cases, only a couple of lines
    of code are enough to implement animations you need in a data visualization project.
    Now, let's get our hands dirty and try out some transitions to further improve
    our understanding on this topic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们已经在[第4章](ch04.html "第4章。平衡技巧")“平衡技巧”中详细介绍了D3插值器和插值函数。过渡建立在插值和缩放之上，以提供随时间改变值的能力，从而产生动画。每个过渡都可以使用起始值和结束值（在动画中也称为**关键帧**）来定义，而不同的算法和插值器将逐帧填充中间值（也称为“中间插值”或简称“tweening”）。乍一看，如果您不熟悉动画算法和技术，这似乎是一种控制动画的较为不严谨的方法。然而，在现实中恰恰相反；基于插值的过渡可以提供对产生的运动直到每一帧的直接和具体期望，从而以简单的方式为动画师提供极大的控制。事实上，D3过渡API设计得如此之好，以至于在大多数情况下，只需要几行代码就足以在数据可视化项目中实现所需的动画。现在，让我们动手尝试一些过渡，以进一步加深我们对这个主题的理解。
- en: Animating a single element
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元素动画
- en: In this recipe, we will first take a look at the simplest case of transition—interpolating
    attributes on a single element over time to produce a simple animation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将首先查看过渡的最简单情况——在单个元素上随时间插值属性以产生简单的动画。
- en: Getting Ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/single-element-transition.html)'
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The code necessary to perform this simple transition is extremely short; good
    news for any animator:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此简单过渡所需的代码非常简短；这对于任何动画师来说都是好消息：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code produces a moving, shrinking, and color-changing square, as shown
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码生成一个移动、缩小和颜色变化的正方形，如下截图所示：
- en: '![How to do it...](img/2162OS_06_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_06_01.jpg)'
- en: Single element transition
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单元素过渡
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You might be surprised to see that the extra code we have added to enable this
    animation is only on line `C` and `D`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现，我们添加以启用此动画的额外代码仅在第`C`行和`D`行：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First on line `C`, we call the `d3.selection.transition` function to define
    a transition. Then, the `transition` function returns a transition-bound selection
    that still represents the same element(s) in the current selection. But now, it
    is equipped with additional functions and allows further customization of the
    transitional behavior. Line `C` returns a transition-bound selection of the `div`
    element we created on line `A`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在第`C`行，我们调用`d3.selection.transition`函数来定义一个过渡。然后，`transition`函数返回一个过渡绑定的选择，它仍然代表当前选择中的相同元素。但现在，它配备了额外的功能，并允许进一步自定义过渡行为。第`C`行返回了第`A`行创建的`div`元素的过渡绑定选择。
- en: 'On line `D`, we set the duration of the transition to `5000` milliseconds using
    the `duration()` function. This function also returns the current transition-bound
    selection, thus allowing function chaining. As we have mentioned at the start
    of this chapter, interpolation-based animations usually only require specifying
    the start and end values while letting interpolators and algorithms fill the intermediate
    values over time. D3 transition treats all values set before calling the `transition`
    function as start values, with values set after the `transition` function call
    as end values. Hence in our example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `D` 行，我们使用 `duration()` 函数将过渡的持续时间设置为 `5000` 毫秒。此函数还返回当前过渡选择，从而允许函数链式调用。正如我们在本章开头提到的，基于插值的动画通常只需要指定起始值和结束值，而让插值器和算法在一段时间内填充中间值。D3
    过渡将调用 `transition` 函数之前设置的值视为起始值，将调用 `transition` 函数之后设置的值视为结束值。因此，在我们的例子中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `background-color` style defined on line `B` is treated as the start value
    for transition. All styles set in the following lines are treated as end values:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `B` 行定义的 `background-color` 样式被视为过渡的起始值。以下行中设置的样式都被视为结束值：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, you might be asking, *why these start and end values are not
    symmetric?*. D3 transition does not require every interpolated value to have explicit
    start and end values. If the start value is missing, then it will try to use the
    computed style, and if the end value is missing then the value will be treated
    as a constant. Once the transition starts, D3 will automatically pick the most
    suitable registered interpolator for each value. In our example, an RGB color
    interpolator will be used in line `E`, while a string interpolator—which internally
    uses number interpolators to interpolate embedded numbers—will be used for the
    rest of the style values. Here we will list the interpolated style values with
    their start and end values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道，*为什么这些起始值和结束值不对称？*。D3 过渡不需要每个插值值都有显式的起始值和结束值。如果缺少起始值，它将尝试使用计算后的样式；如果缺少结束值，则该值将被视为常量。一旦过渡开始，D3
    将自动为每个值选择最合适的已注册插值器。在我们的例子中，第 `E` 行将使用 RGB 颜色插值器，而其余的样式值将使用字符串插值器——该插值器内部使用数字插值器来插值嵌入的数字。以下是我们将列出带有起始值和结束值的插值样式值：
- en: '`background-color`: The start value `#e9967a` is greater than end value `#add8e6`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background-color`: 起始值 `#e9967a` 大于结束值 `#add8e6`'
- en: '`margin-left`: The start value is a computed style and is greater than end
    value `600px`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`margin-left`: 起始值是一个计算后的样式，并且大于结束值 `600px`'
- en: '`width`: The start value is a computed style and it''s greater than the end
    value `100px`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 起始值是一个计算后的样式，并且大于结束值 `100px`'
- en: '`height`: The start value is a computed style and greater than the end value
    `100px`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 起始值是一个计算后的样式，并且大于结束值 `100px`'
- en: Animating multiple elements
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画多个元素
- en: A more elaborate data visualization requires animating multiple elements instead
    of a single element, as demonstrated in the previous recipe. More importantly,
    these transitions often need to be driven by data and coordinated with other elements
    within the same visualization. In this recipe, we will see how a data-driven multielement
    transition can be created to generate a moving bar chart. New bars are added over
    time while the chart shifts from right to left with a smooth transition.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更详细的数据可视化需要动画多个元素而不是单个元素，如前一个食谱所示。更重要的是，这些过渡通常需要由数据驱动，并与同一可视化中的其他元素协调。在本食谱中，我们将看到如何创建一个数据驱动的多元素过渡来生成移动条形图。随着时间的推移，新的条形被添加，图表从右向左平滑过渡。
- en: Getting Ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/multi-element-transition.html)'
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As expected, this recipe is slightly larger than the previous one, however,
    not by that much. Let''s take a look at the code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，这个食谱比之前的稍微大一些，但并不是很大。让我们看看代码：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code generates a sliding bar chart in your web browser, as shown
    in the following screenshots:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在您的网页浏览器中生成一个滑动条形图，如下截图所示：
- en: '![How to do it...](img/2162OS_06_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2162OS_06_02.jpg)'
- en: Sliding bar chart
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动条形图
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: On the surface, this example seems to be quite complex with complicated effects.
    Every second a new bar needs to be created and animated while the rest of the
    bars need to slide over precisely. The beauty of D3 set-oriented functional API
    is that it works exactly the same way no matter how many elements you are manipulating;
    therefore, once you understand the mechanics, you will realize this recipe is
    not so much different than the previous one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这个例子似乎相当复杂，效果复杂。每秒钟都需要创建一个新的条形并对其进行动画处理，同时其余的条形需要精确滑动。D3 集合导向函数的美丽之处在于，无论你操作多少元素，它的工作方式都是完全相同的；因此，一旦你理解了机制，你就会发现这个配方与之前的配方并没有太大的不同。
- en: 'First step, we created a data-bound selection for a number of vertical bars
    (on line `A`), which can then be used in a classic enter-update-exit D3 pattern:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，我们在行`A`上创建了一组垂直条形的数据绑定选择，然后可以使用经典的进入-更新-退出 D3 模式：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One thing we have not touched so far is the second parameter in the `d3.selection.data`
    function. Here, we know that this function is called an **object-identity function**.
    The purpose of using this function is to provide object constancy. What it means
    in simple terms is that we want the binding between data and visual element to
    be stable. In order to achieve object constancy, each datum needs to have a unique
    identifier. Once the ID is provided, D3 will ensure if a `div` element is bound
    to `{id: 3, value: 45}`. Then, the next time when the update selection is computed,
    the same `div` element will be used for the datum with the same `id`, though this
    time the value might get changed, for example, `{id: 3, value: 12}`. Object constancy
    is crucial in this recipe; without object constancy, the sliding effect will not
    work.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '我们尚未涉及的是`d3.selection.data`函数的第二个参数。在这里，我们知道这个函数被称为**对象身份函数**。使用此函数的目的是提供对象恒常性。简单来说，我们希望数据与视觉元素之间的绑定是稳定的。为了实现对象恒常性，每个数据项都需要有一个唯一的标识符。一旦提供了
    ID，D3 将确保如果`div`元素绑定到`{id: 3, value: 45}`，那么在更新选择计算时，相同的`div`元素将被用于具有相同`id`的数据项，尽管这次值可能已更改，例如`{id:
    3, value: 12}`。对象恒常性在这个配方中至关重要；没有对象恒常性，滑动效果将无法工作。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'If you are interested to know more about object constancy, please check this
    excellent writing by Mike Bostock, the creator of D3 at the following link:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于对象恒常性的信息，请查看以下链接中 Mike Bostock 的这篇优秀文章，他是 D3 的创造者：
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[http://bost.ocks.org/mike/constancy/](http://bost.ocks.org/mike/constancy/)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bost.ocks.org/mike/constancy/](http://bost.ocks.org/mike/constancy/)'
- en: 'The second step is to create these vertical bars with the `d3.selection.enter`
    function and compute the `left` position for each bar based on the index number
    (see line `B`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是使用`d3.selection.enter`函数创建这些垂直条形，并根据索引号计算每个条形的`left`位置（见行`B`）：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another point worth mentioning here is that in the `enter` section, we have
    not called transition yet, which means any value we specify here will be used
    as the start value in a transition. If you notice on line `C`, bar `height` is
    set to `0px`. This enables the animation of bars growing from zero height to the
    target `height`. At the same time, the same logic is applied to the `left` position
    of the bar (see line `B`) and was set to `barLeft(i+1)`, thus enabling the sliding
    transition we desired.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在`enter`部分，我们尚未调用过渡，这意味着我们在这里指定的任何值都将用作过渡的起始值。如果你注意到行`C`，条形`高度`被设置为`0px`。这使条形从零高度增长到目标`高度`的动画成为可能。同时，相同的逻辑也应用于条形的`left`位置（见行`B`），并被设置为`barLeft(i+1)`，从而实现了我们想要的滑动过渡。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After completing the `enter` section, now we can take care of the `update`
    section, where the transition is defined. First of all, we want to introduce transition
    for all updates, therefore, we invoke the `transition` function before any style
    change is applied (see line `D`). Once the transition-bound selection is created,
    we applied the following style transitions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成进入（`enter`）部分后，我们现在可以处理更新（`update`）部分，其中定义了过渡。首先，我们希望为所有更新引入过渡，因此，在应用任何样式更改之前，我们调用`transition`函数（见行`D`）。一旦创建了过渡绑定的选择，我们应用以下样式过渡：
- en: '`"top"`: `chartHeight + "px" > chartHeight - barHeight(d)+"px"`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"top"`: `chartHeight + "px" > chartHeight - barHeight(d)+"px"`'
- en: '`"left"`: `barLeft(i+1) + "px" > barLeft(i) + "px"`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"left"`: `barLeft(i+1) + "px" > barLeft(i) + "px"`'
- en: '`"height"`: `"0px" > barHeight(d) + "px"`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"height"`: `"0px" > barHeight(d) + "px"`'
- en: 'The aforementioned three style transitions are all you need to do to handle
    new bars as well as every existing bar and their sliding effect. Finally, the
    last case we need to handle here is the `exit` case, when a bar is no longer needed.
    So, we want to keep the number of bars constant on the page. This is handled in
    the `exit` section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三种样式过渡就是处理新条形图以及每个现有条形图及其滑动效果所需的所有操作。最后，我们需要处理的最后一个情况是`exit`情况，当一个条形图不再需要时。因此，我们希望页面上条形图的数量保持不变。这在`exit`部分进行处理：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far in this book, prior to this chapter, we have always called the `remove()`
    function immediately after the `d3.selection.exit` function. This immediately
    removes the elements that are no longer needed. In fact, the `exit()` function
    also returns a selection, and therefore, can be animated before calling the `remove()`
    function. This is exactly what we did here, starting a transition on line `E`
    using the `exit` selection; then we animated the left value with the following
    transition change:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章之前，我们一直是在调用`d3.selection.exit`函数后立即调用`remove()`函数。这立即移除了不再需要的元素。实际上，`exit()`函数也返回一个选择集，因此可以在调用`remove()`函数之前进行动画处理。这正是我们在这里所做的事情，使用`exit`选择集在行`E`上开始过渡；然后我们使用以下过渡更改来动画化左值：
- en: '`left`: `barLeft(i) + "px" > barLeft(i-1) + "px"`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`: `barLeft(i) + "px" > barLeft(i-1) + "px"`'
- en: Since we are always removing the left-most bar, this transition moves the bar
    left and out of the SVG canvas, then removes it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们总是移除最左边的条形图，这个过渡将条形图向左移动并移出SVG画布，然后将其删除。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `exit` transition is not necessarily limited to simple transitions, such
    as the one we have shown in this recipe. In some visualization, it could be as
    elaborate as the `update` transition.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`过渡不一定局限于简单的过渡，就像我们在本食谱中展示的那样。在某些可视化中，它可能像`update`过渡一样复杂。'
- en: Once the `render` function is in place with the defined transition, all that
    is left is to simply update the data and re-render our bar chart every second
    using the `setInterval` function. Now this completes our example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`render`函数就绪并定义了过渡，剩下的就是简单地更新数据，并使用`setInterval`函数每秒重新渲染我们的条形图。现在这个例子就完成了。
- en: Using ease
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓动
- en: Transition can be thought of as a function of time. It is a function that maps
    time progression into numeric value progression, which then results in object
    motion (if the numeric value is used for positioning) or morphing (if the value
    is used to describe other visual attributes). Time always travels at a constant
    pace; in other words time progression is uniform (unless you are doing visualization
    near a black hole of course), however, the resulting value progression does not
    need to be uniform. **Easing** is a standard technique to provide flexibility
    and control to this kind of mapping. When a transition generates a uniform value
    progression, it is called **linear** **easing**. D3 provides support for different
    types of easing capabilities, and in this recipe, we will explore different built-in
    D3 easing functions, as well as how to implement custom easing functions with
    D3 transition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡可以被视为时间的函数。它是一个将时间进程映射到数值进程的函数，然后导致对象运动（如果数值用于定位）或变形（如果数值用于描述其他视觉属性）。时间总是以恒定的速度前进；换句话说，时间进程是均匀的（当然，除非你在黑洞附近进行可视化），然而，结果数值进程不需要是均匀的。**缓动**是提供这种映射灵活性和控制的标准技术。当一个过渡生成均匀的数值进程时，它被称为**线性****缓动**。D3提供了对不同类型缓动功能的支持，在本例中，我们将探索不同的内置D3缓动函数，以及如何使用D3过渡实现自定义缓动函数。
- en: Getting Ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/easing.html)'
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following code example, we will demonstrate how transition easing can
    be customized on an element-by-element basis:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将演示如何基于元素逐个自定义过渡缓动：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code produces a set of moving boxes with different easing effects.
    The following screenshot is captured at the time the easing effect takes place:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了一组具有不同缓动效果的移动框。以下截图是在缓动效果发生时的截图：
- en: '![How to do it...](img/2162OS_06_03.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_06_03.jpg)'
- en: Different easing effects
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的缓动效果
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we have shown a number of different built-in D3 ease functions
    and their effects on transition. Let''s take a look at how it is done. First,
    we have created an array to store different ease modes we want to demonstrate:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了多个不同的内置D3缓动函数及其对过渡的影响。让我们看看它是如何实现的。首先，我们创建了一个数组来存储我们想要展示的不同缓动模式：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While all the built-in ease functions are defined simply using their name, the
    last element of this array is a custom easing function (**quadric easing**). Then
    afterwards, a set of `div` elements created using this data array and a transition
    with different easing functions was created for each of the `div` element, respectively,
    moving them from `("left", "500px")` to `("left", "10px")`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有内置的缓动函数都简单地使用它们的名称定义，但这个数组的最后一个元素是一个自定义的缓动函数（**二次缓动**）。然后，使用这个数据数组创建了一组
    `div` 元素，并为每个 `div` 元素创建了一个具有不同缓动函数的过渡，将它们从 `("left", "500px")` 移动到 `("left",
    "10px")`。
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, you might be asking, *Why did we not just specify easing using
    a function as we normally would have done for any other D3 attributes?*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道，*为什么我们没有像通常为任何其他D3属性所做的那样使用函数来指定缓动？*
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The reason is that it does not work on the `ease()` function. What we have shown
    on line `D` is a workaround of this limitation, though in real-world projects
    it is fairly rare that you will need to customize easing behavior on a per-element
    basis.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是它不适用于 `ease()` 函数。我们在行 `D` 上展示的是这个限制的解决方案，尽管在实际项目中，你很少需要按元素基础自定义缓动行为。
- en: Note that it is not possible to customize the easing function per-element or
    per-attribute;
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，无法按元素或属性自定义缓动函数；
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: D3 Wiki (2013, August)
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: D3 Wiki (2013年8月)
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Another way to get around this limitation is by using custom tweening, which
    we will cover in the next recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种克服这种限制的方法是使用自定义缓动，我们将在下一个菜谱中介绍。
- en: 'As seen on line `D`, specifying different ease function for D3 transition is
    very straight forward; all you need to do is call the `ease()` function on a transition-bound
    selection. If the pass-in parameter is a string, then D3 will try to find the
    matching function using the name; if not found it will default to **linear**.
    On top of named built-in ease functions, D3 also provides ease mode modifiers
    that you can combine with any ease function to achieve additional effects, for
    example, **sin-out** or **quad-out-in**. Available ease mode modifiers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如在行 `D` 所见，为D3过渡指定不同的缓动函数非常直接；你所需要做的就是在一个过渡绑定的选择上调用 `ease()` 函数。如果传入的参数是一个字符串，那么D3将尝试使用该名称查找匹配的函数；如果没有找到，则默认为
    **linear**。除了命名的内置缓动函数之外，D3还提供了缓动模式修饰符，你可以将其与任何缓动函数结合使用以实现额外的效果，例如，**sin-out**
    或 **quad-out-in**。可用的缓动模式修饰符：
- en: '**in**: default'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**in**: 默认'
- en: '**out**: reversed'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**out**: 反转'
- en: '**in-out**: reflected'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**in-out**: 反射'
- en: '**out-in**: reversed and reflected'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**out-in**: 反转并反射'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The default ease effect used by D3 is **cubic-in-out**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: D3使用的默认缓动效果是 **cubic-in-out**。
- en: 'For the list of supported D3 ease functions please refer to the following link:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于支持的D3缓动函数列表，请参阅以下链接：
- en: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease)'
- en: When a custom ease function is used, the function is expected to take the current
    parametric time value as its parameter in the range of `[0, 1]`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义缓动函数时，该函数应接受当前参数时间值作为其参数，范围在 `[0, 1]` 之间。
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In our example, we have implemented a simple quadric easing function, which
    is actually available as a built-in D3 ease function, and is named as **quad**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们实现了一个简单的二次缓动函数，这实际上是一个内置的D3缓动函数，命名为 **quad**。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on easing and Penner''s equations (most of the modern
    JavaScript framework implementations including D3 and jQuery) check out the following
    link:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缓动和彭纳方程（包括D3和jQuery在内的大多数现代JavaScript框架实现）的更多信息，请查看以下链接：
- en: '[http://www.robertpenner.com/easing/](http://www.robertpenner.com/easing/)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.robertpenner.com/easing/](http://www.robertpenner.com/easing/)'
- en: Using tweening
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓动
- en: '**Tween** comes from the word "inbetween", which is a common practice performed
    in traditional animation where after key frames were created by the master animator,
    less experienced animators were used to generate frames in between the key frames.
    This phrase is borrowed in modern computer-generated animation and it refers to
    the technique or algorithm controlling how the "inbetween" frames are generated.
    In this recipe, we will examine how the D3 transition supports tweening.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tween** 来自单词 "inbetween"，这是传统动画中的一种常见做法，在关键帧由主动画师创建后，经验较少的动画师被用来生成关键帧之间的帧。这个短语被借用到现代计算机生成的动画中，它指的是控制“inbetween”帧如何生成的技术或算法。在本食谱中，我们将检查D3过渡如何支持tweening。'
- en: Getting Ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/tweening.html)'
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following code example, we will create a custom tweening function to
    animate a button label through nine discrete integral numbers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将创建一个自定义的tweening函数来通过九个离散整数来动画化按钮标签：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code generates two buttons morphing at a very different rate,
    and the following screenshot is taken while this process is going on:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码生成了两个以非常不同的速率变形的按钮，以下截图是在此过程进行时的截图：
- en: '![How to do it...](img/2162OS_06_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/2162OS_06_04.jpg)'
- en: Tweening
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Tweening
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, the first button was created using simple transition with linear
    easing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，第一个按钮是使用简单的带有线性缓动的过渡创建的：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The transition changes the button''s width from `"150px"` to `"400px"`, while
    changing its value from `"0"` to `"9"`. As expected, this transition simply relies
    on continuous linear interpolation of these values using D3 string interpolator.
    In comparison, the second button has the effect of changing these values in chunks.
    Moving from 1 to 2, then to 3, and so on up to 9\. This is achieved using D3 tweening
    support with `attrTween` and `styleTween` functions. Let''s first take a look
    at how the button value tweening works:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡将按钮的宽度从 `"150px"` 变更到 `"400px"`，同时将其值从 `"0"` 变更到 `"9"`。正如预期的那样，这个过渡仅仅依赖于使用D3字符串插值器对这些值的连续线性插值。相比之下，第二个按钮的效果是分块地改变这些值。从1变到2，然后到3，依此类推，直到9。这是通过使用D3的`attrTween`和`styleTween`函数的tweening支持来实现的。让我们首先看看按钮值tweening是如何工作的：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code snippet, we can see that instead of setting the end value
    for the value attribute as we have done in the case of the first button, we use
    `attrTween` function and offered a tweening function `valueTween`, which is implemented
    as the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到，与我们在第一个按钮的情况下设置值属性的结束值不同，我们使用`attrTween`函数并提供了一个tweening函数`valueTween`，其实现如下：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In D3, a tween function is expected to be a factory function, which constructs
    the actual function that will be used to perform the tweening. In this case, we
    have defined a `quantize` scale that maps the domain `[0, 1]` to a discrete integral
    range of `[1, 9]`, on line `C`. The actual tweening function defined on line `D`
    simply interpolates the parametric time value using the quantize scale which generates
    the jumping integer effect.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3中，一个tween函数预期是一个工厂函数，它构建用于执行tweening的实际函数。在这种情况下，我们定义了一个`quantize`比例尺，它将域`[0,
    1]`映射到离散的整数范围`[1, 9]`，在行`C`上。实际在行`D`上定义的tweening函数简单地使用量化比例尺插值参数时间值，从而生成跳跃整数效果。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Quantize scales are a variant of linear scale with a discrete range rather
    than continuous. For more information on quantize scales, please visit the following
    link:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 离散比例尺是线性比例尺的一种变体，它有一个离散的范围而不是连续的范围。有关离散比例尺的更多信息，请访问以下链接：
- en: '[https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize](https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize](https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize)'
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'At this point we have touched upon all three concepts related to transition:
    ease, tween, and interpolation. Typically, D3 transition is defined and driven
    through all the three levels shown in the following sequence diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经触及了与过渡相关的三个概念：缓动、tween和插值。通常，D3过渡是通过以下序列图中的三个级别定义和驱动的：
- en: '![There''s more...](img/2162OS_06_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/2162OS_06_05.jpg)'
- en: Drivers of transition
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡的驱动因素
- en: As we have shown through multiple recipes, D3 transition supports customization
    in all three levels. This gives us tremendous flexibility to customize the transition
    behavior exactly the way we want.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们通过多个配方所展示的，D3 过渡支持在三个级别上进行自定义。这给了我们极大的灵活性，可以精确地自定义过渡行为。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Though custom tween is usually implemented using interpolation, there is no
    limit to what you can do in your own tween function. It is entirely possible to
    generate custom tween without using D3 interpolator at all.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义缓动通常使用插值来实现，但你在自己的缓动函数中可以做到的事情没有限制。完全有可能在不使用 D3 插值器的情况下生成自定义缓动。
- en: We used linear easing in this recipe to highlight the effect of tweening, however,
    D3 fully supports **eased tweening**, meaning that you can combine any of the
    ease functions we have demonstrated in the previous recipe with your custom tween
    to generate even more complex transition effects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了线性缓动来突出缓动效果，然而，D3 完全支持 **缓动缓动**，这意味着你可以将我们在上一个配方中展示的任何缓动函数与你的自定义缓动结合，以生成更复杂的过渡效果。
- en: Using transition chaining
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过渡链式连接
- en: The first four recipes in this chapter are focused on single transition controls
    in D3, including custom easing and tweening functions. However, sometimes regardless
    of how much easing or tweening you do, a single transition is just not enough,
    for instance, you want to simulate teleporting a `div` element by first squeezing
    the `div` element into a beam, then passing the beam to a different position on
    the web page, and finally restoring the `div` to its original size. In this recipe,
    we will see exactly how this type of transition can be achieved using **transition
    chaining**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前四个配方专注于 D3 中的单个过渡控制，包括自定义缓动和缓动函数。然而，有时无论你进行多少缓动或缓动，单个过渡都远远不够，例如，你想要通过首先将
    `div` 元素挤压成光束，然后将光束传递到网页上的不同位置，最后将 `div` 恢复到原始大小来模拟传送 `div` 元素。在这个配方中，我们将看到如何使用
    **过渡链式连接** 来实现这种类型的过渡。
- en: Getting Ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/chaining.html)'
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Our simple teleportation transition code is surprisingly short:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的传送过渡代码出奇地短：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code performs a `div` teleportation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码执行了一个 `div` 传送：
- en: '![How to do it...](img/2162OS_06_06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_06_06.jpg)'
- en: DIV teleportation via transition chaining
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过过渡链式连接实现 DIV 传送
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This simple teleportation effect was achieved by chaining a few transitions
    together. In D3, when transitions are chained, they are guaranteed to be executed
    only after the previous transition reaches its completion state. Now, let''s see
    how this is done in the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的传送效果是通过链式连接几个过渡来实现的。在 D3 中，当过渡链式连接时，它们保证只有在之前的过渡达到完成状态后才会执行。现在，让我们看看代码中是如何实现的：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first transition was defined and initiated on line `A` (compression), then
    on line `B` a second transition (beaming) was created, and finally the third transition
    is chained on line `C` (restoration). Transition chaining is a powerful yet simple
    technique to orchestrate a complex transition effect by stitching simple transitions
    together. Finally in this recipe, we have also shown a basic example on re-usable
    composite transition effect by wrapping the teleportation transition in a function
    and then applying it on a selection using the `d3.selection.call` function (see
    line `D`). Re-usable transition effect is essential to following the DRY (Don't
    Repeat Yourself) principle, especially when the animation in your visualization
    becomes more elaborate.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个过渡在行 `A`（压缩）上定义并启动，然后在行 `B` 上创建了一个第二个过渡（光束），最后第三个过渡在行 `C`（恢复）上链式连接。过渡链式连接是一种强大而简单的技术，通过将简单的过渡连接在一起来编排复杂的过渡效果。最后在这个配方中，我们还展示了通过将传送过渡包装在函数中，然后使用
    `d3.selection.call` 函数在选择上应用它（见行 `D`）的基本示例，以实现可重用组合过渡效果。可重用过渡效果对于遵循 DRY（不要重复自己）原则至关重要，尤其是在你的可视化动画变得更加复杂时。
- en: Using transition filter
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过渡过滤器
- en: Under some circumstances, you might find it necessary to selectively apply transition
    to a subset of a certain selection. In this recipe, we will explore this effect
    using data-driven transition filtering techniques.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要选择性地将过渡应用于某个选择的子集。在这个食谱中，我们将使用数据驱动过渡过滤技术来探索这种效果。
- en: Getting Ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/filtering.html)'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we will move a set of `div` elements (or boxes) across the
    web page from right to left. After moving all the boxes to the left, we selectively
    move only the boxes that are marked with **Cat** back, so they won''t fight each
    other. Let''s see the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将一组 `div` 元素（或方框）从网页的右侧移动到左侧。在将所有方框移动到左侧后，我们将仅选择性地将标记为 **Cat** 的方框移回，这样它们就不会相互争斗。让我们看看以下代码：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is what the page looks like after the transition:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 页面过渡后的样子如下所示：
- en: '![How to do it...](img/2162OS_06_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_06_07.jpg)'
- en: Transition filtering
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡过滤
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The initial setup of this recipe is quite simple, since we want to keep the
    plumbing as minimal as possible which will help you focus on the core of the technique.
    We have a data array containing interlaced strings of `"Cat"` and `"Dog"`. Then
    a set of `div` boxes are created for the data and a transition was created (see
    line `A`) to move all the boxes across the web page to the left-hand side. So
    far, it is a simple example of a multi-element transition with no surprises yet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的初始设置相当简单，因为我们希望将管道保持尽可能少，这将有助于您专注于技术的核心。我们有一个包含交错字符串 `"Cat"` 和 `"Dog"`
    的数据数组。然后为数据创建了一组 `div` 方框，并创建了一个过渡（见行 `A`），将所有方框移动到网页的左侧。到目前为止，这是一个多元素过渡的简单示例，还没有任何惊喜：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then on line `B`, `d3.selection.filter` function is used to generate a subselection
    containing only the "cat" boxes. Remember, D3 transition is still a selection
    (transition-bound selection), therefore, the `d3.selection.filter` function works
    exactly the same way as on a regular selection. Once the subselection is generated
    by the `filter` function, we can apply a secondary transition (see line `C`) to
    this subselection alone. The `filter` function returns a transition-bound subselection;
    therefore, the second transition created on line `C` is actually generating a
    transition chain. It will only be triggered after the first transition reaches
    its completion. By using combinations of transition chaining and filtering we
    can generate some really interesting data-driven animations; it is a useful tool
    to have in any data visualizer's toolset.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在行 `B`，使用了 `d3.selection.filter` 函数来生成只包含 "cat" 方框的子选择。记住，D3 过渡仍然是一个选择（过渡绑定选择），因此，`d3.selection.filter`
    函数在常规选择上的工作方式完全相同。一旦通过 `filter` 函数生成了子选择，我们就可以单独对此子选择应用一个二级过渡（见行 `C`）。`filter`
    函数返回一个过渡绑定的子选择；因此，行 `C` 上创建的第二个过渡实际上是在生成一个过渡链。它将在第一个过渡完成之后才会被触发。通过使用过渡链和过滤的组合，我们可以生成一些真正有趣的数据驱动动画；这是任何数据可视化工具集中的一个有用工具。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For recipes on D3 data-driven selection filtering, please see the *Filtering
    with data* recipe [Chapter 3](ch03.html "Chapter 3. Dealing with Data"), *Dealing
    with Data*
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 D3 数据驱动选择过滤的食谱，请参阅 *使用数据过滤* 食谱 [第 3 章](ch03.html "第 3 章。处理数据")，*处理数据*
- en: Read about API doc for the `selection.filter` function at [https://github.com/mbostock/d3/wiki/Selections#wiki-filter](https://github.com/mbostock/d3/wiki/Selections#wiki-filter)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `selection.filter` 函数的 API 文档，请参阅 [https://github.com/mbostock/d3/wiki/Selections#wiki-filter](https://github.com/mbostock/d3/wiki/Selections#wiki-filter)
- en: Listening to transitional events
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监听过渡事件
- en: Transition chaining gives you the ability to trigger secondary transitions after
    the initial transition reaches its completion state; however, sometimes you might
    need to trigger certain action other than a transition, or maybe do something
    else during the transition. This is what transition event listeners are designed
    for, they are the topic of this recipe.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡链允许在初始过渡达到完成状态后触发二级过渡；然而，有时您可能需要触发除过渡之外的其他某些操作，或者可能在过渡期间做其他事情。这就是过渡事件监听器设计的目的，它们是本食谱的主题。
- en: Getting Ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/events.html)'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will demonstrate how to display different captions on an
    animated `div` element based on its transition state. Obviously, this example
    can easily be extended to perform more meaningful tasks using the same technique:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将演示如何根据动画 `div` 元素的转换状态显示不同的标题。显然，这个例子可以很容易地扩展以使用相同的技术执行更有意义的任务：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code produces the following visual output where a box appears
    with **waiting** label; it moves to the right with the label changed to **transitioning**
    and when it''s done, it stops moving and changes its label to **done**:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码产生以下视觉输出，其中出现一个带有**等待**标签的框；它向右移动，标签变为**转换中**，完成后停止移动并将标签改为**完成**：
- en: '![How to do it...](img/2162OS_06_08.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/2162OS_06_08.jpg)'
- en: Transition event handling
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 转换事件处理
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we constructed a single `div` element with a simple horizontal-movement
    transition, which, when initiated, also changes the label based on what transition
    state it is in. Let''s first take a look at how we manage to display the **waiting**
    label:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们构建了一个具有简单水平移动转换的单个 `div` 元素，当它被启动时，也会根据其转换状态更改标签。让我们首先看看我们是如何显示**等待**标签的：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The **waiting** label is set on line `A` before the transition is defined on
    line `B`, however, we also specified a delay for the transition thus showing the
    **waiting** label before the transition is initiated. Next, let''s find out how
    we were able to display the **transitioning** label during the transition:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义在行 `B` 上的转换之前，在行 `A` 上设置了**等待**标签，然而，我们也为转换指定了延迟，因此在转换开始之前显示了**等待**标签。接下来，让我们看看我们是如何在转换期间显示**转换中**标签的：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is achieved by calling the `each()` function and selecting its first parameter
    set as `"start"` event name with an event listener function passed in as the second
    parameter. The `this` reference of the event listener function points to the current
    selected element, hence, can be wrapped by D3 and further manipulated. The transition
    `"end"` event is handled in an identical manner:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过调用 `each()` 函数并选择其第一个参数设置为 `"start"` 事件名称，并将事件监听器函数作为第二个参数传递来实现的。事件监听器函数的
    `this` 引用指向当前选定的元素，因此可以被 D3 包装并进行进一步操作。转换 `"end"` 事件以相同的方式处理：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The only difference here is that the event name is passed into the `each()`
    function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是事件名称被传递到 `each()` 函数中。
- en: Implementing a custom interpolator
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义插值
- en: In [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"), *Tipping the Scales*,
    we explored how custom interpolators can be implemented in D3\. In this recipe,
    we will demonstrate how this technique can be combined with D3 transition to generate
    special transition effects by leveraging custom interpolation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章 *Tipping the Scales* 的 *Tipping the Scales* 中，我们探讨了如何在 D3 中实现自定义插值器。在这个配方中，我们将演示如何将这种技术与
    D3 转换结合使用，通过利用自定义插值生成特殊的转换效果。
- en: Getting Ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/custom-interpolator-transition.html)'
- en: This recipe builds on top of what we have discussed in the *Implementing a custom
    interpolator* recipe in [Chapter 4](ch04.html "Chapter 4. Tipping the Scales"),
    *Tipping the Scales*. If you are not familiar with the concept of custom interpolation,
    please review the related recipe before proceeding with this one.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方建立在我们在第 4 章 *Tipping the Scales* 中讨论的 *Implementing a custom interpolator*
    配方之上，*Tipping the Scales*。如果您不熟悉自定义插值的概念，请在继续此配方之前先查看相关配方。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at the code of the `custom-interpolator-transition.html` file and
    see how it works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `custom-interpolator-transition.html` 文件的代码，看看它是如何工作的：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code generates one ticking box that starts from **a** and finishes
    at **z**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个从 **a** 开始并结束于 **z** 的跳动框：
- en: '![How to do it...](img/2162OS_06_09.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_06_09.jpg)'
- en: Transition with custom interpolation
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义插值进行过渡
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First thing we did in this recipe is register a custom interpolator that is
    identical to the alphabet interpolator we discussed in [Chapter 4](ch04.html "Chapter 4. Tipping
    the Scales"), *Tipping the Scales*:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先注册了一个自定义插值器，它与我们在第 4 章（[第 4 章. 调整比例](ch04.html "第 4 章. 调整比例")）中讨论的字母插值器相同：*调整比例*：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the custom interpolator is registered, the transition part has pretty
    much no custom logic at all. Since it''s based on the value that needs to be interpolated
    and transitioned upon, D3 will automatically pick the correct interpolator to
    perform the task:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了自定义插值器，过渡部分几乎没有任何自定义逻辑。因为它基于需要插值和过渡的值，D3 会自动选择正确的插值器来完成这项任务：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see in the preceding code snippet, the start value is `"a"`, defined
    on line `B`. Afterwards, a standard D3 transition is created on line `C` and finally
    all we had to do is set the end value to `"z"` on line `D`, then D3 and our custom
    interpolator takes care of the rest.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，起始值是 `"a"`，在行 `B` 中定义。之后，在行 `C` 上创建了一个标准的 D3 过渡，最后我们只需在行 `D` 上将结束值设置为
    `"z"`，然后 D3 和我们的自定义插值器就会处理剩下的部分。
- en: Working with timer
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计时器
- en: So far in this chapter we have discussed various topics on D3 transition. At
    this point you might be asking the question, *What is powering D3 transition that
    is generating the animated frames?*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们已经讨论了 D3 过渡的各个方面。此时你可能会问，*是什么在驱动 D3 过渡，从而生成动画帧？*
- en: In this recipe, we will explore a low-level D3 timer function that you can leverage
    to create your own custom animation from scratch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索一个低级的 D3 计时器函数，你可以利用它从头开始创建自己的自定义动画。
- en: Getting Ready
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html](https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter6/timer.html)'
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe, we will create a custom animation that does not rely on D3
    transition or interpolation at all; essentially a custom animation created from
    scratch. Let''s look at the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个不依赖于 D3 过渡或插值的自定义动画；本质上是从头开始创建的自定义动画。让我们看看以下代码：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code generates a box where a timer is set to **0**, and by clicking
    on **Start** the timer increases until it reaches **100** and stops, as shown
    in the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个盒子，其中计时器被设置为 **0**，通过点击 **开始**，计时器增加到 **100** 并停止，如下所示：
- en: '![How to do it...](img/2162OS_06_10.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/2162OS_06_10.jpg)'
- en: Custom timer-based animation
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 基于计时器的自定义动画
- en: How it works...
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, we have constructed a custom animation that moves integer
    from 0 to 100\. For such a simple animation, of course we could have accomplished
    it using D3 transition and tweening. However, a simple example like this avoids
    any distraction from the technique itself. Additionally, even in this simple example,
    the timer-based solution is arguably simpler and more flexible than a typical
    transition-based solution. The power house of this animation lies in the `countup`
    function (see line `A`):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们构建了一个从 0 到 100 移动整数的自定义动画。对于这样简单的动画，当然我们可以使用 D3 过渡和缓动函数来完成。然而，这样的简单例子避免了任何对技术本身的干扰。此外，即使在这样简单的例子中，基于计时器的解决方案在可伸缩性和灵活性方面也优于典型的基于过渡的解决方案。这个动画的强大之处在于
    `countup` 函数（见行 `A`）：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we have shown in this example, the key to understanding this recipe lies
    in the `d3.timer` function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，理解这个菜谱的关键在于 `d3.timer` 函数。
- en: 'This `d3.timer(function, [delay], [mark])` starts a custom timer function and
    invokes the given function repeatedly, until the function returns `true`. There
    is no way to stop the timer once it is started, so the programmer must make sure
    the function eventually returns `true`. Optionally, you can also specify a **delay**
    as well as a **mark**. The delay starts from the mark and when the mark is not
    specified, `Date.now` will be used as the mark. The following illustration shows
    the temporal relationship we discussed here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `d3.timer(function, [delay], [mark])` 开始一个自定义计时器函数，并重复调用给定的函数，直到函数返回 `true`。一旦开始计时器，就无法停止它，因此程序员必须确保函数最终返回
    `true`。可选地，你也可以指定一个 **延迟** 以及一个 **标记**。延迟从标记开始，如果没有指定标记，则使用 `Date.now` 作为标记。以下插图显示了我们所讨论的时间关系：
- en: '![How it works...](img/2162OS_06_11.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/2162OS_06_11.jpg)'
- en: In our implementation, the custom `timer` function increases button caption
    by one, every time it is called (see line `D`) and returns `true` when the value
    reaches `100`, and therefore the the timer is terminated (see line `C`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，自定义的 `timer` 函数每次被调用时（见行 `D`）都会将按钮标题增加一，当值达到 `100` 时返回 `true`，因此计时器终止（见行
    `C`）。
- en: Internally, D3 transition uses the same timer function to generate its animation.
    At this point, you might be asking what is the difference between using `d3.timer`
    and using animation frame directly. The answer is that the `d3.timer` actually
    uses animation frame if the browser supports it, otherwise, it is smart enough
    to fall back to use the `setTimeout` function, thus freeing you from worrying
    about browser's support.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，D3 过渡使用相同的计时器函数来生成其动画。在这个时候，你可能想知道使用 `d3.timer` 和直接使用动画帧有什么区别。答案是，如果浏览器支持的话，`d3.timer`
    实际上会使用动画帧，否则，它会足够智能地回退到使用 `setTimeout` 函数，从而让你不必担心浏览器的支持问题。
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For more information on `d3.timer`, please visit its API at the following link:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `d3.timer` 的更多信息，请访问以下链接的API：
- en: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer)'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer](https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer)'
