<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="packt"/>
<title>9 Calling External APIs to Enrich Your Data</title>



</head>
<body>


<h1 data-number="10">9 Calling External APIs to Enrich Your Data</h1>
<p>In the previous chapter, you saw an example of how to enrich the data you already have with external information. In that instance, the data was provided via CSV files, but this is not always the case. Very often, the data useful for enrichment is exposed via external <strong>Application Programming Interfaces</strong> (<strong>APIs</strong>), most frequently in the form of web service endpoints. Power BI allows you to read data from a web service via a dedicated UI, but most of the time it is unusable. Therefore, you have to resort to writing <strong>M code</strong> to get it done. Writing M code isn't too difficult, but it’s not that straightforward either. You also have to be careful not to write code that leads to refresh issues when publishing the report to the Power BI service. Moreover, in Power BI, it is not possible to parallelize more than one call to the same web service in order to reduce waiting time when retrieving data. Adopting Python or R to get data from a web service solves all these issues very easily.</p>
<p>In this chapter, you will learn the following topics:</p>
<ul>
<li>What a web service is</li>
<li>Registering for Bing Maps Web Services</li>
<li>Geocoding addresses using Python</li>
<li>Geocoding addresses using R</li>
<li>Accessing web services using Power BI</li>
</ul>

<h2 data-number="10.1">Technical requirements</h2>
<p>This chapter requires you to have a working internet connection and <strong>Power BI Desktop</strong> already installed on your machine. You must have properly configured the R and Python engines and IDEs as outlined in <em>Chapter 2</em>, <em>Configuring R with Power BI</em>, and <em>Chapter 3</em>, <em>Configuring Python with Power BI</em>.</p>


<h2 data-number="10.2">What a web service is</h2>
<p>In the course of your work as an analyst, you may need to retrieve data through an API, exposed by a system within your network, for example. However, this is a rare case, since today almost all external data sources are exposed as <strong>web services</strong>, even within a company.</p>
<p>Web services are the most common and popular way of communicating information between heterogeneous information systems. A web service is basically a software module hosted on a server that is available over the internet to provide data to specific requests from a client.</p>
<p>There are mostly two types of design models for web services: <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) and <strong>REpresentational State Transfer</strong> (<strong>REST</strong>).</p>
<ul>
<li>SOAP relies heavily on <strong>XML</strong> and defines a highly typed messaging structure through schemas. All messages exchanged between the service and the client are all encoded through <strong>Web Service Definition Language</strong> (<strong>WSDL</strong>), which, in turn, is based on the XML format. One of the most important aspects of WSDL is that it defines a binding contract between the service provider and each service consumer. Therefore, any change to the API involves a change to be made to the client. Nowadays, almost everything that matters runs on HTTP. But keep in mind that, in addition to HTTP, SOAP can take advantage of any other transport protocol (such as SMTP and TCP).</li>
<li>REST is becoming the default design model for all public APIs. It is an architecture that relies exclusively on the HTTP protocol (as opposed to SOAP). It doesn’t use WSDL contracts and is, therefore, more flexible and faster to implement. REST can handle data in any format, such as XML or YAML, but the most used is surely <strong>JSON</strong>. Unlike SOAP, which is function-driven, REST is very <strong>data-driven</strong>. It is for this reason that all web services used for data enrichment are <strong>RESTful</strong> (take a look at the references for more details) and can generate output in any format – not only JSON but also CSV, or <strong>Really Simple Syndication</strong> (<strong>RSS</strong>), for example! Basically, REST offers a lighter method of interacting with the service, using URLs in most cases to receive or send information. The exposed basic methods are <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code>.</li>
</ul>
<p>Quite often, you will have heard about web service <strong>endpoints</strong>. In general, a web service works by accepting <code>GET</code> requests from the client and providing responses to them. Considering a REST API, an endpoint is a URL at which the web service can be accessed by a client application. A web service can provide more than one endpoint. If you consider <strong>Bing Maps REST Services</strong>, for example, the endpoint used for geocoding is as follows: <code>dev.virtualearth.net/REST/v1/Locations</code>. The one used instead to provide a route between two waypoints is this one: <code>dev.virtualearth.net/REST/v1/Routes</code>.</p>
<p>Now that it's clear what a web service is and what the meaning of the technical terms that often come with it is, we can move on to showing you how to use a RESTful one.</p>


<h2 data-number="10.3">Registering for Bing Maps Web Services</h2>
<p>In this chapter, we will use Bing Maps Web Services as an example. Therefore, you need to create a free Bing Maps Basic Key via your Microsoft account. The necessary steps to do so are as follows:</p>
<ol>
<li>Go to <a href="https://www.microsoft.com/en-us/maps/create-a-bing-maps-key">https://www.microsoft.com/en-us/maps/create-a-bing-maps-key</a>, select the <strong>Basic Key</strong> option just after the main banner, and then click on <strong>Get a free Basic key</strong> button.</li>
<li>On the next <strong>Welcome</strong> page, click on <strong>Sign in</strong> and use your Microsoft Account to log in.</li>
<li>On the next page, you will be notified that this is the first time your email is being used to authenticate in the <strong>Bing Maps Dev Center</strong>. Click on <strong>Yes, let's create a new account</strong> to create a new account.</li>
<li>Enter your account details on the next page and click <strong>Create</strong>. After that, you’ll be logged in to the Dev Center, and you’ll see some claims on the page saying <strong>Announcement</strong> and <strong>Important reminder</strong>.</li>
<li>On that page, under the <strong>My account</strong> menu, click on <strong>My keys</strong>.</li>
<li>You will be prompted with a form asking for a new key . Just fill the required fields, entering <code>geocoding-test</code> in the <strong>Application name</strong> field, and leaving <code>Basic</code> as <strong>Key type</strong> and <code>Dev/Test</code> as <strong>Application type</strong>. Then, click on <strong>Create</strong>.</li>
<li><p>A page will appear to confirm that the key has been created, such as the following one:</p>
<figure>
<img src="img/file227.png" alt="Figure 9.1 – Bing Maps key confirmation" /><figcaption aria-hidden="true">Figure 9.1 – Bing Maps key confirmation</figcaption>
</figure></li>
<li>Click on <strong>Show key</strong> to see the key you’ll use in the next examples and copy it.</li>
<li>Enter the following URL in your browser URL bar, replacing the <code>&lt;your-bing-maps-api-key&gt;</code> string with your key: <a href="http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=%3Cyour-bing-maps-api-key%3E">http://dev.virtualearth.net/REST/v1/Locations/1%20Microsoft%20Way%20Redmond%20WA%2098052?key=&lt;your-bing-maps-api-key&gt;</a>. Then, press <em>Enter</em>.</li>
<li>Some browsers, such as Firefox, prettify JSON responses returned by web services. In your case, if all goes well, you should see a result such as the following:</li>
</ol>
<figure>
<img src="img/file228.png" alt="Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the browser" /><figcaption aria-hidden="true">Figure 9.2 – Your first geocoding using the Bing Maps Locations API via the browser</figcaption>
</figure>
<p>Great! You’ve just geocoded an address passed as a query parameter to the Bing Maps Locations API! Let's now see how to use Python to automate this process.</p>


<h2 data-number="10.4">Geocoding addresses using Python</h2>
<p>In this section, we'll show you how to make calls to the Bing Maps Locations API using both a direct call to the URL via the <code>GET</code> method (which is ultimately equivalent to the example call you made earlier via the browser) and a dedicated Python <strong>Software Development Kit</strong> (<strong>SDK</strong>) that facilitates the query.</p>

<h3 data-number="10.4.1">Using an explicit GET request</h3>
<p>If we want to receive geocoding data for an address from the Bing API, we need to make a request to the web service by passing the address of interest as a parameter. The parameters are passed through appropriate concatenation of the parameters with the URL of the endpoint. In our case, the full format of the endpoint URL useful for geocoding an address is as follows:</p>
<figure>
<img src="img/file229.png" alt="Figure 9.3 – URL format of a GET request to the Bing Maps Locations API" /><figcaption aria-hidden="true">Figure 9.3 – URL format of a GET request to the Bing Maps Locations API</figcaption>
</figure>
<p>The following is the definition of each string token you can see in <em>Figure 9.3</em>:</p>
<ul>
<li><code>base_url</code>: The endpoint URL string, that is, <code>http://dev.virtualearth.net/REST/v1/Locations/</code></li>
<li><code>address</code>: The string of the address that you want to geocode, transformed using the <em>percent encoding</em> technique to avoid using special characters in the final URL</li>
<li><code>AUTH_KEY</code>: Your Bing key</li>
</ul>
<p>Once the URL has been built in this way, it can be used to make a <code>GET</code> request via the <code>get()</code> method of the <code>requests</code> module. After getting the data as a result of the request, you’ll capture the content of the web service response containing JSON, and from that, you can extract the values of interest. For example, in order to extract the <code>formattedAddress</code> value, you have to navigate into the data structure, as shown in <em>Figure 9.4</em>:</p>
<figure>
<img src="img/file230.png" alt="Figure 9.4 – Visual structure of the Bing Maps Locations API response" /><figcaption aria-hidden="true">Figure 9.4 – Visual structure of the Bing Maps Locations API response</figcaption>
</figure>
<p>So, you can navigate your JSON variable <code>data</code>, in the same way to get that value, as follows:</p>
<pre><code>data[&#39;resourceSets&#39;][0][&#39;resources&#39;][0][&#39;address&#39;][&#39;formattedAddress&#39;]</code></pre>
<p>From <em>Figure 9.4</em>, you can see that the resources node can contain more than one subnode, identified with an integer. This is because sometimes the geocoding engine cannot exactly identify the geographic point from the passed address and therefore returns more than one result. The <code>estimatedTotal</code> attribute indicates the number of possible geocodes identified. For simplicity, we have extracted from the JSON the last identified resource, which is the one with the highest identifier.</p>
<p>Besides the answer in JSON format, from the request, you can also extract other values, such as the reason for the state of the answer (useful to understand whether the <code>GET</code> operation is successful or not), the complete content of the answer in text format, and the URL used for the <code>GET</code> request. You will need the <code>requests</code>, <code>urllib</code>, <code>json</code>, <code>pandas</code>, and <code>time</code> modules. The latter is used to measure the geocoding execution time of all addresses in the dataset. Everything can be encapsulated in a handy function called <code>bing_geocode_via_address()</code>:</p>
<pre><code>def bing_geocode_via_address(address):
    # trim the string from leading and trailing spaces using strip
    full_url = f&quot;{base_url}query={urllib.parse.quote(address.strip(), safe=&#39;&#39;)}?key={AUTH_KEY}&quot;
    r = requests.get(full_url)
    try:
        data = r.json()
        # number of resources found, used as index to get 
        # the latest resource
        num_resources = data[&#39;resourceSets&#39;][0][&#39;estimatedTotal&#39;]
        formattedAddress = data[&#39;resourceSets&#39;][0][&#39;resources&#39;][num_resources-1][&#39;address&#39;][&#39;formattedAddress&#39;]
        lat = data[&#39;resourceSets&#39;][0][&#39;resources&#39;][num_resources-1][&#39;point&#39;][&#39;coordinates&#39;][0]
        lng = data[&#39;resourceSets&#39;][0][&#39;resources&#39;][num_resources-1][&#39;point&#39;][&#39;coordinates&#39;][1]
    except:
        num_resources = 0
        formattedAddress = None
        lat = None
        lng = None
    
    text = r.text
    status = r.reason
    url = r.url
    
    return num_resources, formattedAddress, lat, lng, text, status, url</code></pre>
<p>The code chunks contained in this section are available in the <code>01-geocoding-with-python.py</code> file inside the <code>Chapter09\Python</code> folder.</p>
<p>Assuming we have a list of addresses to geocode in a pandas DataFrame, it makes sense to write a handy function that takes as input a DataFrame row and the column name in which the address is stored. It will invoke the previous function to get geocoding values to add to the current row and will return it:</p>
<pre><code>def enrich_with_geocoding(passed_row, col_name):
    # Fixed waiting time to avoid the &quot;Too many requests&quot; 
    # error as basic accounts are limited to 5 queries per second
    time.sleep(3)
    address_value = str(passed_row[col_name])
    
    num_resources, address_formatted, address_lat, address_lng, text, status, url = bing_geocode_via_address(address_value)
    
    passed_row[&#39;numResources&#39;] = num_resources
    passed_row[&#39;formattedAddress&#39;] = address_formatted
    passed_row[&#39;latitude&#39;] = address_lat
    passed_row[&#39;longitude&#39;] = address_lng
    passed_row[&#39;text&#39;] = text
    passed_row[&#39;status&#39;] = status
    passed_row[&#39;url&#39;] = url
    
    return passed_row</code></pre>
<p>You can test these functions using the test dataset at this link: <a href="http://bit.ly/geocoding-test-addresses">http://bit.ly/geocoding-test-addresses</a>. It’s also available in the <code>Chapter09</code> folder.</p>
<p>You have to simply pass the previous function as a parameter to the addresses' DataFrame <code>apply()</code> method to apply it to each of its rows, shown as follows:</p>
<pre><code>base_url= &quot;http://dev.virtualearth.net/REST/v1/Locations/&quot;
AUTH_KEY = os.environ.get(&#39;BINGMAPS_API_KEY&#39;)
df_orig = pd.read_csv(r&#39;D:\&lt;your-path&gt;\Chapter09\geocoding_test_data.csv&#39;, encoding=&#39;latin-1&#39;)
df = df_orig[[&#39;full_address&#39;,&#39;lat_true&#39;,&#39;lon_true&#39;]]
tic = time.perf_counter()
enriched_df = df.apply(enrich_with_geocoding, col_name=&#39;full_address&#39;, axis=1)
toc = time.perf_counter()
print(f&quot;{df.shape[0]} addresses geocoded in {toc - tic:0.4f} seconds&quot;)</code></pre>
<p>Note that the Bing Maps services key is set using the <code>os.environ.get('BINGMAPS_API_KEY')</code> function call. This way of accessing sensitive data avoids having to write it in plain text in the code. So, it must have been previously written to the <code>BINGMAPS_API_KEY</code> environment variable. You can also do this with Python via the following script:</p>
<pre><code> os.environ[&#39;BINGMAPS_API_KEY&#39;] = &#39;&lt;your-bing-api-key&gt;&#39;</code></pre>
<p>This way, however, each time you restart Visual Studio Code, that variable will be lost. To have it permanently available, you must set up a user variable environment directly through your operating system. In Windows, you can follow this guide: <a href="https://phoenixnap.com/kb/windows-set-environment-variable">https://phoenixnap.com/kb/windows-set-environment-variable</a>. Once added, you must restart Visual Studio Code to make it visible to your code.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>We preferred to load the CSV file directly into the Python script. It would have been equivalent to first loading the CSV file via the Power BI <strong>Text/CSV</strong> connector and then adding a transformation step that would run the Python code we just analyzed.</p>
</blockquote>
<p>The geocoding operation takes about 34 seconds for 120 addresses. Part of the content of the final DataFrame is as follows:</p>
<figure>
<img src="img/file231.png" alt="Figure 9.5 – Content of the geocoded DataFrame" /><figcaption aria-hidden="true">Figure 9.5 – Content of the geocoded DataFrame</figcaption>
</figure>
<p>Impressive! You geocoded as many as 120 addresses with just a few lines of Python code in 34 seconds. But did you know that you can also parallelize <code>GET</code> requests by geocoding all your addresses in less time? Let's see how you can achieve this.</p>


<h3 data-number="10.4.2">Using an explicit GET request in parallel</h3>
<p>Just as you learned in <em>Chapter 8</em>, <em>Loading Large Datasets beyond the Available RAM in Power BI</em>, the Swiss army knife that allows you to parallelize your computations in Python is Dask. The great thing is that a Dask DataFrame exposes the <code>apply()</code> method, which has the same functionality as a pandas DataFrame’s <code>apply()</code>function, with the difference that it is parallelized. Therefore, the code used in the previous section is practically reusable with a few minor modifications to achieve significantly reduced execution times. You can find the full script in the <code>02-geocoding-parallel-with-python.py</code> file in the <code>Chapter09\Python</code> folder.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>When the API requires it, it is preferable to provide multiple inputs using <strong>batch mode</strong>, rather than making multiple calls in parallel. However, if batch mode is not covered by the API, multiple parallel calls are the only way to improve execution times. The Bing Maps Locations API supports batch mode, but for demonstration purposes, we preferred to adopt the multiple call technique.</p>
</blockquote>
<p>The <code>enrich_with_geocoding()</code> and <code>bing_geocode_via_address()</code> functions remain as they are. Instead, the Dask DataFrame is introduced already at the data reading stage, as follows:</p>
<pre><code>import dask.dataframe as dd
ddf_orig = dd.read_csv(r&#39;D:\&lt;your-path&gt;\Chapter09\geocoding_test_data.csv&#39;, encoding=&#39;latin-1&#39;)
ddf = ddf_orig[[&#39;full_address&#39;,&#39;lat_true&#39;,&#39;lon_true&#39;]]</code></pre>
<p>Internally, a Dask DataFrame is divided into many partitions, where each partition is a pandas DataFrame. Now, it happens that when the data is not a large amount, it may be loaded in a single partition by <code>read_csv()</code>. In fact, if you run the following code: <code>ddf.npartitions</code>, you will see that it returns <code>1</code>. It is for this reason that in cases such as this, it is necessary to repartition the Dask DataFrame into an appropriate number of partitions to benefit from parallelism, as follows:</p>
<pre><code>ddf = ddf.repartition(npartitions=os.cpu_count()*2)</code></pre>
<p>The following applies to the number of partitions in a DataFrame:</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>There is no precise rule for determining the ideal number of partitions in a DataFrame. The formula used earlier is effective for the dataset we are considering here and has been determined empirically.</p>
</blockquote>
<p>At this point, you have to simply invoke the <code>apply()</code> method of the Dask DataFrame by passing it the <code>enrich_with_geocoding()</code> function, as you did with the <code>apply()</code> method of the pandas DataFrame in the previous section:</p>
<pre><code>enriched_ddf = ddf.apply(enrich_with_geocoding, axis=1, col_name=&#39;full_address&#39;, meta={&#39;full_address&#39;: &#39;string&#39;, &#39;lat_true&#39;: &#39;float64&#39;, &#39;lon_true&#39;: &#39;float64&#39;, &#39;numResources&#39;: &#39;int32&#39;, &#39;formattedAddress&#39;: &#39;string&#39;, &#39;latitude&#39;: &#39;float64&#39;, &#39;longitude&#39;: &#39;float64&#39;, &#39;text&#39;: &#39;string&#39;, &#39;status&#39;: &#39;string&#39;, &#39;url&#39;: &#39;string&#39;})</code></pre>
<p>In this case, we had to specify the expected metadata of the output. This is because many operations on DataFrames rely on knowing the name and type of the column. Internally, Dask DataFrame does its best to propagate this information through all operations. Usually, this is done by evaluating the operation on a small sample of dummy data. Sometimes, however, this operation can fail in user-defined functions (such as in the case of <code>apply</code>). In these cases, many functions support an optional <code>meta</code> keyword, which allows you to specify the metadata directly, avoiding the inference step.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>Dask DataFrame’s <code>apply()</code> method now supports only the <code>axis=1</code> mode (row-wise).</p>
</blockquote>
<p>You’ve just defined a lazy transformation. To actually perform it, you must use the <code>compute()</code> function, so in this case, you can measure the time it takes to geocode all the addresses:</p>
<pre><code>tic = time.perf_counter()
enriched_df = enriched_ddf.compute()
toc = time.perf_counter()
print(f&#39;{enriched_df.shape[0]} addresses geocoded in {toc - tic:0.4f} seconds&#39;)</code></pre>
<p>The end result is stunning: 120 addresses were geocoded in <em>just 3.5 seconds</em> versus 35 seconds for sequential code! You have achieved a 10x improvement in running time thanks to Dask!</p>
<p>As you've seen in this section and the previous one, the most uncomfortable part of the code is perhaps retrieving every single value from the JSON returned by the web service (the logic in the <code>bing_geocode_via_address()</code> function), because you have to know in advance the structure of the result obtained. However, there are Python modules that contain functions that facilitate interaction with specific web services. Let's see how to use the <code>Geocoder</code> library, which simplifies the adoption of the most widely used geocoding providers, such as those of Google and Bing.</p>


<h3 data-number="10.4.3">Using the Geocoder library in parallel</h3>
<p>The <strong>Geocoder</strong> module (<a href="https://geocoder.readthedocs.io/">https://geocoder.readthedocs.io/</a>) is a simple and consistent geocoding library written in Python. It makes consistent responses from expected geocoding providers using a unique JSON schema. Some of the providers available are Google, Bing, Mapbox, and TomTom.</p>
<p>First, you need to install the Geocoder library in the <code>pbi_powerquery_env</code> environment. You can do that by following these steps:</p>
<ol>
<li>Open the Anaconda prompt.</li>
<li>Switch to the <code>pbi_powerquery_env</code> environment by entering this command: <code>conda activate pbi_powerquery_env</code>.</li>
<li>Install the Geocoder library by entering this command: <code>pip install geocoder</code>.</li>
</ol>
<p>Thanks to Geocoder, the <code>GET</code> request for an address is simply transformed into the command <code>r = geocoder.bing(address, key = AUTH_KEY)</code>. And the great thing is that the returned object, <code>r</code>, already contains the attributes useful for geocoding, such as <code>r.address</code>, <code>r.lat</code>, or <code>r.lng</code>. Therefore, the <code>bing_geocode_via_address()</code> function you encountered in the previous sections is embarrassingly simplified, as follows:</p>
<pre><code>def bing_geocode_via_address(address):
    r = geocoder.bing(address, key = AUTH_KEY)
    return r.address, r.lat, r.lng, r.json, r.status, r.url</code></pre>
<p>In this case, Geocoder selects the most appropriate match if the geocoding operation returns more than one match, saving you from further headaches. The option to return multiple results is currently an in-progress development. In more recent versions of the package, it is possible to pass the <code>MaxRows</code> parameter with a value greater than one to the geocoding functions to obtain as many possible results as the value passed. In this way, it is the analyst who can choose the outcome that meets their needs.</p>
<p>You can find the complete script that uses the Geocoder library to geocode addresses in parallel in the <code>03-geocoding-parallel-using-sdk-with-python.py</code> file in the <code>Chapter09\Python</code> folder.</p>
<p>You can now understand that having an SDK available that is designed to simplify your life in using a specific API is a major boon.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>One of the overarching principles we always suggest is to <em>avoid reinventing the wheel</em> every time you need it. If you need to accomplish a goal (in our case, geocoding an address), most likely someone before you has already thought of it and perhaps shared a library with the community that simplifies your life. Always spend a half-hour searching the web for possible pre-existing solutions that can smartly solve your problem. In addition to saving valuable time, you avoid the risk of going crazy with complexities that others have already overcome for you.</p>
</blockquote>
<p>Although we knew of the existence of the Geocoder library, we still wanted to show you how to make <code>GET</code> requests to the web service from scratch in the previous sections. This is because it is not certain that SDKs exist for all web services that you may need in the future.</p>
<p>Let's now see how to get the same results using R.</p>



<h2 data-number="10.5">Geocoding addresses using R</h2>
<p>You have just learned how to query a web service via raw <code>GET</code> requests to the endpoint and via a handy SDK using Python. As you can already guess, you can also do both with R. Let's see how it’s done.</p>

<h3 data-number="10.5.1">Using an explicit GET request</h3>
<p>The package that allows calls to URLs in R is <code>httr</code> (installed by default with the engine). Making a <code>GET</code> request simply translates to <code>GET(your_url)</code> thanks to it. As you have already seen in the previous sections, <strong>percent encoding</strong> must be applied to the address to be passed as a web parameter to the Bing Maps Locations API endpoint. The function that allows you to apply this type of encoding to a string is found in the <code>RCurl</code> package and is named <code>curlPercentEncode()</code>. In addition, the handy <code>tictoc</code> package will be used to measure run times. Both the <code>RCurl</code> and <code>tictoc</code> packages need to be installed, as shown in the following steps:</p>
<ol>
<li>Open RStudio and make sure it is referencing your latest CRAN R engine in <strong>Global Options</strong>.</li>
<li>Click on the <strong>Console</strong> window and enter this command: <code>install.packages("RCurl")</code>. Then press <em>Enter</em> key.</li>
<li>Enter this command: <code>install.packages("tictoc")</code>. Then press <strong>Enter</strong>.</li>
</ol>
<p>At this point, once you have defined the <code>base_url</code> and <code>AUTH_KEY</code> variables specific to the web service to query, it is enough to execute the following code to obtain the result of a <code>GET</code> request:</p>
<pre><code>encoded_address &lt;- RCurl::curlPercentEncode(address)
full_url &lt;- stringr::str_glue(&#39;{base_url}query={encoded_address}?key={AUTH_KEY}&#39;)
r &lt;- httr::GET(full_url)</code></pre>
<p>The <code>str_glue()</code> function of the <code>stringr</code> package has been used to concatenate the strings. Note that also, in this case, the <code>AUTH_KEY</code> variable is set from an environment variable using <code>AUTH_KEY = Sys.getenv('BINGMAPS_API_KEY')</code>. This means that the environment variable must be set beforehand. You can set it directly in your R session using the following R script:</p>
<pre><code>Sys.setenv(BINGMAPS_API_KEY = &#39;&lt;your-bing-api-key&gt;&#39;)</code></pre>
<p>This way, however, each time you restart RStudio, that variable will be lost. To have it permanently available, you must set up a user variable environment directly through your operating system. In Windows, you can follow this guide: <a href="https://phoenixnap.com/kb/windows-set-environment-variable">https://phoenixnap.com/kb/windows-set-environment-variable</a>. Once added, you must restart RStudio to make it visible to your code.</p>
<p>Once you have obtained the result of the request, you can proceed to parse the JSON content to obtain the desired geocoding values. Everything that was taken into account for parsing the result in the previous sections still applies. So again, you will have to handle the multiple results that some geocoding operations might return. As already done for the Python scripts used previously, all this logic can be encapsulated into the <code>bing_geocode_via_address()</code> function in R that returns a list of values obtained as a result of geocoding a passed address. You can find the code in the <code>01-geocoding-with-r.R</code> file in the <code>R\Chapter09</code> folder.</p>
<p>Once you have loaded the contents of the <code>geocoding_test_data.csv</code> file into the <code>tbl_orig</code> tibble and selected the columns of interest in <code>tbl</code>, you will exploit the convenience of the <code>purrr</code> package's <code>map()</code> function to execute the previous defined <code>bing_geocode_via_address()</code> function for each address extracted from the tibble:</p>
<pre><code>tic()
tbl_enriched &lt;- tbl %&gt;%
    pull( full_address ) %&gt;% 
    map_dfr( ~ bing_geocode_via_address(.x) ) %&gt;% 
    bind_cols( tbl, . )
toc()</code></pre>
<p>Note how we used the <code>pull()</code> function to transform the <code>full_address</code> tibble column into a vector and then passed it as a parameter to the <code>map_dfr()</code> function, which only accepts lists or vectors as input. You may be wondering what the <code>map_dfr()</code> function is for. It is part of the <code>purrr</code> family of <code>map()</code> functions. While <code>map()</code> returns a list of results (each obtained by applying the input function to each element of the input vector) as output, <code>map_dfr()</code> directly binds rows when each element of the <code>map()</code> output is a named DataFrame, list, or vector. So the final result of <code>map_dfr()</code> is a DataFrame/tibble composed of the elements returned by the input function arranged row by row. The whole logic is wrapped by the pair of functions, <code>tic()</code> and <code>toc()</code>. By running the entire block of code (from <code>tic()</code> to <code>toc()</code> inclusive), you can get the execution time of the code inside very conveniently.</p>
<p>You may have noticed that there is no need in this case for an intermediate function such as <code>enrich_with_geocoding()</code> that accepts the individual lines of the tibble as a parameter. Since the <code>bing_geocode_via_address()</code> function returns a named list, the <code>map_dfr()</code> function manages to interpret it correctly and bind it into a single tibble.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>We preferred to load the CSV file directly into the R script. It would have been equivalent to first loading the CSV file via the Power BI <strong>Text/CSV</strong> connector and then adding a transformation step that would run the R code we just analyzed.</p>
</blockquote>
<p>Since <code>map_dfr()</code> only returns a tibble of geocoding values, you have to bind this tibble to the initial <code>tbl</code> one in order to have a single enriched tibble. For this reason, we used the function <code>bind_cols(tbl, .)</code>, where the parameter <code>.</code> denotes the tibble of geocoding values passed as a parameter by the piping operation. That said, the whole geocoding operation takes about 30 seconds (which is comparable to the result obtained with Python), and the final tibble will look as follows:</p>
<figure>
<img src="img/file232.png" alt="Figure 9.6 – Content of the geocoded DataFrame" /><figcaption aria-hidden="true">Figure 9.6 – Content of the geocoded DataFrame</figcaption>
</figure>
<p>Well done! You were able to geocode addresses via the web service even with R. Easy, right? Are you now curious to learn how to do this by taking advantage of the parallelism provided by your machine? Let's see how to proceed.</p>


<h3 data-number="10.5.2">Using an explicit GET request in parallel</h3>
<p>Just as in Python, we had to use the Dask module to parallelize computations; in R, we need to introduce a new package to achieve the same thing. The new package is called <code>furrr</code> (<a href="https://furrr.futureverse.org/">https://furrr.futureverse.org/</a>) and is intended to combine the expressive power of the <code>purrr</code> family of mapping functions with the parallel processing capabilities provided by the <strong>future</strong> package (<a href="https://future.futureverse.org/">https://future.futureverse.org/</a>). Both the <code>furrr</code> and <code>future</code> packages are part of an interesting framework called <strong>Futureverse</strong> (<a href="https://www.futureverse.org/">https://www.futureverse.org/</a>), which aims to parallelize existing R code in the simplest way. In practical terms, <code>furrr</code> allows you to replace the <code>map()</code> and <code>map_*()</code> functions of <code>purrr</code> with the <code>future_map()</code> and <code>future_map_*()</code> functions of <code>furrr</code> with minimal effort, and your code will magically run in parallel. Keep in mind that the future engine is also the backend used by the <code>disk.frame</code> packages you learned about in <em>Chapter 8</em>, <em>Loading Large Datasets beyond the Available RAM in Power BI</em>.</p>
<p>First of all, you need to install the <code>furrr</code> package. Just run the command <code>install.packages("furrr")</code> in the RStudio’s <strong>Console</strong> window and that’s it.</p>
<p>To apply what has just been said to the code analyzed in the previous section, it is enough to modify the last part of it as follows to obtain the same result (and obviously loading the <code>furrr</code> library instead of <code>purrr</code>), but while parallelizing the computations:</p>
<pre><code>n_cores &lt;- availableCores() - 1
plan(cluster, workers = n_cores)
tic()
tbl_enriched &lt;- tbl %&gt;%
    pull( full_address ) %&gt;% 
    future_map_dfr( ~ bing_geocode_via_address(.x) ) %&gt;% 
    bind_cols( tbl, . )
toc()</code></pre>
<p>Thanks to the <code>availableCores()</code> function, it is possible to identify the number of virtual processors present on the machine. It is good practice not to use all of them as it can make the machine unresponsive. The <code>plan()</code> function of a future instance allows you to define the strategy with which the future engine performs the calculations (synchronously or asynchronously). It also allows you to define the number of workers that will work in parallel.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>Generally, the default strategy used on Windows machines is <strong>multisession</strong> and it works fine running the code in RStudio. We found that with this strategy, Power BI cannot handle the multiple sessions generated to parallelize computations. Instead, we found that selecting the <strong>cluster</strong> strategy, despite the machine being unique, allows Power BI to complete the computations.</p>
</blockquote>
<p>Another minimal change was to declare the <code>base_url</code> and <code>AUTH</code> variables associated with the web service directly in the function invoked by <code>future_map_dfr()</code> instead of in the main code for simplicity. Passing variables to functions invoked via <code>furrr</code> is done slightly differently than in standard practice (follow this link: <a href="https://furrr.futureverse.org/articles/articles/gotchas.html">https://furrr.futureverse.org/articles/articles/gotchas.html</a>), and we wanted to avoid adding minimal complexity so as not to distract from the main concept.</p>
<p>You can find the full script in the <code>02-geocoding-parallel-with-r.R</code> file in the <code>Chapter09\R</code> folder.</p>
<p>If you run the code, you will get impressive results: 120 addresses were geocoded in <em>just 3 seconds</em> versus 30 seconds for sequential code! Also, in this case, you achieved a 10x improvement in running time thanks to <code>furrr</code>! Simple as that, right?</p>
<p>You can further simplify the code you just ran by adopting a geocoding package that does the bulk of the work for you in invoking the web service. Let's see what this is all about.</p>


<h3 data-number="10.5.3">Using the tidygeocoder package in parallel</h3>
<p>The <code>tidygeocoder</code> (<a href="https://jessecambon.github.io/tidygeocoder/">https://jessecambon.github.io/tidygeocoder/</a>) package provides a unified high-level interface for a selection of supported geocoder services and returns results in tibble format. Some of the providers available are Google, Mapbox, TomTom, and Bing (starting with version 1.0.3).</p>
<p>First of all, you need to install it. If you want to install the latest version, remember to reset the snapshot repository using the following code:</p>
<pre><code>local({
  r &lt;- getOption(&quot;repos&quot;)
  r[&quot;CRAN&quot;] &lt;- &quot;https://cloud.r-project.org/&quot;
  options(repos = r)
})</code></pre>
<p>Then, you can simply run the <code>install.packages("tidygeocoder")</code> command in the Console window.</p>
<p>Thanks to Tidygeocoder, the <code>GET</code> request for an address is simply transformed into the <code>details_tbl &lt;- geo(address, method = 'bing', full_results = TRUE)</code> command, and the great thing is that the returned object, <code>r</code>, already contains the attributes useful for geocoding, such as <code>details_tbl$bing_address.formattedAddress</code>. Therefore, the <code>bing_geocode_via_address()</code> function you encountered in the previous sections is embarrassingly simplified, as shown in the following code block:</p>
<pre><code>bing_geocode_via_address &lt;- function(address) {
    
    details_tbl &lt;- geo(address, method = &#39;bing&#39;, full_results = TRUE)
        
    details_lst &lt;- list(
        formattedAddress = details_tbl$bing_address.formattedAddress,
        lat = details_tbl$point.coordinates[[1]][1],
        lng = details_tbl$point.coordinates[[1]][2],
        details_tbl = details_tbl
    )
    return( details_lst )
}</code></pre>
<p>Also, in this case, the tidygeocoder package selects the most appropriate match if the geocoding operation returns more than one, saving you from further headaches.</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>Note that Tidygeocoder assumes that the <code>BINGMAPS_API_KEY</code> environment variable has been set and uses it to log in to the web service.</p>
</blockquote>
<p>You can find the complete script that uses the Geocoder library to geocode addresses in parallel in the <code>03-geocoding-parallel-using-sdk-with-r.R</code> file in the <code>Chapter09\R</code> folder.</p>
<p>As you've probably figured out by now, using SDKs available to the community makes your life easier and is a winning choice. If an SDK for a specific web service is not available, you still learned how to make a raw <code>GET</code> request with R.</p>
<p>Let's now look at the benefits of what we've learned so far by implementing web service data enrichment solutions with R and Python in Power BI.</p>



<h2 data-number="10.6">Accessing web services using Power BI</h2>
<p>Power BI already has default features that allow you to access the data exposed by a web service into Power Query. There are two main modes:</p>
<ul>
<li>Via GUI (click on <strong>Get data</strong>, then <strong>Web</strong>, and then you can set advanced options if needed)</li>
<li>Through the M language, using the <code>Web.Contents()</code> function</li>
</ul>
<p>The use of the GUI is very cumbersome and almost always it does not lead to the desired results. The only way to effectively connect to a web service using native Power BI features is to write M code. Writing code in M is not too difficult. However, there are some complications in using the <code>Web.Contents()</code> function that arise when publishing a report that makes use of it to the Power BI service. In short, it is necessary to be careful when you have to build the URL to use in the <code>GET</code> request in a dynamic way, making use of the <strong>relative path</strong> and the <strong>query options</strong>. If you do not use this particular construct, the service will not be able to refresh the data. Moreover, the Power BI service does not allow you to securely store sensitive data, such as the API key, forcing you to embed this information into your code. In addition to that, multiple calls to an endpoint cannot be made in parallel using M.</p>
<p>It is for the reasons listed above that we suggest using R or Python to access web services, especially if SDKs are available to facilitate their use.</p>
<p>Keep in mind that the following restriction applies:</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>If the report that uses web service data has to be published to the Power BI service, you can only query web services through Power Query and not within R visuals because the environment used by them on the service is not exposed on the internet.</p>
</blockquote>
<p>That said, in order to be able to geolocate addresses using the Bing Maps Locations API in Power BI using the scripts we provide, the following clause applies:</p>
<blockquote>
<p><strong>Important Note</strong></p>
<p>You must define the <code>BINGMAPS_API_KEY</code> environment variable as a user environment variable on your operating system to use the geocoding script we’ll provide for Power BI. If the report that makes use of the data extracted from the web service will be published to the Power BI service, make sure to create the same environment variable on the data gateway machine as well.</p>
</blockquote>
<p>Now, let's see how to extract data from a web service in Power BI with Python.</p>

<h3 data-number="10.6.1">Geocoding addresses in Power BI with Python</h3>
<p>In Power BI, we will use the Python code that calls the web service through the Geocoder SDK and exploits the parallelism thanks to Dask. The code to be used is practically identical to that already analyzed previously. Therefore, it is enough to follow these steps:</p>
<ol>
<li>Open Power BI Desktop and make sure it references the <code>pbi_powerquery_env</code> environment.</li>
<li>Click on <strong>Get data</strong>, search and select <strong>Python script</strong>, and then copy the script you can find in the <code>04-geocoding-parallel-using-sdk-in-power-bi-with-python.py</code> file into the <code>Chapter09\Python</code> folder. Make sure to edit the path to the <code>geocoding_test_data.csv</code> file. Then click <strong>OK</strong>.</li>
<li><p>After a few seconds, you will see the <strong>Navigator</strong> window appear, where you can select the <code>enriched_df</code> table:</p>
<figure>
<img src="img/file233.png" alt="Figure 9.7 – The enriched_df DataFrame loaded in Power BI" /><figcaption aria-hidden="true">Figure 9.7 – The enriched_df DataFrame loaded in Power BI</figcaption>
</figure>
<p>Then, click on <strong>Load</strong>.</p></li>
</ol>
<p>You just queried the Bing Maps Locations API from within Power BI in parallel using Python! Easy, right?</p>
<p>It is possible to do the same thing with R. Let's see how to proceed.</p>


<h3 data-number="10.6.2">Geocoding addresses in Power BI with R</h3>
<p>In Power BI, we will use the R code that calls the web service through the Tidygeocoder SDK and that exploits the parallelism thanks to the <code>furrr</code> package. The code to be used is practically identical to that already analyzed previously. Therefore, it is enough to follow these steps:</p>
<ol>
<li>Open Power BI Desktop and make sure it references your latest CRAN R.</li>
<li>Click on <strong>Get data</strong>, search and select <strong>Python script</strong>, and then copy the script you can find in the <code>04-geocoding-parallel-using-sdk-in-power-bi-with-r.R</code> file into the <code>Chapter09\R</code> folder. Make sure to edit the path to the <code>geocoding_test_data.csv</code> file. Then click <strong>OK</strong>.</li>
<li><p>After a few seconds, you will see the <strong>Navigator</strong> window appear, where you can select the <code>tbl_enriched</code> table:</p>
<figure>
<img src="img/file234.png" alt="Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI" /><figcaption aria-hidden="true">Figure 9.8 – The tbl_enriched DataFrame loaded in Power BI</figcaption>
</figure>
<p>Then, click on <strong>Load</strong>.</p></li>
</ol>
<p>You just queried the Bing Maps Locations API from within Power BI in parallel using R too!</p>



<h2 data-number="10.7">Summary</h2>
<p>In this chapter, you learned how to query RESTful web services using Python and R. In addition to learning how to execute raw <code>GET</code> requests with both languages, you've also learned how to parallelize multiple calls to the same endpoint by taking advantage of the multithreading capabilities of your machine. Moreover, you've also come across some SDKs of the Bing Maps Locations API, both for Python and R, which make accessing the data much easier. Finally, you've seen how all of this is easily implemented in Power BI.</p>
<p>In the next chapter, you'll see how to enrich your data by applying complex algorithms to the data you already have. In this way, you will create new variables that give a new light to your data, making it more useful to reach your goal.</p>


<h2 data-number="10.8">References</h2>
<p>For additional reading, check out the following books and articles:</p>
<ol>
<li><em>What RESTful actually means</em> (<a href="https://codewords.recurse.com/issues/five/what-restful-actually-means">https://codewords.recurse.com/issues/five/what-restful-actually-means</a>)</li>
<li><em>Bing Maps REST Services</em> (<a href="https://docs.microsoft.com/en-us/bingmaps/rest-services">https://docs.microsoft.com/en-us/bingmaps/rest-services</a>)</li>
<li><em>A Future for R: A Comprehensive Overview</em> (<a href="https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html">https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html</a>)</li>
<li><em>[VIDEO] Accessing API and web service data using Power Query</em> (<a href="https://www.youtube.com/watch?v=SoJ52o7ni2A">https://www.youtube.com/watch?v=SoJ52o7ni2A</a>)</li>
<li><em>Invoking M Functions In Parallel Using List.ParallelInvoke()</em> (<a href="https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/">https://blog.crossjoin.co.uk/2018/09/20/invoking-m-functions-in-parallel-using-list-parallelinvoke/</a>)</li>
</ol>


</body>
</html>
