- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Data Analysis and Visualization with R and Python in Excel – A Case Study
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R 和 Python 在 Excel 中进行数据分析与可视化 – 案例研究
- en: In this final chapter, we are going to perform an analysis—**visualization**
    and a simple model—built with data from Excel and place all those outcomes back
    into it. This can be useful when there is a lot of data, or the calculations themselves
    are best suited to being done outside of Excel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将执行一个分析——**可视化**和一个简单的模型——使用 Excel 中的数据构建，并将所有这些结果放回其中。当数据量很大，或者计算本身最适合在
    Excel 外部进行时，这可能很有用。
- en: First, we will start with importing our data and then performing some data exploration
    via visualizations. For this chapter, we are going to use the `diamonds` dataset
    from the R package called `ggplot2`. We will view the data where the price is
    the outcome and look at it via different facets of the diamond’s characteristics.
    After the visualizations are done, we will perform some simple modeling to predict
    the price of a diamond based on its characteristics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从导入我们的数据开始，然后通过可视化进行一些数据探索。对于本章，我们将使用名为 `ggplot2` 的 R 包中的 `diamonds` 数据集。我们将查看价格作为结果的数据，并通过钻石特性的不同方面来观察它。在完成可视化后，我们将进行一些简单的建模，以根据其特性预测钻石的价格。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Getting a visualization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取可视化
- en: Performing a simple **machine learning** (**ML**) model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个简单的 **机器学习** （**ML**） 模型
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we will be using the following packages/libraries:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将使用以下包/库：
- en: '`ggplot2 3.4.4`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2 3.4.4`'
- en: '`dplyr 1.1.4`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr 1.1.4`'
- en: '`healthyR 0.2.1`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`healthyR 0.2.1`'
- en: '`readxl 1.4.3`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readxl 1.4.3`'
- en: '`tidyverse 2.0.0`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tidyverse 2.0.0`'
- en: '`janitor 2.2.0`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`janitor 2.2.0`'
- en: '`writexl 1.5.0`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writexl 1.5.0`'
- en: '`healthyR.ai 0.0.13`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`healthyR.ai 0.0.13`'
- en: Getting visualizations with R
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 R 获取可视化
- en: In this section, we are going to go over getting some visualizations of the
    data. We will create several visualizations and give short interpretations of
    the outcomes in them. For this, we will create two histograms in base R and a
    few different visuals using the `ggplot2` library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何获取数据的一些可视化。我们将创建几个可视化，并对其中结果的简短解释。为此，我们将使用基础 R 创建两个直方图，并使用 `ggplot2`
    库创建几个不同的可视化。
- en: Getting the data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'The first thing we need to do is load the libraries and get the data. I am
    working in a directory specific to this book so I can source the function directly
    from the chapter I wrote the `read_excel_sheets()?` function in; your path might
    be different. Let’s look at the code up to this point:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是加载库并获取数据。我在一个特定于这本书的目录中工作，因此我可以直接从我所写的章节中获取函数；你的路径可能不同。让我们看看到目前为止的代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we have done here is to simply call in a few libraries into our environment,
    pull in the sheet reading function, and read in our data. We loaded the `read_excel_sheets()`
    function into our environment using the `source()` command. You might be wondering
    how the data was created for this section, and it is important because it was
    exported from the `ggplot2` library. Here is the code if you want to re-create
    the data so that the preceding code will work, and the following sections will
    also work:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是简单地调用几个库到我们的环境中，拉入读取工作表的函数，并读取我们的数据。我们使用 `source()` 命令将 `read_excel_sheets()`
    函数加载到我们的环境中。你可能想知道本节的数据是如何创建的，这是很重要的，因为它是从 `ggplot2` 库导出的。如果你想要重新创建数据，以便前面的代码可以工作，接下来的部分也可以工作，以下是代码：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have gone over how to produce and read in the data, let’s start
    taking a look at some visuals.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何生成和读取数据，让我们开始看看一些可视化。
- en: Visualizing the data
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化数据
- en: We are going to use two different methods of creating graphs in this section,
    firstly, with base R and secondly with `ggplot2`. With that in mind, let’s get
    started.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两种不同的方法来创建图表，首先使用基础 R，其次使用 `ggplot2`。考虑到这一点，让我们开始吧。
- en: Base R visuals
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础 R 可视化
- en: 'The first thing that we are going to do is to create some histograms of the
    `price` column in the `diamonds` dataset. The price is the outcome variable we
    will use as the predictor in our model in the next section. First, we need to
    create a vector of breaks that will get passed to the histograms. There is much
    literature available on techniques for optimal binning strategies. The basic crux
    is that this will help provide the appropriate shape to the histogram that best
    represents the data. That is a separate topic and not one that we will pursue
    in this book, as it is a topic that can span a book unto itself. There is a function
    called `opt_bin()` from the `healthyR` package that will produce a tibble of break
    points for a `value` column that is passed to it. Let’s look at it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是为`diamonds`数据集中的`price`列创建一些直方图。价格是我们将在下一节中用作模型的预测变量的结果变量。首先，我们需要创建一个将传递给直方图的断点向量。关于最优分箱策略的技巧有很多文献。基本核心是这将有助于为直方图提供适当的形状，以最好地表示数据。这是一个单独的主题，我们不会在本书中探讨，因为这个主题可以单独成为一本书。有一个名为`opt_bin()`的函数来自`healthyR`包，它可以生成一个包含传递给它的`value`列断点的tibble。让我们看看它：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The purpose of doing this is to try and capture the proper density of information
    in the data. The `hist()` base function does a good job of this already with a
    standard method. Now, let’s go ahead and create the plots and see the methods
    side by side. We will use `par(mfrow = c(1, 2))` so that we can plot them side
    by side:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的目的是尝试捕捉数据中适当的信息密度。`hist()`基本函数已经以标准方法很好地完成了这一点。现在，让我们继续创建图表，并看看方法并排展示。我们将使用`par(mfrow
    = c(1, 2))`，这样我们就可以并排绘制它们：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s take a look at what it produced:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它产生了什么：
- en: '![Figure 12.1 – Histogram comparison between default binning and optimal binning](img/B19142_12_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 默认分箱与最优分箱的直方图比较](img/B19142_12_01.jpg)'
- en: Figure 12.1 – Histogram comparison between default binning and optimal binning
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 默认分箱与最优分箱的直方图比较
- en: We can see that the shape of the histogram is slightly different, but again,
    this strategy might not work for you, or you may have another strategy that you
    employ with regularity; this was simply a way to illustrate that different methods
    do exist. That is the end of making visuals via base R; we will now move on to
    using `ggplot2`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到直方图的形状略有不同，但同样，这个策略可能不适合你，或者你可能有一个你经常使用的其他策略；这只是一个说明不同方法确实存在的方法。这就是使用基础R制作视觉效果的全部内容；我们现在将转向使用`ggplot2`。
- en: Visuals with ggplot2
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ggplot2的视觉效果
- en: 'We are now going to make the rest of the visuals with `ggplot2` as I find the
    syntax a bit easier and the graphics one can produce are a bit more sophisticated,
    aside from the fact that the package is part of the `tidyverse`, which means it
    is interoperable with the rest of the packages in it such as `dplyr`. You may
    need to install the `hexbin` package as well. Let’s get started:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`ggplot2`制作其余的视觉效果，因为我发现它的语法更容易一些，而且可以生成的图形更复杂，除了它还是`tidyverse`包的一部分，这意味着它可以与其他包（如`dplyr`）互操作。你可能还需要安装`hexbin`包。让我们开始吧：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here’s a breakdown of the code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的分解。
- en: 'For the data and aesthetics, this is how it goes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据和美学，是这样进行的：
- en: '`df |> ggplot(...)`: This starts the visualization using the data in `df`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`df |> ggplot(...)`: 这使用`df`中的数据开始可视化。'
- en: '`aes(x = carat, y = price, fill = cut)`: This defines aesthetics for the plot:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aes(x = carat, y = price, fill = cut)`: 这定义了绘图的美学：'
- en: '`x`: The x-axis represents the carat weight'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`: x轴代表克拉重量'
- en: '`y`: The y-axis represents the price'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`: y轴代表价格'
- en: '`fill`: The color fill represents the diamond cut'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: 颜色填充代表钻石的切割'
- en: 'For the hexagon geometry, this is what we have:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于六边形几何形状，我们有以下内容：
- en: '`geom_hex(bins = length(breaks), alpha = 1/5)`: This plots hexagons representing
    data points.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_hex(bins = length(breaks), alpha = 1/5)`: 这绘制了代表数据点的六边形。'
- en: '`bins`: This controls the number of bins for the hexagonal grid. Here, it uses
    the same number as defined in `breaks` (not shown in the provided code).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bins`: 这控制了六边形网格的箱数。在这里，它使用与`breaks`中定义的相同数量（在提供的代码中未显示）。'
- en: '`alpha`: This is the opacity of the hexagons, set to 1/5 for better visibility.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`: 这是六边形的透明度，设置为1/5以获得更好的可见性。'
- en: 'For faceting by clarity, this is what we have:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过清晰度分面，我们有以下内容：
- en: '`facet_wrap(~ clarity, scales = "free")`: This groups data into subplots based
    on diamond clarity, with independent color scales for each plot'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facet_wrap(~ clarity, scales = "free")`: 这根据钻石的光度将数据分组到子图中，每个图都有独立的颜色尺度'
- en: 'These are the themes and labels:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主题和标签：
- en: '`theme_minimal()`: This applies a minimal theme for cleaner visuals'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme_minimal()`: 这应用了一个最小主题，以获得更清晰的视觉效果'
- en: '`labs(..., title = "Diamonds Data")`: This adds labels for axes and title.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs(..., title = "Diamonds Data")`: 这为坐标轴和标题添加了标签。'
- en: 'This is the code for the colorblind-friendly color scale:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为色盲友好调色板编写的代码：
- en: '`hr_scale_color_colorblind()`: This ensures the color palette is optimized
    for colorblind viewers'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hr_scale_color_colorblind()`: 这确保了调色板针对色盲观众进行了优化'
- en: Now, let’s check the output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查输出。
- en: '![Figure 12.2 – ggplot2 of diamonds data with hex geometry](img/B19142_12_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 使用六边形几何的ggplot2钻石数据](img/B19142_12_02.jpg)'
- en: Figure 12.2 – ggplot2 of diamonds data with hex geometry
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 使用六边形几何的ggplot2钻石数据
- en: Overall, this code visualizes the relationship between the carat weight, price,
    and cut of diamonds, considering clarity groups with a colorblind-friendly color
    scheme.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，此代码可视化了钻石的克拉重量、价格和切割之间的关系，并考虑了具有色盲友好调色板的光度组。
- en: 'The next visual we will see uses a boxplot to check the dispersion of the data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们将看到的视觉是使用箱线图来检查数据的分散：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Again, let’s see the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们看看输出：
- en: '![Figure 12.3 – ggplot2 boxplot of price dispersion](img/B19142_12_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – ggplot2价格分散箱线图](img/B19142_12_03.jpg)'
- en: Figure 12.3 – ggplot2 boxplot of price dispersion
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – ggplot2价格分散箱线图
- en: 'We can now look at the mean price with a question to ponder: does it show the
    information accurately? Let’s refer to the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以带着一个问题来看平均价格：它是否准确地显示了信息？让我们参考以下代码：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of this code is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![Figure 12.4 – ggplot2 mean price dispersion](img/B19142_12_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – ggplot2平均价格分散](img/B19142_12_04.jpg)'
- en: Figure 12.4 – ggplot2 mean price dispersion
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – ggplot2平均价格分散
- en: 'Here is another view of the mean price, but this time by looking at the mean
    price per carat:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是平均价格的另一视角，但这次是通过查看每克拉的平均价格：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s see what story this tells:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个故事告诉我们什么：
- en: '![Figure 12.5 – ggplot mean price per carat](img/B19142_12_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – ggplot每克拉平均价格](img/B19142_12_05.jpg)'
- en: Figure 12.5 – ggplot mean price per carat
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – ggplot每克拉平均价格
- en: These are very good diamonds – does it matter what the cut or color is as long
    as the clarity is better than fair? Seems like it does not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常好的钻石 – 只要清晰度比“良好”更好，切割或颜色是否重要？看起来并不重要。
- en: 'Lastly, we will look at a histogram of price faceted by cut rather than colored
    by it and we are going to use the `breaks` data we created previously. See the
    following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将查看一个按切割而不是按颜色分面的价格直方图，我们将使用之前创建的`breaks`数据。请看以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s take a last look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看最后一眼：
- en: '![Figure 12.6 – Histogram of price faceted by the cut](img/B19142_12_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 根据切割方式分面的价格直方图](img/B19142_12_06.jpg)'
- en: Figure 12.6 – Histogram of price faceted by the cut
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 根据切割方式分面的价格直方图
- en: Now that we have created all the visuals, we can move on to the modeling phase.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有视觉元素，我们可以进入建模阶段。
- en: Performing a simple ML model with R
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R执行简单的机器学习模型
- en: 'In this section, we are going to go over performing a simple ML model in R.
    There are so many different ways to do this in R that it would be impossible for
    me to list them all, however, CRAN has done this so you and I don’t have to. If
    you want to see a task view of ML on CRAN, you can follow this link: [https://cran.r-project.org/view=MachineLearning](https://cran.r-project.org/view=MachineLearning).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何在R中执行一个简单的机器学习模型。在R中有许多不同的方法来做这件事，我无法一一列出，然而CRAN已经做了这件事，这样你和我就不必做了。如果你想查看CRAN上机器学习的任务视图，可以点击以下链接：[https://cran.r-project.org/view=MachineLearning](https://cran.r-project.org/view=MachineLearning)。
- en: For this section, we are going to use the XGBoost algorithm as implemented by
    the `healthyR.ai` package. The algorithm is not written differently, the only
    difference is how data is saved in the output. The `healthyR.ai` package also
    contains a preprocessor for the XGBoost algorithm to ensure that the input data
    matches what the algorithm is expecting before modeling. The two main functions
    that we will be using are `hai_xgboost_data_prepper()` and `hai_auto_xgboost()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将使用由`healthyR.ai`包实现的XGBoost算法。算法本身并没有不同的写法，唯一的不同是输出中数据保存的方式。`healthyR.ai`包还包含XGBoost算法的预处理程序，以确保在建模之前输入数据与算法期望的数据匹配。我们将使用的主要函数是`hai_xgboost_data_prepper()`和`hai_auto_xgboost()`。
- en: We will not cover loading the data in again as it was covered previously. Let’s
    get started!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会再次介绍加载数据，因为之前已经介绍过了。让我们开始吧！
- en: Data preprocessing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据预处理
- en: 'Before we get started, we are going to preprocess our data so that it meets
    the needs of the algorithm for modeling. This is made easy by the `hai_xgboost_data_prepper()`
    function from the `healthyR.ai` library. We are going to see what the data looks
    like before and after the data is processed. Let’s see the following code and
    then the output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将预处理我们的数据，以确保它满足算法建模的需求。这可以通过`healthyR.ai`库中的`hai_xgboost_data_prepper()`函数来实现。我们将看看数据在处理前后的样子。让我们看看以下代码和输出：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the data before processing begins. We see that there are 10 columns,
    and we can see the datatypes of each of those columns clearly in the output. Now,
    let’s create a `recipe` object by passing our data into `hai_xgboost_data_prepper()`
    and checking the output from there. This function takes two arguments: `.data`
    and `.recipe_formula`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理开始之前的数据。我们看到有10列，我们可以在输出中清楚地看到每一列的数据类型。现在，让我们通过将数据传递给`hai_xgboost_data_prepper()`并检查那里的输出来创建一个`recipe`对象。这个函数接受两个参数：`.data`和`.recipe_formula`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s look at the processed data. We can see in the following that columns
    have been added and all the datatypes are now `<dbl>`, which is what was called
    for in the preprocessor:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看处理后的数据。我们可以看到以下列已经添加，并且所有数据类型现在都是`<dbl>`，这是预处理程序所要求的：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have seen the data after processing, let’s use the `hai_auto_xgboost()`
    function to perform the modeling. Here is the full function call and documentation
    on it can be at [https://www.spsanderson.com/healthyR.ai/reference/hai_auto_xgboost.html:](https://www.spsanderson.com/healthyR.ai/reference/hai_auto_xgboost.html:)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了处理后的数据，让我们使用`hai_auto_xgboost()`函数进行建模。这是完整的函数调用和它的文档可以在[https://www.spsanderson.com/healthyR.ai/reference/hai_auto_xgboost.html](https://www.spsanderson.com/healthyR.ai/reference/hai_auto_xgboost.html)找到：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will now create the model and check the output. I am using `.num_cores =
    10`, `.best_metric = "rsq"`, and `.model_type = "regression"`, and I do not suggest
    you run this yourself unless you have plenty of time to spare.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建模型并检查输出。我使用了`.num_cores = 10`、`.best_metric = "rsq"`和`.model_type =
    "regression"`，并且我不建议你自己运行这个，除非你有足够的时间。
- en: 'Now, perform modeling using the `hai_auto_xgboost()` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`hai_auto_xgboost()`函数进行建模：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This produces a rather large object; on my machine, it is 196.1 MB, with the
    largest portion coming from `$tuned_info` sitting at `169836312 bytes`, which
    is mainly due to the `plotly` plot and the Monte Carlo cross-validation `tibble`,
    due to the size of the incoming data. We can now take a look at some of the objects
    that are exported:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生一个相当大的对象；在我的机器上，它是196.1 MB，其中最大部分是`$tuned_info`，占`169836312 bytes`，这主要是由于`plotly`图和Monte
    Carlo交叉验证的`tibble`，因为输入数据的大小。我们现在可以看看导出的某些对象：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing we did was pull out the fitted workflow object, which can be
    used to make predictions on data using the generic `predict()` function. We know
    it is a `workflow` object from when we ran `class(xgb_wflw_fit)`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的是提取拟合的工作流对象，该对象可以用来使用通用的`predict()`函数对数据进行预测。我们知道它是一个`workflow`对象，因为我们运行了`class(xgb_wflw_fit)`。
- en: The final thing we do is to actually take a look at the specification of the
    fitted model itself. This will show us what the parameters were set to during
    the cross-validation process. It is important to remember that I did not use a
    seed, which means that you can obtain different results. This was meant to be
    a primer and not an exhaustive write-up of the inputs and outputs, but rather
    just a showcase of how an XGBoost model can be fitted to data from an Excel file,
    given one cannot perform such a modeling task with the ease it was done in R.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要做的就是查看拟合模型的规格本身。这将显示在交叉验证过程中设置的参数。重要的是要记住，我没有使用种子，这意味着您可能得到不同的结果。这旨在作为一个入门，而不是对输入和输出的详尽描述，而是仅仅展示如何将
    XGBoost 模型拟合到 Excel 文件中的数据，因为您不能像在 R 中那样轻松地完成这样的建模任务。
- en: Now, we can move on to the Python section, where we will follow a similar workflow
    for the same dataset.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入 Python 部分，我们将对相同的数据集执行类似的流程。
- en: Getting visualizations with Python
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 获取可视化
- en: In this section, we are going to go over visualizations of the data in Python,
    analogous to the preceding R section. We will use `plotnine` to have visualizations
    similar to those created in R using `ggplot2` and provide interpretations of the
    results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾 Python 中的数据可视化，类似于前面的 R 部分。我们将使用 `plotnine` 来创建与 R 中使用 `ggplot2`
    创建的可视化相似的结果，并提供结果的解释。
- en: Getting the data
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数据
- en: 'Like in the earlier chapters, we will load the data using `pandas`. Just like
    before, the path to the XLSX file may be different for you from what I have, so
    adjust the `filepath` accordingly:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的章节一样，我们将使用 `pandas` 加载数据。就像之前一样，XLSX 文件的路径可能与你我的不同，所以相应地调整 `filepath`：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we use the raw `diamonds` dataset without spitting it first and then
    recombining it, as it was done in the R part of the chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用原始的 `diamonds` 数据集，而没有先将其分割再重新组合，就像本章 R 部分所做的那样。
- en: Visualizing the data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化数据
- en: Once we have our data loaded, we can use `plotnine` to create visualizations.
    In this section, we’ll demonstrate how to visualize various aspects of the `diamonds`
    dataset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载数据，我们就可以使用 `plotnine` 创建可视化。在本节中，我们将演示如何可视化 `diamonds` 数据集的各个方面。
- en: 'Using the dataset loaded before, we can have a first look at the data:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前加载的数据集，我们可以先看看数据：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This Python code replicates the R code used at the beginning of the chapter
    using `plotnine` for data visualization. The `ggplot()` function initializes the
    plot, `aes()` defines the aesthetics, `geom_bin2d()` adds the geometry, `facet_wrap()`
    creates facets, `theme_minimal()` sets the theme, `labs()` adds labels, and `scale_fill_manual(values=color_palette)`
    ensures the color palette is colorblind friendly using the predefined `color_palette`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Python 代码使用 `plotnine` 对数据进行了可视化，复制了本章开头使用的 R 代码。`ggplot()` 函数初始化绘图，`aes()`
    定义美学，`geom_bin2d()` 添加几何形状，`facet_wrap()` 创建面元，`theme_minimal()` 设置主题，`labs()`
    添加标签，`scale_fill_manual(values=color_palette)` 确保使用预定义的 `color_palette` 使调色板色盲友好。
- en: 'The resulting image will look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像将看起来像这样：
- en: '![Figure 12.7 – The plotnine scatterplot of the diamonds dataset](img/B19142_12_07.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – diamonds 数据集的 plotnine 散点图](img/B19142_12_07.jpg)'
- en: Figure 12.7 – The plotnine scatterplot of the diamonds dataset
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – diamonds 数据集的 plotnine 散点图
- en: As you can see, the plot shows the relationship between carat weight and price
    by color-coding the cut of diamonds, using a colorblind-friendly color scheme.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该图通过使用颜色编码钻石的切割来显示克拉重量和价格之间的关系，并使用色盲友好的颜色方案。
- en: 'Let’s have a look at the boxplot of the data (we will not re-import all of
    the `plotnine` functions again):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看数据的箱线图（我们不会再次重新导入所有的 `plotnine` 函数）：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this code, `geom_boxplot()` is used to create boxplots. The `outlier_color`
    parameter is set to `lightgrey` to change the color of outliers in the boxplot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`geom_boxplot()` 用于创建箱线图。`outlier_color` 参数设置为 `lightgrey` 以改变箱线图中异常值的颜色：
- en: '![Figure 12.8 – The boxplot of the diamonds dataset](img/B19142_12_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – diamonds 数据集的箱线图](img/B19142_12_08.jpg)'
- en: Figure 12.8 – The boxplot of the diamonds dataset
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – diamonds 数据集的箱线图
- en: The core purpose of data visualization remains to get insights into the data
    to better understand it. What if we plot the mean price? Do we see what we need
    to see?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可视化的核心目的是为了深入了解数据，以便更好地理解它。如果我们绘制平均价格，我们会看到我们需要看到的内容吗？
- en: 'We can use the `groupby` functionality from `pandas` to aggregate the prices,
    calculate the mean per group, and create a plot with points, lines, and smoothed
    lines to visualize the mean price by clarity and cut:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pandas`中的`groupby`功能来汇总价格，计算每个组的平均值，并创建一个包含点、线和平滑线的图表，以可视化清晰度和切工的平均价格：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s have a look at the resulting data vizualization:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果数据可视化：
- en: '![Figure 12.9 – Mean price by clarity and cut](img/B19142_12_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9 – 根据清晰度和切工的平均价格](img/B19142_12_09.jpg)'
- en: Figure 12.9 – Mean price by clarity and cut
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 根据清晰度和切工的平均价格
- en: 'For each cut, a similar curve becomes visible: the mean price first rises by
    clarity and then drops. Both rise and fall are the least relevant for the **Ideal**
    clarity while they are the strongest for **Premium** and **Very** **Good** clarities.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个切工，都会出现类似的曲线：平均价格首先随着清晰度的提高而上升，然后下降。上升和下降对于**理想**清晰度来说最不相关，而对于**优质**和**非常好**清晰度来说最相关。
- en: 'Could we gain more insights from plotting the mean price in a different grouping?
    Let’s take a look at the mean price per carat:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否通过以不同的分组绘制平均价格来获得更多见解？让我们看看每克拉的平均价格：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting image indeed shows some interesting things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图像确实显示了一些有趣的东西：
- en: '![Figure 12.10 – The mean price per carat by clarity, color, and cut](img/B19142_12_10.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 根据清晰度、颜色和切工的平均价格](img/B19142_12_10.jpg)'
- en: Figure 12.10 – The mean price per carat by clarity, color, and cut
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 根据清晰度、颜色和切工的平均价格
- en: For all clarities but **Fair**, we see that the D color has an extreme price
    for the IF cut but for the others, the prices remain similar. For **Fair** clarity,
    however, the prices show a clear downward trend with the only large price difference
    being between D and other colors for the I1 cut.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除了**公平**以外的所有清晰度，我们看到D色对于IF切工的价格极端，但对于其他切工，价格保持相似。然而，对于**公平**清晰度，价格显示出明显的下降趋势，只有D色与其他颜色在I1切工之间存在较大的价格差异。
- en: 'Finally, before moving on to modeling, let’s have a look at the histogram of
    prices by cut:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在继续建模之前，让我们看看价格按切工的直方图：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use default binning because, unfortunately, the great package used for the
    R version, `healthyR`, is not available for Python (yet).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用默认的分组，因为不幸的是，用于R版本的优秀包`healthyR`目前还没有Python版本（可用）。
- en: '![Figure 12.11 – Price histogram by cut](img/B19142_12_11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 根据切工的价格直方图](img/B19142_12_11.jpg)'
- en: Figure 12.11 – Price histogram by cut
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 根据切工的价格直方图
- en: We can see that the price has a very long tail (that is, extremely high prices
    are relatively typical even though infrequent) and, surprisingly, we can see a
    second high point for **Good** and **Premium** cuts (and to a lesser extent for
    **Very Good** cut as well).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到价格有一个非常长的尾巴（也就是说，即使不常见，极高价格也是相对典型的），并且令人惊讶的是，我们还可以看到**良好**和**优质**切工的第二个高点（对于**非常好**切工来说，程度较小）。
- en: With the data better understood thanks to the visualizations, we can start with
    the modeling!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可视化更好地理解了数据，我们可以开始建模！
- en: Performing a simple ML model with Python
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python执行简单的机器学习模型
- en: In this section, we create a simple ML model in Python. Python has grown to
    be the primary go-to language for ML work (with R as the obvious alternative)
    and the number of packages implementing ML algorithms is difficult to overestimate.
    Having said that, `sklearn` remains the most widely used so we will also choose
    it for this section. Similarly to the R part of the chapter, we will use the `xgboost`
    model because it has a great balance between performance and explainability.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在Python中创建一个简单的机器学习模型。Python已经成长为主要用于机器学习工作的语言（R是明显的替代品），实现机器学习算法的包的数量难以高估。话虽如此，`sklearn`仍然是使用最广泛的，因此我们也将选择它在本节中使用。与本章的R部分类似，我们将使用`xgboost`模型，因为它在性能和可解释性之间取得了很好的平衡。
- en: We will use the data loaded in the previous section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一节中加载的数据。
- en: Data preprocessing
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据预处理
- en: The first thing to do for the modeling phase is to prepare the data. Fortunately,
    `sklearn` comes with a preprocessing functionality built-in!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于建模阶段的第一步，是准备数据。幸运的是，`sklearn`内置了预处理功能！
- en: 'Let’s review the steps involved in data preprocessing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下数据预处理中涉及到的步骤：
- en: '`sklearn` provides methods for imputing missing values or removing rows/columns
    with missing data.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn`提供了填充缺失值或删除包含缺失数据行/列的方法。'
- en: '`sklearn` offers utilities for scaling features, including standardization
    (scaling features to have zero mean and unit variance) and normalization (scaling
    features to a specified range).'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn`提供了用于缩放特征的实用工具，包括标准化（将特征缩放到具有零均值和单位方差）和归一化（将特征缩放到指定的范围）。'
- en: '`sklearn` provides methods for one-hot encoding categorical variables or encoding
    them using ordinal labels.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn`提供了一元编码分类变量或使用序数标签进行编码的方法。'
- en: '`sklearn` offers functions for splitting datasets into training and testing
    sets with specified proportions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn`提供了用于按指定比例将数据集分为训练集和测试集的函数。'
- en: '`sklearn` supports various feature engineering techniques, such as polynomial
    features generation, interaction terms creation, and dimensionality reduction
    using techniques such as **principal component** **analysis** (**PCA**).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sklearn`支持各种特征工程技术，例如多项式特征生成、交互项创建以及使用**主成分分析**（PCA）等技术进行降维。'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to do the feature engineering in a way that doesn’t pollute
    the training data with information from the test data, just like for data cleaning
    (such as imputation).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要在不将测试数据的信息污染到训练数据中的方式下进行特征工程，就像数据清洗（如插补）一样。
- en: 'We have covered data cleaning to a great extent in the dedicated chapter, so
    we will make use of the fact that the `diamonds` dataset is clean already. We
    will move on to feature scaling and the encoding of categorical variables instead:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在专门的章节中详细介绍了数据清洗，因此我们将利用`diamonds`数据集已经清洗好的事实。我们将继续进行特征缩放和分类变量的编码：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code snippet demonstrates how to encode categorical variables (cut, color,
    and clarity) using one-hot encoding and scale numerical features using `StandardScaler`
    from `sklearn`. Then, it concatenates the encoded categorical features with scaled
    numerical features and splits the dataset into training and testing sets using
    `train_test_split()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段演示了如何使用独热编码对分类变量（切割、颜色和清晰度）进行编码，并使用`sklearn`中的`StandardScaler`对数值特征进行缩放。然后，它将编码的分类特征与缩放的数值特征连接起来，并使用`train_test_split()`将数据集分为训练集和测试集。
- en: Let’s compare the data before and after the preprocessing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较预处理前后的数据。
- en: 'The original dataset looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据集看起来如下：
- en: '![Figure 12.12 – Raw data as read from Excel](img/B19142_12_12.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 从Excel读取的原始数据](img/B19142_12_12.jpg)'
- en: Figure 12.12 – Raw data as read from Excel
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 从Excel读取的原始数据
- en: As you can see, the dataset contains a mix of numerical and categorical variables
    (the latter ones will be encoded using one-hot encoding).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，数据集包含数值和分类变量（后者将使用独热编码进行编码）的混合。
- en: 'After the preprocessing, the dataset looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理之后，数据集看起来如下：
- en: '![](img/B19142_12_13.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19142_12_13.jpg)'
- en: Figure 12.13 – Preprocessed training data
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 预处理后的训练数据
- en: 'The preprocessed training data shown earlier has fewer rows (the rest makes
    up the test data) but more columns: while the `price` column is not present (it’s
    the variable we want to predict), the categorical variables have been replaced
    by multiple `0` and `1` values – the result of one-hot encoding. For each unique
    value of each categorical variable, a new column has been introduced that has
    `1` if the original dataset had that value and `0` if it had something else.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的预处理后的训练数据行数较少（其余部分构成测试数据），但列数更多：虽然`price`列不存在（这是我们想要预测的变量），但分类变量已被多个`0`和`1`值所替代
    – 这是独热编码的结果。对于每个分类变量的每个唯一值，都会引入一个新列，如果原始数据集有该值，则该列的值为`1`，如果有其他值，则该列的值为`0`。
- en: The `y_train` variable has the value of the `price` column for each row in the
    train data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`y_train`变量包含训练数据中每行的`price`列的值。'
- en: 'With the preprocessed data, we can start the modeling:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理后的数据，我们可以开始建模：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this code, we observe the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们观察到以下内容：
- en: We import `GradientBoostingRegressor` from `sklearn.ensemble`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`sklearn.ensemble`中导入`GradientBoostingRegressor`。
- en: We instantiate a gradient boosting regressor (`xgb_reg`) from `scikit-learn`’s
    implementation.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`scikit-learn`的实现中实例化了一个梯度提升回归器（`xgb_reg`）。
- en: We train the model using the `fit` method with the training data (`X_train`
    and `y_train`).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用训练数据（`X_train`和`y_train`）通过`fit`方法训练模型。
- en: We make predictions on the test set using the `predict` method and calculate
    the `RMSE`) between the predicted values (`y_pred`) and the actual target values
    (`y_test`).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`predict`方法在测试集上进行预测，并计算预测值（`y_pred`）与实际目标值（`y_test`）之间的`RMSE`。
- en: The RMSE is a widely used metric in regression analysis that measures the average
    magnitude of the errors between predicted values and observed values. It provides
    a single numerical value to assess the goodness of fit of a regression model.
    RMSE is on the same scale (units) as the target variable (`price`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RMSE 是回归分析中广泛使用的指标，用于衡量预测值与观察值之间误差的平均幅度。它提供了一个单一的数值来评估回归模型的拟合优度。RMSE 与目标变量（`price`）处于相同的尺度（单位）。
- en: Lower values of RMSE indicate that the model’s predictions are closer to the
    actual values, implying better performance. In other words, a lower RMSE signifies
    that the model has a smaller average deviation from the true values, which indicates
    higher accuracy and a better predictive capability.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: RMSE 的值越低，表明模型的预测值越接近实际值，这意味着性能更好。换句话说，较低的 RMSE 表示模型与真实值的平均偏差更小，这表明更高的准确性和更好的预测能力。
- en: The RMSE is particularly useful because it considers the magnitude of errors
    and penalizes larger errors more heavily than smaller ones. Therefore, minimizing
    the RMSE leads to a model that provides more precise and accurate predictions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: RMSE 特别有用，因为它考虑了误差的幅度，并且对较大误差的惩罚比对较小误差的惩罚更重。因此，最小化 RMSE 导致的模型能提供更精确和准确的预测。
- en: Overall, the RMSE serves as a valuable tool for comparing different regression
    models and assessing their predictive accuracy in real-world applications.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，RMSE 是一个有价值的工具，用于比较不同的回归模型，并在实际应用中评估它们的预测准确性。
- en: The model result has an RMSE of around `720`, which is significantly lower than
    the average price (`3933`) and the standard deviation of the `price` variable
    (`3989`). This is good news, indeed, as it indicates the model fit was quite good.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 模型结果具有大约 `720` 的均方根误差（RMSE），这显著低于平均价格（`3933`）和 `price` 变量的标准差（`3989`）。这确实是好消息，因为它表明模型拟合相当好。
- en: Of course, you can consider other ML models (random forests, `lightgbm` or `catgbm`,
    or even **deep learning models**) and other goodness-of-fit metrics (R2, MAE,
    etc.). This section is intended to be a primer on the end-to-end workflow, so
    exploring those options is beyond the scope of this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以考虑其他机器学习模型（如随机森林、`lightgbm` 或 `catgbm`，甚至 **深度学习模型**）以及其他拟合优度指标（如 R2、MAE
    等）。本节旨在作为端到端工作流程的入门指南，因此探索这些选项超出了本书的范围。
- en: Summary
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this last chapter, we explored techniques for performing data analysis and
    visualization using R and Python with data sourced from Excel. We began by loading
    and visualizing the `diamonds` dataset and the `ggplot2` and `plotnine` libraries
    for data visualization. Through various plots such as boxplots, mean price visualizations,
    and histograms, we gained insights into the relationships between different variables
    in the dataset.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们探讨了使用 R 和 Python 以及来自 Excel 的数据执行数据分析和可视化的技术。我们首先加载并可视化了 `diamonds`
    数据集以及用于数据可视化的 `ggplot2` 和 `plotnine` 库。通过箱线图、平均价格可视化和直方图等各种图表，我们了解了数据集中不同变量之间的关系。
- en: Moving on to ML modeling, we utilized the `healthyR` and the `scikit-learn`
    libraries to preprocess the data, including encoding categorical variables and
    splitting the dataset into training and testing sets. We then implemented a regression
    model using the XGBoost algorithm, assessing its performance using the RMSE metric.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行机器学习建模时，我们使用了 `healthyR` 和 `scikit-learn` 库来预处理数据，包括编码分类变量并将数据集划分为训练集和测试集。然后我们使用
    XGBoost 算法实现了一个回归模型，并使用 RMSE 指标评估其性能。
- en: By harnessing the strengths of R, Python, and Excel, users can enhance their
    analytical capabilities and derive valuable insights from their data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 R、Python 和 Excel 的优势，用户可以增强他们的分析能力，并从他们的数据中提取有价值的见解。
- en: Thank you for joining us on this journey through the exciting world of data
    analysis and visualization with R and Python in Excel. We hope you found the content
    engaging and the examples insightful. As you continue to explore and implement
    the knowledge gained from this book, we hope you will discover new possibilities
    and opportunities in your data-driven endeavors. Happy analyzing and visualizing!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您与我们一同踏上通过 Excel 中的 R 和 Python 探索数据分析与可视化的激动人心的旅程。我们希望您觉得内容引人入胜，示例富有洞察力。随着您继续探索和实施从本书中获得的知识，我们希望您能在数据驱动的努力中发现新的可能性和机会。祝您分析愉快，可视化精彩！
