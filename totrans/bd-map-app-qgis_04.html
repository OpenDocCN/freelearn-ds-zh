<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Creating QGIS Plugins</h1></div></div></div><p class="calibre8">In <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre10">Getting Started with QGIS</em>, we took a brief look at how QGIS Python plugins are organized. In this chapter, we will use this knowledge to create two plugins: a simple "Hello World" style plugin, so you can understand the process, and a much more sophisticated and useful plugin that displays information about a clicked-on geometry. In the process, we will learn how plugins work, how to create and distribute plugins, what plugins will allow us to do, and some of the possibilities and limitations involved in implementing your mapping applications as QGIS plugins.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec20" class="calibre1"/>Getting ready</h1></div></div></div><p class="calibre8">Before we can delve <a id="id242" class="calibre1"/>into the plugin development process, there are three things you will need to do:</p><div><ol class="orderedlist"><li class="listitem" value="1">Install the <a id="id243" class="calibre1"/><strong class="calibre9">Qt developer tools</strong> from the Qt developer website (<a class="calibre1" href="http://qt-project.org">http://qt-project.org</a>).</li><li class="listitem" value="2">Install the Python <a id="id244" class="calibre1"/>bindings for Qt, called <strong class="calibre9">PyQt</strong>, from <a class="calibre1" href="http://www.riverbankcomputing.co.uk/software/pyqt">http://www.riverbankcomputing.co.uk/software/pyqt</a>. While we won't be using the Python bindings directly, there are two command-line tools included with PyQt that we will need.<div><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8">QGIS is currently based on PyQt4. Make sure you install Version 4 of the Qt Developer tools and the PyQt bindings so that you get the compatible version.</p><p class="calibre8">PyQt is available as an installer for MS Windows and in source code form for Linux. For Mac OS X users, a binary installer is available at <a class="calibre1" href="http://sourceforge.net/projects/pyqtx">http://sourceforge.net/projects/pyqtx</a>.</p></div></li><li class="listitem" value="3">You should install <a id="id245" class="calibre1"/>and enable the <strong class="calibre9">Plugin Reloader</strong> plugin for QGIS. This makes it much easier to develop and test your plugins. To do this, you will need to turn on experimental plugin support by selecting the <strong class="calibre9">Manage and Install Plugins…</strong> item from the <strong class="calibre9">Plugins</strong> menu, clicking on the <strong class="calibre9">Settings</strong> tab, and then turning on the <strong class="calibre9">Show also experimental plugins</strong> checkbox. You can then see the experimental plugins, including the Plugin Reloader. Select this plugin and then click on the <strong class="calibre9">Install Plugin</strong> button to install it.<p class="calibre26">The Plugin Reloader adds buttons to the QGIS toolbar that you can click on in order to reload your plugin:</p><div><img src="img/00036.jpeg" alt="Getting ready" class="calibre11"/></div><p class="calibre25"> </p><p class="calibre26">This allows you to make changes to your plugin and see the result right away. Without the <a id="id246" class="calibre1"/>Plugin Reloader, you would have to quit and restart QGIS for your changes to take effect.</p></li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec21" class="calibre1"/>Understanding the QGIS plugin architecture</h1></div></div></div><p class="calibre8">As we saw <a id="id247" class="calibre1"/>in <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre10">Getting Started with QGIS</em>, QGIS plugins are stored as Python packages in the <code class="email">~/.qgis2/python/plugins</code> directory.</p><div><h3 class="title2"><a id="tip11" class="calibre1"/>Tip</h3><p class="calibre8">Depending on your operating system and the version of QGIS you're using, the <code class="email">.qgis2</code> directory might be named <code class="email">.qgis</code>.</p></div><p class="calibre8">The plugin's package includes a number of Python modules and other files. At a minimum, the plugin package must include:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">__init__.py</code>: This is <a id="id248" class="calibre1"/>a package initialization module that contains the <strong class="calibre9">class factory</strong> function, which creates and initializes the plugin.</li><li class="listitem"><code class="email">metadata.txt</code>: This is <a id="id249" class="calibre1"/>a text file that contains information about the plugin, including the plugin's version number, the name of the plugin, and the plugin's author.</li></ul></div><p class="calibre8">In addition, most plugins will include:</p><div><ul class="itemizedlist"><li class="listitem">A separate Python module that contains a class definition for the plugin. The plugin class implements a number of specially named methods that get called to start up and shut down the plugin.</li><li class="listitem">One or more user-interface template files with the extension <code class="email">.ui</code>.</li><li class="listitem">The compiled version of each user-interface template in the form of a Python module with the same name as that of the template.</li><li class="listitem">A <code class="email">resources.qrc</code> file, which is an XML format file that lists the various images and other resources used by the plugin.</li><li class="listitem">The compiled version of the resources file, in the form of a Python module named <code class="email">resources.py</code>.</li></ul></div><p class="calibre8">The various <code class="email">.ui</code> template files are <a id="id250" class="calibre1"/>created using <strong class="calibre9">Qt Designer</strong>, which is a part of the standard Qt installation. The command-line tools to convert the <code class="email">.qrc</code> and <code class="email">.ui</code> files <a id="id251" class="calibre1"/>into Python modules are part of PyQt.</p><p class="calibre8">When it starts up, QGIS looks through the various Python packages it finds in the <code class="email">~/.qgis2/python/plugins</code> directory. For each package, it attempts to call the top-level function named <code class="email">ClassFactory()</code> in the plugin's <code class="email">__init__.py</code> file. This function should import and return an instance of the plugin's object, like this:</p><div><pre class="programlisting">  def ClassFactory(iface):
  from myPlugin import MyPlugin
  return MyPlugin(iface)</pre></div><div><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre8">Obviously, you should change the name of <code class="email">myPlugin</code> (and <code class="email">MyPlugin</code>) to something more meaningful when you write a real plugin.</p></div><p class="calibre8">While it's usual to define the plugin in a separate module, you can create it directly within the <code class="email">__init__.py</code> module if you prefer. The important thing is to define a class that provides the following methods:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">__init__(iface)</code>: This <a id="id252" class="calibre1"/>initializes the plugin object. Note that this should accept the <code class="email">iface</code> variable passed to the class factory and store it in an instance variable for later use.</li><li class="listitem"><code class="email">initGui()</code>: This <a id="id253" class="calibre1"/>initializes the plugin's user interface. This would typically involve adding the plugin to the QGIS menus and toolbar, and setting up the signal handlers to respond to various events.</li><li class="listitem"><code class="email">unload()</code>: This <a id="id254" class="calibre1"/>removes the plugin's user-interface elements. This would normally include removing the plugin from the QGIS menus and toolbar, and disconnecting the signal handlers defined in the plugin's <code class="email">initGui()</code> method.</li></ul></div><p class="calibre8">The <code class="email">__init__(iface)</code> method is called by your class factory function to initialize the plugin <a id="id255" class="calibre1"/>object itself. The <code class="email">initGui()</code> method is then called by QGIS when the program starts up, or when the user installs the plugin. Finally, the <code class="email">unload()</code> method is called by QGIS when the user uninstalls the plugin or when QGIS shuts down.</p><p class="calibre8">A plugin doesn't usually run right away when QGIS starts up. Instead, it installs various menu and toolbar items, which the user can then select to perform various actions. For example, a simple plugin may have just one menu item and one toolbar item, and when the user selects one of these, the plugin performs its one and only action. More sophisticated plugins might have a range of menu and toolbar items, each one performing a different action.</p><p class="calibre8">Many plugins add their menu items to the <strong class="calibre9">Plugins</strong> menu using the <code class="email">iface.addPluginToMenu()</code> method. This creates a submenu within the <strong class="calibre9">Plugins</strong> menu for the plugin's menu items, making it easy for the user to see which menu items have been provided by a given plugin. Alternatively, the plugin might choose to add its menu items to one of the existing submenus within the <strong class="calibre9">Vector</strong>, <strong class="calibre9">Raster</strong>, or <strong class="calibre9">Database</strong> menu, as appropriate.</p><p class="calibre8">In the same way, the <a id="id256" class="calibre1"/>plugin might add icons or widgets to the plugin toolbar, or to one of the other toolbars if it prefers. A plugin might also add a whole new toolbar to the QGIS window if it wants to.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec22" class="calibre1"/>Creating a simple plugin</h1></div></div></div><p class="calibre8">Now that we've seen <a id="id257" class="calibre1"/>how plugins are structured and used, let's create a very simple "Hello World" style plugin to see what's involved in making one. While there are various tools such as the <strong class="calibre9">Plugin Builder</strong> plugin, which will create the various files for you, we're going to eschew them in favor of creating our plugin manually. This will make the process clearer and avoid the situation where your code just magically works without knowing why or how.</p><p class="calibre8">Go to the <code class="email">~/.qgis2/python/plugins</code> directory and create a subdirectory named <code class="email">testPlugin</code>. In this directory, create a file named <code class="email">metadata.txt</code> and enter the following values into it:</p><div><pre class="programlisting">[general]
name=Test Plugin
email=test@example.com
author=My Name Here
qgisMinimumVersion=2.0
description=Simple test plugin.
about=A very simple test plugin.
version=version 0.1</pre></div><p class="calibre8">This is the minimum metadata you need to enter for a plugin. Obviously, you can change these values if you want. Now, create a package initialization file, <code class="email">__init__.py</code>, and enter the following into that file:</p><div><pre class="programlisting">def classFactory(iface):
  from testPlugin import TestPlugin
  return TestPlugin(iface)</pre></div><p class="calibre8">As you can see, we're going to define a class named <code class="email">TestPlugin</code> that represents our plugin object, and implement it in a module named <code class="email">testPlugin.py</code>. Let's create this module now:</p><div><pre class="programlisting">from PyQt4.QtCore import *
from PyQt4.QtGui import *

class TestPlugin:
  def __init__(self, iface):
    self.iface = iface

  def initGui(self):
    self.action = QAction("Run", self.iface.mainWindow())
    QObject.connect(self.action, SIGNAL("triggered()"),
            self.onRun)
    self.iface.addPluginToMenu("Test Plugin", self.action)

  def unload(self):
    self.iface.removePluginMenu("Test Plugin", self.action)

  def onRun(self):
    QMessageBox.information(self.iface.mainWindow(), "debug",
                "Running")</pre></div><p class="calibre8">As you can see, we created a Qt <code class="email">QAction</code> object for our menu item, named it <code class="email">Run</code>, and added it to the <strong class="calibre9">Plugin</strong> <a id="id258" class="calibre1"/>menu in a submenu named "Test Plugin". We then connected that action to our <code class="email">onRun()</code> method, which simply displays a message to the user stating that the plugin is running.</p><p class="calibre8">This is all we need for a very minimal plugin. Let's test it out. Start QGIS and choose the <strong class="calibre9">Manage and Install Plugins…</strong> item from the <strong class="calibre9">Plugins</strong> menu. The QGIS <strong class="calibre9">Plugin Manager</strong> window will appear, and if you scroll down, you should see your plugin listed:</p><div><img src="img/00037.jpeg" alt="Creating a simple plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If you click on the checkbox, the plugin will be activated. If you then look in the <strong class="calibre9">Plugins</strong> menu, you should see your plugin listed, and if you select the <strong class="calibre9">Run</strong> item from your plugin's submenu, the "Running" message box should be displayed.</p><p class="calibre8">If your plugin isn't working, or if it isn't listed in the Plugin Manager window, you might have made a mistake in your code. If the plugin can't be loaded for some reason, a window will appear, giving <a id="id259" class="calibre1"/>you the Python traceback when you attempt to install or reload the plugin:</p><div><img src="img/00038.jpeg" alt="Creating a simple plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This window will also appear if your plugin's code generates an exception while it is running.</p><div><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre8">If there's a problem with your plugin that prevents it from even being loaded (for example, a mistake in the <code class="email">metadata.txt</code> file), you might need to check the <strong class="calibre9">Log Messages</strong> panel to see the error. You can show this panel by selecting it from the <strong class="calibre9">Panels</strong> submenu in the <strong class="calibre9">View</strong> menu; make sure you click on the <strong class="calibre9">Plugins</strong> tab to see the log messages associated with your plugin:</p><div><img src="img/00039.jpeg" alt="Creating a simple plugin" class="calibre11"/></div><p class="calibre12"> </p></div><p class="calibre8">Let's add one more feature to our test plugin: a toolbar item, which, when clicked on, also calls the <code class="email">onRun()</code> method. Find <a id="id260" class="calibre1"/>a suitable PNG format image that is 24 x 24 pixels (the default size for a QGIS toolbar icon), and save that image into your plugin's directory under the name <code class="email">icon.png</code>. Then, change your <code class="email">initGui()</code> method to look like the following:</p><div><pre class="programlisting">  def initGui(self):
<strong class="calibre9">    icon = QIcon(":/plugins/testPlugin/icon.png")</strong>
<strong class="calibre9">    self.action = QAction(icon, "Run",</strong>
<strong class="calibre9">               self.iface.mainWindow())</strong>
    QObject.connect(self.action, SIGNAL("triggered()"),
            self.onRun)
    self.iface.addPluginToMenu("Test Plugin", self.action)
<strong class="calibre9">    self.iface.addToolBarIcon(self.action)</strong>
</pre></div><p class="calibre8">The changed lines have been highlighted. As you can see, we've added an icon to our <code class="email">QAction</code> object, and then also called the <code class="email">addToolBarIcon()</code> method to add our action to the Plugins toolbar.</p><p class="calibre8">We'll also have to add one extra line to our <code class="email">unload()</code> method to remove the toolbar icon when the plugin is unloaded:</p><div><pre class="programlisting">  def unload(self):
    self.iface.removePluginMenu("Test Plugin", self.action)
<strong class="calibre9">    self.iface.removeToolBarIcon(self.action)</strong>
</pre></div><p class="calibre8">There's one last thing we need to do before our toolbar icon will work; we need to tell QGIS that the <code class="email">icon.png</code> file is a <strong class="calibre9">resource</strong> used by our plugin. This is done through the <code class="email">resources.qrc</code> file. Create this file now, placing it into your plugin's directory, and edit it using your favorite text editor, so that it contains the following XML format text:</p><div><pre class="programlisting">&lt;RCC&gt;
  &lt;qresource prefix="/plugins/testPlugin"&gt;
    &lt;file&gt;icon.png&lt;/file&gt;
  &lt;/qresource&gt;
&lt;/RCC&gt;</pre></div><p class="calibre8">QGIS can't use this file directly; it has to be compiled into a <code class="email">resources.py</code> module using the <strong class="calibre9">pyrcc4</strong> command-line tool. This tool is installed as part of PyQt; once you've created your <code class="email">resources.qrc</code> file, use the following command to compile it:</p><div><pre class="programlisting">pyrcc4 resources.qrc -o resources.py</pre></div><div><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre8">Depending on where PyQt installed it, you might need to include the path to the <code class="email">pyrcc4</code> command. If you run this command from a directory other than the plugin directory, you will also need to include the path to the <code class="email">resources.qrc</code> and <code class="email">resource.py</code> files.</p></div><p class="calibre8">Finally, we need to add the following to the top of our <code class="email">testPlugin.py</code> module:</p><div><pre class="programlisting">import resources</pre></div><p class="calibre8">This makes the compiled resources available for our plugin to use. When you reload your plugin, an icon should appear in the QGIS toolbar, and if you click on that icon, the "Running" message box should be displayed.</p><p class="calibre8">While this plugin is <a id="id261" class="calibre1"/>very basic, we've actually learned a lot: how to create and install a plugin, how a plugin can add itself to the QGIS user interface, how plugins interact with the user, how errors in a plugin are handled, and how to deal with images and other plugin resources. Let's take a closer look now at the processes typically used to develop and distribute plugins, before going on to create a plugin that actually does something useful.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>The plugin development process</h1></div></div></div><p class="calibre8">In the <a id="id262" class="calibre1"/>previous section, we created a plugin by hand, directly storing the necessary files in the hidden <code class="email">~/.qgis2</code> directory. This isn't a particularly robust way of building plugins. In this section, we will look at some of the best practices for developing and distributing plugins, as well as some of the things you need to be aware of when creating your own plugins.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec24" class="calibre1"/>Using the Plugin Builder</h2></div></div></div><p class="calibre8">QGIS provides a <a id="id263" class="calibre1"/>plugin called <strong class="calibre9">Plugin Builder</strong> that you can use to create your <a id="id264" class="calibre1"/>new plugin from a standard template. Plugin Builder is a sophisticated and useful tool for creating plugins, but it does make some assumptions about the way your plugin will be structured and what it will do. For this reason, we deliberately didn't use the Plugin Builder for our example plugins.</p><p class="calibre8">More information on the Plugin Builder can be found at <a class="calibre1" href="http://geoapt.net/pluginbuilder">http://geoapt.net/pluginbuilder</a>. You can install the Plugin Builder directly from within QGIS, using the <strong class="calibre9">Manage and Install Plugins...</strong> item from the <strong class="calibre9">Plugins</strong> menu. Once installed, you <a id="id265" class="calibre1"/>simply click on the Plugin Builder's icon in the toolbar, and you will be prompted to fill in various details about your new plugin:</p><div><img src="img/00040.jpeg" alt="Using the Plugin Builder" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">After filling in the information, you will be prompted to select the directory in which your plugin's source code is stored. The Plugin Builder will then create the necessary files for you.</p><p class="calibre8">It is up to you whether to use Plugin Builder or not, and whether or not to use all the features it provides. For example, the Plugin Builder provides a <em class="calibre10">make</em> target to create the HTML format help files for your plugin, using Sphynx. If you prefer to create your help files in a different way, or don't want to create help files at all, you can simply ignore this option.</p><p class="calibre8">One of the problems with using Plugin Builder is the complexity of the generated plugin. Right from the outset, your plugin will include:</p><div><ul class="itemizedlist"><li class="listitem">Help files, both in reStructuredText and in HTML format, as well as directories for holding images and HTML templates</li><li class="listitem">Support for internationalization</li><li class="listitem">A Makefile to automate the plugin building process</li><li class="listitem">A Python script for uploading the plugin to the QGIS plugin repository</li><li class="listitem">A <code class="email">pylintrc</code> file, allowing you to check your plugin's Python source files using the Pylint code-analysis system</li><li class="listitem">Two separate README files, one in HTML and another in plain text format</li><li class="listitem">Various shell scripts</li><li class="listitem">A range of standard unit tests</li><li class="listitem">The UI template and Python code that displays a dialog box when the plugin is run</li></ul></div><p class="calibre8">All of this leads to a rather complex directory structure, with lots of files that may or may not be relevant to you. You can certainly remove the various files and directories you don't need, but this can be risky if you don't know what the files and directories are for.</p><p class="calibre8">Due to all this complexity, we <a id="id266" class="calibre1"/>won't be using Plugin Builder in this book. Instead, we'll create our plugins manually, only adding the files and directories you need so <a id="id267" class="calibre1"/>that you can understand what everything does.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec25" class="calibre1"/>Automating the build process</h2></div></div></div><p class="calibre8">For our <a id="id268" class="calibre1"/>example plugin, we had to create the <code class="email">resources.qrc</code> file and then compile this file into a <code class="email">resources.py</code> file using the <code class="email">pyrcc4</code> command-line tool. Whenever we made a change to the <code class="email">resources.qrc</code> file, we had to remember to recompile it. The same thing applies to any user-interface template (<code class="email">.ui</code>) files in our plugin.</p><p class="calibre8">Manually running the compiler each time you make a change is poor programming practice. Instead, you should <a id="id269" class="calibre1"/>use a <strong class="calibre9">Makefile</strong> to automate the process. We won't go into the details of how to use <em class="calibre10">make</em> here (there are complete books on this topic), but we will use it to compile all the necessary files with a single command. We will also store the plugin's source files in a different directory, and use <em class="calibre10">make</em> to compile and copy all the necessary files into the <code class="email">~/.qgis2</code> directory:</p><div><img src="img/00041.jpeg" alt="Automating the build process" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This ensures that the various files in the running plugin are all consistent—you can't forget to compile a template, or break the running plugin by running an updated Python source file before a template has been recompiled. Keeping your source files separate from your running code is also an excellent programming practice.</p><p class="calibre8">By using <em class="calibre10">make</em> in this way, you end up with a highly productive process for developing and testing your plugin:</p><div><img src="img/00042.jpeg" alt="Automating the build process" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A typical <a id="id270" class="calibre1"/>Makefile for building and running QGIS plugins looks like this:</p><div><pre class="programlisting">PLUGINNAME = testPlugin
PY_FILES = testPlugin.py __init__.py
EXTRAS = icon.png metadata.txt
UI_FILES = testPluginDialog.py
RESOURCE_FILES = resources.py

default: compile

compile: $(UI_FILES) $(RESOURCE_FILES)

%.py : %.qrc
  pyrcc4 -o $@ $&lt;

%.py : %.ui
  pyuic4 -o $@ $&lt;

deploy: compile
  mkdir -p $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(PY_FILES) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(UI_FILES) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(RESOURCE_FILES) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(EXTRAS) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)

clean:
  rm $(UI_FILES) $(RESOURCE_FILES)</pre></div><p class="calibre8">The top portion of the Makefile sets five variables that tell <em class="calibre10">make</em> about your plugin:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">PLUGINNAME</code> is, of <a id="id271" class="calibre1"/>course, the name of your plugin.</li><li class="listitem"><code class="email">PY_FILES</code> is a <a id="id272" class="calibre1"/>list of the Python source <a id="id273" class="calibre1"/>files that make up your plugin's source code.</li><li class="listitem"><code class="email">EXTRAS</code> is a list <a id="id274" class="calibre1"/>of additional files that should be included with your plugin. You would typically include the <code class="email">metadata.txt</code> file and any additional images or other files used by your plugin.</li><li class="listitem"><code class="email">UI_FILES</code> is a <a id="id275" class="calibre1"/>list of the UI templates that need to be compiled for your plugin to work. Note that you have to use the <code class="email">.py</code> suffix for each template file, as you're telling <em class="calibre10">make</em> which file you want to have recompiled when the corresponding <code class="email">.ui</code> file is changed.</li><li class="listitem"><code class="email">RESOURCE_FILES</code> is a list of the resource files used by your application. Once again, you <a id="id276" class="calibre1"/>have to use the <code class="email">.py</code> suffix for each resource file rather than the <code class="email">.qrc</code> version of the file.</li></ul></div><p class="calibre8">Typically, you would only have to change the values of these five variables to set up your Makefile. However, if the <code class="email">pyrcc4</code> or <code class="email">pyuic4</code> command-line tools are in a nonstandard location, or if QGIS uses a directory other than <code class="email">~/.qgis2/python/plugins</code> for its Python plugins, then you will have to modify the other parts of the Makefile so that it works with your particular development setup.</p><p class="calibre8">Once it has been set up, the Makefile provides three <strong class="calibre9">make targets</strong> that you can use:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">make compile</code> (or just <code class="email">make</code>) will compile your plugin's <code class="email">.ui</code> and <code class="email">.qrc</code> files into the <a id="id277" class="calibre1"/>corresponding <code class="email">.py</code> modules.</li><li class="listitem"><code class="email">make deploy</code> will <a id="id278" class="calibre1"/>compile the <code class="email">.ui</code> and <code class="email">.qrc</code> files, and then copy all the necessary files into the QGIS plugin directory.</li><li class="listitem"><code class="email">make clean</code> <a id="id279" class="calibre1"/>will remove the <code class="email">.py</code> version of your <code class="email">.ui</code> and <code class="email">.qrc</code> files.</li></ul></div><p class="calibre8">You can use <code class="email">make deploy</code> and then click on the Plugin Reloader tool in QGIS to run the latest version of <a id="id280" class="calibre1"/>your plugin so you can test it out.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec26" class="calibre1"/>Plugin help files</h2></div></div></div><p class="calibre8">QGIS allows you to <a id="id281" class="calibre1"/>include an HTML-formatted help file for your plugin. This file will be displayed using the built-in QGIS help browser if your plugin calls the <code class="email">qgis.utils.showPluginHelp()</code> function. This function has the following signature:</p><div><pre class="programlisting">showPluginHelp(packageName=None, filename='index', section='')</pre></div><p class="calibre8">The various parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">packageName</code>: This is the name of the Python package where the help file can be found. If a package is specified, QGIS will look for the help files inside the given package directory. Otherwise, it will look for the help files in the same directory as the Python module that called <code class="email">showPluginHelp()</code>. Note that it's quite unusual for a plugin to use this parameter, and you would normally just leave it set to <code class="email">None</code>.</li><li class="listitem"><code class="email">filename</code>: This is the base name for the HTML help file to display. Note that an appropriate suffix (for example, <code class="email">.html</code>) will be added to this base name.</li><li class="listitem"><code class="email">section</code>: This is the name of an optional HTML anchor tag, which the help file will be scrolled to when it is opened.</li></ul></div><p class="calibre8">Note that the <code class="email">filename</code> parameter is the <em class="calibre10">base</em> name for the desired HTML file. QGIS allows you to have your help files translated into multiple languages, and will automatically choose the appropriate version of the file based on the current locale. If a translated version of the help file is not available in the current language, then QGIS will fall back to displaying the US English version of the help file, and if that's not available, it will use the file named <code class="email">filename.html</code>.</p><p class="calibre8">This allows you to include translated versions of your help files if you want (for example, <code class="email">index-es.html</code>, <code class="email">index-de.html</code>, and <code class="email">index-fr-ca.html</code>), but if you don't want to have translated help files, a single <code class="email">index.html</code> file will suffice.</p><p class="calibre8">There are several ways in which you can organize your plugin's online help. The following are some examples:</p><div><ol class="orderedlist"><li class="listitem" value="1">You can put all the documentation for your plugin in a single file named <code class="email">index.html</code>, and then simply call <code class="email">showPluginHelp()</code> with no parameters to display that help file when the user asks for help.</li><li class="listitem" value="2">You can use a different filename for your help file and supply that name in the <code class="email">filename</code> parameter when calling <code class="email">showPluginHelp()</code>, for example, <code class="email">showPluginHelp(filename="plugin_help")</code>.</li><li class="listitem" value="3">You're not just limited to having one help file. You can have a whole directory of help files, and have the <code class="email">index.html</code> file act as a table of contents for the plugin's online help. To do this, call <code class="email">showPluginHelp</code> with <code class="email">filename</code> set to something like <code class="email">os.path.join("help_files", "index")</code> so that the help file is found in a subdirectory rather than the main plugin directory.</li><li class="listitem" value="4">If you have multiple help files, for example, one for each of your plugin's main features, you might choose to display the appropriate help file based on which feature the user is using at that time. For example, you might add a <strong class="calibre9">Help</strong> button to a complex dialog or window and have that button call <code class="email">showPluginHelp(filename="my_dialog")</code>.</li><li class="listitem" value="5">Finally, you might put all your documentation into a single file, and use HTML anchor tags (for example, <code class="email">&lt;a id="my_dialog"&gt;My Dialog&lt;/a&gt;</code>) to define the various sections of your documentation. You will then use the <code class="email">section</code> parameter to jump directly to that section of your plugin's documentation, like this: <code class="email">showPluginHelp(section="my_dialog")</code>.</li></ol><div></div><p class="calibre8">Of course, while your help file <a id="id282" class="calibre1"/>has to end up in HTML format, you might not want to write HTML directly. Instead, you can write your documentation using a markup language such as Markdown, reStructuredText, or Latex, and then use a documentation generator to convert your marked-up files into HTML. This is a perfect example of something that can be automated using a Makefile, and indeed, the Plugin Builder's default Makefile includes support for using Sphinx to convert reStructuredText markup into HTML.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch04lvl2sec27" class="calibre1"/>Unit testing</h2></div></div></div><p class="calibre8">Unit tests are a <a id="id283" class="calibre1"/>common programming technique to make sure each part of <a id="id284" class="calibre1"/>your code works as it should. The following is a very simple example of a unit test written in Python:</p><div><pre class="programlisting">import unittest

def double(n):
  return n * 2

class TestDouble(unittest.TestCase):
  def test(self):
    self.assertEqual(double(2), 4)</pre></div><p class="calibre8">You can run this unit test either directly from the command line, or by adding extra code to create a <code class="email">TestRunner</code> object that you can then use to run the test.</p><p class="calibre8">We're not going to describe the rationale behind unit testing, or how to use the <code class="email">unittest</code> library to test your Python code. However, it is worth spending some time learning how you can write and run unit tests for your QGIS plugins.</p><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">If you haven't worked with the <code class="email">unittest</code> module before, check out <a class="calibre1" href="http://docs.python-guide.org/en/latest/writing/tests">http://docs.python-guide.org/en/latest/writing/tests</a>.</p></div><p class="calibre8">Unit testing is done outside of QGIS itself; that is, the unit tests run as an external Python application that loads your plugin and then tests it. Doing this isn't as bad as it sounds; in <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre10">Getting Started with QGIS</em>, we looked at a simple external application built on top of QGIS, and we <a id="id285" class="calibre1"/>can use pretty much the same process to write our testing code. Here's the boilerplate example of an external application, copied <a id="id286" class="calibre1"/>from <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre10">Getting Started with QGIS</em>:</p><div><pre class="programlisting">import os

from qgis.core import *

QgsApplication.setPrefixPath(os.environ['QGIS_PREFIX'], True)
QgsApplication.initQgis()

# ...

QgsApplication.exitQgis()</pre></div><p class="calibre8">You will also need to use an appropriate wrapper script, as described in <a class="calibre1" title="Chapter 1. Getting Started with QGIS" href="part0014_split_000.html#page">Chapter 1</a>, <em class="calibre10">Getting Started with QGIS</em>, so that the Python path and other environment variables are set correctly.</p><p class="calibre8">With QGIS unit tests, you have to set up the QGIS environment before the test is run, and then shut it down again once the test finishes. This is done by placing the appropriate parts of the boilerplate code into the unit test's <code class="email">setup()</code> and <code class="email">tearDown()</code> methods, like this:</p><div><pre class="programlisting">import unittest

import os

from qgis.core import *

class MyTest(unittest.TestCase):
  def setup(self):
    QgsApplication.setPrefixPath(os.environ['QGIS_PREFIX'], True)
    QgsApplication.initQgis()

  def tearDown(self):
    QgsApplication.exitQgis()

  def test_plugin(self):
    ...</pre></div><p class="calibre8">You can then import and test your plugin's Python code within the <code class="email">test_plugin()</code> method.</p><div><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8">You can, of course, have multiple <code class="email">test_XXX()</code> methods in your test case. The PyQGIS library will be initialized before the first test is run, and shut down after the last test finishes.</p></div><p class="calibre8">Testing plugins in this way does reveal a major limitation of this approach: there is no <code class="email">QgisInterface</code> object available for your plugin to use. This means that the parts of the plugin you're testing can't interact with the rest of the QGIS system via the <code class="email">iface</code> variable.</p><p class="calibre8">Unit tests get around this <a id="id287" class="calibre1"/>limitation by creating a fake QGIS environment (including a Python implementation of <code class="email">QgisInterface</code>), which the plugin can use for <a id="id288" class="calibre1"/>testing. The plugin is then loaded by adding the plugin's directory to <code class="email">sys.path</code> and then calling the plugin's <code class="email">ClassFactory()</code> function with the fake <code class="email">QgisInterface</code>:</p><div><pre class="programlisting">sys.path.append("/path/to/my/plugin")
import MyPlugin
plugin = MyPlugin.classFactory(fake_iface)</pre></div><p class="calibre8">While it seems complex and might introduce errors that only occur while the plugin is being tested, this process is actually very useful. If you want to use unit tests, you can either implement your own <code class="email">QgsInterface</code> or make use of the unit testing framework provided by the Plugin Builder.</p><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">If you want to roll your own unit tests, a good starting point is available at <a class="calibre1" href="http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins">http://snorf.net/blog/2014/01/04/writing-unit-tests-for-qgis-python-plugins</a>.</p></div><p class="calibre8">If you are doing unit <a id="id289" class="calibre1"/>testing, then you would normally add an extra target to your Makefile so you can run the unit tests simply by typing:</p><div><pre class="programlisting">make test</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec28" class="calibre1"/>Distributing your plugin</h2></div></div></div><p class="calibre8">To share your <a id="id290" class="calibre1"/>plugin with others, you have to upload it to a plugin repository. Let's look at the steps involved in doing this.</p><p class="calibre8">Firstly, you need to ensure that your plugin adheres to the following rules:</p><div><ul class="itemizedlist"><li class="listitem">The name of your plugin's folder must contain only upper- and lowercase letters, digits, underscores, and hyphens, and must not start with a digit.</li><li class="listitem">Your <code class="email">metadata.txt</code> file must exist and include the following entries:<div><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Metadata entry</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Description</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">name</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">The name of your plugin.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">qgisMinimumVersion</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">The minimum version of QGIS that your plugin will run under.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">description</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">A brief textual description of your plugin and what it does.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">version</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">The version number of your plugin, as a string. Note that you can't upload two copies of a plugin with the same version.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">author</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">The name of the plugin's author.</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">
<code class="literal">email</code>
</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">The author's e-mail address.</p>
</td></tr></tbody></table></div></li></ul></div><p class="calibre8">If you don't follow these rules, your plugin will be rejected when you attempt to upload it.</p><p class="calibre8">The next step is to compress the plugin into a ZIP archive. Note that you should compress the folder that contains your plugin, so that the ZIP archive has only one entry (the plugin's directory) rather than a collection of individual files.</p><p class="calibre8">The final step is to upload the ZIP archive to a QGIS plugin repository. You have two options here:</p><div><ul class="itemizedlist"><li class="listitem">You can use <a id="id291" class="calibre1"/>the official plugin repository at <a class="calibre1" href="http://plugins.qgis.org">http://plugins.qgis.org</a>. This will make your plugin available to all QGIS users.</li><li class="listitem">You can set up your own plugin repository. This means that only people who know about your repository or have access to it (for example, via a VPN) can download your plugins.</li></ul></div><p class="calibre8">Setting up your own plugin repository isn't nearly as daunting as it sounds; you simply create an XML file that lists the plugins that you want to make available, and then upload that XML file and the plugins themselves to a web server. Here is what the XML file looks like:</p><div><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;plugins&gt;
 &lt;pyqgis_plugin name="MyPlugin" version="0.1"&gt;
  &lt;description&gt;This is a test plugin&lt;/description&gt;
  &lt;homepage&gt;http://my-site.com/qgis/myplugin&lt;/homepage&gt;
  &lt;qgis_minimum_version&gt;2.2&lt;/qgis_minimum_version&gt;
  &lt;file_name&gt;myplugin.zip&lt;/file_name&gt;
  &lt;author_name&gt;My Name&lt;/author_name&gt;
  &lt;download_url&gt;http://my-site.com/myplugin.zip&lt;/download_url&gt;
 &lt;/pyqgis_plugin&gt;
&lt;/plugins&gt;</pre></div><p class="calibre8">Create a <code class="email">&lt;pyqgis_plugin&gt;</code> section for each of your repository's plugins. Once this file has been <a id="id292" class="calibre1"/>uploaded, the user simply goes to the QGIS Plugin Manager window, clicks on the <strong class="calibre9">Settings</strong> tab, and clicks on the <strong class="calibre9">Add</strong> button in the <strong class="calibre9">Plugin repositories</strong> section of the window. The user will be asked to enter the details of the new repository:</p><div><img src="img/00043.jpeg" alt="Distributing your plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The <strong class="calibre9">URL</strong> field should be set to the complete URL for the XML file you uploaded, for example <code class="email">http://my-site.com/qgis_plugins.xml</code>. Once the repository has been added, the plugins listed in the XML file will appear in the Plugin Manager, and the user can install them directly.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Writing a useful plugin</h1></div></div></div><p class="calibre8">Let's now <a id="id293" class="calibre1"/>apply the knowledge we've gained to build a plugin that does something useful and interesting. While there are built-in tools in QGIS to query a feature and identify the feature's attributes, there is no easy way of getting information about the <em class="calibre10">geometry</em> associated with a feature. So let's write a plugin that lets the user click on a feature and display various statistics about that feature's geometry.</p><p class="calibre8">We're going to call our new plugin <strong class="calibre9">Geometry Info</strong>. When the user clicks on our plugin's toolbar icon, we will activate a map tool that listens for mouse clicks on the map canvas. When the user clicks on the map canvas, we'll find the feature that the user clicked on, and calculate and display statistics about that feature's geometry.</p><p class="calibre8">Let's start by <a id="id294" class="calibre1"/>setting up the basic template for our plugin. Create a directory named <code class="email">geometryInfo</code>, put it somewhere convenient, and create an <code class="email">__init__.py</code> file within that directory. In that file, place the following code:</p><div><pre class="programlisting">def classFactory(iface):
  from geometryInfo import GeometryInfoPlugin
  return GeometryInfoPlugin(iface)</pre></div><p class="calibre8">Next, we need to define the metadata for our plugin. Create the <code class="email">metadata.txt</code> file and add the following to this file:</p><div><pre class="programlisting">[general]
name=Geometry Info
email=<em class="calibre10">your email address</em>
author=<em class="calibre10">your name</em>
qgisMinimumVersion=2.0
description=Displays information about the clicked-on geometry.
about=Plugin used as an example in Chapter 4 of Building Mapping
   Applications with QGIS.
version=version 0.1</pre></div><p class="calibre8">Next, we need an icon for our plugin. We're going to use the following icon:</p><div><img src="img/00044.jpeg" alt="Writing a useful plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">A copy of this icon <a id="id295" class="calibre1"/>is available with the sample code that comes with this book, though you can create your own icon or find a different one to use somewhere; just make sure that the resulting image file is named <code class="email">icon.png</code>, and that the icon is 24 x 24 pixels. Place this file into your <code class="email">geometryInfo</code> directory along with the other files.</p><p class="calibre8">We next need to define the <code class="email">resources.qrc</code> file that tells QGIS about our icon. Create this file and put the following text into it:</p><div><pre class="programlisting">&lt;RCC&gt;
  &lt;qresource prefix="/plugins/geometryInfo"&gt;
    &lt;file&gt;icon.png&lt;/file&gt;
  &lt;/qresource&gt;
&lt;/RCC&gt;</pre></div><p class="calibre8">Finally, let's create a Makefile to automate the process of compiling and deploying our plugin. Here's a suitable Makefile to get you started:</p><div><pre class="programlisting">PLUGINNAME = geometryInfo
PY_FILES = geometryInfo.py __init__.py
EXTRAS = icon.png metadata.txt
RESOURCE_FILES = resources.py

default: compile

compile: $(RESOURCE_FILES)

%.py : %.qrc
  pyrcc4 -o $@ $&lt;

deploy: compile
  mkdir -p $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(PY_FILES) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(RESOURCE_FILES) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)
  cp -vf $(EXTRAS) $(HOME)/.qgis2/python/plugins/$(PLUGINNAME)

clean:
  rm $(RESOURCE_FILES)</pre></div><p class="calibre8">You may need to modify the paths in this file to suit your development setup. Notice that because our plugin won't have any UI templates, we've removed the portions of the Makefile that compile and deploy the template files.</p><p class="calibre8">Now that we've created the framework for our plugin, let's start writing the code that does the actual work. The <a id="id296" class="calibre1"/>final file we need for our plugin will be named <code class="email">geometryInfo.py</code>. Create this file and put the following code into it:</p><div><pre class="programlisting">from PyQt4.QtCore import *
from PyQt4.QtGui import *
import resources
from qgis.core import *
from qgis.gui import *

class GeometryInfoPlugin:
  def __init__(self, iface):
    self.iface = iface

  def initGui(self):
    icon = QIcon(":/plugins/geometryInfo/icon.png")
    self.action = QAction(icon, "Get Geometry Info",
               self.iface.mainWindow())
    QObject.connect(self.action, SIGNAL("triggered()"),
            self.onClick)
    self.iface.addPluginToMenu("Geometry Info", self.action)
    self.iface.addToolBarIcon(self.action)

  def unload(self):
    self.iface.removePluginMenu("Geometry Info", self.action)
    self.iface.removeToolBarIcon(self.action)

  def onClick(self):
    QMessageBox.information(self.iface.mainWindow(), "debug",
                "Click")</pre></div><p class="calibre8">Apart from a few extra <code class="email">import</code> statements (which we'll need later on), this is almost identical to our earlier example plugin. The <code class="email">onClick()</code> method, of course, is just a placeholder so we can tell if the plugin is working.</p><p class="calibre8">We can now run our plugin by typing <code class="email">make deploy</code> in the command line, starting up QGIS, and enabling the plugin using the <strong class="calibre9">Manage and Install Plugins...</strong> command, just like we did earlier. If all goes well, the plugin's icon should appear in the QGIS toolbar, and when you select it, the "Click" message should be displayed.</p><p class="calibre8">Next, we want to make <a id="id297" class="calibre1"/>our toolbar icon <em class="calibre10">checkable</em>. That is, when the user clicks on our icon, we want to highlight it, activate our map tool, and keep the icon highlighted until the user either clicks on the icon again or switches to a different tool. To make the toolbar icon checkable, add the following line to your <code class="email">initGui()</code> method, immediately after the <code class="email">self.action = QAction(...)</code> statement:</p><div><pre class="programlisting">    self.action.setCheckable(True)</pre></div><p class="calibre8">We then have to respond to the checking and unchecking of our toolbar icon by activating and deactivating our map tool. Here is what the code will look like:</p><div><pre class="programlisting">  def onClick(self):
    if not self.action.isChecked():
      # ...deactivate map tool...
      return
    self.action.setChecked(True)
    # ...activate map tool...</pre></div><p class="calibre8">The first thing we do is see if the user has unchecked our icon, and if this is the case, we deactivate the map tool. Otherwise, we visually highlight the icon by calling <code class="email">self.action.setChecked(True)</code>, and then activate our map tool. In this way, our plugin will act like a mode within QGIS; clicking on the icon will activate the map tool, and clicking on it again (or selecting a different icon) will deactivate it.</p><p class="calibre8">We're now ready to implement our map tool. Earlier, we looked at how you can use the <code class="email">QgsMapTool</code> class to respond to mouse clicks within the map canvas. In this case, we'll use a subclass of <code class="email">QgsMapTool</code>, called <code class="email">QgsMapToolIdentify</code>. This class makes it easy to find the feature at a given point. When the user clicks on the map canvas, we'll use the <code class="email">QgsMapToolIdentify.identify()</code> method to find the first clicked-on feature, and then calculate and display various statistics about that feature's geometry.</p><p class="calibre8">Add the following code to the end of your <code class="email">geometryInfo.py</code> module:</p><div><pre class="programlisting">class GeometryInfoMapTool(QgsMapToolIdentify):
  def __init__(self, iface):
    QgsMapToolIdentify.__init__(self, iface.mapCanvas())
    self.iface = iface

  def canvasReleaseEvent(self, event):
    QMessageBox.information(self.iface.mainWindow(), "debug",
                "Canvas Click")</pre></div><p class="calibre8">This defines our <code class="email">QgsMapToolIdentify</code> subclass. It doesn't do anything useful yet, but it will respond with a simple "Canvas Click" message when the user clicks on the map canvas. Now, let's <a id="id298" class="calibre1"/>finish writing our plugin's <code class="email">onClick()</code> method to activate and deactivate our map tool as the user clicks on our toolbar icon. This is what the <code class="email">onClick()</code> method should look like:</p><div><pre class="programlisting">  def onClick(self):
    if not self.action.isChecked():
      self.iface.mapCanvas().unsetMapTool(self.mapTool)
      self.mapTool = None
      return
    self.action.setChecked(True)
    self.mapTool = GeometryInfoMapTool(self.iface)
    self.mapTool.setAction(self.action)
    self.iface.mapCanvas().setMapTool(self.mapTool)</pre></div><p class="calibre8">You should now be able to run your plugin by typing <code class="email">make deploy</code>, and then reload it in QGIS to see how it works. If all goes well, the toolbar icon will be highlighted when you click on it, and the "Canvas Click" message should appear when you click on the map canvas.</p><p class="calibre8">Now, let's replace the <code class="email">GeometryInfoMapTool.canvasReleaseEvent()</code> method with code to identify the feature the user clicked on. Here's the necessary code:</p><div><pre class="programlisting">    def canvasReleaseEvent(self, event):
    found_features = self.identify(event.x(), event.y(),
                    self.TopDownStopAtFirst,
                    self.VectorLayer)
    if len(found_features) &gt; 0:
      layer = found_features[0].mLayer
      feature = found_features[0].mFeature
      geometry = feature.geometry()</pre></div><p class="calibre8">As you can see, we call <code class="email">QgsMapToolIdentify.identify()</code> to see which feature the user clicked on. The parameters we're using tell the method to only return the top-most vector feature at the point where the user clicked; the <code class="email">identify()</code> method can also return all features at a given point or the pixel value if the user clicked on a raster layer, but in our case, we only want the top-most vector feature.</p><p class="calibre8">Once we've found the clicked-on feature, we identify which map layer the feature is on, and extract the feature's geometry. With this information, we can analyze the geometry and display the calculated statistics, which is the whole purpose of our plugin.</p><p class="calibre8">A <code class="email">QGSGeometry</code> object can represent a point, a line, a polygon, a number of points, a number of lines, a number of polygons, or a collection of different types of geometries. To analyze the statistics for any <code class="email">QGSGeometry</code> object, we have to be ready to handle all these different types of geometries. Fortunately, the basic logic is quite straightforward:</p><div><ul class="itemizedlist"><li class="listitem">If the geometry has multiple parts, we split the geometry into its component parts, and process each part in turn</li><li class="listitem">For point geometries, we count the number of points</li><li class="listitem">For line geometries, we count the number of lines and calculate their total length</li><li class="listitem">For polygon <a id="id299" class="calibre1"/>geometries, we count the number of polygons and calculate their total area and perimeter</li></ul></div><p class="calibre8">Let's add two methods to our <code class="email">GeometryInfoMapTool</code> class to analyze a geometry:</p><div><pre class="programlisting">  def analyzeGeometry(self, geometry, layer, info):
    crs = layer.dataProvider().crs()
    calculator = QgsDistanceArea()
    calculator.setSourceCrs(crs)
    calculator.setEllipsoid(crs.ellipsoidAcronym())
    calculator.setEllipsoidalMode(crs.geographicFlag())

    if geometry.isMultipart():
      self.add(info, 'num_multi', 1)
      parts = geometry.asGeometryCollection()
      for sub_geometry in parts:
        self.analyzeGeometry(sub_geometry, layer, info)
    elif geometry.type() == QGis.Point:
      self.add(info, 'num_points', 1)
    elif geometry.type() == QGis.Line:
      self.add(info, 'num_lines', 1)
      self.add(info, 'tot_line_length',
           calculator.measure(geometry))
    elif geometry.type() == QGis.Polygon:
      self.add(info, 'num_polygons', 1)
      self.add(info, 'tot_poly_area',
           calculator.measure(geometry))
      self.add(info, 'tot_poly_perimeter',
           calculator.measurePerimeter(geometry))

  def add(self, info, key, n):
    if key in info:
      info[key] = info[key] + n
    else:
      info[key] = n</pre></div><p class="calibre8">The <code class="email">add()</code> method is just a helper method that adds a number to a dictionary entry if it exists, and creates that entry if it doesn't. This allows us to use the <code class="email">info</code> dictionary to store the results as we calculate them.</p><p class="calibre8">As you can see, the <code class="email">analyzeGeometry()</code> method makes use of a <code class="email">QgsDistanceArea</code> object to calculate the lengths and areas of a geometry. Note that our <code class="email">analyzeGeometry()</code> method is recursive; if a geometry has multiple parts, each subgeometry might also have multiple parts, so we call <code class="email">analyzeGeometry()</code> recursively on each part to allow these nested geometries to be handled correctly.</p><p class="calibre8">When we call <code class="email">analyzeGeometry()</code> on a given <code class="email">QGSGeometry</code>, the results of the analysis will be stored in the <code class="email">info</code> dictionary. Let's add some code to the end of our <code class="email">canvasReleaseEvent()</code> method to analyze the clicked-on geometry and display the results:</p><div><pre class="programlisting">  info = {}
  self.analyzeGeometry(geometry, layer, info)
  QMessageBox.information(self.iface.mainWindow(), "debug",
              repr(info))</pre></div><p class="calibre8">If you now do a <code class="email">make deploy</code> and reload the plugin, you should be able to click on a feature and display <a id="id300" class="calibre1"/>information about that feature's geometry. The plugin's output should look like the following:</p><div><img src="img/00045.jpeg" alt="Writing a useful plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This is certainly telling us something useful, but it's not very readable. Let's look at how we can improve the way we display the statistics.</p><p class="calibre8">Firstly, notice that the area and perimeter values are not particularly useful; the <code class="email">QgsDistanceArea</code> object returns lengths and areas in meters, but for most geometries, these values are too precise and too big. Let's make it more readable by converting the calculated lengths and areas into a whole number of kilometers. To do this, make the following highlighted changes to your <code class="email">analyzeGeometry()</code> method:</p><div><pre class="programlisting">    ...
    elif geometry.type() == QGis.Line:
      self.add(info, 'num_lines', 1)
      self.add(info, 'tot_line_length',
<strong class="calibre9">          int(calculator.measure(geometry)/1000))</strong>
    elif geometry.type() == QGis.Polygon:
      self.add(info, 'num_polygons', 1)
      self.add(info, 'tot_poly_area',
<strong class="calibre9">         int(calculator.measure(geometry)/1000000))</strong>
      self.add(info, 'tot_poly_perimeter',
<strong class="calibre9">       int(calculator.measurePerimeter(geometry)/1000))</strong>
</pre></div><p class="calibre8">As you can see, we're simply dividing the calculated lengths by a thousand to get the length in kilometers, and dividing the calculated area by a million to get the area in square kilometers.</p><p class="calibre8">The final thing we want <a id="id301" class="calibre1"/>to do is display those calculated statistics in a more friendly way. To do this, replace the <code class="email">QMessageBox.information()</code> call at the end of your <code class="email">canvasReleaseEvent()</code> method with the following:</p><div><pre class="programlisting">      fields = [("num_multi",
             "Number of multipart geometries", ""),
           ("num_points",
             "Number of point geometries", ""),
           ("num_lines",
             "Number of line geometries", ""),
           ("tot_line_length",
             "Total length of line geometries",
             "km"),
           ("num_polygons",
             "Number of polygon geometries", ""),
           ("tot_poly_area",
             "Total area of polygon geometries",
             "square km"),
           ("tot_poly_perimeter",
             "Total perimeter of polygon geometries",
             "km")]

      results = []
      for field,label,suffix in fields:
        if field in info:
          results.append("%s = %s %s" %
                  (label, str(info[field]),
                  suffix))

      QMessageBox.information(self.iface.mainWindow(),
                  "Geometry Info",
                  "\n".join(results))</pre></div><p class="calibre8">Your plugin will now display the statistics in a more readable format, for example:</p><div><img src="img/00046.jpeg" alt="Writing a useful plugin" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We've now completed <a id="id302" class="calibre1"/>our plugin, and can use it to display information about any geometry within QGIS. More importantly, we've learned how to create a complete and useful QGIS plugin, and you can build on this knowledge to create your own plugins.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec25" class="calibre1"/>Possibilities and limitations of plugins</h1></div></div></div><p class="calibre8">As we have <a id="id303" class="calibre1"/>seen, it's quite possible to write a plugin that acts as a sophisticated mapping tool integrated directly into the QGIS user interface, interacting with the map canvas and responding in various ways to the user's actions. Some of the other things you can do with a QGIS plugin include:</p><div><ul class="itemizedlist"><li class="listitem">Creating your own subclass of <code class="email">QgsMapCanvasItem</code>, so your plugin can draw items directly onto the QGIS map canvas.</li><li class="listitem">Creating a custom map layer by subclassing <code class="email">QgsPluginLayer</code>. This allows your plugin to act as a completely separate map layer.</li><li class="listitem">Using signal handlers to intercept standard QGIS actions, for example, redrawing the canvas and executing your own code when a signal is sent.</li><li class="listitem">Creating map layers programmatically, setting up the data provider, and creating custom symbols and renderers to control how the map data is displayed.</li><li class="listitem">Using the QGIS Map Composer tools to combine rendered map layers, labels, legends, tables, and so on, mimicking the layout of a paper map. The resulting map view can be displayed in a window, printed, or saved to disk as an image or a PDF file.</li></ul></div><p class="calibre8">There are, however, some <a id="id304" class="calibre1"/>limitations on what a QGIS plugin is able to do:</p><div><ul class="itemizedlist"><li class="listitem">By its very nature, a plugin sits inside the running QGIS application. Your plugin runs alongside all the other plugins that the user has installed, and shares the same user interface and menu structure. This means that you can't implement turnkey mapping applications as QGIS plugins. The full complexity of QGIS is shown to the user, which can be daunting for the user who might be looking for a custom application that performs just one task. In this situation, it might be better to write your code as an external application that uses the PyQGIS library, rather than attempt to write it as a plugin.</li><li class="listitem">Since the plugin runs within QGIS itself, there are many points of contact between the plugin code and the QGIS environment. As QGIS is constantly evolving, this means that a plugin can stop working when a new version of QGIS is released. This is far more likely to happen with a plugin than with code written as an external application using the PyQGIS library.</li><li class="listitem">Since the plugin uses the Python interpreter built into QGIS itself, you can't make use of third-party Python libraries that aren't included in QGIS's Python interpreter. While you can get around this for pure Python libraries (by including the Python source code as part of your plugin), if the library you want makes use of extensions written in C, you simply won't be able to use that library in your plugin.</li></ul></div><p class="calibre8">Ultimately, it is up to you to decide if plugins are a suitable way of implementing your mapping application. For some applications, they are ideal; they are certainly a lot easier to develop and distribute than external applications, and if your application is aimed at people who are already using QGIS, then the plugin scheme is a logical approach to take. In other situations, an external application built on top of PyQGIS might be more suitable.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec26" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we delved into the topic of QGIS plugin programming. We created two separate plugins, a simple one to get started with, and a more complex and useful plugin that displays information about a clicked-on feature's geometry. We also looked at the QGIS plugin architecture, the plugin development process, and some of the possibilities and limitations of QGIS plugins. Along the way, we learned about the tools needed to develop QGIS plugins, discovered that plugins are simply Python packages with certain special files in them, and saw how the PyQt command-line tools can be used to compile user-interface templates and resource description files into Python modules so that they can be used within a plugin.</p><p class="calibre8">We also looked at how your plugin is integrated into the QGIS user interface using icons and menu items, how to run your plugin, and what happens when your plugin crashes. We also looked briefly at the Plugin Builder, and how it can be useful.</p><p class="calibre8">Next, we looked at how to use a Makefile to automate plugin compilation and deployment, and the typical write-make-reload-test cycle used to develop plugins. We saw how to write and use HTML help files within your plugin, how unit tests can be used for QGIS plugins, and how to distribute your plugin, both to the official QGIS plugin repository and to a repository that you set up yourself.</p><p class="calibre8">We learned that there are many things you can do with plugins, including drawing into the map canvas, creating custom layers, intercepting QGIS actions, programmatically creating map layers, and composing complex maps. At the same time, we saw that there are some constraints in what a QGIS plugin can do, including the need to share the QGIS user interface with all other plugins, the inability to create turnkey mapping applications, compatibility issues, and difficulties in using some third-party Python libraries.</p><p class="calibre8">In the next chapter, we will look at the process of using the PyQGIS libraries within your own external Python programs. This gets around many of the limitations of a QGIS Plugin, at the cost of some additional complexity.</p></div></body></html>