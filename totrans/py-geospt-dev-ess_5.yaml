- en: Chapter 5. Managing and Organizing Geographic Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 管理地理数据
- en: 'Now that we have an up-and-running explorative application, we can move on
    to developing some more day-to-day practical features. A common task for users
    of geographic data is to prepare, clean, restructure, and organize data. In this
    chapter, you will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个运行中的探索性应用程序，我们可以继续开发一些更实用的日常功能。地理数据用户的一个常见任务是准备、清理、重构和组织数据。在本章中，你将执行以下操作：
- en: Create a window for inspecting the basic properties of each layer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个窗口来检查每个层的基属性
- en: 'Build some convenience functions for commonly needed management tasks, and
    later add them to the user interface. These functions are as follows:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为常用的管理任务构建一些便利函数，稍后将其添加到用户界面。这些函数如下：
- en: Operations on individual layers being available when the user right-clicks on
    each layer in the LayersPane widget (splitting, geometry cleaning, and resampling)
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在LayersPane小部件中的每个层上右键单击时，可用的单个层操作（分割、几何清理和重采样）
- en: Batch operations on multiple layers available as buttons in the top ribbon area
    (merging and mosaicking)
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部功能区区域作为按钮提供的多个层的批量操作（合并和镶嵌）
- en: Assign dialogue windows to set the parameters when running each tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配对话框窗口以在运行每个工具时设置参数
- en: Creating the management module
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管理模块
- en: 'We start by creating a separate submodule to contain the functionality, one
    for vector, and one for raster. First, create the `vector/manager.py` file and
    start it up with the following imports:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个单独的子模块来包含功能，一个用于矢量，一个用于栅格。首先，创建`vector/manager.py`文件，并使用以下导入启动它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, create the file `raster/manager.py` as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`raster/manager.py`文件，如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To make these manager modules available to their respective `vector` and `raster`
    parent package, add the following import statement to both `vector/__init__.py`
    and `raster/__init__.py`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些管理模块对其各自的`vector`和`raster`父包可用，请将以下导入语句添加到`vector/__init__.py`和`raster/__init__.py`中：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Inspecting files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件
- en: As the most basic way to organize and troubleshoot one's files, one often needs
    to inspect the properties and details of one's data and loaded layers. This information
    is usually available in a separate layer options window. Later in this chapter,
    we will make this window accessible by right-clicking on a layer, and clicking
    on **Properties** under the **Layer-specific right-click functions** subheading.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为组织和管理个人文件的最基本方式，人们经常需要检查个人数据和加载层属性及细节。这些信息通常可以在一个单独的层选项窗口中找到。在本章的后面部分，我们将通过在层上右键单击并点击**属性**下的**层特定右键功能**子标题来使此窗口可访问。
- en: 'We define a template class for this type of window, with support for tabbed
    windows using our ribbon class, and create a convenience method for adding information
    in a nicely formatted way. This is done in the `app/dialogues.py` module. Since
    we have not yet set up the contents of `app/dialogues.py`, we also have to set
    up its imports and styling, as shown in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这种类型的窗口定义了一个模板类，它支持使用我们的功能区类进行标签窗口，并创建了一个方便的方法来以良好的格式添加信息。这是在`app/dialogues.py`模块中完成的。由于我们尚未设置`app/dialogues.py`的内容，我们还需要设置其导入和样式，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Vector and raster data will typically have very different properties, so we
    make a separate window for each. First, for vector layers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量和栅格数据通常具有非常不同的属性，因此我们为每个数据类型创建了一个单独的窗口。首先，对于矢量层：
- en: '![Inspecting files](img/5407OS_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![检查文件](img/5407OS_05_01.jpg)'
- en: 'Here is the code for the same:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同代码的示例：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, for raster layers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于栅格层：
- en: '![Inspecting files](img/5407OS_05_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![检查文件](img/5407OS_05_02.jpg)'
- en: 'Here is the code for the same:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同代码的示例：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Organizing files
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织文件
- en: Traditionally, when working in a GIS application, one first seeks out the data
    files one wishes to use from various organizational websites. Ideally, one stores
    these in some logically organized folder structure on the local computer, and
    from there, one can load the data into the GIS application. In this section, we
    add functionality to help the user manage their files and access and alter basic
    file contents.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在GIS应用程序中工作时，人们首先从各种组织网站中寻找希望使用的数据文件。理想情况下，人们将这些文件存储在本地计算机上逻辑上组织的文件夹结构中，然后可以从那里将数据加载到GIS应用程序中。在本节中，我们添加了帮助用户管理文件以及访问和修改基本文件内容的功能。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For some great examples of the varied types and sources of GIS data available
    online, see the list at [http://freegisdata.rtwilson.com/](http://freegisdata.rtwilson.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些在线可用的GIS数据类型和来源的精彩示例，请参阅[http://freegisdata.rtwilson.com/](http://freegisdata.rtwilson.com/)上的列表。
- en: Vector data
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量数据
- en: Vector data is very versatile; its table-like data structure means that it can
    contain data on a wide variety of concepts in a single file, or contain data for
    only a very specific concept. For practical usage, it is easier if each file is
    tailored exactly to the data one needs, since these are represented as layers
    when loaded in the application. There are therefore many cases where the user
    may wish to reorganize the data to better fit their needs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数据非常灵活；其类似于表格的数据结构意味着它可以在单个文件中包含关于广泛概念的数据，或者只包含关于非常特定概念的数据。对于实际应用来说，如果每个文件都精确地针对所需数据定制，那就更容易了，因为这些数据在应用程序中加载时是以图层的形式表示的。因此，有许多情况下，用户可能希望重新组织数据以更好地满足他们的需求。
- en: 'Here, we will implement three specific operations for organizing and maintaining
    vector data: splitting, merging, and cleaning. The following illustration gives
    a preview of the inputs and outputs of each:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现三个用于组织和维护向量数据的特定操作：分割、合并和清理。以下插图给出了每个操作的输入和输出的预览：
- en: '![Vector data](img/5407OS_05_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![向量数据](img/5407OS_05_03.jpg)'
- en: Splitting
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割
- en: 'For instance, the user may have a file that groups a diverse set of concepts,
    but is only interested in working with certain types separately. In such cases,
    it will be easier to just split the data for each unique occurrence of a field—known
    as splitting. In terms of data structure, this means slicing the height of the
    table into multiple tables along with their associated geometries. We do this
    conveniently using Python''s built-in `sorted()` and `itertools groupby()` functions.
    A `splitfields` option defines a list of one or more field names to split on so
    that each unique value combination defines a new split. So, head to the `manager.py`
    file for vector data and write the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可能有一个将各种概念分组在一起的文件，但只对单独处理某些类型感兴趣。在这种情况下，只需为每个字段的唯一出现分割数据会更简单——这被称为分割。从数据结构的角度来看，这意味着将表格的高度切割成多个表格，以及它们相关的几何形状。我们方便地使用Python内置的`sorted()`和`itertools.groupby()`函数来完成这项工作。`splitfields`选项定义了一个要分割的字段名称列表，以便每个唯一值组合定义一个新的分割。因此，前往`manager.py`文件以处理向量数据，并编写以下代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Merging
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并
- en: 'One can also face the opposite scenario, where one wishes to group together
    a series of data files spread across multiple files. This is called a **merge
    operation**. A merge operation stacks the rows from multiple tables into one big
    one, and generally increases the spatial coverage, since it leads to a bigger
    collection of geometries. The output attribute table from this operation also
    expands horizontally to include all of the variables/fields from its input files.
    Finally, remember that the `VectorData` instances can only contain one type of
    geometry (points, lines, or polygons), so trying to merge layers of different
    geometry types will result in an error. We implement it in the following way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也可能遇到相反的情况，即希望将分散在多个文件中的多个数据文件组合在一起。这被称为**合并操作**。合并操作将多个表中的行堆叠成一个大的表，通常会增加空间覆盖范围，因为它导致几何形状的集合更大。此操作的输出属性表也水平扩展以包含其输入文件中的所有变量/字段。最后，请记住，`VectorData`实例只能包含一种类型的几何形状（点、线或多边形），因此尝试合并不同几何类型图层将导致错误。我们以以下方式实现它：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Geometry cleaning
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 几何清理
- en: Geographic data can come from a very wide variety of sources, and this means
    that their levels of integrity can vary greatly. For instance, there are many
    rules that govern what is and is not allowed for each geometry type, but not all
    data producers (including both software and individuals) use the same rules or
    follow them to the same degree. This can be a problem for GIS processing, analysis
    applications, and programming libraries if the data is corrupted or not formatted
    in the way that is expected. Data may also contain unnecessary junk information
    that doesn't add anything useful (depending on the level of detail needed), making
    the file size overly large. Geometry cleaning can therefore be a useful feature
    as a first step when gathering one's data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 地理数据可以来自非常广泛的来源，这意味着它们的完整性水平可能会有很大差异。例如，有许多规则规定了每种几何类型允许或不允许的内容，但并非所有数据生产者（包括软件和个人）都使用相同的规则或以相同程度遵循这些规则。如果数据损坏或未以预期的方式格式化，这可能会成为GIS处理、分析应用程序和编程库的问题。数据还可能包含不必要的垃圾信息，这些信息不会增加任何有用的内容（根据所需细节水平而定），从而使文件大小过大。因此，在收集数据时，几何清理可以作为第一步的一个有用功能。
- en: 'To do this, we make a function that loops the geometries of our features. With
    the help of the Shapely library, we fix "bowtie" errors (polygons only), remove
    repeat points, and exclude any remaining geometries deemed to be invalid according
    to the GeoJSON specification. The tolerance argument can be set to higher than
    zero to reduce file size, but note that this alters the shape of the geometries
    and decreases the level of detail and precision in the output. Refer to the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们创建了一个循环我们特征几何体的函数。借助Shapely库的帮助，我们修复“蝴蝶结”错误（仅限多边形），删除重复的点，并排除任何根据GeoJSON规范被认为无效的剩余几何体。容差参数可以设置为一个大于零的值以减小文件大小，但请注意，这会改变几何体的形状，并降低输出中的细节和精度水平。请参考以下代码：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more on polygon bowtie errors, visit:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于多边形蝴蝶结错误的信息，请访问：
- en: '[http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely](http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely](http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely)'
- en: Raster data
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栅格数据
- en: 'There are many common raster file management functionalities that you may wish
    to implement. Here, we will only focus on two of them: mosaicking and resampling,
    as seen in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望实现许多常见的栅格文件管理功能。在这里，我们只关注其中两个：拼接和重采样，如以下截图所示：
- en: '![Raster data](img/5407OS_05_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![栅格数据](img/5407OS_05_04.jpg)'
- en: To implement these functionalities, we will take advantage of the image processing
    functionality from the PIL library. Since we are using an imaging library not
    primarily intended for geospatial data, the following code should be considered
    highly experimental and mostly for demonstration purposes; you may have to troubleshoot
    and improve on these methods on your own.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些功能，我们将利用PIL库的图像处理功能。由于我们使用的是一个并非主要用于地理空间数据的图像库，以下代码应被视为高度实验性的，主要用于演示目的；您可能需要自行调试和改进这些方法。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the main purpose of your application is to process satellite, imagery, and
    raster data, and you don't have time or feel comfortable finding your own solution
    using PIL, you may be better off just adding NumPy, GDAL, and related tools as
    dependencies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您应用程序的主要目的是处理卫星图像、影像和栅格数据，而且您没有时间或感到不舒服自己寻找解决方案使用PIL，那么您可能最好只是将NumPy、GDAL和相关工具作为依赖项添加。
- en: 'For a list of GDAL''s broad range of functionality for handling raster data,
    see:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GDAL处理栅格数据广泛功能的列表，请参阅：
- en: '[https://pcjericks.github.io/py-gdalogr-cookbook/](https://pcjericks.github.io/py-gdalogr-cookbook/)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pcjericks.github.io/py-gdalogr-cookbook/](https://pcjericks.github.io/py-gdalogr-cookbook/)'
- en: Mosaicking
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拼接
- en: 'Similar to how vector data can be merged together, it is also possible to mosaic
    multiple adjacent raster datasets into a single larger raster data. The way we
    implement it here is by creating an `align_rasters()` function, which takes any
    number of rasters, automatically finds the coordinate bounding box that contains
    all, as well as the required pixel dimensions (though we should probably allow
    some user control here), and uses this information to position each raster to
    their respective location in a region that bounds all of our rasters. We add this
    as a function in the `raster/manager.py` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与矢量数据可以合并在一起的方式类似，也可以将多个相邻的栅格数据集镶嵌成一个更大的栅格数据。我们在这里实现的方式是创建一个 `align_rasters()`
    函数，它接受任意数量的栅格，自动找到包含所有栅格的坐标边界框以及所需的像素尺寸（尽管我们可能应该允许一些用户控制），并使用这些信息将每个栅格定位到包含所有栅格的区域中的相应位置。我们将这个函数添加到
    `raster/manager.py` 文件中：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we now have a way to align and properly position the rasters in space,
    we can easily mosaic them into a new raster by simply creating a new grid with
    dimensions that bound all rasters and pasting each raster into it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了一种对齐和正确定位空间中栅格的方法，我们可以通过简单地创建一个新网格，其尺寸包含所有栅格，并将每个栅格粘贴到其中来轻松地将它们镶嵌成一个新的栅格：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that unlike a vector merge, where overlapping geometries are kept in their
    original form, raster mosaicking needs a rule for choosing a value when there
    are overlapping cells. In the previous code, we didn't support any customization
    of the overlap rule, but instead just pasted each raster on top of each other
    so that any overlapping cells hold the value of the last raster to be pasted-a
    so-called "last" rule. You may implement other overlap-rules by looking at the
    tools available in the PIL library, such as `average` value with `PIL.Image.blend()`,
    or `min` or `max` with the functions found in the `PIL.ImageOps` submodule.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与矢量合并不同，矢量合并会保留重叠几何形状的原始形式，而栅格镶嵌需要有一个规则来选择值，当存在重叠的单元格时。在之前的代码中，我们没有支持任何重叠规则的定制，而是简单地逐个将每个栅格粘贴到另一个栅格的上方，使得任何重叠的单元格都保留最后粘贴的栅格的值——这就是所谓的“最后”规则。您可以通过查看
    PIL 库中可用的工具来实现其他重叠规则，例如使用 `PIL.Image.blend()` 的 `average` 值，或者使用 `min` 或 `max`
    与 `PIL.ImageOps` 子模块中找到的函数。
- en: Resampling
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新采样
- en: For raster data, the equivalent to vector cleaning is the removal of unnecessary
    detail and file size reduction, which can be done by resampling the size and frequency
    of the grid cells. Such resampling involves algorithms for smoothing out and redistributing
    the old cell values to the new cell structure. A lot of the same principles apply
    to resizing an image. Fortunately for us, our raster data values are stored in
    a PIL `Image` class, so we simply use its `resize` method with the nearest neighbor
    algorithm, which asks for a size in terms of pixels (or number of grid cells in
    our case). For the convenience of the user, we also give them the alternative
    to, instead specify the desired geographic width and height of each cell (for
    instance, degrees or meters, depending on the data's coordinate reference system),
    with our program calculating the necessary grid resolution behind the scenes.
    If specified, remember that the *y* axis of geographic coordinates tend to run
    in the opposite direction to that of raster coordinates, so `cellheight` must
    be given as a negative number. If the user is curious about the grid dimensions
    or cell size of their existing raster, remember that this can be found in the
    layer properties window we created earlier this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于栅格数据，与矢量清理等效的是移除不必要的细节和减小文件大小，这可以通过重新采样网格单元格的大小和频率来实现。这种重新采样涉及平滑和重新分配旧单元格值到新单元格结构的算法。许多相同的原则也适用于调整图像大小。幸运的是，我们的栅格数据值存储在
    PIL `Image` 类中，所以我们只需使用其 `resize` 方法，并使用最近邻算法，它要求以像素（或在我们的情况下是网格单元格的数量）为单位指定大小。为了方便用户，我们还提供了另一种选择，即指定每个单元格所需的地理宽度或高度（例如，度或米，取决于数据的坐标参考系统），我们的程序会在幕后计算必要的网格分辨率。如果指定了，请记住，地理坐标的
    *y* 轴通常与栅格坐标的方向相反，因此 `cellheight` 必须以负数给出。如果用户对现有栅格的网格尺寸或单元格大小感兴趣，请记住，这可以在我们本章早期创建的图层属性窗口中找到。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative library for raster resampling here will be PyResample. I chose
    not to use it in our lightweight application due to its NumPy and SciPy dependence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个用于栅格重新采样的替代库将是 PyResample。我选择不在我们的轻量级应用程序中使用它，因为它依赖于 NumPy 和 SciPy。
- en: Other useful libraries for raster management functionality that you may wish
    to explore are GDAL as mentioned earlier or Rasterio which depends on GDAL.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 其他用于探索栅格管理功能的实用库包括前面提到的GDAL或依赖于GDAL的Rasterio。
- en: 'Take a look at the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Weaving functionality into the user interface
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将功能编织到用户界面中
- en: Now, we get to the part where we can make the management functionality created
    earlier accessible to the user in the visual user interface.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到可以让我们将之前创建的管理功能在可视化用户界面中提供给用户的部分。
- en: Layer-specific right-click functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层特定右键功能
- en: Some of the functionality we created in this chapter is intrinsically bound
    to only one layer, so it makes sense to make these available directly by right-clicking
    on the desired layer to operate on. Such a feature is only specific to the application
    we are currently making, so let's define this right-click menu in the `app/dialogues.py`
    module. Since Tkinter already has such a nicely formatted popup menu widget, with
    easy methods for adding items and commands, all we need to do is subclass it.
    Vector and raster layers will each get their own menu, but both will have in common
    items called as **Rename**, **Save as**, and **Properties**. To give them better
    visuals, find the three `.png` images with the same names as each of these items
    so we can assign them to the menu items, saving them inside the `app/icons` folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的一些功能本质上是绑定到单一层的，因此通过在所需层上右键单击直接操作这些功能是有意义的。这种功能仅针对我们当前正在制作的应用程序，所以让我们在`app/dialogues.py`模块中定义这个右键菜单。由于Tkinter已经有一个格式良好的弹出菜单小部件，并且提供了添加项目和命令的简单方法，我们只需要继承它。矢量层和栅格层将各自获得自己的菜单，但它们都将有共同的**重命名**、**另存为**和**属性**项目。为了使它们具有更好的视觉效果，找到与每个项目同名且为`.png`格式的三个图像，以便我们可以将它们分配给菜单项，并将它们保存在`app/icons`文件夹中。
- en: 'First, we make the options menu for vector layers. We give it the `split` and
    `clean` functions we created earlier, and assign them icons, which you must find
    and save as `app/icons/split.png` and `app/icons/clean.png`. Refer to the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为矢量层创建选项菜单。我们给它我们之前创建的`split`和`clean`函数，并分配图标，你必须找到并保存为`app/icons/split.png`和`app/icons/clean.png`。参看以下截图：
- en: '![Layer-specific right-click functions](img/5407OS_05_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![层特定右键功能](img/5407OS_05_05.jpg)'
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then move onto the options menu for rasters layers. The only layer-specific
    function here is `resample()`, so find and save an icon for it as `app/icons/resample.png`.
    You can see an icon named **Resample** in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向栅格层选项菜单。这里唯一的层特定功能是`resample()`，所以找到并保存一个图标作为`app/icons/resample.png`。你可以在以下截图看到一个名为**Resample**的图标：
- en: '![Layer-specific right-click functions](img/5407OS_05_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![层特定右键功能](img/5407OS_05_06.jpg)'
- en: 'Refer to the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Defining the tool options windows
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义工具选项窗口
- en: 'In the preceding code, clicking on an item in the menu opens an options window
    for a specific tool. We will now create these options windows in `app/dialogues.py`,
    utilizing our helpful `RunToolFrame` template to populate the window with appropriate
    options and widgets. Since these are layer-specific tools, we also remember to
    set the layer data as a hidden argument. Finally, the results from the processes
    are added to our LayersPane. The following screenshot shows the options window
    for vector cleaning:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，点击菜单中的项目将打开特定工具的选项窗口。我们现在将在`app/dialogues.py`中创建这些选项窗口，利用我们有用的`RunToolFrame`模板用适当的选项和小部件填充窗口。由于这些是层特定工具，我们也记得将层数据作为一个隐藏参数设置。最后，将处理结果添加到我们的LayersPane中。以下截图显示了矢量清理的选项窗口：
- en: '![Defining the tool options windows](img/5407OS_05_07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具选项窗口](img/5407OS_05_07.jpg)'
- en: 'Here is the code to implement the mentioned functionality:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现所提及功能的代码：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot demonstrates the options window for vector splitting
    populated with a list of field to choose from:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了填充了可供选择的字段列表的矢量分割选项窗口：
- en: '![Defining the tool options windows](img/5407OS_05_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具选项窗口](img/5407OS_05_08.jpg)'
- en: 'Here is the code to implement the mentioned functionality:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现所提及功能的代码：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following screenshot of the raster resampling window a user
    can manually enter input for height and width of raster and cell data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示的栅格重采样窗口中，用户可以手动输入栅格的高度和宽度以及单元格数据：
- en: '![Defining the tool options windows](img/5407OS_05_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具选项窗口](img/5407OS_05_09.jpg)'
- en: 'Here is the code for same:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同功能的代码：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we need to instruct our application that right-clicking on a layer
    should open the appropriate menu. We define this in the initialization phase of
    the class defining our GUI in our `app/builder.py` module, after creating the
    LayersPane:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要指示我们的应用程序，在图层上右键单击应打开适当的菜单。我们在`app/builder.py`模块中定义GUI类的初始化阶段中定义了这个，在创建LayersPane之后：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Setting up the management tab
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置管理标签
- en: In contrast to the right-click menu of individual layers, the top ribbon tabs
    should be reserved for more general functionalities that takes multiple layers
    as input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与单个图层的右键菜单相比，顶部的标签栏应该保留用于更通用的功能，这些功能需要多个图层作为输入。
- en: 'All of our data management-related functionality goes in a separate tab called
    **Manage**, to which we attach a vector and a raster toolbar, each populated with
    one or more buttons that open an options window for running related functionalities.
    Therefore, we add the following to `app/builder.py` in our GUI class after having
    created the ribbon and the visualize tab, as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的数据管理相关功能都放在一个名为**管理**的单独标签中，我们将矢量工具栏和栅格工具栏附加到该标签上，每个工具栏都包含一个或多个按钮，这些按钮打开一个选项窗口以运行相关功能。因此，我们在创建标签栏和可视化标签后，在GUI类中的`app/builder.py`中添加了以下内容，如下面的截图所示：
- en: '![Setting up the management tab](img/5407OS_05_10.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![设置管理标签](img/5407OS_05_10.jpg)'
- en: 'Here is the code to set up the **Manage** tab:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设置**管理**标签的代码：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining the tool options windows
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义工具选项窗口
- en: 'We define the various tool-specific options windows in `app/dialogues.py`,
    as we did earlier in text. First for the vector merge tool window, as seen in
    the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`app/dialogues.py`中定义了各种工具特定的选项窗口，就像我们在文本中之前所做的那样。首先是为矢量合并工具窗口，如下面的截图所示：
- en: '![Defining the tool options windows](img/5407OS_05_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具选项窗口](img/5407OS_05_11.jpg)'
- en: 'Here is the code for same:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的代码：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The options window for the raster mosaicking tool looks as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 栅格镶嵌工具的选项窗口如下所示：
- en: '![Defining the tool options windows](img/5407OS_05_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![定义工具选项窗口](img/5407OS_05_12.jpg)'
- en: 'Here is the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we created functionalities related to managing and organizing
    files. This included a window to inspect the basic properties of any data layer.
    As for operations, we implemented splitting, merging, and geometry cleaning for
    vector data, and mosaicking and resampling for raster data. These functions were
    then made available in the application GUI, some by choosing from a pop-up menu
    when right-clicking on a layer, others by clicking on an icon button in the management
    tab up by the top ribbon. Each tool got its own window dialogue class with editable
    options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了与管理和组织文件相关的功能。这包括一个窗口来检查任何数据层的基本属性。至于操作，我们实现了矢量数据的分割、合并和几何清理，以及栅格数据的镶嵌和重采样。然后，这些功能在应用程序GUI中可用，一些是通过在图层上右键单击时从弹出菜单中选择，另一些是通过在顶部的标签栏上的管理标签中单击图标按钮。每个工具都有自己的窗口对话框类，具有可编辑的选项。
- en: By going through this chapter, you should now know the general steps involved
    in adding a geospatial functionality, making it accessible in the GUI, and adding
    the results as a new layer if desired. As we move on to the next chapter, where
    we will build some basic analysis functionality, all we need to do is repeat and
    follow the same steps and procedures.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，你现在应该知道添加地理空间功能的一般步骤，使其在GUI中可用，并在需要时将其作为新图层添加。当我们进入下一章，我们将构建一些基本分析功能时，我们只需要重复并遵循相同的步骤和程序。
