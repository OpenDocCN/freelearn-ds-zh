- en: Chapter 5. Managing and Organizing Geographic Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an up-and-running explorative application, we can move on
    to developing some more day-to-day practical features. A common task for users
    of geographic data is to prepare, clean, restructure, and organize data. In this
    chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a window for inspecting the basic properties of each layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build some convenience functions for commonly needed management tasks, and
    later add them to the user interface. These functions are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on individual layers being available when the user right-clicks on
    each layer in the LayersPane widget (splitting, geometry cleaning, and resampling)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch operations on multiple layers available as buttons in the top ribbon area
    (merging and mosaicking)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign dialogue windows to set the parameters when running each tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the management module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a separate submodule to contain the functionality, one
    for vector, and one for raster. First, create the `vector/manager.py` file and
    start it up with the following imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the file `raster/manager.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To make these manager modules available to their respective `vector` and `raster`
    parent package, add the following import statement to both `vector/__init__.py`
    and `raster/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the most basic way to organize and troubleshoot one's files, one often needs
    to inspect the properties and details of one's data and loaded layers. This information
    is usually available in a separate layer options window. Later in this chapter,
    we will make this window accessible by right-clicking on a layer, and clicking
    on **Properties** under the **Layer-specific right-click functions** subheading.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a template class for this type of window, with support for tabbed
    windows using our ribbon class, and create a convenience method for adding information
    in a nicely formatted way. This is done in the `app/dialogues.py` module. Since
    we have not yet set up the contents of `app/dialogues.py`, we also have to set
    up its imports and styling, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Vector and raster data will typically have very different properties, so we
    make a separate window for each. First, for vector layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting files](img/5407OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for raster layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting files](img/5407OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Organizing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, when working in a GIS application, one first seeks out the data
    files one wishes to use from various organizational websites. Ideally, one stores
    these in some logically organized folder structure on the local computer, and
    from there, one can load the data into the GIS application. In this section, we
    add functionality to help the user manage their files and access and alter basic
    file contents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some great examples of the varied types and sources of GIS data available
    online, see the list at [http://freegisdata.rtwilson.com/](http://freegisdata.rtwilson.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Vector data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vector data is very versatile; its table-like data structure means that it can
    contain data on a wide variety of concepts in a single file, or contain data for
    only a very specific concept. For practical usage, it is easier if each file is
    tailored exactly to the data one needs, since these are represented as layers
    when loaded in the application. There are therefore many cases where the user
    may wish to reorganize the data to better fit their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will implement three specific operations for organizing and maintaining
    vector data: splitting, merging, and cleaning. The following illustration gives
    a preview of the inputs and outputs of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vector data](img/5407OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Splitting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For instance, the user may have a file that groups a diverse set of concepts,
    but is only interested in working with certain types separately. In such cases,
    it will be easier to just split the data for each unique occurrence of a field—known
    as splitting. In terms of data structure, this means slicing the height of the
    table into multiple tables along with their associated geometries. We do this
    conveniently using Python''s built-in `sorted()` and `itertools groupby()` functions.
    A `splitfields` option defines a list of one or more field names to split on so
    that each unique value combination defines a new split. So, head to the `manager.py`
    file for vector data and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Merging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One can also face the opposite scenario, where one wishes to group together
    a series of data files spread across multiple files. This is called a **merge
    operation**. A merge operation stacks the rows from multiple tables into one big
    one, and generally increases the spatial coverage, since it leads to a bigger
    collection of geometries. The output attribute table from this operation also
    expands horizontally to include all of the variables/fields from its input files.
    Finally, remember that the `VectorData` instances can only contain one type of
    geometry (points, lines, or polygons), so trying to merge layers of different
    geometry types will result in an error. We implement it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Geometry cleaning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Geographic data can come from a very wide variety of sources, and this means
    that their levels of integrity can vary greatly. For instance, there are many
    rules that govern what is and is not allowed for each geometry type, but not all
    data producers (including both software and individuals) use the same rules or
    follow them to the same degree. This can be a problem for GIS processing, analysis
    applications, and programming libraries if the data is corrupted or not formatted
    in the way that is expected. Data may also contain unnecessary junk information
    that doesn't add anything useful (depending on the level of detail needed), making
    the file size overly large. Geometry cleaning can therefore be a useful feature
    as a first step when gathering one's data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we make a function that loops the geometries of our features. With
    the help of the Shapely library, we fix "bowtie" errors (polygons only), remove
    repeat points, and exclude any remaining geometries deemed to be invalid according
    to the GeoJSON specification. The tolerance argument can be set to higher than
    zero to reduce file size, but note that this alters the shape of the geometries
    and decreases the level of detail and precision in the output. Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more on polygon bowtie errors, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely](http://stackoverflow.com/questions/20833344/fix-invalid-polygon-python-shapely)'
  prefs: []
  type: TYPE_NORMAL
- en: Raster data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many common raster file management functionalities that you may wish
    to implement. Here, we will only focus on two of them: mosaicking and resampling,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raster data](img/5407OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To implement these functionalities, we will take advantage of the image processing
    functionality from the PIL library. Since we are using an imaging library not
    primarily intended for geospatial data, the following code should be considered
    highly experimental and mostly for demonstration purposes; you may have to troubleshoot
    and improve on these methods on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the main purpose of your application is to process satellite, imagery, and
    raster data, and you don't have time or feel comfortable finding your own solution
    using PIL, you may be better off just adding NumPy, GDAL, and related tools as
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of GDAL''s broad range of functionality for handling raster data,
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pcjericks.github.io/py-gdalogr-cookbook/](https://pcjericks.github.io/py-gdalogr-cookbook/)'
  prefs: []
  type: TYPE_NORMAL
- en: Mosaicking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to how vector data can be merged together, it is also possible to mosaic
    multiple adjacent raster datasets into a single larger raster data. The way we
    implement it here is by creating an `align_rasters()` function, which takes any
    number of rasters, automatically finds the coordinate bounding box that contains
    all, as well as the required pixel dimensions (though we should probably allow
    some user control here), and uses this information to position each raster to
    their respective location in a region that bounds all of our rasters. We add this
    as a function in the `raster/manager.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we now have a way to align and properly position the rasters in space,
    we can easily mosaic them into a new raster by simply creating a new grid with
    dimensions that bound all rasters and pasting each raster into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike a vector merge, where overlapping geometries are kept in their
    original form, raster mosaicking needs a rule for choosing a value when there
    are overlapping cells. In the previous code, we didn't support any customization
    of the overlap rule, but instead just pasted each raster on top of each other
    so that any overlapping cells hold the value of the last raster to be pasted-a
    so-called "last" rule. You may implement other overlap-rules by looking at the
    tools available in the PIL library, such as `average` value with `PIL.Image.blend()`,
    or `min` or `max` with the functions found in the `PIL.ImageOps` submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For raster data, the equivalent to vector cleaning is the removal of unnecessary
    detail and file size reduction, which can be done by resampling the size and frequency
    of the grid cells. Such resampling involves algorithms for smoothing out and redistributing
    the old cell values to the new cell structure. A lot of the same principles apply
    to resizing an image. Fortunately for us, our raster data values are stored in
    a PIL `Image` class, so we simply use its `resize` method with the nearest neighbor
    algorithm, which asks for a size in terms of pixels (or number of grid cells in
    our case). For the convenience of the user, we also give them the alternative
    to, instead specify the desired geographic width and height of each cell (for
    instance, degrees or meters, depending on the data's coordinate reference system),
    with our program calculating the necessary grid resolution behind the scenes.
    If specified, remember that the *y* axis of geographic coordinates tend to run
    in the opposite direction to that of raster coordinates, so `cellheight` must
    be given as a negative number. If the user is curious about the grid dimensions
    or cell size of their existing raster, remember that this can be found in the
    layer properties window we created earlier this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative library for raster resampling here will be PyResample. I chose
    not to use it in our lightweight application due to its NumPy and SciPy dependence.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful libraries for raster management functionality that you may wish
    to explore are GDAL as mentioned earlier or Rasterio which depends on GDAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Weaving functionality into the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we get to the part where we can make the management functionality created
    earlier accessible to the user in the visual user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Layer-specific right-click functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the functionality we created in this chapter is intrinsically bound
    to only one layer, so it makes sense to make these available directly by right-clicking
    on the desired layer to operate on. Such a feature is only specific to the application
    we are currently making, so let's define this right-click menu in the `app/dialogues.py`
    module. Since Tkinter already has such a nicely formatted popup menu widget, with
    easy methods for adding items and commands, all we need to do is subclass it.
    Vector and raster layers will each get their own menu, but both will have in common
    items called as **Rename**, **Save as**, and **Properties**. To give them better
    visuals, find the three `.png` images with the same names as each of these items
    so we can assign them to the menu items, saving them inside the `app/icons` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the options menu for vector layers. We give it the `split` and
    `clean` functions we created earlier, and assign them icons, which you must find
    and save as `app/icons/split.png` and `app/icons/clean.png`. Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layer-specific right-click functions](img/5407OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We then move onto the options menu for rasters layers. The only layer-specific
    function here is `resample()`, so find and save an icon for it as `app/icons/resample.png`.
    You can see an icon named **Resample** in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Layer-specific right-click functions](img/5407OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Defining the tool options windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding code, clicking on an item in the menu opens an options window
    for a specific tool. We will now create these options windows in `app/dialogues.py`,
    utilizing our helpful `RunToolFrame` template to populate the window with appropriate
    options and widgets. Since these are layer-specific tools, we also remember to
    set the layer data as a hidden argument. Finally, the results from the processes
    are added to our LayersPane. The following screenshot shows the options window
    for vector cleaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to implement the mentioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot demonstrates the options window for vector splitting
    populated with a list of field to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to implement the mentioned functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot of the raster resampling window a user
    can manually enter input for height and width of raster and cell data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to instruct our application that right-clicking on a layer
    should open the appropriate menu. We define this in the initialization phase of
    the class defining our GUI in our `app/builder.py` module, after creating the
    LayersPane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the management tab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the right-click menu of individual layers, the top ribbon tabs
    should be reserved for more general functionalities that takes multiple layers
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of our data management-related functionality goes in a separate tab called
    **Manage**, to which we attach a vector and a raster toolbar, each populated with
    one or more buttons that open an options window for running related functionalities.
    Therefore, we add the following to `app/builder.py` in our GUI class after having
    created the ribbon and the visualize tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the management tab](img/5407OS_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to set up the **Manage** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining the tool options windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We define the various tool-specific options windows in `app/dialogues.py`,
    as we did earlier in text. First for the vector merge tool window, as seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The options window for the raster mosaicking tool looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the tool options windows](img/5407OS_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created functionalities related to managing and organizing
    files. This included a window to inspect the basic properties of any data layer.
    As for operations, we implemented splitting, merging, and geometry cleaning for
    vector data, and mosaicking and resampling for raster data. These functions were
    then made available in the application GUI, some by choosing from a pop-up menu
    when right-clicking on a layer, others by clicking on an icon button in the management
    tab up by the top ribbon. Each tool got its own window dialogue class with editable
    options.
  prefs: []
  type: TYPE_NORMAL
- en: By going through this chapter, you should now know the general steps involved
    in adding a geospatial functionality, making it accessible in the GUI, and adding
    the results as a new layer if desired. As we move on to the next chapter, where
    we will build some basic analysis functionality, all we need to do is repeat and
    follow the same steps and procedures.
  prefs: []
  type: TYPE_NORMAL
