<html><head></head><body><div><div><h1 id="_idParaDest-66"><a id="_idTextAnchor116"/>Chapter 3: Quantum Circuit Model of Computation<a id="_idTextAnchor117"/></h1>
			<p class="author-quote">"As we scale towards a million [qubits], I think we've got some fundamental issues in error correction, control, and maybe quantum physics that can rear their heads," he said, adding that even those problems are "solvable." </p>
			<p class="author-quote">– Arvind Krishna, IBM chairman and CEO</p>
			<div><div><img src="img/B18268_Figure_3.1.jpg" alt="" width="1650" height="563"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Scaling of the quantum computer [authors]</p>
			<p>There are fundamental differences between classical computing and quantum computing; classical computing <a id="_idIndexMarker222"/>is deterministic with 1s and 0s, and quantum is probabilistic with a twist. Quantum computers <a id="_idIndexMarker223"/>work with probability amplitudes, which is a postulate of quantum mechanics (see <em class="italic">Section 2.2, Postulate 2 – Probability amplitudes</em>). The probabilistic amplitudes of quantum computing<a id="_idIndexMarker224"/> behave differently from classical probabilities in that these values can cancel each other out, which is known<a id="_idIndexMarker225"/> as <strong class="bold">destructive interference</strong>.</p>
			<p>Destructive interference can be<a id="_idIndexMarker226"/> illustrated with noise-canceling headphones. Specifically, it is when two or more waves come together, eliminating the waves altogether. In other words, the waves that come together are opposite in phase and equal in amplitude.  <strong class="bold">Constructive interference</strong> is <a id="_idIndexMarker227"/>when two or more waves come together, and the amplitudes add positively. These two properties are essential to enable the desired result to come out of the computer with the highest probability.</p>
			<p>So, interference<a id="_idIndexMarker228"/> is at the core of what quantum computing should be, and we also use the concept of the wave function as introduced in <em class="italic">Section 2.1,</em> <em class="italic">Postulate 1 – Wave function</em>, and it is used to define the idea of<a id="_idIndexMarker229"/> the <strong class="bold">qubit</strong>: the quantum bit of information. Typically, in the quantum computing industry, <strong class="bold">state vector</strong> is <a id="_idIndexMarker230"/>used as the term for the wave function.</p>
			<p>Another difference between the two methods of computing is that in quantum computing, when we add one more unit of information, the size of the computational space is doubled. In theory, this allows us to speed up exponentially.</p>
			<p>Quantum computing<a id="_idIndexMarker231"/> also uses the superposition property to achieve parallelism up until the moment a measurement is performed. Recall we discussed superposition in <em class="italic">Section 2.3, Postulate 3 – Measurable quantities and operators</em>. A quantum algorithm needs to be repeated multiplied times to get the probability distribution of the measurement.</p>
			<p>The scaling of <a id="_idIndexMarker232"/>quantum computers paves the way for simulating chemical systems that could enable researchers to conduct virtual experiments and discover new molecules much faster than by performing physical experiments in a lab. In parallel to building a scalable quantum computer, research into optimal mappings of fermionic states and operators to qubit states and quantum gates is essential to exploit the potential of near-term quantum computers.</p>
			<p>We give an illustration of a key component of such mappings, a quantum circuit that creates permutation symmetric or permutation asymmetric states in a probabilistic manner.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li><em class="italic">Section 3.1, Qubits, entanglement, Bloch sphere, Pauli matrices</em></li>
				<li><em class="italic">Section 3.2, Quantum gates</em></li>
				<li><em class="italic">Section 3.3, Computation-driven interference</em></li>
				<li><em class="italic">Section 3.4, Preparing a permutation symmetric or asymmetric state</em></li>
			</ul>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor118"/>Technical requirements</h1>
			<p>A companion Jupyter notebook for this chapter can be downloaded from GitHub at <a href="https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious">https://github.com/PacktPublishing/Quantum-Chemistry-and-Computing-for-the-Curious</a>, which has been tested in the Google Colab environment, which is free and runs entirely in the cloud, and in the IBM Quantum Lab environment. Please refer to <a href="B18268_Appendix_B_ePub.xhtml#_idTextAnchor313"><em class="italic">Appendix B</em></a><em class="italic"> – Leveraging Jupyter Notebooks in the Cloud</em>, for more information. The companion Jupyter notebook automatically installs the following list of libraries:</p>
			<ul>
				<li><strong class="bold">Numerical Python</strong> (<strong class="bold">NumPy</strong>) [NumPy], an open-source Python library that is used in almost every field of science and engineering</li>
				<li>Qiskit [Qiskit], an open-source SDK for working with quantum computers at the level of pulses, circuits, and application modules</li>
				<li>Qiskit visualization support to enable visualization and Jupyter notebooks</li>
				<li><strong class="bold">Quantum Toolbox in Python</strong> (<strong class="bold">QuTiP</strong>) [QuTiP], which is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators</li>
			</ul>
			<p>We recommend using the following online graphical tools:</p>
			<ul>
				<li>IBM Quantum Composer, which is a graphical quantum programming tool that lets you drag and drop operations to build quantum circuits and run them on real quantum hardware or simulators [IBM_comp1] [IBM_comp2]</li>
				<li>Grok the Bloch Sphere, a web-based application that displays the Bloch sphere and shows the action of gates as rotations [Grok]</li>
			</ul>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor119"/>Installing NumPy, Qiskit, QuTiP, and importing various modules</h2>
			<p>Install NumPy<a id="_idIndexMarker233"/> with the following command:</p>
			<pre>pip install numpy</pre>
			<p>Install Qiskit<a id="_idIndexMarker234"/> with the following command:</p>
			<pre>pip install qiskit</pre>
			<p>Install Qiskit visualization support<a id="_idIndexMarker235"/> with the following command:</p>
			<pre>pip install 'qiskit[visualization]'</pre>
			<p>Install QuTiP<a id="_idIndexMarker236"/> with the following command:</p>
			<pre>pip install qutip</pre>
			<p>Import NumPy<a id="_idIndexMarker237"/> with the following command:</p>
			<pre>import numpy as np</pre>
			<p>Import the required functions and class methods. The <code>array_to_latex function()</code> returns a LaTeX representation of a complex array with dimension 1 or 2:</p>
			<pre>from qiskit.visualization import array_to_latex, plot_bloch_vector, plot_bloch_multivector, plot_state_qsphere, plot_state_city
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, transpile
from qiskit import execute, Aer
import qiskit.quantum_info as qi
from qiskit.extensions import Initialize
from qiskit.providers.aer import extensions  # import aer snapshot instructions</pre>
			<p>Import the math libraries<a id="_idIndexMarker238"/> with the following commands:</p>
			<pre>import cmath
import math</pre>
			<p>Import QuTiP<a id="_idIndexMarker239"/> with the following command:</p>
			<pre>import qutip</pre>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor120"/>3.1. Qubits, entanglement, Bloch sphere, Pauli matrices</h1>
			<p>The concepts presented in this section are a specific application of the five postulates of quantum mechanics that were presented in <a href="B18268_02_ePub.xhtml#_idTextAnchor077"><em class="italic">Chapter 2</em></a><em class="italic">, Postulates of Quantum Mechanics</em>.  </p>
			<p>In this section, we describe the following in detail:</p>
			<ul>
				<li><em class="italic">Section 3.1.1, Qubits</em></li>
				<li><em class="italic">Section 3.1.2, Tensor ordering of qubits</em></li>
				<li><em class="italic">Section 3.1.3, Quantum entanglement</em></li>
				<li><em class="italic">Section 3.1.4, Bloch sphere</em></li>
				<li><em class="italic">Section 3.1.5, Displaying the Bloch vector corresponding to a state vector</em></li>
				<li><em class="italic">Section 3.1.6, Pauli matrices</em></li>
			</ul>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor121"/>3.1.1. Qubits</h2>
			<p>In this section, we describe the current setup for quantum computation and the definition of a qubit. A qubit<a id="_idIndexMarker240"/> is a unit of information that represents a two-level quantum system and lives in a two-dimensional Hilbert space <img src="img/Formula_03_001.png" alt="" width="43" height="39"/>. The basis vectors of the quantum space are denoted as <img src="img/Formula_03_002.png" alt="" width="149" height="48"/>, which are referred to as the computational basis states:</p>
			<p class="figure-caption"><img src="img/Formula_03_003.png" alt="" width="470" height="92"/></p>
			<p>A general single-qubit state is described by a superposition of the computational basis: </p>
			<p class="figure-caption"><img src="img/Formula_03_004.png" alt="" width="567" height="87"/></p>
			<p>where <img src="img/Formula_03_005.png" alt="" width="26" height="23"/> and <img src="img/Formula_03_006.png" alt="" width="27" height="42"/> are linear expansion coefficients that satisfy:</p>
			<p class="figure-caption"><img src="img/Formula_03_007.png" alt="" width="291" height="49"/></p>
			<p>Although the qubit is in a quantum superposition during the algorithm, when it is measured in the computational basis, it will be found in state <img src="img/Formula_03_008.png" alt="" width="46" height="40"/> or state <img src="img/Formula_03_009.png" alt="" width="46" height="40"/>, not in a superposition. These measurement <a id="_idIndexMarker241"/>outcomes occur with probability <img src="img/Formula_03_010.png" alt="" width="69" height="48"/> and <img src="img/Formula_03_011.png" alt="" width="68" height="48"/> respectively. If there are <img src="img/Formula_03_012.png" alt="" width="26" height="24"/> qubits in the system, the state is described by a vector in the <img src="img/Formula_03_013.png" alt="" width="45" height="34"/> dimensional Hilbert space <img src="img/Formula_03_014.png" alt="" width="133" height="49"/> formed by taking the tensor product of the Hilbert spaces of the individual qubits. For 10 qubits, the state is described by a vector in a 1,024-dimensional Hilbert space. </p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor122"/>3.1.2. Tensor ordering of qubits</h2>
			<p>The physics community<a id="_idIndexMarker242"/> typically orders a tensor product of <img src="img/Formula_03_012.png" alt="" width="26" height="24"/> qubits with the <img src="img/Formula_03_016.png" alt="" width="56" height="39"/> qubit on <a id="_idIndexMarker243"/>the left-most side of the tensor product:</p>
			<p class="figure-caption"><img src="img/Formula_03_017.png" alt="" width="1048" height="104"/></p>
			<p>where <img src="img/Formula_03_018.png" alt="" width="163" height="41"/>. However, Qiskit uses an ordering in which the <img src="img/Formula_03_019.png" alt="" width="62" height="39"/> qubit is first in the order and the <img src="img/Formula_03_020.png" alt="" width="57" height="40"/> qubit is last: </p>
			<p class="figure-caption"><img src="img/Formula_03_021.png" alt="" width="1119" height="104"/></p>
			<p>In other words, if qubit 0 is in state <img src="img/Formula_03_022.png" alt="" width="48" height="43"/>, qubit 1 is in state <img src="img/Formula_03_022.png" alt="" width="48" height="43"/>, and qubit 2 is in state <img src="img/Formula_03_024.png" alt="" width="48" height="43"/> , many physics textbooks would represent this as <img src="img/Formula_03_025.png" alt="" width="97" height="43"/>, whereas Qiskit would represent this state as <img src="img/Formula_03_026.png" alt="" width="98" height="44"/>. This difference affects the way multi-qubit operations are represented as matrices, so please be on the lookout as we are using Qiskit in the book.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor123"/>3.1.3. Quantum entanglement</h2>
			<p>A quantum system <a id="_idIndexMarker244"/>is entangled when its quantum state cannot be factored as a tensor product of states of its constituents. States can be classified as either a product of single particle states or <strong class="bold">entangled</strong>:</p>
			<ul>
				<li>Product states can be decomposed into tensor products of fewer qubits, such as:</li>
			</ul>
			<p class="figure-caption"><img src="img/Formula_03_027.png" alt="" width="747" height="109"/></p>
			<ul>
				<li>Entangled states cannot be decomposed into tensor products of states. For example, the <a id="_idIndexMarker245"/>Bell state <img src="img/Formula_03_028.png" alt="" width="258" height="90"/> is entangled and can only be measured either in the state <img src="img/Formula_03_029.png" alt="" width="73" height="43"/> or in the state <img src="img/Formula_03_030.png" alt="" width="72" height="42"/>, each with a probability of 1/2.</li>
			</ul>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor124"/>3.1.4. Bloch sphere</h2>
			<p>The <a id="_idIndexMarker246"/>Bloch sphere describes a qubit in space and is a specific form of the coordinate system (<em class="italic">Figure 3.2</em>) presented in <em class="italic">Section 2.1, Postulate 1 – Wave functions</em>. The <img src="img/Formula_03_031.png" alt="" width="22" height="23"/> vector, or the length, of a qubit is always equal to 1, so the coordinates of the Bloch sphere are:</p>
			<p><img src="img/Formula_03_032.png" alt="" width="396" height="142"/></p>
			<p>Let's focus on the general normalized pure state for a single qubit, as presented in <em class="italic">Section 3.1.1, Qubits</em>:</p>
			<ul>
				<li>When <img src="img/Formula_03_033.png" alt="" width="106" height="32"/> and <img src="img/Formula_03_034.png" alt="" width="109" height="42"/>, the <img src="img/Formula_03_035.png" alt="" width="48" height="42"/> state is "up" in the <img src="img/Formula_03_036.png" alt="" width="23" height="22"/>-direction.</li>
				<li>When <img src="img/Formula_03_037.png" alt="" width="107" height="33"/> and <img src="img/Formula_03_038.png" alt="" width="109" height="43"/>, the <img src="img/Formula_03_024.png" alt="" width="48" height="43"/> state is "down" in the <img src="img/Formula_02_107.png" alt="" width="22" height="22"/>-direction.</li>
			</ul>
			<div><div><img src="img/B18268_Figure_3.2.jpg" alt="" width="1650" height="634"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Bloch sphere [authors]</p>
			<p>We derived the<a id="_idIndexMarker247"/> generalized formula for a qubit in <em class="italic">Section 2.1.2, Addition of momenta using Clebsch-Gordan coefficients, example: Coupling spin and angular momentum (</em><img src="img/Formula_03_041.png" alt="" width="327" height="104"/><em class="italic">):</em></p>
			<p class="figure-caption"><img src="img/Formula_03_042.png" alt="" width="839" height="103"/></p>
			<p>However, established by the quantum computing industry and set as a convention, we have a change of variables for the angles <img src="img/Formula_03_043.png" alt="" width="23" height="33"/> and <img src="img/Formula_03_044.png" alt="" width="27" height="32"/> for a qubit defined on the Bloch sphere where the following applies:</p>
			<ul>
				<li><img src="img/Formula_03_045.png" alt="" width="302" height="41"/> in <img src="img/Formula_03_046.png" alt="" width="87" height="41"/>, which becomes <img src="img/Formula_03_047.png" alt="" width="252" height="84"/> in <img src="img/Formula_03_048.png" alt="" width="87" height="73"/> (please note that the arccosine of a positive number is a first quadrant angle)</li>
				<li><img src="img/Formula_03_049.png" alt="" width="29" height="33"/> is the relative phase in <img src="img/Formula_03_050.png" alt="" width="119" height="43"/>, neglecting the global phase <img src="img/Formula_03_051.png" alt="" width="390" height="48"/></li>
			</ul>
			<p>This change of variables results in the following form of the state vector (or wave function) for a qubit on the Bloch sphere:</p>
			<p class="figure-caption"><img src="img/Formula_03_052.png" alt="" width="543" height="102"/></p>
			<p>where we have replaced the spin-up and spin-down functions with the state vectors <img src="img/Formula_03_053.png" alt="" width="48" height="42"/> and <img src="img/Formula_03_054.png" alt="" width="48" height="42"/>, respectively. From a chemical perspective, please note that the qubit state <img src="img/Formula_03_055.png" alt="" width="48" height="42"/> indicates the angular momentum quantum numbers <img src="img/Formula_03_056.png" alt="" width="243" height="44"/> with spin-up, and therefore does not have any angular momentum projection on the <img src="img/Formula_02_513.png" alt="" width="22" height="23"/>-axis. Furthermore, the qubit state <img src="img/Formula_03_058.png" alt="" width="48" height="43"/> indicates the angular momentum quantum numbers <img src="img/Formula_03_059.png" alt="" width="241" height="44"/> with spin-down and does have angular momentum projection on the <img src="img/Formula_03_060.png" alt="" width="23" height="22"/>-axis. This is important to remember when we introduce the Pauli matrices in <em class="italic">Section 3.1.6, Pauli matrices</em>, as we will see how the chemical information is modified when we apply operations.</p>
			<p>On the <a id="_idIndexMarker248"/>Bloch sphere, angles are twice as big as in Hilbert space. For instance, <img src="img/Formula_03_055.png" alt="" width="48" height="42"/> and <img src="img/Formula_03_062.png" alt="" width="49" height="43"/> are orthogonal in Hilbert space, and on the Bloch sphere their angle is <img src="img/Formula_03_063.png" alt="" width="28" height="23"/>. Further, we would like to point out that <img src="img/Formula_03_064.png" alt="" width="28" height="87"/> determines the probability to measure the <img src="img/Formula_03_055.png" alt="" width="48" height="42"/> and <img src="img/Formula_03_054.png" alt="" width="48" height="42"/> states with the following:</p>
			<ul>
				<li><img src="img/Formula_03_053.png" alt="" width="48" height="42"/> such that <img src="img/Formula_03_068.png" alt="" width="266" height="98"/></li>
				<li><img src="img/Formula_03_054.png" alt="" width="48" height="42"/> such that <img src="img/Formula_03_070.png" alt="" width="258" height="98"/></li>
			</ul>
			<p>We show the Bloch vector for a qubit in different directions on the Bloch sphere, which we call pole states, as shown in the table shown in Figure 3.3:</p>
			<div><div><img src="img/B18268_03_Table_01.jpg" alt="" width="1534" height="975"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Pole states in the computational basis and their representation on the Bloch sphere</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor125"/>3.1.5. Displaying the Bloch vector corresponding to a state vector</h2>
			<p>In the following <a id="_idIndexMarker249"/>code, the <code>check</code> function performs sanity checks on a given complex vector <img src="img/Formula_03_101.png" alt="" width="103" height="44"/> to ensure it is a state vector:</p>
			<pre>_EPS = 1e-10 # Global variable used to chop small numbers to zero
def check(s):
  num_qubits = math.log2(len(s))
  # Check if param is a power of 2
  if num_qubits == 0 or not num_qubits.is_integer():
      raise Exception("Input complex vector length is not a positive power of 2.")
  num_qubits = int(num_qubits)
  if num_qubits &gt; 1:
      raise Exception("Only one complex vector is allowed as input.")
  # Check if probabilities (amplitudes squared) sum to 1
  if not math.isclose(sum(np.absolute(s) ** 2), 1.0, abs_tol=_EPS):
      raise Exception("Norm of complex vector does not equal one.")
  return</pre>
			<p>Next, the <code>ToBloch()</code> function <a id="_idIndexMarker250"/>computes the Bloch vector of a given state vector (complex vector) and displays the angles in LaTeX format and the vector on the Bloch sphere. It has two input parameters:</p>
			<ul>
				<li><code>s</code>: A state vector, a complex vector <img src="img/Formula_03_102.png" alt="" width="104" height="45"/>.</li>
				<li><code>show</code>: Set to <code>True</code> to display the angles and the vector on the Bloch sphere.</li>
			</ul>
			<p>It has three output parameters:</p>
			<ul>
				<li><code>theta</code>: <img src="img/Formula_03_103.png" alt="" width="325" height="44"/> in <img src="img/Formula_03_104.png" alt="" width="91" height="43"/> is the angle on the Bloch sphere.</li>
				<li><code>phi</code>: <img src="img/Formula_03_105.png" alt="" width="388" height="47"/> in <img src="img/Formula_03_106.png" alt="" width="116" height="43"/> is the relative phase, neglecting the global phase.</li>
				<li><code>r</code>: This is the vector on the Bloch sphere.</li>
			</ul>
			<pre>def ToBloch(s, show=True):
  check(s)
  phi = cmath.phase(s[1]) - cmath.phase(s[0])
  theta = 2*math.acos(abs(s[0]))
  r1 = math.sin(theta)*math.cos(phi)
  r2 = math.sin(theta)*math.sin(phi)
  r3 = math.cos(theta)
  r = (r1,r2,r3)
  if show:
    display(array_to_latex(s, prefix="\\text{s} = ", precision = 2))
    display(array_to_latex([theta, phi], prefix="\\text{theta, phi} = ", precision = 2))
    display(array_to_latex(r, prefix="\\text{r} = ", precision = 2))
    b = qutip.Bloch()
    b.add_vectors(r)
    display(b.render())
  return theta, phi, r</pre>
			<p>The following <a id="_idIndexMarker251"/>code displays the Bloch vector corresponding to the state vector <img src="img/Formula_03_107.png" alt="" width="368" height="108"/>:</p>
			<pre>s = [1/math.sqrt(2),complex(0.5, 0.5)]
(theta, phi, r) = ToBloch(s)</pre>
			<p>Here is the result with the Bloch sphere displayed using the <code>QuTiP Bloch()</code> function:</p>
			<div><div><img src="img/B18268_Figure_3.4.jpg" alt="" width="1015" height="322"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Displaying a vector on the Bloch sphere</p>
			<p>Finally, the <code>ToS</code> function <a id="_idIndexMarker252"/>computes a state vector of a Bloch vector. It has three input parameters:</p>
			<ul>
				<li><code>theta</code>: <img src="img/Formula_03_108.png" alt="" width="324" height="45"/> in <img src="img/Formula_03_109.png" alt="" width="91" height="43"/> is the angle on the Bloch sphere.</li>
				<li><code>phi</code>: <img src="img/Formula_03_051.png" alt="" width="390" height="48"/> in <img src="img/Formula_03_106.png" alt="" width="116" height="43"/> is the relative phase, neglecting the global phase.</li>
				<li><code>show</code>: This is set to <code>True</code> to display the input angles and the state vector.</li>
			</ul>
			<p>It has one output parameter:</p>
			<ul>
				<li><code>s</code>: a state vector, a complex vector <img src="img/Formula_03_112.png" alt="" width="318" height="101"/></li>
			</ul>
			<pre>def ToS(theta, phi, show=True):
  s = [math.cos(theta/2), complex(math.cos(phi) * math.sin(theta/2), math.sin(phi) * math.sin(theta/2))]
  if show:
    display(array_to_latex([theta, phi], prefix="\\text{theta, phi} = ", precision = 2))
    display(array_to_latex(s, prefix="\\text{s} = ", precision = 1))
  return s</pre>
			<p>Here, we compute the complex amplitudes of a Bloch vector with <img src="img/Formula_03_113.png" alt="" width="153" height="44"/> and <img src="img/Formula_03_114.png" alt="" width="162" height="44"/> :</p>
			<pre>s = ToS(np.pi/2, np.pi/4)</pre>
			<p>Here is the<a id="_idIndexMarker253"/> result:</p>
			<p class="figure-caption"><img src="img/Formula_03_115.png" alt="" width="451" height="47"/></p>
			<div><div><img src="img/Formula_03_116.jpg" alt="" width="360" height="103"/>
				</div>
			</div>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor126"/>3.1.6. Pauli matrices</h2>
			<p>There are three <a id="_idIndexMarker254"/>Pauli mat<a id="_idTextAnchor127"/><a id="_idTextAnchor128"/>rices, <img src="img/Formula_03_117.png" alt="" width="41" height="32"/> , <img src="img/Formula_03_118.png" alt="" width="42" height="39"/>, and <img src="img/Formula_03_119.png" alt="" width="38" height="32"/>:</p>
			<p class="figure-caption"><img src="img/Formula_03_120.png" alt="" width="227" height="83"/>, <img src="img/Formula_03_121.png" alt="" width="250" height="83"/>, <img src="img/Formula_03_122.png" alt="" width="258" height="84"/></p>
			<p>which are Hermitian and unitary, making the square of each equal to the <img src="img/Formula_03_123.png" alt="" width="119" height="40"/> identity matrix:</p>
			<p class="figure-caption"><img src="img/Formula_03_124.png" alt="" width="514" height="86"/></p>
			<p>Each of the Pauli matrices is equal to its inverse:</p>
			<p class="figure-caption"><img src="img/Formula_03_125.png" alt="" width="169" height="49"/></p>
			<p class="figure-caption"><img src="img/Formula_03_126.png" alt="" width="170" height="54"/></p>
			<p class="figure-caption"><img src="img/Formula_03_127.png" alt="" width="172" height="54"/></p>
			<p>We summarize the Pauli matrices and the operations on a qubit that yields the associated eigenvectors in <em class="italic">Figure 3.5</em>:</p>
			<div><div><img src="img/B18268_03_Table_02.jpg" alt="" width="939" height="731"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Pauli matrices and the associated eigenvectors</p>
			<p>In <em class="italic">Figure 3.6</em>, we display on the far-left side the <img src="img/Formula_03_140.png" alt="" width="48" height="43"/> qubit state, which has zero angular momentum projection <a id="_idIndexMarker255"/>on the <img src="img/Formula_02_107.png" alt="" width="22" height="22"/>-axis, as indicated by the dark circle under the Bloch sphere. In the middle, we display the <img src="img/Formula_03_142.png" alt="" width="49" height="42"/> qubit state, which has an angular momentum projection on the <img src="img/Formula_03_143.png" alt="" width="22" height="23"/>-axis indicated by a light grey circle under the Bloch sphere. Recall we discussed the angular momentum projection for the <img src="img/Formula_03_144.png" alt="" width="49" height="42"/> and <img src="img/Formula_03_145.png" alt="" width="48" height="43"/> qubit states in <em class="italic">Section 3.1.4, Bloch sphere</em>. On the far-right side, we indicate the <img src="img/Formula_03_146.png" alt="" width="39" height="33"/> operation on the <img src="img/Formula_03_147.png" alt="" width="48" height="42"/> qubit state, which modifies the angular momentum projection by <img src="img/Formula_03_148.png" alt="" width="26" height="22"/>.</p>
			<div><div><img src="img/B18268_Figure_3.6.jpg" alt="" width="1436" height="498"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Pauli Z operation on basis states <img src="img/Formula_03_144.png" alt="" width="49" height="42"/> and <img src="img/Formula_03_1451.png" alt="" width="49" height="42"/> illustrated with Grok the Bloch sphere</p>
			<p>The <img src="img/Formula_03_151.png" alt="" width="40" height="32"/> operation <a id="_idIndexMarker256"/>does not have an effect on the angular momentum projection, while the <img src="img/Formula_03_152.png" alt="" width="41" height="38"/> operation modifies the angular momentum projection by <img src="img/Formula_03_153.png" alt="" width="64" height="55"/>.</p>
			<h3>Measurement in the sign basis <img src="img/Formula_03_154.png" alt="" width="176" height="47"/></h3>
			<p>Let us<a id="_idIndexMarker257"/> measure a state <img src="img/Formula_03_155.png" alt="" width="330" height="48"/> in the sign basis <img src="img/Formula_03_156.png" alt="" width="175" height="45"/> which is also known as a measurement according to the Pauli matrix <img src="img/Formula_03_157.png" alt="" width="41" height="32"/>. To make this measurement, we perform a change of basis from the sign basis <img src="img/Formula_03_158.png" alt="" width="175" height="46"/> to the standard basis <img src="img/Formula_03_159.png" alt="" width="157" height="46"/> where:</p>
			<div><div><img src="img/Formula_03_160.jpg" alt="" width="378" height="105"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_161.jpg" alt="" width="378" height="108"/>
				</div>
			</div>
			<p>which allows us to rewrite the state:</p>
			<p class="figure-caption"><img src="img/Formula_03_162.png" alt="" width="532" height="109"/></p>
			<p>The possible outcomes of a measurement with their corresponding probabilities and new state are listed in <em class="italic">Figure 3.7</em>:</p>
			<div><div><img src="img/B18268_03_Table_03.jpg" alt="" width="1117" height="361"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Measurement in the sign basis <img src="img/Formula_03_168.png" alt="" width="147" height="39"/></p>
			<p>The expectation <a id="_idIndexMarker258"/>value of the measurement of a state <img src="img/Formula_03_169.png" alt="" width="56" height="45"/> according to the Pauli <img src="img/Formula_03_170.png" alt="" width="41" height="31"/> operation is:</p>
			<p class="figure-caption"><img src="img/Formula_03_171.png" alt="" width="333" height="54"/></p>
			<p>which means we need to calculate the bra in the sign basis by taking the complex conjugate transpose:</p>
			<p class="figure-caption"><img src="img/Formula_03_172.png" alt="" width="798" height="112"/></p>
			<p>We also need to transform the Pauli operation from the standard basis to the sign basis:</p>
			<p class="figure-caption"><img src="img/Formula_03_173.png" alt="" width="762" height="91"/></p>
			<p>Recall that a ket times a bra, as seen previously (<img src="img/Formula_03_174.png" alt="" width="116" height="43"/> and <img src="img/Formula_03_175.png" alt="" width="117" height="44"/>), is an outer product that yields a matrix, whereas a bra times a ket is a scalar. With this, we have the expectation value calculated as:</p>
			<div><div><img src="img/Formula_03_176.jpg" alt="" width="1080" height="105"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_177.jpg" alt="" width="717" height="98"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_178.jpg" alt="" width="585" height="99"/>
				</div>
			</div>
			<p>Please remember that in general, <img src="img/Formula_03_005.png" alt="" width="26" height="23"/> and <img src="img/Formula_03_006.png" alt="" width="27" height="42"/> are complex numbers, and the imaginary part can be zero. The expectation value is the sum of all the possible outcomes (1 and -1) of a measurement of a state <img src="img/Formula_03_181.png" alt="" width="55" height="44"/> in the sign basis weighted by their pr<a id="_idTextAnchor129"/>obabilities.</p>
			<h3>Decomposing a matrix <a id="_idTextAnchor130"/>into the weighted sum of the tensor product of Pauli matrices</h3>
			<p>It can be<a id="_idIndexMarker259"/> shown that any matrix can be decomposed into the weighted sum of the tensor product of the identity matrix and the Pauli matrices <img src="img/Formula_03_182.png" alt="" width="228" height="58"/>, where <img src="img/Formula_03_183.png" alt="" width="345" height="60"/> with weights <img src="img/Formula_03_184.png" alt="" width="35" height="41"/> and <img src="img/Formula_03_185.png" alt="" width="32" height="31"/> qubits:</p>
			<div><div><img src="img/Formula_03_186.jpg" alt="" width="345" height="145"/>
				</div>
			</div>
			<p>For Hermitian matrices, all weights <img src="img/Formula_03_187.png" alt="" width="34" height="42"/> are real.</p>
			<p>We provide a proof for any 2x2 matrix, <img src="img/Formula_03_188.png" alt="" width="342" height="93"/>:</p>
			<div><div><img src="img/Formula_03_189.jpg" alt="" width="804" height="88"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_190.jpg" alt="" width="840" height="89"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_191.jpg" alt="" width="945" height="113"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_192.jpg" alt="" width="945" height="111"/>
				</div>
			</div>
			<p>Since <img src="img/Formula_03_193.png" alt="" width="207" height="45"/>, hence <img src="img/Formula_03_194.png" alt="" width="207" height="46"/>, we have:</p>
			<div><div><img src="img/Formula_03_195.jpg" alt="" width="771" height="100"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_196.jpg" alt="" width="753" height="99"/>
				</div>
			</div>
			<p>Starting from the decomposition of a 2x2 matrix as a sum of outer products:</p>
			<p class="figure-caption"><img src="img/Formula_03_197.png" alt="" width="1356" height="94"/></p>
			<p>we can then write:</p>
			<p class="figure-caption"><img src="img/Formula_03_198.png" alt="" width="1162" height="101"/></p>
			<div><div><img src="img/Formula_03_199.jpg" alt="" width="1311" height="99"/>
				</div>
			</div>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor131"/>3.2. Quantum gates</h1>
			<p>Quantum gates <a id="_idIndexMarker260"/>are unitary operators (<img src="img/Formula_03_200.png" alt="" width="299" height="42"/>) working on one, two, or three qubits. The norm is preserved when applied to a quantum state. The action of a quantum gate on a quantum state corresponds to the multiplication of the matrix representing the gate by the vector representing the quantum state: <img src="img/Formula_03_201.png" alt="" width="83" height="45"/>.</p>
			<p>In this section, a tensor product of <img src="img/Formula_03_202.png" alt="" width="26" height="23"/> qubits is represented with the first qubit on the left-most side of the tensor product: <img src="img/Formula_03_203.png" alt="" width="985" height="99"/> where <img src="img/Formula_03_204.png" alt="" width="176" height="45"/>. Please note that we are not using the Qiskit tensor ordering of qubits unless specifically specified. </p>
			<p>In this section, we cover the following:</p>
			<ul>
				<li><em class="italic">Section 3.2.1, Single-qubit quantum gates</em></li>
				<li><em class="italic">Section 3.2.2, Two-qubit quantum gates</em></li>
				<li><em class="italic">Section 3.2.3, Three-qubit quantum gates</em></li>
				<li><em class="italic">Section 3.2.4, Serial wired gates and parallel quantum gates</em></li>
				<li><em class="italic">Section 3.2.5, Creation of a Bell state</em></li>
				<li><em class="italic">Section 3.2.6, Parallel Hadamard gates</em></li>
			</ul>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor132"/>3.2.1. Single-qubit quantum gates</h2>
			<p>A single-qubit gate <img src="img/Formula_03_205.png" alt="" width="29" height="31"/> has a <img src="img/Formula_03_206.png" alt="" width="132" height="45"/> unitary matrix <a id="_idIndexMarker261"/>form: <img src="img/Formula_03_207.png" alt="" width="300" height="42"/>.</p>
			<p>In this section, we describe in detail the following:</p>
			<ul>
				<li><img src="img/Formula_03_208.png" alt="" width="31" height="31"/> gate</li>
				<li>Hadamard (<img src="img/Formula_03_209.png" alt="" width="33" height="31"/>) gate</li>
				<li>Generalized single-qubit quantum gate</li>
			</ul>
			<p>We summarize<a id="_idIndexMarker262"/> commonly used quantum gates as well as provide<a id="_idIndexMarker263"/> some useful relationships.</p>
			<h3><img src="img/Formula_03_210.png" alt="" width="33" height="31"/> gate</h3>
			<p>An <img src="img/Formula_03_208.png" alt="" width="31" height="31"/> gate maps <img src="img/Formula_03_140.png" alt="" width="48" height="43"/> to <img src="img/Formula_03_213.png" alt="" width="48" height="43"/> and <img src="img/Formula_03_214.png" alt="" width="49" height="42"/> to <img src="img/Formula_03_053.png" alt="" width="48" height="42"/>. It is the quantum equivalent of the NOT gate for classical <a id="_idIndexMarker264"/>computers and is sometimes called a bit-flip. For<a id="_idIndexMarker265"/> classical computing, the NOT gate changes a 0 to a 1 and a 1 to a 0. The <img src="img/Formula_03_216.png" alt="" width="32" height="32"/> gate equates to a rotation by π radians around the X-axis of the Bloch sphere.</p>
			<p class="figure-caption"><img src="img/Formula_03_217.png" alt="" width="224" height="86"/></p>
			<h3>Hadamard (<img src="img/Formula_03_218.png" alt="" width="35" height="32"/>) gate</h3>
			<p>A Hadamard gate<a id="_idIndexMarker266"/> maps the basis state <img src="img/Formula_03_219.png" alt="" width="49" height="43"/> to <img src="img/Formula_03_220.png" alt="" width="242" height="102"/>, which is also <a id="_idIndexMarker267"/>written as <img src="img/Formula_03_221.png" alt="" width="57" height="42"/>, and <img src="img/Formula_03_222.png" alt="" width="50" height="43"/> to <img src="img/Formula_03_223.png" alt="" width="226" height="94"/>, which is also written as <img src="img/Formula_03_224.png" alt="" width="57" height="42"/>. It represents a rotation of π about the axis that is in the middle (45<img src="img/Formula_03_225.png" alt="" width="15" height="35"/> angle) of the <img src="img/Formula_03_226.png" alt="" width="25" height="23"/>- and <img src="img/Formula_03_227.png" alt="" width="23" height="23"/>-axis. A measurement of the state <img src="img/Formula_03_228.png" alt="" width="57" height="43"/> or of the state <img src="img/Formula_03_229.png" alt="" width="57" height="43"/> will have equal probabilities of being 0 or 1, creating a superposition of states.</p>
			<p class="figure-caption"><img src="img/Formula_03_230.png" alt="" width="318" height="109"/></p>
			<p>It is convenient to write the Hadamard gate applied to the 0th qubit (<img src="img/Formula_03_231.png" alt="" width="40" height="34"/>) in the register as follows: <img src="img/Formula_03_232.png" alt="" width="493" height="98"/> where <img src="img/Formula_03_233.png" alt="" width="191" height="46"/>. Please note that the Hadamard gate (<img src="img/Formula_03_209.png" alt="" width="33" height="31"/>) has similar notation to the Hamiltonian operator (<img src="img/Formula_03_235.png" alt="" width="50" height="51"/>; the difference is the hat (<img src="img/Formula_03_236.png" alt="" width="32" height="50"/>) symbol.</p>
			<h3>General single-qubit quantum gate</h3>
			<p>All <a id="_idIndexMarker268"/>single-qubit gates can be obtained from the following <a id="_idIndexMarker269"/>matrix <img src="img/Formula_03_237.png" alt="" width="172" height="46"/>, which describes all unitary matrices up to a global phase factor by an appropriate choice of parameters <img src="img/Formula_03_238.png" alt="" width="111" height="43"/> with <img src="img/Formula_03_239.png" alt="" width="172" height="44"/> , <img src="img/Formula_03_240.png" alt="" width="202" height="46"/> , <img src="img/Formula_03_241.png" alt="" width="194" height="46"/> [Qiskit_Op]:</p>
			<div><div><img src="img/Formula_03_242.jpg" alt="" width="699" height="200"/>
				</div>
			</div>
			<p>The gate <img src="img/Formula_03_243.png" alt="" width="194" height="88"/> has the matrix form:</p>
			<div><div><img src="img/Formula_03_244.jpg" alt="" width="585" height="109"/>
				</div>
			</div>
			<p>The gate <img src="img/Formula_03_245.png" alt="" width="281" height="44"/> and has the matrix form:</p>
			<p class="figure-caption"><img src="img/Formula_03_246.png" alt="" width="283" height="82"/></p>
			<h3>Summary of single-qubit quantum gates and useful relationships</h3>
			<p><em class="italic">Figure 3.8</em> presents <a id="_idIndexMarker270"/>the main list of single-qubit quantum<a id="_idIndexMarker271"/> gates:</p>
			<div><div><img src="img/B18268_03_Table_04.jpg" alt="" width="1405" height="991"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Single-qubit quantum gates</p>
			<p>The rotation operator gates <img src="img/Formula_03_312.png" alt="" width="57" height="31"/>, <img src="img/Formula_03_313.png" alt="" width="55" height="32"/>, and <img src="img/Formula_03_314.png" alt="" width="54" height="31"/> perform rotations about the <img src="img/Formula_03_315.png" alt="" width="30" height="31"/>, <img src="img/Formula_03_316.png" alt="" width="26" height="31"/>, and <img src="img/Formula_03_317.png" alt="" width="27" height="31"/> axes respectively of the Bloch sphere:</p>
			<div><div><img src="img/Formula_03_318.jpg" alt="" width="786" height="185"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_319.jpg" alt="" width="723" height="187"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_320.jpg" alt="" width="654" height="134"/>
				</div>
			</div>
			<p>We would like to point out that the <img src="img/Formula_03_321.png" alt="" width="31" height="30"/> gate can be obtained by using a combination of the Hadamard gate and the <img src="img/Formula_03_322.png" alt="" width="27" height="31"/> gate: <img src="img/Formula_03_323.png" alt="" width="178" height="32"/>. The converse is also true: <img src="img/Formula_03_324.png" alt="" width="178" height="32"/>. It means we can project a state onto the <img src="img/Formula_03_315.png" alt="" width="30" height="31"/>-axis of the Bloch sphere when applying a <img src="img/Formula_03_326.png" alt="" width="31" height="31"/> gate before measuring. Same with the <img src="img/Formula_03_316.png" alt="" width="26" height="31"/>-axis when applying first an <img src="img/Formula_03_328.png" alt="" width="45" height="41"/> gate, then an <img src="img/Formula_03_326.png" alt="" width="31" height="31"/> gate. This way we can <a id="_idIndexMarker272"/>perform qubit tomography (that is, reconstructing the Bloch vector through <img src="img/Formula_03_330.png" alt="" width="31" height="31"/>, <img src="img/Formula_03_316.png" alt="" width="26" height="31"/>, and <img src="img/Formula_03_332.png" alt="" width="28" height="32"/> measurements). These<a id="_idIndexMarker273"/> gate operations are summarized in <em class="italic">Figure 3.9</em>:</p>
			<div><div><img src="img/B18268_Figure_3.9.jpg" alt="" width="223" height="186"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Relations <img src="img/Formula_03_333.png" alt="" width="142" height="31"/>, <img src="img/Formula_03_334.png" alt="" width="147" height="29"/></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor133"/>3.2.2. Two-qubit quantum gates</h2>
			<p>A <a id="_idIndexMarker274"/>two-qubit gate <img src="img/Formula_03_335.png" alt="" width="29" height="32"/> is a <img src="img/Formula_03_336.png" alt="" width="124" height="41"/> unitary matrix, <img src="img/Formula_03_337.png" alt="" width="286" height="41"/> that acts on<a id="_idIndexMarker275"/> two qubits.</p>
			<p>We<a id="_idIndexMarker276"/> summarize commonly used two-qubit quantum <a id="_idIndexMarker277"/>gates in <em class="italic">Figure 3.10</em>.</p>
			<div><div><img src="img/B18268_03_Table_05.jpg" alt="" width="1607" height="928"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Two-qubit quantum gates</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor134"/>3.2.3. Three-qubit quantum gates</h2>
			<p>A <a id="_idIndexMarker278"/>three-qubit gate U is an <img src="img/Formula_03_364.png" alt="" width="131" height="45"/> unitary matrix <img src="img/Formula_03_365.png" alt="" width="299" height="44"/> that acts on three<a id="_idIndexMarker279"/> qubits. We summarize commonly used three-qubit quantum gates in <em class="italic">Figure 3.11</em>:</p>
			<div><div><img src="img/B18268_03_Table_06.jpg" alt="" width="1462" height="755"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Three-qubit quantum gates</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor135"/>3.2.4. Serially wired gates and parallel quantum gates</h2>
			<p>Operations on <a id="_idIndexMarker280"/>quantum gates are applied sequentially from left to right, and there are no loops. Two gates <img src="img/Formula_03_335.png" alt="" width="29" height="32"/> and <img src="img/Formula_03_384.png" alt="" width="27" height="32"/> in series are equivalent to the <a id="_idIndexMarker281"/>matrix product of the two gates, as shown in <em class="italic">Figure 3.12</em>:</p>
			<div><div><img src="img/B18268_03_Table_07.jpg" alt="" width="1239" height="193"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Serially wired quantum gates</p>
			<p>Two gates <img src="img/Formula_03_391.png" alt="" width="30" height="32"/> and <img src="img/Formula_03_392.png" alt="" width="29" height="33"/> in parallel are<a id="_idIndexMarker282"/> equivalent to the tensor product of<a id="_idIndexMarker283"/> the two gates <img src="img/Formula_03_393.png" alt="" width="123" height="39"/>, as shown in <em class="italic">Figure 3.13</em>:</p>
			<div><div><img src="img/B18268_03_Table_08.jpg" alt="" width="1510" height="346"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Parallel quantum gates</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor136"/>3.2.5. Creation of a Bell state</h2>
			<p>Bell states<a id="_idIndexMarker284"/> are maximally entangled pure quantum states, and there are only four:</p>
			<div><div><img src="img/Formula_03_409.jpg" alt="" width="438" height="107"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_410.jpg" alt="" width="438" height="110"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_411.jpg" alt="" width="441" height="107"/>
				</div>
			</div>
			<div><div><img src="img/Formula_03_412.jpg" alt="" width="438" height="110"/>
				</div>
			</div>
			<p>A quantum circuit<a id="_idIndexMarker285"/> is an ordered sequence of instructions, quantum gates, measurements, and resets that is applied to registers of qubits and may be conditioned on real-time classical computation. Se<a id="_idTextAnchor137"/>veral quantum hardware platforms now support dynamic quantum circuits, which allow concurrent classical processing of mid-circuit measurement results [Corcoles] [IBM_mid]. In <em class="italic">Section 3.4, Preparing a permutation symmetric or antisymmetric state</em>, we demonstrate a classical program that aims to obtain the desired quantum state by post selecting the result of a measurement of a control qubit. There is no loop in a quantum circuit, <a id="_idTextAnchor138"/>but we can have a classical loop that appends a quantum sub-circuit. In Qiskit, we use the <code>QuantumRegister</code> class to create a register of qubits and the <code>QuantumCircuit</code> class to create a quantum circuit.</p>
			<p>Let's build a quantum circuit that creates the first Bell state <img src="img/Formula_03_413.png" alt="" width="80" height="44"/> with Qiskit:</p>
			<pre>q = QuantumRegister(2)
qc = QuantumCircuit(q)
qc.h(q[0])
qc.cx(q[0], q[1])
qc.draw(output='mpl')</pre>
			<p><em class="italic">Figure 3.14</em> shows <a id="_idIndexMarker286"/>the result:</p>
			<div><div><img src="img/B18268_Figure_3.14.jpg" alt="" width="980" height="127"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Qiskit quantum circuit that creates a Bell state</p>
			<p>We use the <code>Statevector.from_instruction()</code> class method from the <code>quantum_info</code> module <a id="_idIndexMarker287"/>to get the final state vector <img src="img/Formula_03_414.png" alt="" width="46" height="43"/> :</p>
			<pre>s = qi.Statevector.from_instruction(qc)
s.draw('latex', prefix='|s \\rangle = ')</pre>
			<p><em class="italic">Figure 3.15</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.15.jpg" alt="" width="255" height="55"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Final state vector – Bell state</p>
			<p>The final state vector can only be measured in either the state <img src="img/Formula_03_415.png" alt="" width="73" height="43"/> or <img src="img/Formula_03_416.png" alt="" width="73" height="42"/>, each with a probability of 1/2.</p>
			<p>We use the <code>DensityMatrix.from_instruction()</code> class method to obtain the density matrix representation of the final state vector:</p>
			<pre>rho = qi.DensityMatrix.from_instruction(qc)
rho.draw('latex', prefix='\\rho = ')</pre>
			<p><em class="italic">Figure 3.16</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.16.jpg" alt="" width="222" height="140"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Density matrix – Bell state</p>
			<p>We can visualize the <a id="_idIndexMarker288"/>density matrix using a cityscape plot of the state:</p>
			<pre>from qiskit.visualization import plot_state_city
plot_state_city(rho.data, title='Density Matrix')</pre>
			<p><em class="italic">Figure 3.17</em> shows the<a id="_idIndexMarker289"/> result:</p>
			<div><div><img src="img/B18268_Figure_3.17.jpg" alt="" width="1226" height="493"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Cityscape plot – Bell state</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor139"/>3.2.6. Parallel Hadamard gates</h2>
			<p>It can be shown that applying<a id="_idIndexMarker290"/> parallel Hadamard gates to a register of qubits initialized in the zero state puts it in a uniform superposition of all possible states. Let's experiment with the effect of applying one, two, and three Hadamard gates. In this section, we'll build the following:</p>
			<ul>
				<li>One Hadamard gate</li>
				<li>Two parallel Hadamard gates</li>
				<li>Three parallel Hadamard gates</li>
			</ul>
			<p>The <code>create_parallel_H()</code> function creates a quantum circuit with n parallel Hadamard gates:</p>
			<pre>def create_parallel_H(n):
    q = QuantumRegister(n, 'q')
    qc = QuantumCircuit(q)
    for k in range(n):
        qc.h(k)
    return qc</pre>
			<p>The function <code>run_parallel_H()</code> creates and executes a quantum circuit with n parallel Hadamard <a id="_idIndexMarker291"/>gates and displays a diagram of the final state vector:</p>
			<pre>def run_parallel_H(n):
  qc = create_parallel_H(n)
  s = qi.Statevector.from_instruction(qc)
  display(s.draw('latex'))
  display(qc.draw(output='mpl'))
  return</pre>
			<p>Let's create a quantum circuit with just one Hadamard gate:</p>
			<pre>run_parallel_H(1)</pre>
			<p><em class="italic">Figure 3.18</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.18.jpg" alt="" width="150" height="125"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – One Hadamard gate</p>
			<p>Next, we build a<a id="_idIndexMarker292"/> quantum circuit with two parallel Hadamard gates:</p>
			<pre>run_parallel_H(2)</pre>
			<p><em class="italic">Figure 3.19</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.19.jpg" alt="" width="301" height="172"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Two parallel Hadamard gates</p>
			<p>Last, let's build a circuit with three parallel Hadamard gates:</p>
			<pre>run_parallel_H(3)</pre>
			<p><em class="italic">Figure 3.20</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.20.jpg" alt="" width="816" height="240"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Three parallel Hadamard gates</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor140"/>3.3. Computation-driven interference</h1>
			<p>In this section, we <a id="_idIndexMarker293"/>introduce the process of a generic quantum computation in <em class="italic">Section 3.3.1, Quantum computation process</em>. Then we give an example of a simulation inspired by a chemical experiment in <em class="italic">Section 3.3.2, Simulating interferometric sensing of a quantum superposition of left- and right-handed enantiomer states</em>. In chemistry, molecules or ions that are mirror images of each other are called enantiomers or optical isomers. If these images are non-superimposable, they are called chiral molecules [ChemChiral] and they differ in their ability to rotate plane polarized light either to the left or to the right [Wonders]. Researchers have proposed an experiment to prepare a quantum superposition of left- and right-handed states of enantiomers and to perform interferometric sensing of chirality-dependent forces [Stickler].</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor141"/>3.3.1. Quantum computation process</h2>
			<p>Quantum c<a id="_idTextAnchor142"/>omputing <a id="_idIndexMarker294"/>uses interference and the quantum physical phenomena of superposition and entanglement. A typical quantum computation comprises the following steps:</p>
			<ol>
				<li value="1">Prepare a uniform superposition of all possible basis states. A register of qubits initialized in the zero state is put in a uniform superposition of all possible basis states simply by applying parallel Hadamard gates, as we illustrated previously.</li>
				<li>Orchestr<a id="_idTextAnchor143"/>ate quantum interference and entanglement. A quantum algorithm ought to be designed such that at the end of a computation, only the relative amplitudes and the phases of those quantum states that are of interest will remain.</li>
				<li>Repeat t<a id="_idTextAnchor144"/>he measurements multiple times. Measurements are repeated hundreds or thousands of times in order to obtain a distribution over the possible measurement outcomes. This is the key difference between quantum and classical computing.</li>
			</ol>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor145"/>3.3.2. Simulating interferometric sensing of a quantum superposition of left- and right-handed enantiomer states</h2>
			<p>Let's <a id="_idIndexMarker295"/>design, with Qiskit, a quantum circuit inspired by the interferometer involving enantiomers. We represent a single enantiomer with two qubits. We encode in the direction of propagation qubit <img src="img/Formula_03_417.png" alt="" width="66" height="44"/> the horizontal propagation as the state <img src="img/Formula_03_418.png" alt="" width="48" height="43"/> and the vertical propagation as the state <img src="img/Formula_03_024.png" alt="" width="48" height="43"/> . We simulate a mirror by the Pauli <img src="img/Formula_03_420.png" alt="" width="41" height="33"/> matrix and a beam splitter (<img src="img/Formula_03_421.png" alt="" width="54" height="33"/>) by the matrix <img src="img/Formula_03_422.png" alt="" width="188" height="89"/>:</p>
			<div><div><img src="img/Formula_03_423.jpg" alt="" width="1104" height="120"/>
				</div>
			</div>
			<p>By convention, a phase shift of <img src="img/Formula_03_424.png" alt="" width="37" height="82"/>  is assigned to reflection. From the preceding unitary matrix, we create a beam splitter gate named BS with the following Qiskit code:</p>
			<pre>from qiskit.extensions import UnitaryGate
i = complex(0.0, 1.0)
BS = 1/np.sqrt(2) * np.array([[1,i],[i,1]])
BS = UnitaryGate(BS,'Beam Splitter')</pre>
			<p>We encode the <a id="_idIndexMarker296"/>following in the handedness qubit <img src="img/Formula_03_425.png" alt="" width="67" height="44"/> :</p>
			<ul>
				<li>A left-handed state as the <img src="img/Formula_03_426.png" alt="" width="49" height="43"/> state</li>
				<li>A right-handed state as the <img src="img/Formula_03_024.png" alt="" width="48" height="43"/> state</li>
				<li>A superposition of left- and right-handed states as <img src="img/Formula_03_428.png" alt="" width="221" height="92"/> obtained by applying a Hadamard gate</li>
			</ul>
			<p>We simulate a polarizing beam splitter (<img src="img/Formula_03_429.png" alt="" width="81" height="32"/>): </p>
			<div><div><img src="img/Formula_03_430.jpg" alt="" width="408" height="182"/>
				</div>
			</div>
			<p>which transmits left-handed and reflects right-handed states with the matrix PBS [Rioux]. Unlike the beam splitter, there is no phase change on reflection. From the preceding unitary matrix, we create a polarizing beam splitter gate named PBS with the following Qiskit code:</p>
			<pre>PBS = np.array([[1,0,0,0],[0,0,0,1],[0,0,1,0],[0,1,0,0]])
PBS = UnitaryGate(PBS,'PBS')</pre>
			<p>We <a id="_idIndexMarker297"/>define the <code>show()</code> function, which displays the drawing of a quantum circuit and the state of the state vector using LaTeX as follows:</p>
			<pre>def show(qc):
  display(qc.draw(output='mpl'))
  s = qi.Statevector.from_instruction(qc)
  display(array_to_latex(s, prefix="\\text{state vector} = ", precision = 2))
  return</pre>
			<p>We simulate the action of a polarizing beam splitter on an enantiomer moving horizontally and in the right-handed state with the following Qiskit code:</p>
			<pre>q = QuantumRegister(2, 'q') # register of 2 qubits
# q[0] handedness qubit,|0⟩ left-handed,|1⟩ right-handed
# q[1] direction of propagation qubit,|0⟩ horizontal,|1⟩ vertical
qc = QuantumCircuit(q)
qc.x([0]) # Right-handed
show(qc)
qc.append(PBS, q)
show(qc)</pre>
			<p><em class="italic">Figure 3.21</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.21.jpg" alt="" width="810" height="308"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Simulation of the interaction of a right-handed enantiomer with a polarizing beam splitter</p>
			<p>The <a id="_idIndexMarker298"/>enantiomer moving horizontally and in the right-handed state, represented by <img src="img/Formula_03_431.png" alt="" width="245" height="47"/>, using Qiskit tensor ordering of qubits, has been reflected in the vertical direction of propagation by the polarizing beam splitter, represented by <img src="img/Formula_03_432.png" alt="" width="245" height="50"/>.</p>
			<p>We simulate the action of a polarizing beam splitter on an enantiomer moving horizontally and in a superposition of left- and right-handed states with the following Qiskit code:</p>
			<pre>q = QuantumRegister(2, 'q') # register of 2 qubits
# q[0] handedness qubit,|0⟩ left-handed, |1⟩ right-handed
# q[1] direction of propagation qubit, |0⟩ horizontal, |1⟩ vertical
qc = QuantumCircuit(q)
qc.h(q[0]) # Put enantiomer in a superposition of left- and right-handed states
show(qc)
qc.append(PBS, q)
show(qc)</pre>
			<p><em class="italic">Figure 3.22</em> shows the result:</p>
			<div><div><img src="img/B18268_Figure_3.22.jpg" alt="" width="734" height="329"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – Simulation of the interaction of a left- and right-handed enantiomer with a polarizing beam splitter</p>
			<p>The <a id="_idIndexMarker299"/>enantiomer moving horizontally and in a superposition of the left- and right-handed states, represented by <img src="img/Formula_03_433.png" alt="" width="741" height="91"/>, using Qiskit tensor ordering of qubits, has been put by the polarizing beam splitter in the Bell state <img src="img/Formula_03_434.png" alt="" width="520" height="92"/>, a superposition of left-handed moving horizontally and right-handed moving vertically, thereby achieving interferometric sensing.</p>
			<p>Now we move on to preparing permutation symmetric and antisymmetic states.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor146"/>3.4. Preparing a permutation symmetric or antisymmetric state</h1>
			<p>Given two qubits <img src="img/Formula_03_435.png" alt="" width="66" height="46"/> and <img src="img/Formula_03_436.png" alt="" width="67" height="45"/> , we want to build a symmetrized state that remains invariant<a id="_idIndexMarker300"/> under a permutation of the qubits <img src="img/Formula_03_437.png" alt="" width="67" height="45"/> and <img src="img/Formula_03_438.png" alt="" width="67" height="44"/>, or an antisymmetrized state that is multiplied by <img src="img/Formula_03_439.png" alt="" width="53" height="32"/> under a permutation of the<a id="_idIndexMarker301"/> qubits <img src="img/Formula_03_440.png" alt="" width="65" height="45"/> and <img src="img/Formula_03_441.png" alt="" width="66" height="44"/>. In this section, we show how to prepare such states in a probabilistic manner with a quantum circuit prepared and simulated with Qiskit:</p>
			<ul>
				<li><em class="italic">Section 3.4.1, Creating random states</em></li>
				<li><em class="italic">Section 3.4.2, Creating a quantum circuit and initializing qubits</em></li>
				<li><em class="italic">Section 3.4.3, Creating a circuit that swaps two qubits with a controlled swap gate</em></li>
				<li><em class="italic">Section 3.4.4, Post selecting the control qubit until the desired state is obtained</em></li>
				<li><em class="italic">Section 3.4.5, Examples of final symmetrized and antisymmetrized states </em></li>
			</ul>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor147"/>3.4.1. Creating random states</h2>
			<p>We define a <a id="_idIndexMarker302"/>function called <code>init_random()</code> that creates random 1-qubit states <code>s1</code> and <code>s2</code> that we will use later to run experiments with random states:</p>
			<pre>def init_random():
  # Create random 1-qubit state s1
  s1 = qi.random_statevector(2)
  display(array_to_latex(s1, prefix="\\text{State 1} =", precision=2))
  # Create random 1-qubit state s2
  s2 = qi.random_statevector(2)
  display(array_to_latex(s2, prefix="\\text{State 2} =", precision =2))
  
  return s1, s2</pre>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor148"/>3.4.2. Creating a quantum circuit and initializing qubits</h2>
			<p>We define <a id="_idIndexMarker303"/>the <code>setup_qc()</code> function, which sets up the initialization instruction to create qubits <img src="img/Formula_03_442.png" alt="" width="66" height="46"/> and <img src="img/Formula_03_443.png" alt="" width="67" height="46"/> from the state vectors <code>s1</code> and <code>s2</code> given as input and a quantum circuit <code>qc</code> with a control qubit <img src="img/Formula_03_425.png" alt="" width="67" height="44"/> initialized in state <img src="img/Formula_03_445.png" alt="" width="48" height="43"/>, qubits <img src="img/Formula_03_446.png" alt="" width="65" height="45"/> and <img src="img/Formula_03_447.png" alt="" width="67" height="45"/>, and a <a id="_idIndexMarker304"/>classical register <code>c</code> for measuring <img src="img/Formula_03_448.png" alt="" width="68" height="45"/>:</p>
			<pre>def setup_qc(s1, s2, draw=False):
  init_q1 = Initialize(s1)
  init_q1.label = "init_q1"
  init_q2 = Initialize(s2)
  init_q2.label = "init_q2"
  q = QuantumRegister(3, 'q') # register of 3 qubits
  c = ClassicalRegister(1, name="c") # and 1 classical register
  qc = QuantumCircuit(q,c)
  qc.append(init_q1, [1])
  qc.append(init_q2, [2])
  qc.barrier()
  if draw:
    display(qc.draw(output='mpl'))
  return qc, q, c</pre>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor149"/>3.4.3. Creating a circuit that swaps two qubits with a controlled swap gate</h2>
			<p>We define the <code>swapper()</code> function, which<a id="_idIndexMarker305"/> creates a quantum circuit as follows [Spheres]:</p>
			<ul>
				<li>Applying a Hadamard gate to the control qubit <img src="img/Formula_03_449.png" alt="" width="67" height="47"/> which puts it in the state <img src="img/Formula_03_450.png" alt="" width="222" height="94"/></li>
				<li>Applying a controlled swap gate, which puts the two qubits <img src="img/Formula_03_451.png" alt="" width="67" height="45"/> and <img src="img/Formula_03_452.png" alt="" width="66" height="44"/> in a superposition of being swapped and not swapped</li>
				<li>Applying again a Hadamard gate to the control qubit <img src="img/Formula_03_453.png" alt="" width="67" height="45"/></li>
			</ul>
			<p>Here is the implementation:</p>
			<pre>def swapper(draw=False):
  q = QuantumRegister(3, 'q') # register of 3 qubits
  qc = QuantumCircuit(q, name='Swapper')
  qc.h(q[0])
  qc.cswap(q[0], q[1], q[2])
  qc.h(q[0])
  if draw:
    print("Swapper circuit")
    display(qc.draw(output='mpl'))
  return qc</pre>
			<p>Let's get the unitary<a id="_idIndexMarker306"/> matrix corresponding to the swapper quantum circuit with the unitary simulator:</p>
			<pre>q = QuantumRegister(3, 'q') # register of 3 qubits
qc = QuantumCircuit(q)
qc.append(swapper(draw=True), qargs=q)
# Selecting the unitary_simulator
backend = Aer.get_backend('unitary_simulator')
# Executing the job and getting the result as an object
job = execute(qc, backend)
result = job.result()
# Getting the unitary matrix from the result object
U = result.get_unitary(qc, decimals=2)
array_to_latex(U, prefix="\\text{swapper unitary} = ", precision = 2)</pre>
			<p><em class="italic">Figure 3.23</em> shows the<a id="_idIndexMarker307"/> result:</p>
			<div><div><img src="img/B18268_Figure_3.23.jpg" alt="" width="785" height="219"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – Unitary matrix of the swapper circuit</p>
			<h3>Computing the action of the swapper unitary</h3>
			<p>The initial <a id="_idIndexMarker308"/>state vector pertaining to the two qubits <img src="img/Formula_03_454.png" alt="" width="65" height="44"/> and <img src="img/Formula_03_455.png" alt="" width="66" height="44"/> can be written as follows:</p>
			<p><img src="img/Formula_03_456.png" alt="" width="275" height="197"/></p>
			<p>The swapper unitary<a id="_idIndexMarker309"/> acts on the initial state vector as follows, using Qiskit ordering of the tensor product:</p>
			<p><img src="img/Formula_03_457.png" alt="" width="725" height="377"/></p>
			<p><img src="img/Formula_03_458.png" alt="" width="1189" height="577"/></p>
			<h3>Computing the final state when the control qubit <img src="img/Formula_03_459.png" alt="" width="71" height="44"/> is measured in state <img src="img/Formula_03_460.png" alt="" width="50" height="43"/></h3>
			<p>If the control qubit <img src="img/Formula_03_461.png" alt="" width="66" height="44"/> is measured in state <img src="img/Formula_03_462.png" alt="" width="48" height="42"/>, then the final state is computed by discarding all amplitudes that do not contribute to this outcome, <img src="img/Formula_03_463.png" alt="" width="107" height="43"/> <img src="img/Formula_03_464.png" alt="" width="97" height="42"/>, <img src="img/Formula_03_465.png" alt="" width="107" height="43"/> <img src="img/Formula_03_466.png" alt="" width="107" height="43"/> and then renormalizing:</p>
			<p><img src="img/Formula_03_467.png" alt="" width="1188" height="563"/></p>
			<p>Recall that <img src="img/Formula_03_468.png" alt="" width="80" height="43"/>, <img src="img/Formula_03_469.png" alt="" width="76" height="42"/>, <img src="img/Formula_03_470.png" alt="" width="80" height="43"/> and <img src="img/Formula_03_471.png" alt="" width="76" height="43"/> are the Bell states we introduced in <em class="italic">Section 3.2.5, Creation of a Bell state</em>. The amplitudes <img src="img/Formula_03_472.png" alt="" width="40" height="32"/> of <img src="img/Formula_03_473.png" alt="" width="72" height="42"/> and <img src="img/Formula_03_474.png" alt="" width="39" height="32"/> of <img src="img/Formula_03_475.png" alt="" width="73" height="42"/> are left unchanged up to a renormalization factor in the final state. The symmetrized Bell state <img src="img/Formula_03_476.png" alt="" width="353" height="87"/> is left unchanged. The amplitudes <img src="img/Formula_03_477.png" alt="" width="39" height="32"/> of <img src="img/Formula_03_478.png" alt="" width="73" height="43"/> and <img src="img/Formula_03_479.png" alt="" width="40" height="33"/> of <img src="img/Formula_03_480.png" alt="" width="73" height="43"/> are mixed in the <a id="_idIndexMarker310"/>Bell state <img src="img/Formula_03_481.png" alt="" width="378" height="94"/>, which is symmetrized.</p>
			<h3>Computing the final state when the control qubit <img src="img/Formula_03_482.png" alt="" width="71" height="45"/> is measured in state <img src="img/Formula_03_483.png" alt="" width="50" height="43"/></h3>
			<p>If the control qubit <img src="img/Formula_03_484.png" alt="" width="66" height="44"/> is measured in state <img src="img/Formula_03_485.png" alt="" width="49" height="42"/>, then the final state is computed by discarding all amplitudes that do not contribute to this outcome, <img src="img/Formula_03_486.png" alt="" width="107" height="43"/> <img src="img/Formula_03_487.png" alt="" width="98" height="44"/>, <img src="img/Formula_03_488.png" alt="" width="108" height="45"/> and <img src="img/Formula_03_489.png" alt="" width="94" height="42"/>, and then renormalizing:</p>
			<p><img src="img/Formula_03_490.png" alt="" width="974" height="568"/></p>
			<p>The only non-null amplitudes of the final state are those in the <img src="img/Formula_03_491.png" alt="" width="73" height="44"/> and <img src="img/Formula_03_492.png" alt="" width="73" height="43"/> subspace, which are mixed in the Bell state <img src="img/Formula_03_493.png" alt="" width="360" height="88"/>, which is antisymmetrized.</p>
			<p>These <a id="_idIndexMarker311"/>properties of symmetry and antisymmetry are key to efficient implementations of the <strong class="bold">Variational Quantum Eigensolver</strong> (<strong class="bold">VQE</strong>) algorithms [Gard] that we will cover in <a href="B18268_06_ePub.xhtml#_idTextAnchor228"><em class="italic">Chapter 6</em></a><em class="italic">, Variational Quantum Eigensolver Algorithm</em>.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor150"/>3.4.4. Post selecting the control qubit until the desired state is obtained</h2>
			<p>We define the <code>post_select()</code> function, which performs a loop that executes the swapper circuit <a id="_idIndexMarker312"/>and measures the state of the control qubit <img src="img/Formula_03_425.png" alt="" width="67" height="44"/> until the desired symmetrized or antisymmetrized state is obtained, or until the maximum number of iterations is reached:</p>
			<ul>
				<li>Append a circuit created by the <code>swapper()</code> function.</li>
				<li>Measure the control qubit <img src="img/Formula_03_495.png" alt="" width="67" height="44"/>. If we get 0, then qubits <img src="img/Formula_03_496.png" alt="" width="65" height="45"/> and <img src="img/Formula_03_436.png" alt="" width="67" height="45"/> are in a symmetrized state and if we get 1, then qubits <img src="img/Formula_03_498.png" alt="" width="66" height="45"/> and <img src="img/Formula_03_499.png" alt="" width="66" height="45"/> are in an antisymmetrized state.</li>
			</ul>
			<p>Then, <code>post_select()</code> calls the <code>proc_result()</code> function to process the results.</p>
			<p>The <code>post_select()</code> function has the following input parameters:</p>
			<ul>
				<li><code>simulator</code>, by default <code>statevector_simulator</code>, which simulates perfect qubits.</li>
				<li><code>symm:</code> set to <code>True</code> to get a symmetrized state and <code>False</code> to get an antisymmetrized state.</li>
				<li><code>shots</code> is the number of shots, and by default is set to <code>1</code>.</li>
				<li><code>max_iter</code> is the maximum number of iterations, and by default is set to <code>20</code>.</li>
				<li><code>swap_test</code> is set to <code>True</code> to perform a swap test to determine whether the final state is permutation symmetric or permutation asymmetric, and by default is set to <code>False</code>.</li>
			</ul>
			<p>Here is <a id="_idIndexMarker313"/>the code:</p>
			<pre>def post_select(qc, q, c, symm=True, simulator='statevector_simulator', shots=1, max_iter=20, swap_test=False):
  backend = Aer.get_backend(simulator)
  s = qi.Statevector.from_instruction(qc)
  display(array_to_latex(s, prefix="\\text{Initial state} = ", precision = 2))
  done = False
  iter = 0
  while not done and iter &lt; max_iter:
    qc.append(swapper(draw=(iter==0)), qargs=q)
    qc.measure(q[0], c[0]) # Measure control qubit q[0]
    qc.save_statevector(label=str(iter)) # Save the current simulator state vector
    job = execute(qc, backend, shots=shots) # Execute the Simulator
    result = job.result()
    counts = result.get_counts(qc)
    for k, v in counts.items():
      if symm and k == '0' and v &gt; shots/2:
        done = True
      elif not symm and k == '1' and v &gt; shots/2:
        done = True
    if not done:
      qc.reset(q[0])
      iter += 1
  success = proc_result(result, iter, counts, max_iter=max_iter, symm=symm, simulator=simulator, swap_test=swap_test)
  return result, success</pre>
			<p>The <code>proc_result()</code> function processes the results, displays the saved state vector, and calls the <code>factor()</code> function. If the input parameter <code>swap_test</code> is set to <code>True</code>, it calls the <code>swap_check()</code> function, which tests whether the final state is permutation symmetric or permutation asymmetric.</p>
			<p>It returns <code>Success</code>, a <a id="_idIndexMarker314"/>Boolean; <code>True</code> if the desired state has been obtained, <code>False</code> otherwise:</p>
			<pre>def proc_result(result, iter, counts, max_iter=20, symm=True, simulator='statevector_simulator', swap_test=False):
  if symm:
    print("Preparing a permutation symmetric state")
  else:
    print("Preparing a permutation antisymmetric state")
  print("simulator:", simulator)
  print("counts: ", counts)
  if iter &gt;= max_iter:
    print("Post selection unsuccessful iteration {}".format(iter))
    success = False
  else:
    print("Post selection successful iteration {}".format(iter))
    success = True
    s = result.data()[str(iter)]
    factor(s, symm) # Call factor()
    if swap_test:
      swap_check(qc, q, iter, symm, s, simulator=simulator)
    print(" ") # Display Density matrix of the final state
    display(array_to_latex(qi.DensityMatrix(s), prefix="\\text{Density matrix of the final state: }", precision = 2))
    display(plot_state_city(s, title='Cityscape plot of the final state')) # Display Cityscape plot of the final state
  return success</pre>
			<p>The <code>sym_test()</code> function<a id="_idIndexMarker315"/> determines whether two amplitudes of a state vector are equal or opposite to one another and the sum of their modulus squared is equal to 1:</p>
			<pre>def sym_test(s, symm, i0, i1):
  if symm:
    b = np.isclose(np.abs(s[i0]-s[i1]), 0, rtol=_EPS) and np.isclose(np.abs(s[i0]**2 + s[i1]**2), 1, rtol=1e-4)
  else:
    b = np.isclose(np.abs(s[i0]+s[i1]), 0, rtol=_EPS) and np.isclose(np.abs(s[i0]**2 + s[i1]**2), 1, rtol=1e-4)
  return b</pre>
			<p>The <code>factor()</code> function <a id="_idIndexMarker316"/>attempts to factor the final state into a tensor product of the control qubit <img src="img/Formula_03_500.png" alt="" width="67" height="45"/> and the permutation symmetric Bell states <img src="img/Formula_03_501.png" alt="" width="375" height="92"/> or <img src="img/Formula_03_502.png" alt="" width="365" height="89"/>, or the permutation antisymmetric Bell states <img src="img/Formula_03_503.png" alt="" width="369" height="90"/> or <img src="img/Formula_03_504.png" alt="" width="367" height="91"/>, which were <a id="_idIndexMarker317"/>introduced in <em class="italic">Section 3.2.5, Creation of a Bell state</em>:</p>
			<pre>def factor(s, symm):
  b0 = np.allclose(s, [1, 0, 0, 0, 0, 0, 0, 0], rtol=_EPS)
  b1 = np.allclose(s, [0, 0, 0, 0, 0, 0, 1, 0], rtol=_EPS)
  b2 = sym_test(s, symm, 2, 4)
  b3 = sym_test(s, symm, 3, 5)
  b4 = sym_test(s, symm, 0, 6)
  b5 = sym_test(s, symm, 1, 7)
  df = {b0: "|00", b1: "|11", b2: "|\\Psi_+", b3: "|\\Psi_-", b4: "|\\Phi_+", b5: "|\\Phi_-"}
  found = False
  for k, v in df.items():
    if not found and symm and k:
      display(array_to_latex([s], prefix = "\\text{Symmetrized state: }" + v + "\\rangle, \\text{  Final state: }" + v + " \\rangle |0 \\rangle =", precision = 2))
      found = True
    elif not found and not symm and k:
      display(array_to_latex([s], prefix = "\\text{Antisymmetrized state: }" + v + "\\rangle, \\text{  Final state: }" + v + " \\rangle |1 \\rangle =", precision = 2))
      found = True
  if not found:
    display(array_to_latex(s, prefix="\\text{Final state} = ", precision = 2))
  return</pre>
			<p>The <code>swap_check()</code> function tests whether the final state is permutation symmetric or permutation asymmetric. It calls the <code>swap()</code> function and then compares the states before and<a id="_idIndexMarker318"/> after the swap:</p>
			<pre>def swap_check(qc, q, iter, symm, s, simulator='statevector_simulator'):
  s21 = swap(qc, q, iter, simulator=simulator)
  if symm:
    if np.allclose(s-s21, 0, rtol=_EPS):
      print("Swap test confirms that final state is permutation symmetric")
  else:
    if np.allclose(s+s21, 0, rtol=_EPS):
      print("Swap test confirms that final state is permutation asymmetric")
  return</pre>
			<p>The <code>swap()</code> function performs a swap of qubits <img src="img/Formula_03_505.png" alt="" width="64" height="45"/> and <img src="img/Formula_03_455.png" alt="" width="66" height="44"/>, measures the control qubit, and returns the final state vector for comparison purposes:</p>
			<pre>def swap(qc, q, iter, simulator='statevector_simulator'):
  backend = Aer.get_backend(simulator)
  qc.swap(q[1], q[2])
  qc.measure(q[0], c[0]) # Measure control qubit q[0]
  qc.save_statevector(label=str(iter+1)) # Save the current simulator state vector
  job = execute(qc, backend, shots=1) # Execute the Simulator
  result = job.result()
  s21 = result.data()[str(iter+1)]
  return s21</pre>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor151"/>3.4.5. Examples of final symmetrized and antisymmetrized states</h2>
			<p>We now <a id="_idIndexMarker319"/>implement five experiments creating:</p>
			<ul>
				<li>A symmetrized state from state <img src="img/Formula_03_507.png" alt="" width="73" height="42"/></li>
				<li>An<a id="_idIndexMarker320"/> antisymmetrized state from state <img src="img/Formula_03_508.png" alt="" width="73" height="43"/></li>
				<li>A symmetrized state from qubits initialized with random states</li>
				<li>An antisymmetrized state from qubits initialized with random states</li>
				<li>A symmetrized state from the Bell state <img src="img/Formula_03_509.png" alt="" width="81" height="42"/></li>
			</ul>
			<h3>Experiment creating a symmetrized state from state <img src="img/Formula_03_510.png" alt="" width="77" height="43"/></h3>
			<p>We create two state<a id="_idIndexMarker321"/> vectors in states <img src="img/Formula_03_511.png" alt="" width="48" height="42"/> and <img src="img/Formula_03_022.png" alt="" width="48" height="43"/> , we give them as input to the <code>setup_qc()</code> function, and then we call the <code>post_select()</code> function with <code>symm</code> set to <code>True</code>:</p>
			<pre>s1 = qi.Statevector([0, 1])
s2 = qi.Statevector([1, 0])
qc, q, c = setup_qc(s1, s2)
result, success = post_select(qc, q, c, symm=True)</pre>
			<p>We have obtained the symmetrized state <img src="img/Formula_03_513.png" alt="" width="388" height="94"/> , as shown in <em class="italic">Figure 3.24</em>:</p>
			<div><div><img src="img/B18268_Figure_3.24.jpg" alt="" width="912" height="263"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – Symmetrized state obtained from state <img src="img/Formula_03_514.png" alt="" width="57" height="36"/></p>
			<p>We show the density <a id="_idIndexMarker322"/>matrix using a cityscape plot of the final state in <em class="italic">Figure 3.25</em>:</p>
			<div><div><img src="img/B18268_Figure_3.25.jpg" alt="" width="819" height="331"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – Cityscape plot of the symmetrized state obtained from state <img src="img/Formula_03_515.png" alt="" width="68" height="37"/></p>
			<p>We display the quantum circuit with the <code>draw()</code> method of the quantum circuit class:</p>
			<pre>qc.draw(output='mpl', plot_barriers=False)</pre>
			<p>After one iteration, the quantum circuit looks like <em class="italic">Figure 3.26</em>:</p>
			<div><div><img src="img/B18268_Figure_3.26.jpg" alt="" width="336" height="220"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26 – Quantum circuit after one iteration</p>
			<h3>Experiment creating an antisymmetrized state from state <img src="img/Formula_03_516.png" alt="" width="76" height="42"/></h3>
			<p>We create two state vectors<a id="_idIndexMarker323"/> in states <img src="img/Formula_03_517.png" alt="" width="48" height="43"/> and <img src="img/Formula_03_022.png" alt="" width="48" height="43"/> , we give them as input to the <code>setup_qc()</code> function, and then we call the <code>post_select()</code> function with <code>symm</code> set to <code>False</code>:</p>
			<pre>s1 = qi.Statevector([0, 1])
s2 = qi.Statevector([1, 0])
qc, q, c = setup_qc(s1, s2)
result, success = post_select(qc, q, c, symm=False)</pre>
			<p>We have obtained the antisymmetrized state <img src="img/Formula_03_519.png" alt="" width="341" height="85"/>, as shown in <em class="italic">Figure 3.27</em>:</p>
			<div><div><img src="img/B18268_Figure_3.27.jpg" alt="" width="971" height="271"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27 – Antisymmetrized state obtained from state <img src="img/Formula_03_520.png" alt="" width="56" height="36"/></p>
			<p>We show the<a id="_idIndexMarker324"/> density matrix using a cityscape plot of the final state in <em class="italic">Figure 3.28</em>:</p>
			<div><div><img src="img/B18268_Figure_3.28.jpg" alt="" width="816" height="324"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28 – Cityscape plot of the antisymmetrized state obtained from state <img src="img/Formula_03_521.png" alt="" width="63" height="38"/></p>
			<h3>Experiment creating a symmetrized state from qubits initialized with random states</h3>
			<p>We create two state vectors in<a id="_idIndexMarker325"/> random states with <code>init_random()</code>, we give them as input to the <code>setup_qc()</code> function, and then we call the <code>post_select()</code> function with <code>symm</code> set to <code>True</code> and <code>swap_test</code> set to <code>True</code> to confirm that the final state is indeed permutation symmetric. We expect the final state to have four non-null amplitudes, based on the computation made in <em class="italic">Section 3.4.3, Creating a circuit that swaps two qubits with a controlled swap gate, Computing the final state when the control qubit </em><img src="img/Formula_03_522.png" alt="" width="71" height="49"/><em class="italic"> is measured in state </em><img src="img/Formula_03_523.png" alt="" width="49" height="44"/><em class="italic">:</em></p>
			<pre>s1, s2 = init_random()
qc, q, c = setup_qc(s1, s2)
result, success = post_select(qc, q, c, symm=True, swap_test=True)</pre>
			<p>In <em class="italic">Figure 3.29</em>, we show a result where the final state has four non-null amplitudes, as expected, and the swap test has confirmed that the final state is permutation symmetric:</p>
			<div><div><img src="img/B18268_Figure_3.29.jpg" alt="" width="1177" height="297"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29 – Symmetrized state obtained from qubits initialized in random states</p>
			<p>In the cityscape plot of the<a id="_idIndexMarker326"/> final state shown in <em class="italic">Figure 3.30</em>, we see that the state <img src="img/Formula_03_524.png" alt="" width="97" height="43"/> has the largest probability to come out after measuring the final state:</p>
			<div><div><img src="img/B18268_Figure_3.30.jpg" alt="" width="819" height="335"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.30 – Cityscape plot of symmetrized state obtained from qubits initialized in random states</p>
			<h3>Experiment creating an antisymmetrized state from qubits initialized with random states</h3>
			<p>We create two state vectors in <a id="_idIndexMarker327"/>random states with <code>init_random()</code>, we give them as input to the <code>setup_qc()</code> function, and then we call the <code>post_select()</code> function with <code>symm</code> set to <code>False</code>:</p>
			<pre>s1, s2 = init_random()
qc, q, c = setup_qc(s1, s2)
result, success = post_select(qc, q, c, symm=False)</pre>
			<p>We have obtained the antisymmetrized state <img src="img/Formula_03_525.png" alt="" width="371" height="92"/> up to a global phase, as shown in <em class="italic">Figure 3.31</em>:</p>
			<div><div><img src="img/B18268_Figure_3.31.jpg" alt="" width="1123" height="287"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.31 – Antisymmetrized state obtained from qubits initialized in random states</p>
			<p>We show the density<a id="_idIndexMarker328"/> matrix using a cityscape plot of the final state in <em class="italic">Figure 3.32</em>:</p>
			<div><div><img src="img/B18268_Figure_3.32.jpg" alt="" width="823" height="326"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.32 – Cityscape plot of the antisymmetrized state obtained from qubits initialized in random states</p>
			<h3>Experiment creating a symmetrized state from the Bell state <img src="img/Formula_03_526.png" alt="" width="86" height="43"/></h3>
			<p>We define a function <a id="_idIndexMarker329"/>called <code>setup1_qc()</code>, which sets up a quantum circuit that puts qubits <img src="img/Formula_03_527.png" alt="" width="65" height="45"/> and <img src="img/Formula_03_528.png" alt="" width="67" height="45"/> into the Bell state <img src="img/Formula_03_529.png" alt="" width="392" height="99"/>, as follows:</p>
			<pre>def setup1_qc(draw=False):
  q = QuantumRegister(3, 'q') # register of 3 qubits
  c = ClassicalRegister(1, name="c") # and 1 classical register
  qc = QuantumCircuit(q,c)
  qc.h(q[1])
  qc.cx(q[1], q[2])
  qc.barrier()
  if draw:
    display(qc.draw(output='mpl'))
  return qc, q, c</pre>
			<p>We execute the following code, which calls <code>setup1_qc()</code> to create a Bell state <img src="img/Formula_03_530.png" alt="" width="81" height="43"/> and then calls the <code>post_select()</code> function with <code>symm</code> set to <code>True</code>:</p>
			<pre>qc, q, c = setup1_qc()
result, success = post_select(qc, q, c, symm=True)</pre>
			<p>As expected in <em class="italic">Section 3.4.3, Creating a circuit that swaps two qubits with a controlled swap gate</em>, the <a id="_idIndexMarker330"/>swapper circuit followed by a measurement of the qubit <img src="img/Formula_03_531.png" alt="" width="66" height="45"/> in state 0 leaves the symmetrized Bell state <img src="img/Formula_03_532.png" alt="" width="370" height="91"/> unchanged, as shown in <em class="italic">Figure 3.33</em>:</p>
			<div><div><img src="img/B18268_Figure_3.33.jpg" alt="" width="902" height="267"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.33 – Symmetrized state obtained from the Bell state <img src="img/Formula_03_533.png" alt="" width="72" height="43"/></p>
			<p>We show the density matrix using a cityscape plot of the final state in <em class="italic">Figure 3.34</em>:</p>
			<div><div><img src="img/B18268_Figure_3.34.jpg" alt="" width="1020" height="395"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.34 – Cityscape plot of the final state obtained from the Bell state <img src="img/Formula_03_533.png" alt="" width="72" height="43"/></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor152"/>References</h1>
			<p>[ChemChiral] 5.1 Chiral Molecules, Chemistry LibreTexts, 5 Jul 2015, <a href="https://chem.libretexts.org/Bookshelves/Organic_Chemistry/Map%3A_Organic_Chemistry_(Vollhardt_and_Schore)/05._Stereoisomers/5.1%3A_Chiral__Molecules">https://chem.libretexts.org/Bookshelves/Organic_Chemistry/Map%3A_Organic_Chemistry_(Vollhardt_and_Schore)/05._Stereoisomers/5.1%3A_Chiral__Molecules</a></p>
			<p>[Corcoles] A. D. Córcoles, Maika Takita, Ken Inoue, Scott Lekuch, Zlatko K. Minev, Jerry M. Chow, and Jay M. Gambetta, Exploiting Dynamic Quantum Circuits in a Quantum Algorithm with Superconducting Qubits, Phys. Rev. Lett. 127, 100501, 31 August 2021, <a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.100501">https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.127.100501</a></p>
			<p>[Crockett] Christopher Crockett, Superpositions of Chiral Molecules, September 14, 2021, Physics 14, s108, <a href="https://physics.aps.org/articles/v14/s108">https://physics.aps.org/articles/v14/s108</a></p>
			<p>[Gard] Gard, B.T., Zhu, L., Barron, G.S. et al., Efficient symmetry-preserving state preparation circuits for the variational quantum eigensolver algorithm, npj Quantum Inf 6, 10 (2020), <a href="https://doi.org/10.1038/s41534-019-0240-1">https://doi.org/10.1038/s41534-019-0240-1</a></p>
			<p>[Grok] Grok the Bloch Sphere, <a href="https://javafxpert.github.io/grok-bloch/">https://javafxpert.github.io/grok-bloch/</a></p>
			<p>[IBM_CEO] IBM CEO: Quantum computing will take off 'like a rocket ship' this decade, Fast Company, Sept 28, 2021., <a href="https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade">https://www.fastcompany.com/90680174/ibm-ceo-quantum-computing-will-take-off-like-a-rocket-ship-this-decade</a></p>
			<p>[IBM_comp1] Welcome to IBM Quantum Composer, <a href="https://quantum-computing.ibm.com/composer/docs/iqx/">https://quantum-computing.ibm.com/composer/docs/iqx/</a></p>
			<p>[IBM_comp2] IBM Quantum Composer, <a href="https://quantum-computing.ibm.com/composer/files/new">https://quantum-computing.ibm.com/composer/files/new</a></p>
			<p>[IBM_mid] Mid-Circuit Measurements Tutorial, IBM Quantum systems, <a href="https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/midcircuit-measurement/">https://quantum-computing.ibm.com/lab/docs/iql/manage/systems/midcircuit-measurement/</a></p>
			<p>[NumPy] NumPy: the absolute basics for beginners, <a href="https://numpy.org/doc/stable/user/absolute_beginners.html">https://numpy.org/doc/stable/user/absolute_beginners.html</a></p>
			<p>[Qiskit] Qiskit, <a href="https://qiskit.org/">https://qiskit.org/</a></p>
			<p>[QuTiP] QuTiP, Plotting on the Bloch Sphere, <a href="https://qutip.org/docs/latest/guide/guide-bloch.html">https://qutip.org/docs/latest/guide/guide-bloch.html</a></p>
			<p>[Rioux] Mach-Zehnder Polarizing Interferometer Analyzed Using Tensor Algebra, <a href="https://faculty.csbsju.edu/frioux/photon/MZ-Polarization.pdf">https://faculty.csbsju.edu/frioux/photon/MZ-Polarization.pdf</a></p>
			<p>[Spheres] How to Prepare a Permutation Symmetric Multiqubit State on an Actual Quantum Computer, <a href="https://spheres.readthedocs.io/en/stable/notebooks/9_Symmetrized_Qubits.html">https://spheres.readthedocs.io/en/stable/notebooks/9_Symmetrized_Qubits.html</a></p>
			<p>[Stickler] B. A. Stickler et al., Enantiomer superpositions from matter-wave interference of chiral molecules, Phys. Rev. X 11, 031056 (2021), <a href="https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.031056">https://journals.aps.org/prx/abstract/10.1103/PhysRevX.11.031056</a></p>
			<p>[Wonders] Optical Isomers, Enantiomers and Chiral Molecules, WondersofChemistry, <a href="https://www.youtube.com/watch?v=8TIZdWR4gIU">https://www.youtube.com/watch?v=8TIZdWR4gIU</a></p>
		</div>
	</div></body></html>