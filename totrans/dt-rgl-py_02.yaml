- en: '*Chapter 2*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Data Structures and File Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Compare Pythonâ€™s advanced data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize data structures to solve real-world problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make use of OS file-handling operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter emphasizes the data structures in Python and the operating system
    functions that are the foundation of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were introduced to the basic concepts of different fundamental data structures
    in the last chapter. We learned about the list, set, dict, tuple, and string.
    They are the building blocks of future chapters and are essential for data science.
  prefs: []
  type: TYPE_NORMAL
- en: However, what we have covered so far were only basic operations on them. They
    have much more to offer once you learn how to utilize them effectively. In this
    chapter, we will venture further into the land of data structures. We will learn
    about advanced operations and manipulations and use these fundamental data structures
    to represent more complex and higher-level data structures; this is often handy
    while wrangling data in real life.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, we deal with data that comes from different sources and generally
    read data from a file or a database. We will be introduced to operations related
    to files. We will see how to open a file and how many ways there are to do it,
    how to read data from it, how to write data to it, and how to safely close it
    once we are done. The last part, which many people tend to ignore, is super important.
    We often run into very strange and hard-to-track-down bugs in a real-world system
    just because a process opened a file and did not close it properly. Without further
    ado, let's begin our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start this chapter by discussing advanced data structures. We will do
    that by revisiting lists. We will construct a stack and a queue, explore multiple
    element membership checking, and throw a bit of functional programming in for
    good measure. If all of this sounds intimidating, then do not worry. We will get
    to things step by step, like in the previous chapter, and you will feel confident
    once you have finished this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this chapter, you have to open an empty notebook. To do that, you
    can simply input the following command in a shell. It is advised that you first
    navigate to an empty directory using `cd` before you enter the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the Docker container is running, point your browser to [http://localhost:8888](http://localhost:8888)
    and use `dw_4_all` as the passcode to access the notebook interface.
  prefs: []
  type: TYPE_NORMAL
- en: Iterator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start off this topic with lists. However, before we get into lists,
    we will introduce the concept of an iterator. An iterator is an object that implements
    the `next` method, meaning an iterator is an object that can iterate over a collection
    (lists, tuples, dicts, and so on). It is stateful, which means that each time
    we call the `next` method, it gives us the next element from the collection. And
    if there is no further element, then it raises a `StopIteration` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `StopIteration` exception occurs with the iterator's next method when there
    are no further values to iterate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with a programming language like C, C++, Java, JavaScript,
    or PHP, you may have noticed the difference between the `for` `loop` implementation
    in those languages, which consists of three distinct parts, precisely the initiation,
    the increment, and the termination condition, and the `for` `loop` in Python.
    In Python, we do not use that kind of for loop. What we use in Python is more
    like a `foreach` loop: `for` `i` `in` `list_1`. This is because, under the hood,
    the for loop is using an iterator, and thus we do not need to do all the extra
    steps. The iterator does this for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15: Introduction to the Iterator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To generate lists of numbers, we can use different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a list that will contain 10000000: ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the size of this variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value it will show you will be something around `81528056` (it is in bytes).
    This is a lot of memory! And the `big_list_of_numbers` variable is only available
    once the list comprehension is over. It can also overflow the available system
    memory if you try too big a number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use an iterator to reduce memory utilization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last line shows that our `small_list_of_numbers` is only `56` bytes in size.
    Also, it is a lazy method, as it did not generate all the elements. It will generate
    them one by one when asked, thus saving us time. In fact, if you omit the `times`
    keyword argument, then you can practically generate an infinite number of 1s.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Loop over the newly generated iterator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `enumerate` function so that we get the loop counter, along with
    the values. This will help us break once we reach a certain number of the counter
    (10 for example).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The output will be a list of 10 ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To look up the definition of any function, type the function name, followed
    by a *?* and press *Shift* + *Enter* in a Jupyter notebook. Run the following
    code to understand how we can use permutations and combinations with itertools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A stack is a very useful data structure. If you know a bit about CPU internals
    and how a program gets executed, then you have an idea that a stack is present
    in many such cases. It is simply a list with one restriction, Last In First Out
    (LIFO), meaning an element that comes in last goes out first when a value is read
    from a stack. The following illustration will make this a bit clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: A stack with two insert and one pop operation](img/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: A stack with two insert elements and one pop operation'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, we have a LIFO strategy to read values from a stack. We will
    implement a stack using a Python list. Python's lists have a method called `pop`,
    which does the exact same pop operation that you can see in the preceding illustration.
    We will use that to implement a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Implementing a Stack in Python'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, define an empty stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the append method to add an element in the stack. Thanks to append, the
    element will be always appended at the end of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append another value to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read a value from our stack using the `pop` method. This method reads at the
    current last index of the list and returns it to us. It also deletes the index
    once the read is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we execute the preceding code, we will have -12 in `tos` and the stack
    will have only one element in it, `25`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Append hello to the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Imagine you are scraping a web page and you want to follow each URL that is
    present there. If you insert (append) them one by one in a stack, while you read
    the web page, and then pop them one by one and follow the link, then you have
    a clean and extendable solution to the problem. We will examine part of this task
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Implementing a Stack Using User-Defined Methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will continue the topic of the stack from the last exercise. But this time,
    we will implement the `append` and `pop` functions by ourselves. The aim of this
    exercise is twofold. On one hand, we will implement the stack, and this time with
    a real-life example, which also involves knowledge of string methods and thus
    serves as a reminder of the last chapter and activity. On the other hand, it will
    show us a subtle feature of Python and how it handles passing list variables to
    functions, and will bring us to the next exercise, functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define two functions, `stack_push` and `stack_pop`. We renamed
    them so that we do not have a namespace conflict. Also, create a stack called
    `url_stack` for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first function takes the already existing stack and adds the value at the
    end of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the square brackets around the value to convert it in to a one-element
    list for the sake of the + operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second one reads the value that's currently at the `-1` index of the stack
    and then uses the `del` operator to delete that index, and finally returns the
    value it read earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we are going to have a string with a few URLs in it. Our job is to analyze
    the string so that we push the URLs in the stack one by one as we encounter them,
    and then finally use a for loop to pop them one by one. Let''s take the first
    line from the Wikipedia article about data science:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the sake of the simplicity of this exercise, we have kept the links in square
    brackets beside the target words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the length of the string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert this string into a list by using the `split` method from the string
    and then calculate its length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a for loop to go over each word and check whether it is a URL. To do that,
    we will use the `startswith` method from the string, and if it is a URL, then
    we push it into the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the value in `url_stack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterate over the list and print the URLs one by one by using the `stack_pop`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.2:  Output of the URLs printed using a stack](img/Figure_2.2.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.2: Output of the URLs that are printed using a stack'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Print it again to make sure that the stack is empty after the final for loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have noticed a strange phenomenon in the `stack_pop` method. We passed the
    list variable there, and we used the `del` operator inside the function, but it
    changed the original variable by deleting the last index each time we call the
    function. If you are coming from a language like C, C++, and Java, then this is
    a completely unexpected behavior, as in those languages this can only happen if
    we pass the variable by reference and it can lead to subtle bugs in Python code.
    So be careful. In general, it is not a good idea to change a variable's value
    in place, meaning inside a function. Any variable that's passed to the function
    should be considered and treated as immutable. This is close to the principles
    of functional programming. A lambda expression in Python is a way to construct
    one-line, nameless functions that are, by convention, side effect-free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18: Lambda Expression'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a lambda expression to prove the famous trigonometric
    identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 Trigonometric identity
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Import the `math` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define two functions, `my_sine` and `my_cosine`. The reason we are declaring
    these functions is because the original `sin` and `cos` functions from the math
    package take radians as input, but we are more familiar with degrees. So, we will
    use a lambda expression to define a nameless one-line function and use it. This
    lambda function will automatically convert our degree input to radians and then
    apply `sin` or `cos` on it and return the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `sine` and `cosine` for our purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we have assigned the return value from both `my_sine` and `my_cosine`
    to two variables, and then used them directly as the functions. It is a much cleaner
    approach than using them explicitly. Notice that we did not explicitly write a
    `return` statement inside the lambda function. It is assumed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 19: Lambda Expression for Sorting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The lambda expression will take an input and sort it according to the values
    in tuples. A lambda can take one or more inputs. A lambda expression can also
    be used to reverse sort by using the parameter of `reverse` as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you''re in a data wrangling job where you are confronted with the following
    list of tuples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sort this list by the name of the capitals of each country, using a simple
    lambda expression. Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, lambda expressions are powerful if we master them and use them
    in our data wrangling jobs. They are also side effect-free, meaning that they
    do not change the values of the variables that are passed to them in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Multi-Element Membership Checking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an interesting problem. Let''s imagine a list of a few words scraped
    from a text corpus you are working with:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `list_of_words` list with words scraped from a text corpus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find out whether this list contains all the elements from another list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There exists an elaborate solution, which involves a `for loop` and few if-else
    conditions (and you should try to write it!), but there also exists an elegant
    Pythonic solution to this problem, which takes one line and uses the `all` function.
    The `all` function returns `True` if all elements of the iterable are true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the `in` keyword to check membership in the list `list_of_words`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is indeed elegant and simple to reason about, and this neat trick is very
    important when dealing with lists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from stacks, another high-level data structure that we are interested
    in is queue. A queue is like a stack, meaning that you continue adding elements
    one by one. With a queue, the reading of elements obeys a FIFO (First In First
    Out) strategy. Check out the following diagram to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Pictorial representation of a queue](img/Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Pictorial representation of a queue'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We will accomplish this first using list methods and we will show you that for
    this purpose, it is inefficient. Then, we will learn about the `dequeue` data
    structure from the collection module of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Implementing a Queue in Python'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a Python queue with the plain list methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `pop` function to empty the queue and check items in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we use the `%%time` magic command while executing the preceding code, we
    will see that it takes a while to finish. In a modern MacBook, with a quad-core
    processor and 8 GB RAM, it took around 1.20 seconds to finish. This time is taken
    because of the `pop(0)` operation, which means every time we pop a value from
    the left of the list (which is the current 0 index), Python has to rearrange all
    the other elements of the list by shifting them one space left. Indeed, it is
    not a very optimized implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the same queue using the `deque` data structure from Python''s collection
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the specialized and optimized queue implementation from Python's standard
    library, the time that's taken for this operation is only in the range of 28 milliseconds!
    This is a huge improvement on the previous one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A queue is a very important data structure. To give one example from real life,
    we can think about a producer-consumer system design. While doing data wrangling,
    you will often come across a problem where you must process very big files. One
    of the ways to deal with this problem is to chunk the contents of the file in
    to smaller parts and then push them in to a queue while creating small, dedicated
    worker processes, which reads off the queue and processes one small chunk at a
    time. This is a very powerful design, and you can even use it efficiently to design
    huge multi-node data wrangling pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: We will end the discussion on data structures here. What we discussed here is
    just the tip of the iceberg. Data structures are a fascinating subject. There
    are many other data structures that we did not touch and which, when used efficiently,
    can offer enormous added value. We strongly encourage you to explore data structures
    more. Try to learn about linked lists, tree, graph, trie, and all the different
    variations of them as much as you can. Not only do they offer the joy of learning,
    but they are also the secret mega weapons in the arsenal of a data practitioner
    that you can bring out every time you are challenged with a difficult data wrangling
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Permutation, Iterator, Lambda, List'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, we will be using `permutations` to generate all possible three-digit
    numbers that can be generated using 0, 1, and 2\. Then, loop over this iterator,
    and also use `isinstance` and `assert` to make sure that the return types are
    tuples. Also, use a single line of code involving `dropwhile` and `lambda` expressions
    to convert all the tuples to lists while dropping any leading zeros (for example,
    (0, 1, 2) becomes [1, 2]). Finally, write a function that takes a list like before
    and returns the actual number contained in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will guide you to solve this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the definition of `permutations` and `dropwhile` from `itertools`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an expression to generate all the possible three-digit numbers using `0`,
    `1`, and `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop over the iterator expression you generated before. Print each element that's
    returned by the iterator. Use `assert` and `isinstance` to make sure that the
    elements are of the tuple type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the loop again using `dropwhile` with a lambda expression to drop any
    leading zeros from the tuples. As an example, `(0, 1, 2)` will become `[0, 2]`.
    Also, cast the output of `dropwhile` to a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the actual type that `dropwhile` returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combine the preceding code into one block, and this time write a separate function
    where you will pass the list generated from `dropwhile`, and the function will
    return the whole number contained in the list. As an example, if you pass `[1,
    2]` to the function, it will return `12`. Make sure that the return type is indeed
    a number and not a string. Although this task can be achieved using other tricks,
    we require that you treat the incoming list as a stack in the function and generate
    the number by reading the individual digits from the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this activity, we have finished this topic and we will head over to the
    next topic, which involves basic file-level operations. But before we leave this
    topic, we encourage you to think about a solution to the preceding problem without
    using all the advanced operations and data structures we have used here. You will
    soon realize how complex the naive solution is, and how much value these data
    structures and operations bring.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 289.
  prefs: []
  type: TYPE_NORMAL
- en: Basic File Operations in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous topic, we investigated a few advanced data structures and also
    learned neat and useful functional programming methods to manipulate them without
    side effects. In this topic, we will learn about a few operating system (OS)-level
    functions in Python. We will concentrate mainly on file-related functions and
    learn how to open a file, read the data line by line or all at once, and finally
    how to cleanly close the file we opened. We will apply a few of the techniques
    we have learned about on a file that we will read to practice our data wrangling
    skills further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: File Operations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will learn about the OS module of Python, and we will also
    see two very useful ways to write and read environment variables. The power of
    writing and reading environment variables is often very important while designing
    and developing data wrangling pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In fact, one of the factors of the famous 12-factor app design is the very
    idea of storing configuration in the environment. You can check it out at this
    URL: https://12factor.net/config.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the OS module is to give you ways to interact with operating
    system-dependent functionalities. In general, it is pretty low-level and most
    of the functions from there are not useful on a day-to-day basis, however, some
    are worth learning. `os.environ` is the collection Python maintains with all the
    present environment variables in your OS. It gives you the power to create new
    ones. The `os.getenv` function gives you the ability to read an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `os` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set few environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the environment variable when it is not set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the `os` environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The output has not been added for security reasons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After executing the preceding code, you will be able to see that you have successfully
    printed the value of `MY_KEY`, and when you tried to print `MY_KEY_NOT_SET`, it
    printed None.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: File Handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will learn about how to open a file in Python. We will
    learn about the different modes that we can use and what they stand for. Python
    has a built-in `open` function that we will use to open a file. The `open` function
    takes few arguments as input. Among them, the first one, which stands for the
    name of the file you want to open, is the only one that's mandatory. Everything
    else has a default value. When you call `open`, Python uses underlying system-level
    calls to open a file handler and will return it to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, a file can be opened either for reading or for writing. If we open
    a file in one mode, the other operation is not supported. Whereas reading usually
    means we start to read from the beginning of an existing file, writing can mean
    either starting a new file and writing from the beginning or opening an existing
    file and appending to it. Here is a table showing you all the different modes
    Python supports for opening a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 Modes to read a file](img/Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 Modes to read a file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There also exists a deprecated mode, `U`, which in a Python3 environment does
    nothing. One thing we must remember here is that Python will always differentiate
    between `t` and `b` modes, even if the underlying OS doesn't. This is because
    in `b` mode, Python does not try to decode what it is reading and gives us back
    the bytes object instead, whereas in `t` mode, it does try to decode the stream
    and gives us back the string representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open a file for reading like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is opened in `rt` mode. You can open the same file in binary mode if you
    want. To open the file in binary mode, use the `rb` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we open a file for writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 23: Opening and Closing a File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to close an open file. It is very important
    that we close a file once we open it. A lot of system-level bugs can occur due
    to a dangling file handler. Once we close a file, no further operations can be
    performed on that file using that specific file handler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a file in binary mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close a file using `close()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Python also gives us a `closed` flag with the file handler. If we print it before
    closing, then we will see `False`, whereas if we print it after closing, then
    we will see `True`. If our logic checks whether a file is properly closed or not,
    then this is the flag we want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `with` Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will learn about the `with` statement in Python and how
    we can effectively use it in the context of opening and closing files.
  prefs: []
  type: TYPE_NORMAL
- en: The `with` command is a compound statement in Python. Like any compound statement,
    `with` also affects the execution of the code enclosed by it. In the case of `with`,
    it is used to wrap a block of code in the scope of what we call a `Context Manager`
    in Python. A detailed discussion of the context manager is out of the scope of
    this exercise and this topic in general, but it is sufficient to say that thanks
    to a context manager implemented inside the `open` call for opening a file in
    Python, it is guaranteed that a close call will automatically happen if we wrap
    it inside a `with` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is an entire PEP for with at [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/).
    We encourage you to look into it.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a File Using the `with` Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open a file using the with statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If we execute the preceding code, we will see that the first print will end
    up printing `False`, whereas the second one will print `True`. This means that
    as soon as the control goes out of the `with` block, the file descriptor is automatically
    closed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is by far the cleanest and most Pythonic way to open a file and obtain
    a file descriptor for it. We encourage you to use this pattern whenever you need
    to open a file by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 24: Reading a File Line by Line'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open a file and then read the file line by line and print it as we read it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Fig 2.6: Screenshot from the Jupyter notebook](img/Figure_2.6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 2.6: Screenshot from the Jupyter notebook'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Looking at the preceding code, we can really see why it is important. With this
    small snippet of code, you can even open and read files that are many GBs in size,
    line by line, and without flooding or overrunning the system memory!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is another explicit method in the file descriptor object called `readline`,
    which reads one line at a time from a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Duplicate the same for loop, just after the first one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 2.7: Section of file opened](img/Figure_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Section of the open file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 25: Write to a File'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will end this topic on file operations by showing you how to write to a
    file. We will write a few lines to a file and read the file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `write` function from the file descriptor object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the print function to write to a file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note:'
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: In the second case, we did not add an extra newline character, \n, at the end
    of the string to be written. The print function does that automatically for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this, we will end this topic. Just like the previous topics, we have designed
    an activity for you to practice your newly acquired skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4: Design Your Own CSV Parser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CSV file is something you will encounter a lot in your life as a data practitioner.
    A CSV is a comma-separated file where data from a tabular format is generally
    stored and separated using commas, although other characters can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we will be tasked with building our own CSV reader and parser.
    Although it is a big task if we try to cover all use cases and edge cases, along
    with escape characters and all, for the sake of this small activity, we will keep
    our requirements small. We will assume that there is no escape character, meaning
    that if you use a comma at any place in your row, it means you are starting a
    new column. We will also assume that the only function we are interested in is
    to be able to read a CSV file line by line where each read will generate a new
    dict with the column names as keys and row names as values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 Table with sample data](img/Figure_2.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 Table with sample data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can convert the data in the preceding table into a Python dictionary, which
    would look as follows: `{"Name": "Bob", "Age": "24", "Location": "California"}`:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `zip_longest` from `itertools`. Create a function to zip `header`, `line`
    and `fillvalue=None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the accompanying `sales_record.csv` file from the GitHub link by using
    `r` mode inside a with block and first check that it is opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the first line and use string methods to generate a list of all the column
    names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start reading the file. Read it line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read each line and pass that line to a function, along with the list of the
    headers. The work of the function is to construct a dict out of these two and
    fill up the `key:values`. Keep in mind that a missing value should result in `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 291.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned about the workings of advanced data structures such
    as stacks and queues. We implemented and manipulated both stacks and queues. We
    then focused on different methods of functional programming, including iterators,
    and combined lists and functions together. After this, we looked at the `OS`-level
    functions and the management of environment variables and files. We also examined
    a clean way to deal with files, and we created our own CSV parser in the last
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be dealing with the three most important libraries,
    namely NumPy, pandas, and matplotlib.
  prefs: []
  type: TYPE_NORMAL
