- en: '*Chapter 2*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*'
- en: Advanced Data Structures and File Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据结构和文件处理
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Compare Python’s advanced data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较Python的高级数据结构
- en: Utilize data structures to solve real-world problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用数据结构解决现实世界问题
- en: Make use of OS file-handling operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用操作系统文件处理操作
- en: This chapter emphasizes the data structures in Python and the operating system
    functions that are the foundation of this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调Python中的数据结构和本书基础的操作系统的函数。
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引言
- en: We were introduced to the basic concepts of different fundamental data structures
    in the last chapter. We learned about the list, set, dict, tuple, and string.
    They are the building blocks of future chapters and are essential for data science.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了不同基本数据结构的基本概念。我们学习了列表、集合、字典、元组和字符串。它们是未来章节的基石，对于数据科学至关重要。
- en: However, what we have covered so far were only basic operations on them. They
    have much more to offer once you learn how to utilize them effectively. In this
    chapter, we will venture further into the land of data structures. We will learn
    about advanced operations and manipulations and use these fundamental data structures
    to represent more complex and higher-level data structures; this is often handy
    while wrangling data in real life.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止我们所涵盖的只是它们的基本操作。一旦你学会了如何有效地利用它们，它们将提供更多。在本章中，我们将进一步探索数据结构的世界。我们将学习高级操作和操作，并使用这些基本数据结构来表示更复杂和更高级的数据结构；这在现实生活中处理数据时非常有用。
- en: In real life, we deal with data that comes from different sources and generally
    read data from a file or a database. We will be introduced to operations related
    to files. We will see how to open a file and how many ways there are to do it,
    how to read data from it, how to write data to it, and how to safely close it
    once we are done. The last part, which many people tend to ignore, is super important.
    We often run into very strange and hard-to-track-down bugs in a real-world system
    just because a process opened a file and did not close it properly. Without further
    ado, let's begin our journey.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们处理来自不同来源的数据，通常从文件或数据库中读取数据。我们将介绍与文件相关的操作。我们将看到如何打开文件，以及有多少种方法可以做到这一点，如何从其中读取数据，如何写入数据，以及完成工作后如何安全地关闭它。最后一部分，许多人往往忽略，但非常重要。我们经常在现实世界的系统中遇到非常奇怪且难以追踪的bug，仅仅是因为一个进程打开了一个文件而没有正确关闭它。无需多言，让我们开始我们的旅程。
- en: Advanced Data Structures
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级数据结构
- en: We will start this chapter by discussing advanced data structures. We will do
    that by revisiting lists. We will construct a stack and a queue, explore multiple
    element membership checking, and throw a bit of functional programming in for
    good measure. If all of this sounds intimidating, then do not worry. We will get
    to things step by step, like in the previous chapter, and you will feel confident
    once you have finished this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论高级数据结构。我们将通过回顾列表来实现这一点。我们将构建一个栈和一个队列，探索多个元素成员资格检查，并加入一些函数式编程来增加趣味。如果这一切听起来令人生畏，那么请不要担心。我们将一步一步地完成，就像上一章一样，一旦你完成了这一章，你将感到自信。
- en: 'To start this chapter, you have to open an empty notebook. To do that, you
    can simply input the following command in a shell. It is advised that you first
    navigate to an empty directory using `cd` before you enter the command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章，你需要打开一个空白的笔记本。为此，你可以在shell中简单地输入以下命令。建议你在输入命令之前，首先使用`cd`命令导航到一个空目录：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the Docker container is running, point your browser to [http://localhost:8888](http://localhost:8888)
    and use `dw_4_all` as the passcode to access the notebook interface.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Docker容器启动，将你的浏览器指向[http://localhost:8888](http://localhost:8888)，并使用`dw_4_all`作为密码来访问笔记本界面。
- en: Iterator
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器
- en: We will start off this topic with lists. However, before we get into lists,
    we will introduce the concept of an iterator. An iterator is an object that implements
    the `next` method, meaning an iterator is an object that can iterate over a collection
    (lists, tuples, dicts, and so on). It is stateful, which means that each time
    we call the `next` method, it gives us the next element from the collection. And
    if there is no further element, then it raises a `StopIteration` exception.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个主题开始，即列表。然而，在我们进入列表之前，我们将介绍迭代器的概念。迭代器是一个实现了`next`方法的对象，这意味着迭代器是一个可以遍历集合（列表、元组、字典等）的对象。它是状态化的，这意味着每次我们调用`next`方法时，它都会从集合中给出下一个元素。如果没有更多的元素，那么它将引发`StopIteration`异常。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A `StopIteration` exception occurs with the iterator's next method when there
    are no further values to iterate.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的值可以迭代时，迭代器的`next`方法会引发`StopIteration`异常。
- en: 'If you are familiar with a programming language like C, C++, Java, JavaScript,
    or PHP, you may have noticed the difference between the `for` `loop` implementation
    in those languages, which consists of three distinct parts, precisely the initiation,
    the increment, and the termination condition, and the `for` `loop` in Python.
    In Python, we do not use that kind of for loop. What we use in Python is more
    like a `foreach` loop: `for` `i` `in` `list_1`. This is because, under the hood,
    the for loop is using an iterator, and thus we do not need to do all the extra
    steps. The iterator does this for us.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像C、C++、Java、JavaScript或PHP这样的编程语言，你可能已经注意到了这些语言中`for`循环实现的差异，它由三个不同的部分组成，即初始化、递增和终止条件，以及Python中的`for`循环。在Python中，我们不使用那种`for`循环。我们在Python中使用的是更类似于`foreach`循环的：`for`
    `i` `in` `list_1`。这是因为，在底层，`for`循环使用的是迭代器，所以我们不需要做所有额外的步骤。迭代器会为我们完成这些。
- en: 'Exercise 15: Introduction to the Iterator'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习15：迭代器简介
- en: 'To generate lists of numbers, we can use different methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成数字列表，我们可以使用不同的方法：
- en: 'Generate a list that will contain 10000000: ones:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个包含10000000个1的列表：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check the size of this variable:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这个变量的大小：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The value it will show you will be something around `81528056` (it is in bytes).
    This is a lot of memory! And the `big_list_of_numbers` variable is only available
    once the list comprehension is over. It can also overflow the available system
    memory if you try too big a number.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将显示的值将大约是`81528056`（它在字节中）。这很多内存！而且`big_list_of_numbers`变量只有在列表推导完成后才可用。如果你尝试太大的数字，它也可能超出可用系统内存。
- en: 'Use an iterator to reduce memory utilization:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用迭代器来减少内存使用：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last line shows that our `small_list_of_numbers` is only `56` bytes in size.
    Also, it is a lazy method, as it did not generate all the elements. It will generate
    them one by one when asked, thus saving us time. In fact, if you omit the `times`
    keyword argument, then you can practically generate an infinite number of 1s.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一行显示我们的`small_list_of_numbers`大小仅为`56`字节。此外，它是一种懒惰的方法，因为它没有生成所有元素。当需要时，它会逐个生成元素，从而节省我们的时间。实际上，如果你省略了`times`关键字参数，那么你可以实际生成无限数量的1。
- en: 'Loop over the newly generated iterator:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历新生成的迭代器：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the `enumerate` function so that we get the loop counter, along with
    the values. This will help us break once we reach a certain number of the counter
    (10 for example).
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`enumerate`函数，以便我们得到循环计数器以及值。这有助于我们在达到计数器的某个特定数量时（例如10）退出循环。
- en: The output will be a list of 10 ones.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将是一个包含10个1的列表。
- en: 'To look up the definition of any function, type the function name, followed
    by a *?* and press *Shift* + *Enter* in a Jupyter notebook. Run the following
    code to understand how we can use permutations and combinations with itertools:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找任何函数的定义，在Jupyter笔记本中输入函数名，然后输入一个*?*并按*Shift* + *Enter*。运行以下代码以了解我们如何使用itertools中的排列和组合：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Stacks
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: 'A stack is a very useful data structure. If you know a bit about CPU internals
    and how a program gets executed, then you have an idea that a stack is present
    in many such cases. It is simply a list with one restriction, Last In First Out
    (LIFO), meaning an element that comes in last goes out first when a value is read
    from a stack. The following illustration will make this a bit clearer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个非常有用的数据结构。如果你对CPU内部结构和程序执行方式有些了解，那么你会意识到栈在很多这种情况下都存在。它只是一个具有一个限制条件的列表，即后进先出（LIFO），这意味着当从栈中读取值时，最后进入的元素会首先出来。以下插图将使这一点更加清晰：
- en: '![Figure 2.1: A stack with two insert and one pop operation](img/Figure_2.1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：进行两次插入和一次弹出操作的栈](img/Figure_2.1.jpg)'
- en: 'Figure 2.1: A stack with two insert elements and one pop operation'
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.1：进行两次插入元素和一次弹出操作的栈
- en: As you can see, we have a LIFO strategy to read values from a stack. We will
    implement a stack using a Python list. Python's lists have a method called `pop`,
    which does the exact same pop operation that you can see in the preceding illustration.
    We will use that to implement a stack.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个后进先出（LIFO）策略来从栈中读取值。我们将使用 Python 列表来实现栈。Python 的列表有一个名为 `pop` 的方法，它执行与前面插图中所见相同的弹出操作。我们将使用它来实现栈。
- en: 'Exercise 16: Implementing a Stack in Python'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 16：在 Python 中实现栈
- en: 'First, define an empty stack:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义一个空栈：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the append method to add an element in the stack. Thanks to append, the
    element will be always appended at the end of the list:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 append 方法向栈中添加一个元素。多亏了 append，元素将始终追加到列表的末尾：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Append another value to the stack:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向栈中追加另一个值：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Read a value from our stack using the `pop` method. This method reads at the
    current last index of the list and returns it to us. It also deletes the index
    once the read is done:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pop` 方法从我们的栈中读取一个值。此方法读取当前列表的最后一个索引，并将其返回给我们。读取完成后，它也会删除该索引：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After we execute the preceding code, we will have -12 in `tos` and the stack
    will have only one element in it, `25`.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行前面的代码后，`tos` 中将会有 -12，栈中只有一个元素，即 `25`。
- en: 'Append hello to the stack:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向栈中追加 "hello"：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Imagine you are scraping a web page and you want to follow each URL that is
    present there. If you insert (append) them one by one in a stack, while you read
    the web page, and then pop them one by one and follow the link, then you have
    a clean and extendable solution to the problem. We will examine part of this task
    in the next exercise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在抓取一个网页，并且想要跟随其中存在的每个 URL。如果你在阅读网页时逐个将它们（追加）插入栈中，然后逐个弹出并跟随链接，那么你就有了一个干净且可扩展的解决方案。我们将在下一个练习中检查这个任务的这部分。
- en: 'Exercise 17: Implementing a Stack Using User-Defined Methods'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 17：使用用户定义的方法实现栈
- en: 'We will continue the topic of the stack from the last exercise. But this time,
    we will implement the `append` and `pop` functions by ourselves. The aim of this
    exercise is twofold. On one hand, we will implement the stack, and this time with
    a real-life example, which also involves knowledge of string methods and thus
    serves as a reminder of the last chapter and activity. On the other hand, it will
    show us a subtle feature of Python and how it handles passing list variables to
    functions, and will bring us to the next exercise, functional programming:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续从上一个练习中关于栈的话题。但这次，我们将自己实现 `append` 和 `pop` 函数。这个练习的目标有两个。一方面，我们将实现栈，这次是一个真实世界的例子，这也涉及到对字符串方法的知识，因此也作为对上一章和活动的提醒。另一方面，它将向我们展示
    Python 的一个微妙特性以及它是如何处理将列表变量传递给函数的，并将我们带到下一个练习，即函数式编程：
- en: 'First, we will define two functions, `stack_push` and `stack_pop`. We renamed
    them so that we do not have a namespace conflict. Also, create a stack called
    `url_stack` for later use:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义两个函数，`stack_push` 和 `stack_pop`。我们将其重命名，以避免命名空间冲突。同时，创建一个名为 `url_stack`
    的栈以供以后使用：
- en: '[PRE15]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first function takes the already existing stack and adds the value at the
    end of it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个函数接受已经存在的栈，并将值添加到其末尾。
- en: Note
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the square brackets around the value to convert it in to a one-element
    list for the sake of the + operation.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意值周围的方括号，这是为了将其转换为单元素列表，以便进行 + 操作。
- en: The second one reads the value that's currently at the `-1` index of the stack
    and then uses the `del` operator to delete that index, and finally returns the
    value it read earlier.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数读取栈中当前 `-1` 索引处的值，然后使用 `del` 操作符删除该索引，并最终返回它之前读取的值。
- en: 'Now, we are going to have a string with a few URLs in it. Our job is to analyze
    the string so that we push the URLs in the stack one by one as we encounter them,
    and then finally use a for loop to pop them one by one. Let''s take the first
    line from the Wikipedia article about data science:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将有一个包含几个 URL 的字符串。我们的任务是分析这个字符串，当我们遇到 URL 时，逐个将它们推入栈中，然后最终使用 for 循环逐个弹出。让我们从关于数据科学的维基百科文章的第一行开始：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the sake of the simplicity of this exercise, we have kept the links in square
    brackets beside the target words.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化这个练习，我们在目标词旁边保留了方括号中的链接。
- en: 'Find the length of the string:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找字符串的长度：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Convert this string into a list by using the `split` method from the string
    and then calculate its length:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串的 `split` 方法将此字符串转换为列表，然后计算其长度：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use a for loop to go over each word and check whether it is a URL. To do that,
    we will use the `startswith` method from the string, and if it is a URL, then
    we push it into the stack:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 for 循环遍历每个单词并检查它是否是 URL。为此，我们将使用字符串的 `startswith` 方法，如果是 URL，则将其推入栈中：
- en: '[PRE21]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Print the value in `url_stack`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `url_stack` 中的值：
- en: '[PRE22]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Iterate over the list and print the URLs one by one by using the `stack_pop`
    function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历列表并使用 `stack_pop` 函数逐个打印 URL：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.2:  Output of the URLs printed using a stack](img/Figure_2.2.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 2.2：使用栈打印的 URL 输出](img/Figure_2.2.jpg)'
- en: 'Figure 2.2: Output of the URLs that are printed using a stack'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.2：使用栈打印的 URL 输出
- en: 'Print it again to make sure that the stack is empty after the final for loop:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打印以确保在最后的 for 循环之后栈为空：
- en: '[PRE25]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have noticed a strange phenomenon in the `stack_pop` method. We passed the
    list variable there, and we used the `del` operator inside the function, but it
    changed the original variable by deleting the last index each time we call the
    function. If you are coming from a language like C, C++, and Java, then this is
    a completely unexpected behavior, as in those languages this can only happen if
    we pass the variable by reference and it can lead to subtle bugs in Python code.
    So be careful. In general, it is not a good idea to change a variable's value
    in place, meaning inside a function. Any variable that's passed to the function
    should be considered and treated as immutable. This is close to the principles
    of functional programming. A lambda expression in Python is a way to construct
    one-line, nameless functions that are, by convention, side effect-free.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `stack_pop` 方法中注意到一个奇怪的现象。我们传递了列表变量到那里，并在函数内部使用了 `del` 操作符，但每次调用函数时都会通过删除最后一个索引来改变原始变量。如果你来自像
    C、C++ 和 Java 这样的语言，那么这完全是一个意外的行为，因为在那些语言中，这只能通过引用传递变量来实现，这可能导致 Python 代码中的微妙错误。所以请小心。一般来说，在函数内部更改变量的值不是一个好主意，这意味着在函数内部。传递给函数的任何变量都应被视为不可变的。这接近函数式编程的原则。Python
    中的 lambda 表达式是一种构建单行、无名的函数的方法，按照惯例，这些函数是副作用免费的。
- en: 'Exercise 18: Lambda Expression'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 18：Lambda 表达式
- en: 'In this exercise, we will use a lambda expression to prove the famous trigonometric
    identity:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 lambda 表达式来证明著名的三角恒等式：
- en: '![](img/Figure_2.3.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.3.jpg)'
- en: Figure 2.3 Trigonometric identity
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.3 三角恒等式
- en: 'Import the `math` package:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `math` 包：
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define two functions, `my_sine` and `my_cosine`. The reason we are declaring
    these functions is because the original `sin` and `cos` functions from the math
    package take radians as input, but we are more familiar with degrees. So, we will
    use a lambda expression to define a nameless one-line function and use it. This
    lambda function will automatically convert our degree input to radians and then
    apply `sin` or `cos` on it and return the value:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个函数，`my_sine` 和 `my_cosine`。我们声明这些函数的原因是，来自 math 包的原始 `sin` 和 `cos` 函数以弧度为输入，但我们更熟悉度。因此，我们将使用
    lambda 表达式定义一个无名的单行函数并使用它。这个 lambda 函数将自动将我们的度数输入转换为弧度，然后对其应用 `sin` 或 `cos` 并返回值：
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define `sine` and `cosine` for our purpose:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `sine` 和 `cosine` 以满足我们的目的：
- en: '[PRE29]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we have assigned the return value from both `my_sine` and `my_cosine`
    to two variables, and then used them directly as the functions. It is a much cleaner
    approach than using them explicitly. Notice that we did not explicitly write a
    `return` statement inside the lambda function. It is assumed.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们将 `my_sine` 和 `my_cosine` 的返回值分配给两个变量，然后直接使用它们作为函数。这比显式使用它们的方法要干净得多。注意，我们并没有在
    lambda 函数中显式地写一个 `return` 语句。这是默认的。
- en: 'Exercise 19: Lambda Expression for Sorting'
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 19：排序的 Lambda 表达式
- en: 'The lambda expression will take an input and sort it according to the values
    in tuples. A lambda can take one or more inputs. A lambda expression can also
    be used to reverse sort by using the parameter of `reverse` as `True`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式将接受一个输入并根据元组中的值对其进行排序。Lambda 可以接受一个或多个输入。Lambda 表达式也可以通过使用 `reverse`
    参数为 `True` 来实现逆序排序：
- en: 'Imagine you''re in a data wrangling job where you are confronted with the following
    list of tuples:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象你在一个数据清洗工作中，你面临以下元组列表：
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output will be as follows:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Sort this list by the name of the capitals of each country, using a simple
    lambda expression. Use the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简单的 lambda 表达式按每个国家的首都名称对列表进行排序。使用以下代码：
- en: '[PRE33]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will be as follows:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, lambda expressions are powerful if we master them and use them
    in our data wrangling jobs. They are also side effect-free, meaning that they
    do not change the values of the variables that are passed to them in place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，如果我们掌握了 lambda 表达式并在我们数据清洗工作中使用它们，它们是非常强大的。它们也是无副作用的，这意味着它们不会改变传递给它们的变量的值。
- en: 'Exercise 20: Multi-Element Membership Checking'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 20：多元素成员资格检查
- en: 'Here is an interesting problem. Let''s imagine a list of a few words scraped
    from a text corpus you are working with:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题。让我们想象一下，你从你正在处理的一个文本语料库中抓取的一些单词列表：
- en: 'Create a `list_of_words` list with words scraped from a text corpus:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `list_of_words` 列表，其中包含从文本语料库中抓取的单词：
- en: '[PRE35]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find out whether this list contains all the elements from another list:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找此列表是否包含另一个列表的所有元素：
- en: '[PRE36]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There exists an elaborate solution, which involves a `for loop` and few if-else
    conditions (and you should try to write it!), but there also exists an elegant
    Pythonic solution to this problem, which takes one line and uses the `all` function.
    The `all` function returns `True` if all elements of the iterable are true.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在一个复杂的解决方案，它涉及一个 `for` 循环和几个 if-else 条件（你应该尝试编写它！），但还有一个优雅的 Pythonic 解决方案来解决这个问题，它只需要一行代码并使用
    `all` 函数。`all` 函数在可迭代对象的所有元素都为真时返回 `True`。
- en: 'Using the `in` keyword to check membership in the list `list_of_words`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `in` 关键字检查列表 `list_of_words` 中的成员资格：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is indeed elegant and simple to reason about, and this neat trick is very
    important when dealing with lists.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它确实既优雅又简单，这个巧妙的小技巧在处理列表时非常重要。
- en: Queue
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列
- en: 'Apart from stacks, another high-level data structure that we are interested
    in is queue. A queue is like a stack, meaning that you continue adding elements
    one by one. With a queue, the reading of elements obeys a FIFO (First In First
    Out) strategy. Check out the following diagram to understand this better:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了栈之外，我们感兴趣的另一个高级数据结构是队列。队列就像栈一样，意味着你一个接一个地添加元素。使用队列时，元素的读取遵循 FIFO（先进先出）策略。查看以下图表以更好地理解这一点：
- en: '![Figure 2.4: Pictorial representation of a queue](img/Figure_2.4.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4：队列的示意图](img/Figure_2.4.jpg)'
- en: 'Figure 2.4: Pictorial representation of a queue'
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.4：队列的示意图
- en: We will accomplish this first using list methods and we will show you that for
    this purpose, it is inefficient. Then, we will learn about the `dequeue` data
    structure from the collection module of Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用列表方法来完成这个任务，然后我们会向你展示这样做是不高效的。然后，我们将从 Python 的集合模块中学习 `dequeue` 数据结构。
- en: 'Exercise 21: Implementing a Queue in Python'
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 21：在 Python 中实现队列
- en: 'Create a Python queue with the plain list methods:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纯列表方法创建一个 Python 队列：
- en: '[PRE39]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE40]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `pop` function to empty the queue and check items in it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `pop` 函数清空队列并检查其中的项目：
- en: '[PRE41]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we use the `%%time` magic command while executing the preceding code, we
    will see that it takes a while to finish. In a modern MacBook, with a quad-core
    processor and 8 GB RAM, it took around 1.20 seconds to finish. This time is taken
    because of the `pop(0)` operation, which means every time we pop a value from
    the left of the list (which is the current 0 index), Python has to rearrange all
    the other elements of the list by shifting them one space left. Indeed, it is
    not a very optimized implementation.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们在执行前面的代码时使用 `%%time` 魔法命令，我们会看到它需要一段时间才能完成。在一个现代 MacBook 上，具有四核处理器和 8 GB
    RAM，它大约需要 1.20 秒才能完成。这种时间是因为 `pop(0)` 操作，这意味着每次我们从列表的左侧（当前 0 索引）弹出值时，Python 都必须通过将其他所有元素向左移动一个位置来重新排列列表的所有其他元素。确实，这不是一个非常优化的实现。
- en: 'Implement the same queue using the `deque` data structure from Python''s collection
    package:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python集合包中的`deque`数据结构实现相同的队列：
- en: '[PRE43]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the specialized and optimized queue implementation from Python's standard
    library, the time that's taken for this operation is only in the range of 28 milliseconds!
    This is a huge improvement on the previous one.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python标准库中的专业和优化队列实现，这个操作所需的时间仅为28毫秒！这比之前有了巨大的改进。
- en: A queue is a very important data structure. To give one example from real life,
    we can think about a producer-consumer system design. While doing data wrangling,
    you will often come across a problem where you must process very big files. One
    of the ways to deal with this problem is to chunk the contents of the file in
    to smaller parts and then push them in to a queue while creating small, dedicated
    worker processes, which reads off the queue and processes one small chunk at a
    time. This is a very powerful design, and you can even use it efficiently to design
    huge multi-node data wrangling pipelines.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个非常重要的数据结构。为了举一个现实生活中的例子，我们可以考虑一个生产者-消费者系统设计。在进行数据处理时，你经常会遇到必须处理非常大的文件的问题。处理这个问题的方法之一是将文件内容分成更小的部分，然后在创建小的、专门的工人进程时将它们推入队列，这些进程一次读取队列中的一小部分进行处理。这是一个非常强大的设计，你甚至可以有效地使用它来设计巨大的多节点数据处理管道。
- en: We will end the discussion on data structures here. What we discussed here is
    just the tip of the iceberg. Data structures are a fascinating subject. There
    are many other data structures that we did not touch and which, when used efficiently,
    can offer enormous added value. We strongly encourage you to explore data structures
    more. Try to learn about linked lists, tree, graph, trie, and all the different
    variations of them as much as you can. Not only do they offer the joy of learning,
    but they are also the secret mega weapons in the arsenal of a data practitioner
    that you can bring out every time you are challenged with a difficult data wrangling
    job.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里结束对数据结构的讨论。我们在这里讨论的只是冰山一角。数据结构是一个迷人的主题。还有许多其他的数据结构我们没有涉及，而且当它们被有效地使用时，可以提供巨大的附加价值。我们强烈鼓励你更多地探索数据结构。尽量了解链表、树、图、字典树以及它们的所有不同变体。它们不仅提供了学习的乐趣，而且也是数据从业者武器库中的秘密超级武器，你可以在每次面对困难的数据处理任务时使用它们。
- en: 'Activity 3: Permutation, Iterator, Lambda, List'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动3：排列、迭代器、Lambda、列表
- en: In this activity, we will be using `permutations` to generate all possible three-digit
    numbers that can be generated using 0, 1, and 2\. Then, loop over this iterator,
    and also use `isinstance` and `assert` to make sure that the return types are
    tuples. Also, use a single line of code involving `dropwhile` and `lambda` expressions
    to convert all the tuples to lists while dropping any leading zeros (for example,
    (0, 1, 2) becomes [1, 2]). Finally, write a function that takes a list like before
    and returns the actual number contained in it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用`permutations`生成所有可能的由0、1和2组成的三位数。然后遍历这个迭代器，并使用`isinstance`和`assert`确保返回类型是元组。同时，使用涉及`dropwhile`和`lambda`表达式的单行代码将所有元组转换为列表，同时删除任何前导零（例如，`(0,
    1, 2)`变为`[1, 2]`）。最后，编写一个函数，它接受一个列表作为输入，并返回其中包含的实际数字。
- en: 'These steps will guide you to solve this activity:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将指导你解决这个活动：
- en: Look up the definition of `permutations` and `dropwhile` from `itertools`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`permutations`和`dropwhile`的定义，来自`itertools`。
- en: Write an expression to generate all the possible three-digit numbers using `0`,
    `1`, and `2`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个表达式，使用`0`、`1`和`2`生成所有可能的三位数。
- en: Loop over the iterator expression you generated before. Print each element that's
    returned by the iterator. Use `assert` and `isinstance` to make sure that the
    elements are of the tuple type.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历之前生成的迭代器表达式。打印迭代器返回的每个元素。使用`assert`和`isinstance`确保元素是元组类型。
- en: Write the loop again using `dropwhile` with a lambda expression to drop any
    leading zeros from the tuples. As an example, `(0, 1, 2)` will become `[0, 2]`.
    Also, cast the output of `dropwhile` to a list.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`dropwhile`和Lambda表达式编写循环，以删除元组中的任何前导零。例如，`(0, 1, 2)`将变为`[0, 2]`。同时，将`dropwhile`的输出转换为列表。
- en: Check the actual type that `dropwhile` returns.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`dropwhile`实际返回的类型。
- en: Combine the preceding code into one block, and this time write a separate function
    where you will pass the list generated from `dropwhile`, and the function will
    return the whole number contained in the list. As an example, if you pass `[1,
    2]` to the function, it will return `12`. Make sure that the return type is indeed
    a number and not a string. Although this task can be achieved using other tricks,
    we require that you treat the incoming list as a stack in the function and generate
    the number by reading the individual digits from the stack.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的代码合并到一个块中，这次编写一个单独的函数，你将传递由`dropwhile`生成的列表，该函数将返回列表中的整个数字。例如，如果你将`[1, 2]`传递给函数，它将返回`12`。确保返回类型确实是一个数字而不是字符串。尽管这个任务可以使用其他技巧完成，但我们要求你在函数中将传入的列表视为一个栈，并通过读取栈中的各个数字来生成数字。
- en: With this activity, we have finished this topic and we will head over to the
    next topic, which involves basic file-level operations. But before we leave this
    topic, we encourage you to think about a solution to the preceding problem without
    using all the advanced operations and data structures we have used here. You will
    soon realize how complex the naive solution is, and how much value these data
    structures and operations bring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个活动，我们已经完成了这个主题，我们将转向下一个主题，该主题涉及基本的文件级操作。但在我们离开这个主题之前，我们鼓励你考虑一个解决方案来解决这个问题，而不使用我们在这里使用的所有高级操作和数据结构。你很快就会意识到原始解决方案是多么复杂，以及这些数据结构和操作带来了多大的价值。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 289.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第289页找到。
- en: Basic File Operations in Python
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的基本文件操作
- en: In the previous topic, we investigated a few advanced data structures and also
    learned neat and useful functional programming methods to manipulate them without
    side effects. In this topic, we will learn about a few operating system (OS)-level
    functions in Python. We will concentrate mainly on file-related functions and
    learn how to open a file, read the data line by line or all at once, and finally
    how to cleanly close the file we opened. We will apply a few of the techniques
    we have learned about on a file that we will read to practice our data wrangling
    skills further.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个主题中，我们研究了一些高级数据结构，并且学习了整洁且有用的函数式编程方法来无副作用地操作它们。在本主题中，我们将学习Python中的一些操作系统（OS）级函数。我们将主要关注与文件相关的函数，学习如何打开文件，逐行读取数据或一次性读取所有数据，最后如何干净地关闭我们打开的文件。我们将应用我们学到的一些技术，在一个我们将要读取的文件上进一步练习我们的数据处理技能。
- en: 'Exercise 22: File Operations'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习22：文件操作
- en: In this exercise, we will learn about the OS module of Python, and we will also
    see two very useful ways to write and read environment variables. The power of
    writing and reading environment variables is often very important while designing
    and developing data wrangling pipelines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习Python的OS模块，我们还将看到两种非常实用的方法来写入和读取环境变量。在设计和开发数据处理管道时，写入和读取环境变量的能力通常非常重要。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In fact, one of the factors of the famous 12-factor app design is the very
    idea of storing configuration in the environment. You can check it out at this
    URL: https://12factor.net/config.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，著名12因子应用程序设计的因素之一就是将配置存储在环境中的想法。你可以在以下URL查看：https://12factor.net/config。
- en: 'The purpose of the OS module is to give you ways to interact with operating
    system-dependent functionalities. In general, it is pretty low-level and most
    of the functions from there are not useful on a day-to-day basis, however, some
    are worth learning. `os.environ` is the collection Python maintains with all the
    present environment variables in your OS. It gives you the power to create new
    ones. The `os.getenv` function gives you the ability to read an environment variable:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: OS模块的目的是为你提供与操作系统依赖功能交互的方法。一般来说，它是相当底层的，而且大多数来自那里的函数在日常使用中并不有用，然而，其中一些是值得学习的。`os.environ`是Python维护的包含你操作系统中的所有当前环境变量的集合。它赋予你创建新环境变量的能力。`os.getenv`函数让你能够读取一个环境变量：
- en: Import the `os` module.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`os`模块。
- en: '[PRE45]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Set few environment variables:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一些环境变量：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Print the environment variable when it is not set:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当环境变量未设置时打印环境变量：
- en: '[PRE48]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output is as follows:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Print the `os` environment:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`os`环境：
- en: '[PRE50]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The output has not been added for security reasons.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于安全原因，输出尚未添加。
- en: After executing the preceding code, you will be able to see that you have successfully
    printed the value of `MY_KEY`, and when you tried to print `MY_KEY_NOT_SET`, it
    printed None.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行前面的代码后，你会看到你已成功打印了 `MY_KEY` 的值，当你尝试打印 `MY_KEY_NOT_SET` 时，它打印了 `None`。
- en: File Handling
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件处理
- en: In this exercise, we will learn about how to open a file in Python. We will
    learn about the different modes that we can use and what they stand for. Python
    has a built-in `open` function that we will use to open a file. The `open` function
    takes few arguments as input. Among them, the first one, which stands for the
    name of the file you want to open, is the only one that's mandatory. Everything
    else has a default value. When you call `open`, Python uses underlying system-level
    calls to open a file handler and will return it to the caller.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将了解如何在 Python 中打开文件。我们将了解我们可以使用的不同模式以及它们代表的意义。Python 有一个内置的 `open`
    函数，我们将使用它来打开文件。`open` 函数接受一些输入参数。其中，第一个参数代表你想要打开的文件名，是唯一必须的。其他所有内容都有默认值。当你调用 `open`
    时，Python 使用底层系统级调用打开文件句柄，并将其返回给调用者。
- en: 'Usually, a file can be opened either for reading or for writing. If we open
    a file in one mode, the other operation is not supported. Whereas reading usually
    means we start to read from the beginning of an existing file, writing can mean
    either starting a new file and writing from the beginning or opening an existing
    file and appending to it. Here is a table showing you all the different modes
    Python supports for opening a file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件可以以读取或写入模式打开。如果我们以某种模式打开一个文件，则不支持其他操作。读取通常意味着我们从现有文件的开始处开始读取，而写入可以意味着从文件开始处创建新文件并写入，或者打开现有文件并附加到它。以下是一个表格，展示了
    Python 支持的所有不同文件打开模式：
- en: '![Figure 2.5 Modes to read a file](img/Figure_2.5.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 读取文件的模式](img/Figure_2.5.jpg)'
- en: Figure 2.5 Modes to read a file
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.5 读取文件的模式
- en: There also exists a deprecated mode, `U`, which in a Python3 environment does
    nothing. One thing we must remember here is that Python will always differentiate
    between `t` and `b` modes, even if the underlying OS doesn't. This is because
    in `b` mode, Python does not try to decode what it is reading and gives us back
    the bytes object instead, whereas in `t` mode, it does try to decode the stream
    and gives us back the string representation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个已弃用的模式 `U`，在 Python3 环境中不起作用。我们必须记住的一件事是，Python 总是会区分 `t` 和 `b` 模式，即使底层操作系统不会。这是因为
    `b` 模式下，Python 不会尝试解码它所读取的内容，而是返回字节对象，而在 `t` 模式下，它会尝试解码流并返回字符串表示。
- en: 'You can open a file for reading like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样打开一个文件进行读取：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is opened in `rt` mode. You can open the same file in binary mode if you
    want. To open the file in binary mode, use the `rb` mode:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是以 `rt` 模式打开的。如果你想以二进制模式打开相同的文件，也可以。要以二进制模式打开文件，请使用 `rb` 模式：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is how we open a file for writing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们以写入模式打开文件的方式：
- en: '[PRE54]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Exercise 23: Opening and Closing a File'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 23：打开和关闭文件
- en: 'In this exercise, we will learn how to close an open file. It is very important
    that we close a file once we open it. A lot of system-level bugs can occur due
    to a dangling file handler. Once we close a file, no further operations can be
    performed on that file using that specific file handler:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将了解如何关闭打开的文件。一旦我们打开文件，关闭它非常重要。由于悬挂的文件句柄，可能会发生许多系统级错误。一旦我们关闭文件，就无法使用该特定的文件句柄在该文件上执行任何进一步的操作：
- en: 'Open a file in binary mode:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以二进制模式打开文件：
- en: '[PRE56]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Close a file using `close()`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `close()` 关闭文件：
- en: '[PRE57]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Python also gives us a `closed` flag with the file handler. If we print it before
    closing, then we will see `False`, whereas if we print it after closing, then
    we will see `True`. If our logic checks whether a file is properly closed or not,
    then this is the flag we want to use.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 还为我们提供了一个与文件句柄一起的 `closed` 标志。如果我们关闭前打印它，那么我们会看到 `False`，而如果我们关闭后打印它，那么我们会看到
    `True`。如果我们逻辑上检查文件是否已正确关闭，那么这就是我们想要使用的标志。
- en: The `with` Statement
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`with` 语句'
- en: In this exercise, we will learn about the `with` statement in Python and how
    we can effectively use it in the context of opening and closing files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将了解 Python 中的 `with` 语句以及我们如何在打开和关闭文件的情况下有效地使用它。
- en: The `with` command is a compound statement in Python. Like any compound statement,
    `with` also affects the execution of the code enclosed by it. In the case of `with`,
    it is used to wrap a block of code in the scope of what we call a `Context Manager`
    in Python. A detailed discussion of the context manager is out of the scope of
    this exercise and this topic in general, but it is sufficient to say that thanks
    to a context manager implemented inside the `open` call for opening a file in
    Python, it is guaranteed that a close call will automatically happen if we wrap
    it inside a `with` statement.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的 `with` 命令是一个复合语句。像任何复合语句一样，`with` 也会影响其内部代码的执行。在 `with` 的情况下，它用于将一段代码包裹在所谓的
    Python 中的 `上下文管理器` 的作用域内。关于上下文管理器的详细讨论超出了本练习和这个主题的范围，但可以说，多亏了在 Python 中打开文件时 `open`
    调用内部实现的上下文管理器，当我们用 `with` 语句包裹它时，可以保证会自动发生关闭调用。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There is an entire PEP for with at [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/).
    We encourage you to look into it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `with` 的整个 PEP 可以在 [https://www.python.org/dev/peps/pep-0343/](https://www.python.org/dev/peps/pep-0343/)
    找到。我们鼓励您去查看。
- en: Opening a File Using the `with` Statement
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `with` 语句打开文件
- en: 'Open a file using the with statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 语句打开一个文件：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we execute the preceding code, we will see that the first print will end
    up printing `False`, whereas the second one will print `True`. This means that
    as soon as the control goes out of the `with` block, the file descriptor is automatically
    closed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，我们会看到第一个打印将结束打印 `False`，而第二个将打印 `True`。这意味着一旦控制流出 `with` 块，文件描述符将自动关闭。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This is by far the cleanest and most Pythonic way to open a file and obtain
    a file descriptor for it. We encourage you to use this pattern whenever you need
    to open a file by yourself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这无疑是打开文件并获得文件描述符的最干净、最 Pythonic 的方式。我们鼓励您在需要自己打开文件时始终使用此模式。
- en: 'Exercise 24: Reading a File Line by Line'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 24：逐行读取文件
- en: 'Open a file and then read the file line by line and print it as we read it:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文件，然后逐行读取文件并打印出来，就像我们读取它一样：
- en: '[PRE60]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output is as follows:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Fig 2.6: Screenshot from the Jupyter notebook](img/Figure_2.6.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 2.6：Jupyter 笔记本截图](img/Figure_2.6.jpg)'
- en: 'Figure 2.6: Screenshot from the Jupyter notebook'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.6：Jupyter 笔记本截图
- en: Looking at the preceding code, we can really see why it is important. With this
    small snippet of code, you can even open and read files that are many GBs in size,
    line by line, and without flooding or overrunning the system memory!
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过查看前面的代码，我们可以真正地看到为什么这很重要。通过这段简短的代码，你甚至可以逐行打开和读取大小为许多 GB 的文件，而不会淹没或超出系统内存！
- en: There is another explicit method in the file descriptor object called `readline`,
    which reads one line at a time from a file.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件描述符对象中还有一个名为 `readline` 的显式方法，它一次从文件中读取一行。
- en: 'Duplicate the same for loop, just after the first one:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个循环之后立即复制相同的 for 循环：
- en: '[PRE61]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output is as follows:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 2.7: Section of file opened](img/Figure_2.6.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7：打开文件的部分](img/Figure_2.6.jpg)'
- en: 'Figure 2.7: Section of the open file'
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.7：打开文件的部分
- en: 'Exercise 25: Write to a File'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 25：写入文件
- en: 'We will end this topic on file operations by showing you how to write to a
    file. We will write a few lines to a file and read the file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向您展示如何写入文件来结束关于文件操作的主题。我们将写入几行到文件中，并读取该文件：
- en: 'Use the `write` function from the file descriptor object:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件描述符对象的 `write` 函数：
- en: '[PRE62]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Read the file using the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令读取文件：
- en: '[PRE63]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE64]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use the print function to write to a file using the following command:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使用打印函数写入文件：
- en: '[PRE65]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Read the file using the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令读取文件：
- en: '[PRE66]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note:'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: In the second case, we did not add an extra newline character, \n, at the end
    of the string to be written. The print function does that automatically for us.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们没有在要写入的字符串末尾添加额外的换行符，\n，打印函数会自动为我们完成这个操作。
- en: With this, we will end this topic. Just like the previous topics, we have designed
    an activity for you to practice your newly acquired skills.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们将结束这个主题。就像前面的主题一样，我们为您设计了一个活动来练习您新获得的知识。
- en: 'Activity 4: Design Your Own CSV Parser'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 4：设计您自己的 CSV 解析器
- en: A CSV file is something you will encounter a lot in your life as a data practitioner.
    A CSV is a comma-separated file where data from a tabular format is generally
    stored and separated using commas, although other characters can also be used.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为数据从业者的一生中，你将经常遇到 CSV 文件。CSV 是一个以逗号分隔的文件，其中通常存储和分隔表格格式的数据，尽管也可以使用其他字符。
- en: In this activity, we will be tasked with building our own CSV reader and parser.
    Although it is a big task if we try to cover all use cases and edge cases, along
    with escape characters and all, for the sake of this small activity, we will keep
    our requirements small. We will assume that there is no escape character, meaning
    that if you use a comma at any place in your row, it means you are starting a
    new column. We will also assume that the only function we are interested in is
    to be able to read a CSV file line by line where each read will generate a new
    dict with the column names as keys and row names as values.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将被要求构建自己的 CSV 读取器和解析器。虽然如果我们试图涵盖所有用例和边缘情况，包括转义字符等，这将是一个大任务，但为了这个小型活动，我们将保持我们的要求简单。我们将假设没有转义字符，这意味着如果你在行中的任何位置使用逗号，那么它意味着你正在开始一个新列。我们还将假设我们感兴趣的唯一功能是能够逐行读取
    CSV 文件，其中每次读取都会生成一个新字典，列名作为键，行名作为值。
- en: 'Here is an example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![Figure 2.8 Table with sample data](img/Figure_2.8.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 示例数据表](img/Figure_2.8.jpg)'
- en: Figure 2.8 Table with sample data
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2.8 示例数据表
- en: 'We can convert the data in the preceding table into a Python dictionary, which
    would look as follows: `{"Name": "Bob", "Age": "24", "Location": "California"}`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以将前表中的数据转换为 Python 字典，其外观如下：`{"Name": "Bob", "Age": "24", "Location": "California"}`：'
- en: Import `zip_longest` from `itertools`. Create a function to zip `header`, `line`
    and `fillvalue=None`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `itertools` 导入 `zip_longest`。创建一个函数来压缩 `header`、`line` 和 `fillvalue=None`。
- en: Open the accompanying `sales_record.csv` file from the GitHub link by using
    `r` mode inside a with block and first check that it is opened.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 with 块内的 `r` 模式，从 GitHub 链接打开附带的 `sales_record.csv` 文件，并首先检查它是否已打开。
- en: Read the first line and use string methods to generate a list of all the column
    names.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取第一行，并使用字符串方法生成所有列名的列表。
- en: Start reading the file. Read it line by line.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始读取文件。逐行读取。
- en: Read each line and pass that line to a function, along with the list of the
    headers. The work of the function is to construct a dict out of these two and
    fill up the `key:values`. Keep in mind that a missing value should result in `None`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取每一行，并将该行传递给一个函数，同时带有标题列表。该函数的工作是从这两个中构建一个字典，并填充 `键:值`。请记住，缺失的值应导致 `None`。
- en: Note
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 291.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 291 页找到。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the workings of advanced data structures such
    as stacks and queues. We implemented and manipulated both stacks and queues. We
    then focused on different methods of functional programming, including iterators,
    and combined lists and functions together. After this, we looked at the `OS`-level
    functions and the management of environment variables and files. We also examined
    a clean way to deal with files, and we created our own CSV parser in the last
    activity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了高级数据结构（如栈和队列）的工作原理。我们实现了栈和队列，然后专注于函数式编程的不同方法，包括迭代器，并将列表和函数结合起来。之后，我们探讨了
    `OS` 级别的函数和环境变量以及文件的管理。我们还检查了处理文件的一种干净方式，并在最后一个活动中创建了自己的 CSV 解析器。
- en: In the next chapter, we will be dealing with the three most important libraries,
    namely NumPy, pandas, and matplotlib.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理三个最重要的库，即 NumPy、pandas 和 matplotlib。
