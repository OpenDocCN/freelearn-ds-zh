- en: Chapter 5. SciPy for Signal Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define a signal as data that measures either time-varying or spatially varying
    phenomena. Sound or electrocardiograms are excellent examples of time-varying
    quantities, while images embody the quintessential spatially varying cases. Moving
    images (movies or videos) are treated with the techniques of both types of signals,
    obviously.
  prefs: []
  type: TYPE_NORMAL
- en: The field of signal processing treats four aspects of this kind of data – its
    acquisition, quality improvement, compression, and feature extraction. SciPy has
    many routines to treat tasks effectively in any of the four fields. All these
    are included in two low-level modules (`scipy.signal` being the main one, with
    an emphasis in time-varying data, and `scipy.ndimage`, for images). Many of the
    routines in these two modules are based on Discrete Fourier Transform of the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of background algorithms, `scipy.fftpack`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in functions for signal construction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presentation of functions to filter spatial or time series signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional details on the subject can be found in *Python for Signal Processing*,
    *Unpingco José*, *Springer Publishing*.
  prefs: []
  type: TYPE_NORMAL
- en: Discrete Fourier Transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discrete Fourier Transform (DFT) transforms any signal from its time/space domain
    into a related signal in frequency domain. This allows us not only to analyze
    the different frequencies of the data, but also enables faster filtering operations,
    when used properly. It is possible to turn a signal in frequency domain back to
    its time/spatial domain, thanks to the Inverse Fourier Transform (IFT). We will
    not go into details of the mathematics behind these operators, since we assume
    familiarity at some level with this theory. We will focus on syntax and applications
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic routines in the `scipy.fftpack` module compute the DFT and its inverse,
    for discrete signals in any dimension – `fft`, `ifft` (one dimension); `fft2`,
    `ifft2` (two dimensions); `fftn`, `ifftn` (any number of dimensions). All of these
    routines assume that the data is complex valued. If we know beforehand that a
    particular dataset is actually real valued, and should offer real-valued frequencies,
    we use `rfft` and `irfft` instead, for a faster algorithm. All these routines
    are designed so that composition with their inverses always yields the identity.
    The syntax is the same in all cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `x`, is always the signal in any array-like form. Note
    that `fft` performs one-dimensional transforms. This means that if `x` happens
    to be two-dimensional, for example, `fft` will output another two-dimensional
    array where each row is the transform of each row of the original. We can use
    columns instead, with the optional parameter, `axis`. The rest of the parameters
    are also optional; `n` indicates the length of the transform and `overwrite_x`
    gets rid of the original data to save memory and resources. We usually play with
    the integer `n` when we need to pad the signal with zeros, or truncate it. For
    a higher dimension, `n` is substituted by `shape` (a tuple), and `axis` by `axes`
    (another tuple).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the output, it is often useful to shift the zero frequencies
    to the center of the output arrays with `fftshift`. The inverse of this operation,
    `ifftshift`, is also included in the module. The following code shows some of
    these routines in action when applied to a checkerboard image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how the first four rows of the one-dimensional transform are equal (and
    so are the last four), while the two-dimensional transform (once shifted) presents
    a peak at the origin and nice symmetries in the frequency domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, which has been obtained from the previous code,
    the image on the left is `fft` and the one on the right is `fft2` of a 2 x 2 checkerboard
    signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Discrete Fourier Transforms](img/7702OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `scipy.fftpack` module also offers the Discrete Cosine Transform with its
    inverse (`dct`, `idct`) as well as many differential and pseudo-differential operators
    defined in terms of all these transforms – `diff` (for derivative/integral); `hilbert`,
    `ihilbert` (for the Hilbert transform); `tilbert`, `itilbert` (for the h-Tilbert
    transform of periodic sequences); and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Signal construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To aid the construction of signals with predetermined properties, the `scipy.signal`
    module has a nice collection of the most frequent one-dimensional waveforms in
    the literature – `chirp` and `sweep_poly` (for the frequency-swept cosine generator),
    `gausspulse` (a Gaussian modulated sinusoid), `sawtooth` and `square` (for the
    waveforms with those names). They all take as their main parameter a one-dimensional
    `ndarray` representing the times at which the signal is to be evaluated. Other
    parameters control the design of the signal according to frequency or time constraints.
    Let''s take a look into the following code snippet which illustrates the use of
    these one dimensional waveforms that we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Generated by this code, the following diagram shows waveforms for `chirp`,
    `gausspulse`, `sawtooth`, and `square`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Signal construction](img/7702OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The usual method of creating signals is to import them from a file. This is
    possible by using purely NumPy routines; for example, `fromfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file` argument may point to either a file or a string, the `count` argument
    is used to determine the number of items to read, and `sep` indicates what constitutes
    a separator in the original file/string. For images, we have the versatile routine,
    `imread` in in either the `scipy.ndimage` or `scipy.misc` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `fname` argument is a string containing the location of an image. The routine
    infers the type of file, and reads the data into array accordingly. In case if
    the `flatten` argument is turned to `True`, the image is converted to gray scale.
    Note that, in order for `fromfile` and `imread` to work, the **Python Imaging
    Library** (**PIL**) needs to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to load `.wav` files for analysis, with the `read` and
    `write` routines from the `wavfile` submodule in the `scipy.io` module. For instance,
    the following line of code reads an audio file, say `audio.wav`, using the `read`
    routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The command assigns an integer value to the `rate` variable, indicating the
    sample rate of the file (in samples per second), and a NumPy `ndarray` to the
    `data` variable, containing the numerical values assigned to the different notes.
    If we wish to write some one-dimensional `ndarray data` into an audio file of
    this kind, with the sample rate given by the `rate` variable, we may do so by
    issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filter is an operation on signals that either removes features or extracts
    some component. SciPy has a complete set of known filters as well as the tools
    to allow construction of new ones. The complete list of filters in SciPy is long,
    and we encourage the reader to explore the help documents of the `scipy.signal`
    and `scipy.ndimage` modules for the complete picture. We will introduce in these
    pages, as an exposition, some of the most used filters in the treatment of audio
    or image processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a signal worth filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we test the classical smoothing filter of **Wiener** and **Kolmogorov**,
    `wiener`. We present in a `plot` the original signal (in black) and the corresponding
    filtered data, with a choice of Wiener window of size 55 samples (in blue). Next
    we compare the result of applying the median filter, `medfilt`, with a kernel
    of the same size as before (in red):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following graph showing the comparison of smoothing filters
    (**Wiener**, in red, is the one that has its starting point just above **0.5**
    and **Medfilt**, in blue, has its starting point just below **0.5**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filters](img/7702OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of the filters in the `scipy.signal` module can be adapted to work with
    arrays of any dimension. But in the particular case of images, we prefer to use
    the implementations in the `scipy.ndimage` module, since they are coded with these
    objects in mind. For instance, to perform a median filter on an image for smoothing,
    we use `scipy.ndimage.median_filter`. Let us show an example. We will start by
    loading Lena to array, and corrupting the image with Gaussian noise (zero mean
    and standard deviation of 16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The set of filters for images come in two flavors – statistical and morphological.
    For example, among the filters of statistical nature, we have the **Sobel** algorithm
    oriented to detection of edges (singularities along curves). Its syntax is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional parameter, `axis`, indicates the dimension in which the computations
    are performed. By default, this is always the last axis (-1). The `mode` parameter,
    which is one of the strings `''reflect''`, `''constant''`, `''nearest''`, `''mirror''`,
    or `''wrap''`, indicates how to handle the border of the image in case there is
    insufficient data to perform the computations there. In case `mode` is `''constant''`,
    we may indicate the value to use in the border with the `cval` parameter. Let''s
    look into the following code snippet which illustrates the use of `sobel` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the previous two filters in action—Lena
    (upper-left), noisy Lena (upper-right), edge map with sobel (lower-left), and
    median filter (lower-right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filters](img/7702OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The LTI system theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To investigate the response of a time-invariant linear system to input signals,
    we have many resources in the `scipy.signal` module. As a matter of fact, to simplify
    representation of objects, we have an `lti` class (linear-time invariant class)
    with associated methods such as `bode` (to calculate bode magnitude and phase
    data), `impulse`, `output`, and `step`.
  prefs: []
  type: TYPE_NORMAL
- en: Whether we are working with continuous or discrete-time linear systems, we have
    routines to simulate such systems (`lsim` and `lsim2` for continuous, `dsim` for
    discrete), as well as compute impulses (`impulse` and `impulse2` for continuous,
    `dimpulse` for discrete) and steps (`step` and `step2` for continuous, `dstep`
    for discrete).
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a system from continuous to discrete is possible with `cont2discrete`,
    but in either case we are able to provide for any system with any of its representations,
    as well as to convert from one to another. For instance, if we have the zeros
    `z`, poles `p`, and system gain `k` of the transfer function, we may obtain the
    polynomial representation (numerator first, then denominator) with `zpk2tf(z,p,k)`.
    If we have numerator (`num`) and denominator (`dem`) of the transfer function,
    we obtain the state-space with `tf2ss(num,dem)`. This operation is reversible
    with the `ss2tf` routine. The change of representation from zero-pole-gain to/from
    state-space is also contemplated in the (`zpk2ss`, `ss2zpk`) module.
  prefs: []
  type: TYPE_NORMAL
- en: Filter design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are routines in the `scipy.signal` module that allow the creation of different
    kinds of filters with diverse methods. For instance, the `bilinear` function returns
    a digital filter from an analog using a bilinear transform. **Finite impulse response**
    (**FIR**) filters can be designed by the window method with the `firwin` and `firwin2`
    routines. **Infinite impulse response** (**IIR**) filters can be designed in two
    different ways, via `iirdesign` or `iirfilter`. **Butterworth** filters can be
    designed with the `butter` routine. There are also routines to design filters
    of **Chebyshev** (`cheby1`, `cheby2`), **Cauer** (`ellip`), and Bessel (`bessel`).
  prefs: []
  type: TYPE_NORMAL
- en: Window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No signal processing computational system would be complete without an extensive
    list of windows—mathematical functions that are zero valued outside specific domains.
    In this section, we will use a few of the coded windows implemented in the `scipy.signal`
    module to design very simple smoothing filters by using convolution.
  prefs: []
  type: TYPE_NORMAL
- en: We will be testing them on the same one-dimensional signal we employed before,
    for comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by showing the plot of four well-known window functions – Boxcar,
    Hamming, Blackman-Harris (Nuttall version), and triangular. We will use a size
    of 31 samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to extend the original signal by fifteen samples for plotting purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is the filter itself, which we perform by a simple convolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output, showing convolution of a signal with different
    windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Window functions](img/7702OS_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Image interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The set of filters on images that performs some geometric manipulation of the
    input is classically termed image interpolation, since this numerical technique
    is the root of all the algorithms. As a matter of fact, SciPy collects all these
    under the submodule, `scipy.ndimage.interpolation`, for ease of access. This section
    is best explained through examples, going over the most meaningful routines for
    geometric transformation. The starting point is the image, Lena. We now assume
    that all functions from the submodule have been imported into the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to apply an affine transformation on the domain of the image, given
    in matrix form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image interpolation](img/7702OS_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To apply the transformation on the domain of the image we issue the `affine_transform`
    command (note that the syntax is self-explanatory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For a general transformation, we use the `geometric_transform` routine with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to provide a rank-2 map from tuples to tuples as the parameter mapping.
    For instance, we desired to apply the **Möbius** transform for complex-valued
    number `z` (where we assume the values of `a`, `b`, `c`, and `d` are already defined
    and they are complex-valued numbers) in the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image interpolation](img/7702OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We would have to code it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In both functions, the values of the grid that cannot be computed directly with
    the formula are inferred with spline interpolation. We may specify the order of
    this interpolation with the `order` parameter. The points outside the domain of
    definition are not interpolated, but filled according to some predetermined rule.
    We may impose this rule by passing a string to the `mode` option. The choices
    are – `'constant'`, to use a constant value that we may impose with the `cval`
    option; `'nearest'`, that continues the last value of the interpolation on each
    level line; and `'reflect'` or `'wrap'`, which are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for the values `a = 2**15*(1+1j)`, `b = 0`, `c = -2**8*(1-1j*2)`,
    and `d = 2**18-1j*2**14`, we obtain (after imposing the `reflect` mode) the result,
    as shown just after this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows affine transformation (left) and geometric transformation
    (right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image interpolation](img/7702OS_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For special cases of rotations, shifts, or dilations, we have the syntactic
    sugar routines, `rotate(input,angle)`, `shift(input, offset)`, and `zoom(input,dilation_factor)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given any image, we know the value of the array at pixel values (with integer
    coordinates) in the domain. But what would the corresponding value of a location
    be without integer coordinates? We may obtain that information with the valuable
    routine, map_coordinates. Note that the syntax may be confusing, especially with
    the `coordinates` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if we wish to evaluate Lena at the locations (10.5, 11.7) and
    (12.3, 1.4), we collect the coordinates as a sequence of sequences; the first
    internal sequence contains the `x` values, and the second, the `y` values. We
    may specify the order of splines used with `order`, and the interpolation scheme
    outside of the domain, if needed, as in the previous examples. Let''s evaluate
    Lena at the locations (which we just discussed in our example) using following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we evaluate Lena with `order=2` as shown in following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Morphology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also have the possibility of creating and applying filters to images based
    on mathematical morphology, both to binary and gray-scale images. The four basic
    morphological operations are opening (`binary_opening`), closing (`binary_closing`),
    dilation (`binary_dilation`), and erosion (`binary_erosion`). Note that the syntax
    of each of these filters is very simple, since we only need two ingredients –
    the signal to filter and the structuring element to perform the morphological
    operation. Let''s take a look into the general syntax for these morphological
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have illustrated the use some of these operations towards an application
    to obtain the structural model of an oxide, but we will postpone this example
    until we cover the notions of triangulations and Voronoi diagrams in [Chapter
    7](ch07.html "Chapter 7. SciPy for Computational Geometry"), *SciPy for Computational
    Geometry*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may use combinations of these four basic morphological operations to create
    more complex filters for the removal of holes, hit-or-miss transforms (to find
    the location of specific patterns in binary images), denoising, edge detection,
    and many more. The module even provides us with some of the most common filters
    constructed this way. For instance, for the location of the letter e in a text
    (which we covered in [Chapter 2](ch02.html "Chapter 2. Working with the NumPy
    Array As a First Step to SciPy"), *Working with the NumPy Array As a First Step
    to SciPy*, as an application of correlation), we could use the following command
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparative purposes, let''s apply this command to the example from [Chapter
    2](ch02.html "Chapter 2. Working with the NumPy Array As a First Step to SciPy"),
    *Working with the NumPy Array As a First Step to SciPy*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output, which the reader should compare with the
    corresponding one on [Chapter 2](ch02.html "Chapter 2. Working with the NumPy
    Array As a First Step to SciPy"), *Working with the NumPy Array As a First Step
    to SciPy*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Morphology](img/7702OS_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For gray-scale images, we may use a structuring element (`structuring_element`)
    or a footprint. The syntax is, therefore, a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we desire to use a completely flat and rectangular structuring element (all
    *ones*), then it is enough to indicate the size as a tuple. For instance, to perform
    gray-scale dilation of a flat element of `size (15,15)` on our classical image
    of Lena, we issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The last kind of morphological operations coded in the scipy.ndimage module
    perform distance and feature transforms. Distance transforms create a map that
    assigns to each pixel the distance to the nearest object. Feature transforms provide
    the index of the closest background element instead. These operations are used
    to decompose images into different labels. We may even choose different metrics
    such as Euclidean distance, chessboard distance, and **taxicab** distance. The
    syntax for the distance transform (`distance_transform`) using a brute force algorithm
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We indicate the metric with the strings such as `'euclidean'`, `'taxicab'`,
    or `'chessboard'`. If we desire to provide the feature transform instead, we switch
    `return_distances` to `False` and `return_indices` to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar routines are available with more sophisticated algorithms – `distance_transform_cdt`
    (using chamfering for taxicab and chessboard distances). For Euclidean distance,
    we also have `distance_transform_edt`. All these use the same syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored signal processing (any dimensional), including
    the treatment of signals in frequency space, by means of their Discrete Fourier
    Transforms. These correspond to the `fftpack`, `signal`, and `ndimage` modules.
  prefs: []
  type: TYPE_NORMAL
- en: The [Chapter 6](ch06.html "Chapter 6. SciPy for Data Mining"), *SciPy for Data
    Mining*, will explore the tools included in SciPy to approach Statistical and
    Data Mining problems. In addition to standard statistical quantities, special
    topics like kernel estimation, statistical distances, and the clustering of big
    data sets will be presented.
  prefs: []
  type: TYPE_NORMAL
