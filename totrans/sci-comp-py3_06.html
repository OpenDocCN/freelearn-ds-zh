<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Plotting</h1></div></div></div><p>Plotting in Python can be done with the <code class="literal">pyplot</code> part of the matplotlib module. With matplotlib you can create high-quality figures and graphics and also plot and visualize your results. Matplotlib is open source and freely available software, <a class="link" href="apa.html" title="Appendix . References">[21]</a>. The matplotlib website also contains excellent documentation with examples, <a class="link" href="apa.html" title="Appendix . References">[35]</a>. In this section, we will show you how to use the most common features. The examples in the upcoming sections assume that you have imported the module as:</p><pre class="programlisting">from matplotlib.pyplot import *</pre><p>In case you want to use the plotting commands in IPython, it is recommended that you run the magic command <code class="literal">%matplotlib</code> directly after starting the IPython shell. This prepares IPython for interactive plotting.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Basic plotting</h1></div></div></div><p>The standard plotting function is <code class="literal">plot</code>. Calling <code class="literal">plot(x,y)</code> creates a figure window with a plot of <em>y</em> as a function of <em>x</em>. The input arguments are arrays (or lists) of equal length. It is also possible to use <code class="literal">plot(y)</code>, in which case the values in <em>y</em> will be plotted against their index, that is, <code class="literal">plot(y)</code> is a short form of <code class="literal">plot(range(len(y)),y)</code>.</p><p>Here is an example that shows how to plot sin(<em>x</em>) for <em> x </em>ϵ [-2π, 2π]  using 200 sample points and sets markers at every fourth point:</p><pre class="programlisting"># plot sin(x) for some interval&#13;
x = linspace(-2*pi,2*pi,200)&#13;
plot(x,sin(x))&#13;
&#13;
# plot marker for every 4th point&#13;
samples = x[::4]&#13;
plot(samples,sin(samples),'r*')&#13;
&#13;
# add title and grid lines&#13;
title('Function sin(x) and some points plotted')&#13;
grid()</pre><p>The result is shown in the following figure (<em>Figure 6.1</em>):</p><p>
</p><div><img src="img/plotting_sinexample.jpg" alt="Basic plotting"/></div><p>
</p><p>Figure 6.1: A plot of the function sin(x) with grid lines shown.</p><p>As you can see, the standard plot is a solid blue curve. Each axis gets automatically scaled to fit the values but can also be set manually. Color and plot options can be given after the first two input arguments. Here, <code class="literal">r*</code> indicates red star-shaped markers. Formatting is covered in more detail in the next section. The <code class="literal">title</code> command puts a title text string above the plot area.</p><p>Calling <code class="literal">plot</code> multiple times will overlay the plots in the same window. To get a new clean figure window, use <code class="literal">figure()</code>. The <code class="literal">figure</code> command might contain an integer, for example, <code class="literal">figure(2)</code>, which can be used to switch between figure windows. If there is no figure window with that number, a new one is created, otherwise, the window is activated for plotting and all subsequent plotting commands apply to that window.</p><p>Multiple plots can be explained using the <code class="literal">legend</code> function, along with adding labels to each plot call. The following example fits polynomials to a set of points using the commands <code class="literal">polyfit</code> and <code class="literal">polyval</code>, and plots the result with a legend:</p><pre class="programlisting"># —Polyfit example—&#13;
x = range(5)&#13;
y = [1,2,1,3,5]&#13;
p2 = polyfit(x,y,2)&#13;
p4 = polyfit(x,y,4)&#13;
&#13;
# plot the polynomials and points&#13;
xx = linspace(-1,5,200) &#13;
plot(xx, polyval(p2, xx), label='fitting polynomial of degree 2')&#13;
plot(xx, polyval(p4, xx),&#13;
                label='interpolating polynomial of degree 4') &#13;
plot(x,y,'*')&#13;
&#13;
# set the axis and legend&#13;
axis([-1,5,0,6])&#13;
legend(loc='upper left', fontsize='small')</pre><p>Here you can also see how to manually set the range of the axis using <code class="literal">axis([xmin,xmax,ymin,ymax])</code>. The <code class="literal">legend</code> command takes optional arguments on placement and formatting; in this case the legend is put in the upper-left corner and typeset with a small font size, as shown in the following figure (<em>Figure 6.2</em>).</p><p>
</p><div><img src="img/plotting_polynomialfit.jpg" alt="Basic plotting"/></div><p>
</p><p>Figure 6.2: Two polynomials fitted to the same points.</p><p>As final examples for basic plotting, we demonstrate how to do scatter plots and logarithmic plots in two dimensions.</p><p>Example of 2D point scatter plot:</p><pre class="programlisting"># create random 2D points&#13;
import numpy&#13;
x1 = 2*numpy.random.standard_normal((2,100))&#13;
x2 = 0.8*numpy.random.standard_normal((2,100)) + array([[6],[2]])&#13;
plot(x1[0],x1[1],'*')&#13;
plot(x2[0],x2[1],'r*')&#13;
title('2D scatter plot')</pre><p>
</p><div><img src="img/plotting_scatterplot.jpg" alt="Basic plotting"/></div><p>
</p><p>Figure 6.3(a): An example of a scatter plot</p><p>The following code is an example of a logarithmic plot using <code class="literal">loglog</code>:</p><pre class="programlisting"># log both x and y axis &#13;
x = linspace(0,10,200) &#13;
loglog(x,2*x**2, label = 'quadratic polynomial',&#13;
                            linestyle = '-', linewidth = 3)&#13;
loglog(x,4*x**4, label = '4th degree polynomial',&#13;
                            linestyle = '-.', linewidth = 3)&#13;
loglog(x,5*exp(x), label = 'exponential function', linewidth = 3)&#13;
title('Logarithmic plots')&#13;
legend(loc = 'best')</pre><p>
</p><div><img src="img/plotting_loglogplot.jpg" alt="Basic plotting"/></div><p>
</p><p>Figure 6.3(b): An example of a plot with logarithmic x and y axis</p><p>The examples shown in the preceding figure (<em>Figure 6.3(a)</em> and <em>Figure 6.3(b)</em>) used some parameters of <code class="literal">plot</code> and <code class="literal">loglog</code> which allow special formatting. In the next section, we will explain the parameters in more detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Formatting</h1></div></div></div><p>The appearance of figures and plots can be styled and customized to look how you want them to look. Some important variables are <code class="literal">linewidth</code>, which controls the thickness of plot lines; <code class="literal">xlabel</code>, <code class="literal">ylabel</code>, which set the axis labels, <code class="literal">color</code> for plot colors, and <code class="literal">transparent</code> for transparency. This section will tell you how to use some of them. The following is an example with more keywords:</p><pre class="programlisting">k = 0.2&#13;
x = [sin(2*n*k) for n in range(20)]&#13;
plot(x, color='green', linestyle='dashed', marker='o', &#13;
                       markerfacecolor='blue', markersize=12, linewidth=6)</pre><p>There are short commands that can be used if you only need basic style changes, for example, setting the color and line style. The following table (<em>Table 6.1</em>) shows some examples of these formatting commands. You may use either the short string syntax <code class="literal">plot(...,'ro-')</code>, or the more explicit syntax <code class="literal">plot(..., marker='o', color='r', linestyle='-')</code>.</p><p>
</p><div><img src="img/table-6.1.jpg" alt="Formatting"/></div><p>
</p><p>Table 6.1: Some common plot formatting arguments</p><p>To set the color to green with the <code class="literal">'o'</code> marker we write:</p><pre class="programlisting">plot(x,'go')</pre><p>To plot histograms instead of regular plots, the <code class="literal">hist</code> command is used:</p><pre class="programlisting"># random vector with normal distribution&#13;
sigma, mu = 2, 10&#13;
x = sigma*numpy.random.standard_normal(10000)+mu &#13;
hist(x,50,normed=1)&#13;
z = linspace(0,20,200)&#13;
plot(z, (1/sqrt(2*pi*sigma**2))*exp(-(z-mu)**2/(2*sigma**2)),'g')&#13;
# title with LaTeX formatting &#13;
title('Histogram with '.format(mu,sigma))</pre><p>
</p><div><img src="img/plotting_histexample.jpg" alt="Formatting"/></div><p>
</p><p>Figure 6.4 normal distribution with 50 bins and a green curve indicating the true distribution</p><p>The resulting plot looks similar to the preceding figure (<em>Figure 6.4</em>). The title, and any other text, can be formatted using LaTeX to show mathematical formulas. LaTeX formatting is enclosed within a pair of <code class="literal">$</code> signs. Also, note the string formatting done using the <code class="literal">format</code> method, refer to section <em>Strings </em>in <a class="link" href="ch02.html" title="Chapter 2. Variables and Basic Types">Chapter 2</a>, <em>Variables and Basic Types</em>.</p><p>Sometimes the brackets for the string formatting interfere with LaTeX bracket environments. If this occurs, replace the LaTeX bracket with a double bracket, for example, <code class="literal">x_{1}</code> should be replaced with <code class="literal">x_{{1}}</code>. The text might contain sequences that overlap with string escape sequences, for example, <code class="literal">\tau</code> will be interpreted as the tab character <code class="literal">\t</code>. An easy workaround  is to add <code class="literal">r</code> before the string, for example <code class="literal">r'\tau'</code>; this makes it a raw string.</p><p>Placing several plots in one figure window can be done using the <code class="literal">subplot</code> command. Consider the following example, which iteratively averages out the noise on a sine curve.</p><pre class="programlisting">def avg(x):&#13;
    """ simple running average """&#13;
    return (roll(x,1) + x + roll(x,-1)) / 3&#13;
# sine function with noise&#13;
x = linspace(-2*pi, 2*pi,200)&#13;
y = sin(x) + 0.4*rand(200)&#13;
&#13;
# make successive subplots&#13;
for iteration in range(3):&#13;
    subplot(3, 1, iteration + 1)&#13;
    plot(x,y, label = '{:d} average{}'.format(iteration, 's' if iteration &gt; 1 else ''))&#13;
    yticks([])&#13;
    legend(loc = 'lower left', frameon = False)&#13;
    y = avg(y) #apply running average &#13;
subplots_adjust(hspace = 0.7)</pre><p>
</p><div><img src="img/plotting_sinsubplot.jpg" alt="Formatting"/></div><p>
</p><p>Figure 6.5: An example of plotting several times in the same figure window.</p><p>The function <code class="literal">avg</code>  uses a <code class="literal">roll</code> call to shift all values of the array. <code class="literal">subplot</code> takes three arguments: the number of vertical plots, the number of horizontal plots, and an index indicating which location to plot in (counted row-wise). Note that we used the <code class="literal">subplots_adjust</code> command to add extra space to adjust the distance between both the subplots.</p><p>A useful command is <code class="literal">savefig</code> which lets you save a figure as an image (this can also be done from the figure window). Many image and file formats are supported by this command, they are specified by the filename's extension as:</p><pre class="programlisting">savefig('test.pdf')  # save to pdf</pre><p>or</p><pre class="programlisting">savefig('test.svg')  # save to svg (editable format)</pre><p>You can place the image against a non-white background, for example, a webpage. For this, the <code class="literal">transparent</code> parameter can be set to make the figure's background transparent:</p><pre class="programlisting">savefig('test.pdf', transparent=True)</pre><p>If you intend to embed a figure into a LaTeX document, it is recommended that you reduce the surrounding white space by setting the figure's bounding box tight around the drawing, as shown here:</p><pre class="programlisting">savefig('test.pdf', bbox_inches='tight')</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Meshgrid and contours</h1></div></div></div><p>A common task is a graphical representation of a scalar function over a rectangle:</p><p>
</p><div><img src="img/function_meshgrid.jpg" alt="Meshgrid and contours"/></div><p>
</p><p>For this, first we have to generate a grid on the rectangle [<em>a</em>,<em>b</em>] x [<em>c</em>,<em>d</em>]. This is done using the <code class="literal">meshgrid</code> command:</p><pre class="programlisting">n = ... # number of discretization points along the x-axis&#13;
m = ... # number of discretization points along the x-axis &#13;
X,Y = meshgrid(linspace(a,b,n), linspace(c,d,m))</pre><p>
<code class="literal">X</code> and <code class="literal">Y</code> are arrays with <code class="literal">(n,m)</code> shape such that <img src="img/xijYij.jpg" alt="Meshgrid and contours"/> contains the coordinates of the grid point <img src="img/PIJ.jpg" alt="Meshgrid and contours"/> as shown in the next figure <em>(Figure 6.6)</em>:</p><p>
</p><div><img src="img/meshgrid.jpg" alt="Meshgrid and contours"/></div><p>
</p><p>Figure 6.6: A rectangle discretized by meshgrid</p><p>A rectangle discretized by <code class="literal">meshgrid</code> will be used  to visualize the behavior of an iteration. Bur first we will use it to plot level curves of a function. This is done by the command <code class="literal">contour</code>.</p><p>As an example we choose Rosenbrock's banana function:</p><p>
</p><div><img src="img/banana.jpg" alt="Meshgrid and contours"/></div><p>
</p><p>It is used to challenge optimization methods. The function values descend towards a banana-shaped valley, which itself decreases slowly towards the function’s global minimum at (1, 1).</p><p>First we display the level curves using <code class="literal">contour</code>.</p><pre class="programlisting">rosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2 &#13;
X,Y = meshgrid(linspace(-.5,2.,100), linspace(-1.5,4.,100))&#13;
Z = rosenbrockfunction(X,Y) &#13;
contour(X,Y,Z,logspace(-0.5,3.5,20,base=10),cmap='gray') &#13;
title('Rosenbrock Function: ')&#13;
xlabel('x')&#13;
ylabel('y')</pre><p>This plots the level curve at the levels given by the fourth parameter and uses the colormap <code class="literal">gray</code>. Furthermore, we used logarithmically spaced steps from 10<sup>0.5</sup> to 10<sup>3</sup> using the function <code class="literal">logscale</code> to define the levels, as shown in the next figure.</p><p>
</p><div><img src="img/rosenbrock.jpg" alt="Meshgrid and contours"/></div><p>
</p><p>Figure 6.7: A contour plot of Rosenbrock function</p><p>In the preceding example, an anonymous function indicated by the keyword <code class="literal">lambda</code> is used to keep the code compact. Anonymous functions are explained in section <em>Anonymous functions - the lambda keyword</em> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <em>Functions</em>, <em>Anonymous functions</em>. If levels are not given as arguments to <code class="literal">contour</code>, the function chooses appropriate levels by itself .</p><p>The <code class="literal">contourf</code> function performs the same function as <code class="literal">contour</code> but fills the plot with colors according to different levels. Contour plots are ideal for visualizing the behavior of a numerical method. We illustrate this here by showing the iterations of an optimization method.</p><p>We continue the preceding example and depict the steps towards the minimum of the Rosenbrock function generated by Powell's method, <a class="link" href="apa.html" title="Appendix . References">[27]</a>, which we will apply to find the minimum of the Rosenbrock function:</p><pre class="programlisting">import scipy.optimize as so&#13;
rosenbrockfunction = lambda x,y: (1-x)**2+100*(y-x**2)**2&#13;
X,Y=meshgrid(linspace(-.5,2.,100),linspace(-1.5,4.,100))&#13;
Z=rosenbrockfunction(X,Y)&#13;
cs=contour(X,Y,Z,logspace(0,3.5,7,base=10),cmap='gray')&#13;
rosen=lambda x: rosenbrockfunction(x[0],x[1])&#13;
solution, iterates = so.fmin_powell(rosen,x0=array([0,-0.7]),retall=True)&#13;
x,y=zip(*iterates)&#13;
plot(x,y,'ko') # plot black bullets&#13;
plot(x,y,'k:',linewidth=1) # plot black dotted lines&#13;
title("Steps of Powell's method to compute a  minimum")&#13;
clabel(cs)</pre><p>The iterative method <code class="literal">fmin_powell</code> applies Powell's method to find a minimum. It is started by a given start value of <em>x<sub>0 </sub></em>and reports all iterates when the option <code class="literal">retall=True</code> is given. After sixteen iterations, the solution<em> x=</em>0<em>, y=</em>0 was found. The iterations are depicted as bullets in the following contour plot (<em>Figure 6.8</em>).</p><p>
</p><div><img src="img/rosenbrock_opt.jpg" alt="Meshgrid and contours"/></div><p>
</p><p>Figure 6.8: A contour plot of Rosenbrock function with a search path of an optimization method</p><p>
<code class="literal">contour</code> also creates a contour set object that we assigned to the variable <code class="literal">cs</code>. This is then used by <code class="literal">clabel</code> to annotate the levels of the corresponding function values, as shown in the preceding figure (<em>Figure 6.8</em>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Images and contours</h1></div></div></div><p>Let us take a look at some examples of visualizing arrays as images. The following function will create a matrix of color values for the Mandelbrot fractal<strong>. </strong>Here we consider a fixed point iteration, that depends on a complex parameter <em>c</em>:</p><p>
</p><div><img src="img/B05511_06_02.jpg" alt="Images and contours"/></div><p>
</p><p>Depending on the choice of this parameter it may or may not create a bounded sequence of complex values <em>z<sub>n</sub></em>.</p><p>For every value of <em>c</em>, we check if <em>z<sub>n</sub></em> exceeds a prescribed bound. If it remains below the bound within <code class="literal">maxit</code> iterations, we assume the sequence to be bounded.</p><p>Note how, in the following piece of code,<code class="literal">meshgrid</code> is used to generate a matrix of complex parameter values <em>c:</em>
</p><pre class="programlisting">def mandelbrot(h,w, maxit=20):&#13;
    X,Y = meshgrid(linspace(-2, 0.8, w), linspace(-1.4, 1.4, h))&#13;
    c = X + Y*1j&#13;
    z = c&#13;
    exceeds = zeros(z.shape, dtype=bool)&#13;
&#13;
    for iteration in range(maxit):&#13;
        z  = z**2 + c&#13;
        exceeded = abs(z) &gt; 4&#13;
        exceeds_now = exceeded &amp; (logical_not(exceeds))  &#13;
        exceeds[exceeds_now] = True        &#13;
        z[exceeded] = 2  # limit the values to avoid overflow&#13;
    return exceeds&#13;
&#13;
imshow(mandelbrot(400,400),cmap='gray')&#13;
axis('off')</pre><p>The command <code class="literal">imshow</code>  displays the matrix as an image. The selected color map shows the regions where the sequence appeared unbounded in white and others in black. Here we used <code class="literal">axis('off')</code> to turn off the axis as this might be not so useful for images.</p><p>
</p><div><img src="img/plotting_mandelbrot_gray.jpg" alt="Images and contours"/></div><p>
</p><p>Figure 6.9: An example of using imshow to visualize a matrix as an image.</p><p>By default, <code class="literal">imshow</code> uses interpolation to make the images look nicer. This is clearly seen when the matrices are small. The next figure shows the difference between using:</p><pre class="programlisting">imshow(mandelbrot(40,40),cmap='gray')</pre><p>and</p><pre class="programlisting">imshow(mandelbrot(40,40), interpolation='nearest', cmap='gray')</pre><p>In the second example, pixel values are just replicated.</p><p>
</p><div><img src="img/plotting_mandelbrot_small.jpg" alt="Images and contours"/></div><p>
</p><p>Figure 6.10: The difference between using the linear interpolation of imshow compared to using nearest neighbor interpolation</p><p>For more details on working and plotting with images using Python refer to <a class="link" href="apa.html" title="Appendix . References">[30]</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Matplotlib objects</h1></div></div></div><p>Till now, we have used the <code class="literal">pyplot</code> module of matplotlib. This module makes it easy for us to use the most important plot commands directly. Mostly, we are interested in creating a figure and display it immediately. Sometimes, though, we want to generate a figure that should be modified later by changing some of its attributes. This requires us to work with graphical objects in an object-oriented way. In this section, we will present some basic steps to modify figures. For a more sophisticated object oriented approach to plotting in Python, you have to leave <code class="literal">pyplot</code> and have to dive directly into <code class="literal">matplotlib</code> with its extensive documentation.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec76"/>The axes object</h2></div></div></div><p>When creating a plot that should be modified later, we need references to a figure and an axes object. For this we have to create a figure first and then define some axes and their location in the figure. And we should not forget to assign these objects to a variable:</p><pre class="programlisting">fig = figure()&#13;
ax = subplot(111)</pre><p>A figure can have several axes objects depending on the use of <code class="literal">subplot</code>. In a second step plots are associated with a given axes object:</p><pre class="programlisting">fig = figure(1)&#13;
ax = subplot(111)&#13;
x = linspace(0,2*pi,100) &#13;
# We set up a function that modulates the amplitude of the sin function&#13;
amod_sin = lambda x: (1.-0.1*sin(25*x))*sin(x)&#13;
# and plot both...&#13;
ax.plot(x,sin(x),label = 'sin') &#13;
ax.plot(x, amod_sin(x), label = 'modsin')</pre><p>Here we used an anonymous function indicated by the <code class="literal">lambda</code> keyword . We will explain this construct later in section <em>Anonymous functions - the lambda keyword</em> in <a class="link" href="ch07.html" title="Chapter 7. Functions">Chapter 7</a>, <em>Functions</em>. In fact, these two plot commands fill the list <code class="literal">ax.lines</code> with two <code class="literal">Lines2D</code> objects:</p><pre class="programlisting">ax.lines #[&lt;matplotlib.lines.Line2D at ...&gt;, &lt;matplotlib.lines.Line2D at ...&gt;]</pre><p>It is a good practice to use labels so that we can later identify objects in an easy way:</p><pre class="programlisting">for il,line in enumerate(ax.lines):&#13;
    if line.get_label() == 'sin':&#13;
       break</pre><p>
We set up now things in a way that allows further modifications. The figure we got so far is shown in preceding figure (<em>Figure 6.11, left</em>).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Modifying line properties</h2></div></div></div><p>We just identified a particular line object by its label. It is an element of the list <code class="literal">ax.lines</code> list with the index  <code class="literal">il</code> . All its properties are collected in a dictionary</p><pre class="programlisting">dict_keys(['marker', 'markeredgewidth', 'data', 'clip_box', 'solid_capstyle', 'clip_on', 'rasterized', 'dash_capstyle', 'path', 'ydata', 'markeredgecolor', 'xdata', 'label', 'alpha', 'linestyle', 'antialiased', 'snap', 'transform', 'url', 'transformed_clip_path_and_affine', 'clip_path', 'path_effects', 'animated', 'contains', 'fillstyle', 'sketch_params', 'xydata', 'drawstyle', 'markersize', 'linewidth', 'figure', 'markerfacecolor', 'pickradius', 'agg_filter', 'dash_joinstyle', 'color', 'solid_joinstyle', 'picker', 'markevery', 'axes', 'children', 'gid', 'zorder', 'visible', 'markerfacecoloralt'])</pre><p>which can be obtained by the command:</p><pre class="programlisting">ax.lines[il].properties()</pre><p>They can be changed by corresponding setter methods. Let us change the line style of the sine - curve:</p><pre class="programlisting">ax.lines[il].set_linestyle('-.')&#13;
ax.lines[il].set_linewidth(2)</pre><p>We can even modify the data, as shown:</p><pre class="programlisting">ydata=ax.lines[il].get_ydata()&#13;
ydata[-1]=-0.5&#13;
ax.lines[il].set_ydata(ydata)</pre><p>The result is shown in the next figure <em>(Figure 6.11, right)</em>:</p><p> </p><div><img src="img/amp_mod_sin01.jpg" alt="Modifying line properties"/></div><p>
</p><p>Figure 6.11: The amplitude modulated sine-function (left) and a curve with the last data point corrupted (right).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Annotations</h2></div></div></div><p>One useful axes method is <code class="literal">annotate</code>. It sets an annotation at a given position and points, with an arrow, to another position in the drawing. The arrow can be given properties in a dictionary:</p><pre class="programlisting">annot1=ax.annotate('amplitude modulated\n curve', (2.1,1.0),(3.2,0.5),&#13;
       arrowprops={'width':2,'color':'k', 'connectionstyle':'arc3,rad=+0.5', &#13;
                   'shrink':0.05},&#13;
       verticalalignment='bottom', horizontalalignment='left',fontsize=15, &#13;
                   bbox={'facecolor':'gray', 'alpha':0.1, 'pad':10})&#13;
annot2=ax.annotate('corrupted data', (6.3,-0.5),(6.1,-1.1),&#13;
       arrowprops={'width':0.5,'color':'k','shrink':0.1},&#13;
       horizontalalignment='center', fontsize=12)</pre><p>In the first annotation example above, the arrow points to a point with the coordinates (<em>2.1, 1.0</em>) and the left bottom coordinate of the text is (<em>3.2, 0.5</em>). If not otherwise specified, the coordinates are given in the convenient data-coordinate system, which refers to the data used to generate the plots.</p><p>Furthermore, we demonstrated a couple of arrow properties specified by the <code class="literal">arrowprop</code>  dictionary. You can scale the arrow by the <code class="literal">shrink</code> key. The setting <code class="literal">'shrink':0.05</code> reduces the arrow size by 5% to keep a distance to the curve it points to. You can let the arrow follow a spline arc or give it other shapes using the <code class="literal">connectionstyle</code> key.</p><p>Text properties or even a bounding box around the text can be made by extra keyword arguments to the annotate method, refer to the following figure (<em>Figure 6.12, left</em>):</p><p>Experimenting with annotations requires sometimes to remove attempts that we would like to reject. Therefore we assigned the annotate object to a variable, which allows us to remove the annotation by its <code class="literal">remove</code> method:</p><pre class="programlisting">annot1.remove()</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Filling areas between curves</h2></div></div></div><p>Filling is an ideal tool to highlight differences between curves, such as noise on top of expected data, approximations versus exact functions, and so on.</p><p>Filling is done by the axis method</p><pre class="programlisting">ax.fill_between(x,y1,y2)</pre><p>For the next figure we used:</p><pre class="programlisting">axf = ax.fill_between(x, sin(x), amod_sin(x), facecolor='gray')</pre><p> <code class="literal">where</code> is a very convenient parameter that needs a Boolean array to specify the additional filling conditions.</p><pre class="programlisting">axf = ax.fill_between(x, sin(x), amod_sin(x),where=amod_sin(x)-sin(x) &gt; 0, facecolor=’gray’)</pre><p>The Boolean array which selects the regions to fill is <code class="literal">amod_sin(x)-sin(x) &gt; 0</code>.</p><p>The next figure shows the curve with both variants of filling areas:</p><p>    </p><div><img src="img/amp_mod_sin23.jpg" alt="Filling areas between curves"/></div><p>
</p><p>Figure 6.12: The amplitude modulated sin-function with annotations and filled areas(left) and a modified figure with only partially filled areas by using the where parameter (right).</p><p>If you test these commands yourself, do not forget to remove the complete filling before you try out the partial filling, otherwise you will not see any change:</p><pre class="programlisting">axf.remove()</pre><p>Related filling commands are <code class="literal">fill</code> and <code class="literal">fill_betweenx</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Ticks and ticklabels</h2></div></div></div><p>Figures in talks, posters, and publications look much nicer if they are not overloaded with unnecessary information. You want to direct the spectator to those parts that contain the message. In our example, we clean up the picture by removing ticks from the <em>x</em>-axis and <em>y</em>-axis and by introducing problem related tick labels:</p><p>
</p><div><img src="img/amp_mod_sin4.jpg" alt="Ticks and ticklabels"/></div><p>
</p><p>Figure 6.13: The completed example of the amplitude modulated sine - function with annotations and filled areas and modified ticks and tick labels.</p><pre class="programlisting">ax.set_xticks(array([0,pi/2,pi,3/2*pi,2*pi]))&#13;
ax.set_xticklabels(('$0$','$\pi/2$','$\pi$','$3/2 \pi$','$2 \pi$'),fontsize=18)&#13;
ax.set_yticks(array([-1.,0.,1]))&#13;
ax.set_yticklabels(('$-1$','$0$','$1$'),fontsize=18)</pre><p>Note that we used LaTeX formatting in the strings to represent Greek letters, to set formulas correctly, and to use a LaTeX font. It is also a good practice to increase the font size so that the resulting figure can be scaled down into a text document without affecting the readability of the axes. The final result of this guiding example is shown in the previous figure (<em>Figure 6.13</em>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Making 3D plots</h1></div></div></div><p>There are some useful <code class="literal">matplotlib</code> tool kits and modules that can be used for a variety of special purposes. In this section, we describe a method for producing 3D-plots.</p><p>The <code class="literal">mplot3d</code> toolkit provides 3D plotting of points, lines, contours, surfaces, and all other basic components as well as 3D rotation and scaling. Making a 3D plot is done by adding the keyword <code class="literal">projection='3d'</code> to the axes object as shown in the following example:</p><pre class="programlisting">from mpl_toolkits.mplot3d import axes3d&#13;
&#13;
fig = figure()&#13;
ax = fig.gca(projection='3d')&#13;
# plot points in 3D&#13;
class1 = 0.6 * random.standard_normal((200,3))&#13;
ax.plot(class1[:,0],class1[:,1],class1[:,2],'o')&#13;
class2 = 1.2 * random.standard_normal((200,3)) + array([5,4,0])&#13;
ax.plot(class2[:,0],class2[:,1],class2[:,2],'o')&#13;
class3 = 0.3 * random.standard_normal((200,3)) + array([0,3,2])&#13;
ax.plot(class3[:,0],class3[:,1],class3[:,2],'o')</pre><p>As you can see, you need to import the <code class="literal">axes3D</code> type from <code class="literal">mplot3d</code>. The resulting plot displays the scattered 3D-data which can be seen in the following figure (<em>Figure 6.14</em>)</p><p>
</p><div><img src="img/scatter3d.jpg" alt="Making 3D plots"/></div><p>
</p><p>Figure 6.14: Plotting 3D data using mplot3d toolkit</p><p>Plotting surfaces is just as easy. The following example uses the built-in function <code class="literal">get_test_data</code> to create a sample data for plotting a surface. Consider the following example of a surface plot with transparency.</p><pre class="programlisting">X,Y,Z = axes3d.get_test_data(0.05)&#13;
&#13;
fig = figure()&#13;
ax = fig.gca(projection='3d')&#13;
# surface plot with transparency 0.5 &#13;
ax.plot_surface(X,Y,Z,alpha=0.5)</pre><p>The <em>alpha</em> value sets the transparency. The surface plot is shown in the following figure (<em>Figure 6.15</em>). </p><p>
</p><div><img src="img/surface_plot.jpg" alt="Making 3D plots"/></div><p>
</p><p>Figure 6.15: Example for plotting a surface mesh with three 2D projections.</p><p>You can also plot contours in any of the coordinate projections as in the next example.</p><pre class="programlisting">fig = figure()&#13;
ax = fig.gca(projection = '3d')&#13;
ax.plot_wireframe(X,Y,Z,rstride = 5,cstride = 5)&#13;
&#13;
# plot contour projection on each axis plane&#13;
ax.contour(X,Y,Z, zdir='z',offset = -100)&#13;
ax.contour(X,Y,Z, zdir='x',offset = -40)&#13;
ax.contour(X,Y,Z, zdir='y',offset = 40)&#13;
&#13;
# set axis limits&#13;
ax.set_xlim3d(-40,40)&#13;
ax.set_ylim3d(-40,40)&#13;
ax.set_zlim3d(-100,100)&#13;
&#13;
# set labels&#13;
ax.set_xlabel('X axis')&#13;
ax.set_ylabel('Y axis')&#13;
ax.set_zlabel('Z axis')</pre><p>Note the commands for setting the axis limits. The standard <code class="literal">matplotlib</code> commands for setting the axis limits are <code class="literal">axis([-40, 40, -40, 40])</code>, this works fine for 2D plots. However, <code class="literal">axis([-40,40,-40,40,-40,40])</code> does not work. For 3D plots you need to use the object oriented version of the commands, <code class="literal">ax.set_xlim3d(-40,40)</code> and likewise. The same goes for labeling the axis; note the commands for setting the labels. For 2D plots you can do <code class="literal">xlabel(’X axis’)</code> and <code class="literal">ylabel(’Y axis’)</code> but there is no <code class="literal">zlabel</code> command. Instead, in 3D plots you need to use <code class="literal">ax.set_xlabel(’X axis’)</code> and likewise, as shown in the preceding example.</p><p>The resulting figure from this code is the following</p><p>
</p><div><img src="img/wireframe_contours.jpg" alt="Making 3D plots"/></div><p>
</p><p>There are many options for formatting the appearance of the plots, including color and transparency of surfaces. The <code class="literal">mplot3d</code> documentation website, <a class="link" href="apa.html" title="Appendix . References">[23]</a>, has the details.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Making movies from plots</h1></div></div></div><p>If you have data that evolves, you might want to save it as a movie besides showing it in a figure window, similar to the <code class="literal">savefig</code> command. One way to do this is with the <code class="literal">visvis</code> module available at visvis (refer to <a class="link" href="apa.html" title="Appendix . References">[37]</a> for more information).</p><p>Here is a simple example of evolving a circle using an implicit representation. Let the circle be represented by the zero level, <img src="img/math_circle.jpg" alt="Making movies from plots"/>, of a function <img src="img/2d_function-1.jpg" alt="Making movies from plots"/>. Alternatively, consider the disk <img src="img/disk_math.jpg" alt="Making movies from plots"/> inside the zero set. If the value of <em>f</em> decreases at a rate <em>v</em> then the circle will move outward with rate <img src="img/nabla_math.jpg" alt="Making movies from plots"/>.</p><p>This can be implemented as:</p><pre class="programlisting">import visvis.vvmovie as vv&#13;
&#13;
# create initial function values&#13;
x = linspace(-255,255,511)&#13;
X,Y = meshgrid(x,x)&#13;
f = sqrt(X*X+Y*Y) - 40 #radius 40&#13;
&#13;
# evolve and store in a list&#13;
imlist = []&#13;
for iteration in range(200):&#13;
    imlist.append((f&gt;0)*255)&#13;
    f -= 1 # move outwards one pixel&#13;
vv.images2swf.writeSwf('circle_evolution.swf',imlist)</pre><p>The result is a Flash movie (*.swf file) of a growing black circle, as shown in the next figure (<em>Figure 6.16)</em>:</p><p>
</p><div><img src="img/circle_evolution_0-new.jpg" alt="Making movies from plots"/></div><p>
</p><p>Figure 6.16: An example of evolving a circle</p><p>In this example, a list of arrays was used to create the movie. The <code class="literal">visvis</code> module can also save an GIF animation and on certain platforms an AVI animation (*.gif and *.avi files<em>)</em>, and there is also the possibility to capturing movie frames directly from the figure window. These options, however, require some more packages to be installed on your system (for example, <code class="literal">PyOpenGL</code> and <code class="literal">PIL</code>, the Python Imaging Library). See the documentation on the <code class="literal">visvis</code> webpage for more details.</p><p>Another option is to use <code class="literal">savefig</code> to create images, one for each frame.</p><pre class="programlisting"># create initial function values&#13;
x = linspace(-255,255,511)&#13;
X,Y = meshgrid(x,x)&#13;
f = sqrt(X*X+Y*Y) - 40 #radius 40&#13;
for iteration in range(200):&#13;
    imshow((f&gt;0)*255)&#13;
    gray()&#13;
    axis('off')&#13;
    savefig('circle_evolution_{:d}.png'.format(iteration))&#13;
    f -= 1</pre><p>These images can then be combined using a standard video editing software, for example, Mencoder or ImageMagick. This approach has the advantage that you can make high-resolution videos by saving high-resolution images.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Summary</h1></div></div></div><p>A graphical representation is the most compact form in which to present mathematical results or the behavior of an algorithm. This chapter provided you with the basic tools for plotting and introduced you to a more sophisticated way to work with graphical objects, such as figures, axes, and lines in an object-oriented way.</p><p>In this chapter, you learned how to make plots, not only classical x/y-plots but also 3D-plots and histograms. We gave you an appetizer on making films. You also saw how to modify plots considering them to be graphical objects with related methods and attributes which can be set, deleted, or modified.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Exercises</h1></div></div></div><p>
<strong>Ex. 1</strong> → Write a function that plots an ellipse given its center coordinates (<em>x,y</em>), the half axis <em>a</em> and <em>b</em> rotation angle θ.</p><p>
<strong>Ex. 2</strong> → Write a short program that takes a 2D array, e.g., the preceding Mandelbrot contour image, and iteratively replace each value by the average of its neighbors. Update a contour plot of the array in a figure window to animate the evolution of the contours. Explain the behavior.</p><p>
<strong>Ex. 3</strong> → Consider an <em>N × N</em> matrix or image with integer values. The mapping</p><p>
</p><div><img src="img/I_map_math.jpg" alt="Exercises"/></div><p>
</p><p>is an example of a mapping of a toroidal square grid of points onto itself. This has the interesting property that it distorts the image by shearing and then moving the pieces outside the image back using the modulu function <code class="literal">mod</code>. Applied iteratively, this results in randomizing the image in a way that eventually returns the original. Implement the following sequence:</p><p>
</p><div><img src="img/I_map_iter_math.jpg" alt="Exercises"/></div><p>
</p><p>and save out the first N steps to files or plot them in a figure window.</p><p>As an example image, you can use the classic 512 <em>× </em> 512 Lena test image from <code class="literal">scipy.misc</code>.</p><pre class="programlisting">from scipy.misc import lena&#13;
I = lena()</pre><p>The result should look like this:</p><div><table border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p>
</p><div><img src="img/lena_cat_0.jpg" alt="Exercises"/></div><p>
</p>
</td><td>
<p>
</p><div><img src="img/lena_cat_1.jpg" alt="Exercises"/></div><p>
</p>
</td><td>
<p>…</p>
</td><td>
<p>
</p><div><img src="img/lena_cat_128.jpg" alt="Exercises"/></div><p>
</p>
</td><td>
<p>…</p>
</td><td>
<p>
</p><div><img src="img/lena_cat_256.jpg" alt="Exercises"/></div><p>
</p>
</td><td>
<p>…</p>
</td><td>
<p>
</p><div><img src="img/lena_cat_511.jpg" alt="Exercises"/></div><p>
</p>
</td><td>
<p>
</p><div><img src="img/lena_cat_512.jpg" alt="Exercises"/></div><p>
</p>
</td></tr><tr><td>
<p>0</p>
</td><td>
<p>1</p>
</td><td>
</td><td>
<p>128</p>
</td><td>
</td><td>
<p>256</p>
</td><td>
</td><td>
<p>511</p>
</td><td>
<p>512</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>Compute the <em>x</em> and <em>y</em> mappings and use array indexing (refer to section <em>Array Indexing</em> in <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <em>Advance Array Concepts</em>) to copy the pixel values.</p></div></div><p>
<strong>Ex. 4</strong> → Reading and plotting on images. SciPy comes with the <code class="literal">imread</code> function (in the <code class="literal">scipy.misc</code> module) for reading images, (refer to section<em> Reading and Writing Images</em> in <a class="link" href="ch12.html" title="Chapter 12. Input and Output">Chapter 12</a>, <em>Input and output</em>). Write a short program that reads an image from file and plots the image contour at a given gray level value overlaid on the original image.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>You can get a gray level version of the image by averaging the color channels like this: <code class="literal">mean(im,axis=2)</code>
</p></div></div><p>
<strong>Ex. 5</strong> → Image edges. The zero crossings of the 2D Laplacian are a good indication of image edges. Modify the program in the previous exercise to use the <code class="literal">gaussian_laplace</code> or <code class="literal">laplace</code> function from the <code class="literal">scipy.ndimage</code> module to compute the 2D Laplacian and overlay the edges on top of the image.</p><p>
<strong>Ex. 6</strong> → Reformulate the Mandelbrod fractal example (see section <em>Images and Contours)</em> by using <code class="literal">orgid</code> instead of <code class="literal">meshgrid,</code> see also the explanation <code class="literal">ogrid</code> in <em>Function of two variables</em> in <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <em>Advanced Array Concepts</em>. What is the difference between <code class="literal">orgid</code>, <code class="literal">mgrid</code>, and <code class="literal">meshgrid</code>?</p></div></body></html>