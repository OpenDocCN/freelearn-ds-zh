<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Reading Excel Spreadsheets</h1>
			<p>In the deep and wide landscape of data analysis, Excel stands tall and by your side as a trusted warrior, simplifying the process of organizing, calculating, and presenting information. Its intuitive interface and widespread usage have cemented its position as a staple in the business world. However, as the volume and complexity of data continue to grow exponentially, Excel’s capabilities may start to feel constrained. It is precisely at this point that the worlds of Excel, R, and Python converge. Extending Excel with R and Python invites you to embark on a truly transformative journey. This trip will show you the power of these programming languages as they synergize with Excel, expanding its horizons and empowering you to conquer data challenges with ease. In this book, we will delve into how to integrate Excel with R and Python, uncovering the hidden potential that lies beneath the surface and enabling you to extract valuable insights, automate processes, and unleash the true power of data analysis.</p>
			<p>Microsoft Excel came to market in 1985 and has remained a popular spreadsheet software choice. Excel<a id="_idIndexMarker000"/> was originally known as MultiPlan. Microsoft Excel and databases in general share some similarities in terms of organizing and managing data, although they serve different purposes. Excel is a spreadsheet program that allows users to store and manipulate data in a tabular format. It consists of rows and columns, where each cell can contain text, numbers, or formulas. Similarly, a database is a structured collection of data stored in tables, consisting of rows and columns.</p>
			<p>Both Excel and databases provide a way to store and retrieve data. In Excel, you can enter data, perform calculations, and create charts and graphs. Similarly, databases store and manage large amounts of structured data and enable querying, sorting, and filtering. Excel and databases also support the concept of relationships. In Excel, you can link cells or ranges across different sheets, creating connections between data. Databases use relationships to link tables based on common fields, allowing you to retrieve related data from multiple tables.</p>
			<p>This chapter aims to familiarize you with reading Excel files into the R environment and performing some manipulation on them. Specifically, in this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>R packages for Excel manipulation</li>
				<li>Reading Excel files to manipulate with R</li>
				<li>Reading multiple Excel sheets with a custom R function</li>
				<li>Python packages for Excel manipulation</li>
				<li>Opening an Excel sheet from Python and reading the data</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>At the time of writing, we are using the following:</p>
			<ul>
				<li>R 4.2.1</li>
				<li>The RStudio 2023.03.1+446 “Cherry Blossom” release for Windows</li>
			</ul>
			<p>For this chapter, you will need to install the following packages:</p>
			<ul>
				<li><code>readxl</code></li>
				<li><code>openxlsx</code></li>
				<li><code>xlsx</code></li>
			</ul>
			<p>To run the Python code in this chapter, we will be using the following:</p>
			<ul>
				<li>Python 3.11</li>
				<li><code>pandas</code></li>
				<li><code>openpyxl</code></li>
				<li>The <code>iris.xlsx</code> Excel file available in this book’s GitHub repository</li>
			</ul>
			<p>While setting up a Python environment is outside the scope of this book, this is easy to do. The necessary packages can be installed by running the following commands:</p>
			<pre class="console">
python -m pip install pandas==2.0.1
python -m pip install openpyxl==3.1.2</pre>			<p>Note that these commands have to be run from a terminal and not from within a Python script. They need to be run in the folder where <code>requirements.txt</code> resides or a full path to the <code>requirements.txt</code> file has to be included. </p>
			<p>This book’s GitHub repository also contains a <code>requirements.txt</code> file that you can use to install all dependencies. You can do this by running the following command:</p>
			<pre class="console">
python -m pip install -r requirements.txt</pre>			<p>This command installs all the packages that will be used in this chapter so that you don’t have to install them one by one. It also guarantees that the whole dependency tree (including the dependencies of the dependencies) will be the same as what this book’s authors have used.</p>
			<p>Alternatively, when using Jupyter Notebooks, you can use the following magic commands:</p>
			<pre class="console">
%pip install pandas==2.0.1
%pip install openpyxl==3.1.2</pre>			<p>There is a GitHub account for all of the code examples in this book located at this link: <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R</a>. Each chapter has it’s own folder, with the current one as <code>Chapter01</code>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Technical requirements for Python throughout the book are conveniently compiled in the <code>requirements.txt</code> file, accessible on GitHub repository here, <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/blob/main/requirements.txt">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/blob/main/requirements.txt</a>. Installing these dependencies will streamline your coding experience and ensure smooth progression through the book. Be sure to install them all before diving into the exercises.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Working with R packages for Excel manipulation</h1>
			<p>There are several packages available both on CRAN and on GitHub that allow for reading and manipulation of Excel files. In this section, we are specifically going to focus on the packages: <code>readxl</code>, <code>openxlsx</code>, and <code>xlsx</code> to read Excel files. These three packages all have their own functions to read Excel files. These functions are as follows:</p>
			<ul>
				<li><code>readxl::read_excel() </code></li>
				<li><code>openxlsx::read.xlsx()</code></li>
				<li><code>xlsx::read.xlsx()</code></li>
			</ul>
			<p>Each function has a set of parameters and conventions to follow. Since <code>readxl</code> is part of the <code>tidyverse</code> collection of packages, it follows its conventions and returns a <code>tibble</code> object upon reading the file. If you do not know what a tibble is, it is a modern version of R’s <code>data.frame</code>, a sort of spreadsheet in the R environment. It is the building block of most analyses. Moving on to <code>openxlsx</code> and <code>xlsx</code>, they both return a base R <code>data.frame</code> object, with the latter also able to return a <code>list</code> object. If you are wondering how this relates to manipulating an actual Excel file, I can explain. First, to manipulate something in R, the data must be in the R environment, so you cannot manipulate the file unless the data is read in. These packages have different functions for manipulating Excel or reading data in certain ways that allow for further analysis and or manipulation. It is important to note that <code>xlsx</code> does require Java to be installed.</p>
			<p>As we transition from our exploration of R packages for Excel manipulation, we’ll turn our attention to the crucial task of effectively reading Excel files into R, thereby unlocking even more possibilities for data analysis and manipulation.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Reading Excel files to R</h1>
			<p>In this section, we are<a id="_idIndexMarker001"/> going to read<a id="_idIndexMarker002"/> data from Excel with a few different R libraries. We need to do this before we can even consider performing any type of manipulation or analysis on the data contained in the sheets of the Excel files.</p>
			<p>As mentioned in the Technical requirements section, we are going to be using the <code>readxl</code>, <code>openxlsx</code>, and <code>xlsx</code> packages to read data into R.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing and loading libraries</h2>
			<p>In this section, we are going<a id="_idIndexMarker003"/> to install and load<a id="_idIndexMarker004"/> the necessary libraries if you do not yet have them. We are going to use the <code>openxlsx</code>, <code>xlsx</code>, <code>readxl</code>, and <code>readxlsb</code> libraries. To install and load them, run the following code block:</p>
			<pre class="source-code">
pkgs &lt;- c("openxlsx", "xlsx", "readxl")
install.packages(pkgs, dependencies = TRUE)
lapply(pkgs, library, character.only = TRUE)</pre>			<p>The <code>lapply()</code> function in R is a versatile tool for applying a function to each element of a list, vector, or <code>DataFrame</code>. It takes two arguments, <code>x</code> and <code>FUN</code>, where <code>x</code> is the list and <code>FUN</code> is the function that is applied to the list object, <code>x</code>.</p>
			<p>Now that the libraries have been installed, we can get to work. To do this, we are going to read a spreadsheet built from the Iris dataset that is built into base R. We are going to read the file with three different libraries, and then we are going to create a custom function to work with the <code>readxl</code> library that will read all the sheets of an Excel file. We will call this the <code>read_excel_sheets()</code> function.</p>
			<p>Let’s start reading the files. The first library we will use to open an Excel file is <code>openxlsx</code>. To read the Excel file we are working with, you can run the code in the <code>chapter1</code> folder of this book’s GitHub repository called <code>ch1_create_iris_dataset.R</code>  Refer to the following screenshot to see how to read the file into R.</p>
			<p>You will notice a variable called <code>f_pat</code>. This is the path to where the Iris dataset was saved as an Excel file – for example, <code>C:/User/UserName/Documents/iris_data.xlsx</code>:</p>
			<div><div><img src="img/B19142_01_1.jpg" alt="Figure 1.1 – Using the openxlsx package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Using the openxlsx package to read the Excel file</p>
			<p>The preceding screenshot shows<a id="_idIndexMarker005"/> how to read an Excel<a id="_idIndexMarker006"/> file. This example assumes that you have used the <code>ch1_create_iris_datase.R</code> file to create the example Excel file. In reality, you can read in any Excel file that you would like or need.</p>
			<p>Now, we will perform the same type of operation, but this time with the <code>xlsx</code> library. Refer to the following screenshot, which uses the same methodology as with the <code>openxlsx</code> package:</p>
			<div><div><img src="img/B19142_01_2.jpg" alt="Figure 1.2 – Using the xlsx library and the read.xlsx() function to open the Excel file we’ve created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Using the xlsx library and the read.xlsx() function to open the Excel file we’ve created</p>
			<p>Finally, we will use<a id="_idIndexMarker007"/> the <code>readxl</code> library, which is part <a id="_idIndexMarker008"/>of the tidyverse:</p>
			<div><div><img src="img/B19142_01_3.jpg" alt="Figure 1.3 – Using the readxl library and the read_excel() function to read the Excel file into memory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Using the readxl library and the read_excel() function to read the Excel file into memory</p>
			<p>In this section, we learned<a id="_idIndexMarker009"/> how to read in an Excel file with a few different packages. While these packages<a id="_idIndexMarker010"/> can do more than simply read in an Excel file, that is what we needed to focus on in this section. You should now be familiar with how to use the <code>readxl::read_excel()</code>, <code>xlsx::read.xlsx()</code>, and  <code>openxlsx::read.xlsx()</code> functions.</p>
			<p>Building upon our expertise in reading Excel files into R, we’ll now embark on the next phase of our journey: unraveling the secrets of efficiently extracting data from multiple sheets within an Excel file.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Reading multiple sheets with readxl and a custom function</h1>
			<p>In Excel, we often encounter <a id="_idIndexMarker011"/>workbooks that<a id="_idIndexMarker012"/> have multiple sheets in them. These could be stats for different months of the year, table data that follows a specific format month over month, or some other period. The point is that we may want to read all the sheets in a file for one reason or another, and we should not call the read function from a particular package for each sheet. Instead, we should use the power of R to loop through this with <code>purrr</code>.</p>
			<p>Let’s build a customized<a id="_idIndexMarker013"/> function. To do this, we are going to load the <code>readxl</code> function. If we have it already loaded, then this is not necessary; however, if it is already installed and you do not wish to load the library into memory, then you can call the <code>excel_sheets()</code> function by using <code>readxl::excel_sheets()</code>:</p>
			<div><div><img src="img/B19142_01_4.jpg" alt="Figure 1.4 – Creating a function to read all the sheets into an Excel file at once – read_excel_sheets()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Creating a function to read all the sheets into an Excel file at once – read_excel_sheets()</p>
			<p>The new code can be broken down as follows:</p>
			<pre class="console">
 read_excel_sheets &lt;- function(filename, single_tbl) {</pre>			<p>This line defines a function<a id="_idIndexMarker014"/> called <code>read_excel_sheets</code> that takes two arguments: <code>filename</code> (the name of the Excel file to be read) and <code>single_tbl</code> (a logical value indicating whether the function should return a single table or a list of tables).</p>
			<p>Next, we have the following line:</p>
			<pre class="console">
sheets &lt;- readxl::excel_sheets(filename)</pre>			<p>This line uses the <code>readxl</code> package<a id="_idIndexMarker015"/> to extract the names of all the sheets<a id="_idIndexMarker016"/> in the Excel file specified by <code>filename</code>. The sheet names are stored in the <code>sheets</code> variable.</p>
			<p>Here’s the next line:</p>
			<pre class="console">
if (single_tbl) {</pre>			<p>This line starts an <code>if</code> statement that checks the value of the <code>single_tbl</code> argument.</p>
			<p>Now, we have the following:</p>
			<pre class="console">
x &lt;- purrr::map_df(sheets, read_excel, path = filename)</pre>			<p>If <code>single_tbl</code> is <code>TRUE</code>, this line uses the <code>purrr</code> package’s <code>map_df</code> function to iterate over each sheet name in <code>sheets</code> and read the corresponding sheet using the <code>read_excel</code> function from the <code>readxl</code> package. The resulting <code>DataFrame</code> are combined into a single table, which is assigned to the <code>x</code> variable.</p>
			<p>Now, we have the following line:</p>
			<pre class="console">
} else {</pre>			<p>This line indicates the start of the <code>else</code> block of the <code>if</code> statement. If <code>single_tbl</code> is <code>FALSE</code>, the code in this block will be executed.</p>
			<p>Here’s the next line:</p>
			<pre class="console">
 x &lt;- purrr::map(sheets, ~ readxl::read_excel(filename, sheet = .x))</pre>			<p>In this line, the <code>purrr</code> package’s <code>map</code> function<a id="_idIndexMarker017"/> is used to iterate over each sheet<a id="_idIndexMarker018"/> name in <code>sheets</code>. For each sheet, the <code>read_excel</code> function<a id="_idIndexMarker019"/> from the <code>readxl</code> package is called to read the corresponding sheet from the Excel file specified by <code>filename</code>. The resulting <code>DataFrame</code> are stored in a list assigned to the <code>x</code> variable.</p>
			<p>Now, we have the following:</p>
			<pre class="console">
 purrr::set_names(x, sheets)</pre>			<p>This line uses the <code>set_names</code> function from the <code>purrr</code> package to set the names of the elements in the <code>x</code> list to the sheet names in sheets.</p>
			<p>Finally, we have the following line:</p>
			<pre class="console">
 x</pre>			<p>This line returns the value of <code>x</code> from the function, which will be either a single table (<code>data.frame</code>) if <code>single_tbl</code> is <code>TRUE</code>, or a list of tables (<code>data.frame</code>) if <code>single_tbl</code> is <code>FALSE</code>.</p>
			<p>In summary, the <code>read_excel_sheets</code> function takes an Excel filename and a logical value indicating whether to return a single table or a list of tables. It uses the <code>readxl</code> package to extract the sheet names from the Excel file, and then reads the corresponding sheets either into a single table (if <code>single_tbl</code> is <code>TRUE</code>) or into a list of tables (if <code>single_tbl</code> is <code>FALSE</code>). The resulting data is returned as the output of the function. To see how this works, let’s look at the following example.</p>
			<p>We have a spreadsheet that has four tabs in it – one for each species in the famous Iris dataset and then one sheet called <code>iris</code>, which is the full dataset.</p>
			<p>As shown in <em class="italic">Figure 1</em><em class="italic">.5</em>, the <code>read_excel_sheets()</code> function has read all four sheets of the Excel file. We can also see that the function has imported the sheets as a list object and has named each item in the list after the name of the corresponding tab in the Excel file. It is also important to note that the sheets must all have the same column names and structure for this to work:</p>
			<div><div><img src="img/B19142_01_5.jpg" alt="Figure 1.5 – Excel file read by read_excel_sheets()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Excel file read by read_excel_sheets()</p>
			<p>In this section, we learned<a id="_idIndexMarker020"/> how to write<a id="_idIndexMarker021"/> a function that will read<a id="_idIndexMarker022"/> all of the sheets in any Excel file. This function will also return them as a named item list, where the names are the names of the tabs in the file itself.</p>
			<p>Now that we have learned how to read Excel sheets in R, in the next section, we will cover Python, where we will revisit the same concepts but from the perspective of the Python language.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Python packages for Excel manipulation</h1>
			<p>In this section, we will explore how to read Excel spreadsheets using Python. One of the key aspects of working with Excel files in Python is having the right set of packages that provide the necessary functionality. In this section, we will discuss some commonly used Python packages for Excel manipulation and highlight their advantages and considerations.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Python packages for Excel manipulation</h2>
			<p>When it comes to interacting<a id="_idIndexMarker023"/> with Excel files in Python, several packages offer a range of features and capabilities. These packages allow you to extract data from Excel files, manipulate the data, and write it back to Excel files. Let’s take a look at some popular Python packages for Excel manipulation.</p>
			<h3>pandas</h3>
			<p><code>pandas</code> is a powerful<a id="_idIndexMarker024"/> data manipulation<a id="_idIndexMarker025"/> library that can read Excel files using the <code>read_excel</code> function. The advantage of using <code>pandas</code> is that it provides a <code>DataFrame</code> object, which allows you to manipulate the data in a tabular form. This makes it easy to perform data analysis and manipulation. <code>pandas</code> excels in handling large datasets efficiently and provides flexible options for data filtering, transformation, and aggregation.</p>
			<h3>openpyxl</h3>
			<p><code>openpyxl</code> is a widely used<a id="_idIndexMarker026"/> library specifically <a id="_idIndexMarker027"/>designed for working with Excel files. It provides a comprehensive set of features for reading and writing Excel spreadsheets, including support for various Excel file formats and compatibility with different versions of Excel. In addition, <code>openpyxl</code> allows fine-grained control over the structure and content of Excel files, enabling tasks such as accessing<a id="_idIndexMarker028"/> individual cells, creating<a id="_idIndexMarker029"/> new worksheets, and applying formatting.</p>
			<h3>xlrd and xlwt</h3>
			<p><code>xlrd</code> and <code>xlwt</code> are older libraries<a id="_idIndexMarker030"/> that are still<a id="_idIndexMarker031"/> in use for reading and writing<a id="_idIndexMarker032"/> Excel files, particularly<a id="_idIndexMarker033"/> with legacy formats such as <code>.xls</code>. <code>xlrd</code> enables reading data from Excel files, while <code>xlwt</code> facilitates writing data to Excel files. These libraries are lightweight and straightforward to use, but they lack some of the advanced features provided by <code>pandas</code> and <code>openpyxl</code>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Considerations</h2>
			<p>When choosing a Python<a id="_idIndexMarker034"/> package for Excel manipulation, it’s essential to consider the specific requirements of your project. Here are a few factors to keep in mind:</p>
			<ul>
				<li><strong class="bold">Functionality</strong>: Evaluate the package’s capabilities and ensure it meets your needs for reading Excel files. Consider whether you require advanced data manipulation features or if a simpler package will suffice.</li>
				<li><code>pandas</code>, which have optimized algorithms, can offer significant performance advantages.</li>
				<li><strong class="bold">Compatibility</strong>: Check the compatibility of the package with different Excel file formats and versions. Ensure that it supports the specific format you are working with to avoid any compatibility issues.</li>
				<li><code>pandas</code>, have a more extensive range of functionality, but they may require additional time and effort to master.</li>
			</ul>
			<p>Each package offers unique features and has its strengths and weaknesses, allowing you to read Excel spreadsheets effectively in Python. For example, if you need to read and manipulate large amounts of data, <code>pandas</code> may be the better choice. However, if you need fine-grained control over the Excel file, <code>openpyxl</code> will likely fit your needs better.</p>
			<p>Consider the specific requirements<a id="_idIndexMarker035"/> of your project, such as data size, functionality, and compatibility, to choose the most suitable package for your needs. In the following sections, we will delve deeper into how to utilize these packages to read and extract data from Excel files using Python.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Opening an Excel sheet from Python and reading the data</h1>
			<p>When working with Excel files<a id="_idIndexMarker036"/> in Python, it’s common to need<a id="_idIndexMarker037"/> to open a specific<a id="_idIndexMarker038"/> sheet and read the data into Python<a id="_idIndexMarker039"/> for further analysis. This can be achieved using popular libraries such as <code>pandas</code> and <code>openpyxl</code>, as discussed in the previous section.</p>
			<p>You can most likely use other Python and package versions, but the code in this section has not been tested with anything other than what we’ve stated here.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Using pandas</h2>
			<p><code>pandas</code> is a powerful data<a id="_idIndexMarker040"/> manipulation library that simplifies the process of working with structured data, including Excel spreadsheets. To read an Excel sheet using <code>pandas</code>, you can use the <code>read_excel</code> function. Let’s consider an example of using the <code>iris_data.xlsx</code> file with a sheet named <code>setosa</code>:</p>
			<pre class="source-code">
import pandas as pd
# Read the Excel file
df = pd.read_excel('iris_data.xlsx', sheet_name='setosa')
# Display the first few rows of the DataFrame
print(df.head())</pre>			<p>You will need to run this code either with the Python working directory set to the location where the Excel file is located, or you will need to provide the full path to the file in the <code>read_excel()</code> command:</p>
			<div><div><img src="img/B19142_01_6.jpg" alt="Figure 1.6 – Using the pandas package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Using the pandas package to read the Excel file</p>
			<p>In the preceding code snippet, we imported the <code>pandas</code> library and utilized the <code>read_excel</code> function to read <code>setosa</code> from the <code>iris_data.xlsx</code> file. The resulting data is stored in a <code>pandas</code> <code>DataFrame</code>, which provides a tabular representation of the data. By calling <code>head()</code> on the <code>DataFrame</code>, we displayed<a id="_idIndexMarker041"/> the first few rows of the data, giving us a quick preview.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using openpyxl</h2>
			<p><code>openpyxl</code> is a powerful library<a id="_idIndexMarker042"/> for working with Excel files, offering more granular control over individual cells and sheets. To open an Excel sheet and access its data using <code>openpyxl</code>, we can utilize the <code>load_workbook</code> function. Please note that <code>openpyxl</code> cannot handle <code>.xls</code> files, only the more modern <code>.xlsx</code> and <code>.</code><code>xlsm</code> versions.</p>
			<p>Let’s consider an example<a id="_idIndexMarker043"/> of using the <code>iris_data.xlsx</code> file with a sheet named <code>versicolor</code>:</p>
			<pre class="source-code">
import openpyxl
import pandas as pd
# Load the workbook
wb = openpyxl.load_workbook('iris_data.xlsx')
# Select the sheet
sheet = wb['versicolor']
# Extract the values (including header)
sheet_data_raw = sheet.values
# Separate the headers into a variable
header = next(sheet_data_raw)[0:]
# Create a DataFrame based on the second and subsequent lines of data with the header as column names
sheet_data = pd.DataFrame(sheet_data_raw, columns=header)
print(sheet_data.head())</pre>			<p>The preceding code results in the following output:</p>
			<div><div><img src="img/B19142_01_7.jpg" alt="Figure 1.7 – Using the openpyxl package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Using the openpyxl package to read the Excel file</p>
			<p>In this code snippet, we import the <code>load_workbook</code> function from the <code>openpyxl</code> library. Then, we load the workbook by providing the <code>iris_data.xlsx</code> filename. Next, we select the desired sheet by accessing it using its name – in this case, this is <code>versicolor</code>. Once we’ve done this, we read the raw data using the <code>values</code> property of the loaded sheet object. This is a generator and can be accessed via a <code>for</code> cycle or by converting it into a list or a <code>DataFrame</code>, for example. In this example, we have converted it into a <code>pandas</code> <code>DataFrame</code> because it is the format that is the most comfortable to work with later.</p>
			<p>Both <code>pandas</code> and <code>openpyxl</code> offer valuable features for working with Excel files in Python. While pandas simplifies data manipulation with its <code>DataFrame</code> structure, <code>openpyxl</code> provides more fine-grained control over individual cells and sheets. Depending on your specific requirements, you can choose the library that best suits your needs.</p>
			<p>By mastering the techniques<a id="_idIndexMarker044"/> of opening Excel sheets and reading data into Python, you will be able to extract valuable insights from your Excel data, perform various data transformations, and prepare it for further analysis or visualization. These skills are essential<a id="_idIndexMarker045"/> for anyone seeking to leverage the power of Python and Excel in their data-driven workflows.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Reading in multiple sheets with Python (openpyxl and custom functions)</h1>
			<p>In many Excel files, it’s common<a id="_idIndexMarker046"/> to have multiple sheets<a id="_idIndexMarker047"/> containing different sets of data. Being able to read in multiple sheets and consolidate the data into a single data structure can be highly valuable for analysis and processing. In this section, we will explore how to achieve this using the <code>openpyxl</code> library and a custom function.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>The importance of reading multiple sheets</h2>
			<p>When working with complex<a id="_idIndexMarker048"/> Excel files, it’s not uncommon to encounter scenarios where related data is spread across different sheets. For example, you may have one sheet for sales data, another for customer information, and yet another for product inventory. By reading in multiple sheets and consolidating the data, you can gain a holistic view and perform a comprehensive analysis.</p>
			<p>Let’s start by examining the basic steps involved in reading in multiple sheets:</p>
			<ol>
				<li><code>load_workbook</code> function provided by <code>openpyxl</code>.</li>
				<li><code>sheetnames</code> attribute. This allows us to identify the sheets we want to read.</li>
				<li><code>Openpyxl</code> provides methods such as <code>iter_rows</code> or <code>iter_cols</code> to traverse the cells of each sheet and retrieve the desired data.</li>
				<li><code>pandas</code> <code>DataFrame</code> or a Python list. As we read the data from each sheet, we concatenate<a id="_idIndexMarker050"/> or merge it into the consolidated data structure:<ul><li>If the data in all sheets follows the same format (as is the case in the example used in this chapter), we can simply concatenate the datasets</li><li>However, if the datasets have different structures because they describe different aspects of a dataset (for example, one sheet contains product information, the next contains customer data, and the third contains the sales of the products to the customers), then we can merge these datasets based on unique identifiers to create a comprehensive dataset</li></ul></li>
			</ol>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Using openpyxl to access sheets</h2>
			<p><code>openpyxl</code> is a powerful library<a id="_idIndexMarker051"/> that allows<a id="_idIndexMarker052"/> us to interact with Excel files using Python. It provides a wide range of functionalities, including accessing and manipulating multiple sheets. Before we dive into the details, let’s take a moment to understand why <code>openpyxl</code> is a popular choice for this task.</p>
			<p>One of the primary advantages of <code>openpyxl</code> is its ability to handle various Excel file formats, such as <code>.xlsx</code> and <code>.xlsm</code>. This flexibility allows us to work with different versions of Excel files without compatibility issues. Additionally, <code>openpyxl</code> provides a straightforward and intuitive interface to access sheet data, making it easier for us to retrieve the desired information.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Reading data from each sheet</h2>
			<p>To begin reading in multiple<a id="_idIndexMarker053"/> sheets, we need<a id="_idIndexMarker054"/> to load the Excel workbook using the <code>load_workbook</code> function provided by <code>openpyxl</code>. This function takes the file path as input and returns a workbook object that represents the entire Excel file.</p>
			<p>Once we have loaded the workbook, we can retrieve the names of all the sheets using the sheetnames attribute. This gives us a list of sheet names present in the Excel file. We can then iterate over these sheet names to read the data from each sheet individually.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Retrieving sheet data with openpyxl</h2>
			<p><code>openpyxl</code> provides various <a id="_idIndexMarker055"/>methods to access<a id="_idIndexMarker056"/> the data within a sheet.</p>
			<p>Two commonly used methods are <code>iter_rows</code> and <code>iter_cols</code>. These methods allow us to iterate over the rows or columns of a sheet and retrieve the cell values.</p>
			<p>Let’s have a look at how <code>iter_rows</code> can be used:</p>
			<pre class="source-code">
# Assuming you are working with the first sheet
sheet = wb['versicolor']
# Iterate over rows and print raw values
for row in sheet.iter_rows(min_row=1, max_row=5, values_only=True):
    print(row)</pre>			<p>Similarly, <code>iter_cols</code> can be used like this:</p>
			<pre class="source-code">
# Iterate over columns and print raw values
for column in sheet.iter_cols(min_col=1, max_col=5, values_only=True):
    print(column)</pre>			<p>When using <code>iter_rows</code> or <code>iter_cols</code>, we can specify whether we want to retrieve the cell values as raw values or as formatted values. Raw values give us the actual data stored in the cells, while formatted values include any formatting applied to the cells, such as date formatting or number formatting.</p>
			<p>By iterating over the rows or columns of a sheet, we can retrieve the desired data and store it in a suitable data structure. One popular choice is to use <code>pandas</code> <code>DataFrame</code>, which provide a tabular representation of the data and offer convenient methods for data manipulation and analysis.</p>
			<p>An alternative solution is using the <code>values</code> attribute of the sheet object. This provides a generator for all values<a id="_idIndexMarker057"/> in the sheet (much like <code>iter_rows</code> and <code>iter_cols</code> do for rows<a id="_idIndexMarker058"/> and columns, respectively). While generators cannot be used directly to access the data, they can be used in <code>for</code> cycles to iterate over each value. The <code>pandas</code> library’s <code>DataFrame</code> function also allows direct conversion from a suitable generator object to a <code>DataFrame</code>.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Combining data from multiple sheets</h2>
			<p>As we read the data<a id="_idIndexMarker059"/> from each<a id="_idIndexMarker060"/> sheet, we can store it in a list or dictionary, depending on our needs. Once we have retrieved the data from all the sheets, we can combine it into a single consolidated data structure. This step is crucial for further analysis and processing.</p>
			<p>To combine the data, we can use <code>pandas</code> <code>DataFrame</code>. By creating individual <code>DataFrame</code> for each sheet’s data and then concatenating or merging them into a single <code>DataFrame</code>, we can obtain a comprehensive dataset that includes all the information from multiple sheets.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Custom function for reading multiple sheets</h2>
			<p>To simplify the process of reading<a id="_idIndexMarker061"/> in multiple sheets <a id="_idIndexMarker062"/>and consolidating the data, we can create custom functions tailored to our specific requirements. These functions encapsulate the necessary steps and allow us to reuse the code efficiently.</p>
			<p>In our example, we define a function called <code>read_multiple_sheets</code> that takes the file path as input. Inside the function, we load the workbook using <code>load_workbook</code> and iterate over the sheet names retrieved with the sheets attribute.</p>
			<p>For each sheet, we access it using the workbook object and retrieve the data using the custom read_single_sh<code>eet</code> function. We then store the retrieved data in a list. Finally, we combine the data from all the sheets into a single <code>pandas</code> <code>DataFrame</code> using the appropriate concatenation method from <code>pandas</code>.</p>
			<p>By using these custom functions, we can easily read in multiple sheets from an Excel file and obtain a consolidated dataset that’s ready for analysis. The function provides a reusable and efficient solution, saving us time and effort in dealing with complex Excel files.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Customizing the code</h2>
			<p>The provided example is a starting point that you can customize based on your specific requirements. Here are a few considerations<a id="_idIndexMarker063"/> for customizing the code:</p>
			<ul>
				<li><code>iter_cols</code> method instead of the <code>values</code> attribute and using a filtered list in a <code>for</code> cycle or by filtering the resulting <code>pandas</code> <code>DataFrame</code> object(s).</li>
				<li><strong class="bold">Handling missing data</strong>: If the sheets contain missing data, you can incorporate appropriate handling techniques, such as filling in missing values or excluding incomplete rows.</li>
				<li><strong class="bold">Applying transformations</strong>: Depending on the nature of your data, you might need to apply transformations or calculations to the consolidated dataset. The custom function<a id="_idIndexMarker064"/> can be expanded to accommodate these transformations.</li>
			</ul>
			<p>Remember, the goal is to tailor the code to suit your unique needs and ensure it aligns with your data processing requirements.</p>
			<p>By leveraging the power <a id="_idIndexMarker065"/>of <code>openpyxl</code> and creating custom functions, you can efficiently read in multiple sheets from Excel files, consolidate the data, and prepare it for further analysis. This capability enables you to unlock valuable insights from complex Excel files and leverage the full potential of your data.</p>
			<p>Now, let’s dive into an example that demonstrates this process:</p>
			<pre class="source-code">
from openpyxl import load_workbook
import pandas as pd
def read_single_sheet(workbook, sheet_name):
   # Load the sheet from the workbook
    sheet = workbook[sheet_name]
    # Read out the raaw data including headers
    sheet_data_raw = sheet.values
    # Separate the headers into a variable
    columns = next(sheet_data_raw)[0:]
    # Create a DataFrame based on the second and subsequent lines of data with the header as column names and return it
    return pd.DataFrame(sheet_data_raw, columns=columns)
def read_multiple_sheets(file_path):
    # Load the workbook
    workbook = load_workbook(file_path)
    # Get a list of all sheet names in the workbook
    sheet_names = workbook.sheetnames
    # Cycle through the sheet names, load the data for each and concatenate them into a single DataFrame
    return pd.concat([read_single_sheet(workbook=workbook, sheet_name=sheet_name) for sheet_name in sheet_names], ignore_index=True)
# Define the file path and sheet names
file_path = 'iris_data.xlsx' # adjust the path as needed
# Read the data from multiple sheets
consolidated_data = read_multiple_sheets(file_path)
# Display the consolidated data
print(consolidated_data.head())</pre>			<p>Let’s have a look at the results:</p>
			<div><div><img src="img/B19142_01_8.jpg" alt="Figure 1.8 – Using the openxlsx package to read in the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Using the openxlsx package to read in the Excel file</p>
			<p>In the preceding code, we define<a id="_idIndexMarker066"/> two functions:</p>
			<ul>
				<li><code>read_single_sheet</code>: This reads the data from a single sheet into a <code>pandas</code> <code>DataFrame</code></li>
				<li><code>read_multiple_sheets</code>: This reads and concatenates the data from all sheets in the workbook</li>
			</ul>
			<p>Within the <code>read_multiple_sheets</code> function, we load the workbook using <code>load_workbook</code> and iterate over the sheet names. For each sheet, we retrieve the data using the <code>read_single_sheet</code> helper function, which reads the data from a sheet and creates a <code>pandas</code> <code>DataFrame</code> for each sheet’s data, with the header row used as column names. Finally, we use <code>pd.concat</code> to combine all the <code>DataFrame</code> into a single consolidated <code>DataFrame</code>.</p>
			<p>By utilizing these custom functions, we can easily read in multiple sheets from an Excel file and obtain a consolidated dataset. This allows us to perform various data manipulations, analyses, or visualizations on the combined data.</p>
			<p>Understanding how to handle<a id="_idIndexMarker067"/> multiple sheets efficiently enhances our ability to work with complex Excel files and extract valuable insights from diverse datasets.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
			<p>In this chapter, we explored the process of importing data from Excel spreadsheets into our programming environments. For R users, we delved into the functionalities of libraries such as <code>readxl</code>, <code>xlsx</code>, and <code>openxlsx</code>, providing efficient solutions for extracting and manipulating data. We also introduced a custom function, <code>read_excel_sheets</code>, to streamline the process of extracting data from multiple sheets within Excel files. On the Python side, we discussed the essential <code>pandas</code> and <code>openpyxl</code> packages for Excel manipulation, demonstrating their features through practical examples. At this point, you should have a solid understanding of these tools and their capabilities for efficient Excel manipulation and data analysis.</p>
			<p>In the next chapter, we will learn how to write the results to Excel.</p>
		</div>
	</body></html>