<html><head></head><body>
		<div id="_idContainer018">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Reading Excel Spreadsheets</h1>
			<p>In the deep and wide landscape of data analysis, Excel stands tall and by your side as a trusted warrior, simplifying the process of organizing, calculating, and presenting information. Its intuitive interface and widespread usage have cemented its position as a staple in the business world. However, as the volume and complexity of data continue to grow exponentially, Excel’s capabilities may start to feel constrained. It is precisely at this point that the worlds of Excel, R, and Python converge. Extending Excel with R and Python invites you to embark on a truly transformative journey. This trip will show you the power of these programming languages as they synergize with Excel, expanding its horizons and empowering you to conquer data challenges with ease. In this book, we will delve into how to integrate Excel with R and Python, uncovering the hidden potential that lies beneath the surface and enabling you to extract valuable insights, automate processes, and unleash the true power of <span class="No-Break">data analysis.</span></p>
			<p>Microsoft Excel came to market in 1985 and has remained a popular spreadsheet software choice. Excel<a id="_idIndexMarker000"/> was originally known as MultiPlan. Microsoft Excel and databases in general share some similarities in terms of organizing and managing data, although they serve different purposes. Excel is a spreadsheet program that allows users to store and manipulate data in a tabular format. It consists of rows and columns, where each cell can contain text, numbers, or formulas. Similarly, a database is a structured collection of data stored in tables, consisting of rows <span class="No-Break">and columns.</span></p>
			<p>Both Excel and databases provide a way to store and retrieve data. In Excel, you can enter data, perform calculations, and create charts and graphs. Similarly, databases store and manage large amounts of structured data and enable querying, sorting, and filtering. Excel and databases also support the concept of relationships. In Excel, you can link cells or ranges across different sheets, creating connections between data. Databases use relationships to link tables based on common fields, allowing you to retrieve related data from <span class="No-Break">multiple tables.</span></p>
			<p>This chapter aims to familiarize you with reading Excel files into the R environment and performing some manipulation on them. Specifically, in this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>R packages for <span class="No-Break">Excel manipulation</span></li>
				<li>Reading Excel files to manipulate <span class="No-Break">with R</span></li>
				<li>Reading multiple Excel sheets with a custom <span class="No-Break">R function</span></li>
				<li>Python packages for <span class="No-Break">Excel manipulation</span></li>
				<li>Opening an Excel sheet from Python and reading <span class="No-Break">the data</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>At the time of writing, we are using <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">R 4.2.1</span></li>
				<li>The RStudio 2023.03.1+446 “Cherry Blossom” release <span class="No-Break">for Windows</span></li>
			</ul>
			<p>For this chapter, you will need to install the <span class="No-Break">following packages:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">readxl</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">openxlsx</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">xlsx</strong></span></li>
			</ul>
			<p>To run the Python code in this chapter, we will be using <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Python 3.11</span></li>
				<li><span class="No-Break"><strong class="source-inline">pandas</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">openpyxl</strong></span></li>
				<li>The <strong class="source-inline">iris.xlsx</strong> Excel file available in this book’s <span class="No-Break">GitHub repository</span></li>
			</ul>
			<p>While setting up a Python environment is outside the scope of this book, this is easy to do. The necessary packages can be installed by running the <span class="No-Break">following commands:</span></p>
			<pre class="console">
python -m pip install pandas==2.0.1
python -m pip install openpyxl==3.1.2</pre>			<p>Note that these commands have to be run from a terminal and not from within a Python script. They need to be run in the folder where <strong class="source-inline">requirements.txt</strong> resides or a full path to the <strong class="source-inline">requirements.txt</strong> file has to be included. </p>
			<p>This book’s GitHub repository also contains a <strong class="source-inline">requirements.txt</strong> file that you can use to install all dependencies. You can do this by running the <span class="No-Break">following command:</span></p>
			<pre class="console">
python -m pip install -r requirements.txt</pre>			<p>This command installs all the packages that will be used in this chapter so that you don’t have to install them one by one. It also guarantees that the whole dependency tree (including the dependencies of the dependencies) will be the same as what this book’s authors <span class="No-Break">have used.</span></p>
			<p>Alternatively, when using Jupyter Notebooks, you can use the following <span class="No-Break">magic commands:</span></p>
			<pre class="console">
%pip install pandas==2.0.1
%pip install openpyxl==3.1.2</pre>			<p>There is a GitHub account for all of the code examples in this book located at this link: <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R</a>. Each chapter has it’s own folder, with the current one as <strong class="source-inline">Chapter01</strong>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Technical requirements for Python throughout the book are conveniently compiled in the <strong class="source-inline">requirements.txt</strong> file, accessible on GitHub repository here, <a href="https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/blob/main/requirements.txt">https://github.com/PacktPublishing/Extending-Excel-with-Python-and-R/blob/main/requirements.txt</a>. Installing these dependencies will streamline your coding experience and ensure smooth progression through the book. Be sure to install them all before diving into <span class="No-Break">the exercises.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Working with R packages for Excel manipulation</h1>
			<p>There are several packages available both on CRAN and on GitHub that allow for reading and manipulation of Excel files. In this section, we are specifically going to focus on the packages: <strong class="source-inline">readxl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">xlsx</strong> to read Excel files. These three packages all have their own functions to read Excel files. These functions are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">readxl::read_excel() </strong></li>
				<li><span class="No-Break"><strong class="source-inline">openxlsx::read.xlsx()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">xlsx::read.xlsx()</strong></span></li>
			</ul>
			<p>Each function has a set of parameters and conventions to follow. Since <strong class="source-inline">readxl</strong> is part of the <strong class="source-inline">tidyverse</strong> collection of packages, it follows its conventions and returns a <strong class="source-inline">tibble</strong> object upon reading the file. If you do not know what a tibble is, it is a modern version of R’s <strong class="source-inline">data.frame</strong>, a sort of spreadsheet in the R environment. It is the building block of most analyses. Moving on to <strong class="source-inline">openxlsx</strong> and <strong class="source-inline">xlsx</strong>, they both return a base R <strong class="source-inline">data.frame</strong> object, with the latter also able to return a <strong class="source-inline">list</strong> object. If you are wondering how this relates to manipulating an actual Excel file, I can explain. First, to manipulate something in R, the data must be in the R environment, so you cannot manipulate the file unless the data is read in. These packages have different functions for manipulating Excel or reading data in certain ways that allow for further analysis and or manipulation. It is important to note that <strong class="source-inline">xlsx</strong> does require Java to <span class="No-Break">be installed.</span></p>
			<p>As we transition from our exploration of R packages for Excel manipulation, we’ll turn our attention to the crucial task of effectively reading Excel files into R, thereby unlocking even more possibilities for data analysis <span class="No-Break">and manipulation.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Reading Excel files to R</h1>
			<p>In this section, we are<a id="_idIndexMarker001"/> going to read<a id="_idIndexMarker002"/> data from Excel with a few different R libraries. We need to do this before we can even consider performing any type of manipulation or analysis on the data contained in the sheets of the <span class="No-Break">Excel files.</span></p>
			<p>As mentioned in the Technical requirements section, we are going to be using the <strong class="source-inline">readxl</strong>, <strong class="source-inline">openxlsx</strong>, and <strong class="source-inline">xlsx</strong> packages to read data <span class="No-Break">into R.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Installing and loading libraries</h2>
			<p>In this section, we are going<a id="_idIndexMarker003"/> to install and load<a id="_idIndexMarker004"/> the necessary libraries if you do not yet have them. We are going to use the <strong class="source-inline">openxlsx</strong>, <strong class="source-inline">xlsx</strong>, <strong class="source-inline">readxl</strong>, and <strong class="source-inline">readxlsb</strong> libraries. To install and load them, run the following <span class="No-Break">code block:</span></p>
			<pre class="source-code">
pkgs &lt;- c("openxlsx", "xlsx", "readxl")
install.packages(pkgs, dependencies = TRUE)
lapply(pkgs, library, character.only = TRUE)</pre>			<p>The <strong class="source-inline">lapply()</strong> function in R is a versatile tool for applying a function to each element of a list, vector, or <strong class="source-inline">DataFrame</strong>. It takes two arguments, <strong class="source-inline">x</strong> and <strong class="source-inline">FUN</strong>, where <strong class="source-inline">x</strong> is the list and <strong class="source-inline">FUN</strong> is the function that is applied to the list <span class="No-Break">object, </span><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break">.</span></p>
			<p>Now that the libraries have been installed, we can get to work. To do this, we are going to read a spreadsheet built from the Iris dataset that is built into base R. We are going to read the file with three different libraries, and then we are going to create a custom function to work with the <strong class="source-inline">readxl</strong> library that will read all the sheets of an Excel file. We will call this the <span class="No-Break"><strong class="source-inline">read_excel_sheets()</strong></span><span class="No-Break"> function.</span></p>
			<p>Let’s start reading the files. The first library we will use to open an Excel file is <strong class="source-inline">openxlsx</strong>. To read the Excel file we are working with, you can run the code in the <strong class="source-inline">chapter1</strong> folder of this book’s GitHub repository called <strong class="source-inline">ch1_create_iris_dataset.R</strong>  Refer to the following screenshot to see how to read the file <span class="No-Break">into R.</span></p>
			<p>You will notice a variable called <strong class="source-inline">f_pat</strong>. This is the path to where the Iris dataset was saved as an Excel file – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">C:/User/UserName/Documents/iris_data.xlsx</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B19142_01_1.jpg" alt="Figure 1.1 – Using the openxlsx package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Using the openxlsx package to read the Excel file</p>
			<p>The preceding screenshot shows<a id="_idIndexMarker005"/> how to read an Excel<a id="_idIndexMarker006"/> file. This example assumes that you have used the <strong class="source-inline">ch1_create_iris_datase.R</strong> file to create the example Excel file. In reality, you can read in any Excel file that you would like <span class="No-Break">or need.</span></p>
			<p>Now, we will perform the same type of operation, but this time with the <strong class="source-inline">xlsx</strong> library. Refer to the following screenshot, which uses the same methodology as with the <span class="No-Break"><strong class="source-inline">openxlsx</strong></span><span class="No-Break"> package:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B19142_01_2.jpg" alt="Figure 1.2 – Using the xlsx library and the read.xlsx() function to open the Excel file we’ve created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Using the xlsx library and the read.xlsx() function to open the Excel file we’ve created</p>
			<p>Finally, we will use<a id="_idIndexMarker007"/> the <strong class="source-inline">readxl</strong> library, which is part <a id="_idIndexMarker008"/>of <span class="No-Break">the tidyverse:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B19142_01_3.jpg" alt="Figure 1.3 – Using the readxl library and the read_excel() function to read the Excel file into memory"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Using the readxl library and the read_excel() function to read the Excel file into memory</p>
			<p>In this section, we learned<a id="_idIndexMarker009"/> how to read in an Excel file with a few different packages. While these packages<a id="_idIndexMarker010"/> can do more than simply read in an Excel file, that is what we needed to focus on in this section. You should now be familiar with how to use the <strong class="source-inline">readxl::read_excel()</strong>, <strong class="source-inline">xlsx::read.xlsx()</strong>, and  <span class="No-Break"><strong class="source-inline">openxlsx::read.xlsx()</strong></span><span class="No-Break"> functions.</span></p>
			<p>Building upon our expertise in reading Excel files into R, we’ll now embark on the next phase of our journey: unraveling the secrets of efficiently extracting data from multiple sheets within an <span class="No-Break">Excel file.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Reading multiple sheets with readxl and a custom function</h1>
			<p>In Excel, we often encounter <a id="_idIndexMarker011"/>workbooks that<a id="_idIndexMarker012"/> have multiple sheets in them. These could be stats for different months of the year, table data that follows a specific format month over month, or some other period. The point is that we may want to read all the sheets in a file for one reason or another, and we should not call the read function from a particular package for each sheet. Instead, we should use the power of R to loop through this <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">purrr</strong></span><span class="No-Break">.</span></p>
			<p>Let’s build a customized<a id="_idIndexMarker013"/> function. To do this, we are going to load the <strong class="source-inline">readxl</strong> function. If we have it already loaded, then this is not necessary; however, if it is already installed and you do not wish to load the library into memory, then you can call the <strong class="source-inline">excel_sheets()</strong> function by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">readxl::excel_sheets()</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B19142_01_4.jpg" alt="Figure 1.4 – Creating a function to read all the sheets into an Excel file at once – read_excel_sheets()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Creating a function to read all the sheets into an Excel file at once – read_excel_sheets()</p>
			<p>The new code can be broken down <span class="No-Break">as follows:</span></p>
			<pre class="console">
 read_excel_sheets &lt;- function(filename, single_tbl) {</pre>			<p>This line defines a function<a id="_idIndexMarker014"/> called <strong class="source-inline">read_excel_sheets</strong> that takes two arguments: <strong class="source-inline">filename</strong> (the name of the Excel file to be read) and <strong class="source-inline">single_tbl</strong> (a logical value indicating whether the function should return a single table or a list <span class="No-Break">of tables).</span></p>
			<p>Next, we have the <span class="No-Break">following line:</span></p>
			<pre class="console">
sheets &lt;- readxl::excel_sheets(filename)</pre>			<p>This line uses the <strong class="source-inline">readxl</strong> package<a id="_idIndexMarker015"/> to extract the names of all the sheets<a id="_idIndexMarker016"/> in the Excel file specified by <strong class="source-inline">filename</strong>. The sheet names are stored in the <span class="No-Break"><strong class="source-inline">sheets</strong></span><span class="No-Break"> variable.</span></p>
			<p>Here’s the <span class="No-Break">next line:</span></p>
			<pre class="console">
if (single_tbl) {</pre>			<p>This line starts an <strong class="source-inline">if</strong> statement that checks the value of the <span class="No-Break"><strong class="source-inline">single_tbl</strong></span><span class="No-Break"> argument.</span></p>
			<p>Now, we have <span class="No-Break">the following:</span></p>
			<pre class="console">
x &lt;- purrr::map_df(sheets, read_excel, path = filename)</pre>			<p>If <strong class="source-inline">single_tbl</strong> is <strong class="source-inline">TRUE</strong>, this line uses the <strong class="source-inline">purrr</strong> package’s <strong class="source-inline">map_df</strong> function to iterate over each sheet name in <strong class="source-inline">sheets</strong> and read the corresponding sheet using the <strong class="source-inline">read_excel</strong> function from the <strong class="source-inline">readxl</strong> package. The resulting <strong class="source-inline">DataFrame</strong> are combined into a single table, which is assigned to the <span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break"> variable.</span></p>
			<p>Now, we have the <span class="No-Break">following line:</span></p>
			<pre class="console">
} else {</pre>			<p>This line indicates the start of the <strong class="source-inline">else</strong> block of the <strong class="source-inline">if</strong> statement. If <strong class="source-inline">single_tbl</strong> is <strong class="source-inline">FALSE</strong>, the code in this block will <span class="No-Break">be executed.</span></p>
			<p>Here’s the <span class="No-Break">next line:</span></p>
			<pre class="console">
 x &lt;- purrr::map(sheets, ~ readxl::read_excel(filename, sheet = .x))</pre>			<p>In this line, the <strong class="source-inline">purrr</strong> package’s <strong class="source-inline">map</strong> function<a id="_idIndexMarker017"/> is used to iterate over each sheet<a id="_idIndexMarker018"/> name in <strong class="source-inline">sheets</strong>. For each sheet, the <strong class="source-inline">read_excel</strong> function<a id="_idIndexMarker019"/> from the <strong class="source-inline">readxl</strong> package is called to read the corresponding sheet from the Excel file specified by <strong class="source-inline">filename</strong>. The resulting <strong class="source-inline">DataFrame</strong> are stored in a list assigned to the <span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break"> variable.</span></p>
			<p>Now, we have <span class="No-Break">the following:</span></p>
			<pre class="console">
 purrr::set_names(x, sheets)</pre>			<p>This line uses the <strong class="source-inline">set_names</strong> function from the <strong class="source-inline">purrr</strong> package to set the names of the elements in the <strong class="source-inline">x</strong> list to the sheet names <span class="No-Break">in sheets.</span></p>
			<p>Finally, we have the <span class="No-Break">following line:</span></p>
			<pre class="console">
 x</pre>			<p>This line returns the value of <strong class="source-inline">x</strong> from the function, which will be either a single table (<strong class="source-inline">data.frame</strong>) if <strong class="source-inline">single_tbl</strong> is <strong class="source-inline">TRUE</strong>, or a list of tables (<strong class="source-inline">data.frame</strong>) if <strong class="source-inline">single_tbl</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">FALSE</strong></span><span class="No-Break">.</span></p>
			<p>In summary, the <strong class="source-inline">read_excel_sheets</strong> function takes an Excel filename and a logical value indicating whether to return a single table or a list of tables. It uses the <strong class="source-inline">readxl</strong> package to extract the sheet names from the Excel file, and then reads the corresponding sheets either into a single table (if <strong class="source-inline">single_tbl</strong> is <strong class="source-inline">TRUE</strong>) or into a list of tables (if <strong class="source-inline">single_tbl</strong> is <strong class="source-inline">FALSE</strong>). The resulting data is returned as the output of the function. To see how this works, let’s look at the <span class="No-Break">following example.</span></p>
			<p>We have a spreadsheet that has four tabs in it – one for each species in the famous Iris dataset and then one sheet called <strong class="source-inline">iris</strong>, which is the <span class="No-Break">full dataset.</span></p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em>, the <strong class="source-inline">read_excel_sheets()</strong> function has read all four sheets of the Excel file. We can also see that the function has imported the sheets as a list object and has named each item in the list after the name of the corresponding tab in the Excel file. It is also important to note that the sheets must all have the same column names and structure for this <span class="No-Break">to work:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B19142_01_5.jpg" alt="Figure 1.5 – Excel file read by read_excel_sheets()"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Excel file read by read_excel_sheets()</p>
			<p>In this section, we learned<a id="_idIndexMarker020"/> how to write<a id="_idIndexMarker021"/> a function that will read<a id="_idIndexMarker022"/> all of the sheets in any Excel file. This function will also return them as a named item list, where the names are the names of the tabs in the <span class="No-Break">file itself.</span></p>
			<p>Now that we have learned how to read Excel sheets in R, in the next section, we will cover Python, where we will revisit the same concepts but from the perspective of the <span class="No-Break">Python language.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Python packages for Excel manipulation</h1>
			<p>In this section, we will explore how to read Excel spreadsheets using Python. One of the key aspects of working with Excel files in Python is having the right set of packages that provide the necessary functionality. In this section, we will discuss some commonly used Python packages for Excel manipulation and highlight their advantages <span class="No-Break">and considerations.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Python packages for Excel manipulation</h2>
			<p>When it comes to interacting<a id="_idIndexMarker023"/> with Excel files in Python, several packages offer a range of features and capabilities. These packages allow you to extract data from Excel files, manipulate the data, and write it back to Excel files. Let’s take a look at some popular Python packages for <span class="No-Break">Excel manipulation.</span></p>
			<h3>pandas</h3>
			<p><strong class="source-inline">pandas</strong> is a powerful<a id="_idIndexMarker024"/> data manipulation<a id="_idIndexMarker025"/> library that can read Excel files using the <strong class="source-inline">read_excel</strong> function. The advantage of using <strong class="source-inline">pandas</strong> is that it provides a <strong class="source-inline">DataFrame</strong> object, which allows you to manipulate the data in a tabular form. This makes it easy to perform data analysis and manipulation. <strong class="source-inline">pandas</strong> excels in handling large datasets efficiently and provides flexible options for data filtering, transformation, <span class="No-Break">and aggregation.</span></p>
			<h3>openpyxl</h3>
			<p><strong class="source-inline">openpyxl</strong> is a widely used<a id="_idIndexMarker026"/> library specifically <a id="_idIndexMarker027"/>designed for working with Excel files. It provides a comprehensive set of features for reading and writing Excel spreadsheets, including support for various Excel file formats and compatibility with different versions of Excel. In addition, <strong class="source-inline">openpyxl</strong> allows fine-grained control over the structure and content of Excel files, enabling tasks such as accessing<a id="_idIndexMarker028"/> individual cells, creating<a id="_idIndexMarker029"/> new worksheets, and <span class="No-Break">applying formatting.</span></p>
			<h3>xlrd and xlwt</h3>
			<p><strong class="source-inline">xlrd</strong> and <strong class="source-inline">xlwt</strong> are older libraries<a id="_idIndexMarker030"/> that are still<a id="_idIndexMarker031"/> in use for reading and writing<a id="_idIndexMarker032"/> Excel files, particularly<a id="_idIndexMarker033"/> with legacy formats such as <strong class="source-inline">.xls</strong>. <strong class="source-inline">xlrd</strong> enables reading data from Excel files, while <strong class="source-inline">xlwt</strong> facilitates writing data to Excel files. These libraries are lightweight and straightforward to use, but they lack some of the advanced features provided by <strong class="source-inline">pandas</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">openpyxl</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Considerations</h2>
			<p>When choosing a Python<a id="_idIndexMarker034"/> package for Excel manipulation, it’s essential to consider the specific requirements of your project. Here are a few factors to keep <span class="No-Break">in mind:</span></p>
			<ul>
				<li><strong class="bold">Functionality</strong>: Evaluate the package’s capabilities and ensure it meets your needs for reading Excel files. Consider whether you require advanced data manipulation features or if a simpler package <span class="No-Break">will suffice.</span></li>
				<li><strong class="bold">Performance</strong>: If you’re working with large datasets or need efficient processing, packages such as <strong class="source-inline">pandas</strong>, which have optimized algorithms, can offer significant <span class="No-Break">performance advantages.</span></li>
				<li><strong class="bold">Compatibility</strong>: Check the compatibility of the package with different Excel file formats and versions. Ensure that it supports the specific format you are working with to avoid any <span class="No-Break">compatibility issues.</span></li>
				<li><strong class="bold">Learning curve</strong>: Consider the learning curve associated with each package. Some packages, such as <strong class="source-inline">pandas</strong>, have a more extensive range of functionality, but they may require additional time and effort <span class="No-Break">to master.</span></li>
			</ul>
			<p>Each package offers unique features and has its strengths and weaknesses, allowing you to read Excel spreadsheets effectively in Python. For example, if you need to read and manipulate large amounts of data, <strong class="source-inline">pandas</strong> may be the better choice. However, if you need fine-grained control over the Excel file, <strong class="source-inline">openpyxl</strong> will likely fit your <span class="No-Break">needs better.</span></p>
			<p>Consider the specific requirements<a id="_idIndexMarker035"/> of your project, such as data size, functionality, and compatibility, to choose the most suitable package for your needs. In the following sections, we will delve deeper into how to utilize these packages to read and extract data from Excel files <span class="No-Break">using Python.</span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Opening an Excel sheet from Python and reading the data</h1>
			<p>When working with Excel files<a id="_idIndexMarker036"/> in Python, it’s common to need<a id="_idIndexMarker037"/> to open a specific<a id="_idIndexMarker038"/> sheet and read the data into Python<a id="_idIndexMarker039"/> for further analysis. This can be achieved using popular libraries such as <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong>, as discussed in the <span class="No-Break">previous section.</span></p>
			<p>You can most likely use other Python and package versions, but the code in this section has not been tested with anything other than what we’ve <span class="No-Break">stated here.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Using pandas</h2>
			<p><strong class="source-inline">pandas</strong> is a powerful data<a id="_idIndexMarker040"/> manipulation library that simplifies the process of working with structured data, including Excel spreadsheets. To read an Excel sheet using <strong class="source-inline">pandas</strong>, you can use the <strong class="source-inline">read_excel</strong> function. Let’s consider an example of using the <strong class="source-inline">iris_data.xlsx</strong> file with a sheet <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">setosa</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import pandas as pd
# Read the Excel file
df = pd.read_excel('iris_data.xlsx', sheet_name='setosa')
# Display the first few rows of the DataFrame
print(df.head())</pre>			<p>You will need to run this code either with the Python working directory set to the location where the Excel file is located, or you will need to provide the full path to the file in the <span class="No-Break"><strong class="source-inline">read_excel()</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B19142_01_6.jpg" alt="Figure 1.6 – Using the pandas package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Using the pandas package to read the Excel file</p>
			<p>In the preceding code snippet, we imported the <strong class="source-inline">pandas</strong> library and utilized the <strong class="source-inline">read_excel</strong> function to read <strong class="source-inline">setosa</strong> from the <strong class="source-inline">iris_data.xlsx</strong> file. The resulting data is stored in a <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong>, which provides a tabular representation of the data. By calling <strong class="source-inline">head()</strong> on the <strong class="source-inline">DataFrame</strong>, we displayed<a id="_idIndexMarker041"/> the first few rows of the data, giving us a <span class="No-Break">quick preview.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using openpyxl</h2>
			<p><strong class="source-inline">openpyxl</strong> is a powerful library<a id="_idIndexMarker042"/> for working with Excel files, offering more granular control over individual cells and sheets. To open an Excel sheet and access its data using <strong class="source-inline">openpyxl</strong>, we can utilize the <strong class="source-inline">load_workbook</strong> function. Please note that <strong class="source-inline">openpyxl</strong> cannot handle <strong class="source-inline">.xls</strong> files, only the more modern <strong class="source-inline">.xlsx</strong> and <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xlsm</strong></span><span class="No-Break"> versions.</span></p>
			<p>Let’s consider an example<a id="_idIndexMarker043"/> of using the <strong class="source-inline">iris_data.xlsx</strong> file with a sheet <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">versicolor</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import openpyxl
import pandas as pd
# Load the workbook
wb = openpyxl.load_workbook('iris_data.xlsx')
# Select the sheet
sheet = wb['versicolor']
# Extract the values (including header)
sheet_data_raw = sheet.values
# Separate the headers into a variable
header = next(sheet_data_raw)[0:]
# Create a DataFrame based on the second and subsequent lines of data with the header as column names
sheet_data = pd.DataFrame(sheet_data_raw, columns=header)
print(sheet_data.head())</pre>			<p>The preceding code results in the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B19142_01_7.jpg" alt="Figure 1.7 – Using the openpyxl package to read the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Using the openpyxl package to read the Excel file</p>
			<p>In this code snippet, we import the <strong class="source-inline">load_workbook</strong> function from the <strong class="source-inline">openpyxl</strong> library. Then, we load the workbook by providing the <strong class="source-inline">iris_data.xlsx</strong> filename. Next, we select the desired sheet by accessing it using its name – in this case, this is <strong class="source-inline">versicolor</strong>. Once we’ve done this, we read the raw data using the <strong class="source-inline">values</strong> property of the loaded sheet object. This is a generator and can be accessed via a <strong class="source-inline">for</strong> cycle or by converting it into a list or a <strong class="source-inline">DataFrame</strong>, for example. In this example, we have converted it into a <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong> because it is the format that is the most comfortable to work <span class="No-Break">with later.</span></p>
			<p>Both <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong> offer valuable features for working with Excel files in Python. While pandas simplifies data manipulation with its <strong class="source-inline">DataFrame</strong> structure, <strong class="source-inline">openpyxl</strong> provides more fine-grained control over individual cells and sheets. Depending on your specific requirements, you can choose the library that best suits <span class="No-Break">your needs.</span></p>
			<p>By mastering the techniques<a id="_idIndexMarker044"/> of opening Excel sheets and reading data into Python, you will be able to extract valuable insights from your Excel data, perform various data transformations, and prepare it for further analysis or visualization. These skills are essential<a id="_idIndexMarker045"/> for anyone seeking to leverage the power of Python and Excel in their <span class="No-Break">data-driven workflows.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Reading in multiple sheets with Python (openpyxl and custom functions)</h1>
			<p>In many Excel files, it’s common<a id="_idIndexMarker046"/> to have multiple sheets<a id="_idIndexMarker047"/> containing different sets of data. Being able to read in multiple sheets and consolidate the data into a single data structure can be highly valuable for analysis and processing. In this section, we will explore how to achieve this using the <strong class="source-inline">openpyxl</strong> library and a <span class="No-Break">custom function.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>The importance of reading multiple sheets</h2>
			<p>When working with complex<a id="_idIndexMarker048"/> Excel files, it’s not uncommon to encounter scenarios where related data is spread across different sheets. For example, you may have one sheet for sales data, another for customer information, and yet another for product inventory. By reading in multiple sheets and consolidating the data, you can gain a holistic view and perform a <span class="No-Break">comprehensive analysis.</span></p>
			<p>Let’s start by examining the basic steps involved in reading in <span class="No-Break">multiple sheets:</span></p>
			<ol>
				<li><strong class="bold">Load the workbook</strong>: Before accessing <a id="_idIndexMarker049"/>the sheets, we need to load the Excel workbook using the <strong class="source-inline">load_workbook</strong> function provided <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">openpyxl</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Get the sheet names</strong>: We can obtain the names of all the sheets in the workbook using the <strong class="source-inline">sheetnames</strong> attribute. This allows us to identify the sheets we want <span class="No-Break">to read.</span></li>
				<li><strong class="bold">Read data from each sheet</strong>: By iterating over the sheet names, we can access each sheet individually and read the data. <strong class="source-inline">Openpyxl</strong> provides methods such as <strong class="source-inline">iter_rows</strong> or <strong class="source-inline">iter_cols</strong> to traverse the cells of each sheet and retrieve the <span class="No-Break">desired data.</span></li>
				<li><strong class="bold">Store the data</strong>: To consolidate the data from multiple sheets, we can use a suitable data structure, such as a <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong> or a Python list. As we read the data from each sheet, we concatenate<a id="_idIndexMarker050"/> or merge it into the consolidated <span class="No-Break">data structure:</span><ul><li>If the data in all sheets follows the same format (as is the case in the example used in this chapter), we can simply concatenate <span class="No-Break">the datasets</span></li><li>However, if the datasets have different structures because they describe different aspects of a dataset (for example, one sheet contains product information, the next contains customer data, and the third contains the sales of the products to the customers), then we can merge these datasets based on unique identifiers to create a <span class="No-Break">comprehensive dataset</span></li></ul></li>
			</ol>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Using openpyxl to access sheets</h2>
			<p><strong class="source-inline">openpyxl</strong> is a powerful library<a id="_idIndexMarker051"/> that allows<a id="_idIndexMarker052"/> us to interact with Excel files using Python. It provides a wide range of functionalities, including accessing and manipulating multiple sheets. Before we dive into the details, let’s take a moment to understand why <strong class="source-inline">openpyxl</strong> is a popular choice for <span class="No-Break">this task.</span></p>
			<p>One of the primary advantages of <strong class="source-inline">openpyxl</strong> is its ability to handle various Excel file formats, such as <strong class="source-inline">.xlsx</strong> and <strong class="source-inline">.xlsm</strong>. This flexibility allows us to work with different versions of Excel files without compatibility issues. Additionally, <strong class="source-inline">openpyxl</strong> provides a straightforward and intuitive interface to access sheet data, making it easier for us to retrieve the <span class="No-Break">desired information.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Reading data from each sheet</h2>
			<p>To begin reading in multiple<a id="_idIndexMarker053"/> sheets, we need<a id="_idIndexMarker054"/> to load the Excel workbook using the <strong class="source-inline">load_workbook</strong> function provided by <strong class="source-inline">openpyxl</strong>. This function takes the file path as input and returns a workbook object that represents the entire <span class="No-Break">Excel file.</span></p>
			<p>Once we have loaded the workbook, we can retrieve the names of all the sheets using the sheetnames attribute. This gives us a list of sheet names present in the Excel file. We can then iterate over these sheet names to read the data from each <span class="No-Break">sheet individually.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Retrieving sheet data with openpyxl</h2>
			<p><strong class="source-inline">openpyxl</strong> provides various <a id="_idIndexMarker055"/>methods to access<a id="_idIndexMarker056"/> the data within <span class="No-Break">a sheet.</span></p>
			<p>Two commonly used methods are <strong class="source-inline">iter_rows</strong> and <strong class="source-inline">iter_cols</strong>. These methods allow us to iterate over the rows or columns of a sheet and retrieve the <span class="No-Break">cell values.</span></p>
			<p>Let’s have a look at how <strong class="source-inline">iter_rows</strong> can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
# Assuming you are working with the first sheet
sheet = wb['versicolor']
# Iterate over rows and print raw values
for row in sheet.iter_rows(min_row=1, max_row=5, values_only=True):
    print(row)</pre>			<p>Similarly, <strong class="source-inline">iter_cols</strong> can be used <span class="No-Break">like this:</span></p>
			<pre class="source-code">
# Iterate over columns and print raw values
for column in sheet.iter_cols(min_col=1, max_col=5, values_only=True):
    print(column)</pre>			<p>When using <strong class="source-inline">iter_rows</strong> or <strong class="source-inline">iter_cols</strong>, we can specify whether we want to retrieve the cell values as raw values or as formatted values. Raw values give us the actual data stored in the cells, while formatted values include any formatting applied to the cells, such as date formatting or <span class="No-Break">number formatting.</span></p>
			<p>By iterating over the rows or columns of a sheet, we can retrieve the desired data and store it in a suitable data structure. One popular choice is to use <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong>, which provide a tabular representation of the data and offer convenient methods for data manipulation <span class="No-Break">and analysis.</span></p>
			<p>An alternative solution is using the <strong class="source-inline">values</strong> attribute of the sheet object. This provides a generator for all values<a id="_idIndexMarker057"/> in the sheet (much like <strong class="source-inline">iter_rows</strong> and <strong class="source-inline">iter_cols</strong> do for rows<a id="_idIndexMarker058"/> and columns, respectively). While generators cannot be used directly to access the data, they can be used in <strong class="source-inline">for</strong> cycles to iterate over each value. The <strong class="source-inline">pandas</strong> library’s <strong class="source-inline">DataFrame</strong> function also allows direct conversion from a suitable generator object to <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">DataFrame</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Combining data from multiple sheets</h2>
			<p>As we read the data<a id="_idIndexMarker059"/> from each<a id="_idIndexMarker060"/> sheet, we can store it in a list or dictionary, depending on our needs. Once we have retrieved the data from all the sheets, we can combine it into a single consolidated data structure. This step is crucial for further analysis <span class="No-Break">and processing.</span></p>
			<p>To combine the data, we can use <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong>. By creating individual <strong class="source-inline">DataFrame</strong> for each sheet’s data and then concatenating or merging them into a single <strong class="source-inline">DataFrame</strong>, we can obtain a comprehensive dataset that includes all the information from <span class="No-Break">multiple sheets.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Custom function for reading multiple sheets</h2>
			<p>To simplify the process of reading<a id="_idIndexMarker061"/> in multiple sheets <a id="_idIndexMarker062"/>and consolidating the data, we can create custom functions tailored to our specific requirements. These functions encapsulate the necessary steps and allow us to reuse the <span class="No-Break">code efficiently.</span></p>
			<p>In our example, we define a function called <strong class="source-inline">read_multiple_sheets</strong> that takes the file path as input. Inside the function, we load the workbook using <strong class="source-inline">load_workbook</strong> and iterate over the sheet names retrieved with the <span class="No-Break">sheets attribute.</span></p>
			<p>For each sheet, we access it using the workbook object and retrieve the data using the custom read_single_sh<strong class="source-inline">eet</strong> function. We then store the retrieved data in a list. Finally, we combine the data from all the sheets into a single <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong> using the appropriate concatenation method <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">pandas</strong></span><span class="No-Break">.</span></p>
			<p>By using these custom functions, we can easily read in multiple sheets from an Excel file and obtain a consolidated dataset that’s ready for analysis. The function provides a reusable and efficient solution, saving us time and effort in dealing with complex <span class="No-Break">Excel files.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Customizing the code</h2>
			<p>The provided example is a starting point that you can customize based on your specific requirements. Here are a few considerations<a id="_idIndexMarker063"/> for customizing <span class="No-Break">the code:</span></p>
			<ul>
				<li><strong class="bold">Filtering columns</strong>: If you only need specific columns from each sheet, you can modify the code to extract only the desired columns during the data retrieval step. You can do this by using the <strong class="source-inline">iter_cols</strong> method instead of the <strong class="source-inline">values</strong> attribute and using a filtered list in a <strong class="source-inline">for</strong> cycle or by filtering the resulting <strong class="source-inline">pandas</strong> <span class="No-Break"><strong class="source-inline">DataFrame</strong></span><span class="No-Break"> object(s).</span></li>
				<li><strong class="bold">Handling missing data</strong>: If the sheets contain missing data, you can incorporate appropriate handling techniques, such as filling in missing values or excluding <span class="No-Break">incomplete rows.</span></li>
				<li><strong class="bold">Applying transformations</strong>: Depending on the nature of your data, you might need to apply transformations or calculations to the consolidated dataset. The custom function<a id="_idIndexMarker064"/> can be expanded to accommodate <span class="No-Break">these transformations.</span></li>
			</ul>
			<p>Remember, the goal is to tailor the code to suit your unique needs and ensure it aligns with your data <span class="No-Break">processing requirements.</span></p>
			<p>By leveraging the power <a id="_idIndexMarker065"/>of <strong class="source-inline">openpyxl</strong> and creating custom functions, you can efficiently read in multiple sheets from Excel files, consolidate the data, and prepare it for further analysis. This capability enables you to unlock valuable insights from complex Excel files and leverage the full potential of <span class="No-Break">your data.</span></p>
			<p>Now, let’s dive into an example that demonstrates <span class="No-Break">this process:</span></p>
			<pre class="source-code">
from openpyxl import load_workbook
import pandas as pd
def read_single_sheet(workbook, sheet_name):
   # Load the sheet from the workbook
    sheet = workbook[sheet_name]
    # Read out the raaw data including headers
    sheet_data_raw = sheet.values
    # Separate the headers into a variable
    columns = next(sheet_data_raw)[0:]
    # Create a DataFrame based on the second and subsequent lines of data with the header as column names and return it
    return pd.DataFrame(sheet_data_raw, columns=columns)
def read_multiple_sheets(file_path):
    # Load the workbook
    workbook = load_workbook(file_path)
    # Get a list of all sheet names in the workbook
    sheet_names = workbook.sheetnames
    # Cycle through the sheet names, load the data for each and concatenate them into a single DataFrame
    return pd.concat([read_single_sheet(workbook=workbook, sheet_name=sheet_name) for sheet_name in sheet_names], ignore_index=True)
# Define the file path and sheet names
file_path = 'iris_data.xlsx' # adjust the path as needed
# Read the data from multiple sheets
consolidated_data = read_multiple_sheets(file_path)
# Display the consolidated data
print(consolidated_data.head())</pre>			<p>Let’s have a look at <span class="No-Break">the results:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B19142_01_8.jpg" alt="Figure 1.8 – Using the openxlsx package to read in the Excel file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Using the openxlsx package to read in the Excel file</p>
			<p>In the preceding code, we define<a id="_idIndexMarker066"/> <span class="No-Break">two functions:</span></p>
			<ul>
				<li><strong class="source-inline">read_single_sheet</strong>: This reads the data from a single sheet into a <span class="No-Break"><strong class="source-inline">pandas</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">DataFrame</strong></span></li>
				<li><strong class="source-inline">read_multiple_sheets</strong>: This reads and concatenates the data from all sheets in <span class="No-Break">the workbook</span></li>
			</ul>
			<p>Within the <strong class="source-inline">read_multiple_sheets</strong> function, we load the workbook using <strong class="source-inline">load_workbook</strong> and iterate over the sheet names. For each sheet, we retrieve the data using the <strong class="source-inline">read_single_sheet</strong> helper function, which reads the data from a sheet and creates a <strong class="source-inline">pandas</strong> <strong class="source-inline">DataFrame</strong> for each sheet’s data, with the header row used as column names. Finally, we use <strong class="source-inline">pd.concat</strong> to combine all the <strong class="source-inline">DataFrame</strong> into a single <span class="No-Break">consolidated </span><span class="No-Break"><strong class="source-inline">DataFrame</strong></span><span class="No-Break">.</span></p>
			<p>By utilizing these custom functions, we can easily read in multiple sheets from an Excel file and obtain a consolidated dataset. This allows us to perform various data manipulations, analyses, or visualizations on the <span class="No-Break">combined data.</span></p>
			<p>Understanding how to handle<a id="_idIndexMarker067"/> multiple sheets efficiently enhances our ability to work with complex Excel files and extract valuable insights from <span class="No-Break">diverse datasets.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Summary</h1>
			<p>In this chapter, we explored the process of importing data from Excel spreadsheets into our programming environments. For R users, we delved into the functionalities of libraries such as <strong class="source-inline">readxl</strong>, <strong class="source-inline">xlsx</strong>, and <strong class="source-inline">openxlsx</strong>, providing efficient solutions for extracting and manipulating data. We also introduced a custom function, <strong class="source-inline">read_excel_sheets</strong>, to streamline the process of extracting data from multiple sheets within Excel files. On the Python side, we discussed the essential <strong class="source-inline">pandas</strong> and <strong class="source-inline">openpyxl</strong> packages for Excel manipulation, demonstrating their features through practical examples. At this point, you should have a solid understanding of these tools and their capabilities for efficient Excel manipulation and <span class="No-Break">data analysis.</span></p>
			<p>In the next chapter, we will learn how to write the results <span class="No-Break">to Excel.</span></p>
		</div>
	</body></html>