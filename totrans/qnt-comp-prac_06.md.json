["```py\n    plot_bloch_multivector(state_vector)\n    ```", "```py\n    plot_state_qsphere(state_vector)\n    ```", "```py\n    circuit.initialize(initial_vector,qubit)\n    ```", "```py\n    Aer.get_backend('statevector_simulator')\n    ```", "```py\n    Aer.get_backend('unitary_simulator')\n    ```", "```py\n    # List our start states\n    start_states=[\"1\",\"+\",\"-\",\"R\",\"L\",\"r\",\"d\"]\n    valid_start=[\"0\"]+start_states\n    ```", "```py\n    # List our gates\n    rot_gates=[\"rx\",\"ry\",\"rz\"]\n    unitary_gates=[\"u1\",\"u2\",\"u3\"]\n    single_gates=[\"id\",\"x\",\"y\",\"z\",\"t\",\"tdg\",\"s\",\"sdg\",\"h\"]\n        +rot_gates\n    oneq_gates=single_gates+unitary_gates\n    control_gates=[\"cx\",\"cy\",\"cz\",\"ch\"]\n    twoq_gates=control_gates+[\"swap\"]\n    all_gates=oneq_gates+twoq_gates+rot_gates+unitary_gates\n    ```", "```py\n    def get_psi(circuit):\n        global psi\n        backend = Aer.get_backend('statevector_simulator') \n        result = execute(circuit, backend).result()\n        psi = result.get_statevector(circuit)\n        return(psi)\n    ```", "```py\n    def get_unitary(circuit):\n        simulator = Aer.get_backend('unitary_simulator')\n        result = execute(circuit, simulator).result()\n        unitary = result.get_unitary(circuit)  \n        return(unitary)  \n    ```", "```py\n    def create_circuit(n_qubits,start):\n        if start==\"1\":\n            initial_vector = [0,complex(1,0)]\n        elif start==\"+\":\n            # Create |+> state\n            initial_vector = [1/sqrt(2) * complex(1, 0),             1/sqrt(2) * complex(1, 0)]\n        elif start==\"-\":\n            # Create |-> state\n            initial_vector = [1/sqrt(2) * complex(1, 0),             -1/sqrt(2) * complex(1, 0)]\n        elif start==\"R\":\n            # Create  state\n            initial_vector = [1/sqrt(2) * complex(1, 0),            1*1.j/sqrt(2) * complex(1, 0)]\n        elif start==\"L\":\n            # Create  state\n            initial_vector = [1/sqrt(2) * complex(1, 0),            -1*1.j/sqrt(2) * complex(1, 0)]\n        elif start==\"r\":\n            # Create random initial vector\n            theta=random.random()*pi\n            phi=random.random()*2*pi\n            a = cos(theta/2)\n            b = cmath.exp(phi*1j)*sin(theta/2)\n            initial_vector = [a * complex(1, 0),            b * complex(1, 0)]\n        elif start==\"d\":\n            a = cos(start_theta/2)\n            b = cmath.exp(start_phi*1j)*sin(start_theta/2)\n            initial_vector = [a * complex(1, 0),            b * complex(1, 0)]\n        else:\n            initial_vector = [complex(1,0),0]\n        if start!=\"n\":\n            print(\"\\nInitial vector for |\"+start+\"\\u232A:\")\n            print(np.around(initial_vector, decimals = 3))   \n    ```", "```py\n        circuit = QuantumCircuit(n_qubits)\n        if start in start_states:\n            circuit.initialize(initial_vector,n_qubits-1)\n        return(circuit)\n    ```", "```py\n    def qgate_out(circuit,start):\n        # Print the circuit\n        psi=get_psi(circuit)\n        if start!=\"n\":\n            print(\"\\nCircuit:\")\n            print(\"--------\")\n            print(circuit)\n            print(\"\\nState vector:\")\n            print(\"-------------\")\n            print(np.around(psi, decimals = 3))\n            display(plot_bloch_multivector(psi))\n            if circuit.num_qubits>1 and gate \n                in control_gates:\n                display(plot_state_qsphere(psi))\n        return(psi)\n    ```", "```py\n    circuit+=QuantumCircuit.from_qasm_str(qasm_string+gate+\"    q[0];\")\n    ```", "```py\n    qasm_string+gate+\" q[0];\" \n    ```", "```py\n    OPENQASM 2.0; include \"qelib1.inc\"; \n    qreg q[1];\n    x q[0];\n    ```", "```py\n    def qgate(gate,start): \n        # If the gates require angles, add those to the QASM\n        # code\n        qasm_angle_gates={\"rx\":\"rx(\"+str(theta)+\") q[0];\",        \"ry\":\"ry(\"+str(theta)+\") q[0];\",\n            \"rz\":\"rz(\"+str(phi)+\") q[0];\",        \"u1\":\"u1(\"+str(phi)+\") q[0];\",        \"u2\":\"u2(\"+str(phi)+\",\n            \"+str(lam)+\") q[0];\", \n            \"u3\":\"u3(\"+str(theta)+\",\n            \"+str(phi)+\",\"+str(lam)+\") q[0];\"}\n        # Create the circuits and then add the gate using \n        # QASM import \n        if gate in oneq_gates:\n            circuit=create_circuit(1,start)\n            qasm_string='OPENQASM 2.0; include \"qelib1.inc\";\n                qreg q[1];'\n        else: \n            circuit=create_circuit(2,start)\n            qasm_string='OPENQASM 2.0; include \"qelib1.inc\";            qreg q[2];'\n        qgate_out(circuit,start)    \n        if gate in oneq_gates:\n            if gate in rot_gates+unitary_gates:\n                circuit+=QuantumCircuit.from_qasm_str(\n                    qasm_string+qasm_angle_gates[gate])\n            else:\n                circuit+=QuantumCircuit.from_qasm_str(\n                    qasm_string+gate+\" q[0];\")\n        else:\n            circuit+=QuantumCircuit.from_qasm_str(\n                qasm_string+gate+\" q[1],q[0];\")   \n        return(circuit)\n    ```", "```py\nx(qubit) = u3(3.141,0,3.141,qubit)\ny(qubit) = u3(3.141,1.571,1.571,qubit)\nz(qubit) = u1(3.141,qubit)\n```", "```py\nh(qubit)=u2(0,3.141,qubit)\n```", "```py\ns(qubit) = u1(1.570,qubit)\nsdg(qubit) = u1(-1.570,qubit)\nt(qubit) = u1(0.785,qubit)\ntdg(qubit) = u1(-0.785,qubit)\n```", "```py\nrx(,qubit) = u3(,-1.507,1.507,qubit)\nry(,qubit) = u3(,0,0,qubit)\nrz(,qubit) = u1(,qubit)\n```", "```py\nbackend.configuration().basis_gates\n```", "```py\n['u1', 'u2', 'u3', 'cx', 'id']\n```", "```py\n    Animating the U gates\n    ---------------------\n    Enter u3, u2, or u3:\n    u3\n    Enter :\n    1.57\n    Enter :\n    3.14\n    Enter :\n    0\n    Building animation...\n    ```", "```py\n    def create_images(gate,theta=0.0,phi=0.0,lam=0.0):\n        steps=20.0\n        theta_steps=theta/steps\n        phi_steps=phi/steps\n        lam_steps=lam/steps\n        n, theta,phi,lam=0,0.0,0.0,0.0\n    ```", "```py\n        global q_images, b_images, q_filename, b_filename\n        b_images=[]\n        q_images=[]\n        b_filename=\"animated_qubit\"\n        q_filename=\"animated_qsphere\"\n    ```", "```py\n        while n < steps+1:\n            qc=QuantumCircuit(1)\n            if gate==\"u3\":\n                qc.u3(theta,phi,lam,0)\n                title=\"U3: \\u03B8 = \"+str(round(theta,2))+\"                \\u03D5 = \"+str(round(phi,2))+\" \\u03BB =                \"+str(round(lam,2))\n            elif gate==\"u2\":\n                qc.u2(phi,lam,0)\n                title=\"U2: \\u03D5 = \"+str(round(phi,2))+\"                 \\u03BB = \"+str(round(lam,2))\n            else:\n                qc.h(0)\n                qc.u1(phi,0)\n                title=\"U1: \\u03D5 = \"+str(round(phi,2))\n            # Get the statevector of the qubit \n            # Create Bloch sphere images\n            plot_bloch_multivector(get_psi(qc),title).            savefig('images/bloch'+str(n)+'.png')\n            imb = Image.open('images/bloch'+str(n)+'.png')\n            b_images.append(imb)\n            # Create Q-sphere images\n            plot_state_qsphere(psi).savefig(\n               'images/qsphere'+str(n)+'.png')\n            imq = Image.open('images/qsphere'+str(n)+'.png')\n            q_images.append(imq)\n            # Rev our loop\n            n+=1\n            theta+=theta_steps\n            phi+=phi_steps\n            lam+=lam_steps\n    ```", "```py\n    def save_gif(gate):\n        duration=100\n        b_images[0].save(gate+'_'+b_filename+'.gif',\n                   save_all=True,\n                   append_images=b_images[1:],\n                   duration=duration,\n                   loop=0)\n        q_images[0].save(gate+'_'+q_filename+'.gif',\n                   save_all=True,\n                   append_images=q_images[1:],\n                   duration=duration,\n                   loop=0)\n        print(\"Bloch sphere animation saved as: \\n\"+os.        getcwd()+\"/\"+gate+\"_\"+b_filename+\".        gif\"+\"\\nQsphere animation saved as: \\n\"+os.        getcwd()+\"/\"+gate+\"_\"+q_filename+\".gif\")\n    ```", "```py\n    Bloch sphere animation saved as: \n    /<path_to_your_directory>/ch6/Recipes/u3_animated_qubit.gif\n    Qsphere animation saved as: \n    /<path_to_your_directory>/ch6/Recipes/u3_animated_qsphere.gif\n    ```", "```py\nqc.u1(-1.507,0)\nqc.cx(1,0)\nqc.u1(1.507,0)\n```", "```py\nfrom qiskit import QuantumCircuit\nqc=QuantumCircuit(3)\nqc.ccx(2,1,0)\nprint(qc)\n```", "```py\nfrom qiskit import QuantumCircuit\nqc=QuantumCircuit(4)\nqc.mcx([1,2,3],0)\nprint(qc)\n```", "```py\nfrom qiskit import QuantumCircuit\nqc=QuantumCircuit(3)\nqc.cswap(2,1,0)\nprint(qc)\n```", "```py\n    from qiskit import QuantumCircuit, IBMQ\n    from qiskit.compiler import transpile\n    from qiskit.providers.ibmq import least_busy\n    ```", "```py\n    if not IBMQ.active_account():\n        IBMQ.load_account()\n    provider = IBMQ.get_provider()\n    backend = least_busy(provider.backends(n_qubits=5,    operational=True, simulator=False)) \n    ```", "```py\n    print(\"Basis gates for:\", backend)\n    print(backend.configuration().basis_gates)\n    print(\"Coupling map for:\", backend)\n    print(backend.configuration().coupling_map)\n    ```", "```py\n    def build_circuit(choice):\n        # Create the circuit \n        qc = QuantumCircuit(5,5)\n\n        if choice==\"1\":\n            # Simple X\n            qc.x(0)\n        elif choice==\"2\":\n            # H + Barrier\n            #'''\n            qc.x(0)\n            qc.barrier(0)\n            qc.h(0)\n        elif choice==\"3\":\n            # Controlled Y (CY)\n            qc.cy(0,1)\n        elif choice==\"4\":    \n            # Non-conforming CX\n            qc.cx(0,4)\n        else:\n            # Multi qubit circuit\n            qc.h(0)\n            qc.h(3)\n            qc.cx(0,4)\n            qc.cswap(3,1,2)\n        # Show measurement targets\n        #qc.barrier([0,1,2,3,4])\n        #qc.measure([0,1,2,3,4],[0,1,2,3,4])\n        return(qc)\n    ```", "```py\n    def main(): \n        choice=\"1\"\n        while choice !=\"0\": \n            choice=input(\"Pick a circuit: 1\\. Simple, \n                2\\. H + Barrier, 3\\. Controlled-Y, \n                4\\. Non-conforming CX, 5\\. Multi\\n\")\n            qc=build_circuit(choice) \n            trans_qc = transpile(qc, backend)\n            print(\"Circuit:\")\n            display(qc.draw())\n            print(\"Transpiled circuit:\")\n            display(trans_qc.draw())\n            print(\"Circuit depth:\")\n            print(\"---------------\")\n            print(\"Circuit:\", qc.depth())\n            print(\"Transpiled circuit:\", trans_qc.depth())\n            print(\"\\nCircuit size:\")\n            print(\"---------------\")\n            print(\"Circuit:\", qc.size())\n            print(\"Transpiled circuit:\", trans_qc.size())\n    if __name__ == '__main__':\n        main()\n    ```", "```py\n# Add H\nqc.x(0)\nqc.h(0)\n```", "```py\n# H + Barrier\nqc.x(0)\nqc.barrier(0)\nqc.h(0)\n```", "```py\n# Controlled Y (CY)\nqc.cy(0,1)\n```", "```py\n# Non-conforming CX\nqc.cx(0,4)\n```", "```py\n# Show measurement targets\nqc.barrier([0,1,2,3,4])\nqc.measure([0,1,2,3,4],[0,1,2,3,4])\n```", "```py\n# Multi qubit circuit\nqc.h(0)\nqc.h(3)\nqc.cx(0,4)\nqc.cswap(3,1,2)\n```"]