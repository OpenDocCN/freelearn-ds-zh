["```py\nnimbus.host: \"localhost\"\ntopology.workers: 1\n\noauth.consumer_key: \"blahblahblah\"\noauth.consumer_secret: \"blahblahblah\"\noauth.access_token: \"blahblahblah\"\noauth.access_token_secret: \"blahblahblah\"\n```", "```py\nimport json\nimport Queue\nimport threading\n\nfrom petrel import storm\nfrom petrel.emitter import Spout\n\nfrom tweepy.streaming import StreamListener\nfrom tweepy import OAuthHandler, Stream\n\nclass QueueListener(StreamListener):\n    def __init__(self, queue):\n        self.queue = queue\n\n    def on_data(self, data):\n        tweet = json.loads(data)\n        if 'text' in tweet:\n            self.queue.put(tweet['text'])\n        return True\n\nclass TwitterStreamSpout(Spout):\n    def __init__(self):\n        super(TwitterStreamSpout, self).__init__(script=__file__)\n        self.queue = Queue.Queue(1000)\n\n    def initialize(self, conf, context):\n        self.conf = conf\n        thread = threading.Thread(target=self._get_tweets)\n        thread.daemon = True\n        thread.start()\n\n    @classmethod\n    def declareOutputFields(cls):\n        return ['sentence']\n\n    def _get_tweets(self):\n        auth = OAuthHandler(\n            self.conf['oauth.consumer_key'],\n            self.conf['oauth.consumer_secret'])\n        auth.set_access_token(\n            self.conf['oauth.access_token'],\n            self.conf['oauth.access_token_secret'])\n        stream = Stream(auth, QueueListener(self.queue))\n        stream.sample(languages=['en'])\n\n    def nextTuple(self):\n        tweet = self.queue.get()\n        storm.emit([tweet])\n        self.queue.task_done()\n\ndef run():\n    TwitterStreamSpout().run()\n```", "```py\nimport nltk.corpus\n\nfrom petrel import storm\nfrom petrel.emitter import BasicBolt\n\nclass SplitSentenceBolt(BasicBolt):\n    def __init__(self):\n        super(SplitSentenceBolt, self).__init__(script=__file__)\n        self.stop = set(nltk.corpus.stopwords.words('english'))\n        self.stop.update(['http', 'https', 'rt'])\n\n    def declareOutputFields(self):\n        return ['word']\n\n    def process(self, tup):\n        for word in self._get_words(tup.values[0]):\n            storm.emit([word])\n\n    def _get_words(self, sentence):\n        for w in nltk.word_tokenize(sentence):\n            w = w.lower()\n            if w.isalpha() and w not in self.stop:\n                yield w\n\ndef run():\n    SplitSentenceBolt().run()\n```", "```py\nfrom collections import defaultdict\n\nfrom petrel import storm\nfrom petrel.emitter import BasicBolt\n\nclass SlotBasedCounter(object):\n    def __init__(self, numSlots):\n        self.numSlots = numSlots\n        self.objToCounts = defaultdict(lambda: [0] * numSlots)\n\n    def incrementCount(self, obj, slot):\n        self.objToCounts[obj][slot] += 1\n\n    def getCount(self, obj, slot):\n        return self.objToCounts[obj][slot]\n\n    def getCounts(self):\n        return dict((k, sum(v)) for k, v in self.objToCounts.iteritems())\n\n    def wipeSlot(self, slot):\n        for obj in self.objToCounts.iterkeys():\n            self.objToCounts[obj][slot] = 0\n\n    def shouldBeRemovedFromCounter(self, obj):\n        return sum(self.objToCounts[obj]) == 0\n\n    def wipeZeros(self):\n        objToBeRemoved = set()\n        for obj in self.objToCounts.iterkeys():\n            if sum(self.objToCounts[obj]) == 0:\n                objToBeRemoved.add(obj)\n        for obj in objToBeRemoved:\n            del self.objToCounts[obj]\n\nclass SlidingWindowCounter(object):\n    def __init__(self, windowLengthInSlots):\n        self.windowLengthInSlots = windowLengthInSlots\n        self.objCounter = /\n            SlotBasedCounter(\n                self.windowLengthInSlots)\n        self.headSlot = 0\n        self.tailSlot = self.slotAfter(self.headSlot)\n\n    def incrementCount(self, obj):\n        self.objCounter.incrementCount(obj, self.headSlot)\n\n    def getCountsThenAdvanceWindow(self):\n        counts = self.objCounter.getCounts()\n        self.objCounter.wipeZeros()\n        self.objCounter.wipeSlot(self.tailSlot)\n        self.headSlot = self.tailSlot\n        self.tailSlot = self.slotAfter(self.tailSlot)\n        return counts\n\n    def slotAfter(self, slot):\n        return (slot + 1) % self.windowLengthInSlots\n\nclass RollingCountBolt(BasicBolt):\n    numWindowChunks = 5\n    emitFrequencyInSeconds = 60\n    windowLengthInSeconds = numWindowChunks * \\\n        emitFrequencyInSeconds\n\n    def __init__(self):\n        super(RollingCountBolt, self).__init__(script=__file__)\n        self.counter = SlidingWindowCounter(\n            self.windowLengthInSeconds /\n                self.emitFrequencyInSeconds\n\n    @classmethod\n    def declareOutputFields(cls):\n        return ['word', 'count']\n\n    def process(self, tup):\n        if tup.is_tick_tuple():\n            self.emitCurrentWindowCounts()\n        else:\n            self.counter.incrementCount(tup.values[0])\n\n    def emitCurrentWindowCounts(self):\n        counts = self.counter.getCountsThenAdvanceWindow()\n        for k, v in counts.iteritems():\n            storm.emit([k, v])\n\n    def getComponentConfiguration(self):\n        return {\"topology.tick.tuple.freq.secs\":\n            self.emitFrequencyInSeconds}\n\ndef run():\n    RollingCountBolt().run()\n```", "```py\nfrom petrel import storm\nfrom petrel.emitter import BasicBolt\n\ndef tup_sort_key(tup):\n    return tup.values[1]\n\nclass IntermediateRankingsBolt(BasicBolt):\n    emitFrequencyInSeconds = 15\n    maxSize = 10\n\n    def __init__(self):\n        super(IntermediateRankingsBolt, self).__init__(script=__file__)\n        self.rankedItems = {}\n\n    def declareOutputFields(self):\n        return ['word', 'count']\n\n    def process(self, tup):\n        if tup.is_tick_tuple():\n            for t in self.rankedItems.itervalues():\n                storm.emit(t.values)\n        else:\n            self.rankedItems[tup.values[0]] = tup\n            if len(self.rankedItems) > self.maxSize:\n                for t in sorted(\n                        self.rankedItems.itervalues(), key=tup_sort_key):\n                    del self.rankedItems[t.values[0]]\n                    break\n\n    def getComponentConfiguration(self):\n        return {\"topology.tick.tuple.freq.secs\":\n            self.emitFrequencyInSeconds}\n\ndef run():\n    IntermediateRankingsBolt().run()\n```", "```py\nimport logging\n\nfrom petrel import storm\nfrom petrel.emitter import BasicBolt\n\nlog = logging.getLogger('totalrankings')\n\ndef tup_sort_key(tup):\n    return tup.values[1]\n\nclass TotalRankingsBolt(BasicBolt):\n    emitFrequencyInSeconds = 15\n    maxSize = 10\n\n    def __init__(self):\n        super(TotalRankingsBolt, self).__init__(script=__file__)\n        self.rankedItems = {}\n\n    def declareOutputFields(self):\n        return ['word', 'count']\n\n    def process(self, tup):\n        if tup.is_tick_tuple():\n            for t in sorted(\n                    self.rankedItems.itervalues(),\n                    key=tup_sort_key,\n                    reverse=True):\n                log.info('Emitting: %s', repr(t.values))\n                storm.emit(t.values)\n        else:\n            self.rankedItems[tup.values[0]] = tup\n            if len(self.rankedItems) > self.maxSize:\n                for t in sorted(\n                        self.rankedItems.itervalues(),\n                        key=tup_sort_key):\n                    del self.rankedItems[t.values[0]]\n                    break\n            zero_keys = set(\n                k for k, v in self.rankedItems.iteritems()\n                if v.values[1] == 0)\n            for k in zero_keys:\n                del self.rankedItems[k]\n\n    def getComponentConfiguration(self):\n        return {\"topology.tick.tuple.freq.secs\": self.emitFrequencyInSeconds}\n\ndef run():\n    TotalRankingsBolt().run()\n```", "```py\nfrom twitterstream import TwitterStreamSpout\nfrom splitsentence import SplitSentenceBolt\nfrom rollingcount import RollingCountBolt\nfrom intermediaterankings import IntermediateRankingsBolt\nfrom totalrankings import TotalRankingsBolt\n\ndef create(builder):\n    spoutId = \"spout\"\n    splitterId = \"splitter\"\n    counterId = \"counter\"\n    intermediateRankerId = \"intermediateRanker\"\n    totalRankerId = \"finalRanker\"\n    builder.setSpout(spoutId, TwitterStreamSpout(), 1)\n    builder.setBolt(\n        splitterId, SplitSentenceBolt(), 1).shuffleGrouping(\"spout\")\n    builder.setBolt(\n        counterId, RollingCountBolt(), 4).fieldsGrouping(\n            splitterId, [\"word\"])\n    builder.setBolt(\n        intermediateRankerId,\n        IntermediateRankingsBolt(), 4).fieldsGrouping(\n            counterId, [\"word\"])\n    builder.setBolt(\n        totalRankerId, TotalRankingsBolt()).globalGrouping(\n            intermediateRankerId)\n```", "```py\n    pip install -U pip\n    pip install nltk==3.0.1 oauthlib==0.7.2 tweepy==3.2.0\n    ```", "```py\n    logconfig.ini\n    setup.sh\n    ```", "```py\n    petrel submit --config topology.yaml --logdir `pwd`\n    ```", "```py\nls -ltr petrel*totalrankings.log\n```", "```py\ntail -f petrel24748_totalrankings.log\n```"]