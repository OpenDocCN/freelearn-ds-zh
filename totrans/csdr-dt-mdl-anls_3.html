<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;CQL Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. CQL Data Types</h1></div></div></div><p>In this chapter, we will have an overview of Cassandra Query Language and take a detailed look into the wealthy set of data types supported by Cassandra. We will walk through the data types to study what their internal storage structure looks like. If you want to know how Cassandra implements them behind the scenes, the Java source code of Cassandra can be referenced. For those of you who have not installed and set up Cassandra, you can refer to <a class="link" href="ch05.html" title="Chapter 5. First-cut Design and Implementation">Chapter 5</a>, <span class="emphasis"><em>First-cut Design and Implementation</em></span>, for a quick procedure.</p><div class="section" title="Introduction to CQL"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Introduction to CQL</h1></div></div></div><p>Cassandra introduced Cassandra Query Language (CQL) in release 0.8 as a SQL-like alternative<a id="id188" class="indexterm"/> to the traditional Thrift RPC API. As of the time of this writing, the latest CQL version is 3.1.7. I do not want to take you through all of its old versions and therefore, I will focus on version 3.1.7 only. It should be noted that CQL Version 3 is not backward compatible with CQL Version 2 and differs from it in many ways.</p><div class="section" title="CQL statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>CQL statements</h2></div></div></div><p>CQL Version 3 provides a model very similar to SQL. Conceptually, it uses a table to store data<a id="id189" class="indexterm"/> in rows of columns. It is composed of three main types of <a id="id190" class="indexterm"/>statements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data definition statements</strong></span>: These <a id="id191" class="indexterm"/>are <a id="id192" class="indexterm"/>used to set and change how data is stored in Cassandra</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data manipulation statements</strong></span>: These <a id="id193" class="indexterm"/>are used to create, delete, and modify data</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Query statements</strong></span>: These<a id="id194" class="indexterm"/> are used to look <a id="id195" class="indexterm"/>up data</li></ul></div><p>CQL is case insensitive, unless the word is enclosed in double quotation marks. It defines a list of keywords that have a fixed meaning for the language. It distinguishes between reserved and <a id="id196" class="indexterm"/>non-reserved keywords. <span class="strong"><strong>Reserved</strong></span> keywords <a id="id197" class="indexterm"/>cannot be used as identifiers. They are truly<a id="id198" class="indexterm"/> reserved for the language. <span class="strong"><strong>Non-reserved</strong></span> keywords only have a <a id="id199" class="indexterm"/>specific meaning in certain contexts but can be used as identifiers. The list of CQL keywords is shown in DataStax's<a id="id200" class="indexterm"/> documentation at <a class="ulink" href="http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html">http://www.datastax.com/documentation/cql/3.1/cql/cql_reference/keywords_r.html</a>.</p></div><div class="section" title="CQL command-line client – cqlsh"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>CQL command-line client – cqlsh</h2></div></div></div><p>Cassandra <a id="id201" class="indexterm"/>bundles an interactive terminal supporting CQL, known as <code class="literal">cqlsh</code>. It is<a id="id202" class="indexterm"/> a Python-based command-line client used to run CQL commands. To start <code class="literal">cqlsh</code>, navigate to Cassandra's <code class="literal">bin</code> directory and type the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On Linux, type <code class="literal">./cqlsh</code></li><li class="listitem" style="list-style-type: disc">On Windows, type <code class="literal">cqlsh.bat</code> or <code class="literal">python cqlsh</code></li></ul></div><p>As shown in the following figure, <code class="literal">cqlsh</code> shows the cluster name, Cassandra, CQL, and Thrift protocol versions on startup:</p><div class="mediaobject"><img src="graphics/8884OS_03_01.jpg" alt="CQL command-line client – cqlsh"/><div class="caption"><p>cqlsh connected to the Cassandra instance running on the local node</p></div></div><p>We can use <code class="literal">cqlsh</code> to connect to other nodes by appending the host (either hostname or IP address) and port as command-line parameters.</p><p>If we want to create a keyspace called <code class="literal">packt</code> using <code class="literal">SimpleStrategy</code> (which <code class="literal"> </code>will be explained in <a class="link" href="ch06.html" title="Chapter 6. Enhancing a Version">Chapter 6</a>, <span class="emphasis"><em>Enhancing a Version</em></span>) as its replication strategy and setting the replication factor as one for a single-node Cassandra cluster, we can type the CQL statement, shown in the following screenshot, in <code class="literal">cqlsh</code>.</p><p>This utility will be used extensively in this book to demonstrate how to use CQL to define the Cassandra data model:</p><div class="mediaobject"><img src="graphics/8884OS_03_02.jpg" alt="CQL command-line client – cqlsh"/><div class="caption"><p>Create keyspace packt in cqlsh</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can<a id="id203" class="indexterm"/> download the example code files for all Packt books<a id="id204" class="indexterm"/> you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a>and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="Native data types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Native data types</h2></div></div></div><p>CQL Version 3<a id="id205" class="indexterm"/> supports many basic data types for columns. It also supports collection types and all data types available to Cassandra. The following table lists the supported basic data types and their corresponding meanings:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>ascii</p>
</td><td style="text-align: left" valign="top">
<p>ASCII <a id="id206" class="indexterm"/>character string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>bigint</p>
</td><td style="text-align: left" valign="top">
<p>64-bit signed<a id="id207" class="indexterm"/> long</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>blob</p>
</td><td style="text-align: left" valign="top">
<p>Arbitrary<a id="id208" class="indexterm"/> bytes (no validation)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Boolean</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">True</code> or<a id="id209" class="indexterm"/> <code class="literal">False</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>counter</p>
</td><td style="text-align: left" valign="top">
<p>Counter<a id="id210" class="indexterm"/> column (64-bit signed value)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>decimal</p>
</td><td style="text-align: left" valign="top">
<p>Variable-precision<a id="id211" class="indexterm"/> decimal</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>double</p>
</td><td style="text-align: left" valign="top">
<p>64-bit IEEE 754 floating <a id="id212" class="indexterm"/>point</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>float</p>
</td><td style="text-align: left" valign="top">
<p>32-bit IEEE 754<a id="id213" class="indexterm"/> floating point</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>inet</p>
</td><td style="text-align: left" valign="top">
<p>An IP <a id="id214" class="indexterm"/>address that can be either 4 bytes long (IPv4) or 16 bytes long (IPv6) and should be inputted as a string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>int</p>
</td><td style="text-align: left" valign="top">
<p>32-bit <a id="id215" class="indexterm"/>signed integer</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>text</p>
</td><td style="text-align: left" valign="top">
<p>UTF8<a id="id216" class="indexterm"/> encoded string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>timestamp</p>
</td><td style="text-align: left" valign="top">
<p>A <a id="id217" class="indexterm"/>timestamp in which string constants are allowed to input timestamps as dates</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>timeuuid</p>
</td><td style="text-align: left" valign="top">
<p>Type 1 UUID<a id="id218" class="indexterm"/> that is generally used as a "conflict-free" timestamp</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>uuid</p>
</td><td style="text-align: left" valign="top">
<p>Type 1 <a id="id219" class="indexterm"/>or type 4 UUID</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>varchar</p>
</td><td style="text-align: left" valign="top">
<p>UTF8-encoded <a id="id220" class="indexterm"/>string</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>varint</p>
</td><td style="text-align: left" valign="top">
<p>Arbitrary-precision<a id="id221" class="indexterm"/> integer</p>
</td></tr></tbody></table></div><div class="blockquote"><blockquote class="blockquote"><p>Table 1. CQL Version 3 basic data types</p></blockquote></div></div><div class="section" title="Cassandra implementation"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Cassandra implementation</h2></div></div></div><p>If we look<a id="id222" class="indexterm"/> into the Cassandra's Java source code, the CQL Version 3 <a id="id223" class="indexterm"/>native data types are declared in an <code class="literal">enum</code> called <code class="literal">Native</code> in the <code class="literal">org.apache.cassandra.cql3.CQL3Type</code> interface, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_03.jpg" alt="Cassandra implementation"/><div class="caption"><p>Cassandra source code declaring CQL Version 3 native data types</p></div></div><p>It is <a id="id224" class="indexterm"/>interesting to know that <code class="literal">TEXT</code> and <code class="literal">VARCHAR</code> are indeed<a id="id225" class="indexterm"/> both <code class="literal">UTF8Type</code>. The Java classes of <code class="literal">AsciiType</code>, <code class="literal">LongType</code>, <code class="literal">BytesType</code>, <code class="literal">DecimalType</code>, and so on are declared in the <code class="literal">org.apache.cassandra.db.marshal</code> package.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>Cassandra <a id="id226" class="indexterm"/>source code is available on GitHub at <a class="ulink" href="https://github.com/apache/cassandra">https://github.com/apache/cassandra</a>.</p></div></div><p>Knowing the Java implementation of the native data types allows us to have a deeper understanding of how Cassandra handles them. For example, Cassandra uses the <code class="literal">org.apache.cassandra.serializers.InetAddressSerializer</code> class and <code class="literal">java.net.InetAddress</code> class to handle the serialization/deserialization of the <code class="literal">INET</code> data type.</p></div><div class="section" title="A not-so-long example"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>A not-so-long example</h2></div></div></div><p>These native<a id="id227" class="indexterm"/> data types are used in CQL statements to specify the type of data to be stored in a column of a table. Now let us create an experimental table with columns of each native data type (except counter type since it requires a separate table), and then insert some data into it. We need to specify the keyspace, <code class="literal">packt</code> in this example, before creating the table called <code class="literal">table01</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_04.jpg" alt="A not-so-long example"/><div class="caption"><p>Create table01 to illustrate each native data type</p></div></div><p>We create the table using the default values, but, there are other options to configure the new table for optimizations, including compaction, compression, failure handling, and so on. The <code class="literal">PRIMARY KEY</code> clause, which is on only one column, could also be specified along with an attribute, that is, <code class="literal">rowkey ascii PRIMARY KEY</code>. Then insert a sample record into <code class="literal">table01</code>. We make it with an <code class="literal">INSERT</code> statement, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_05.jpg" alt="A not-so-long example"/><div class="caption"><p>Insert a sample record into table01</p></div></div><p>We now <a id="id228" class="indexterm"/>have data inside <code class="literal">table01</code>. We use <code class="literal">cqlsh</code> to query the table. For the sake of comparison, we also use another Cassandra command-line tool called Cassandra CLI to have a low-level view of the row. Let us open Cassandra CLI on a terminal.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>
<span class="strong"><strong>Cassandra CLI utility</strong></span>
</p><p>Cassandra CLI is <a id="id229" class="indexterm"/>used to set storage configuration attributes on a per-keyspace or per-table basis. To start it up, you navigate to Cassandra bin directory and type the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On Linux, <code class="literal">./cassandra-cli</code></li><li class="listitem" style="list-style-type: disc">On Windows, <code class="literal">cassandra.bat</code></li></ul></div><p>Note that it was announced to be deprecated in Cassandra 3.0 and <code class="literal">cqlsh</code> should be used instead.</p></div></div><p>The results of the <code class="literal">SELECT</code> statement in <code class="literal">cqlsh</code> and the <code class="literal">list</code> command in Cassandra CLI are shown in the following screenshot. We will then walk through each column one by one:</p><div class="mediaobject"><img src="graphics/8884OS_03_06.jpg" alt="A not-so-long example"/><div class="caption"><p>Comparison of the sample row in cqlsh and Cassandra CLI</p></div></div></div><div class="section" title="ASCII"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>ASCII</h2></div></div></div><p>Internally, a <a id="id230" class="indexterm"/>data value <code class="literal">'ABC'</code> is stored as the byte values in <a id="id231" class="indexterm"/>hexadecimal representation of each individual character, <code class="literal">'A'</code>, <code class="literal">'B'</code>, and <code class="literal">'C'</code> as <code class="literal">0x41</code>, <code class="literal">0x42</code>, and <code class="literal">0x43</code> respectively.</p></div><div class="section" title="Bigint"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Bigint</h2></div></div></div><p>This <a id="id232" class="indexterm"/>one<a id="id233" class="indexterm"/> is simple; the hexadecimal representation of the number <code class="literal">1000000000</code> is <code class="literal">0x000000003b9aca00</code> of 64-bit length stored internally.</p></div><div class="section" title="BLOB"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>BLOB</h2></div></div></div><p>A <code class="literal">BLOB</code> data type<a id="id234" class="indexterm"/> is used to store a large binary object. In our previous <a id="id235" class="indexterm"/>example, we inserted a text <code class="literal">'ABC'</code> as a <code class="literal">BLOB</code> into the <code class="literal">blobfield</code>. The internal representation is <code class="literal">414243</code>, which is just a stream of bytes in hexadecimal representation.</p><p>Obviously, a <code class="literal">BLOB</code> field can accept all kinds of data, and because of this flexibility it cannot have validation on its data value. For example, a data value <code class="literal">2</code> may be interpreted as either an integer <code class="literal">2</code> or a text <code class="literal">'2'</code>. Without knowing the interpretation we want, a <code class="literal">BLOB</code> field can impose a check on the data value.</p><p>Another interesting point of a <code class="literal">BLOB</code> field is that, as shown in the <code class="literal">SELECT</code> statement in the previous screenshot in <code class="literal">cqlsh</code>, the data value of <code class="literal">blobfield</code> returned is <code class="literal">0x414243</code> for <code class="literal">'ABC'</code> text. We know from the previous section that <code class="literal">0x41</code>, <code class="literal">0x42</code>, <code class="literal">0x43</code> are the byte values of <code class="literal">'A'</code>, <code class="literal">'B'</code>, and <code class="literal">'C'</code>, respectively. However, for a <code class="literal">BLOB</code> field, <code class="literal">cqlsh</code> prefixes its data value with <code class="literal">'0x'</code> to make it a so-called BLOB constant. A BLOB constant is a sequence of bytes in their hexadecimal values prefixed by <code class="literal">0[xX](hex)+</code> where <code class="literal">hex</code> is a hexadecimal character, such as <code class="literal">[0-9a-fA-F]</code>.</p><p>CQL also provides a number of <code class="literal">BLOB</code> conversion functions to convert native data types into a <code class="literal">BLOB</code> and vice versa. For every <code class="literal">&lt;native-type&gt;</code> (except <code class="literal">BLOB</code> for an obvious reason) supported by CQL, the <code class="literal">&lt;native-type&gt;AsBlob</code> function takes an argument of type <code class="literal">&lt;native-type&gt;</code> and returns it as a <code class="literal">BLOB</code>. Contrarily, the <code class="literal">blobAs&lt;Native-type&gt;</code> function reverses the conversion from a <code class="literal">BLOB</code> back to a <code class="literal">&lt;native-type&gt;</code>. As demonstrated in the <code class="literal">INSERT</code> statement, we have used <code class="literal">textAsBlob()</code> to convert a <code class="literal">text</code> data type into a <code class="literal">BLOB</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>
<span class="strong"><strong>BLOB constant</strong></span>
</p><p>BLOB constants were introduced in CQL version 3.0.2 to allow users to input <code class="literal">BLOB</code> values. In <a id="id236" class="indexterm"/>older versions of CQL, inputting <code class="literal">BLOB</code> as <a id="id237" class="indexterm"/>string was supported for convenience. It<a id="id238" class="indexterm"/> is now deprecated and will be removed in a future version. It is still supported only to allow smoother transition to a <code class="literal">BLOB</code> constant. Updating the client code to switch to <code class="literal">BLOB</code> constants should be done as soon as possible.</p></div></div></div><div class="section" title="Boolean"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Boolean</h2></div></div></div><p>A <code class="literal">boolean</code> data type<a id="id239" class="indexterm"/> is also very intuitive. It is merely a single byte<a id="id240" class="indexterm"/> of either <code class="literal">0x00</code>, which means <code class="literal">False</code>, or <code class="literal">0x01</code>, which means <code class="literal">True</code>, in the internal storage.</p></div><div class="section" title="Decimal"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Decimal</h2></div></div></div><p>A <code class="literal">decimal</code> data type<a id="id241" class="indexterm"/> can store a variable-precision decimal, basically<a id="id242" class="indexterm"/> a <code class="literal">BigDecimal</code> data type in Java.</p></div><div class="section" title="Double"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Double</h2></div></div></div><p>The <code class="literal">double</code> data type <a id="id243" class="indexterm"/>is a double-precision 64-bit IEEE 754 floating <a id="id244" class="indexterm"/>point in its internal storage.</p></div><div class="section" title="Float"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Float</h2></div></div></div><p>The <code class="literal">float</code> data <a id="id245" class="indexterm"/>type is a single-precision 32-bit IEEE 754 floating <a id="id246" class="indexterm"/>point in its internal storage.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>
<span class="strong"><strong>BigDecimal, double, or float?</strong></span>
</p><p>The <a id="id247" class="indexterm"/>difference between <code class="literal">double</code> and <code class="literal">float</code> is obviously<a id="id248" class="indexterm"/> the length of precision in the floating point value. Both <code class="literal">double</code> and <code class="literal">float</code> use binary representation of decimal numbers with a radix which is in many cases an approximation, not an absolute value. <code class="literal">double </code>is a 64-bit value while <code class="literal">float</code> is an even shorter 32-bit value. Therefore, we can say that double is more precise than float. However, in both cases, there is still a possibility of loss of precision which can be very noticeable when working with either very big numbers or very small numbers.</p><p>On the contrary, <code class="literal">BigDecimal</code> is devised to overcome this loss of precision discrepancy. It is an exact way of representing numbers. Its disadvantage is slower<a id="id249" class="indexterm"/> runtime performance.</p><p>Whenever <a id="id250" class="indexterm"/>you are dealing with money or precision<a id="id251" class="indexterm"/> is a must, <code class="literal">BigDecimal</code> is the best choice (or <code class="literal">decimal</code> in CQL native data types), otherwise <code class="literal">double</code> or <code class="literal">float</code> should be<a id="id252" class="indexterm"/> good enough.</p></div></div></div><div class="section" title="Inet"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Inet</h2></div></div></div><p>The <code class="literal">inet</code> data type<a id="id253" class="indexterm"/> is designed for storing IP address values in <span class="strong"><strong>IP Version 4</strong></span> (<span class="strong"><strong>IPv4</strong></span>) and <span class="strong"><strong>IP Version 6</strong></span> (<span class="strong"><strong>IPv6</strong></span>) format. The IP address, <code class="literal">192.168.0.1</code>, in <a id="id254" class="indexterm"/>the example record is stored as four bytes internally; <code class="literal">192</code> is<a id="id255" class="indexterm"/> stored as <code class="literal">0xc0</code>, <code class="literal">168</code> as <code class="literal">0xa8</code>, <code class="literal">0</code> as <code class="literal">0x00</code>, and <code class="literal">1</code> as <code class="literal">0x01</code>, respectively. It <a id="id256" class="indexterm"/>should be noted that regardless of the IP address being stored is IPv4 or IPv6, the port number is <span class="emphasis"><em>not</em></span> stored. We need another column to store it if required.</p><p>We can also store an IPv6 address value. The following <code class="literal">UPDATE</code> statement changes the <code class="literal">inetfield</code> to an IPv6 address <code class="literal">2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_07.jpg" alt="Inet"/><div class="caption"><p>Comparison of the sample row in cqlsh and Cassandra CLI in inetfield</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>
<span class="strong"><strong>Internet Protocol Version 6</strong></span>
</p><p>Internet Protocol Version 6 (IPv6) is the latest version of the <span class="strong"><strong>Internet Protocol</strong></span> (<span class="strong"><strong>IP</strong></span>). It was <a id="id257" class="indexterm"/>developed by the IETF to deal with the<a id="id258" class="indexterm"/> long-anticipated problem of IPv4 address exhaustion.</p><p>IPv6 uses a 128-bit address whereas IPv4 uses 32-bit address. The two protocols are not designed to be interoperable, making the transition to IPv6 complicated.</p><p>IPv6 addresses are usually represented as eight groups of four hexadecimal digits separated by colons, such as <code class="literal">2001:0db8:85a3:0042:1000:8a2e:0370:7334</code>.</p></div></div><p>In <code class="literal">cqlsh</code>, the<a id="id259" class="indexterm"/> leading zeros of each group of four hexadecimal <a id="id260" class="indexterm"/>digits are removed. In Cassandra's internal storage, the IPv6 address value consumes 16 bytes.</p></div><div class="section" title="Int"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Int</h2></div></div></div><p>The <code class="literal">int</code> data<a id="id261" class="indexterm"/> type<a id="id262" class="indexterm"/> is a primitive 32-bit signed integer.</p></div><div class="section" title="Text"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Text</h2></div></div></div><p>The <code class="literal">text</code> data type <a id="id263" class="indexterm"/>is a UTF-8 encoded string accepting Unicode<a id="id264" class="indexterm"/> characters. As shown previously, the byte values of "<code class="literal">ABC</code>", <code class="literal">0x41</code>, <code class="literal">0x42</code>, and <code class="literal">0x43</code>, are stored internally. We can test the <code class="literal">text</code> field with non-ASCII characters by updating the <code class="literal">textfield</code> as shown in the following screenshot:</p><p>The <code class="literal">text</code> data type is a combination of non-ASCII and ASCII characters. The four non-ASCII characters are represented as their 3-byte UTF-8 values, <code class="literal">0xe8b584</code>, <code class="literal">0xe6ba90</code>, <code class="literal">0xe68f90</code>, and <code class="literal">0xe4be9b</code>.</p><p>However, the ASCII characters are still stored as byte values, as shown in the screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_08.jpg" alt="Text"/><div class="caption"><p>Experiment of the textfield data type</p></div></div></div><div class="section" title="Timestamp"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Timestamp</h2></div></div></div><p>The value of the <code class="literal">timestampfield</code> is encoded as a 64-bit signed integer representing a number <a id="id265" class="indexterm"/>of milliseconds since the standard base time known as the <span class="emphasis"><em>epoch</em></span>: January 1, 1970, at 00:00:00 GMT. A <code class="literal">timestamp</code> data type can be entered as an<a id="id266" class="indexterm"/> integer for CQL input, or as a string literal in ISO 8601 formats. As shown in the following screenshot, the internal value of May 1, 2014, 16:02:03, in the +08:00 timezone is <code class="literal">0x00000145b6cdf878</code> or 1,398,931,323,000 milliseconds since the epoch:</p><div class="mediaobject"><img src="graphics/8884OS_03_13.jpg" alt="Timestamp"/><div class="caption"><p>Experiment of the timestamp data type</p></div></div><p>A <code class="literal">timestamp</code> data type contains a date portion and a time portion in which the time of the day <a id="id267" class="indexterm"/>can be omitted if only the value of the date is wanted. Cassandra <a id="id268" class="indexterm"/>will use 00:00:00 as the default for the omitted time of day.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>
<span class="strong"><strong>ISO 8601</strong></span>
</p><p>ISO 8601<a id="id269" class="indexterm"/> is the international standard for representation of dates and times. Its full reference number is ISO 8601:1988 (E), and its title is "Data elements and interchange formats – Information interchange – Representation of dates and times."</p><p>ISO 8601 describes a large number of date/time formats depending on the desired level of granularity. The formats are as follows. Note that the "T" appears literally in the string to indicate the beginning of the time element.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Year: YYYY (e.g. 1997)</li><li class="listitem" style="list-style-type: disc">Year and month: YYYY-MM (e.g. 1997-07)</li><li class="listitem" style="list-style-type: disc">Date: YYYY-MM-DD (e.g. 1997-07-16)</li><li class="listitem" style="list-style-type: disc">Date plus hours and minutes: YYYY-MM-DDThh:mmTZD (e.g. 1997-07-16T19:20+01:00)</li><li class="listitem" style="list-style-type: disc">Date plus hours, minutes and seconds: YYYY-MM-DDThh:mm:ssTZD (e.g. 1997-07-16T19:20:30+01:00)</li><li class="listitem" style="list-style-type: disc">Date plus<a id="id270" class="indexterm"/> hours, minutes, seconds and a decimal fraction of a second: YYYY-MM-DDThh:mm:ss.sTZD (e.g. 1997-07-16T19:20:30.45+01:00)</li></ul></div><p>Where:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">YYYY = four-digit year</li><li class="listitem" style="list-style-type: disc">MM = two-digit month (01=January, etc.)</li><li class="listitem" style="list-style-type: disc">DD = two-digit day of month (01 through 31)</li><li class="listitem" style="list-style-type: disc">hh = two digits of hour (00 through 23) (am/pm NOT allowed)</li><li class="listitem" style="list-style-type: disc">mm = two digits of minute (00 through 59)</li><li class="listitem" style="list-style-type: disc">ss = two digits of second (00 through 59)</li><li class="listitem" style="list-style-type: disc">s = one or more digits representing a decimal fraction of a second</li><li class="listitem" style="list-style-type: disc">TZD = time zone designator (Z or +hh:mm or -hh:mm)</li></ul></div><p>Times <a id="id271" class="indexterm"/>are expressed either in <span class="strong"><strong>Coordinated Universal Time</strong></span> (<span class="strong"><strong>UTC</strong></span>) with a special UTC designator "Z" or in local time together with a time zone offset in hours and minutes. A time zone offset of "+/-hh:mm" indicates the use of a local time zone which is "hh" hours and "mm" minutes ahead/behind of UTC.</p></div></div><p>If no<a id="id272" class="indexterm"/> time zone is specified, the time zone of the Cassandra <a id="id273" class="indexterm"/>coordinator node handing the write request is used. Therefore the best practice is to specify the time zone with the timestamp rather than relying on the time zone configured on the Cassandra nodes to avoid any ambiguities.</p></div><div class="section" title="Timeuuid"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Timeuuid</h2></div></div></div><p>A value<a id="id274" class="indexterm"/> of the <code class="literal">timeuuid</code> data type is a Type 1 UUID which<a id="id275" class="indexterm"/> includes the time of its generation and is sorted by timestamp. It is therefore ideal for use in applications requiring conflict-free timestamps. A valid <code class="literal">timeuuid</code> uses the time in 100 intervals since 00:00:00.00 UTC (60 bits), a clock sequence number for prevention of duplicates (14 bits), and the IEEE 801 MAC address (48 bits) to generate a unique identifier, for example, <code class="literal">74754ac0-e13f-11e3-a8a3-a92bc9056ee6</code>.</p><p>CQL v3 offers a number of functions to make the manipulation of <code class="literal">timeuuid</code> handy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>dateOf()</strong></span>: This<a id="id276" class="indexterm"/> is used in a <code class="literal">SELECT</code> statement to extract the timestamp portion of a <code class="literal">timeuuid</code> column</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>now()</strong></span>: This <a id="id277" class="indexterm"/>is used to generate a new unique <code class="literal">timeuuid</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>minTimeuuid() and maxTimeuuid()</strong></span>: These are used to return a result similar<a id="id278" class="indexterm"/> to a UUID given a conditional time <a id="id279" class="indexterm"/>component as its argument</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>unixTimestampOf()</strong></span>: This is used in a <code class="literal">SELECT</code> statement to extract the timestamp<a id="id280" class="indexterm"/> portion as a raw 64-bit integer timestamp of a <code class="literal">timeuuid</code> column</li></ul></div><p>The <a id="id281" class="indexterm"/>following figure uses <code class="literal">timeuuidfield</code> of <code class="literal">table01</code> to<a id="id282" class="indexterm"/> demonstrate the usage of these <code class="literal">timeuuid</code> functions:</p><div class="mediaobject"><img src="graphics/8884OS_03_09.jpg" alt="Timeuuid"/><div class="caption"><p>Demonstration of timeuuid functions</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>
<span class="strong"><strong>Timestamp or Timeuuid?</strong></span>
</p><p>Timestamp is<a id="id283" class="indexterm"/> suitable for storing date and time values. TimeUUID, however, is more suitable in those cases where a conflict free, unique timestamp is needed.</p></div></div></div><div class="section" title="UUID"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>UUID</h2></div></div></div><p>The <code class="literal">UUID</code> data type<a id="id284" class="indexterm"/> is usually used to avoid collisions in values. It is a <a id="id285" class="indexterm"/><a id="id286" class="indexterm"/>16-byte value that accepts a type 1 or type 4 UUID. CQL v3.1.6 or later versions provide a function called <code class="literal">uuid()</code> to easily generate random type 4 UUID values.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>
<span class="strong"><strong>Type 1 or type 4 UUID?</strong></span>
</p><p>Type 1 uses the MAC address of the computer that is generating the <code class="literal">UUID</code> data type and <a id="id287" class="indexterm"/>the number of 100-nanosecond intervals since the adoption of the Gregorian calendar, to generate UUIDs. Its uniqueness across computers is guaranteed if MAC addresses are not duplicated; however, given the speed of modern processors, successive invocations on the same machine of a naive implementation of a type 1 generator might produce the same <code class="literal">UUID</code>, negating the property of uniqueness.</p><p>Type 4 uses random or pseudorandom numbers. Therefore, it is the recommended type of <code class="literal">UUID</code> to be used.</p></div></div></div><div class="section" title="Varchar"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Varchar</h2></div></div></div><p>Basically <code class="literal">varchar</code> is<a id="id288" class="indexterm"/> identical to <code class="literal">text</code> as evident by the<a id="id289" class="indexterm"/> same <code class="literal">UTF8Type</code> in the source code.</p></div><div class="section" title="Varint"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Varint</h2></div></div></div><p>A <code class="literal">varint</code> data <a id="id290" class="indexterm"/>type<a id="id291" class="indexterm"/> is used to store integers of arbitrary precision.</p></div><div class="section" title="Counter"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Counter</h2></div></div></div><p>A <code class="literal">counter</code> data type<a id="id292" class="indexterm"/> is a special kind of column whose user-visible <a id="id293" class="indexterm"/>value is a 64-bit signed integer (though this is more complex internally) used to store a number that incrementally counts the occurrences of a particular event. When a new value is written to a given counter column, it is added to the previous value of the counter.</p><p>A counter is ideal for counting things quickly in a distributed environment which makes it invaluable for real time analytical tasks. The <code class="literal">counter</code> data type was introduced in Cassandra Version 0.8. Counter column tables must use <code class="literal">counter</code> data type. Counters can be stored in dedicated tables only, and you cannot create an index on a counter column.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Counter type don'ts</strong></span>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't assign the <code class="literal">counter</code> data type to a column that serves as the primary key</li><li class="listitem" style="list-style-type: disc">Don't use the <code class="literal">counter</code> data type in a table that contains anything other than <code class="literal">counter</code> data types and primary keys</li><li class="listitem" style="list-style-type: disc">Don't use the <code class="literal">counter</code> data type to generate sequential numbers for surrogate keys; use the <code class="literal">timeuuid</code> data type instead</li></ul></div></div></div><p>We <a id="id294" class="indexterm"/>use a <code class="literal">CREATE TABLE</code> statement to create a counter table. However, <code class="literal">INSERT</code> statements are not allowed on counter tables and so we must use an <code class="literal">UPDATE</code> statement <a id="id295" class="indexterm"/>to update the counter column as shown in the following screenshot.</p><p>Cassandra uses <code class="literal">counter</code> instead of <code class="literal">name</code> to indicate that the column is of a counter data type. The counter value is stored in the value of the column.</p><p>This is a very good article that explains the internals of how a counter works in a distributed environment <a class="ulink" href="http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters">http://www.datastax.com/dev/blog/whats-new-in-cassandra-2-1-a-better-implementation-of-counters</a>.</p><p>The following screenshot shows that counter value is stored in the value of the column:</p><div class="mediaobject"><img src="graphics/8884OS_03_10.jpg" alt="Counter"/><div class="caption"><p>Experiment of the counter data type</p></div></div></div></div></div>
<div class="section" title="Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Collections</h1></div></div></div><p>Cassandra also <a id="id296" class="indexterm"/>supports collections in its data model to store a small amount of data. Collections are a complex type that can provide tremendous flexibility. Three collections are supported: Set, List, and Map. The type of data stored in each of these collections requires to be defined, for example, a set of timestamp is defined as <code class="literal">set&lt;timestamp&gt;</code>, a list of text is defined as <code class="literal">list&lt;text&gt;</code>, a map containing a text key and a text value is defined as <code class="literal">map&lt;text, text&gt;</code>, and so on. Also, only native data types can be used in collections.</p><p>Cassandra reads a collection in its entirety and the collection is not paged internally. The maximum number of items of a collection is 64K and the maximum size of an item is 64K.</p><p>To better demonstrate the CQL support on these collections, let us create a table in the <code class="literal">packt</code> keyspace <a id="id297" class="indexterm"/>with columns of each collection and insert some data into it, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8884OS_03_11.jpg" alt="Collections"/><div class="caption"><p>Experiment on collections</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>
<span class="strong"><strong>How to update or delete a collection?</strong></span>
</p><p>CQL also<a id="id298" class="indexterm"/> supports updation and deletion of elements in a<a id="id299" class="indexterm"/> collection. You can refer to the relevant information in DataStax's documentation at <a class="ulink" href="http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html">http://www.datastax.com/documentation/cql/3.1/cql/cql_using/use_collections_c.html</a>.</p></div></div><p>As in the case of native data types, let us walk through each collection below.</p><div class="section" title="Set"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Set</h2></div></div></div><p>CQL uses <a id="id300" class="indexterm"/>sets to keep a collection of unique elements. The benefit of a<a id="id301" class="indexterm"/> set is that Cassandra automatically keeps track of the uniqueness of the elements and we, as application developers, do not need to bother on it.</p><p>CQL uses curly braces (<code class="literal">{}</code>) to represent a set of values separated by commas. An empty set is simply <code class="literal">{}</code>. In the previous example, although we inserted the set as <code class="literal">{'Lemon', 'Orange', 'Apple'}</code>, the input order was not preserved. Why?</p><p>The reason is in the mechanism of how Cassandra stores the set. Internally, Cassandra stores each element of the set as a single column whose column name is the original column name suffixed by a colon and the element value. As shown previously, the ASCII values of <code class="literal">'Apple'</code>, <code class="literal">'Lemon'</code>, and <code class="literal">'Orange'</code> are <code class="literal">0x4170706c65</code>, <code class="literal">0x4c656d6f6e</code>, and <code class="literal">0x4f72616e6765</code>, respectively. So they are stored in three columns with column names, <code class="literal">setfield:4170706c65</code>, <code class="literal">setfield:4c656d6f6e</code>, and <code class="literal">setfield:4f72616e6765</code>. By the built-in order column-name-nature of Cassandra, the elements of a set are sorted automatically.</p></div><div class="section" title="List"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>List</h2></div></div></div><p>A list<a id="id302" class="indexterm"/> is ordered by the natural order of the type selected. Hence it is suitable <a id="id303" class="indexterm"/>when uniqueness is not required and maintaining order is required.</p><p>CQL uses square brackets (<code class="literal">[]</code>) to represent a list of values separated by commas. An empty list is <code class="literal">[]</code>. In contrast to a set, the input order of a list is preserved by Cassandra. Cassandra also stores each element of the list as a column. But this time, the columns have the same name composed of the original column name (<code class="literal">listfield</code> in our example), a colon, and a<a id="id304" class="indexterm"/> UUID generated at the time of update. The element value of the list<a id="id305" class="indexterm"/> is stored in the value of the column.</p></div><div class="section" title="Map"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Map</h2></div></div></div><p>A map<a id="id306" class="indexterm"/> in Cassandra is a dictionary-like data structure with keys and values. It<a id="id307" class="indexterm"/> is useful when you want to store table-like data within a single Cassandra row.</p><p>CQL also uses curly braces (<code class="literal">{}</code>) to represent a map of keys and values separated by commas. Each key-value pair is separated by a colon. An empty map is simply represented as <code class="literal">{}</code>. Conceivably, each key/value pair is stored in a column whose column name is composed of the original map column name followed by a colon and the key of that pair. The value of the pair is stored in the value of the column. Similar to a set, the map sorts its items automatically. As a result, a map can be imagined as a hybrid of a set and a list.</p></div></div>
<div class="section" title="User-defined type and tuple type"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>User-defined type and tuple type</h1></div></div></div><p>Cassandra 2.1 introduces support for <span class="strong"><strong>User-Defined Types</strong></span> (<span class="strong"><strong>UDT</strong></span>) and tuple types.</p><p>User-defined types <a id="id308" class="indexterm"/>are declared at the keyspace level. A user-defined type simplifies <a id="id309" class="indexterm"/>handling a group of related properties. We can define a group of related properties as a type and access them separately or as a single entity. We can map our UDTs to application entities. Another new type for CQL introduced by Cassandra 2.1 is the tuple type. A tuple is a fixed-length set of typed positional fields without labels.</p><p>We can use user-defined and tuple types in tables. However, to support future capabilities, a column definition of a user-defined or tuple type requires the <code class="literal">frozen</code> keyword. Cassandra serializes a frozen value having multiple components into a single value. This means we cannot update parts of a UDT value. The entire value must be overwritten. Cassandra treats the value of a frozen UDT like a <code class="literal">BLOB</code>.</p><p>We create a UDT called <code class="literal">contact</code> in the <code class="literal">packt</code> keyspace and use it to define <code class="literal">contactfield</code> in <code class="literal">table04</code>. Moreover, we have another column, <code class="literal">tuplefield</code>, to store a tuple in a row. Pay attention to the syntax of the <code class="literal">INSERT</code> statement for UDT and tuple. For UDT, we may use a dotted notation to retrieve a component of the UDT column, such as <code class="literal">contactfield.facebook</code> in our following example. As shown in <code class="literal">cassandra-cli</code>, <code class="literal">contactfield</code> is stored as a single value, <code class="literal">00000001620000000163000000076440642e636f6d</code>.</p><p>The value concatenates each UDT component in sequence with the format, a length of 4 bytes indicating the length of the component value and the component value itself. So, for <code class="literal">contactfield.facebook</code>, <code class="literal">0x00000001</code> is the<a id="id310" class="indexterm"/> length and <code class="literal">0x62</code> is the byte value of <code class="literal">'a'</code>. Cassandra <a id="id311" class="indexterm"/>applies the same treatment to a tuple:</p><div class="mediaobject"><img src="graphics/8884OS_03_12.jpg" alt="User-defined type and tuple type"/><div class="caption"><p>Experiment of user-defined and tuple types</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Further <a id="id312" class="indexterm"/>information<a id="id313" class="indexterm"/> can be found at DataStax's documentation, available at the following links: <a class="ulink" href="http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html">http://www.datastax.com/documentation/cql/3.1/cql/cql_using/cqlUseUDT.html</a>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html">http://www.datastax.com/documentation/developer/python-driver/2.1/python-driver/reference/tupleTypes.html</a></li></ul></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Summary</h1></div></div></div><p>This chapter is the second part of Cassandra data modeling. We have learned the basics of Cassandra Query Language (CQL), which offers a SQL-like language to implement a Cassandra data model and operate the data inside. Then a very detailed walkthrough, with ample examples of native data types, more advanced collections, and new user-defined and tuple types, was provided to help you know how to select appropriate data types for your data models. The internal storage of each data type was also explained to let you know how Cassandra implements its data types.</p><p>In the next chapter, we will learn another important element of a Cassandra query—indexes.</p></div></body></html>