- en: Developing Automatic Presentations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自动演示文稿
- en: Have you ever found yourself doing the same mechanical task over and over again?
    It's surprising how many programmers, statisticians, and scientists, in general,
    do not invest time to automate many of their activities, especially reporting
    results. Doing so would allow them to focus deeper on their core competencies.
    Furthermore, this is not unique to individuals; organizations at large still do
    not automate many of their processes, especially analytical ones. Remember the
    graph creation automation we performed in [Chapter 2](part0059.html#1O8H60-f494c932c729429fb734ce52cafce730),
    *Understanding Votes with Descriptive Statistics*, or the regressions automation
    we performed in [Chapter 3](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730),
    *Predicting Votes with Linear Models*? In this chapter, we will show you how to
    automate another activity—developing presentations. By this, we don't mean to
    automate the explanations behind the results, but automate the creation of slides
    that show tables and graphs of the *current status* of a process. This a very
    high benefit/cost area that is often overlooked, and a lot of time is wasted producing
    such presentations for discussion among peers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否发现自己反复进行同样的机械任务？令人惊讶的是，许多程序员、统计学家和科学家通常不花时间自动化许多活动，尤其是报告结果。这样做将使他们能够更深入地专注于他们的核心能力。此外，这不仅仅是个人的问题；大型组织仍然没有自动化许多流程，尤其是分析流程。还记得我们在[第2章](part0059.html#1O8H60-f494c932c729429fb734ce52cafce730)，*使用描述性统计理解投票*中执行的图形创建自动化，或者我们在[第3章](part0076.html#28FAO0-f494c932c729429fb734ce52cafce730)，*使用线性模型预测投票*中执行的回归自动化吗？在本章中，我们将向您展示如何自动化另一项活动——开发演示文稿。通过这种方式，我们并不是指自动化结果背后的解释，而是自动化展示流程*当前状态*的表格和图形的幻灯片创建。这是一个非常高的效益/成本区域，通常被忽视，很多时间都浪费在制作这样的演示文稿以供同行讨论上。
- en: This is the last chapter for The Food Factory example, and here, we will automate
    an activity that people in many organizations find themselves doing over and over
    again—developing presentations for weekly updates. We will show what a content
    automation pipeline looks like in R and build a presentation that can be updated
    automatically with the latest data. To do so, we will use the results we have
    developed during the previous chapters in this example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是《食品工厂》示例的最后一章，在这里，我们将自动化许多组织中的许多人反复进行的活动——为每周更新开发演示文稿。我们将展示R中的内容自动化流程是什么样的，并构建一个可以自动使用最新数据更新的演示文稿。为此，我们将使用我们在本示例前几章中开发的结果。
- en: 'Some of the important topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些重要主题如下：
- en: The importance and benefits of automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的重要性和好处
- en: Setting up and running automation pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和运行自动化流程
- en: Communicating ideas with literate programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文献编程交流想法
- en: Writing static content using Markdown
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Markdown编写静态内容
- en: Developing dynamic content using R Markdown
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用R Markdown开发动态内容
- en: Producing presentation and web pages using knitr
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用knitr制作演示文稿和网页
- en: Integrating R resources efficiently
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效集成R资源
- en: Required packages
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必需的软件包
- en: There are only two required packages for this chapter and you should be able
    to install them without a problem in your system. For more information take a
    look at [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)*, Required
    Packages*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只需要两个必需的软件包，你应该能够在你的系统中无问题地安装它们。更多信息请参阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)*，必需的软件包*。
- en: '| **Package** | Reason |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **软件包** | 原因 |'
- en: '| `ggrepel` | Avoid overlapping labels in graphs |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `ggrepel` | 避免在图形中重叠标签 |'
- en: '| `rmarkdown` | Markdown documents with executable R code |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `rmarkdown` | 带有可执行R代码的Markdown文档 |'
- en: Why invest in automation?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要投资自动化？
- en: Automation is an investment. It often involves taking different applications
    and integrating them to make processes happen repeatedly, hopefully seamlessly
    and effortlessly. Process automation can increase productivity by reducing the
    time taken to perform repetitive tasks, as well as reduce defects, which also
    saves time and enhances the value-creation process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是一种投资。它通常涉及将不同的应用程序集成在一起，以便重复执行流程，希望无缝且轻松。流程自动化可以通过减少执行重复性任务所需的时间来提高生产力，同时减少缺陷，这也可以节省时间并增强价值创造过程。
- en: Furthermore, automated systems do not get bored. It's likely that anyone who
    has to undertake a repetitive task over and over again will get bored. This will
    slow down their performance and increase the risk of defects. An automated process
    will not get bored, no matter how often it is run, so performance is not likely
    to be slowed down.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自动化系统不会感到无聊。很可能任何必须反复执行重复性任务的人都会感到无聊。这会减慢他们的表现并增加缺陷的风险。自动化流程不会感到无聊，无论运行多少次，因此性能不太可能减慢。
- en: 'Scientists can leverage automation to reduce cycle time through scientific
    methods, which in turn increases learning rates, often exponentially. In my opinion,
    this is one of the most powerful consequences of automation: accelerating learning
    processes by removing us (humans) from activities to which we do not add value,
    and allowing us to focus on activities that (so far) cannot be automated, such
    as being creative or developing innovative solutions to valuable problems.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家可以通过科学方法利用自动化来缩短周期时间，这反过来又提高了学习率，通常是指数级的。在我看来，这是自动化最强大的后果之一：通过让我们（人类）从那些我们无法增加价值的活动中解脱出来，从而加速学习过程，并让我们专注于那些（到目前为止）无法自动化的活动，例如创造性地解决问题或开发创新解决方案。
- en: Lastly, people often complain about not having enough time. One effective way
    to get time back is to automate processes, and that's the ultimate benefit of
    automation—making more of your time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，人们常常抱怨没有足够的时间。一种有效的方法是自动化流程，这就是自动化的最终好处——让你的时间更加充实。
- en: Literate programming as a content creation methodology
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文献编程作为一种内容创作方法
- en: Automation requires us to put different pieces together in such a way that the
    process is clear for both humans and machines. The process must be reproducible
    and capable of evolving as new ideas come to us or requirements change. Automating
    content creation can be achieved with literate programming, which comes from Donald
    Knuth's *Literate Programming, 1992* ([http://www-cs-faculty.stanford.edu/~knuth/lp.html](http://www-cs-faculty.stanford.edu/~knuth/lp.html)).
    The basic idea is that a document is viewed as a combination of text and code.
    Code is divided into chunks with text surrounding the code chunks explaining what
    is going on. Text adapts as necessary to keep the ideas behind the code updated,
    clear, and accurate.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化要求我们将不同的部分组合在一起，使得流程对人类和机器都清晰可见。流程必须是可重复的，并且能够随着新想法的产生或需求的变化而发展。通过文献编程可以实现内容创作自动化，这源于唐纳德·克努特在1992年的《文献编程》一书（[http://www-cs-faculty.stanford.edu/~knuth/lp.html](http://www-cs-faculty.stanford.edu/~knuth/lp.html)）。基本思想是将文档视为文本和代码的结合。代码被分成块，周围的文本解释代码块的内容。文本根据需要调整，以保持代码背后的思想更新、清晰和准确。
- en: In this chapter, we use the words *presentation* and *document* interchangeably
    as you can create both of them with the tools we will show.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用“展示”和“文档”这两个词可以互换使用，因为你可以使用我们将展示的工具创建它们。
- en: Literate programming is not a requisite for automating content creation, but
    it certainly is a great tool for it. Literate programming has the advantages of
    being easily readable, just as a manual or instruction set. Also, it allows for
    where code and natural language need to be combined. Results can be automatically
    shown as we go through the document. The document itself is simple text, which
    makes it flexible and easy to change. In general, literate programs are *weaved*
    to produce human-readable documents and *tangled* to produce machine-readable
    documents. To make this work, we only need a documentation language and a programming
    language, which are English and R in our case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 文献编程不是自动化内容创作的必要条件，但它确实是一个很好的工具。文献编程的优点是易于阅读，就像手册或指令集一样。此外，它允许代码和自然语言结合在一起。结果可以在我们浏览文档时自动显示。文档本身是简单的文本，这使得它灵活且易于更改。一般来说，文献程序被“编织”成人类可读的文档，并被“纠缠”成机器可读的文档。为了使这一切工作，我们只需要一种文档语言和一种编程语言，在我们的例子中是英语和R语言。
- en: Literate programming seems to have the potential to make many tools obsolete
    that are currently being used to produce content. However, there are still better
    tools available if you need to produce documents with very accurate formatting
    or that require highly technical optimizations. This is not due to any inherent
    weaknesses in the concept of literate programming, but due to the fact that available
    tools are not as performant as specialized tools in those aspects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 文献编程似乎有潜力使许多目前用于生成内容的工具变得过时。然而，如果你需要生成具有非常精确格式或需要高度技术优化的文档，仍然有更好的工具可用。这并不是因为文献编程概念本身有任何固有的弱点，而是因为可用的工具在这些方面并不像专业工具那样高效。
- en: When it comes to literate programming, R strikes a nice balance between technical
    complexity and simple presentations, allowing for a wide range of content automation
    to be developed, and this can produce documents that can serve very well for research
    and data analysis in general. If at some point you find that you need to make
    a change, you can easily do so, recompile, and you'll be looking at the latest
    version in a matter of seconds. That's why it's very handy to develop automated
    presentations the way we will show you in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到文献编程时，R在技术复杂性和简单展示之间找到了一个很好的平衡，这使得可以开发出广泛的内容自动化，这可以产生非常适合研究和数据分析的文档。如果你在某个时候发现你需要进行更改，你可以轻松地做到这一点，重新编译，你将在几秒钟内看到最新版本。这就是为什么我们将在本章中向您展示如何以这种方式开发自动化演示文稿非常方便。
- en: Reproducibility as a benefit of literate programming
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文献编程作为可重复性的好处
- en: In science, reproducibility is the most important element of verifying and validating
    analysis findings. The analyses, models, and algorithms we run are much more complicated
    than they used to be. Having a basic understanding of these algorithms is difficult,
    even for a sophisticated person, and it's almost impossible to describe with words
    alone. Understanding what someone did nowadays requires looking at data and code
    directly, not only at results.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学中，可重复性是验证和验证分析发现最重要的元素。我们运行的分析和模型、算法比以往任何时候都要复杂。即使对于复杂的人来说，对这些算法有基本理解也很困难，而且几乎不可能仅用文字来描述。现在理解某人做了什么需要直接查看数据和代码，而不仅仅是结果。
- en: Scientists write a lot of reports describing the results of data analyses. Making
    those reports reproducible is essential to have your work reviewed by your peers,
    and it is a very good way to accomplish this with literate programming. With it,
    the final report depends on code that is executed at the moment of its creation,
    and thus, reproducibility is embedded in the process. There's a clear and automatic
    path from data and code to the final report.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家们写了很多报告，描述数据分析的结果。使这些报告可重复是让同行审阅你的工作的关键，而且这是使用文献编程实现这一目标的非常好的方法。有了它，最终报告依赖于在创建时执行的代码，因此可重复性被嵌入到过程中。从数据和代码到最终报告有一个清晰且自动的路径。
- en: Literate programming for data analysis has become quite popular due to the development
    and communication efficiency it provides. In the following sections, we will show,
    how to do it using R, R Markdown, and knitr.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供了开发和通信效率，文献编程在数据分析中已经变得相当流行。在接下来的章节中，我们将展示如何使用R、R Markdown和knitr来实现它。
- en: The basic tools for an automation pipeline
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化流程的基本工具
- en: A pipeline is a process that starts with text, code, and raw data, and ends
    with the final document or presentation we want to show or distribute. Luckily,
    much of the hard work is automated for you within R, so there's not much you need
    to do other than install these tools and set up a compilation file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 流程是一个从文本、代码和原始数据开始，以我们想要展示或分发的最终文档或演示文稿结束的过程。幸运的是，在R中，许多艰苦的工作已经为你自动化了，所以你除了安装这些工具和设置编译文件之外，不需要做太多。
- en: '![](img/00054.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00054.gif)'
- en: Our pipeline should be general enough to accommodate various use cases without
    having to be modified substantially. If it is, we can master one set of tools
    and reuse them for different projects rather than learning a new tool set each
    time. On the input side, using text, code, and data, is general enough. On the
    output side, being able to generate HTML, PDF, LaTeX, and even Word documents
    seems to be general enough so we are good to go.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计流程应该足够通用，以便能够适应各种用例，而无需进行实质性的修改。如果是这样，我们就可以掌握一套工具，并可以在不同的项目中重复使用，而不是每次都学习一套新的工具集。在输入端，使用文本、代码和数据已经足够通用。在输出端，能够生成HTML、PDF、LaTeX甚至Word文档似乎也足够通用，因此我们可以继续前进。
- en: Markdown is a low-overhead mark-up language ([http://spec.commonmark.org/0.28/](http://spec.commonmark.org/0.28/)).
    Its main benefit for writers is that it allows us to focus on writing as opposed
    to formatting. It has simple and minimal yet intuitive formatting elements, and
    there are many programs that can translate Markdown into HTML and PDF files, among
    many others. R Markdown is an extension of Markdown to incorporate R code ([http://rmarkdown.rstudio.com/](http://rmarkdown.rstudio.com/)).
    Documents written in R Markdown have R code nested inside, which allows us to
    create dynamic presentations. They can not be evaluated using standard Markdown
    tools. Instead, R code is evaluated as part of the processing of the R Markdown
    before the traditional Markdown tools are called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种低开销的标记语言（[http://spec.commonmark.org/0.28/](http://spec.commonmark.org/0.28/))。对于作者来说，它的主要好处是它允许我们专注于写作而不是格式化。它具有简单、最小化但直观的格式化元素，并且有许多程序可以将Markdown转换为HTML和PDF文件等。R
    Markdown是Markdown的扩展，用于结合R代码（[http://rmarkdown.rstudio.com/](http://rmarkdown.rstudio.com/))。在R
    Markdown中编写的文档包含嵌套的R代码，这使得我们可以创建动态演示。它们不能使用标准的Markdown工具进行评估。相反，R代码在调用传统的Markdown工具之前作为R
    Markdown处理的一部分进行评估。
- en: One of the first literate programming systems in R is **Sweave**, which is used
    for creating dynamic reports and reproducible research using **LaTeX** ([https://www.latex-project.org/](https://www.latex-project.org/)).
    Sweave enables the embedding of R code within LaTeX documents to generate a PDF
    file that includes text, analysis, graphics, code, and the computation results.
    knitr (with first letter lowercase) is an R package that adds many new capabilities
    to Sweave ([https://yihui.name/knitr/](https://yihui.name/knitr/)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: R中第一个文学编程系统之一是**Sweave**，它用于使用**LaTeX**（[https://www.latex-project.org/](https://www.latex-project.org/)）创建动态报告和可重复的研究。Sweave允许在LaTeX文档中嵌入R代码，以生成包含文本、分析、图形、代码和计算结果的PDF文件。knitr（首字母小写）是一个R包，它为Sweave添加了许多新功能（[https://yihui.name/knitr/](https://yihui.name/knitr/))）。
- en: R Markdown can be converted to standard markdown using the knitr package in
    R, which inserts R results into a Markdown document. Markdown can subsequently
    be converted to HTML using Pandoc (a very powerful document translator, [https://pandoc.org/](https://pandoc.org/)).
    The use of R Markdown to create reproducible reports has quickly become a core
    tool for many scientists.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: R Markdown可以使用R中的knitr包转换为标准Markdown，该包将R结果插入到Markdown文档中。Markdown随后可以使用Pandoc（一个非常强大的文档转换器，[https://pandoc.org/](https://pandoc.org/))转换为HTML。使用R
    Markdown创建可重复的报告已经迅速成为许多科学家的核心工具。
- en: We won't go into details of how Sweave, LaTeX, or Pandoc transform files among
    different formats, since you won't have to operate them directly. We will focus
    on using R Markdown and knitr. However, we still need to make sure that we have
    all these tools installed in our system before we continue. Sweave is shipped
    within any R distribution. R Markdown and knitr can be installed within R. Pandoc
    and LaTeX should be installed directly into your computer. Specific instructions
    for Windows, macOS, and Linux can be found in [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨Sweave、LaTeX或Pandoc如何在不同格式之间转换文件，因为您不需要直接操作它们。我们将专注于使用R Markdown和knitr。然而，在我们继续之前，我们仍然需要确保我们已经在系统中安装了所有这些工具。Sweave包含在任何R发行版中。R
    Markdown和knitr可以在R中安装。Pandoc和LaTeX应直接安装到您的计算机上。有关Windows、macOS和Linux的具体说明，请参阅[附录](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730)，“所需软件包”。
- en: Finally, you should note that these are not the only tools available to produce
    automated content. As literate programming for R has become a topic of high interest,
    naturally, many tools have been, and continue to be, developed for it. Even though
    this chapter focuses on R Markdown and knitr, there are other tools such as **R
    Studio's Presenter** (**RPres**) and **Slidify**. We have not shown this tools
    in this book because they are either more restricted in their application or more
    complex in their usage. We believe that the R Markdown-knitr combination strikes
    a very good balance between power and ease of use, and it's our combination of
    choice. However, we encourage the reader to research other tools and find the
    best fit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该注意，这些并不是制作自动化内容的唯一工具。随着R的文献编程成为热点话题，自然地，许多工具已经开发出来，并且仍在继续开发。尽管本章重点介绍R
    Markdown和knitr，但还有其他工具，如**R Studio的演示者**（**RPres**）和**Slidify**。我们没有在本书中展示这些工具，因为它们要么在应用上更加受限，要么在用法上更加复杂。我们相信，R
    Markdown-knitr组合在功能性和易用性之间取得了非常好的平衡，这是我们首选的组合。然而，我们鼓励读者研究其他工具，找到最适合的工具。
- en: A gentle introduction to Markdown
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Markdown的温和介绍
- en: Markdown has various syntax versions that are supported by different systems
    and platforms. The one we show here is a general one that is useful throughout
    many systems, including R Markdown.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown有各种语法版本，这些版本由不同的系统和平台支持。我们在这里展示的是一种通用的版本，它在许多系统中都很有用，包括R Markdown。
- en: What we show in the following examples are the basic elements to structure content
    using Markdown. The actual aesthetics depend on what styles are being applied
    to your files. The examples shown as follows don't have any aesthetics applied
    to them. We will show you how to adjust them for our presentation later in the
    chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下示例中展示的是使用Markdown结构化内容的基本元素。实际的美观取决于应用于您的文件的风格。以下示例没有应用任何美学。我们将在本章后面向您展示如何调整它们以适应我们的演示。
- en: Text
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本
- en: If you want simple text, you can simply write as you normally would. If you
    want to format the text, you can use pairs of asterisks (`*`) or underscores (`_`).
    The following table shows how to use pairs of asterisks. Underscores work the
    same way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用简单的文本，您可以像平时一样写。如果您想格式化文本，可以使用一对星号（`*`）或下划线（`_`）。以下表格显示了如何使用一对星号。下划线的作用相同。
- en: 'If we use the following input:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We get the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下输出：
- en: Text with *italic* text inside.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 包含*斜体*文本的文本。
- en: Text with **bold** text inside.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 包含**粗体**文本的文本。
- en: Text with ***bold and italic text***.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包含***粗体和斜体文本***的文本。
- en: Headers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题
- en: If you want, you can have the equivalent to sections (first-level headers),
    subsections (second-level headers), sub-subsections (third-level headers), and
    so on. The organizational structures are marked using a number sign, repeated
    as many times as the depth you want to produce in the document. A string like
    `# Header` would produce a first-level header, while `### Header` would create
    a third-level header.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想，您可以有相当于部分（一级标题）、子部分（二级标题）、次子部分（三级标题）等等。组织结构使用数字符号标记，重复次数与您希望在文档中产生的深度相同。例如，`#
    标题`会产生一个一级标题，而`### 标题`会创建一个三级标题。
- en: 'If we use the following input:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We get the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到以下输出：
- en: Header Level  1
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题级别 1
- en: Header Level  2
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题级别 2
- en: Header Level  3
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题级别 3
- en: Header Level  4
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题级别 4
- en: Lists
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists can be ordered, unordered, and can be marked as tasks. These cover most
    cases you'll need, and they are very simple to use. For ordered lists, you can
    use hyphens (-) or asterisks (*), and you can nest them to create nested lists.
    For ordered lists, you can use numbers and letters. Finally, to create task lists,
    you simply need to put a pair of brackets at the beginning of an item ([]). If
    the brackets contain an X, then it means that the task has been completed. If
    the brackets have a space in between them, then the item is still pending.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以是有序的、无序的，也可以标记为任务。这些涵盖了您可能需要的绝大多数情况，并且它们的使用非常简单。对于有序列表，您可以使用连字符（-）或星号（*），并且您可以嵌套它们以创建嵌套列表。对于有序列表，您可以使用数字和字母。最后，要创建任务列表，您只需在项目开头放置一对括号（[]）。如果括号中包含一个X，则表示该任务已完成。如果括号之间有空格，则表示该项目仍在待办。
- en: 'If we use the following input:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Output
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出
- en: This is an ordered item
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个有序列表项
- en: This is an unordered item
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个无序列表项
- en: This is another unordered item
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是另一个无序列表项
- en: This is another ordered item
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个另一个有序列表项
- en: '[ ] This is a pending task'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ ] 这是一个待办任务'
- en: '[X] This is a completed task'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[X] 这是一个完成的任务'
- en: '[ ] This is another incomplete task'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ ] 这是另一个未完成的任务'
- en: Which contains one ordered item
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中有一个有序列表项
- en: And one unordered item
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个无序列表项
- en: Tables
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: Tables are one of the most cumbersome structures to create when using Markdown.
    Having said that, it's still not hard to create them. If you align them, everything
    looks normal. However, most of the time, people don't align them, and they seem
    a bit odd if you're not used to the syntax. By non-aligned tables, we mean that
    there are no padding spaces after items so that vertical lines align. The table
    shown as follows is an aligned table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Markdown时，表格是最繁琐的结构之一来创建。话虽如此，创建它们仍然不难。如果你对齐它们，一切看起来都很正常。然而，大多数时候，人们没有对齐它们，如果你不熟悉语法，它们看起来会有些奇怪。我们所说的非对齐表格是指项目后面没有填充空间，这样垂直线才能对齐。下面显示的表格是一个对齐表格。
- en: 'If we use the following input:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We get the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '| **First column** | **Second column** | **Third column** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **第一列** | **第二列** | **第三列** |'
- en: '| Item one | Item two | Item three |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 第一项 | 第二项 | 第三项 |'
- en: '| Item four | Item five | Item six |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 第四项 | 第五项 | 第六项 |'
- en: '| Item seven | Item eight | Item nine |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 第七项 | 第八项 | 第九项 |'
- en: Links
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接
- en: To provide links, you can simply write the link directly. If you want to name
    links so that only the name shows but not the URL, like the ones you see in web
    pages, you can use brackets containing the name followed immediately by parenthesis
    containing the actual link , in the format "[Name](URL)".
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供链接，你可以直接写出链接。如果你想给链接命名，以便只显示名称而不显示URL，就像你在网页上看到的那样，你可以使用包含名称的括号后立即跟包含实际链接的括号，格式为"[名称](URL)"。
- en: 'If we use the following input:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[The R Project for Statistical Computing](https://www.r-project.org/)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[The R Project for Statistical Computing](https://www.r-project.org/)'
- en: '[Packt Publishing](https://www.packtpub.com/)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[Packt Publishing](https://www.packtpub.com/)'
- en: Images
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片
- en: Images have a similar structure to links, but they are preceded by an exclamation
    mark (!). The name for the image (what is contained inside the brackets) is only
    shown if the actual image was not (for example, the file was not found in the
    specified route). The URL is replaced by the path to the image you want to show.
    By default, an image's size will be as large as possible. Under the assumption
    that the images are within a directory named images in the same directory as the
    Markdown file is, the following example works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的结构与链接类似，但它们前面有一个感叹号（!）。图片的名称（括号内的内容）仅在实际图片未显示时（例如，文件未在指定的路径中找到）才会显示。URL会被替换成你想显示的图片的路径。默认情况下，图片的大小将是尽可能大。假设图片位于与Markdown文件相同的目录下的名为images的目录中，以下示例是有效的。
- en: 'If we use the following input:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/00055.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: Quotes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用
- en: Quotes are very useful when trying to emphasize points to the readers. They
    are also very easy to create. All you have to do is prepend a greater-than sign
    (>) followed by a space at the beginning of a line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 引用非常有助于强调读者想要强调的点。它们也非常容易创建。你只需要在行首添加一个大于号（>）后跟一个空格。
- en: 'If we use the following input:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: Look deep into nature, and then you will understand everything better.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究自然，然后你就会更好地理解一切。
- en: '- Albert Einstein'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '- 阿尔伯特·爱因斯坦'
- en: Code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: Code can be embedded within text using single backticks (`` ` ``) surrounding
    it, or can be used in independent blocks by using triple backticks ([PRE7] [PRE8]
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以通过在它周围使用单反引号（`` ` ``）来嵌入到文本中，或者可以通过使用三重反引号（[PRE7] [PRE8]）在独立块中使用。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: add_two_numbers <- function(x, y) {
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: add_two_numbers <- function(x, y) {
- en: return(x + y)
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return(x + y)
- en: '}'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: $$\Theta = \begin{pmatrix} \alpha & \beta \\ \gamma & \delta \end{pmatrix}$$
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: $$\Theta = \begin{pmatrix} \alpha & \beta \\ \gamma & \delta \end{pmatrix}$$
- en: '[PRE12]` [PRE13]`), knitr knows that it''s an R code block which will be identified
    with the `chunk-label` label. The chunk label is not a requirement, and if you
    do not specify one, one will be automatically created for you, but they are useful
    when trying to remember the purpose of a code block and to reference images (more
    on this later).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]` [PRE13]`), knitr知道这是一个R代码块，它将被`chunk-label`标签识别。代码块标签不是必需的，如果你没有指定一个，系统会自动为你创建一个，但它们在尝试记住代码块的目的和引用图像时很有用（关于这一点稍后还会详细介绍）。'
- en: Finally, you should note that whatever code you write inside a standard Markdown
    code block is not executed in any way, so it can be full of errors and nothing
    will happen. However, when using R Markdown code chunks, the code within an R
    block is actually evaluated when compiling the document, and if it contains errors,
    the document or presentation will not compile successfully until you fix them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该注意，无论你在标准的Markdown代码块中编写什么代码，都不会以任何方式执行，所以它可能充满错误，但什么也不会发生。然而，当使用R Markdown代码块时，R块中的代码实际上在编译文档时会被评估，如果它包含错误，文档或演示文稿将无法成功编译，直到你修复它们。
- en: 'If we use the following input:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE14]{r optional-label}'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]{r optional-label}'
- en: 1 + 2
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tables
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格
- en: In informal reports, you may just print out a matrix or data frame rather than
    creating a formal table. If you need to, there are multiple ways to make tables
    with R Markdown that may look a bit nicer. We show how to use `kable` from the
    `knitr` package, as it's the simplest one. If you need more control, you may look
    at the `xtable` package, which gives you complete control. You need to be sure
    to use `results = "asis"` in the code chunk.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在非正式报告中，你可能只需打印出矩阵或数据框，而不是创建正式的表格。如果你需要，有几种方法可以使用R Markdown制作表格，可能看起来更美观。我们展示了如何使用`knitr`包中的`kable`，因为它是最简单的一个。如果你需要更多控制，你可以查看`xtable`包，它给你完全的控制。你需要在代码块中确保使用`results
    = "asis"`。
- en: 'If we use the following input:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE17]{r r-markdown-label, results = "asis"}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]{r r-markdown-label, results = "asis"}'
- en: library(knitr)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 加载knitr库
- en: x <- rnorm(100)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: x <- rnorm(100)
- en: y <- 2 * x + rnorm(100)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: y <- 2 * x + rnorm(100)
- en: coeficients <- summary(lm(y ~ x))$coef
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: coeficients <- summary(lm(y ~ x))$coef
- en: kable(coeficients, digits = 2)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以两位小数显示系数(kable(coeficients, digits = 2))
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We get the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '|  | **Estimate** | **Std. error** | **t value** | **Pr(>&#124;t&#124;)** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  | **估计值** | **标准误差** | **t值** | **Pr(>|t|)** |'
- en: '| (Intercept) | 0.02 | 0.10 | 0.21 | 0.83 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| (截距) | 0.02 | 0.10 | 0.21 | 0.83 |'
- en: '| `x` | 2.09 | 0.09 | 22.98 | 0.00 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 2.09 | 0.09 | 22.98 | 0.00 |'
- en: Graphs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表
- en: Creating graphs with R Markdown is as easy as creating the within R. Actually,
    you don't need to do anything extra; knitr is smart enough to do it automatically.
    If you need to, specify the width and height for your image using the corresponding
    chunk options shown in the next section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R Markdown创建图表与在R中创建图表一样简单。实际上，你不需要做任何额外的事情；knitr足够智能，可以自动完成。如果你需要，可以使用下一节中显示的相应代码块选项指定图像的宽度和高度。
- en: 'If we use the following input:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用以下输入：
- en: '[PRE19]{r basic-r-graph}'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]{r basic-r-graph}'
- en: attach(mtcars)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加数据集(mtcars)
- en: plot(wt, mpg)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制散点图(wt, mpg)
- en: abline(lm(mpg ~ wt))
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加线性拟合线(abline(lm(mpg ~ wt)))
- en: title("Regression of MPG on Weight")
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标题("MPG对重量的回归")
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We get the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/00057.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: Chunk options
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码块选项
- en: 'When working with chunks we have a lot of flexibility, and this flexibility
    can be seen by the many options we may adjust. Here, we will only mention the
    most common ones. To avoid including the code as output, use `echo = FALSE`. To
    avoid showing the results, use `include = FALSE`. To avoid evaluating the code
    block, use `eval = FALSE`. To avoid showing warnings, use `warning = FALSE`. To
    set the figure width and height, use `fig.height = 10` and `fig.width = 10` with
    the actual numbers you want (units are inches by default). All of these can be
    used in the code chunk header shown as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理代码块时，我们有很大的灵活性，这种灵活性可以通过我们可以调整的许多选项来体现。在这里，我们只提到最常见的几个。为了避免将代码作为输出包含，使用`echo
    = FALSE`。为了避免显示结果，使用`include = FALSE`。为了避免评估代码块，使用`eval = FALSE`。为了避免显示警告，使用`warning
    = FALSE`。要设置图形的宽度和高度，使用`fig.height = 10`和`fig.width = 10`，使用你想要的实际数字（默认单位是英寸）。所有这些都可以在代码块标题中使用，如下所示：
- en: '[PRE21]{r some-label, include = TRUE, eval = FALSE}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]{r some-label, include = TRUE, eval = FALSE}'
- en: 1 + 2
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Global chunk options
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局代码块选项
- en: 'You may use global chunk options rather than repeated local chunk options.
    Whenever you need to, you can override a global chunk option by specifying a different
    local chunk option. Using the following code would make every code chunk have
    the `echo = TRUE` and `eval = FALSE` options enabled, unless otherwise specified
    at specific blocks:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用全局代码块选项而不是重复的局部代码块选项。无论何时你需要，你都可以通过指定不同的局部代码块选项来覆盖全局代码块选项。使用以下代码将使每个代码块都启用`echo
    = TRUE`和`eval = FALSE`选项，除非在特定块中指定了其他选项：
- en: '[PRE23]{r global-options}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]{r global-options}'
- en: knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Caching
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: As we mentioned earlier, knitr is not so useful if you are writing a very long
    document or one involving complex computations. However, you may avoid some of
    these problems by using caches. The basic issue is that if you have a long document
    or one involving lengthy computations, then every time you want to *refresh* your
    document, you need to recompile it, meaning that you need to rerun all the computations.
    This may not be a problem if your document is efficient or small. However, it
    can be inefficient to sit there and wait for every computation to run every single
    time. Chunk caching is one way to avoid those lengthy computations. By setting
    the `cache = TRUE` chunk option, knitr runs the chunk once and stores the output
    in your working directory. When you *reknit* the document, instead of running
    the code in that particular chunk, knitr will reload the stored output. If the
    code in the chunk changes at all, knitr will detect it and will rerun the code,
    storing the updated results.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，如果您正在编写一个非常长的文档或涉及复杂计算的文档，knitr 就不那么有用。然而，通过使用缓存，您可以避免一些这些问题。基本问题是，如果您有一个很长的文档或涉及长时间计算的文档，那么每次您想要
    *刷新* 您的文档时，您都需要重新编译它，这意味着您需要重新运行所有的计算。如果您的文档效率高或体积小，这可能不是问题。然而，每次都等待每个计算运行可能效率低下。块缓存是避免这些长时间计算的一种方法。通过设置
    `cache = TRUE` 块选项，knitr 会运行一次块并将输出存储在您的当前工作目录中。当您 *重新编织* 文档时，knitr 将重新加载存储的输出。如果块中的代码有任何变化，knitr
    会检测到并重新运行代码，存储更新的结果。
- en: There are some caveats to caching. In particular, by default, dependencies between
    chunks are not checked. If the results of a cached chunk depend on a previous
    chunk that has been modified, those changes will not necessarily propagate down
    to later cached chunks. Also, chunks with significant side effects, such as those
    writing output to files or interacting with the external environment in any way,
    may not be cacheable. As long as you are careful with these, you should not have
    any issues.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有一些注意事项。特别是，默认情况下，不会检查块之间的依赖关系。如果一个缓存的块的结果依赖于已经被修改的先前块，那么这些更改不一定能传播到后续的缓存块。此外，具有显著副作用（如向文件写入输出或以任何方式与外部环境交互）的块可能无法缓存。只要您对这些方面小心谨慎，就不应该有任何问题。
- en: Producing the final output with knitr
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 knitr 生成最终输出
- en: 'Once you have a finished document or are ready to see its next iteration, you
    may compile within R Studio if you''re using it or by executing the code that
    triggers the compilation. We will show the latter since it''s more general and
    can be used by people who are not necessarily using R Studio. You simply need
    to execute the following lines, changing the filename `"document.Rmd"` with your
    own, and choosing the appropriate output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了文档或准备好查看其下一个迭代版本，如果您使用 R Studio，您可以在其中编译，或者通过执行触发编译的代码。我们将展示后者，因为它更通用，可以供不一定是使用
    R Studio 的人使用。您只需执行以下行，将文件名 `"document.Rmd"` 替换为您自己的，并选择适当的输出：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We suggest that you create a `compile.R` file that contains those line, and
    execute it every time you want to recompile your document. The following outputs
    are available:.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您创建一个名为 `compile.R` 的文件，其中包含这些行，并在每次您想要重新编译您的文档时执行它。以下输出是可用的：
- en: '| **String** | **Output** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | **输出** |'
- en: '| `html_document` | HTML document |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `html_document` | HTML 文档 |'
- en: '| `pdf_document` | PDF document |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `pdf_document` | PDF 文档 |'
- en: '| `word_document` | Word document |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `word_document` | Word 文档 |'
- en: '| `10slides_presentation` | HTML presentation, type 1 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `10slides_presentation` | HTML 演示文稿，类型 1 |'
- en: '| `slidy_presentation` | HTML presentation, type 2 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `slidy_presentation` | HTML 演示文稿，类型 2 |'
- en: '| `beamer_presentation` | Beamer (LaTex) PDF presentation |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `beamer_presentation` | Beamer (LaTeX) PDF 演示文稿 |'
- en: At this point, you should be able to create your own presentations. In the following
    sections, we will start building the presentation we want to actually develop
    for The Food Factory example.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够创建自己的演示文稿。在接下来的章节中，我们将开始构建为 The Food Factory 示例实际开发的演示文稿。
- en: Developing graphs and analysis as we normally would
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正常开发图表和分析
- en: As you saw in previous sections, you can work directly with our R Markdown file
    for the presentation (`presentation.Rmd`, in our case). However, you can be more
    productive if you first develop the content for the presentation as you would
    normally work with R, taking advantage of any configurations and tooling you may
    be accustomed to. When the code has been finalized, you translate only the necessary
    parts into the R Markdown file. Even though it seems counter intuitive because
    it would be more work, it's actually faster to work this way just because you're
    used to working with R more than with R Markdown, and you'll think about producing
    modular code that can be plugged into your presentation. This allows your to produce
    higher quality and reusable code. That's exactly what we will do here. We will
    start working with our usual `main.R` and `functions.R` files to develop what
    we need. Then, in a later section, we will migrate the code into our `presentation.Rmd`
    file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，你可以直接使用我们的R Markdown文件进行演示（在我们的案例中是`presentation.Rmd`）。然而，如果你首先像通常使用R一样开发演示内容，利用你可能习惯的任何配置和工具，你会更加高效。当代码最终确定后，你只需将必要的部分翻译成R
    Markdown文件。尽管这看起来似乎反直觉，因为这样会多做一些工作，但实际上这样做会更快，因为你比使用R Markdown更习惯于使用R，你将考虑产生模块化代码，这些代码可以插入到你的演示中。这允许你产生更高质量和可重用的代码。这正是我们将要做的。我们将从我们常用的`main.R`和`functions.R`文件开始，开发我们需要的内容。然后，在后面的章节中，我们将把代码迁移到我们的`presentation.Rmd`文件中。
- en: 'Since we want to present the analysis we have developed during the last couple
    of chapters and we shouldn''t rewrite code, we will bring some of it back from
    [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730), *Simulating
    Sales Data and Working with Databases*, as well as the data that we simulated
    for **The Food Factory**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要展示我们在过去几章中开发的分析，我们不应该重写代码，因此我们将从[第4章](part0091.html#2MP360-f494c932c729429fb734ce52cafce730)，*模拟销售数据和与数据库协同工作*中恢复一些内容，以及我们为**食品工厂**模拟的数据：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that using the `source()` function, as we did, loads into memory all of
    the functions we have in the functions file from [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales with Visualization*. This may or may not be what you actually
    need, and if you''re not careful, you may end up overwriting a function definition
    when doing so. In this particular case, it''s not a problem, so we''ll leave it
    as is. If it were a problem, we could always move the desired function into its
    own file and just `source` that file. The function we are interested in is the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用我们使用的`source()`函数，将[第5章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)，*通过可视化沟通销售*中的所有函数加载到内存中。这可能是你真正需要的，也可能不是，如果你不小心，你可能会在这样做时覆盖一个函数定义。在这种情况下，这不是一个问题，所以我们将保持原样。如果这是一个问题，我们总是可以将所需的函数移动到自己的文件中，然后只`source`那个文件。我们感兴趣的函数如下：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's suppose that a long time has passed since you first simulated the data.
    If you execute a function call like `filter_n_days_back(data, 7)`, you are not
    guaranteed to have the data for the previous week, and you'll most likely get
    an empty result due to `n_days_back <- Sys.Date() - n` containing  data of 7 days
    back from `today`, not the last date recorded in the data. That's a problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设自从你第一次模拟数据以来已经过去很长时间了。如果你执行一个像`filter_n_days_back(data, 7)`这样的函数调用，你不能保证有上周的数据，你很可能会因为`n_days_back
    <- Sys.Date() - n`包含从`今天`往回推7天的数据，而不是数据中最后记录的日期，而得到一个空的结果。这是一个问题。
- en: 'How to deal with situations like these can take you down a long debate with
    your peers. In general, we have two options: rewrite an independent function,
    or fix the code we already have. The right answer will depend on your specific
    circumstances and context, and both of them have their advantages and disadvantages.
    In general, when you write a new function, you''ll be certain that your code works
    and that you didn''t accidentally break someone else''s code, which depended on
    the previous version. The disadvantage is that you''ll have to maintain more code
    without gaining much functionality, and over time, this can be a huge pain. Remember
    the DRY principle we mentioned before? **Don''t Repeat Yourself** (**DRY**). If
    you decide to fix the current version of the code, you will possibly end up with
    a more robust code base that you can reuse for even more cases that you initially
    anticipated without increasing too much (sometimes decreasing) the code you need
    to maintain. However, there''s also the possibility that you break code that depended
    on the previous functionality, which can be very tricky to fix down the road when
    you realize that you did.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理这些情况可能会让你与同事进行长时间的辩论。一般来说，我们有两种选择：重写一个独立的函数，或者修复我们已有的代码。正确的答案将取决于你的具体情况和背景，两者都有其优点和缺点。一般来说，当你编写一个新函数时，你可以确信你的代码是正确的，你没有意外地破坏依赖于先前版本的别人的代码。缺点是，你将不得不维护更多的代码，而功能增长却不多，随着时间的推移，这可能会变得非常痛苦。还记得我们之前提到的DRY原则吗？**不要重复自己**（**DRY**）。如果你决定修复当前版本的代码，你可能会得到一个更健壮的代码库，你可以将其用于更多你最初没有预料到的情况，而无需增加太多（有时甚至减少）需要维护的代码。然而，也存在这样的可能性，即你破坏了依赖于先前功能的代码，当你意识到这一点时，修复起来可能会非常棘手。
- en: 'There are two basic fundamentals that will save you from strong headaches when
    dealing with these types of situations. We have been using one of them throughout
    this book: developing small and modular code. By small, we mean code that follows
    the *Single Responsibility* principle, mentioned in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*. When you do, something magical happens; you start plugging
    in code to other code and you can easily modify those plugins and create new ones
    as you need them without too much trouble. The other fundamental is having unit
    tests for your code. Simply put, unit tests are pieces of code designed to test
    that other code is performing as it should. Unit testing is out of the scope for
    this book, but it''s something you should definitely study if you don''t already
    know.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这些类型的情况时，有两个基本的原则可以帮你避免严重的头痛。我们在整本书中一直在使用其中一个：开发小型和模块化的代码。通过“小型”，我们指的是遵循[第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)中提到的**单一职责原则**的代码，*R语言简介*。当你这样做时，一些神奇的事情会发生；你开始将代码插入到其他代码中，你可以轻松地修改这些插件，并在需要时创建新的插件，而不会遇到太多麻烦。另一个基本的原则是给你的代码编写单元测试。简单来说，单元测试是设计用来测试其他代码是否按预期执行的代码片段。单元测试超出了本书的范围，但如果你还不了解，这绝对是一件事你应该去学习的。
- en: Going back to the code for this specific example, we choose to fix the code
    we already have. For us to make sure that we don't accidentally break other code
    that depends on this function, we follow the *Open-Closed* principle, which states
    that objects should be open for extensions and closed for modification ([https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf](https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf)).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 回到这个特定示例的代码，我们选择修复我们已有的代码。为了确保我们不会意外地破坏依赖于这个函数的其他代码，我们遵循**开闭原则**，该原则指出对象应该是可扩展的，但不可修改的（[https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf](https://www.cs.duke.edu/courses/fall07/cps108/papers/ocp.pdf)）。
- en: 'Basically, we will extend the interface without modifying it in such a way
    that the output is the same when using the same previous inputs, but the extended
    version will allow us to get the new outputs we want. It sounds more cumbersome
    than it really is. As you can see, we simply add a new optional parameter with
    a default value of `NULL`. Then, instead of computing `n_days_back` with the current
    date, we check to see if any value was sent; if it was, then we use that as the
    starting point; if not, we go back to the old behavior:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将扩展接口而不对其进行修改，这样使用相同的先前输入时输出结果保持不变，但扩展版本将使我们能够获得我们想要的新输出。这听起来比实际情况要复杂得多。正如你所看到的，我们只是添加了一个具有默认值`NULL`的新可选参数。然后，我们不再使用当前日期来计算`n_days_back`，而是检查是否发送了任何值；如果发送了，我们就使用那个值作为起点；如果没有，我们就回到旧的行为：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have this new version of the function, we can actually use it to
    take the last week in the data by computing the maximum date we have recorded
    in it, and using that as our `from_date` parameter. Also, note how easy it is
    to take not only the data for this week, but also from last week. However, for
    this to work, we need to make sure that the `max_date` object is a `Date` object
    in R, so that we can subtract 7 from it, and it actually means 7 days. If it's
    a string instead of a date, we would get an error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数的新版本，我们可以实际使用它来通过计算记录中的最大日期来获取数据中的上周，并使用该日期作为我们的`from_date`参数。此外，请注意，获取本周的数据以及上周的数据是多么容易。然而，为了使这可行，我们需要确保`max_date`对象是R中的`Date`对象，这样我们就可以从中减去7天，它实际上意味着7天。如果它是一个字符串而不是日期，我们会得到一个错误。
- en: 'As a side note, note that if were using data that is constantly being recorded,
    *this week* and *last week* would make perfect sense, but since we''re using data
    we simulated possibly a long time ago, *this week* and *last week* will vary depending
    on the dates in the actual data we''re using. That''s not a problem because we''re
    using the *maximum* date in the data, which will be adjusted accordingly for each
    situation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，请注意，如果我们使用的是不断记录的数据，那么“本周”和“上周”将非常有意义，但因为我们使用的是可能很久以前模拟的数据，所以“本周”和“上周”将取决于我们实际使用的数据中的日期。这不是问题，因为我们使用的是数据中的“最大”日期，它将相应地调整每个情况：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have the three datasets we need (`all_time`, `last_week`, and `this_week`),
    we can start developing the code that will use them to create the graphs we''re
    looking for. First, we need to get proportion tables for each variable of interest
    and for each dataset. As always, we want to wrap code that is not very explicit
    about its functionality into its own function so that we can assign a name to
    it and quickly know what it''s supposed to do. In this case, we create the `proportion_table()`
    function, which should be self-explanatory, and we apply it as mentioned. Note
    that we''re multiplying by `100`, because we want to show `20%` instead of `0.2`
    in our graphs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所需的三个数据集（`all_time`、`last_week`和`this_week`），我们可以开始开发使用这些数据集创建我们所需图表的代码。首先，我们需要为每个感兴趣变量和每个数据集获取比例表。像往常一样，我们希望将功能不明确的代码封装到自己的函数中，以便我们可以给它命名并快速了解它的用途。在这种情况下，我们创建了`proportion_table()`函数，它应该是自解释的，并且我们按照说明应用它。请注意，我们乘以`100`，因为我们想在图表中显示`20%`而不是`0.2`：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point, each of these objects should contain a table with the percentage
    of each category within the variable of interest. Those ending with `_all` contain
    the percentages for all the data recorded. Similarly, those ending with `_last`
    and `_this` contain the percentages for last week and this week, respectively.
    The number of decimal points will depend on the actual data and your configuration.
    In all cases, the numbers should add up to 100:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些对象中的每一个都应该包含一个表格，显示感兴趣变量中每个类别的百分比。以`_all`结尾的包含所有记录数据的百分比。同样，以`_last`和`_this`结尾的包含上周和本周的百分比。小数点的数量将取决于实际数据和你的配置。在所有情况下，数字的总和应该是100：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The careful reader should have noticed that `quantity_all` contains one more
    category than `quantity_last` and `quantity_this`. That''s because in the last
    two weeks in the data, there were no sales for nine items. This means that when
    we try to compare the count change in each of these categories, we will have a
    problem due to the extra category in `quantity_all`. We will deal with it by keeping
    only categories that are shared among any table pair we''re using. The `equal_length_data()` function
    receives two of these tables as `data_1` and `data_2`, then, it computes the minimum
    length (`ml`) among them and uses it to get elements up to that point in both
    `data_1` and `data_2`. Since both of them are tables at this point, we want the
    numeric array of its values, not the table object, that''s why we apply the `as.numeric()`.
    If we don''t do so, `ggplot2` will complain about not knowing how to deal with
    objects of type `table`. We don''t lose the category names by applying the `as.numeric()`
    function to the tables because we''re taking those separately in the `names` element
    of the returned list. Finally, we want to know if any categories were deleted,
    and we can know that by checking if the length of any of the data tables contains
    less categories than the `ml` number indicates. If that''s the case, `deleted`
    will be `TRUE` and will be sent, and it will be `FALSE` otherwise:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者应该已经注意到`quantity_all`包含的类别比`quantity_last`和`quantity_this`多一个。这是因为在过去两周的数据中，有九个商品没有销售。这意味着当我们试图比较这些类别中每个类别的计数变化时，由于`quantity_all`中额外的类别，我们将会遇到问题。我们将通过只保留任何我们使用的表对中共享的类别来处理这个问题。`equal_length_data()`函数接收这些表中的两个作为`data_1`和`data_2`，然后，它计算它们之间的最小长度（`ml`），并使用它来获取`data_1`和`data_2`中到那个点为止的元素。由于此时它们都是表格，我们想要的是其值的数值数组，而不是表格对象，这就是为什么我们应用了`as.numeric()`。如果我们不这样做，`ggplot2`将会抱怨不知道如何处理类型为`table`的对象。通过将`as.numeric()`函数应用于表格，我们没有丢失类别名称，因为我们是在返回列表的`names`元素中单独取那些名称。最后，我们想知道是否删除了任何类别，我们可以通过检查任何数据表的长度的类别数是否少于`ml`数字所指示的数量来知道这一点。如果是这样，`deleted`将会是`TRUE`并且会被发送，否则将是`FALSE`：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We now have access to data with equal length, with the corresponding category
    names, and with a Boolean value indicating whether any categories were deleted.
    We can use this object as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够访问具有相等长度的数据，相应的类别名称，以及一个布尔值，指示是否删除了任何类别。我们可以如下使用这个对象：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we will focus on preparing the data for our graphs. As we will be using
    the `ggplot2` package, we know we need to create a dataframe. This dataframe should
    contain category names in `Category`, the absolute and percent differences among
    matching categories from the two tables in the `Difference` and `Percent`, respectively,
    the `Sign` and `Color` depending on whether the absolute difference is positive
    or negative, and the *before* and *after* data in `Before` and `After`, respectively.
    Note that the order in which the `parts` were computed is important for the absolute
    and percent differences, which in turn impact the color and sign. We must be careful
    of sending the latest data as `data_2` so that we get an interpretation like *compared
    to last week, this week we had X more*. Otherwise, the interpretation would be
    inverted:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于为我们的图表准备数据。由于我们将使用`ggplot2`包，我们知道我们需要创建一个数据框。这个数据框应该包含在`Category`中的类别名称，两个表匹配类别之间的绝对和百分比差异分别在`Difference`和`Percent`中，以及根据绝对差异是正还是负的`Sign`和`Color`，以及分别在`Before`和`After`中的`before`和`after`数据。请注意，`parts`的计算顺序对于绝对和百分比差异很重要，这反过来又影响颜色和符号。我们必须小心地将最新数据作为`data_2`发送，这样我们就能得到像“与上周相比，本周我们多了X”这样的解释。否则，解释将会相反：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will define two colors using hexadecimal notation so that we can call them
    by name instead of copying the hexadecimal string every time. Later, if we want
    to change the colors, we can change them in a single place instead of replacing
    them everywhere we used them:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用十六进制表示法定义两种颜色，这样我们就可以通过名称来调用它们，而不是每次都复制十六进制字符串。稍后，如果我们想更改颜色，我们可以在一个地方更改它们，而不是在它们被使用的地方到处替换：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you read [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales with Visualizations*, the `difference_bars()` function should
    be clear. As you can see, we are computing the `parts` and `data` objects using
    the functions shown earlier, and then we use the `ggplot2` package to develop
    the graph. Note that we only add a subtitle containing the indication that some
    categories have been deleted if the `deleted` Boolean from `parts` is `TRUE`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了[第5章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)，*通过可视化进行销售沟通*，`difference_bars()`函数应该很清晰。正如你所见，我们正在使用前面显示的函数来计算`parts`和`data`对象，然后我们使用`ggplot2`包来开发图表。请注意，如果`parts`中的`deleted`布尔值为`TRUE`，我们只添加一个包含指示某些类别已被删除的副标题：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can create some useful graphs, as follows. Keep in mind that the values
    in the *y* axis do not indicate a percentage growth, but a change in percentage
    points. This can be immediately understood by looking at the code, but it is not
    clear when looking at the graph. In reality, we would have to include some explanation
    for this in a real presentation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一些有用的图表，如下所示。请记住，*y*轴上的值并不表示百分比增长，而是百分比点的变化。这可以通过查看代码立即理解，但在查看图表时并不明显。实际上，我们可能需要在实际演示中包含一些解释：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resulting graphs are shown as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图表如下所示：
- en: '![](img/00058.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/00058.jpeg)'
- en: The second type of graph we want to develop is a bit more complex. We will create
    vertical lines at 1 and 2 along the *x* axis, place text labels indicating where
    the percentage for each category is in the `before` and `after` data sets, and
    the change percentage in the middle. First, we create the `data` object as we
    did before. Next, we create the labels we will use for each category. The ones
    one the left are the `before_labels`, the ones in the center are the `percent_labels`,
    and the ones in the right are the `after_labels`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要开发的第二种图表类型稍微复杂一些。我们将在*x*轴上的1和2处创建垂直线，放置文本标签以指示每个类别的百分比在`before`和`after`数据集中在哪里，以及中间的变化百分比。首先，我们创建与之前相同的`data`对象。接下来，我们创建我们将用于每个类别的标签。左侧的是`before_labels`，中间的是`percent_labels`，右侧的是`after_labels`。
- en: The `percent_y` contains the values for the y axis where the `percent_labels`
    will be placed. The *x* axis value is fixed at 1.5 so that it's between the two
    vertical lines. To compute the `percent_y` value, we want to get the minimum between
    the before and after values for each category and add half the difference between
    them. This will make sure that the value is at the middle of the line that will
    join both values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`percent_y`包含y轴上`percent_labels`将被放置的值。*x*轴的值固定为1.5，以便它在两条垂直线之间。为了计算`percent_y`值，我们想要得到每个类别的前后值之间的最小值，并加上它们之间差异的一半。这将确保该值位于连接这两个值的线的中点。'
- en: We are now ready to start using the `ggplot2` package. First, we define the
    data as we normally would and add a segment joining the *before* and *after* values
    for each category by starting at the `$(1, Before)$` tuple and ending at the `$(2,
    After)$` tuple, where each tuple has the form `$(x, y)$`. We will use the `Sign`
    variable as the *fill* color for the bars, and avoid showing a legend since we
    will show some labels ourselves. We will use the *scale_color_manual()* function
    to specify the colors that should be used for each line depending on whether the
    absolute difference was positive or negative.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备开始使用`ggplot2`包。首先，我们像平常一样定义数据，并为每个类别添加一个连接*before*和*after*值的段落，从`$(1,
    Before)$`元组开始，到`$(2, After)$`元组结束，其中每个元组的形式为`$(x, y)$`。我们将使用`Sign`变量作为条形的*填充*颜色，并避免显示图例，因为我们自己将显示一些标签。我们将使用`*scale_color_manual()*`函数来指定根据绝对差异是正还是负而应使用的颜色。
- en: Next come the vertical lines, which are created with the `geom_vline()` function.
    As mentioned before, they will be placed at values 1 and 2 along the *x* axis.
    We will make the line dashed to improve aesthetics and use a smaller size than
    the segment lines we created before.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是垂直线，它们是通过`geom_vline()`函数创建的。如前所述，它们将放置在*x*轴上的1和2的位置。我们将使线条为虚线以改善美观，并使用比我们之前创建的段落线条更小的尺寸。
- en: Next,  we will place the labels using the `geom_text()` function. We start creating
    the label for each of the vertical lines, which are created at 0.7 and 2.3 *x*
    axis values, and a slightly increased maximum of the *before* and *after* values.
    Then, we place the labels for the categories in the left, center, and right using
    the `geom_text_repel()` function. This function is not included in the `ggplot2`
    package, and it's actually an extension for it. It is designed to *repel* (hence
    the name) labels that overlap each other. To do so, the function moves labels
    away from the point's position and draws a line that indicates which label belongs
    to each point. You can find nice examples on its website ([https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html)).
    In our case, we remove said line with the *segment.color = NA* parameter and indicate
    that the direction for adjustment is only along the *y* axis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`geom_text()`函数放置标签。我们开始为每个垂直线创建标签，这些线位于0.7和2.3 *x*轴值，以及略微增加的*之前*和*之后*值的最大值。然后，我们使用`geom_text_repel()`函数在左侧、中心和右侧放置类别的标签。这个函数不包括在`ggplot2`包中，实际上它是它的一个扩展。它被设计用来*排斥*（因此得名）相互重叠的标签。为了做到这一点，函数将标签从点的位置移开，并绘制一条线来指示哪个标签属于每个点。你可以在它的网站上找到很好的例子（[https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html](https://cran.r-project.org/web/packages/ggrepel/vignettes/ggrepel.html)）。在我们的情况下，我们使用`segment.color
    = NA`参数移除这条线，并指示调整的方向仅沿*y*轴。
- en: In reality, it's very hard for someone to come up with all of this code on their
    first attempt, and our case was no different. We started with some small plots
    and continuously added the elements we were looking for through iterated experimentation.
    In particular, we realized that some labels were overlapping each other, which
    doesn't look great, and so we decided to use the `geom_text_repl()` package, which
    we did not previously know, but easily found online since many people have the
    same problem and luckily someone had developed a solution for it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，很难有人第一次就能想出所有这些代码，我们的情况也不例外。我们从一个小的图表开始，通过迭代实验不断添加我们需要的元素。特别是，我们意识到一些标签相互重叠，这看起来并不好，所以我们决定使用`geom_text_repl()`包，这是我们之前不知道的，但很容易在网上找到，因为很多人都有同样的问题，幸运的是有人为这个问题开发了解决方案。
- en: The `x_adjustment` parameter is a result of similar experimentation. We realized
    that different graph's labels were overlapping the vertical lines depending on
    the number of characters in the category names. To fix that, we decided to introduce
    a new parameter that adjusts the position along the x axis that can be experimented
    with until we find a good parameter for it. All this is to say that you should
    take advantage of R's rapid experimentation cycles to iteratively produce what
    you're looking for.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`x_adjustment`参数是类似实验的结果。我们意识到，不同图表的标签根据类别名称中的字符数不同，会重叠在垂直线上。为了解决这个问题，我们决定引入一个新的参数，它可以调整x轴上的位置，我们可以通过实验找到适合它的参数。所有这些都是在说，你应该利用R的快速实验周期，迭代地产生你想要的结果。'
- en: 'Finally, we remove any text from the x and y axes and limit their range of
    values because they are unnecessary to read the graph and provide a cleaner visualization.
    It may take a bit of experimentation for you to understand exactly what each part
    of the code is doing, which is totally fine, and you should definitely do so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从x轴和y轴上移除任何文本，并限制它们的值范围，因为它们对于读取图表和提供更清晰的视觉效果是不必要的。你可能需要一点实验来理解代码的每一部分到底在做什么，这是完全可以接受的，你绝对应该这样做：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](img/00059.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00059.jpeg)'
- en: 'Now, we can present some very useful and nice-looking graphs with the following
    code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码展示一些非常有用且看起来很棒的图表：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These graphs can be easily interpreted and don't seem to be as vulnerable to
    the *x* axis percentage units problem we mentioned for the previous graphs. You
    can easily see if a category increased or decreased its percentage among periods,
    and by how much percentage. Keep in mind that the plots for *all-time* also contain
    *this week* when interpreting them. In reality, this may or may not be correct
    for your specific use case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图表很容易解释，并且似乎不像我们之前提到的对于前一个图表的*x*轴百分比单位问题那样容易受到影响。你可以很容易地看出一个类别在各个时期中百分比是增加还是减少，以及增加了多少百分比。记住，在解释*all-time*的图表时，它们也包含了*本周*的数据。实际上，这对你特定的用例可能是正确也可能是错误的。
- en: Building our presentation with R Markdown
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用R Markdown构建我们的演示文稿
- en: 'In this section, we will develop our presentation''s R Markdown file. We create
    an empty file named `presentation.R` and put the following headers in. The quotation
    marks are not required unless you want to include a colon in the title. As shown
    in a previous section, using backticks (“ ’), we can execute R code. In this case,
    we put the current date automatically in the front page. Finally, we chose `ioslides_presentation`
    as an output format. Feel free to experiment with the other outputs shown previously:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发我们的演示文稿的 R Markdown 文件。我们创建一个名为 `presentation.R` 的空文件，并在其中放置以下标题。除非您想在标题中包含冒号，否则不需要引号。正如前一个章节所示，使用反引号（“
    ”），我们可以执行 R 代码。在这种情况下，我们将当前日期自动放在首页。最后，我们选择了 `ioslides_presentation` 作为输出格式。您可以自由尝试之前显示的其他输出格式：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following code sets up the default configuration for the *code chunks*
    in our presentation. We avoid showing code in the presentation with `echo = FALSE`
    and make each picture full width unless stated otherwise with `out.width = ''100%''`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码设置了演示文稿中 *代码块* 的默认配置。我们通过 `echo = FALSE` 来避免在演示文稿中显示代码，并使每张图片都全宽，除非有其他说明使用
    `out.width = '100%'`：
- en: '[PRE41]{r setup, include=FALSE}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE41]{r setup, include=FALSE}'
- en: knitr::opts_chunk$set(echo = FALSE, out.width = '100%')
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: knitr::opts_chunk$set(echo = FALSE, out.width = '100%')
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we need to bring all the resources we need for our presentation to work.
    Specifically, we need to load the functions we have developed along the last three
    chapters. Load the data `sales` and `client_messages` data and apply the same
    transformation we have seen in previous chapters to set up the data. Note that
    in this chapter, we referenced the sales data as `all_time` instead of `sales`,
    and to avoid changing our code so that we can still easily reference our development
    files, we simply copy the `sales` object into the `all_time` object. Be careful
    when doing this if you have tight memory restrictions in your system:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们演示文稿所需的所有资源整合起来。具体来说，我们需要加载我们在过去三章中开发的函数。加载 `sales` 和 `client_messages`
    数据，并应用我们在前几章中看到的相同转换来设置数据。请注意，在本章中，我们将销售数据引用为 `all_time` 而不是 `sales`，为了避免更改我们的代码，以便我们仍然可以轻松地引用我们的开发文件，我们只是简单地将
    `sales` 对象复制到 `all_time` 对象中。如果您系统内存限制较严格，请在此过程中小心操作：
- en: '[PRE43]{r load-functions-and-data, include=FALSE}'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE43]{r load-functions-and-data, include=FALSE}'
- en: source("../functions.R")
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: source("../functions.R")
- en: source("../../chapter-05/functions.R")
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: source("../../chapter-05/functions.R")
- en: source ("../../chapter-06/functions.R")
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: source ("../../chapter-06/functions.R")
- en: sales           <- readRDS("../../chapter-04/results/sales.rds")
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: sales           <- readRDS("../../chapter-04/results/sales.rds")
- en: client_messages <- readRDS("../../chapter-04/results/client_messages.rds")
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: client_messages <- readRDS("../../chapter-04/results/client_messages.rds")
- en: sales           <- add_profits(sales)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: sales           <- add_profits(sales)
- en: all_time  <- sales
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: all_time  <- sales
- en: max_date  <- max(all_time$DATE)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: max_date  <- max(all_time$DATE)
- en: this_week <- filter_n_days_back(all_time, 7, max_date)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: this_week <- filter_n_days_back(all_time, 7, max_date)
- en: last_week <- filter_n_days_back(all_time, 7, max_date - 7)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: last_week <- filter_n_days_back(all_time, 7, max_date - 7)
- en: quantity_all   <- proportions_table(all_time, "QUANTITY")
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: quantity_all   <- proportions_table(all_time, "QUANTITY")
- en: continent_all  <- proportions_table(all_time, "CONTINENT")
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: continent_all  <- proportions_table(all_time, "CONTINENT")
- en: protein_all    <- proportions_table(all_time, "PROTEIN_SOURCE")
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: protein_all    <- proportions_table(all_time, "PROTEIN_SOURCE")
- en: quantity_last  <- proportions_table(last_week, "QUANTITY")
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: quantity_last  <- proportions_table(last_week, "QUANTITY")
- en: continent_last <- proportions_table(last_week, "CONTINENT")
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: continent_last <- proportions_table(last_week, "CONTINENT")
- en: protein_last   <- proportions_table(last_week, "PROTEIN_SOURCE")
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: protein_last   <- proportions_table(last_week, "PROTEIN_SOURCE")
- en: quantity_this  <- proportions_table(this_week, "QUANTITY")
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: quantity_this  <- proportions_table(this_week, "QUANTITY")
- en: continent_this <- proportions_table(this_week, "CONTINENT")
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: continent_this <- proportions_table(this_week, "CONTINENT")
- en: protein_this   <- proportions_table(this_week, "PROTEIN_SOURCE")
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: protein_this   <- proportions_table(this_week, "PROTEIN_SOURCE")
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now that our resources have been set up, we can work on the code that will actually
    show our analysis in the presentation. We start with the slides that use the functions
    we developed previously in this chapter to show changes using bars and lines.
    Note that we are specifying different heights in each case for bar and line graphs.
    Also note that we're using a 50% width for line graphs. That's because we want
    them to appear vertically in the slide. A 50% width with a height of 10 achieves
    that distribution.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了资源，我们可以着手编写将在演示文稿中展示分析的代码。我们首先使用本章先前开发的函数来展示使用条形图和折线图的变化。请注意，我们在每种情况下都指定了条形图和折线图的不同高度。另外请注意，我们使用50%的宽度来绘制折线图。这是因为我们希望它们在幻灯片中垂直显示。50%的宽度和10的高度实现了这种分布。
- en: 'In reality, you may want to choose better titles for each slide, but we will
    keep them obvious for this example. Note that working this way, we avoid placing
    any logic code in our slides, and by simply reading the function titles, we know
    exactly what will be shown. This lets you easily move things around without breaking
    things up due to dependencies among pieces of code since we have abstracted that
    into separate files. If you fill your presentation files with R logic, you''ll
    quickly find it very confusing when you need to change them. It''s better to have
    that logic in an actual `.R` file, as we do with our `functions.R` file. Not to
    mention that it''s also much more reusable that way:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，你可能希望为每一张幻灯片选择更好的标题，但在这个例子中我们将保持标题的明显性。请注意，以这种方式工作，我们避免在幻灯片中放置任何逻辑代码，通过简单地阅读函数标题，我们就能确切知道将要展示什么。这让你可以轻松地移动内容，而不会因为代码片段之间的依赖关系而破坏结构，因为我们已经将它们抽象成单独的文件。如果你在演示文稿文件中填充了R逻辑，当你需要更改它们时，你会发现非常混乱。最好将这些逻辑放在实际的`.R`文件中，就像我们在`functions.R`文件中所做的那样。更不用说，这样也更容易重用：
- en: '[PRE45]{r quantity-bars, fig.height = 2.5}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE45]{r quantity-bars, fig.height = 2.5}'
- en: difference_bars_absolute(quantity_last, quantity_this, "This week", "Last week")
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(quantity_last, quantity_this, "This week", "Last week")
- en: difference_bars_absolute(quantity_all, quantity_this, "This week", "All-time")
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(quantity_all, quantity_this, "This week", "All-time")
- en: '[PRE46]{r quantity-lines, out.width = ''50%'', fig.height = 10}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]{r quantity-lines, out.width = ''50%'', fig.height = 10}'
- en: change_lines(quantity_last, quantity_this, "This week", "Last week", 0.2)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(quantity_last, quantity_this, "This week", "Last week", 0.2)
- en: change_lines(quantity_all, quantity_this, "This week", "All-time", 0.2)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(quantity_all, quantity_this, "This week", "All-time", 0.2)
- en: '[PRE47]{r continent-bars, fig.height = 2.5}'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE47]{r continent-bars, fig.height = 2.5}'
- en: difference_bars_absolute(continent_last, continent_this, "This week", "Last
    week")
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(continent_last, continent_this, "This week", "Last
    week")
- en: difference_bars_absolute(continent_all, continent_this, "This week", "All-time")
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(continent_all, continent_this, "This week", "All-time")
- en: '[PRE48]{r continent-lines, out.width = ''50%'', fig.height = 10}'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE48]{r continent-lines, out.width = ''50%'', fig.height = 10}'
- en: change_lines(continent_last, continent_this, "This week", "Last week", 0.3)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(continent_last, continent_this, "This week", "Last week", 0.3)
- en: change_lines(continent_all, continent_this, "This week", "All-time", 0.3)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(continent_all, continent_this, "This week", "All-time", 0.3)
- en: '[PRE49]{r protein-source-bars, fig.height = 2.5}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE49]{r protein-source-bars, fig.height = 2.5}'
- en: difference_bars_absolute(protein_last, protein_this, "This week", "Last week")
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(protein_last, protein_this, "This week", "Last week")
- en: difference_bars_absolute(protein_all, protein_this, "This week", "All-time")
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: difference_bars_absolute(protein_all, protein_this, "This week", "All-time")
- en: '[PRE50]{r protein-source-lines, out.width = ''50%'', fig.height = 10}'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE50]{r protein-source-lines, out.width = ''50%'', fig.height = 10}'
- en: change_lines(protein_last, protein_this, "This week", "Last week", 0.5)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(protein_last, protein_this, "This week", "Last week", 0.5)
- en: change_lines(protein_all, protein_this, "This week", "All-time", 0.5)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: change_lines(protein_all, protein_this, "This week", "All-time", 0.5)
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, we will add function calls to code we developed in previous chapters. As
    you can see, the process is exactly the same since we have already loaded those
    resources at this point in the `load-functions-and-data` code chunk shown earlier.
    All we have to do is actually call the functions that produce the graphs for us.
    If you can't remember what these functions do, we suggest to go back to their
    corresponding chapters to go over the details on how they were created.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向之前章节中开发的代码中添加函数调用。正如你所见，这个过程完全相同，因为我们已经在这个`load-functions-and-data`代码块中加载了这些资源。我们实际上只需要调用为我们生成图表的函数。如果你记不起这些函数的作用，我们建议回到它们对应的章节，回顾它们是如何创建的细节。
- en: 'As you can see, the last slide from this *code chunk* calls the `graph_client_messages_interactive()`
    function that produces the interactive map you could move around in [Chapter 5](part0110.html#38STS0-f494c932c729429fb734ce52cafce730),
    *Communicating Sales with Visualizations*. A great thing about creating presentations
    this way is that you can actually play around with the map within the presentation!
    Of course, this will only work if you''re using an output format that uses the
    web browser for visualization (it will not work with PDFs or Word documents, for
    example), but it can be a fantastic way to add powerful content to your presentations
    if you''re using a web browser to visualize them:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最后一张幻灯片中的*代码块*调用了`graph_client_messages_interactive()`函数，该函数生成了可以在[第5章](part0110.html#38STS0-f494c932c729429fb734ce52cafce730)“使用可视化进行销售沟通”中移动的交互式地图。以这种方式创建演示文稿的一个好处是，你实际上可以在演示文稿中玩弄地图！当然，这仅在你使用支持在浏览器中可视化的输出格式时才有效（例如，它不适用于PDF或Word文档），但如果你使用浏览器进行可视化，这可以是一个向演示文稿添加强大内容的绝佳方式：
- en: '[PRE52]{r sales-proft-ratio-by-continent-and-protein-source }'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE52]{r sales-proft-ratio-by-continent-and-protein-source }'
- en: graph_bars(sales, "CONTINENT", "PROFIT_RATIO", "PROTEIN_SOURCE")
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: graph_bars(sales, "CONTINENT", "PROFIT_RATIO", "PROTEIN_SOURCE")
- en: '[PRE53]{r price-vs-cost}'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE53]{r price-vs-cost}'
- en: graph_marginal_distributions(sales, "COST", "PRICE", "PROTEIN_SOURCE", "CONTINENT")
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: graph_marginal_distributions(sales, "COST", "PRICE", "PROTEIN_SOURCE", "CONTINENT")
- en: '[PRE54]{r price-vs-profit-ratio}'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]{r price-vs-profit-ratio}'
- en: graph_marginal_distributions(sales, "PRICE", "PROFIT_RATIO", "PROTEIN_SOURCE",
    "CONTINENT")
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: graph_marginal_distributions(sales, "PRICE", "PROFIT_RATIO", "PROTEIN_SOURCE",
    "CONTINENT")
- en: '[PRE55]{r date-vs-frequency-profit-and-profit-ratio, fig.height = 1.8}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE55]{r date-vs-frequency-profit-and-profit-ratio, fig.height = 1.8}'
- en: graph_last_n_days(sales, 30, color = "PROTEIN_SOURCE")
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: graph_last_n_days(sales, 30, color = "PROTEIN_SOURCE")
- en: graph_last_n_days(sales, 30, "PROFIT", "PROTEIN_SOURCE")
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: graph_last_n_days(sales, 30, "PROFIT", "PROTEIN_SOURCE")
- en: graph_last_n_days(sales, 30, "PROFIT_RATIO", "PROTEIN_SOURCE")
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: graph_last_n_days(sales, 30, "PROFIT_RATIO", "PROTEIN_SOURCE")
- en: '[PRE56]{r top-customers-preferences}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE56]{r top-customers-preferences}'
- en: subset <- filter_data(sales, 30, 5, "CLIENT_ID")
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: subset <- filter_data(sales, 30, 5, "CLIENT_ID")
- en: graph_radar(subset, "CLIENT_ID")
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: graph_radar(subset, "CLIENT_ID")
- en: '[PRE57]{r customers-dynamic-map}'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE57]{r customers-dynamic-map}'
- en: graph_client_messages_interactive(client_messages, sales)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: graph_client_messages_interactive(client_messages, sales)
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, we want to show the latest tweets using actual live Twitter data. Since
    The Food Factory company that we have alluded to during this example is fictitious,
    we can't really get data for it, but we will still search Twitter for *The Food
    Factory* phrase and show the top 5 results we get back. In reality, you can retrieve
    tweets that mention a specific account you're interested in, and be more creative
    with the querying process. We will keep it simple for this example.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望使用实际的实时Twitter数据来展示最新的推文。由于在本例中提到的The Food Factory公司是虚构的，我们无法真正获取其数据，但我们将仍然搜索Twitter中的*The
    Food Factory*短语，并展示我们得到的排名前5的结果。实际上，你可以检索提到你感兴趣特定账户的推文，并在查询过程中更加富有创意。为了本例的简单起见，我们将保持操作简单。
- en: 'The first thing we must do, as shown in [Chapter 6](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730),
    *Understanding Reviews with Text Analysis*, is to identify ourselves with Twitter''s
    API so that we can retrieve data. If you don''t remember how to do so, take a
    look at said chapter. Since we want to execute this piece of code but we don''t
    want to show it or its output, we simply apply the option `include = FALSE`. Note
    that we keep the slide title on top of the authentication code as a sign to ourselves
    that this code belongs to this slide''s logic:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事，如[第6章](part0129.html#3R0OI0-f494c932c729429fb734ce52cafce730)“通过文本分析理解评论”中所示，是使用Twitter的API来识别自己，以便我们可以检索数据。如果你不记得如何操作，请查看该章节。由于我们想要执行这段代码，但又不想展示它或其输出，我们简单地应用了`include
    = FALSE`选项。请注意，我们保持幻灯片标题在认证代码的顶部，作为我们自己的一个标记，表明此代码属于此幻灯片的逻辑：
- en: '[PRE59]{r twitter-setup, include = FALSE}'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE59]{r twitter-setup, include = FALSE}'
- en: consumer_key    <- "b9SGfRpz4b1rnHFtN2HtiQ9xl"
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: consumer_key    <- "b9SGfRpz4b1rnHFtN2HtiQ9xl"
- en: consumer_secret <- "YMifSUmCJ4dlgB8RVxKRNcTLQw7Y4IBwDwBRkdz2Va1vcQjOP0"
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: consumer_secret <- "YMifSUmCJ4dlgB8RVxKRNcTLQw7Y4IBwDwBRkdz2Va1vcQjOP0"
- en: access_token    <- "171370802-RTl4RBpMDaSFdVf5q9xrSWQKxtae4Wi3y76Ka4Lz"
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: access_token    <- "171370802-RTl4RBpMDaSFdVf5q9xrSWQKxtae4Wi3y76Ka4Lz"
- en: access_secret   <- "dHfbMtmpeA2QdOH5cYPXO5b4hF8Nj6LjxELfOMSwHoUB8"
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: access_secret   <- "dHfbMtmpeA2QdOH5cYPXO5b4hF8Nj6LjxELfOMSwHoUB8"
- en: setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we put in another *code chunk* that actually produces the output we want
    to show in the slide. We are getting data from Twitter using the `get_twitter_data()`
    we created in the previous chapter, and we pass it through the `format_tweets()`
    function we will show next:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们放入另一个实际生成我们想在幻灯片中展示的输出的 *代码块*。我们正在使用上一章中创建的 `get_twitter_data()` 从推特获取数据，并将其通过我们将要展示的
    `format_tweets()` 函数传递：
- en: '[PRE61]{r twitter-live-data, size = "footnotesize", comment = ""}'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE61]{r twitter-live-data, size = "footnotesize", comment = ""}'
- en: format_tweets(get_twitter_data("The Food Factory", 5))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: format_tweets(get_twitter_data("The Food Factory", 5))
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This `format_tweets()` function was necessary to print the data we are interested
    in showing in the slide. If you remember, the data we get from the `get_twitter_data()`
    function contains quite a bit of metadata around each tweet, which is very useful
    when doing analysis, but for this slide, we would rather show only the screen
    name for the person who tweeted, the tweet's timestamp, and the actual tweet.
    We also need to truncate the tweet's length to make sure that it looks fine in
    the presentation. Even though it's a small function, the code can be a bit complex
    if you haven't seen those functions before, so we will take it step by step.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `format_tweets()` 函数是必要的，以便打印我们在幻灯片中想要展示的数据。如果你记得，我们从 `get_twitter_data()`
    函数获取的数据包含每条推文周围的大量元数据，这在分析时非常有用，但在这个幻灯片中，我们更愿意只展示发推者的屏幕名、推文的日期和时间戳以及实际的推文内容。我们还需要截断推文的长度，以确保它在演示中看起来不错。即使这是一个小的函数，如果你之前没有见过这些函数，代码可能会有些复杂，所以我们将一步一步地进行。
- en: 'The `format_tweets()` function receives a single argument, which is the data
    we got back from the `get_twitter_data()` function, and we know that data structure
    contains the `created`, `text`, and `screenName` variables we''re interested in.
    Since this is vectorized code, we don''t have to use a for loop to print each
    tweet independently. We can simply use the arrays of values directly. If you don''t
    remember what vectorized code refers to, you can review it in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_tweets()` 函数接收一个单一参数，即我们从 `get_twitter_data()` 函数获取的数据，我们知道该数据结构包含我们感兴趣的
    `created`、`text` 和 `screenName` 变量。由于这是向量化的代码，我们不需要使用循环来独立打印每条推文。我们可以直接使用值数组。如果你不记得向量化代码是什么，你可以在[第1章](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730)，“R语言简介”中复习它：'
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first thing you may notice is that we're not using the `print()` function.
    We are using the `write()` function passing in the `stdout()` function call. This
    means that we will *write* an object into the standard output. You can think of
    this as a *dumb* `print()` function call, where R will not do any processing for
    us, and will simply show exactly what we tell it to. What this does is avoid printing
    the numbered lines we normally get when using the print function. Remember those
    `[1], [2], ...` at the beginning of the output in the previous code? This `write(...,
    stdout())` technique avoids them. You normally don't want that, but it's useful
    for aesthetics purposes in this particular case.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到我们没有使用 `print()` 函数。我们使用 `write()` 函数传递 `stdout()` 函数调用。这意味着我们将 *写入*
    一个对象到标准输出。你可以把它想象成一个 *简单的* `print()` 函数调用，其中 R 不会为我们做任何处理，而只是显示我们告诉它的内容。这样做可以避免使用
    `print` 函数时通常得到的编号行。记得之前代码输出开头的那 `[1], [2], ...` 吗？这个 `write(..., stdout())` 技巧避免了它们。你通常不希望这样，但在这个特定情况下，它对美观目的很有用。
- en: Next, we use the `paste()` function as we have been doing to put together everything
    we want to print. In this case, we start with screen names, followed by parenthesis
    enclosing the timestamp (contained in `data$created`), and followed by a combination
    that indicates a *new line*. The `\n` combination, when used inside the `write()`
    function, tells R to actually introduce a new line at that point, just as if you
    had pressed the *return* key (*Enter* key on your keyboard). Next, we pass the
    actual tweet (`data$text`) to the `substr()` function so that we can get characters
    1 through 65\. This is done, again, for aesthetic purposes since we don't want
    very long tweets to take more than one line. That output is sent to the `enc2utf8()`
    function, which sets the string's encoding to UTF-8, and this output is passed
    through the `iconv()` function with a `sub = ""` parameter, which will delete
    any non-convertible characters. Finally, we put a `"(...) \n"` string to show
    that the tweet was probably truncated, and another *new line* symbol.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `paste()` 函数，就像我们之前做的那样，将我们想要打印的所有内容组合在一起。在这种情况下，我们以屏幕名称开始，然后是包含时间戳（位于
    `data$created` 中）的括号，然后是一个表示 *换行* 的组合。当 `\n` 组合在 `write()` 函数中使用时，它会告诉 R 在该点实际引入一个新行，就像你按下了
    *回车* 键（键盘上的 *Enter* 键）。接下来，我们将实际的推文（`data$text`）传递给 `substr()` 函数，以便我们可以获取第 1
    到 65 个字符。这样做是为了美观，因为我们不希望很长的推文占用超过一行。该输出被发送到 `enc2utf8()` 函数，该函数将字符串的编码设置为 UTF-8，然后通过带有
    `sub = ""` 参数的 `iconv()` 函数传递此输出，这将删除任何不可转换的字符。最后，我们添加一个 `"(...) \n"` 字符串来显示推文可能被截断，并添加另一个
    *换行* 符号。
- en: When using the `iconv()` function, what happens is that it will try to convert
    characters one by one, and whenever it can't convert a character, it will replace
    it with the `sub` string we send. We need to do this because we may get characters
    from languages like Chinese or Arabic whose output, would contain a Unicode representation
    which would not make sense to people who are not familiar with these types of
    encoding issues. We're trying to produce a user-friendly presentation.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `iconv()` 函数时，它会逐个尝试转换字符，每当它无法转换一个字符时，就会用我们发送的 `sub` 字符串来替换它。我们需要这样做，因为我们可能从像中文或阿拉伯语这样的语言中获取字符，其输出将包含一个对不熟悉这些类型编码问题的人没有意义的
    Unicode 表示。我们试图产生一个用户友好的展示。
- en: If you recompile this presentation, the messages you retrieve from Twitter will
    be different from the ones shown here because they will be retrieved at that moment.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新编译这个演示文稿，你从 Twitter 获取的消息将不同于这里显示的，因为它们将在那一刻被检索。
- en: Now, you can compile your presentation with any of the methods mentioned earlier,
    and if everything goes fine, you should see a `presentation.html` file in your
    directory. If you open that file in your web browser, you should see slides similar
    to the ones shown as follows. You may also open directly the live presentation
    in the repository for this book. Remember to play around with the interactive
    map!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用前面提到的方法中的任何一种来编译你的演示文稿，如果一切顺利，你应该会在你的目录中看到一个 `presentation.html` 文件。如果你在网页浏览器中打开该文件，你应该会看到类似于以下所示的幻灯片。你也可以直接打开这个书的存储库中的实时演示文稿。记住要尝试与交互式地图互动！
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the benefits of automating tasks as well as content
    creation. We showed how to integrate automation pipelines for content creation,
    how to write R Markdown documents, which provide dynamic content, and how to use
    these documents to produce documents and presentations that look nice and are
    efficient. We showed how to integrate various R resources to create content that
    can be updated automatically.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了自动化任务以及内容创建的好处。我们展示了如何集成内容创建的自动化管道，如何编写提供动态内容的 R Markdown 文档，以及如何使用这些文档制作看起来不错且高效的文档和演示文稿。我们展示了如何集成各种
    R 资源来创建可以自动更新的内容。
- en: In case you want to develop documents that are more technical or lengthy, the
    `bookdown` package may be a good option for you. Its purpose is to make the creation
    of lengthy documents, such as books, easier using R Markdown. As a matter of fact,
    this book was written using `bookdown`, and the process was a really nice one.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要开发更技术性或篇幅较长的文档，`bookdown` 包可能是一个不错的选择。它的目的是通过 R Markdown 使创建长篇文档，如书籍，变得更加容易。实际上，这本书就是使用
    `bookdown` 编写的，整个过程非常愉快。
- en: In the next chapter, we will start a new example focused on evaluating cryptocurrency
    trades. We will start by building an object-oriented system that simulates a trading
    platform and evaluates traders' performances automatically. After that, we will
    show you how to make our algorithms run faster by using parallelization and delegation,
    and finally, in the last chapter, we will show you how to create web pages that
    contain interactive dashboards, all from within R.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新的示例，专注于评估加密货币交易。我们将首先构建一个面向对象的系统，模拟交易平台并自动评估交易者的表现。之后，我们将向您展示如何通过并行化和委托来使我们的算法运行得更快，最后，在最后一章中，我们将向您展示如何从R中创建包含交互式仪表板的网页。
