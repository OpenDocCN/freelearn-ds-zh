- en: Chapter 4. Linear Algebra – Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear algebra is one of the essential building blocks of computational mathematics.
    The objects of linear algebra are vectors and matrices. The package NumPy includes
    all the necessary tools to manipulate those objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first task is to build matrices and vectors, or to alter existing ones by
    slicing. The other main task is the `dot` operation, which embodies most of the
    linear algebra operations (scalar product, matrix-vector product, and matrix-matrix
    product). Finally, various methods are available to solve linear problems.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the array type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the impatient, here is how to use arrays in a nutshell. Be aware though
    that the behavior of arrays may be surprising at first, so we encourage you to
    read on after this introductory section.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors and matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating vectors is as simple as using the function `array`  to convert a list
    to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The object `v`  is now a vector that behaves much like a vector in linear algebra.
    We have already emphasized the differences with the list object in Python (refer
    to section *Arrays* in [Chapter 3](ch03.html "Chapter 3. Container Types"), *Containers
    Type)*. Here are some illustrations of the basic linear algebra operations on
    vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all basic arithmetic operations are performed elementwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Some functions act elementwise on arrays as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This subject will be covered in the section *Functions Acting on Arrays.*
  prefs: []
  type: TYPE_NORMAL
- en: 'A matrix is created in a similar way to a vector, but from a list of lists
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Vectors are no column - and no row matrices**'
  prefs: []
  type: TYPE_NORMAL
- en: The *n* vector, an *n* × 1, and a 1 × n matrix are three different objects even
    if they contain the same data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a row matrix containing the same data as the vector `v = array([1.,
    2., 1.])`, we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding column matrix is obtained by the method `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexing and slicing are similar to that of a list. The main difference is
    that there may be several indexes or slices when the array is a matrix. The subject
    will be covered in depth in section *Array indexing;* here, we just give some
    illustrating examples of indexing and slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Linear algebra operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The essential operator that performs most of the usual operations of linear
    algebra is the Python function `dot`. It is used for matrix-vector multiplications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be used to compute a scalar product between two vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, it is used to compute matrix-matrix products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Solving a linear system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If *A* is a matrix and *b* is a vector, you can solve the linear equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a linear system](img/linsystem.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `solve` method, which has this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we want to solve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a linear system](img/b05511_06_1200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the solution for the preceding equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The command `allclose` is used here to compare two vectors. If they are close
    enough to each other, this command returns `True`. Optionally a tolerance value
    can be set. For more methods related to linear equations systems, refer to section
    *Linear algebra methods in SciPy*.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical preliminaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how arrays work in NumPy, it is useful to understand
    the mathematical parallel between accessing tensor (matrix and vector) elements
    by indexes and evaluating mathematical functions by providing arguments. We also
    cover in this section the generalization of the dot product as a reduction operator.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays as functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays may be considered from several different points of view. We believe that
    the most fruitful one in order to understand arrays is that of functions of several
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, selecting a component of a given vector in *ℝ*^(*n*) may just
    be considered a function from the set of ℕ[*n*] to ℝ, where we define the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arrays as functions](img/somenumbers.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here the set ℕ[n] has *n* elements. The Python function `range` generates ℕ[*n*].
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an element of a given matrix, on the other hand, is a function of
    two parameters, taking its value in ℝ. Picking a particular element of an *m*
    × *n* matrix may thus be considered a function from ℕ[*m*] × ℕ[*n*] to ℝ.
  prefs: []
  type: TYPE_NORMAL
- en: Operations are elementwise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy arrays are essentially treated as mathematical functions. This is in
    particular true for operations. Consider two functions, *f* and *g*, defined on
    the same domain and taking real values. The product *f g* of those two functions
    is defined as the pointwise product, that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operations are elementwise](img/pointwiseproduct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this construction is possible for any operation between two functions.
    For an arbitrary operation defined on two scalars, which we denote here by ![Operations
    are elementwise](img/star.jpg), we could define ![Operations are elementwise](img/fstarg.jpg)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operations are elementwise](img/starop.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This innocuous remark allows us to understand NumPy''s stance on operations;
    all operations are elementwise in arrays. For instance, the product between two
    matrices *m* and *n* is defined, as with functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Operations are elementwise](img/indexfunction.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shape and number of dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a clear distinction between a:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar**: Function with no arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector**: Function with one argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matrix**: Function with two arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher order tensor**: Function with more than two arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In what follows, the number of dimensions is the number of arguments of a function.
    The shape corresponds essentially to the domain of definition of a function.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a vector of size *n* is a function from the set ℕ[*n*] to ℝ. As
    a result, its domain of definition is ℕ[*n*]. Its shape is defined as the singleton
    (*n,*). Similarly, a matrix of size *m* × *n* is a function defined on ℕ[*m*]
    × ℕ[*m*]. The corresponding shape is simply the pair (*m*, *n*). The shape of
    an array is obtained by the `numpy.shape` function, and the number of dimensions
    by the `numpy.ndim` function.
  prefs: []
  type: TYPE_NORMAL
- en: The dot operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Treating arrays as functions, although very powerful, completely neglects the
    linear algebra structures we are familiar with, that is, matrix-vector and matrix-matrix
    operations. Fortunately, these linear algebra operations may all be written in
    a similar unified form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector-vector operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The matrix-vector operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The matrix-matrix operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The vector-matrix operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The essential mathematical concept is that of reduction. For a matrix-vector
    operation, the reduction is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In general, a reduction operation defined between two tensors *T* and *U* of
    respective number of dimensions *m* and *n* may be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/B05511_04_07-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, the shapes of the tensors must be compatible for that operation to
    make any sense. This requirement is familiar for matrix-matrix multiplication.
    The multiplication *M N* of matrices *M* and *N* only makes sense if the number
    of columns of *M* equals the number of rows of *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another consequence of the reduction operation is that it produces a new tensor
    with *m + n - 2* dimensions. In the following table, we gather the output of the
    reduction operation for the familiar cases involving matrices and vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The dot operations](img/Table-4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 4.1: Output of the reduction operation for the familiar cases involving
    matrices and vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, all reduction operations are performed using the `dot` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As in mathematical textbooks, also in modern Python (Version 3.5 and higher),
    the dot product is sometimes preferred to be written in its operator form, `dot(M,
    v)`, or by using the more handy infix notation, `M @ v`. From now on we stick
    to the operator form; you can modify the examples if the other form is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Elementwise versus matrix multiplication**'
  prefs: []
  type: TYPE_NORMAL
- en: The multiplication operator `*` is always elementwise. It has nothing to do
    with the dot operation. Even if *A* is a matrix and *v* is a vector, *A*v* is
    still a legal operation.
  prefs: []
  type: TYPE_NORMAL
- en: The matrix-vector multiplication is performed using the `dot` function. Refer
    to section *Broadcasting* of [Chapter 5](ch05.html "Chapter 5. Advanced Array
    Concepts"), *Advanced Array Concepts*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The array type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects used to manipulate vectors, matrices, and more general tensors in
    NumPy are called arrays. In this section, we examine their essential properties,
    how to create them, and how to access their information.
  prefs: []
  type: TYPE_NORMAL
- en: Array properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays are essentially characterized by three properties, which is given in
    the following table (*Table 4.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `shape` | It describes how the data should be interpreted, as a vector, a
    matrix or as a higher order tensor, and it gives the corresponding dimension.
    It is accessed with the `shape` attribute. |'
  prefs: []
  type: TYPE_TB
- en: '| `dtype` | It gives the type of the underlying data (float, complex, integer,
    and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `strides` | This attribute specifies in which order the data should be read.
    For instance, a matrix could be stored in memory contiguously column by column
    (the FORTRAN convention), or row by row (the C convention). The attribute is a
    tuple with the numbers of bytes that have to be skipped in memory to reach the
    next row and the number of bytes to be skipped to reach the next column. The `strides`
    attribute even allows for a more flexible interpretation of the data in memory,
    which is what makes array views possible. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.2 : Properties of Arrays'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Its elements have type `'int64'`; that is, they use 64 bits or 8 bytes in memory.
    The complete array is stored in memory row-wise. The distance from `A[0, 0]` to
    the first element in the next row `A[1,0]` is thus 24 bytes (three matrix elements)
    in memory. Correspondingly, the distance in memory between `A[0,0]` and `A[0,1]`
    is 8 bytes (one matrix element). These values are stored in the attribute `strides`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays from lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general syntax to create an array is the function `array` . The syntax
    to create a real vector would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a complex vector with the same data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When no type is specified, the type is guessed. The `array` function chooses
    the type that allows storing of all the specified values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Silent type conversion** NumPy silently casts floats into integers, which
    might give unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same often unexpected array type casting happens from complex to float.
  prefs: []
  type: TYPE_NORMAL
- en: '**Array and Python parentheses**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have noticed in section *Program and program flow* in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*, Python allows a line break when
    some opening brace or parenthesis is not closed. This allows a convenient syntax
    for array creation, which makes it more pleasing to the human eye:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Accessing array entries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array entries are accessed by indexes. In contrast to vector coefficients two
    indexes are needed to access matrix coefficients. These are given in one pair
    of brackets. This distinguishes the array syntax from a list of lists. There,
    two pairs of brackets are needed to access elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Basic array slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Slices are similar to those of lists except that there might now be in more
    than one dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M[i,:]` is a vector filled by the row *i* of *M.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[:,j]` is a vector filled by the column *i* of *M.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[2:4,:]` is a slice of `2:4` on the rows only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M[2:4,1:4]` is a slice on rows and columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of matrix slicing is given in the following figure (*Figure 4.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic array slicing](img/array_slice.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The result of matrix slicing'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Omitting a dimension**'
  prefs: []
  type: TYPE_NORMAL
- en: If you omit an index or a slice, NumPy assumes you are taking rows only. `M[3]`
    is a vector that is a view on the third row of *M *and `M[1:3]` is a matrix that
    is a view on the second and third rows of *M.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the elements of a slice affects the entire array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'General slicing rules are given in the following table (*Table 4.3)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic array slicing](img/Table-4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 4.3: General Slicing Rules'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of slicing operations for an array `M` of shape *(4, 4)* are given
    in the following table (*Table 4.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic array slicing](img/Table-4.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 4.4: Result of slicing operation for an array M of shape (4,4)'
  prefs: []
  type: TYPE_NORMAL
- en: Altering an array using slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may alter an array using slices or by direct access. The following changes
    only one element in a 5 × 3 matrix `M`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But we may change one full row of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also replace a full submatrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a distinction between a column matrix and a vector. The following
    assignment with a column matrix returns no error `M[1:4, 2:3] = array([[1.],[0.],[-1.0]])`
    while the assignment with a vector returns a `Value Error` `M[1:4, 2:3] = array([1.,
    0., -1.0]) #  error`'
  prefs: []
  type: TYPE_NORMAL
- en: The general slicing rules are shown in *Table 4.2*. The matrices and vectors
    in the preceding examples must have the right size to fit into matrix *M*. You
    may also make use of the broadcasting rules (for more information, refer to section
    *Broadcasting* of [Chapter 5](ch05.html "Chapter 5. Advanced Array Concepts"),
    *Advanced Array Concepts*) to determine the allowed size of the replacement arrays.
    If the replacement array does not have the right shape, a `ValueError` exception
    will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Functions to construct arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The usual way to set up an array is via a list. But there are also a couple
    of convenient methods for generating special arrays, which are given in the following
    table (*Table 4.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Shape** | **Generates** |'
  prefs: []
  type: TYPE_TB
- en: '|  `zeros((n,m))` | *(n,m)* | Matrix filled with zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `ones((n,m)) ` | *(n,m)* | Matrix filled with ones |'
  prefs: []
  type: TYPE_TB
- en: '| `diag(v,k) ` | *(n,n)* | (Sub-, super-) diagonal matrix from a vector *v*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `random.rand(n,m) ` | *(n,m)* | Matrix filled with uniformly distributed
    random numbers in (0,1) |'
  prefs: []
  type: TYPE_TB
- en: '|  `arange(n)` | *(n,)* | First *n* integers |'
  prefs: []
  type: TYPE_TB
- en: '| `linspace(a,b,n) ` | *(n,)* | Vector with *n* equispaced points between *a*
    and *b* |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.5: Commands to create arrays'
  prefs: []
  type: TYPE_NORMAL
- en: These commands may take additional arguments. In particular, the commands `zeros`,
    `ones`, and `arange` take `dtype` as an optional argument. The default type is
    `float`, except for `arange`. There are also methods such as `zeros_like` and
    `ones_like`, which are slight variants of the preceding ones. For instance, the
    `zeros_like(A)` method is equivalent to `zeros(shape(A))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `identity` function, which constructs an identity matrix of a given
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is identical to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Accessing and changing the shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of dimensions is what distinguishes a vector from a matrix. The **shape**
    is what distinguishes vectors of different sizes, or matrices of different sizes.
    In this section, we examine how to obtain and change the shape of an array.
  prefs: []
  type: TYPE_NORMAL
- en: The shape function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The shape of a matrix is the tuple of its dimensions. The shape of an n × m
    matrix is the tuple `(n, m)`. It can be obtained by the `shape` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For a vector, the shape is a singleton containing the length of that vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is to use the array attribute `shape`, which gives  the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the advantage of using  `shape` as a function is that this function
    may be used on scalars and lists as well. This may come in handy when code is
    supposed to work with both scalars and arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Number of dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The number of dimensions of an array is obtained with the function `numpy.ndim` 
    or using the array attribute `ndarray.ndim` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the number of dimensions, given by the function `ndim`, of a tensor
    `T` (a vector, matrix, or higher order tensor) is always equal to the length of
    its shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Reshape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method `reshape` gives a new view of the array, with a new shape, without
    copying the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Reshape does not copy**'
  prefs: []
  type: TYPE_NORMAL
- en: Reshape does not create a new array. It rather gives a new view on the existing
    array. In the preceding example, changing one element of `M` would automatically
    result in a change in the corresponding element in `v`. When this behavior is
    not acceptable, you need to copy the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various effects of the `reshape` method on an array defined by `arange(6)` are
    given in the following figure :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reshape](img/array_reshape.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The various effects of the reshape method on an array defined by
    arange(6)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If one tries to reshape an array with a shape that does not multiply to the
    original shape, an error is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is convenient to specify only one shape parameter and let Python
    determine the other in such a way that it multiplies to the original shape. This
    is done by setting the free shape parameter `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Transpose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A special form of reshaping is transposing. It just switches the two shape
    elements of the matrix. The transpose of a matrix *A* is a matrix *B* such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transpose](img/transpose.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Which is resolved in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Transpose does not copy**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transposition is very similar to reshaping. In particular, it does not copy
    the data either and just returns a view on the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Transposing a vector makes no sense since vectors are tensors of one dimension,
    that is, functions of one variable. NumPy will, however, comply and return exactly
    the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'What you have in mind when you want to transpose a vector is probably to create
    a row or column matrix. This is done using `reshape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Stacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The universal method to build matrices from a couple of (matching) submatrices
    is `concatenate`. Its syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This command stacks the submatrices vertically (on top of each other) when
    `axis=0` is specified. With the `axis=1` argument, they are stacked horizontally,
    and this generalizes according to arrays with more dimensions. This function is
    called by several convenient functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hstack`: Used to stack matrices horizontally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vstack`: Used to stack matrices vertically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columnstack`: Used to stack vectors in columns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stacking vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One may stack vectors row-wise or column-wise using `vstack` and `column_stack`,
    as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stacking vectors](img/array_stack.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`hstack` would produce the concatenation of v1 and v2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider the symplectic permutation as an example for vector stacking:
    We have a vector of size 2*n*. We want to perform a symplectic transformation
    of a vector with an even number of components, that is, exchange the first half
    with the second half of the vector with sign change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stacking vectors](img/symplectic.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This operation is resolved in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Functions acting on arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different types of functions acting on arrays. Some act elementwise,
    and they return an array of the same shape. Those are called universal functions.
    Other array functions return an array of a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: Universal functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Universal functions are functions that act elementwise on arrays. They thus
    have an output array that has the same shape as the input array. These functions
    allow us to compute the result of a scalar function on a whole array at once.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in universal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A typical example is the `cos` function (the one provided by NumPy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that universal functions work on arrays in a componentwise manner. This
    is also true for operators, such as multiplication or exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Create universal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your function will automatically be universal if you use only universal functions
    in it. If, however, your function uses functions that are not universal, you might
    get scalar results, or even an error, when trying to apply them on an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected behaviour would be that the `heaviside` function applied to a
    vector `[*a*, *b*]` would return `[heaviside(*a*), heaviside(*b*)]`. Alas, this
    does not work because the function always returns a scalar, no matter the size
    of the input argument. Besides, using the function with an array input would raise
    an exception. The NumPy function `vectorize` allows us to quickly solve this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical application of this method is its use when plotting a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following graph shows the heaviside function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Create universal functions](img/heaviside.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `vectorize` function does not improve performance*.* It provides only a
    convenient way to quickly transform a function, so that it operates elementwise
    on list and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of functions acting on arrays that do not act componentwise.
    Examples of such functions are `max`, `min`, and `sum`. These functions may operate
    on the whole matrix, row-wise, or column-wise. When no argument is provided, they
    act on the whole matrix. Suppose `A` is the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array functions](img/array_methods_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sum` function acting on that matrix returns a scalar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The command has an optional parameter, `axis` . It allows us to choose along which
    axis to perform the operation. For instance, if the axis is *0*, it means that
    the sum should be computed along the first axis. The sum along axis *0* of an
    array of shape (*m*, *n*) will be a vector of length *n*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we compute the sum of `A` along the axis 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This amounts to computing the sum on the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array functions](img/array_methods_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array functions](img/array_methods_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now suppose we compute the sum along the axis *1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This amounts to computing the sum on the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array functions](img/array_methods_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The result is a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Array functions](img/array_methods_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear algebra methods in SciPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SciPy offers a large range of methods from numerical linear algebra in its `scipy.linalg`
    module. Many of these methods are Python wrapping programs from `LAPACK`, a collection
    of well-approved FORTRAN subroutines used to solve linear equation systems and
    eigenvalue problems. Linear algebra methods are the core of any method in scientific
    computing, and the fact that SciPy uses wrappers instead of pure Python code makes
    these central methods extremely fast. We present in detail here how two linear
    algebra problems are solved with SciPy to give you a flavour of this module.
  prefs: []
  type: TYPE_NORMAL
- en: Solving several linear equation systems with LU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let *A* be an *n × n* matrix and *b[1]*, *b[2]*, ..., *b[k]* be a sequence
    of *n*-vectors. We consider the problem to find *n* vectors *x[i]* such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving several linear equation systems with LU](img/severallinsystems.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We assume that the vectors *b[i]* are not known simultaneously. In particular,
    it is quite a common situation that the *i*^(th) problem has to be solved before
    *b[i+1]* becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'LU factorization is a way to organize the classical Gauss elimination method
    in such a way that the computation is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A factorization step of the matrix *A* to get matrices in triangular form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relatively cheap backward and forward elimination step that works on the *b[i]*'s
    and benefits from the more time-consuming factorization step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method also uses the fact that if *P* is a permutation matrix such that
    *PA* is the original matrix with its rows permuted.
  prefs: []
  type: TYPE_NORMAL
- en: The two systems
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving several linear equation systems with LU](img/permutation.jpg)'
  prefs: []
  type: TYPE_IMG
- en: have the same solution.
  prefs: []
  type: TYPE_NORMAL
- en: '*LU* factorization finds a permutation matrix *P*, a lower triangular matrix
    *L,* and an upper triangular matrix *U* such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving several linear equation systems with LU](img/permutation2.jpg) .'
  prefs: []
  type: TYPE_NORMAL
- en: Such a factorization always exists. Furthermore, *L* can be determined in such
    a way that *L[ii] = 1*. Thus, the essential data from *L* that has to be stored
    is *L[ij]* with *i > j*. Consequently, *L* and *U* can be stored together in an
    *n* × *n* array, while the information about the permutation matrix *P* just requires
    an *n* integer vector – the pivot vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SciPy, there are two methods to compute the *LU* factorization. The standard
    one is `scipy.linalg.lu`, which returns the three matrices `L`, `U`, and `P`.
    The other method is`lu_factor.` That is the method we describe here, because it
    will be conveniently used later in combination with `lu_solve`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `A` matrix is factorized and an array with the information about
    `L` and `U` is returned, together with the pivot vector. With this information,
    the system can be solved by performing row interchanges of the vectors *b[i]*
    according to the information stored in the pivot vector, backward substitution
    using *U,* and finally forward substitution using *L*. This is bundled in Python,
    in the `lu_solve` method. The following code snippet shows how the system *Ax[i]
    = b[i]* is solved once the *LU* factorization is performed and its results stored
    in the tuple `(LU, piv)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Solving a least square problem with SVD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A linear equation system *Ax = b*, with *A* being an *m* × *n* matrix and *m*
    > *n*, is called an overdetermined linear system. In general it has no classical
    solution and one seeks a vector *x** ![Solving a least square problem with SVD](img/in.jpg) 
    ℝ^(*n*) with the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a least square problem with SVD](img/B05511_04_08.900.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, ![Solving a least square problem with SVD](img/norm.jpg) denotes the Euclidean
    vector norm ![Solving a least square problem with SVD](img/B05511_04_09.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: This problem is called a least square problem. A stable method to solve it is
    based on factorizing *A = U*Σ*V^T*, with *U* being a *m* × *m* orthogonal matrix,
    *V* a *n* × *n* orthogonal matrix, and Σ = (σ[*ij*]) an *m* × *n* matrix with
    the property σ[*ij*] = 0 for all *i* ≠*j*. This factorization is called a **singular
    value decomposition** (**SVD**).
  prefs: []
  type: TYPE_NORMAL
- en: We write,
  prefs: []
  type: TYPE_NORMAL
- en: '![Solving a least square problem with SVD](img/B05511_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with a diagonal *n* × *n* matrix Σ[*1*]. If we assume that *A* has full rank,
    then Σ[*1*]  is invertible and it can be shown that, ![Solving a least square
    problem with SVD](img/B05511_04_11.jpg). If we split *U* = [*U[1] U[2]*] with
    *U[1]* being an *m* × *n* submatrix, then the preceding equation can be simplified
    to ![Solving a least square problem with SVD](img/B05511_04_12.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'SciPy provides a function called `svd`, which we use to solve this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The keyword `full_matrices` says that only the portion *U[1]* of *U* needs to
    be computed. As one often uses `svd` to compute only singular values, σ[*ii*],
    we have to explicitly demand the computation of *U* and *V* by using the keyword
    `compute_uv`. The SciPy function `scipy.linalg.lstsq` solves the least square
    problem similarly by using a singular value decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: More methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples so far, you met a couple of methods for computational tasks
    in linear algebra, for example, `solve`. Most common methods are available after
    the command `import scipy.linalg as sl` is executed. We refer to their documentation
    for further reference. Some linear algebra functions of the `scipy.linalg` module
    are given in the following table (*Table 4.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods** | **Description (matrix methods)** |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.det` | Determinant of a matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.eig` | Eigenvalues and eigenvectors of a matrix |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.inv` | Matrix inverse |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.pinv` | Matrix pseudoinverse |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.norm` | Matrix or vector norm |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.svd` | Singular value decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.lu` | LU decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.qr` | QR decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.cholesky` | Cholesky decomposition |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.solve` | Solution of a general or symmetric linear system: *Ax = b* |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.solve.banded` | The same for banded matrices |'
  prefs: []
  type: TYPE_TB
- en: '| `sl.lstsq` | Least squares solution |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.6: Linear algebra functions of the **scipy.linalg** module'
  prefs: []
  type: TYPE_NORMAL
- en: Execute `import scipy.linalg as sl` first.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with the most important objects in linear algebra
    – vectors and matrices. For this, we learned how to define arrays and we met important
    array methods. A smaller section demonstrated how to use modules from `scipy.linalg`
    to solve central tasks in linear algebra.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ex. 1** → Consider a 4 × 3 matrix *M*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_04_13..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Construct this matrix in Python using the function `array` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct the same matrix using the function `arange`  followed by a suitable
    reshape.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the result of the expression `M[2,:]` ? What is the result of the similar
    expression `M[2:]`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 2** → Given a vector *x*, construct in Python the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *x[i]* are the components of the vector *x* (numbered from zero). Given
    a vector *y*, solve in Python the linear equation system *Va = y*. Let the components
    of *a* be denoted by *a[i], i = 0, ..., 5*. Write a function `poly`, which has
    *a* and *z* as input and which computes the polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_04_15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Plot this polynomial and depict in the same plot the points (*x[i]*, *y[i]*)
    as small stars. Try your code with the vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x = (0.0, 0.5, 1.o, 1.5, 2.0, 2.5)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*y = (-2.0, 0.5, -2.0, 1.0, -0.5, 1.0)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ex. 3** → The matrix *V* in *Ex. 2* is called a Vandermonde matrix. It can
    be set up in Python directly by the command `vander`. Evaluating a polynomial
    defined by a coefficient vector can be done with the Python command `polyval`.
    Repeat *Ex. 2* by using these commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 4** → Let *u* be a one dimensional array. Construct another array ξ with
    values ξ*[i] = (u[1] + u[i+1] + u[i+2])/3*. In statistics, this array is called
    the moving average of *u*. In approximation theory, it plays the role as the Greville
    abscissae of cubic splines. Try to avoid the use of for loops in your script.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 5** →'
  prefs: []
  type: TYPE_NORMAL
- en: Construct from the matrix *V* given in *Ex. 2* a matrix *A* by deleting *V*'s
    first column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Form the matrix *B = (A^T A)^(-1) A^T*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute *c = B y* with *y* from *Ex. 2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *c* and `polyval` to plot the polynomial defined by *c*. Plot in the same
    picture again the points (*x[i]*, *y[i]*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Ex. 6** → *Ex. 5* describes the least square method. Repeat that exercise
    but use SciPy''s `scipy.linalg.lstsq` method instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 7** → Let *v* be a vector written in its coordinate form as a 3 × 1 matrix
    [1 -1 1]*^T*. Construct the projection matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/projection.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Show experimentally that *v* is an eigenvector for both matrices *P* and *Q*.
    What are the corresponding eigenvalues?
  prefs: []
  type: TYPE_NORMAL
- en: '**Ex. 8** → In numerical linear algebra the *m* × *m* matrix *A* with the property'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is used as an example for an extreme growth-factor, when performing *LU* factorization.
  prefs: []
  type: TYPE_NORMAL
- en: Set up this matrix in Python for various *m*, compute its *LU* factorization
    using the command `scipy.linalg.lu` and derive experimentally a statement about
    the growth factor
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercises](img/B05511_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: in relation to m.
  prefs: []
  type: TYPE_NORMAL
