- en: Chapter 4. Linear Algebra – Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。线性代数 – 数组
- en: Linear algebra is one of the essential building blocks of computational mathematics.
    The objects of linear algebra are vectors and matrices. The package NumPy includes
    all the necessary tools to manipulate those objects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是计算数学的基本构建块之一。线性代数的对象是向量和矩阵。NumPy 包含了操作这些对象所需的所有必要工具。
- en: The first task is to build matrices and vectors, or to alter existing ones by
    slicing. The other main task is the `dot` operation, which embodies most of the
    linear algebra operations (scalar product, matrix-vector product, and matrix-matrix
    product). Finally, various methods are available to solve linear problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是构建矩阵和向量，或者通过切片修改现有的矩阵和向量。另一个主要任务是 `dot` 操作，它包含了大多数线性代数操作（标量积、矩阵-向量积和矩阵-矩阵积）。最后，有各种方法可以解决线性问题。
- en: Overview of the array type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型概述
- en: For the impatient, here is how to use arrays in a nutshell. Be aware though
    that the behavior of arrays may be surprising at first, so we encourage you to
    read on after this introductory section.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于急于求成的人来说，这里简要介绍如何使用数组。但请注意，数组的行为一开始可能会令人惊讶，所以我们鼓励你在本介绍性章节之后继续阅读。
- en: Vectors and matrices
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量和矩阵
- en: 'Creating vectors is as simple as using the function `array`  to convert a list
    to an array:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创建向量与使用 `array` 函数将列表转换为数组一样简单：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The object `v`  is now a vector that behaves much like a vector in linear algebra.
    We have already emphasized the differences with the list object in Python (refer
    to section *Arrays* in [Chapter 3](ch03.html "Chapter 3. Container Types"), *Containers
    Type)*. Here are some illustrations of the basic linear algebra operations on
    vectors:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对象 `v` 现在是一个行为线性代数中的向量。我们已强调它与 Python 中的列表对象的区别（参见 [第 3 章](ch03.html "第 3 章。容器类型")
    中的 *数组* 部分，*容器类型)*。以下是向量上基本线性代数操作的示例：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that all basic arithmetic operations are performed elementwise:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有基本算术运算都是逐元素执行的：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some functions act elementwise on arrays as well:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数也对数组进行逐元素操作：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This subject will be covered in the section *Functions Acting on Arrays.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题将在 *作用在数组上的函数* 这一部分进行讲解。
- en: 'A matrix is created in a similar way to a vector, but from a list of lists
    instead:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的创建方式与向量类似，但它是从列表的列表中创建的：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Vectors are no column - and no row matrices**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量既不是列矩阵也不是行矩阵**'
- en: The *n* vector, an *n* × 1, and a 1 × n matrix are three different objects even
    if they contain the same data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们包含相同的数据，*n* 向量、一个 *n* × 1 的矩阵和一个 1 × n 的矩阵仍然是三个不同的对象。
- en: 'To create a row matrix containing the same data as the vector `v = array([1.,
    2., 1.])`, we do this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含与向量 `v = array([1., 2., 1.])` 相同数据的行矩阵，我们这样做：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The corresponding column matrix is obtained by the method `reshape`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `reshape` 方法可以得到相应的列矩阵：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Indexing and slices
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引和切片
- en: 'Indexing and slicing are similar to that of a list. The main difference is
    that there may be several indexes or slices when the array is a matrix. The subject
    will be covered in depth in section *Array indexing;* here, we just give some
    illustrating examples of indexing and slicing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和切片与列表类似。主要区别在于，当数组是矩阵时，可能会有多个索引或切片。这个主题将在 *数组索引* 这一部分进行深入讲解；在这里，我们只给出一些索引和切片的示例：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Linear algebra operations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数运算
- en: 'The essential operator that performs most of the usual operations of linear
    algebra is the Python function `dot`. It is used for matrix-vector multiplications:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行线性代数大多数常规操作的必要运算符是 Python 函数 `dot`。它用于矩阵-向量乘法：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It may be used to compute a scalar product between two vectors:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用来计算两个向量之间的标量积：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, it is used to compute matrix-matrix products:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它用于计算矩阵-矩阵积：
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Solving a linear system
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求解线性系统
- en: 'If *A* is a matrix and *b* is a vector, you can solve the linear equation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *A* 是一个矩阵，而 *b* 是一个向量，你可以求解线性方程：
- en: '![Solving a linear system](img/linsystem.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![求解线性系统](img/linsystem.jpg)'
- en: 'Using the `solve` method, which has this syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `solve` 方法，其语法如下：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For example, we want to solve:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要求解：
- en: '![Solving a linear system](img/b05511_06_1200.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![求解线性系统](img/b05511_06_1200.jpg)'
- en: 'Here is the solution for the preceding equation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面方程的解：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The command `allclose` is used here to compare two vectors. If they are close
    enough to each other, this command returns `True`. Optionally a tolerance value
    can be set. For more methods related to linear equations systems, refer to section
    *Linear algebra methods in SciPy*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `allclose` 在这里用于比较两个向量。如果它们彼此足够接近，此命令将返回 `True`。可以设置一个容差值。有关与线性方程系统相关的方法，请参阅
    *SciPy 中的线性代数方法* 部分。
- en: Mathematical preliminaries
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学预备知识
- en: In order to understand how arrays work in NumPy, it is useful to understand
    the mathematical parallel between accessing tensor (matrix and vector) elements
    by indexes and evaluating mathematical functions by providing arguments. We also
    cover in this section the generalization of the dot product as a reduction operator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 NumPy 中数组的工作方式，了解通过索引访问张量（矩阵和向量）元素与通过提供参数评估数学函数之间的数学平行是有用的。我们还在本节中介绍了点积作为降维算子的推广。
- en: Arrays as functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组作为函数
- en: Arrays may be considered from several different points of view. We believe that
    the most fruitful one in order to understand arrays is that of functions of several
    variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以从几个不同的角度来考虑。我们认为，为了理解数组，最有成效的角度是将其视为多个变量的函数。
- en: 'For instance, selecting a component of a given vector in *ℝ*^(*n*) may just
    be considered a function from the set of ℕ[*n*] to ℝ, where we define the set:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择 *ℝ*^(*n*) 中给定向量的一个分量可以仅仅被视为从集合 ℕ[*n*] 到 ℝ 的函数，其中我们定义该集合：
- en: '![Arrays as functions](img/somenumbers.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![数组作为函数](img/somenumbers.jpg)'
- en: Here the set ℕ[n] has *n* elements. The Python function `range` generates ℕ[*n*].
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，集合 ℕ[n] 有 *n* 个元素。Python 函数 `range` 生成 ℕ[*n*]。
- en: Selecting an element of a given matrix, on the other hand, is a function of
    two parameters, taking its value in ℝ. Picking a particular element of an *m*
    × *n* matrix may thus be considered a function from ℕ[*m*] × ℕ[*n*] to ℝ.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，选择给定矩阵的一个元素是两个参数的函数，其值在 ℝ 中。因此，选择一个 *m* × *n* 矩阵的特定元素可以被视为从 ℕ[*m*] × ℕ[*n*]
    到 ℝ 的函数。
- en: Operations are elementwise
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素级运算
- en: 'NumPy arrays are essentially treated as mathematical functions. This is in
    particular true for operations. Consider two functions, *f* and *g*, defined on
    the same domain and taking real values. The product *f g* of those two functions
    is defined as the pointwise product, that is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组基本上被视为数学函数。这在运算中尤其如此。考虑两个在相同定义域上定义并取实数值的函数 *f* 和 *g*。这两个函数的乘积 *f g*
    定义为点积，即：
- en: '![Operations are elementwise](img/pointwiseproduct.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![元素级运算](img/pointwiseproduct.jpg)'
- en: 'Note that this construction is possible for any operation between two functions.
    For an arbitrary operation defined on two scalars, which we denote here by ![Operations
    are elementwise](img/star.jpg), we could define ![Operations are elementwise](img/fstarg.jpg)
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种构造适用于两个函数之间的任何操作。对于定义在两个标量上的任意操作，我们在这里用 ![元素级运算](img/star.jpg) 表示，我们可以如下定义
    ![元素级运算](img/fstarg.jpg)：
- en: '![Operations are elementwise](img/starop.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![元素级运算](img/starop.jpg)'
- en: 'This innocuous remark allows us to understand NumPy''s stance on operations;
    all operations are elementwise in arrays. For instance, the product between two
    matrices *m* and *n* is defined, as with functions, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这无害的评论使我们能够理解 NumPy 对运算的态度；数组中的所有运算都是元素级的。例如，两个矩阵 *m* 和 *n* 的乘积定义为，与函数一样，如下所示：
- en: '![Operations are elementwise](img/indexfunction.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![元素级运算](img/indexfunction.jpg)'
- en: Shape and number of dimensions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状和维度数
- en: 'There is a clear distinction between a:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，我们可以清楚地区分一个：
- en: '**Scalar**: Function with no arguments'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：无参数的函数'
- en: '**Vector**: Function with one argument'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向量**：具有一个参数的函数'
- en: '**Matrix**: Function with two arguments'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**矩阵**：具有两个参数的函数'
- en: '**Higher order tensor**: Function with more than two arguments'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高阶张量**：具有两个以上参数的函数'
- en: In what follows, the number of dimensions is the number of arguments of a function.
    The shape corresponds essentially to the domain of definition of a function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，维度数是函数的参数数。形状基本上对应于函数的定义域。
- en: For instance, a vector of size *n* is a function from the set ℕ[*n*] to ℝ. As
    a result, its domain of definition is ℕ[*n*]. Its shape is defined as the singleton
    (*n,*). Similarly, a matrix of size *m* × *n* is a function defined on ℕ[*m*]
    × ℕ[*m*]. The corresponding shape is simply the pair (*m*, *n*). The shape of
    an array is obtained by the `numpy.shape` function, and the number of dimensions
    by the `numpy.ndim` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个大小为 *n* 的向量是从集合 ℕ[*n*] 到 ℝ 的函数。因此，其定义域是 ℕ[*n*]。其形状定义为单元素 (*n,*）。同样，一个大小为
    *m* × *n* 的矩阵是在集合 ℕ[*m*] × ℕ[*m*] 上定义的函数。相应的形状简单地是 (*m*, *n*）。数组的形状可以通过 `numpy.shape`
    函数获得，维数可以通过 `numpy.ndim` 函数获得。
- en: The dot operations
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点积操作
- en: 'Treating arrays as functions, although very powerful, completely neglects the
    linear algebra structures we are familiar with, that is, matrix-vector and matrix-matrix
    operations. Fortunately, these linear algebra operations may all be written in
    a similar unified form:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组视为函数，虽然功能强大，但完全忽略了我们所熟悉的线性代数结构，即矩阵-向量和矩阵-矩阵操作。幸运的是，所有这些线性代数操作都可以用类似统一的形式表示：
- en: 'The vector-vector operation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-向量操作：
- en: '![The dot operations](img/B05511_04_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_02.jpg)'
- en: 'The matrix-vector operation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量操作：
- en: '![The dot operations](img/B05511_04_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_03.jpg)'
- en: 'The matrix-matrix operation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-矩阵操作：
- en: '![The dot operations](img/B05511_04_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_04.jpg)'
- en: 'The vector-matrix operation:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 向量-矩阵操作：
- en: '![The dot operations](img/B05511_04_05.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_05.jpg)'
- en: 'The essential mathematical concept is that of reduction. For a matrix-vector
    operation, the reduction is given by:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 核心数学概念是归约。对于一个矩阵-向量操作，归约由以下公式给出：
- en: '![The dot operations](img/B05511_04_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_06.jpg)'
- en: 'In general, a reduction operation defined between two tensors *T* and *U* of
    respective number of dimensions *m* and *n* may be defined as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，定义在两个张量 *T* 和 *U* 之间（分别具有 *m* 和 *n* 个维度）的归约操作可以定义为：
- en: '![The dot operations](img/B05511_04_07-1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/B05511_04_07-1.jpg)'
- en: Clearly, the shapes of the tensors must be compatible for that operation to
    make any sense. This requirement is familiar for matrix-matrix multiplication.
    The multiplication *M N* of matrices *M* and *N* only makes sense if the number
    of columns of *M* equals the number of rows of *N*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，张量的形状必须兼容，这样操作才有意义。这个要求对于矩阵-矩阵乘法是熟悉的。矩阵 *M* 和 *N* 的乘积 *M N* 只有在 *M* 的列数等于
    *N* 的行数时才有意义。
- en: 'Another consequence of the reduction operation is that it produces a new tensor
    with *m + n - 2* dimensions. In the following table, we gather the output of the
    reduction operation for the familiar cases involving matrices and vectors:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 归约操作的另一个后果是它产生了一个具有 *m + n - 2* 维度的新张量。在下面的表中，我们收集了涉及矩阵和向量的常见归约操作输出：
- en: '![The dot operations](img/Table-4.1.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![点操作](img/Table-4.1.jpg)'
- en: 'Table 4.1: Output of the reduction operation for the familiar cases involving
    matrices and vectors'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1：涉及矩阵和向量的常见归约操作输出
- en: 'In Python, all reduction operations are performed using the `dot` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，所有归约操作都是通过 `dot` 函数来执行的：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As in mathematical textbooks, also in modern Python (Version 3.5 and higher),
    the dot product is sometimes preferred to be written in its operator form, `dot(M,
    v)`, or by using the more handy infix notation, `M @ v`. From now on we stick
    to the operator form; you can modify the examples if the other form is preferred.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数学教科书中所描述的，在现代 Python（版本 3.5 及更高版本）中，点积有时更倾向于以操作符形式书写，即 `dot(M, v)`，或者使用更方便的中缀表示法，`M
    @ v`。从现在开始，我们将坚持使用操作符形式；如果您更喜欢其他形式，可以修改示例。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Elementwise versus matrix multiplication**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**逐元素与矩阵乘法**'
- en: The multiplication operator `*` is always elementwise. It has nothing to do
    with the dot operation. Even if *A* is a matrix and *v* is a vector, *A*v* is
    still a legal operation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法操作符 `*` 总是逐元素操作。它与点积无关。即使 *A* 是一个矩阵，*v* 是一个向量，*A*v* 仍然是一个合法的操作。
- en: The matrix-vector multiplication is performed using the `dot` function. Refer
    to section *Broadcasting* of [Chapter 5](ch05.html "Chapter 5. Advanced Array
    Concepts"), *Advanced Array Concepts*, for more information.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵-向量乘法是通过 `dot` 函数执行的。有关更多信息，请参阅第 5 章 *高级数组概念* 中的 *广播* 部分。
- en: The array type
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组类型
- en: The objects used to manipulate vectors, matrices, and more general tensors in
    NumPy are called arrays. In this section, we examine their essential properties,
    how to create them, and how to access their information.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在 NumPy 中操作向量、矩阵和更一般的张量的对象称为数组。在本节中，我们检查它们的本质属性、如何创建它们以及如何访问它们的信息。
- en: Array properties
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组属性
- en: 'Arrays are essentially characterized by three properties, which is given in
    the following table (*Table 4.2*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数组本质上由三个属性来表征，如下表所示（*表 4.2*）：
- en: '| **Name** | **Description** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `shape` | It describes how the data should be interpreted, as a vector, a
    matrix or as a higher order tensor, and it gives the corresponding dimension.
    It is accessed with the `shape` attribute. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `shape` | 它描述了数据应该如何被解释，作为一个向量、一个矩阵或一个更高阶的张量，并给出了相应的维度。它通过 `shape` 属性来访问。|'
- en: '| `dtype` | It gives the type of the underlying data (float, complex, integer,
    and so on). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `dtype` | 它给出了底层数据类型（浮点数、复数、整数等）。|'
- en: '| `strides` | This attribute specifies in which order the data should be read.
    For instance, a matrix could be stored in memory contiguously column by column
    (the FORTRAN convention), or row by row (the C convention). The attribute is a
    tuple with the numbers of bytes that have to be skipped in memory to reach the
    next row and the number of bytes to be skipped to reach the next column. The `strides`
    attribute even allows for a more flexible interpretation of the data in memory,
    which is what makes array views possible. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `strides` | 此属性指定了数据应该以何种顺序读取。例如，一个矩阵可以在内存中连续地按列存储（FORTRAN 习惯），或者按行存储（C 习惯）。该属性是一个元组，包含到达下一行和到达下一列需要跳过的字节数。`strides`
    属性甚至允许对内存中的数据进行更灵活的解释，这就是数组视图成为可能的原因。|'
- en: 'Table 4.2 : Properties of Arrays'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '表 4.2 : 数组的属性'
- en: 'Consider the following array:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下数组：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Its elements have type `'int64'`; that is, they use 64 bits or 8 bytes in memory.
    The complete array is stored in memory row-wise. The distance from `A[0, 0]` to
    the first element in the next row `A[1,0]` is thus 24 bytes (three matrix elements)
    in memory. Correspondingly, the distance in memory between `A[0,0]` and `A[0,1]`
    is 8 bytes (one matrix element). These values are stored in the attribute `strides`
    .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的元素类型为 `'int64'`；也就是说，它们在内存中使用64位或8字节。整个数组以行的方式存储在内存中。因此，从 `A[0, 0]` 到下一行
    `A[1,0]` 的第一个元素在内存中的距离是24字节（三个矩阵元素）。相应地，`A[0,0]` 和 `A[0,1]` 在内存中的距离是8字节（一个矩阵元素）。这些值存储在
    `strides` 属性中。
- en: Creating arrays from lists
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从列表创建数组
- en: 'The general syntax to create an array is the function `array` . The syntax
    to create a real vector would be:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的通用语法是 `array` 函数。创建实向量的语法将是：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To create a complex vector with the same data:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有相同数据的复向量：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When no type is specified, the type is guessed. The `array` function chooses
    the type that allows storing of all the specified values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有指定类型时，类型会被猜测。`array` 函数会选择允许存储所有指定值的类型：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Silent type conversion** NumPy silently casts floats into integers, which
    might give unexpected results:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**静默类型转换** NumPy 静默地将浮点数转换为整数，这可能会产生意外的结果：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The same often unexpected array type casting happens from complex to float.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从复数到浮点数的数组类型转换通常也是意外的。
- en: '**Array and Python parentheses**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组和 Python 括号**'
- en: 'As we have noticed in section *Program and program flow* in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*, Python allows a line break when
    some opening brace or parenthesis is not closed. This allows a convenient syntax
    for array creation, which makes it more pleasing to the human eye:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 1 章 [程序和程序流程](ch01.html "第 1 章。入门") 中的 *程序和程序流程* 节所注意到的，Python 允许在某个开括号或括号未关闭时进行换行。这允许创建数组的方便语法，这使得它对人类眼睛来说更加令人愉悦：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Accessing array entries
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: Array entries are accessed by indexes. In contrast to vector coefficients two
    indexes are needed to access matrix coefficients. These are given in one pair
    of brackets. This distinguishes the array syntax from a list of lists. There,
    two pairs of brackets are needed to access elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数组元素通过索引访问。与向量系数不同，访问矩阵系数需要两个索引。这些索引在一个括号对中给出。这区分了数组语法和列表的列表。在那里，需要两个括号对来访问元素。
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Basic array slicing
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数组切片
- en: 'Slices are similar to those of lists except that there might now be in more
    than one dimension:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 切片与列表的切片类似，但现在可能有多个维度：
- en: '`M[i,:]` is a vector filled by the row *i* of *M.*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[i,:]` 是由 *M* 的第 *i* 行填充的向量。'
- en: '`M[:,j]` is a vector filled by the column *i* of *M.*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[:,j]` 是由 *M* 的列 *i* 填充的向量。'
- en: '`M[2:4,:]` is a slice of `2:4` on the rows only.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[2:4,:]` 是对行 `2:4` 的切片。'
- en: '`M[2:4,1:4]` is a slice on rows and columns.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M[2:4,1:4]` 是对行和列的切片。'
- en: 'The result of matrix slicing is given in the following figure (*Figure 4.1*):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵切片的结果在以下图中给出（*图4.1*）：
- en: '![Basic array slicing](img/array_slice.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![基本数组切片](img/array_slice.jpg)'
- en: 'Figure 4.1: The result of matrix slicing'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：矩阵切片的结果
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Omitting a dimension**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**省略一个维度**'
- en: If you omit an index or a slice, NumPy assumes you are taking rows only. `M[3]`
    is a vector that is a view on the third row of *M *and `M[1:3]` is a matrix that
    is a view on the second and third rows of *M.*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了一个索引或切片，NumPy 假设你只取行。`M[3]` 是一个视图，它是 *M* 的第三行，而 `M[1:3]` 是一个视图，它是 *M*
    的第二行和第三行。
- en: 'Changing the elements of a slice affects the entire array:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中的元素更改会影响整个数组：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'General slicing rules are given in the following table (*Table 4.3)*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通用切片规则在以下表格中给出（*表4.3*）：
- en: '![Basic array slicing](img/Table-4.3.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![基本数组切片](img/Table-4.3.jpg)'
- en: 'Table 4.3: General Slicing Rules'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3：通用切片规则
- en: 'The results of slicing operations for an array `M` of shape *(4, 4)* are given
    in the following table (*Table 4.4*):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 形状为 *(4, 4)* 的数组 `M` 的切片操作结果如下表（*表4.4*）所示：
- en: '![Basic array slicing](img/Table-4.4.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![基本数组切片](img/Table-4.4.jpg)'
- en: 'Table 4.4: Result of slicing operation for an array M of shape (4,4)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.4：形状为 (4,4) 的数组 M 的切片操作结果
- en: Altering an array using slices
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用切片更改数组
- en: 'You may alter an array using slices or by direct access. The following changes
    only one element in a 5 × 3 matrix `M`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用切片或直接访问来更改数组。以下更改了一个 5 × 3 矩阵 `M` 中的一个元素：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But we may change one full row of the matrix:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可能改变矩阵的一整行：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We may also replace a full submatrix:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以替换一个完整的子矩阵：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is a distinction between a column matrix and a vector. The following
    assignment with a column matrix returns no error `M[1:4, 2:3] = array([[1.],[0.],[-1.0]])`
    while the assignment with a vector returns a `Value Error` `M[1:4, 2:3] = array([1.,
    0., -1.0]) #  error`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '列矩阵和向量之间有一个区别。以下使用列矩阵的赋值没有错误 `M[1:4, 2:3] = array([[1.],[0.],[-1.0]])`，而使用向量的赋值会返回一个
    `ValueError` 错误 `M[1:4, 2:3] = array([1., 0., -1.0]) #  错误`'
- en: The general slicing rules are shown in *Table 4.2*. The matrices and vectors
    in the preceding examples must have the right size to fit into matrix *M*. You
    may also make use of the broadcasting rules (for more information, refer to section
    *Broadcasting* of [Chapter 5](ch05.html "Chapter 5. Advanced Array Concepts"),
    *Advanced Array Concepts*) to determine the allowed size of the replacement arrays.
    If the replacement array does not have the right shape, a `ValueError` exception
    will be raised.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通用切片规则在 *表4.2* 中显示。前例中的矩阵和向量必须具有正确的大小，以便适合矩阵 *M*。你也可以使用广播规则（更多信息，请参阅第5章的 *Broadcasting*
    部分，*高级数组概念*），以确定替换数组的允许大小。如果替换数组没有正确的大小，将引发 `ValueError` 异常。
- en: Functions to construct arrays
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建数组的函数
- en: 'The usual way to set up an array is via a list. But there are also a couple
    of convenient methods for generating special arrays, which are given in the following
    table (*Table 4.5*):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 设置数组的最常见方式是通过列表。但也有一些方便的方法可以生成特殊数组，以下表格（*表4.5*）中给出了这些方法：
- en: '| **Methods** | **Shape** | **Generates** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **形状** | **生成** |'
- en: '|  `zeros((n,m))` | *(n,m)* | Matrix filled with zeros |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  `zeros((n,m))` | *(n,m)* | 用零填充的矩阵 |'
- en: '| `ones((n,m)) ` | *(n,m)* | Matrix filled with ones |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `ones((n,m)) ` | *(n,m)* | 用一填充的矩阵 |'
- en: '| `diag(v,k) ` | *(n,n)* | (Sub-, super-) diagonal matrix from a vector *v*
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `diag(v,k) ` | *(n,n)* | 从向量 *v* 生成的（子-，超-）对角矩阵 |'
- en: '| `random.rand(n,m) ` | *(n,m)* | Matrix filled with uniformly distributed
    random numbers in (0,1) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `random.rand(n,m) ` | *(n,m)* | 用在 (0,1) 中均匀分布的随机数填充的矩阵 |'
- en: '|  `arange(n)` | *(n,)* | First *n* integers |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|  `arange(n)` | *(n,)* | 前 *n* 个整数 |'
- en: '| `linspace(a,b,n) ` | *(n,)* | Vector with *n* equispaced points between *a*
    and *b* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `linspace(a,b,n) ` | *(n,)* | 在 *a* 和 *b* 之间有 *n* 个等间距点的向量 |'
- en: 'Table 4.5: Commands to create arrays'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.5：创建数组的命令
- en: These commands may take additional arguments. In particular, the commands `zeros`,
    `ones`, and `arange` take `dtype` as an optional argument. The default type is
    `float`, except for `arange`. There are also methods such as `zeros_like` and
    `ones_like`, which are slight variants of the preceding ones. For instance, the
    `zeros_like(A)` method is equivalent to `zeros(shape(A))`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可能需要额外的参数。特别是，`zeros`、`ones` 和 `arange` 命令接受 `dtype` 作为可选参数。默认类型是 `float`，除了
    `arange`。还有像 `zeros_like` 和 `ones_like` 这样的方法，是前面方法的轻微变体。例如，`zeros_like(A)` 方法等同于
    `zeros(shape(A))`。
- en: 'Here is the `identity` function, which constructs an identity matrix of a given
    size:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `identity` 函数，它构建一个给定大小的单位矩阵：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The command is identical to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 命令与以下命令相同：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Accessing and changing the shape
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和更改形状
- en: The number of dimensions is what distinguishes a vector from a matrix. The **shape**
    is what distinguishes vectors of different sizes, or matrices of different sizes.
    In this section, we examine how to obtain and change the shape of an array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 维度数是区分向量和矩阵的因素。**形状**是区分不同大小的向量或矩阵的因素。在本节中，我们将探讨如何获取和更改数组的形状。
- en: The shape function
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形状函数
- en: 'The shape of a matrix is the tuple of its dimensions. The shape of an n × m
    matrix is the tuple `(n, m)`. It can be obtained by the `shape` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的形状是其维度的元组。一个 n × m 矩阵的形状是元组 `(n, m)`。可以通过 `shape` 函数获得：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For a vector, the shape is a singleton containing the length of that vector:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向量，形状是一个包含该向量长度的单元素：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An alternative is to use the array attribute `shape`, which gives  the same
    result:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用数组属性 `shape`，它给出相同的结果：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, the advantage of using  `shape` as a function is that this function
    may be used on scalars and lists as well. This may come in handy when code is
    supposed to work with both scalars and arrays:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `shape` 作为函数的优势在于，这个函数也可以用于标量和列表。当代码需要同时处理标量和数组时，这可能会很有用：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Number of dimensions
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维度数
- en: 'The number of dimensions of an array is obtained with the function `numpy.ndim` 
    or using the array attribute `ndarray.ndim` :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的维度数可以通过函数 `numpy.ndim` 或使用数组属性 `ndarray.ndim` 获取：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the number of dimensions, given by the function `ndim`, of a tensor
    `T` (a vector, matrix, or higher order tensor) is always equal to the length of
    its shape:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，张量 `T`（一个向量、矩阵或更高阶的张量）的维度数，由函数 `ndim` 给出，总是等于其形状的长度：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reshape
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重塑
- en: 'The method `reshape` gives a new view of the array, with a new shape, without
    copying the data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `reshape` 给出了数组的新视图，具有新的形状，而不复制数据：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Reshape does not copy**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**重塑不复制**'
- en: Reshape does not create a new array. It rather gives a new view on the existing
    array. In the preceding example, changing one element of `M` would automatically
    result in a change in the corresponding element in `v`. When this behavior is
    not acceptable, you need to copy the data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重新塑形不会创建一个新的数组。它更像是给现有的数组提供了一个新的视图。在先前的例子中，更改 `M` 中的一个元素将自动导致 `v` 中相应元素的变化。当这种行为不可接受时，你需要复制数据。
- en: 'The various effects of the `reshape` method on an array defined by `arange(6)` are
    given in the following figure :'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下图给出了由 `arange(6)` 定义的数组上 `reshape` 方法的各种效果：
- en: '![Reshape](img/array_reshape.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![重塑](img/array_reshape.jpg)'
- en: 'Figure 4.2: The various effects of the reshape method on an array defined by
    arange(6)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：由 `arange(6)` 定义的数组上重塑方法的多种效果
- en: 'If one tries to reshape an array with a shape that does not multiply to the
    original shape, an error is raised:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试将形状乘积不等于原始形状的数组进行重塑，将引发错误：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sometimes, it is convenient to specify only one shape parameter and let Python
    determine the other in such a way that it multiplies to the original shape. This
    is done by setting the free shape parameter `-1`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，指定一个形状参数并让 Python 以乘积等于原始形状的方式确定其他参数是很方便的。这是通过将自由形状参数设置为 `-1` 来实现的：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Transpose
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转置
- en: 'A special form of reshaping is transposing. It just switches the two shape
    elements of the matrix. The transpose of a matrix *A* is a matrix *B* such that:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重新塑形的一种特殊形式是转置。它只是交换矩阵的两个形状元素。矩阵 *A* 的转置是一个矩阵 *B*，使得：
- en: '![Transpose](img/transpose.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![转置](img/transpose.jpg)'
- en: 'Which is resolved in the following way:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这以下列方式解决：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Transpose does not copy**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**转置不复制**'
- en: 'Transposition is very similar to reshaping. In particular, it does not copy
    the data either and just returns a view on the same array:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 转置与重塑非常相似。特别是，它也不复制数据，只是返回对同一数组的视图：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Transposing a vector makes no sense since vectors are tensors of one dimension,
    that is, functions of one variable. NumPy will, however, comply and return exactly
    the same object:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 转置向量没有意义，因为向量是一维的张量，即一元函数。然而，NumPy会遵守并返回完全相同的对象：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What you have in mind when you want to transpose a vector is probably to create
    a row or column matrix. This is done using `reshape`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想转置一个向量时，你可能在想创建一个行矩阵或列矩阵。这是使用`reshape`完成的：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stacking
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆叠
- en: 'The universal method to build matrices from a couple of (matching) submatrices
    is `concatenate`. Its syntax is:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从一对（匹配的）子矩阵构建矩阵的通用方法是`concatenate`。其语法如下：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This command stacks the submatrices vertically (on top of each other) when
    `axis=0` is specified. With the `axis=1` argument, they are stacked horizontally,
    and this generalizes according to arrays with more dimensions. This function is
    called by several convenient functions, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定`axis=0`时，此命令将子矩阵垂直堆叠（彼此之上）。使用`axis=1`参数时，它们将水平堆叠，并且这种通用性适用于更多维度的数组。此功能由以下几个方便的函数调用：
- en: '`hstack`: Used to stack matrices horizontally'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hstack`：用于水平堆叠矩阵'
- en: '`vstack`: Used to stack matrices vertically'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vstack`：用于垂直堆叠矩阵'
- en: '`columnstack`: Used to stack vectors in columns'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columnstack`：用于按列堆叠向量'
- en: Stacking vectors
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆叠向量
- en: 'One may stack vectors row-wise or column-wise using `vstack` and `column_stack`,
    as illustrated in the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`vstack`和`column_stack`按行或按列堆叠向量，如下图所示：
- en: '![Stacking vectors](img/array_stack.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![堆叠向量](img/array_stack.jpg)'
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`hstack` would produce the concatenation of v1 and v2.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`hstack`将产生v1和v2的连接。'
- en: 'Let us consider the symplectic permutation as an example for vector stacking:
    We have a vector of size 2*n*. We want to perform a symplectic transformation
    of a vector with an even number of components, that is, exchange the first half
    with the second half of the vector with sign change:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以向量堆叠为例，让我们考虑辛排列：我们有一个大小为2*n*的向量。我们想要对具有偶数个分量的向量执行辛变换，即交换向量的前半部分与后半部分，并改变符号：
- en: '![Stacking vectors](img/symplectic.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![堆叠向量](img/symplectic.jpg)'
- en: 'This operation is resolved in Python as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作在Python中的解析如下：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Functions acting on arrays
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用于数组的函数
- en: There are different types of functions acting on arrays. Some act elementwise,
    and they return an array of the same shape. Those are called universal functions.
    Other array functions return an array of a different shape.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的函数作用于数组。一些逐元素作用，并返回具有相同形状的数组。这些被称为通用函数。其他数组函数返回不同形状的数组。
- en: Universal functions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用函数
- en: Universal functions are functions that act elementwise on arrays. They thus
    have an output array that has the same shape as the input array. These functions
    allow us to compute the result of a scalar function on a whole array at once.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数是逐元素作用于数组的函数。因此，它们的输出数组与输入数组具有相同的形状。这些函数允许我们一次性计算整个数组上的标量函数的结果。
- en: Built-in universal functions
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置通用函数
- en: 'A typical example is the `cos` function (the one provided by NumPy):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 典型例子是`cos`函数（NumPy提供的）：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note that universal functions work on arrays in a componentwise manner. This
    is also true for operators, such as multiplication or exponent:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通用函数以分组件方式作用于数组。这也适用于运算符，如乘法或指数：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Create universal functions
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建通用函数
- en: 'Your function will automatically be universal if you use only universal functions
    in it. If, however, your function uses functions that are not universal, you might
    get scalar results, or even an error, when trying to apply them on an array:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数只使用通用函数，则该函数将自动成为通用函数。然而，如果你的函数使用非通用函数，则在尝试将它们应用于数组时可能会得到标量结果，甚至出现错误：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another example is the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子如下：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The expected behaviour would be that the `heaviside` function applied to a
    vector `[*a*, *b*]` would return `[heaviside(*a*), heaviside(*b*)]`. Alas, this
    does not work because the function always returns a scalar, no matter the size
    of the input argument. Besides, using the function with an array input would raise
    an exception. The NumPy function `vectorize` allows us to quickly solve this problem:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的行为是，将`heaviside`函数应用于向量`[*a*, *b*]`将返回`[heaviside(*a*), heaviside(*b*)]`。然而，这不起作用，因为该函数总是返回一个标量，无论输入参数的大小如何。此外，使用数组输入该函数将引发异常。NumPy函数`vectorize`允许我们快速解决这个问题：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A typical application of this method is its use when plotting a function:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的典型应用是在绘制函数时使用：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following graph shows the heaviside function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了 Heaviside 函数：
- en: '![Create universal functions](img/heaviside.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![创建通用函数](img/heaviside.jpg)'
- en: Tip
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `vectorize` function does not improve performance*.* It provides only a
    convenient way to quickly transform a function, so that it operates elementwise
    on list and arrays.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`vectorize` 函数并不会提高性能*.* 它只提供了一个方便的方式来快速转换一个函数，使其能够逐元素地对列表和数组进行操作。'
- en: Array functions
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组函数
- en: 'There are a number of functions acting on arrays that do not act componentwise.
    Examples of such functions are `max`, `min`, and `sum`. These functions may operate
    on the whole matrix, row-wise, or column-wise. When no argument is provided, they
    act on the whole matrix. Suppose `A` is the following matrix:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多作用于数组的函数不是逐分量操作的。这类函数的例子有 `max`、`min` 和 `sum`。这些函数可以作用于整个矩阵、按行或按列操作。如果没有提供参数，它们作用于整个矩阵。假设
    `A` 是以下矩阵：
- en: '![Array functions](img/array_methods_1.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![数组函数](img/array_methods_1.jpg)'
- en: 'The `sum` function acting on that matrix returns a scalar:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对该矩阵作用的 `sum` 函数返回一个标量：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The command has an optional parameter, `axis` . It allows us to choose along which
    axis to perform the operation. For instance, if the axis is *0*, it means that
    the sum should be computed along the first axis. The sum along axis *0* of an
    array of shape (*m*, *n*) will be a vector of length *n*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 命令有一个可选参数，`axis`。它允许我们选择在哪个轴上执行操作。例如，如果轴是 *0*，则表示总和应该沿着第一个轴计算。形状为 (*m*, *n*)
    的数组的轴 *0* 的总和将是一个长度为 *n* 的向量。
- en: 'Suppose we compute the sum of `A` along the axis 0:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们沿着轴 0 计算 `A` 的总和：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This amounts to computing the sum on the columns:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在列上计算总和：
- en: '![Array functions](img/array_methods_2.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![数组函数](img/array_methods_2.jpg)'
- en: 'The result is a vector:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个向量：
- en: '![Array functions](img/array_methods_5.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![数组函数](img/array_methods_5.jpg)'
- en: 'Now suppose we compute the sum along the axis *1*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们沿着轴 *1* 计算总和：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This amounts to computing the sum on the rows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在行上计算总和：
- en: '![Array functions](img/array_methods_4.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![数组函数](img/array_methods_4.jpg)'
- en: 'The result is a vector:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个向量：
- en: '![Array functions](img/array_methods_3.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![数组函数](img/array_methods_3.jpg)'
- en: Linear algebra methods in SciPy
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SciPy 中的线性代数方法
- en: SciPy offers a large range of methods from numerical linear algebra in its `scipy.linalg`
    module. Many of these methods are Python wrapping programs from `LAPACK`, a collection
    of well-approved FORTRAN subroutines used to solve linear equation systems and
    eigenvalue problems. Linear algebra methods are the core of any method in scientific
    computing, and the fact that SciPy uses wrappers instead of pure Python code makes
    these central methods extremely fast. We present in detail here how two linear
    algebra problems are solved with SciPy to give you a flavour of this module.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 在其 `scipy.linalg` 模块中提供了大量数值线性代数方法。其中许多方法都是 Python 对 `LAPACK` 程序的封装，`LAPACK`
    是一组经过良好验证的 FORTRAN 子例程集合，用于解决线性方程组和特征值问题。线性代数方法是任何科学计算方法的核心，而 SciPy 使用封装而不是纯 Python
    代码的事实使得这些核心方法非常快速。我们在此详细介绍了如何使用 SciPy 解决两个线性代数问题，以让您了解此模块。
- en: Solving several linear equation systems with LU
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 LU 解多个线性方程组
- en: 'Let *A* be an *n × n* matrix and *b[1]*, *b[2]*, ..., *b[k]* be a sequence
    of *n*-vectors. We consider the problem to find *n* vectors *x[i]* such that:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *A* 为一个 *n × n* 矩阵，*b[1]*、*b[2]*、...、*b[k]* 是一个 *n*-向量的序列。我们考虑的问题是找到 *n* 个向量
    *x[i]*，使得：
- en: '![Solving several linear equation systems with LU](img/severallinsystems.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![使用 LU 解多个线性方程组](img/severallinsystems.jpg)'
- en: We assume that the vectors *b[i]* are not known simultaneously. In particular,
    it is quite a common situation that the *i*^(th) problem has to be solved before
    *b[i+1]* becomes available.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设向量 *b[i]* 不是同时已知的。特别是，在 *i*^(th) 问题必须解决之后 *b[i+1]* 才可用的情形相当常见。
- en: 'LU factorization is a way to organize the classical Gauss elimination method
    in such a way that the computation is done in two steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: LU 分解是将经典的 Gauss 消元法组织成两步计算的方式：
- en: A factorization step of the matrix *A* to get matrices in triangular form
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵 *A* 分解以得到三角矩阵的步骤
- en: A relatively cheap backward and forward elimination step that works on the *b[i]*'s
    and benefits from the more time-consuming factorization step
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相对便宜的向后和向前消除步骤，它作用于 *b[i]* 并从更耗时的分解步骤中受益
- en: The method also uses the fact that if *P* is a permutation matrix such that
    *PA* is the original matrix with its rows permuted.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还利用了如果 *P* 是一个排列矩阵，使得 *PA* 是通过行排列的原始矩阵这一事实。
- en: The two systems
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个系统
- en: '![Solving several linear equation systems with LU](img/permutation.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![使用LU分解求解多个线性方程组](img/permutation.jpg)'
- en: have the same solution.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同的解。
- en: '*LU* factorization finds a permutation matrix *P*, a lower triangular matrix
    *L,* and an upper triangular matrix *U* such that:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*LU* 分解找到一个置换矩阵 *P*，一个下三角矩阵 *L*，和一个上三角矩阵 *U*，使得：'
- en: '![Solving several linear equation systems with LU](img/permutation2.jpg) .'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用LU分解求解多个线性方程组](img/permutation2.jpg) .'
- en: Such a factorization always exists. Furthermore, *L* can be determined in such
    a way that *L[ii] = 1*. Thus, the essential data from *L* that has to be stored
    is *L[ij]* with *i > j*. Consequently, *L* and *U* can be stored together in an
    *n* × *n* array, while the information about the permutation matrix *P* just requires
    an *n* integer vector – the pivot vector.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的分解总是存在的。此外，*L* 可以这样确定，使得 *L[ii] = 1*. 因此，必须存储的 *L* 的基本数据是 *L[ij]*，其中 *i >
    j*. 因此，*L* 和 *U* 可以存储在一个 *n* × *n* 数组中，而关于置换矩阵 *P* 的信息只需要一个 *n* 整数向量——主元向量。
- en: 'In SciPy, there are two methods to compute the *LU* factorization. The standard
    one is `scipy.linalg.lu`, which returns the three matrices `L`, `U`, and `P`.
    The other method is`lu_factor.` That is the method we describe here, because it
    will be conveniently used later in combination with `lu_solve`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SciPy 中，有两种方法来计算 *LU* 分解。标准的方法是 `scipy.linalg.lu`，它返回三个矩阵 `L`、`U` 和 `P`。另一种方法是
    `lu_factor.` 那是我们在这里描述的方法，因为它将方便地与 `lu_solve` 结合使用：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, the `A` matrix is factorized and an array with the information about
    `L` and `U` is returned, together with the pivot vector. With this information,
    the system can be solved by performing row interchanges of the vectors *b[i]*
    according to the information stored in the pivot vector, backward substitution
    using *U,* and finally forward substitution using *L*. This is bundled in Python,
    in the `lu_solve` method. The following code snippet shows how the system *Ax[i]
    = b[i]* is solved once the *LU* factorization is performed and its results stored
    in the tuple `(LU, piv)`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`A` 矩阵被分解，并返回一个包含关于 `L` 和 `U` 的信息的数组，以及主元向量。有了这些信息，可以通过根据主元向量中存储的信息进行向量 *b[i]*
    的行交换，使用 *U* 进行回代，最后使用 *L* 进行前向代换来求解系统。这被捆绑在 Python 的 `lu_solve` 方法中。以下代码片段显示了在执行
    *LU* 分解并将结果存储在元组 `(LU, piv)` 中后，如何求解系统 *Ax[i] = b[i]*：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Solving a least square problem with SVD
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用奇异值分解求解最小二乘问题
- en: 'A linear equation system *Ax = b*, with *A* being an *m* × *n* matrix and *m*
    > *n*, is called an overdetermined linear system. In general it has no classical
    solution and one seeks a vector *x** ![Solving a least square problem with SVD](img/in.jpg) 
    ℝ^(*n*) with the property:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程组 *Ax = b*，其中 *A* 是一个 *m* × *n* 矩阵且 *m* > *n*，被称为超定线性方程组。一般来说，它没有经典解，人们寻求一个向量
    *x** ![使用奇异值分解求解最小二乘问题](img/in.jpg)  ℝ^(*n*)，它具有以下性质：
- en: '![Solving a least square problem with SVD](img/B05511_04_08.900.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![使用奇异值分解求解最小二乘问题](img/B05511_04_08.900.jpg)'
- en: Here, ![Solving a least square problem with SVD](img/norm.jpg) denotes the Euclidean
    vector norm ![Solving a least square problem with SVD](img/B05511_04_09.jpg).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里， ![使用奇异值分解求解最小二乘问题](img/norm.jpg) 表示欧几里得向量范数 ![使用奇异值分解求解最小二乘问题](img/B05511_04_09.jpg).
- en: This problem is called a least square problem. A stable method to solve it is
    based on factorizing *A = U*Σ*V^T*, with *U* being a *m* × *m* orthogonal matrix,
    *V* a *n* × *n* orthogonal matrix, and Σ = (σ[*ij*]) an *m* × *n* matrix with
    the property σ[*ij*] = 0 for all *i* ≠*j*. This factorization is called a **singular
    value decomposition** (**SVD**).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题被称为最小二乘问题。解决它的一个稳定方法是基于分解 *A = U*Σ*V^T*，其中 *U* 是一个 *m* × *m* 正交矩阵，*V* 是一个
    *n* × *n* 正交矩阵，Σ = (σ[*ij*]) 是一个 *m* × *n* 矩阵，其性质是 σ[*ij*] = 0 对于所有 *i* ≠*j*。这种分解被称为**奇异值分解**(**SVD**)。
- en: We write,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写，
- en: '![Solving a least square problem with SVD](img/B05511_04_10.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![使用奇异值分解求解最小二乘问题](img/B05511_04_10.jpg)'
- en: with a diagonal *n* × *n* matrix Σ[*1*]. If we assume that *A* has full rank,
    then Σ[*1*]  is invertible and it can be shown that, ![Solving a least square
    problem with SVD](img/B05511_04_11.jpg). If we split *U* = [*U[1] U[2]*] with
    *U[1]* being an *m* × *n* submatrix, then the preceding equation can be simplified
    to ![Solving a least square problem with SVD](img/B05511_04_12.jpg).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对角线 *n* × *n* 矩阵 Σ[*1*]. 如果我们假设 *A* 具有满秩，那么 Σ[*1*]  是可逆的，并且可以证明，![使用奇异值分解求解最小二乘问题](img/B05511_04_11.jpg). 如果我们把
    *U* = [*U[1] U[2]*] 分解，其中 *U[1]* 是一个 *m* × *n* 子矩阵，那么前面的方程可以简化为![使用奇异值分解求解最小二乘问题](img/B05511_04_12.jpg).
- en: 'SciPy provides a function called `svd`, which we use to solve this task:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy提供了一个名为`svd`的函数，我们用它来解决这个问题：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The keyword `full_matrices` says that only the portion *U[1]* of *U* needs to
    be computed. As one often uses `svd` to compute only singular values, σ[*ii*],
    we have to explicitly demand the computation of *U* and *V* by using the keyword
    `compute_uv`. The SciPy function `scipy.linalg.lstsq` solves the least square
    problem similarly by using a singular value decomposition.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`full_matrices`表示只需要计算*U*的*U[1]*部分。由于经常使用`svd`来计算仅奇值σ[*ii*]，我们必须明确要求通过使用关键字`compute_uv`来计算*U*和*V*。SciPy函数`scipy.linalg.lstsq`通过使用奇异值分解以类似的方式解决最小二乘问题。
- en: More methods
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多方法
- en: 'In the examples so far, you met a couple of methods for computational tasks
    in linear algebra, for example, `solve`. Most common methods are available after
    the command `import scipy.linalg as sl` is executed. We refer to their documentation
    for further reference. Some linear algebra functions of the `scipy.linalg` module
    are given in the following table (*Table 4.6*):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，你遇到了线性代数中计算任务的几种方法，例如，`solve`。在执行命令`import scipy.linalg as sl`之后，大多数常用方法都可用。我们参考它们的文档以获取更多信息。以下表格（*表4.6*）给出了`scipy.linalg`模块的一些线性代数函数：
- en: '| **Methods** | **Description (matrix methods)** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述（矩阵方法）** |'
- en: '| `sl.det` | Determinant of a matrix |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `sl.det` | 矩阵行列式 |'
- en: '| `sl.eig` | Eigenvalues and eigenvectors of a matrix |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `sl.eig` | 矩阵的特征值和特征向量 |'
- en: '| `sl.inv` | Matrix inverse |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `sl.inv` | 矩阵逆 |'
- en: '| `sl.pinv` | Matrix pseudoinverse |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `sl.pinv` | 矩阵伪逆 |'
- en: '| `sl.norm` | Matrix or vector norm |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `sl.norm` | 矩阵或向量范数 |'
- en: '| `sl.svd` | Singular value decomposition |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `sl.svd` | 矩阵奇异值分解 |'
- en: '| `sl.lu` | LU decomposition |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `sl.lu` | LU分解 |'
- en: '| `sl.qr` | QR decomposition |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `sl.qr` | QR分解 |'
- en: '| `sl.cholesky` | Cholesky decomposition |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `sl.cholesky` | Cholesky分解 |'
- en: '| `sl.solve` | Solution of a general or symmetric linear system: *Ax = b* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `sl.solve` | 解一般或对称线性系统：*Ax = b* |'
- en: '| `sl.solve.banded` | The same for banded matrices |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `sl.solve.banded` | 同样适用于带状矩阵 |'
- en: '| `sl.lstsq` | Least squares solution |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `sl.lstsq` | 最小二乘解 |'
- en: 'Table 4.6: Linear algebra functions of the **scipy.linalg** module'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.6：**scipy.linalg**模块的线性代数函数
- en: Execute `import scipy.linalg as sl` first.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行`import scipy.linalg as sl`。
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we worked with the most important objects in linear algebra
    – vectors and matrices. For this, we learned how to define arrays and we met important
    array methods. A smaller section demonstrated how to use modules from `scipy.linalg`
    to solve central tasks in linear algebra.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了线性代数中最重要的对象——向量和矩阵。为此，我们学习了如何定义数组，并遇到了重要的数组方法。一小节展示了如何使用`scipy.linalg`模块中的模块来解决线性代数中的核心任务。
- en: Exercises
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Ex. 1** → Consider a 4 × 3 matrix *M*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**例1** → 考虑一个4 × 3矩阵*M*：'
- en: '![Exercises](img/B05511_04_13..jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_04_13..jpg)'
- en: Construct this matrix in Python using the function `array` .
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数`array`在Python中构建此矩阵。
- en: Construct the same matrix using the function `arange`  followed by a suitable
    reshape.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数`arange`后跟适当的reshape构建相同的矩阵。
- en: What is the result of the expression `M[2,:]` ? What is the result of the similar
    expression `M[2:]`?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式`M[2,:]`的结果是什么？类似的表达式`M[2:]`的结果是什么？
- en: '**Ex. 2** → Given a vector *x*, construct in Python the following matrix:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**例2** → 给定一个向量*x*，在Python中构建以下矩阵：'
- en: '![Exercises](img/B05511_04_14.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_04_14.jpg)'
- en: 'Here, *x[i]* are the components of the vector *x* (numbered from zero). Given
    a vector *y*, solve in Python the linear equation system *Va = y*. Let the components
    of *a* be denoted by *a[i], i = 0, ..., 5*. Write a function `poly`, which has
    *a* and *z* as input and which computes the polynomial:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*x[i]*是向量*x*的分量（从零开始编号）。给定一个向量*y*，在Python中求解线性方程组*Va = y*。设*a*的分量表示为*a[i]，i
    = 0, ..., 5*。编写一个名为`poly`的函数，该函数以*a*和*z*作为输入，并计算多项式：
- en: '![Exercises](img/B05511_04_15-1.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05511_04_15-1.jpg)'
- en: 'Plot this polynomial and depict in the same plot the points (*x[i]*, *y[i]*)
    as small stars. Try your code with the vectors:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这个多项式，并在同一张图上描绘点（*x[i]*，*y[i]*）作为小星星。尝试使用以下向量：
- en: '*x = (0.0, 0.5, 1.o, 1.5, 2.0, 2.5)*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x = (0.0, 0.5, 1.0, 1.5, 2.0, 2.5)*'
- en: '*y = (-2.0, 0.5, -2.0, 1.0, -0.5, 1.0)*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y = (-2.0, 0.5, -2.0, 1.0, -0.5, 1.0)*'
- en: '**Ex. 3** → The matrix *V* in *Ex. 2* is called a Vandermonde matrix. It can
    be set up in Python directly by the command `vander`. Evaluating a polynomial
    defined by a coefficient vector can be done with the Python command `polyval`.
    Repeat *Ex. 2* by using these commands.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 3** → *Ex. 2* 中的矩阵 *V* 被称为范德蒙德矩阵。可以直接使用命令 `vander` 在 Python 中设置它。通过 Python
    命令 `polyval` 计算由系数向量定义的多项式。通过使用这些命令重复 *Ex. 2*。'
- en: '**Ex. 4** → Let *u* be a one dimensional array. Construct another array ξ with
    values ξ*[i] = (u[1] + u[i+1] + u[i+2])/3*. In statistics, this array is called
    the moving average of *u*. In approximation theory, it plays the role as the Greville
    abscissae of cubic splines. Try to avoid the use of for loops in your script.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 4** → 设 *u* 为一维数组。构造另一个数组 ξ，其值为 ξ*[i] = (u[1] + u[i+1] + u[i+2])/3*。在统计学中，这个数组被称为
    *u* 的移动平均。在逼近理论中，它扮演着三次样条的重格林斯比斯的角色。尝试在脚本中避免使用循环。'
- en: '**Ex. 5** →'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 5** →'
- en: Construct from the matrix *V* given in *Ex. 2* a matrix *A* by deleting *V*'s
    first column.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *Ex. 2* 中给出的矩阵 *V* 中删除 *V* 的第一列，构建一个矩阵 *A*。
- en: Form the matrix *B = (A^T A)^(-1) A^T*.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造矩阵 *B = (A^T A)^(-1) A^T*。
- en: Compute *c = B y* with *y* from *Ex. 2*.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *y* 从 *Ex. 2* 中计算 *c = B y*。
- en: Use *c* and `polyval` to plot the polynomial defined by *c*. Plot in the same
    picture again the points (*x[i]*, *y[i]*).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *c* 和 `polyval` 绘制由 *c* 定义的多项式。再次在同一张图中绘制点 (*x[i]*, *y[i]*)。
- en: '**Ex. 6** → *Ex. 5* describes the least square method. Repeat that exercise
    but use SciPy''s `scipy.linalg.lstsq` method instead.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 6** → *Ex. 5* 描述了最小二乘法。重复该练习，但使用 SciPy 的 `scipy.linalg.lstsq` 方法。'
- en: '**Ex. 7** → Let *v* be a vector written in its coordinate form as a 3 × 1 matrix
    [1 -1 1]*^T*. Construct the projection matrices:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 7** → 设 *v* 为一个以 3 × 1 矩阵 [1 -1 1]*^T* 的坐标形式写成的向量。构建投影矩阵：'
- en: '![Exercises](img/projection.jpg).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![Exercises](img/projection.jpg)。'
- en: Show experimentally that *v* is an eigenvector for both matrices *P* and *Q*.
    What are the corresponding eigenvalues?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实验证明 *v* 是矩阵 *P* 和 *Q* 的特征向量。相应的特征值是什么？
- en: '**Ex. 8** → In numerical linear algebra the *m* × *m* matrix *A* with the property'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ex. 8** → 在数值线性代数中，具有该性质的 *m* × *m* 矩阵 *A*：'
- en: '![Exercises](img/B05511_04_17.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![Exercises](img/B05511_04_17.jpg)'
- en: is used as an example for an extreme growth-factor, when performing *LU* factorization.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行 *LU* 分解时，被用作极端增长因子的例子。
- en: Set up this matrix in Python for various *m*, compute its *LU* factorization
    using the command `scipy.linalg.lu` and derive experimentally a statement about
    the growth factor
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中设置这个矩阵，对于各种 *m*，使用命令 `scipy.linalg.lu` 计算其 *LU* 分解，并通过实验推导出关于增长因子的陈述。
- en: '![Exercises](img/B05511_04_18.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![Exercises](img/B05511_04_18.jpg)'
- en: in relation to m.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *m* 相关。
