<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flask and GeoAlchemy2</h1>
                </header>
            
            <article>
                
<p class="mce-root">Python has always had strong internet capabilities. The standard library includes models for HTTP processing, STMP messages, and URL requests. Thousands of third-party modules have been written to extend or improve the built-in web functionality. Over time, a few modules coalesced into Python web frameworks—code libraries written to manage the creation and maintenance of complex and dynamic websites.</p>
<p class="mce-root">To better understand how to use a Python web framework and how to add geospatial capabilities, we'll implement the Flask <span><strong>Model View Controller</strong> (<strong>MVC</strong>) </span>framework. A pure Python web framework, Flask can be combined with SQLAlchemy, GeoAlchemy2, and the Jinja2 HTML template system to create geospatially-enabled web pages.</p>
<p class="mce-root">In this chapter, you will learn about:</p>
<ul>
<li class="mce-root">The Flask web framework</li>
<li class="mce-root">SQLAlchemy database management</li>
<li class="mce-root">GeoAlchemy2</li>
<li class="mce-root">Connecting to PostGIS using <span>o</span><span>bject-relational mapping (ORM)</span></li>
<li class="mce-root">The Jinja2 web page template system</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Flask and its component modules</h1>
                </header>
            
            <article>
                
<p class="mce-root">Flask, as opposed to Django and GeoDjango (covered in <a href="a91ad85f-494d-4cc3-952f-d39a8933758e.xhtml">Chapter 12</a>, <em>GeoDjango</em>), does not include batteries. Instead, it allows a number of supporting modules to be installed as needed. This gives more freedom to you as the programmer, but it also makes it necessary to install the required components separately.</p>
<p class="mce-root">I've chosen some modules for this chapter that will allow us to create a Flask application with a geospatial component. The following sections will detail how to set up, install, and utilize these modules to generate a website, using a demonstration site with a PostGIS database backend (as covered in <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>) and the ability to perform spatial queries through a web-based interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setup</h1>
                </header>
            
            <article>
                
<p class="mce-root">A number of important Python modules must be in place to ensure that the Flask application and its connection to the PostgreSQL and PostGIS database components, will run as required. These modules will be downloaded and installed using <kbd>pip</kbd>, which connects to the <strong>Python Package Index</strong> (<strong>PyPI</strong>), an online repository of registered modules located at <a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>.</p>
<p class="mce-root">These modules include:</p>
<ul>
<li class="mce-root">Flask, a pure Python MVC web framework (<a href="http://flask.pocoo.org/">http://flask.pocoo.org/</a>).</li>
<li class="mce-root">Flask-SQLAlchemy, a database ORM module that can connect to a multitude of database backends (<a href="http://flask-sqlalchemy.pocoo.org/2.3/">http://flask-sqlalchemy.pocoo.org/2.3/</a>). This module installs SQLAlchemy.</li>
<li class="mce-root">GeoAlchemy2, a Python module that builds on the SQLAlchemy module and the Postgres/PostGIS backend (covered in <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>), is used to allow for geospatial data columns and ORM spatial queries (<a href="https://geoalchemy-2.readthedocs.io/en/latest/">https://geoalchemy-2.readthedocs.io/en/latest/</a>).</li>
<li class="mce-root">Flask-WTForms, a web form module built on the WTForms (<a href="https://wtforms.readthedocs.io/en/latest/">https://wtforms.readthedocs.io/en/latest/</a>) that allows for Flask to carry the logic of each web page and to process the inputs (<a href="https://flask-wtf.readthedocs.io/en/stable/">https://flask-wtf.readthedocs.io/en/stable/</a>).</li>
<li>SQLAlchemy-Utils, used to manage database creation and deletion (<a href="https://github.com/kvesteri/sqlalchemy-utils/">https://github.com/kvesteri/sqlalchemy-utils/</a>).</li>
<li class="mce-root"><kbd>psycopg2</kbd>, used to create connections to the PostgreSQL database and is used by the SQLAlchemy module (<a href="http://initd.org/psycopg/">http://initd.org/psycopg/</a>).</li>
<li class="mce-root"><kbd>pyshapefile</kbd> (or <kbd>pyshp</kbd>), used to read the shapefiles used in this example and add it to the database tables (<a href="https://pypi.python.org/pypi/pyshp">https://pypi.python.org/pypi/pyshp</a>).</li>
<li class="mce-root">Finally, <kbd>pygeoif</kbd> (<a href="https://pypi.python.org/pypi/pygeoif">https://pypi.python.org/pypi/pygeoif</a>) is used to allow for the conversion of data from a shapefile binary encoding to a <strong>well-known text</strong> (<strong>WKT</strong>) encoding, for insertion of geometry data into the database.</li>
</ul>
<p class="mce-root">Other important supporting modules are automatically installed along with Flask and the preceding modules, including the Jinja2 templating system (<a href="http://jinja.pocoo.org/">http://jinja.pocoo.org/</a>) and the Werkzeug <strong>Web Server Gateway Interface</strong> (<strong>WSGI</strong>) module (<a href="http://werkzeug.pocoo.org/">http://werkzeug.pocoo.org/</a>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing modules using pip</h1>
                </header>
            
            <article>
                
<p class="mce-root">If you have multiple versions of Python installed on your machine and you're not using a virtual environment with the <kbd>virtualenv</kbd> module, ensure that the <kbd>pip</kbd> version being called with the command line is the Python 3 version using the <kbd>pip -V</kbd> option:</p>
<pre class="mce-root"><strong> C:\Python36\Scripts&gt;pip -V</strong><br/> <strong>pip 9.0.1 from c:\python36\lib\site-packages (python 3.6)</strong></pre>
<p class="mce-root">Once it is clear that the correct <kbd>pip</kbd> is being called from the command line, the modules can be installed. Let's walk through the required <kbd>pip</kbd> commands and some examples of the expected output that each command will generate.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Flask using pip</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, install the Flask module itself. Use the <kbd>pip</kbd> command <kbd>pip install flask</kbd>:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install flask</strong></pre>
<p><span>The <kbd>pip</kbd> will find Flask and its required dependencies on PyPI and will then run the included </span><kbd>setup.py</kbd><span> instructions (or the equivalent) to install the modules:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/22176846-a3f1-4e2d-a648-f807ca651a8d.png" width="1197" height="428"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Flask-SQLAlchemy via pip</h1>
                </header>
            
            <article>
                
<p class="mce-root">Use the command <kbd>pip install flask-sqlalchemy</kbd> to install the <kbd>flask-sqlalchemy</kbd> wheel and its required dependencies:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install flask-sqlalch</strong><strong>emy</strong></pre>
<p>The install command will find the <kbd>flask-sqlalchemy</kbd> wheel file (a pre-built file type used by <kbd>pip</kbd> to install modules) on PyPI and run the installation process: </p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/dcee7274-f35b-44f2-952c-4305f5475864.png" width="1330" height="469"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing GeoAlchemy2 using pip</h1>
                </header>
            
            <article>
                
<p class="mce-root">Use the command <kbd>pip install GeoAlchemy2</kbd> to call the module from PyPI, download the wheel file, and install it into the <kbd>Lib</kbd>/<kbd>site-packages</kbd> folder of the Python installation:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install <span>GeoAlchemy2</span></strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing Flask-WTForms and WTForms using pip</h1>
                </header>
            
            <article>
                
<p>With the WTForms module and the Flask-WTF interface, we can create the web forms that will make the webpage interactive. Install it using the <kbd>pip install flask-wtf</kbd> command:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install flask-wtf</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing psycopg2 using pip</h1>
                </header>
            
            <article>
                
<p>The <kbd>pscycopg2</kbd> is a Python module used to connect to PostgreSQL databases. If it is not installed yet (see <a href="4f2388a3-51fc-419f-a827-bbbedbbb6374.xhtml">Chapter 7</a>, <em>Geoprocessing with Geodatabases</em>), i<span>nstall it using the <kbd>pip install psycopg2</kbd></span> command:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install psycopg2</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing SQLAlchemy-Utils using pip</h1>
                </header>
            
            <article>
                
<p>These utilities allow for quick database creation:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install sqlalchemy-utils</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing pyshapefile (or pyshp) using pip</h1>
                </header>
            
            <article>
                
<p>The <kbd>pyshapefile</kbd> module can read and write shapefiles:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install pyshp</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing pygeoif using pip</h1>
                </header>
            
            <article>
                
<p>The <kbd>pygeoif</kbd> module allows for geospatial data format conversion:</p>
<pre class="mce-root"><strong>C:\Python36\Scripts&gt;pip install pygeoif</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a Flask application</h1>
                </header>
            
            <article>
                
<p class="mce-root">To explore the basics of Flask and GeoAlchemy2, we'll build a Flask web application and test and deploy it locally using the included web server. This web application allows the user to find the county, state, and congressional district associated with different arena's located throughout the country. This application will involve downloading shapefiles from a <strong>United States Geological Survey</strong> (<strong>USGS</strong>) data catalog and will have views (Python functions that process web requests) performing geospatial queries using the GeoAlchemy2 ORM and table relationship searches using the SQLAlchemy ORM.</p>
<p>This application requires the use of two scripts that create the database and database tables. These scripts are detailed as we proceed further and are in the <kbd>Chapter11</kbd> folder of the book's code package. The final product will be a web application that uses a <kbd>Leaflet</kbd> JavaScript map to display the results of ORM-based spatial queries and a relationship query.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Downloading the data from a data source</h1>
                </header>
            
            <article>
                
<p class="mce-root">To start this project, let's download data from the USGS data catalog. This project will use four US-based shapefiles—an NBA arena shapefile, a states shapefile, a congressional districts shapefile, and a counties shapefile.</p>
<div class="mce-root packt_infobox">The USGS has a lot of USA shapefiles for download available here: <a href="https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20">https://www.sciencebase.gov/catalog/item/503553b3e4b0d5ec45b0db20</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">County, district, state, and arena shapefiles</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>US_County_Boundaries</kbd> data is a polygon shapefile available from the USGS data catalog at this address: <a href="https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738">https://www.sciencebase.gov/catalog/item/4f4e4a2ee4b07f02db615738</a>.</p>
<p class="mce-root">Click on the download zip link, as shown in the image. Unzip the file into a project folder (for example, <kbd>C:\GeospatialPy3\Chapter11</kbd>) so it can be accessed throughout the chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/4b1862b4-a369-41a9-80dd-7d08f08e80a3.png" width="769" height="200"/></div>
<p class="mce-root">The <kbd>Arenas_NBA</kbd> shapefile is available here: <a href="https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d">https://www.sciencebase.gov/catalog/item/4f4e4a0ae4b07f02db5fb54d</a>.</p>
<p class="mce-root">The <kbd>Congressional_Districts</kbd> shapefile is available here: <a href="https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58">https://www.sciencebase.gov/catalog/item/4f4e4a06e4b07f02db5f8b58</a>.</p>
<p class="mce-root">The <kbd>US_States</kbd> shapefile is available here: <a href="https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce">https://www.sciencebase.gov/catalog/item/4f4e4783e4b07f02db4837ce</a>.</p>
<p class="mce-root">These shapefiles are not current (for example, the Nets arena is still listed as being in New Jersey and not in Brooklyn), but it's the application techniques that we're exploring here (and how they deal with geometry data types) and not the data itself, so ignore the temporal quality of the data.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the database and data tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create our database and the tables that will hold the application data, we will use the SQLAlchemy and GeoAlchemy2 classes and methods. The following code is in the script called <kbd>Chapter11_0.py</kbd>. This code will allow us to connect to a PostgreSQL data server to create a database and data tables that will form the backend of the web application. Import these libraries:</p>
<pre class="mce-root">from sqlalchemy import create_engine<br/>from sqlalchemy_utils import database_exists, create_database,<br/>                             drop_database<br/>from sqlalchemy import Column, Integer, String, ForeignKey, Float<br/>from sqlalchemy.orm import relationship<br/>from <strong>geoalchemy2</strong> import <strong>Geometry</strong><br/>from sqlalchemy.ext.declarative import declarative_base</pre>
<p class="mce-root">Connecting the database server to both generate and query the data tables is achieved using the <kbd>create_engine</kbd> function and the connection string format, demonstrated as follows:</p>
<pre class="mce-root"><strong>conn_string</strong> = '{DBtype}://{user}:{pword}@{instancehost}:{port}/{database}'<br/>engine = <strong>create_engine</strong>(<strong>conn_string</strong>, echo=True)</pre>
<p class="mce-root">Connection strings are used throughout all Python database modules. They usually include a specification of the <strong><span>relational database management system</span></strong> (<strong>RDBMS</strong>) type, the username, the password, the instance host (that is the IP address or <kbd>localhost</kbd> for a database server installed on the local machine), an optional port number, and a database name. For example, a connection string might look like this:</p>
<pre class="mce-root">connstring = 'postgresql://postgres:bond007@localhost:5432/chapter11'<br/>engine = create_engine(connstring, echo=True)</pre>
<p class="mce-root">In this example, <kbd>postgresql</kbd> is the RDBMS type, <kbd>postgres</kbd> is the user, <kbd>bond007</kbd> is the password, <kbd>localhost</kbd> is the instance host, <kbd>5432</kbd> is the port (and the default port for PostgreSQL installations; if the port wasn't changed on installation, it can be left out of the connection string), and <kbd>chapter11</kbd> is the name of the database. The <kbd>echo=True</kbd> statement is used to generate logs of the database interactions to the standard output window. To turn these messages off, change the echo value to <kbd>False</kbd>.</p>
<div class="mce-root packt_infobox">A more thorough explanation of this pattern can be found here: <a href="http://docs.sqlalchemy.org/en/latest/core/engines.html">http://docs.sqlalchemy.org/en/latest/core/engines.html</a>.</div>
<p class="mce-root">For our database, we can use the following format. Replace <kbd>{user}</kbd> and <kbd>{pword}</kbd> (including the brackets) with your PostgreSQL server username and password:</p>
<pre class="mce-root">conn_string ='postgresql://<strong>{user}</strong>:<strong>{pword}</strong>@localhost:5432/chapter11'<br/>engine = create_engine(conn_string, echo=True)</pre>
<p class="mce-root">If the connection string is valid, the <kbd>create_engine</kbd> function will return an object to the <kbd>engine</kbd> variable, which will be used to perform database interactions throughout the script.</p>
<p class="mce-root">The code in the comment (<kbd>#drop_database(engine.url)</kbd>) is commented out but can be uncommented if the database needs to be dropped and then recreated using the script. It calls the SQLAlchemy create_engine's <kbd>url</kbd> property, which is a reference to the connection string:</p>
<pre class="mce-root"># Uncomment the line below if you need to recreate the database.<br/>#drop_database(engine.url)</pre>
<p class="mce-root">The database and the data tables it will contain is created within an <kbd>if not</kbd> conditional that relies on the <kbd>database_exists</kbd> function. If the conditional returns <kbd>True</kbd> (indicating that the database does not exist), the <kbd>engine</kbd> variable is passed to the <kbd>create_database</kbd> function:</p>
<pre class="mce-root"># Check to ensure that the database doesn't exist<br/># If it doesn't, create it and generate the PostGIS extention and tables<br/>if not database_exists(engine.url):<br/>    create_database(engine.url)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding the PostGIS extension tables to the new database</h1>
                </header>
            
            <article>
                
<p class="mce-root">Just underneath the <kbd>create_database</kbd> function, we will need to connect to the database using the <kbd>engine.connect</kbd> function to pass an SQL statement directly to the database. This SQL statement, <kbd>("CREATE EXTENSION postgis<em>"</em>)</kbd> enables spatial columns and queries within the new database:</p>
<pre class="mce-root">    # Create a direct connection to the database using the engine.<br/>    # This will allow the new database to use the PostGIS extension.<br/>    conn = engine.connect()<br/>    conn.execute("commit")<br/>    try:<br/>         conn.execute("CREATE EXTENSION postgis")<br/>     except Exception as e:<br/>         print(e)<br/>         print("extension postgis already exists")<br/>     conn.close()</pre>
<p class="mce-root">A <kbd>try</kbd>/<kbd>except</kbd> block is used here in case the database has already been spatially enabled. Check the output from the <kbd>print</kbd> statements to ensure that no other exception occurs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining the database tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">Within the world of Python MVC web frameworks, the database tables are the <strong>models</strong>. Used by the website to store data, they are generated with and modeled by Python classes. These classes subclass or inherit pre-written functionality from a superclass that contains a majority of the database management code, leaving us to simply define the columns of the table using basic data types such as strings and integers, as well as advanced classes such as geometries.</p>
<p class="mce-root">These class-defined tables can be generated in multiple RDBMS without the need to revamp how the model code is written. While GeoAlchemy2 only works on top of PostgreSQL/PostGIS, SQLAlchemy models can be used to generate tables in a variety of databases, including SQL Server, Oracle, Postgres, MySQL and more.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The declarative base</h1>
                </header>
            
            <article>
                
<p class="mce-root">For SQLAlchemy database classes, a base class called the <kbd>declarative_base</kbd> allows for inheritance of database methods and properties (this is where the superclass magic of SQLAlchemy exists, handling database SQL statements in multiple SQL versions, which simplifies the code <span>required to write to any RDBMS</span>):</p>
<pre class="mce-root">    # Define the model Base<br/>    Base = declarative_base()</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Database table model classes </h1>
                </header>
            
            <article>
                
<p class="mce-root">Once the base has been called or instantiated, it can be passed to the model classes. These classes, like all Python classes, could include functions, properties, and methods which are useful for processing data internally to the class. In this chapter, the models do not include any internal functions, but instead only define columns. </p>
<div class="packt_infobox">Explore SQLAlchemy models and their internal functions here: <a href="http://docs.sqlalchemy.org/en/latest/orm/tutorial.html">http://docs.sqlalchemy.org/en/latest/orm/tutorial.html</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Table properties</h1>
                </header>
            
            <article>
                
<p class="mce-root">The name of the data table generated in the RDBMS database will correspond to the <kbd>__tablename__</kbd> property of a model class. The primary key for each table is used for relationships and queries and must be defined using the keyword <kbd>primary_key</kbd>. The <kbd>Column</kbd> class and the <kbd>String</kbd>, <kbd>Float</kbd> and <kbd>Integer</kbd> type classes are called from SQLAlchemy and are used to define table columns to be generated within the underlying RDBMS (thus allowing the programmer to avoid crafting <kbd>CREATE TABLE</kbd> statements for each variety of SQL used by the major RDBMS).</p>
<p class="mce-root">For example, the <kbd>Arena</kbd> class will be used to manage a table that has four columns—a <kbd>String</kbd> <kbd>name</kbd> field, two <kbd>Float</kbd> fields (<kbd>longitude</kbd> and <kbd>latitude</kbd>), and a <kbd>POINT</kbd> geometry type with an SRID or EPSG spatial reference system ID of <kbd>4326</kbd>, corresponding to the WGS 1984 coordinate system (<a href="http://spatialreference.org/ref/epsg/wgs-84/">http://spatialreference.org/ref/epsg/wgs-84/</a>):</p>
<pre class="mce-root">    # Define the Arena class, which will model the Arena database table<br/>    class Arena(Base):<br/>        __tablename__ = 'arena'<br/>       id = Column(Integer, primary_key=True)<br/>       name = Column(String)<br/>       longitude = Column(Float)<br/>       latitude = Column(Float)<br/>       geom = Column(Geometry(geometry_type='POINT', srid=4326))</pre>
<p class="mce-root">Like the <kbd>Arena</kbd> class, the following classes use a <kbd>String</kbd> <kbd>name</kbd> column. For the geometry type, they also use SRID <kbd>4326</kbd>, but they use the <kbd>MULTIPOLYGON</kbd> geometry type to store the complex multipolygon geometries used to model these geographies. For tables with relationships, as in the case of the <kbd>County</kbd>, <kbd>District</kbd>, and <kbd>State</kbd> classes, there are also special classes used to manage table relationships and queries between tables.</p>
<p class="mce-root">These special classes include the <kbd>ForeignKey</kbd> class and the <kbd>relationship</kbd> function. The <kbd>ForeignKey</kbd> class is passed an <kbd>id</kbd> parameter and passed to a <kbd>Column</kbd> class, associating the child row's with the parent. The <kbd>relationship</kbd> function allows two-way queries. The <kbd>backref</kbd> keyword generates a function that instantiates an instance of the joined table's model:</p>
<pre class="mce-root">    # Define the County class<br/>    class County(Base):<br/>        __tablename__ = 'county'<br/>        id = Column(Integer, primary_key=True)<br/>        name = Column(String)<br/>        state_id = Column(Integer, ForeignKey('state.id'))<br/>        state_ref = relationship("State",backref='county')<br/>        geom =   Column(Geometry(geometry_type='MULTIPOLYGON',srid=4326))<br/>    <br/>    # Define the District class<br/>    class District(Base):<br/>        __tablename__ = 'district'<br/>        id = Column(Integer, primary_key=True)<br/>        district = Column(String)<br/>        name = Column(String)<br/>        state_id = Column(Integer, ForeignKey('state.id'))<br/>        state_ref = relationship("State",backref='district')<br/>        geom = Column(Geometry(geometry_type='MULTIPOLYGON',srid=4326))<br/>    <br/><br/></pre>
<p><span>The <kbd>County</kbd> class and the <kbd>District</kbd> class will have a <kbd>relationship</kbd> with the <kbd>State</kbd> class, allowing session queries that call the <kbd>State</kbd> class. This <kbd>relationship</kbd> makes it easy to find which US state a county or congressional district is located in. The</span> <kbd>state_id</kbd> <span>column builds the <kbd>relationship</kbd>, and the </span><kbd>state_ref</kbd> <span>field references the parent <kbd>State</kbd> class. For the <kbd>State</kbd> class, the counties and districts have their own</span> <kbd>backref</kbd> re<span>ferences, allowing the parent <kbd>State</kbd> class to access the associated counties/districts:</span></p>
<pre class="mce-root">    # Define the State class<br/>    class State(Base):<br/>        __tablename__ = 'state'<br/>        id = Column(Integer, primary_key=True)<br/>        name = Column(String)<br/>        statefips = Column(String)<br/>        stpostal = Column(String)<br/>        counties = relationship('County', backref='state')<br/>        districts = relationship('District', backref='state')<br/>        geom =         <br/>        Column(Geometry(geometry_type='MULTIPOLYGON',srid=4326))</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">To actually generate the tables, there are two methods that can be used. Table model classes have an internal <kbd>__table__</kbd> method that has a <kbd>create</kbd> function, which can be used to create each table separately. There is also a <kbd>drop</kbd> function that can be called to drop a table.</p>
<p class="mce-root">In the script, we use <kbd>try</kbd><em>/</em><kbd>except</kbd> blocks to generate the tables. If an exception is incurred (that is, if the table already exists), the table is dropped and then created. Here is the <kbd>State</kbd> table creation statement as an example:</p>
<pre class="mce-root">    # Generate the State table from the State class.<br/>    # If it already exists, drop it and regenerate it<br/>    try:<br/>        State.__table__.create(engine)<br/>    except:<br/>        State.__table__.drop(engine)<br/>        State.__table__.create(engine)</pre>
<p class="mce-root">Alternatively, all database tables can be generated from the defined classes using the <kbd>Base</kbd> method <kbd>metadata</kbd> and its <kbd>create_all</kbd> function:</p>
<pre class="mce-root">    Base.metadata.create_all(engine)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inserting data into the new data tables</h1>
                </header>
            
            <article>
                
<p class="mce-root">Once the database has been created and the database tables have been defined and created within the database, the data can be added. A second script, <kbd>Chapter11_1.py</kbd>, will be used to find and read the data contained within the downloaded shapefiles and <kbd>for</kbd> loops will be used to read through the data and write it to the respective database table. An SQLAlchemy session manager will be used to query and commit data to the tables.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Importing the required modules</h1>
                </header>
            
            <article>
                
<p class="mce-root">For the data to be processed and imported, a few new modules will be used. The <kbd>pyshapefile</kbd> module (or <kbd>pyshp</kbd>, imported as shapefile) is used to connect to the shapefiles and to read both the geometries and attribute data that they contain. The <kbd>pygeoif</kbd> module is a pure Python module that implements a protocol known as the <kbd>geo_interface</kbd>.</p>
<p class="mce-root">This protocol allows Python object-level introspection of geospatial data, for example, it converts geospatial data formats into Python objects. It will be used to convert between shapefile geometries stored in binary into WKT geometries that can be inserted into the database using the GeoAlchemy2 ORM:</p>
<pre class="mce-root"># The pyshapefile module is used to read shapefiles and<br/># the pygeoif module is used to convert between geometry types<br/>import shapefile<br/>import pygeoif</pre>
<div class="mce-root packt_tip packt_infobox">More discussion of the <kbd>geo_interface</kbd> protocol is available here: <a href="https://gist.github.com/sgillies/2217756">https://gist.github.com/sgillies/2217756</a>.</div>
<p class="mce-root">To connect to the database and the tables, import the SQLAlchemy ORM and other SQLAlchemy functions:</p>
<pre class="mce-root">from sqlalchemy import create_engine<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy import Column, Integer, String, ForeignKey, Float<br/>from sqlalchemy.orm import sessionmaker<br/>from sqlalchemy.orm import relationship</pre>
<p class="mce-root">To add data to the geometry columns of the database tables, the GeoAlchemy2 <kbd>Geometry</kbd> data type will be used:</p>
<pre class="mce-root"># The Geometry columns from GeoAlchemy2 extend the SQLAlchemy ORM <br/>from geoalchemy2 import Geometry</pre>
<p class="mce-root">To enable the script to find the downloaded shapefiles, use the <kbd>Tkinter</kbd> module and its <kbd>filedialog</kbd> method, as it is built into Python and is OS-agnostic:</p>
<pre class="mce-root"># The built-in Tkinter GUI module allows for file dialogs<br/>from tkinter import filedialog<br/>from tkinter import Tk</pre>
<p class="mce-root">Connections to the database will again be created using the <kbd>create_engine</kbd> function from SQLAlchemy. This section also generates a <kbd>session</kbd> using the session manager, binding it to the <kbd>engine</kbd> variable that connects to the database:</p>
<pre class="mce-root"># Connect to the database called chapter11 using SQLAlchemy functions<br/>conn_string = 'postgresql://postgres:password@localhost/chapter11'<br/>engine = create_engine(conn_string)<br/>Session = sessionmaker(bind=engine)<br/>session = Session()</pre>
<p class="mce-root">The <kbd>session</kbd> will allow for queries and commits (that is, writing to the database) to them being managed. We will need to query against database tables inside the <kbd>for</kbd> loop, to create the database relationships between the counties, districts, and states.</p>
<p class="mce-root">The database table models are again defined within the script, subclassing from the <kbd>declarative_base</kbd> class. These class definitions will match those within the last script.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Locating and reading the shapefiles</h1>
                </header>
            
            <article>
                
<p class="mce-root">To create file dialogs that allow the user to search for and locate shapefiles, Tkinter's <kbd>Tk</kbd> class is instantiated and assigned to the variable <kbd>root</kbd>. The <kbd>Tk</kbd> class creates a small console window that is not necessary, so it is withdrawn using the <kbd>root.withdraw</kbd> method:</p>
<pre class="mce-root"># Initiate the Tkinter module and withdraw the console it generates<br/>root = Tk()<br/>root.withdraw()</pre>
<p class="mce-root">The file dialogs are generated using the <kbd>filedialog.askopenfilename</kbd> method. The method accepts a number of arguments, including the <kbd>title</kbd> of the file dialog window, the initial directory, and the file extensions that should be visible while using the file dialog. Here is the <kbd>Select Arena Shapefile</kbd> dialog code as an example:</p>
<pre class="mce-root"># Navigate to the Arena shapefile using the Tkinter file dialog<br/>root.arenafile = filedialog.askopenfilename(initialdir = "/",<br/>                              title = "Select Arena Shapefile",<br/>                              filetypes = (("shapefiles","*.shp"),<br/>                              ("all files", "*.*")))</pre>
<p class="mce-root">Within the script, this is repeated for each of the downloaded shapefiles. After using the file dialogs, each of the shapefiles located will pass a string type file path to the <kbd>root</kbd> variable and the file path will be held in a property.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing shapefile data</h1>
                </header>
            
            <article>
                
<p class="mce-root">To access the data within the shapefiles, the <kbd>pyshp</kbd> <kbd>Reader</kbd> class is invoked by passing the respective file path property to the <kbd>Reader</kbd> class. The instantiated class will have both <kbd>records</kbd> and a <kbd>shapes</kbd> method, to allow access to the shapefile's attribute data and geometry data respectively:</p>
<pre class="mce-root"># Read the Arena shapefile using the Reader class of the pyshp module<br/>import shapefile<br/>arena_shapefile = shapefile.Reader(root.arenafile)<br/>arena_shapes = arena_shapefile.shapes()<br/>arena_records = arena_shapefile.records()</pre>
<p class="mce-root"><span>Once the data has been read and assigned to</span> iteratable<span> variables, they can be iterated using</span> <kbd>for</kbd> loops<span>. Because the data accessed using the <kbd>pyshp</kbd> <kbd>Reader</kbd></span> <kbd>records</kbd> <span>method corresponds to the data accessed using the</span> <kbd>shapes</kbd> <span>method, a loop counter generated using the</span> <kbd>enumerate</kbd> <span>function is used to match indexes between the current record and the corresponding geometry data in the list of geometries generated by the</span> <kbd>shapes</kbd> <span>method.</span></p>
<p class="mce-root">For the <kbd>Arena</kbd> shapefile geometry, the <kbd>Reader</kbd> <kbd>shapes</kbd> method returns the data as a list with coordinate pairs. As the <kbd>Arena</kbd> class geometry column is a <kbd>POINT</kbd> data type, the data can be written to the database table using a <kbd>POINT(X Y)</kbd> WKT template. The SRID (<kbd>4326</kbd>) is included at the beginning of the string, as per GeoAlchemy2 Extended WKT (EWKT) requirements.</p>
<div class="mce-root packt_infobox">Read more on the GeoAlcheym2 ORM here: <a href="http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html">http://geoalchemy-2.readthedocs.io/en/0.4/orm_tutorial.html</a>.</div>
<p class="mce-root">With each loop, a new <kbd>Arena</kbd> class is instantiated and assigned to the variable <kbd>arena</kbd>. The <kbd>name</kbd> field is extracted from the <kbd>Reader</kbd> <kbd>record</kbd> data item located at index <kbd>6</kbd> and assigned to the <kbd>arena</kbd> variable, while the geometry data is extracted from the <kbd>arena_shapes</kbd> data item at <kbd>count</kbd> (that is, the current loop number) and assigned to the <kbd>Arena</kbd> columns called <kbd>arena.longitude</kbd> and <kbd>arena.latitude</kbd>.</p>
<p class="mce-root">These coordinates are then passed to the string <kbd>format</kbd> method to format the EWKT template and assigned to the <kbd>arena.geom</kbd> property. Once the data for the <kbd>arena</kbd> row has been assigned, it's added to the session using <kbd>session.add</kbd>. Finally, the data is written to the database using the session's <kbd>commit</kbd> method:</p>
<pre class="mce-root"># Iterate through the Arena data read from the shapefile<br/>for count, record in enumerate(arena_records):<br/>    arena = Arena()<br/>    <strong>arena.name = record[6]</strong><br/>    print(arena.name)<br/>    point = arena_shapes[count].points[0]<br/>    arena.longitude = point[0]<br/>    arena.latitude = point[1]<br/>    <strong>arena.geom = 'SRID=4326;POINT({0} {1})'.format(point[0],     <br/>    point[1])</strong><br/><strong>    session.add(arena)</strong><br/><strong>session.commit()</strong></pre>
<p>For the <kbd>State</kbd> class (and the <kbd>County</kbd> and <kbd>District</kbd> classes), the name, <strong>Federal Information Processing Standards</strong> (<strong>FIPS</strong>) code, and postal code abbreviation are extracted from the attribute data using indexing. The <kbd>pygeoif</kbd> is used to convert the geometry first into a <kbd>pygeoif</kbd> <kbd>MultiPolygon</kbd> format and then into WKT, which is passed to a string template and written to the <kbd>geom</kbd> field as EWKT:</p>
<pre class="mce-root"># Iterate through the State data read from the shapefile<br/>for count, record in enumerate(state_records):<br/>    state = State()<br/>    state.name = record[1]<br/>    state.statefips = record[0]<br/>    state.stpostal = record[2]<br/>    state_geo = state_shapes[count]<br/><strong>    gshape =     <br/>    pygeoif.MultiPolygon(pygeoif.geometry.as_shape(state_geo))</strong><br/><strong>    state.geom = 'SRID=4326;{0}'.format(gshape.wkt)</strong><br/>    session.add(state)<br/>    <strong>if count % 10 == 0:</strong><br/><strong>        session.commit()</strong><br/>session.commit()</pre>
<p>Because of the large size of the geometry data for states, they are committed to the database every <kbd>10</kbd> loops. The final <kbd>commit</kbd> catches any remainder.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using queries</h1>
                </header>
            
            <article>
                
<p>For the <kbd>District</kbd> and <kbd>County</kbd> data tables, a final wrinkle is added, querying against the newly added <kbd>state</kbd> data to find the associated state by FIPS code. By querying the <kbd>State</kbd> class using <kbd>session.query</kbd> and filtering the state's data using the <kbd>filter_by</kbd> method (passing the FIPS code from the district records as the <kbd>filter</kbd> argument), and then specifying that the <kbd>first</kbd> result should be used, the correct <kbd>state</kbd> can be called. The variable state's <kbd>id</kbd> field is used to populate the district's <kbd>state_id</kbd> column to create the <kbd>relationship</kbd>:</p>
<pre class="mce-root"># This uses the STFIPS data to query the State table and find the state<br/>for count, record in enumerate(district_records):<br/>    district = District()<br/>    district.district = record[0]<br/>    district.name = record[1]<br/>    <strong>state = session.query(State).filter_by(statefips=record[4]).first()</strong><br/>    <strong>district.state_id = state.id<br/></strong>    dist_geo = district_shapes[count]<br/>    <br/>   gshape=pygeoif.MultiPolygon(pygeoif.geometry.as_shape(dist_geo))<br/>    district.geom = 'SRID=4326;{0}'.format(gshape.wkt)<br/>    session.add(district)<br/>    if count % 50 == 0:<br/>        session.commit()<br/>session.commit()</pre>
<p>The <kbd>County</kbd> table is similarly looped and also includes a <kbd>State</kbd> query. Check the script to see the completed code. Once all of the data has been written to the data tables, <kbd>close</kbd> the session and <kbd>dispose</kbd> of the connection engine:</p>
<pre class="mce-root"> session.close()<br/> engine.dispose()</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Components of the Flask application</h1>
                </header>
            
            <article>
                
<p>Now that the backend database and tables have been created and loaded with data and the relationships between the tables have been modeled and generated, it's time to write the scripts that will create the Flask application. These scripts will contain views, models, and forms that process web requests, query the database, and return an HTTP response.</p>
<p>The web application is called the Arena application, as it lists all of the NBA <kbd>arenas</kbd> stored in the <kbd>arena</kbd> table in a drop-down list, and allows the user to display the location on a map along with a <kbd>popup</kbd> that contains information about the <kbd>arena</kbd> from spatial queries and table relationships.</p>
<p class="mce-root">The MVC method of web development allows for separation between the necessary components of a web application. These components include database models (the SQLAlchemy models described earlier), web forms for accepting application input, and a controller object that routes requests. The separation of components is reflected in the separate scripts. Making each component independent makes it easier to adjust without affecting other components of the application.</p>
<p class="mce-root">The database model will be contained in a script called <kbd>models.py</kbd>, along with the required module imports. The web forms (Python classes that create web page components such as drop-down lists and entry fields) will be contained in a script called <kbd>forms.py</kbd>. All of the views, which include the URL endpoints and the processing of the web requests to those URLs, will be contained within a script called <kbd>views.py</kbd>. </p>
<p class="mce-root"><span>A controller is an object generated from the</span> <kbd>Flask</kbd> class and assigned to the variable called <kbd>app</kbd>. Each URL endpoint of the web application is defined using <kbd>app.route</kbd> and has an associated Python function (the view) that contains the logic to process the web request and return an HTTP response. The controller is used to route web requests to the correct URL endpoint and can distinguish between <kbd>GET</kbd> and <kbd>POST HTTP</kbd> requests. It is created in the <kbd>views.py</kbd> script. </p>
<p class="mce-root"><span>HTML templates are used to present the processed results of a web request. Using the Jinja2 templating system, the data contained within the web forms will be passed to HTML templates and sent back to the requesting web browser as a complete web page. The template for this application contains links to JavaScript libraries, including <kbd>Leaflet</kbd>, which allows the web page to present a map within the web page.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Folder structure and the controller object</h1>
                </header>
            
            <article>
                
<p>To contain the separate components of the application, a specific folder structure is recommended. It will allow for the components to reference each other as needed, while still maintaining independence. Adjustments made to one portion of a component shouldn't require the overhaul of a separated component (at least as much as possible).</p>
<p>The Arena application is contained within a folder called <kbd>arenaapp</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/5c34b72a-3640-46e3-a156-2c8f1d69668b.png" style="width:14.83em;height:13.50em;" width="206" height="186"/></div>
<p>Inside the <kbd>arenaapp</kbd> folder is a script called <kbd>app.py</kbd> and a folder called <kbd>application</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c947cb29-fc9f-4f4d-afaf-5bc9298ebf38.png" style="width:10.50em;height:7.25em;" width="143" height="98"/></div>
<p><span>The</span> <kbd>app.py</kbd> <span>script imports the</span> <kbd>app</kbd> <span>controller object from</span> the <kbd>application</kbd> <span>and calls the</span> <kbd>app.run</kbd> <span>method to start the web application:</span></p>
<pre>from application import app<br/>app.run()</pre>
<p><span>Making the folder</span> <kbd>application</kbd><span> importable and allowing</span> <kbd>app</kbd> <span>access to code inside the component scripts is made possible by adding a Python</span> <kbd>__init__.py</kbd><span> script. This special script indicates to the Python executable that the folder is a module:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f34e301a-ca18-4df3-b8ea-b28e672ab8b1.png" width="151" height="241"/></div>
<p><span>Inside</span> <kbd>__init__.py</kbd>, the <kbd>app</kbd> object is defined and configured. The <kbd>app</kbd> object contains a configuration dictionary that allows the web application to connect to the backend (<kbd>'SQLALCHEMY_DATABASE_URI'</kbd>) and to perform session management and encryption. While we have included the configuration settings within this script, note that larger applications will separate out the configuration settings into a separate <kbd>config.py</kbd> script:</p>
<pre>import flask<br/>app = flask.Flask(__name__)<br/>conn_string = 'postgresql://postgres:password@localhost:5432/chapter11'<br/>app.config['SQLALCHEMY_DATABASE_URI'] = conn_string <br/>app.config['SECRET_KEY'] = "SECRET_KEY"<br/>app.config['DEBUG'] = True<br/>import application.views</pre>
<p><span>To make it easier to debug the application, the <kbd>DEBUG</kbd> configuration has been set to <kbd>True</kbd>. Set it to <kbd>False</kbd> in production. Replace <kbd>'SECRET KEY'</kbd> with your own secret key.</span></p>
<div class="packt_infobox">Read more about configuring a Flask web application here: <a href="http://flask.pocoo.org/docs/latest/config/">http://flask.pocoo.org/docs/latest/config/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Models</h1>
                </header>
            
            <article>
                
<p>For the Arena application, a script called <kbd>models.py</kbd> contains the models that will be used for the application. As described earlier, these models are Python classes that contain database column definitions and can have internal functions for processing data. Our simplified models contain only data column definitions using SQLAlchemy and GeoAlchemy2 classes.</p>
<p>To connect to the database, the <kbd>app</kbd> object is imported. This makes the application configuration variables, including <kbd>app.config['SQLALCHEMY_DATABASE_URI']</kbd> which stores the database connection string, available to the SQLAlchemy <kbd>create_engine</kbd> function:</p>
<pre>from application import app<br/># The database connections and session management are managed with SQLAlchemy functions<br/>from sqlalchemy import create_engine<br/>from sqlalchemy.ext.declarative import declarative_base<br/>from sqlalchemy import Column, Integer, String, ForeignKey, Float<br/>from sqlalchemy.orm import sessionmaker<br/>from sqlalchemy.orm import relationship<br/>from geoalchemy2 import Geometry<br/>engine = create_engine(app.config['SQLALCHEMY_DATABASE_URI'])<br/>Session = sessionmaker(bind=engine)<br/>session = Session()<br/>Base = declarative_base()</pre>
<p>For the sake of brevity, I've skipped detailing the model class definitions here as they were explained previously. Look for them inside the <kbd>arenaapp</kbd>/<kbd>application</kbd> folder's <kbd>models.py</kbd> script.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Forms</h1>
                </header>
            
            <article>
                
<p>Web forms are used in web applications to accept data from a user and send it to the server for validation and processing. To generate the required forms (for example drop-downs, entry fields, and even password fields that hide their contents from the user), the Flask-WTF module and the WTForms module are used. These modules contain classes that make it possible to create the form components and to ensure that the data entered into them is valid for that field.</p>
<p>For our simple application, only one form is created. The <kbd>ArenaForm</kbd> form inherits from the <kbd>FlaskFor</kbd> class and contains a <kbd>description</kbd> attribute and field called <kbd>selections</kbd>. This field is a <kbd>SelectField</kbd>, which will create a drop-down list on the web page. It requires a description string and uses the keyword <kbd>choices</kbd> to generate the list of the choices available in the drop-down list. As the members of the drop-down list will be generated dynamically within the view (explained as follows), an empty list is passed to the <kbd>choices</kbd> keyword here:</p>
<pre>from flask_wtf import FlaskForm<br/>from wtforms import SelectField<br/>class ArenaForm(FlaskForm):<br/>    description  = "Use the dropdown to select an arena."<br/>    selections = SelectField('Select an Arena',choices=[])</pre>
<p>Other field classes, such as <kbd>TextField</kbd>, <kbd>BooleanField</kbd>, <kbd>StringField</kbd>, <kbd>FloatField</kbd>, <kbd>PasswordField</kbd>, and many others, are available from WTForms for implementation of complex web applications. Also, because they are Python objects, forms can be updated to include other data attributes on the fly, as we will see as we proceed further.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Views</h1>
                </header>
            
            <article>
                
<p class="mce-root">Flask views are Python functions that, when paired with the <kbd>app</kbd> controller object and its <kbd>app.route</kbd> URL definitions, allows us to write Python code to accept a web request, process it, and return a response. They are the heart of the web application, making it possible to connect web pages and their forms to the database and its tables.</p>
<p>To create views, we will import all of the application components along with a number of Flask functions. The forms and models are imported from their respective scripts, as is the <kbd>app</kbd> object:</p>
<pre>from application import app<br/>from flask import render_template,jsonify, redirect, url_for, request<br/>from .forms import * <br/>from .models import *</pre>
<p>For the Arena application, we have two views defined that create two application URL endpoints. The first view, <kbd>home</kbd>, is in place only to redirect requests to the IP address root. Using the Flask functions <kbd>redirect</kbd> and <kbd>url_for</kbd>, any web requests sent to the <kbd>root</kbd> address will be redirected to the <kbd>arenas</kbd> view:</p>
<pre>@app.route('/', methods=["GET"])<br/>def home():<br/> return redirect(url_for('arenas'))</pre>
<p>The second view, <kbd>arenas</kbd>, is more complex. It accepts both <kbd>GET</kbd> and <kbd>POST</kbd> request methods. Depending on the <kbd>request</kbd> method, the data processed and returned will be different, though they both rely on the template <kbd>index.html</kbd> which is stored in the <kbd>application</kbd>/<kbd>templates</kbd> folder (where all Flask HTML templates are stored). Here is the complete view:</p>
<pre>@app.route('/arenas', methods=["GET","POST"])<br/>def arenas():<br/>    form = ArenaForm(request.form)<br/>    arenas = session.query(Arena).all()<br/>    form.selections.choices = [(arena.id, <br/>                                arena.name) for arena in arenas]<br/>    form.popup = "Select an Arena"<br/>    form.latitude = 38.89517<br/>    form.longitude = -77.03682    <br/>    if request.method == "POST":<br/>        arena_id = form.selections.data<br/>        arena = session.query(Arena).get(arena_id)<br/>        form.longitude = round(arena.longitude,4)<br/>        form.latitude = round(arena.latitude,4)<br/>        county=session.query(County).filter(<br/>                        County.geom.ST_Contains(arena.geom)).first()<br/>        if county != None:<br/>            district=session.query(District).filter(<br/>                       District.geom.ST_Intersects(arena.geom)).first()<br/>            state = county.state_ref<br/>            form.popup = """The {0} is located at {4}, {5}, which is in <br/>            {1} County, {3}, and in {3} Congressional District         <br/>            {2}.""".format(arena.name,county.name, district.district, <br/>            state.name,                                          <br/>            form.longitude, form.latitude)<br/><br/>        else:<br/>                 form.popup = """The county, district, and state could                                                             <br/>                 not be located using point in polygon analysis"""<br/><br/>        return render_template('index.html',form=form)<br/>    return render_template('index.html',form=form)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dissecting the view</h1>
                </header>
            
            <article>
                
<p class="mce-root">The views's URL is <kbd>http://{localhost}/arenas</kbd><em><strong>.</strong></em> Using a special Python object called a <strong>decorator</strong> (such as <kbd>@app.route</kbd><em>)</em> allows us to connect the URL that we want to use with the function that will accept and handle the request processing. The function and the URL do not need to have the same name, though it is common for them to do so:</p>
<pre class="mce-root">@app.route('<strong>/arenas</strong>', methods=["GET","POST"])<br/>def arenas():</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using forms</h1>
                </header>
            
            <article>
                
<p><span>Underneath the decorator and the function declaration, the </span><kbd>ArenaForm</kbd><span> from</span> <kbd>forms.py</kbd> <span>is called and the function </span><kbd>request.form</kbd><span> is passed as a parameter. This adds functionality to the </span><kbd>ArenaForm</kbd><span> and allows it to access the request's own parameters as needed.</span></p>
<p>Once the <kbd>ArenaForm</kbd> object is passed to the variable <kbd>form</kbd>, it can be populated with data. This data will come from an SQLAlchemy session <kbd>query</kbd> on the <kbd>Arena</kbd> model. This query requests all rows of data from the <kbd>Arena</kbd> table and passes it to the variable <kbd>arenas</kbd> using <kbd>all</kbd> method (as opposed to the <kbd>filter_by</kbd> method which would limit the rows returned).</p>
<p>Because the ArenaForm's <kbd>selections</kbd> field is currently blank, we'll use a list comprehension to loop through the <kbd>arena</kbd> objects contained within the list called <kbd>arenas</kbd>, adding their <kbd>id</kbd> and <kbd>name</kbd> fields to tuples inside the list. This populates the drop-down list and makes it so each selection in the list has a value (the <kbd>id</kbd>) and a label (the <kbd>name</kbd>):</p>
<pre>    form = ArenaForm(request.form)<br/>    arenas = session.query(Arena).all()<br/>    form.selections.choices = [(arena.id, <br/>                                arena.name) for arena in arenas]<br/>    form.popup = "Select an Arena"<br/>    form.latitude = 38.89517<br/>    form.longitude = -77.03682  </pre>
<p>After populating the selections choices, three new attributes are added to the form—<kbd>popup</kbd>, <kbd>latitude</kbd>, and <kbd>longitude</kbd>. Initially, these are just placeholders and are not derived from the <kbd>arena</kbd> data. However, once the web application is running and users are selecting <kbd>arenas</kbd> from the drop-down list, these placeholder values will be replaced with data derived from the <kbd>arenas</kbd> tables and from queries against the other tables.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Evaluating the request method</h1>
                </header>
            
            <article>
                
<p>The next line is an <kbd>if</kbd> conditional that uses the <kbd>request.method</kbd> property to see if the HTTP request method is <kbd>POST</kbd>:</p>
<pre>if request.method == "POST":</pre>
<p>Because the initial request to the URL <kbd>arenas</kbd> is a <kbd>GET</kbd> request, the code initially evaluates the <kbd>if</kbd> conditional as <kbd>False</kbd>, skipping the indented code section to the bottom of the view to return the template <kbd>index.html</kbd> and the now populated <kbd>form</kbd>:</p>
<pre>return render_template('index.html',form=form)</pre>
<p>This function returns uses the <kbd>render_template</kbd> function to return the template called <kbd>index.html</kbd> and passes the populated <kbd>ArenaForm</kbd> variable called <kbd>form</kbd> into the template, making it possible for the Jinja2 templating system to generate the completed web page and send it to the requesting web browser. All of the template's double-bracketed variables are filled in with the corresponding data from <kbd>form</kbd> (for example, the selections are added to the drop-down list).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">POST requests</h1>
                </header>
            
            <article>
                
<p>If a user selects an <kbd>arena</kbd> from the list and pushes the <span class="packt_screen">Find Data</span> button, the HTML form issues a <kbd>POST</kbd> request to the view. With the <kbd>if</kbd> conditional resolving to <kbd>True</kbd>, the view handles the request by generating an <kbd>arena</kbd> location coordinate pair and a custom <kbd>popup</kbd>, instead of using a default coordinate pair and <kbd>popup</kbd> value:</p>
<pre>  if request.method == "POST":<br/>       arena_id = form.selections.data<br/>       arena = session.query(Arena).get(arena_id)<br/>       form.longitude = round(arena.longitude,4)<br/>       form.latitude = round(arena.latitude,4)</pre>
<p>The property <kbd>form.selections.data</kbd> is used to retrieve the <kbd>id</kbd> of the <kbd>arena</kbd> chosen from the list and is passed to a variable called <kbd>arena_id</kbd>. This <kbd>id</kbd> is then used to query the database through the SQLAlchemy ORM's <kbd>get</kbd> method. The <kbd>form.longitude</kbd> and <kbd>form.latitude</kbd> fields can be populated from data fields of the <kbd>arena</kbd> object returned by the query.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spatial queries</h1>
                </header>
            
            <article>
                
<p>To find the county and the congressional district, two PostGIS spatial analysis techniques are used—<kbd>ST_Contains</kbd> and <kbd>ST_Intersects</kbd>. The first query determines if the <kbd>arena</kbd> is contained within a <kbd>county</kbd>; if not, the result is null (or <kbd>None</kbd> in Python):</p>
<pre>        county=session.query(County).filter(<br/>                        County.geom.ST_Contains(arena.geom)).first()<br/>        if county != None:<br/>            district=session.query(District).filter(<br/>                       District.geom.ST_Intersects(arena.geom)).first()</pre>
<p><span>While</span> <kbd>ST_Contains</kbd> <span>could be used for both queries, I wanted to demonstrate that the</span> GeoAlchemy2 <span>ORM allows for access to all PostGIS functions when using <kbd>Geometry</kbd> columns. These searches combine the SQLAlchemy</span> <kbd>filter</kbd> <span>method with the</span> GeoAlchemy2 <span>ORM to make it possible to return query results based on a spatial analysis.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Relationship query</h1>
                </header>
            
            <article>
                
<p>If the <kbd>county</kbd> query was successful, the <kbd>district</kbd> query is performed, and then a relationship attribute (<kbd>state_ref</kbd>) is used to find the <kbd>state</kbd> within which the <kbd>county</kbd> is placed:</p>
<pre>        state = county.state_ref</pre>
<p>The two-way relationship established in the <kbd>County</kbd>, <kbd>District</kbd>, and <kbd>State</kbd> model definitions make this possible. This <kbd>state</kbd> object is a member of the <kbd>State</kbd> model class and can be used to retrieve the <kbd>name</kbd> of the <kbd>state</kbd>.</p>
<p>To create the custom <kbd>popup</kbd>, string template formatting is used to populate the <kbd>popup</kbd> with the specifics describing the <kbd>arena</kbd> requested. The result is assigned to the variable <kbd>form.popup</kbd>.</p>
<p>Finally, the populated <kbd>form</kbd> is then passed once again to the <kbd>index.html</kbd> template, but this time it contains data about the selected <kbd>arena</kbd>:</p>
<pre>    return render_template('index.html',form=form)</pre>
<p>Here is a screenshot of the application query results for The Oracle Arena:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/54a1006e-af1e-4437-98ca-3af63d58a38c.png" width="1007" height="902"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The web map template</h1>
                </header>
            
            <article>
                
<p>Within the <kbd>index.html</kbd> template, the <kbd>form</kbd> data is accessed inside double-bracketed variables. These variables can be located inside the JavaScript or within the HTML. In this example, the <kbd>form.latitude</kbd> and <kbd>form.longitude</kbd> variables are located inside the map JavaScript that defines the initial center point of the map:</p>
<pre><span> </span>var themap = L.map('map').setView([<strong>{{form.latitude}}</strong>,                                                   <strong>{{form.longitude}}</strong>], 13);</pre>
<p>To create the <kbd>marker</kbd> at the location of the <kbd>arena</kbd> requested, with a custom <kbd>popup</kbd>, the location coordinates and the <kbd>popup</kbd> fields are added:</p>
<pre>  L.marker([<strong>{{form.latitude}}</strong>,<strong>{{form.longitude}}</strong>]).addTo(themap)<br/>    .bindPopup("<strong>{{form.popup}}</strong>").openPopup();</pre>
<p>To make the <kbd>POST</kbd> requests possible, an HTML form with a <kbd>POST</kbd> method houses the <kbd>form.description</kbd> and <kbd>form.selection</kbd> (the drop-down list) attributes. The HTML form's button generates the <kbd>POST</kbd> request when it is pushed:</p>
<pre class="mce-root">  &lt;form method="post" class="form"&gt;<br/>    &lt;h3&gt;{{form.description}}&lt;/h3&gt;<br/>    {{form.selections(class_='form-control',placeholder="")}}<br/>    &lt;br&gt;<br/>    &lt;input type="submit" value="Find Data"&gt;<br/>  &lt;/form&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Running the web application locally</h1>
                </header>
            
            <article>
                
<p>To run the application locally, we can call the <kbd>app.py</kbd> script, located in the <kbd>arenaapp</kbd> folder, using the Python executable. Open up a command line and pass a script argument:</p>
<pre><strong>C:\Python36&gt;python C:\GeospatialPy3\Chapter11\Scripts\arenaapp\app.py</strong></pre>
<p>To run this application on a web server is beyond the scope of the chapter, but it involves configuring a web server with a WSGI handler to allow for web requests to be processed by the Python executable and <kbd>app.py</kbd>. For Apache web servers, the <kbd>mod_wsgi</kbd> module is popular. For Windows servers using <strong>Internet Information Services</strong> (<strong>IIS</strong>), the <kbd>wfastcgi</kbd> module is very useful and is available from the Microsoft Web Platform Installer.</p>
<div class="packt_infobox">Explore more about Apache and the <kbd>mod_wsgi</kbd> module here: <a href="http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/">http://flask.pocoo.org/docs/latest/deploying/mod_wsgi/</a>.<em><br/></em><br/>
For IIS, these installation instructions are very useful: <a href="http://netdot.co/2015/03/09/flask-on-iis/">http://netdot.co/2015/03/09/flask-on-iis/</a>.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to use the Flask MVC web framework and some of the available component modules that add extra functionality. These modules include the SQLAlchemy ORM, the GeoAlchemy2 ORM for geospatial queries, WTForms for processing of web data, and the Jinja2 templating system for creating web page templates. We created database tables, added data tables and tables relationships, and created a web application that utilized geospatial and relationship queries to generate dynamic web pages.</p>
<p><span>A fun challenge, building on the code reviewed here, would be to explore adding editing capabilities to the Arena application, allowing the user to move the <kbd>arenas</kbd> into their correct location if the data is out of date. Explore the</span> GeoAlchemy2 <span>ORM documentation for more advanced capabilities.</span></p>
<p>In the next chapter, we will review a similar MVC web framework, Django, and its GeoDjango spatial component. With more batteries included philosophy, Django solves the same problems inherent to web applications in different ways, but with less freedom of module choice, when compared to Flask.</p>


            </article>

            
        </section>
    </div>



  </body></html>