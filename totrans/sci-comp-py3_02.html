<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Variables and Basic Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Variables and Basic Types</h1></div></div></div><p>In this chapter, we will present the most important and basic types in Python. What is a type? It is a set consisting of data content, its representation, and all possible operations. Later in this book, we will make this definition much more precise, when we introduce the concepts of a class in <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>.</p><div class="section" title="Variables"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Variables</h1></div></div></div><p>Variables are references to Python objects. They are created by assignments, for example:</p><pre class="programlisting">a = 1 &#13;
diameter = 3.&#13;
height = 5.&#13;
cylinder = [diameter, height] # reference to a list</pre><p>Variables take names that consist of any combination of capital and small letters, the underscore <code class="literal">_ </code>, and digits. A variable name must not start with a digit. Note that variable names are case sensitive. A good naming of variables is an essential part of documenting your work, so we recommend that you use descriptive variable names.</p><p>Python has some <span class="emphasis"><em>reserved keywords</em></span>, which cannot be used as variable names (refer to following table, <span class="emphasis"><em>Table 2.1</em></span>). An attempt to use such a keyword as variable name would raise a syntax error.</p><p>
</p><div class="mediaobject"><img src="graphics/Table-2.11.jpg" alt="Variables"/></div><p>
</p><p>Table 2.1: Reserved Python keywords.</p><p>As opposed to other programming languages, variables require no type declaration. You can create several variables with a multiple assignment statement:</p><pre class="programlisting">a = b = c = 1   # a, b and c get the same value 1</pre><p>Variables can also be altered after their definition:</p><pre class="programlisting">a = 1 &#13;
a = a + 1 # a gets the value 2 &#13;
a = 3 * a   # a gets the value 6</pre><p>The last two statements can be written by combining the two operations with an assignment directly by using increment operators:</p><pre class="programlisting">a += 1  # same as a = a + 1 &#13;
a *= 3  # same as a = 3 * a</pre></div></div>
<div class="section" title="Numeric types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Numeric types</h1></div></div></div><p>At some point, you will have to work with numbers, so we start by considering different forms of numeric types in Python. In mathematics, we distinguish between natural numbers (ℕ), integers (ℤ), rational numbers (ℚ), real numbers (ℝ) and complex numbers (ℂ). These are infinite sets of numbers. Operations differ between these sets and may even not be defined. For example, the usual division of two numbers in ℤ  might not result in an integer — it is not defined on ℤ.</p><p>In Python, like many other computer languages, we have numeric types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The numeric type <code class="literal">int</code>, which is at least theoretically the entire ℤ</li><li class="listitem" style="list-style-type: disc">The numeric type <code class="literal">float</code>, which is a finite subset of ℝ and</li><li class="listitem" style="list-style-type: disc">The numeric type <code class="literal">complex</code>, which is a finite subset of ℂ</li></ul></div><p>Finite sets have a smallest and a largest number and there is a minimum spacing between two numbers; refer to the section on <span class="emphasis"><em>Floating Point Representation</em></span> for further details.</p><div class="section" title="Integers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Integers</h2></div></div></div><p>The simplest numerical type is the integer type.</p><div class="section" title="Plain integers"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec1"/>Plain integers</h3></div></div></div><p>The statement <code class="literal">k = 3</code> assigns the variable <code class="literal">k</code> to an integer.</p><p>Applying an operation of the type <code class="literal">+</code>, <code class="literal">-</code>, or <code class="literal">*</code> to integers returns an integer. The division operator, <code class="literal">//</code>, returns an integer, while <code class="literal">/</code> may return a <code class="literal">float:</code>
</p><pre class="programlisting">6 // 2  # 3&#13;
7 // 2  # 3&#13;
7 / 2   # 3.5</pre><p>The set of integers in Python is unbounded; there is no largest integer. The limitation here is the computer’s memory rather than any fixed value given by the language.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip7"/>Tip</h3><p>If the division operator (<code class="literal">/</code>) in the example returns 3, you might not have installed the correct Python version.</p></div></div></div></div><div class="section" title="Floating point numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Floating point numbers</h2></div></div></div><p>If you execute the statement <code class="literal">a = 3.0</code> in Python, you create a floating-point number (Python type: <code class="literal">float</code>). These numbers form a subset of rational numbers, ℚ.</p><p>Alternatively the constant could have been given in exponent notation as <code class="literal">a = 30.0e-1</code> or simply <code class="literal">a = 30.e-1</code>. The symbol <code class="literal">e</code> separates the exponent from the mantissa, and the expression reads in mathematical notation <span class="emphasis"><em>a = 30.0 × 10<sup>−1</sup></em></span>. The name <span class="emphasis"><em>floating-point number</em></span> refers to the internal representation of these numbers and reflects the floating position of the decimal point when considering numbers over a wide range.</p><p>Applying the elementary mathematical operations <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, and <code class="literal">/</code> to two floating-point numbers or to an integer and a floating-point number returns a floating-point number. Operations between floating-point numbers rarely return the exact result expected from rational number operations:</p><pre class="programlisting">0.4 - 0.3 # returns 0.10000000000000003</pre><p>This facts matters, when comparing floating point numbers:</p><pre class="programlisting">0.4 - 0.3 == 0.1 # returns False</pre><div class="section" title="Floating point representation"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec2"/>Floating point representation</h3></div></div></div><p>Internally, floating-point numbers are represented by four quantities: the sign, the mantissa, the exponent sign, and the exponent:</p><p>
</p><div class="mediaobject"><img src="graphics/float1.jpg" alt="Floating point representation"/></div><p>
</p><p>with <span class="emphasis"><em>β </em></span>ϵ<span class="emphasis"><em> ℕ</em></span> and <span class="emphasis"><em>x<sub>0</sub></em></span>≠ 0, 0 ≤<span class="emphasis"><em> x<sub>i</sub>≤ β</em></span></p><p><span class="emphasis"><em>x</em></span><sub>0</sub>...x<sub>t-1</sub> is called the mantissa, <span class="emphasis"><em>β</em></span> the basis and <span class="emphasis"><em>e</em></span> the exponent <span class="emphasis"><em>|e| ≤ U</em></span> . <span class="emphasis"><em>t</em></span> is called the mantissa length. The condition <span class="emphasis"><em>x</em></span><sub>0</sub> ≠ 0 makes the representation unique and saves, in the binary case (<span class="emphasis"><em>β</em></span> = 2), one bit.</p><p>There exist two-floating point zeros +0 and -0, both represented by the mantissa 0.</p><p>On a typical Intel processor, <span class="emphasis"><em>β</em></span> = 2 . To represent a number in the <code class="literal">float</code> type 64 bits are used, namely 2 bits for the signs, <span class="emphasis"><em>t </em></span>= 52 bits for the mantissa and 10 bits for the exponent <code class="literal">|e|</code>. The upper bound <span class="emphasis"><em>U</em></span> for the exponent is consequently 2<sup>10</sup>-1<span class="emphasis"><em> = </em></span>102<span class="emphasis"><em>3</em></span>.</p><p>With this data the smallest positive representable number is</p><p>fl<sub>min</sub> = 1.0 <span class="emphasis"><em>×</em></span> 2<sup>-1023</sup> ≈ 10<sup>-308  </sup>and the largest is  fl<sub>max</sub> = 1.111...1 <span class="emphasis"><em>×</em></span> 2<sup>1023</sup> ≈ 10<sup>308</sup><span class="emphasis"><em>.</em></span>
</p><p>Note that floating-point numbers are not equally spaced in [0, fl<sub>max</sub>]. There is in particular a  gap at zero (refer to <a class="link" href="apa.html" title="Appendix . References">[29]</a>). The distance between 0 and the first positive number is 2<sup>-1023</sup>, while the distance between the first and the second is smaller by a factor <span class="emphasis"><em>2</em></span><sup>-52</sup><span class="emphasis"><em>≈ 2.2</em></span> <span class="emphasis"><em>×</em></span> 10<sup>-16</sup>. This effect, caused by the normalization <span class="emphasis"><em>x</em></span><sub>0</sub><span class="emphasis"><em> ≠ 0</em></span>, is visualized in <span class="emphasis"><em>Figure 2.1</em></span>.</p><p>This gap is filled equidistantly with subnormal floating-point numbers to which such a result is rounded. Subnormal floating-point numbers have the smallest possible exponent and do not follow the convention that the leading digit <span class="emphasis"><em>x<sub>0</sub></em></span> has to differ from zero; refer to <a class="link" href="apa.html" title="Appendix . References">[13]</a>.</p></div><div class="section" title="Infinite and not a number"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec3"/>Infinite and not a number</h3></div></div></div><p>There are in total<span class="inlinemediaobject"><img src="graphics/float2.jpg" alt="Infinite and not a number"/></span> floating-point numbers. Sometimes a numerical algorithm computes floating-point numbers outside this range.</p><p>This generates number over- or underflow. In SciPy the special floating-point number <code class="literal">inf</code> is assigned to overflow results:</p><pre class="programlisting">exp(1000.) # inf &#13;
a = inf&#13;
3 - a   # -inf&#13;
3 + a   # inf</pre><p>Working with <code class="literal">inf</code> may lead to mathematically undefined results. This is indicated in Python by assigning the result another special floating-point number, <code class="literal">nan</code>. This stands for not-a-number, that is, an undefined result of a mathematical operation:</p><pre class="programlisting">a + a # inf&#13;
a - a # nan &#13;
a / a # nan</pre><p>There are special rules for operations with <code class="literal">nan</code> and <code class="literal">inf</code>. For instance, <code class="literal">nan</code> compared to anything (even to itself) always returns <code class="literal">False</code>:</p><pre class="programlisting">x = nan &#13;
x &lt; 0 # False&#13;
x &gt; 0 # False&#13;
x == x # False</pre><p>See <span class="emphasis"><em>Exercise 4</em></span> for some surprising consequences of the fact that <code class="literal">nan</code> is never equal to itself.</p><p>The float <code class="literal">inf</code> behaves much more as expected:</p><pre class="programlisting">0 &lt; inf     # True &#13;
inf &lt;= inf  # True &#13;
inf == inf  # True &#13;
-inf &lt; inf  # True &#13;
inf - inf   # nan &#13;
exp(-inf)   # 0 &#13;
exp(1 / inf)  # 1</pre><p>One way to check for <code class="literal">nan</code> and <code class="literal">inf</code> is to use the  <code class="literal">isnan</code> and <code class="literal">isinf</code> functions. Often, one wants to react directly when a variable gets the value <code class="literal">nan</code> or <code class="literal">inf</code>. This can be achieved by using the NumPy command <code class="literal">seterr</code>. The following command</p><pre class="programlisting">seterr(all = 'raise')</pre><p>would raise an error if a calculation were to return one of those values.</p></div><div class="section" title="Underflow - Machine Epsilon"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec4"/>Underflow - Machine Epsilon</h3></div></div></div><p>Underflow occurs when an operation results in a rational number that falls into the gap at zero; refer to <span class="emphasis"><em>Figure 2.1</em></span>.</p><p>
</p><div class="mediaobject"><img src="graphics/floatz.jpg" alt="Underflow - Machine Epsilon"/></div><p>
</p><p>Figure 2.1: The floating point gap at zero, here t = 3, U = 1</p><p>The <span class="emphasis"><em>machine epsilon</em></span> or rounding unit is the largest number <span class="emphasis"><em>ε</em></span> such that float<span class="emphasis"><em>(</em></span>1.0<span class="emphasis"><em> + ε) = </em></span>1.0.</p><p>Note that <span class="emphasis"><em>ε </em></span>≈<span class="emphasis"><em> β</em></span><sup>1-t</sup>/2 = 1.1102 × 10<sup>-16</sup> on most of today’s computers. The value that is valid on the actual machine you are running your code on is accessible using the following command:</p><pre class="programlisting">import sys &#13;
sys.float_info.epsilon # 2.220446049250313e-16 (something like that)</pre><p>The variable <code class="literal">sys.float_info</code>  contains more information about the internal representation of the float type on your machine.</p><p>The function <code class="literal">float</code>  converts other types to a floating-point number—if possible. This function is especially useful when converting an appropriate string to a number:</p><pre class="programlisting">a = float('1.356')</pre></div><div class="section" title="Other float types in NumPy"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec5"/>Other float types in NumPy
</h3></div></div></div><p>NumPy also provides other float types, known from other programming languages as double-precision and single-precision  numbers, namely <code class="literal">float64</code> and <code class="literal">float32</code>:</p><pre class="programlisting">a = pi            # returns 3.141592653589793 &#13;
a1 = float64(a)   # returns 3.1415926535897931 &#13;
a2 = float32(a)   # returns 3.1415927 &#13;
a - a1            # returns 0.0 &#13;
a - a2            # returns -8.7422780126189537e-08</pre><p>The second last line demonstrates that <code class="literal">a</code> and <code class="literal">a1</code> do not differ in accuracy. In the first two lines, they only differ in the way they are displayed. The real difference in accuracy is between <code class="literal">a</code> and its single-precision counterpart, <code class="literal">a2</code>.</p><p>The NumPy function <code class="literal">finfo</code>  can be used to display information on these floating-point types:</p><pre class="programlisting">f32 = finfo(float32) &#13;
f32.precision   # 6 (decimal digits) &#13;
f64 = finfo(float64) &#13;
f64.precision   # 15 (decimal digits) &#13;
f = finfo(float) &#13;
f.precision     # 15 (decimal digits) &#13;
f64.max         # 1.7976931348623157e+308 (largest number) &#13;
f32.max         # 3.4028235e+38 (largest number) &#13;
help(finfo)     # Check for more options</pre></div></div><div class="section" title="Complex numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Complex numbers</h2></div></div></div><p>Complex numbers are an extension of the real numbers frequently used in many scientific and engineering fields.</p><div class="section" title="Complex Numbers in Mathematics"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec6"/>Complex Numbers in Mathematics</h3></div></div></div><p>Complex numbers consist of two floating-point numbers, the real part <span class="emphasis"><em>a</em></span> of the number and its imaginary part <span class="emphasis"><em>b</em></span>. In mathematics, a complex number is written as <span class="emphasis"><em>z=a+b</em></span>i, where i defined by i<span class="emphasis"><em><sup>2</sup> = </em></span>-1 is the imaginary unit. The conjugate complex counterpart of <span class="emphasis"><em>z</em></span> is <span class="inlinemediaobject"><img src="graphics/conjcomplex.jpg" alt="Complex Numbers in Mathematics"/></span>.</p><p>If the real part <span class="emphasis"><em>a</em></span> is zero, the number is called an imaginary number.</p></div><div class="section" title="The j notation"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec7"/>The j notation</h3></div></div></div><p>In Python, imaginary numbers are characterized by suffixing a floating-point number with the letter <code class="literal">j</code>, for example, <code class="literal">z = 5.2j</code>. A complex number is formed by the sum of a floating-point number and an imaginary number, for example, <code class="literal">z = 3.5 + 5.2j</code>.</p><p>While in mathematics the imaginary part is expressed as a product of a real number <span class="emphasis"><em>b</em></span> with the imaginary unit i, the Python way of expressing an imaginary number is not a product: <code class="literal">j</code> is just a suffix to indicate that the number is imaginary.</p><p>This is demonstrated by the following small experiment:</p><pre class="programlisting">b = 5.2 &#13;
z = bj   # returns a NameError &#13;
z = b*j  # returns a NameError&#13;
z = b*1j # is correct</pre><p>The method <code class="literal">conjugate</code> returns the conjugate of <code class="literal">z</code>:</p><pre class="programlisting">z = 3.2 + 5.2j &#13;
z.conjugate() # returns (3.2-5.2j)</pre></div><div class="section" title="Real and imaginary parts"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec8"/>Real and imaginary parts</h3></div></div></div><p>One may access the real and imaginary parts of a complex number <span class="emphasis"><em>z</em></span> using the <code class="literal">real</code> and <code class="literal">imag</code> attributes. Those attributes are read-only:</p><pre class="programlisting">z = 1j &#13;
z.real       # 0.0 &#13;
z.imag       # 1.0 &#13;
z.imag = 2   # AttributeError: readonly attribute</pre><p>It is not possible to convert a complex number to a real number:</p><pre class="programlisting">z = 1 + 0j &#13;
z == 1     # True &#13;
float(z)   # TypeError</pre><p>Interestingly, the <code class="literal">real</code> and <code class="literal">imag</code> attributes as well as the conjugate method work just as well for complex arrays <span class="emphasis"><em>(<a class="link" href="ch04.html" title="Chapter 4. Linear Algebra – Arrays">Chapter 4</a></em></span>, <span class="emphasis"><em>Linear Algebra – Arrays)</em></span>. We demonstrate this by computing the <span class="emphasis"><em>N</em></span><sup>th</sup> roots of unity which are <span class="inlinemediaobject"><img src="graphics/rootsofunity.jpg" alt="Real and imaginary parts"/></span>, that is, the <span class="emphasis"><em>N</em></span> solutions of the equation <span class="inlinemediaobject"><img src="graphics/rootsofunity1.jpg" alt="Real and imaginary parts"/></span>:</p><pre class="programlisting">N = 10&#13;
# the following vector contains the Nth roots of unity: &#13;
unity_roots = array([exp(1j*2*pi*k/N) for k in range(N)])&#13;
# access all the real or imaginary parts with real or imag:&#13;
axes(aspect='equal')&#13;
plot(unity_roots.real, unity_roots.imag, 'o')&#13;
allclose(unity_roots**N, 1) # True</pre><p>The resulting figure (<span class="emphasis"><em>Figure 2.2</em></span>) shows the roots of unity together with the unit circle. (For more details on how to make plots, refer <a class="link" href="ch06.html" title="Chapter 6. Plotting">Chapter 6</a>, <span class="emphasis"><em>Plotting.</em></span>)</p><p>
</p><div class="mediaobject"><img src="graphics/nrootsofunity.jpg" alt="Real and imaginary parts"/></div><p>
</p><p>Figure 2.2: Roots of unity together with a unit circle</p><p>It is of course possible to mix the previous methods, as illustrated by the following examples:</p><pre class="programlisting">z = 3.2+5.2j &#13;
(z + z.conjugate()) / 2.   # returns (3.2+0j) &#13;
((z + z.conjugate()) / 2.).real   # returns 3.2 &#13;
(z - z.conjugate()) / 2.   # returns 5.2j &#13;
((z - z.conjugate()) / 2.).imag   # returns 5.2 &#13;
sqrt(z * z.conjugate())   # returns (6.1057350089894991+0j)</pre></div></div></div>
<div class="section" title="Booleans"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Booleans</h1></div></div></div><p>Boolean is a datatype named after <span class="emphasis"><em>George Boole</em></span> (1815-1864). A Boolean variable can take only two values, <code class="literal">True</code> or <code class="literal">False</code>. The main use of this type is in logical expressions. Here are some examples:</p><pre class="programlisting">a = True &#13;
b = 30 &gt; 45   # b gets the value False</pre><p>Boolean expressions are often used in conjunction with the <code class="literal">if</code> statement:</p><pre class="programlisting">if x &gt; 0:&#13;
   print("positive")&#13;
else:&#13;
   print("nonpositive)</pre><div class="section" title="Boolean operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Boolean operators</h2></div></div></div><p>Boolean operations are performed using the <code class="literal">and</code>, <code class="literal">or</code>, and <code class="literal">not</code> keywords in Python:</p><pre class="programlisting">True and False # False&#13;
False or True # True&#13;
(30 &gt; 45) or (27 &lt; 30) # True&#13;
not True # False&#13;
not (3 &gt; 4) # True</pre><p>The operators follow some precedence rules (refer to section <span class="emphasis"><em>Executing scripts</em></span> in <a class="link" href="ch01.html" title="Chapter 1. Getting Started">Chapter 1</a>, <span class="emphasis"><em>Getting started</em></span>) which would make the parentheses in the third line and in the last obsolete (it is a good practice to use them anyway to increase the readability of your code). Note that the <code class="literal">and</code> operator is implicitly chained in the following Boolean expressions:</p><pre class="programlisting">a &lt; b &lt; c     # same as: a &lt; b and b &lt; c &#13;
a == b == c   # same as: a == b and b == c</pre><p>Rules of Conversion to Booleans:</p><p>
</p><div class="mediaobject"><img src="graphics/Capture.jpg" alt="Boolean operators"/></div><p>
</p><p>Table 2.2 : Rule of conversion to Boolean</p></div><div class="section" title="Boolean casting"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Boolean casting</h2></div></div></div><p>Most objects Python may be converted to Booleans; this is called <span class="emphasis"><em>Boolean casting</em></span>. The built-in function <code class="literal">bool</code> performs that conversion. Note that most objects are cast to <code class="literal">True</code>, except <code class="literal">0</code>, the empty tuple, the empty list, the empty string, or the empty array. These are all cast to <code class="literal">False</code>.</p><p>It is <span class="emphasis"><em>not</em></span> possible to cast arrays into Booleans unless they contain no or only one element; this is explained further in <a class="link" href="ch05.html" title="Chapter 5. Advanced Array Concepts">Chapter 5</a>, <span class="emphasis"><em>Advanced Array Concepts</em></span>. The previous table contains summarized rules for Boolean casting. Some usage examples:</p><pre class="programlisting">bool([])   # False &#13;
bool(0)   # False &#13;
bool(' ')   # True &#13;
bool('')   # False &#13;
bool('hello')   # True &#13;
bool(1.2)   # True &#13;
bool(array([1]))   # True &#13;
bool(array([1,2]))   # Exception raised!</pre></div><div class="section" title="Automatic Boolean casting"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Automatic Boolean casting</h2></div></div></div><p>Using an <code class="literal">if</code> statement with a non-Boolean type will cast it to a Boolean. In other words, the following two statements are always equivalent:</p><pre class="programlisting">if a:&#13;
   ...&#13;
if bool(a): # exactly the same as above&#13;
   ...</pre><p>A typical example is testing whether a list is empty:</p><pre class="programlisting"># L is a list&#13;
if L:&#13;
    print("list not empty")&#13;
else:&#13;
    print("list is empty")</pre><p>An empty array, list, or tuple will return <code class="literal">False</code>. You can also use a variable in the <code class="literal">if</code> statement, for example, an integer:</p><pre class="programlisting"># n is an integer&#13;
if n % 2:&#13;
    print("n is odd")&#13;
else:&#13;
    print("n is even")</pre><p>Note that we used <code class="literal">%</code> for the modulo operation, which returns the remainder of an integer division. In this case, it returns <code class="literal">0</code> or <code class="literal">1</code> as the remainder after modulo <code class="literal">2</code>.</p><p>In this last example, the values <code class="literal">0</code> or <code class="literal">1</code> are cast to <code class="literal">bool</code>. Boolean operators <code class="literal">or</code>,<code class="literal">and</code> , and <code class="literal">not</code> will also implicitly convert some of their arguments to a Boolean.</p></div><div class="section" title="Return values of and and or"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Return values of and and or</h2></div></div></div><p>Note that the operators <code class="literal">and</code> and <code class="literal">or</code> do not necessarily produce Boolean values. The expression <code class="literal">
<span class="emphasis"><em>x</em></span> and<span class="emphasis"><em> y</em></span>
</code> is equivalent to:</p><pre class="programlisting">def and_as_function(x,y):&#13;
    if not x:&#13;
        return x&#13;
    else:&#13;
        return y</pre><p>And the expression <code class="literal">x or y</code> is equivalent to:</p><pre class="programlisting">def or_as_function(x,y):&#13;
    if x:&#13;
        return x&#13;
    else:&#13;
        return y</pre><p>Interestingly, this means that when executing the statement <code class="literal">True or x</code>, the variable <code class="literal">x</code> need not even be defined! The same holds for <code class="literal">False and x</code>.</p><p>Note that, unlike their counterparts in mathematical logic, these operators are no longer commutative in Python. Indeed, the following expressions are not equivalent:</p><pre class="programlisting">[1] or 'a' # produces [1] &#13;
'a' or [1] # produces 'a'</pre></div><div class="section" title="Boolean and integer"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>Boolean and integer</h2></div></div></div><p>In fact, Booleans and integers are the same. The only difference is in the string representation of 0 and 1 which is in the case of Booleans <code class="literal">False</code> and <code class="literal">True</code> respectively. This allows constructions like this (for the format method refer section on <span class="emphasis"><em>string formatting</em></span>):</p><pre class="programlisting">def print_ispositive(x):&#13;
    possibilities = ['nonpositive', 'positive']&#13;
    return "x is {}".format(possibilities[x&gt;0])</pre><p>We note for readers already familiar with the concept of subclasses, that the type <code class="literal">bool</code> is a subclass of the type <code class="literal">int</code> (refer to <a class="link" href="ch08.html" title="Chapter 8. Classes">Chapter 8</a>, <span class="emphasis"><em>Classes</em></span>). Indeed, all four inquiries <code class="literal">isinstance(True, bool)</code>, <code class="literal">isinstance(False, bool)</code>, <code class="literal">isinstance(True, int)</code>, and <code class="literal">isinstance(False, int)</code> return the value <code class="literal">True</code> (refer to section<span class="emphasis"><em> Type Checking</em></span> in <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <span class="emphasis"><em>Container Types</em></span>).</p><p>Even rarely used statements such as <code class="literal">True+13</code> are syntactically correct.</p></div></div>
<div class="section" title="Strings"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Strings</h1></div></div></div><p>The type <code class="literal">string</code> is a type used for text:</p><pre class="programlisting">name = 'Johan Carlsson'&#13;
child = "Åsa is Johan Carlsson's daughter"&#13;
book = """Aunt Julia &#13;
       and the Scriptwriter"""</pre><p>A string is enclosed either by single or double quotes. If a string contains several lines, it has to be enclosed by three double quotes <code class="literal">"""</code> or three single quotes <code class="literal">'''</code>.</p><p>Strings can be indexed with simple indexes or slices (refer to <a class="link" href="ch03.html" title="Chapter 3. Container Types">Chapter 3</a>, <span class="emphasis"><em>Container Types</em></span>, for a comprehensive explanation on slices):</p><pre class="programlisting">book[-1] # returns 'r' &#13;
book[-12:] # returns 'Scriptwriter'</pre><p>Strings are immutable; that is, items cannot be altered. They share this property with tuples. The command <span class="strong"><strong>
<code class="literal">book[1] = 'a'</code>
</strong></span> returns:</p><pre class="programlisting">TypeError: 'str' object does not support item assignment</pre><p>The string <code class="literal">'\n'</code> is used to insert a line break  and <code class="literal">'t'</code> inserts a horizontal tabulator (TAB) into the string to align several lines:</p><pre class="programlisting">print('Temperature:\t20\tC\nPressure:\t5\tPa')</pre><p>These strings are examples of <span class="emphasis"><em>escape sequences</em></span>. Escape sequences always start with a backslash, <code class="literal">\</code> . A multi line string automatically includes escape sequences:</p><pre class="programlisting">a=""" &#13;
A multiline &#13;
example""" &#13;
a #  returns '\nA multiline \nexample'</pre><p>A special escape sequence is <code class="literal">""</code>, which represents the backslash symbol in text:</p><pre class="programlisting">latexfontsize="\\tiny"</pre><p>The same can be achieved by using a raw string instead:</p><pre class="programlisting">latexfs=r"\tiny"   # returns "\tiny"&#13;
latexfontsize == latexfs  # returns True</pre><p>Note that in raw strings, the backslash remains in the string and is used to escape some special characters:</p><pre class="programlisting">r"<code class="literal">\</code>"<code class="literal">\</code>"   # returns  '<code class="literal">\\</code>"'&#13;
r"<code class="literal">\\</code>"   # returns  '<code class="literal">\\\\</code>'&#13;
r"<code class="literal">\</code>"    # returns an error</pre><div class="section" title="Operations on strings and string methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>Operations on strings and string methods</h2></div></div></div><p>Addition of strings means concatenation:</p><pre class="programlisting">last_name = 'Carlsson'&#13;
first_name = 'Johanna'&#13;
full_name = first_name + ' ' + last_name&#13;
                              # returns 'Johanna Carlsson'</pre><p>Multiplication is just repeated addition:</p><pre class="programlisting">game = 2 * 'Yo' # returns 'YoYo'</pre><p>When strings are compared, lexicographical order applies and the uppercase form precedes the lowercase form of the same letter:</p><pre class="programlisting">'Anna' &gt; 'Arvi' # returns false &#13;
'ANNA' &lt; 'anna'  # returns true &#13;
'10B' &lt; '11A'    # returns true</pre><p>Among the variety of string methods, we will mention here only the most important ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Splitting a string</strong></span>: This method generates a list from a string by using a single or multiple blanks as separators. Alternatively, an argument can be given by specifying a particular string as a separator:
<pre class="programlisting">      text = 'quod erat    demonstrandum'&#13;
      text.split() # returns ['quod', 'erat', 'demonstrandum']&#13;
      table = 'Johan;Carlsson;19890327'&#13;
      table.split(';') # returns ['Johan','Carlsson','19890327']&#13;
      king = 'CarlXVIGustaf'&#13;
      king.split('XVI')  # returns ['Carl','Gustaf']&#13;
&#13;
</pre></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Joining a list to a string</strong></span>: This is the reverse operation of splitting:
<pre class="programlisting">      sep = ';'&#13;
      sep.join(['Johan','Carlsson','19890327']) &#13;
      # returns 'Johan;Carlsson;19890327'&#13;
</pre></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Searching in a string</strong></span>: This method returns the first index in the string, where a given search substring starts:<pre class="programlisting">      birthday = '20101210'&#13;
      birthday.find('10') # returns 2 </pre><p>If the search string is not found, the return value of the method is -1 .</p></li></ul></div><div class="section" title="String formatting"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec9"/>String formatting</h3></div></div></div><p>String formatting is done using the <code class="literal">format</code> method:</p><pre class="programlisting">course_code = "NUMA21"&#13;
print("This course's name is {}".format(course_code)) &#13;
# This course's name is NUMA21</pre><p>The function <code class="literal">format</code> is a string method; it scans the string for the occurrence of placeholders, which are enclosed by curly brackets. These placeholders are replaced in a way specified by the argument of the format method. How they are replaced depends on the format specification defined in each <code class="literal">{}</code> pair. Format specifications are indicated by a colon, <code class="literal">":"</code>, as their prefix.</p><p>The format method offers a range of possibilities to customize the formatting of objects depending on their types. Of particular use in scientific computing are the formatting specifiers for the <code class="literal">float</code> type. One may choose either the standard with <code class="literal">{:f}</code> or the exponential notation with <code class="literal">{:e}</code>:</p><pre class="programlisting">quantity = 33.45&#13;
print("{:f}".format(quantity)) # 33.450000&#13;
print("{:1.1f}".format(quantity)) # 33.5&#13;
print("{:.2e}".format(quantity)) # 3.35e+01</pre><p>The format specifiers allow to specify the rounding precision (digits following the decimal point in the representation). Also the total number of symbols including leading blanks to represent the number can be set.</p><p>In this example, the name of the object that gets its value inserted is given as an argument to the format method. The first <code class="literal">{}</code> pair is replaced by the first argument and the following pairs by the subsequent arguments. Alternatively, it may also be convenient to use the key-value syntax:</p><pre class="programlisting">print("{name} {value:.1f}".format(name="quantity",value=quantity))&#13;
# prints "quantity 33.5"</pre><p>Here, two values are processed, a string <code class="literal">name</code> without a format specifier and a float <code class="literal">value</code> that is printed in fixed point notation with one digit after the decimal point. (We refer to the complete reference documentation for more details on <span class="emphasis"><em>string formatting</em></span>, <a class="link" href="apa.html" title="Appendix . References">[34]</a>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip8"/>Tip</h3><p>
</p><p>
<span class="strong"><strong>Braces in the string</strong></span>
</p><p>
</p><p>Sometimes, a string might contain a pair of curly braces, which should not be considered as placeholders for a <code class="literal">format</code> method. In that case, double braces are used:</p><p>
</p><p>
<code class="literal">r"we {} in LaTeX \begin{{equation}}".format('like')</code>
</p><p>
</p><p>This returns the following string: <code class="literal">'we like in LaTeX \\begin{equation}'</code>.</p><p>
</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, you met the basic data types in Python and saw the corresponding syntax elements. We will work mostly with numeric types such as integers, floats and complex.</p><p>Booleans are needed for setting conditions, and by using strings, we often communicate results and messages.</p></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Exercises</h1></div></div></div><p>
<span class="strong"><strong>Ex. 1 </strong></span>→ Check whether <span class="emphasis"><em>x = </em></span>2.3 is a zero of the function:</p><p>
</p><div class="mediaobject"><img src="graphics/polynomialCh2.jpg" alt="Exercises"/></div><p>
</p><p>
<span class="strong"><strong>Ex. 2 → </strong></span>According to de Moivre's formula, the following holds:</p><p>
</p><div class="mediaobject"><img src="graphics/deMoivre-1.jpg" alt="Exercises"/></div><p>
</p><p>Choose numbers <span class="emphasis"><em>n</em></span> and <span class="emphasis"><em>x</em></span> and verify that formula in Python.</p><p>
<span class="strong"><strong>Ex. 3 → </strong></span>Complex numbers. Verify Euler's formula in the same way:</p><p>
</p><div class="mediaobject"><img src="graphics/EulersFormula.jpg" alt="Exercises"/></div><p>
</p><p>
<span class="strong"><strong>Ex. 4 → </strong></span> Suppose we are trying to check the convergence of a diverging sequence (here the sequence is defined by the recursive relation<span class="emphasis"><em> u<sub>n</sub></em></span><sub>+1</sub>= 2<span class="emphasis"><em>u<sub>n</sub></em></span> and u<sub>0</sub> = 1.0):</p><pre class="programlisting">u = 1.0 # you have to use a float here!&#13;
uold = 10. &#13;
for iteration in range(2000):&#13;
    if not abs(u-uold) &gt; 1.e-8:&#13;
         print('Convergence')&#13;
         break # sequence has converged&#13;
    uold = u&#13;
    u = 2*u&#13;
else:&#13;
    print('No convergence')</pre><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Since the sequence does not converge, the code should print the <code class="literal">No convergence</code> message. Execute it to see what happens.</li><li class="listitem">What happens if you replace the line:<pre class="programlisting">      if not abs(u-uold) &gt; 1.e-8</pre><p>with:</p><pre class="programlisting">      if abs(u-uold) &lt; 1.e-8</pre><p>It should give exactly the same result, shouldn't it? Run the code again to see what happens.</p></li><li class="listitem">What happens if you replace <span class="emphasis"><em>u=1.0</em></span> by <span class="emphasis"><em>u=1</em></span> (without decimal point). Run the code to check your predictions.</li><li class="listitem">Explain the unexpected behavior of this code. The key to understand what happens is that <code class="literal">inf</code>evaluates to <code class="literal">nan</code>, and the comparison of <code class="literal">nan</code> with anything else is returns always the value <code class="literal"> False</code> . </li></ol></div><p>
<span class="strong"><strong>Ex. 5 → </strong></span> An implication<span class="emphasis"><em> C = (A ⇒ B)</em></span> is a Boolean expression that is defined as</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>C</em></span> is <code class="literal">True</code> if <span class="emphasis"><em>A</em></span> is <code class="literal">False</code> or <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>B</em></span> are both <code class="literal">True</code></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em> C </em></span>is <code class="literal">False</code> otherwise<p>Write a Python function <code class="literal">implication(A, B)</code>.</p></li></ul></div><p>
<span class="strong"><strong> Ex. 6 → </strong></span>This exercise is to train Boolean operations. Two binary digits (bits) are added by using a logical device called a<span class="strong"><strong> half adder</strong></span>. It produces a carry bit (the digit of the next higher value) and the sum as defined by the following table, and half adder circuit.</p><div class="informaltable"><table border="1"><colgroup><col/><col/><col/><col/></colgroup><tbody><tr><td>
<p>
</p><p>
<span class="strong"><strong>p</strong></span>
</p><p>
</p>
</td><td>
<p>
</p><p>
<span class="strong"><strong>q</strong></span>
</p><p>
</p>
</td><td>
<p>
</p><p>
<span class="strong"><strong>sum</strong></span>
</p><p>
</p>
</td><td>
<p>
</p><p>
<span class="strong"><strong>carry</strong></span>
</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>1</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>1</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td></tr><tr><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td><td>
<p>
</p><p>0</p><p>
</p>
</td></tr></tbody></table></div><p>Definition of the half adder operation</p><p>
</p><div class="mediaobject"><img src="graphics/half_adder.jpg" alt="Exercises"/></div><p>
</p><p>Figure 2.3: A half adder circuit</p><p>A full adder consists of two half adders and sums up two bits and an additional carry bit on the input (refer to the following figure):</p><p>
</p><div class="mediaobject"><img src="graphics/full_adder.jpg" alt="Exercises"/></div><p>
</p><p>Figure 2.4: A full adder circuit</p><p>Write a function that implements a half adder and another that implements a full adder. Test these functions.</p><p>
</p><p>
</p><p>
</p></div></body></html>