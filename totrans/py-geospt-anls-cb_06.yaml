- en: Chapter 6. Overlay Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Punching holes in polygons with a symmetric difference operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union polygons without merging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union polygons with merging (dissolving)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing an identity function (difference + intersection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discovering how two datasets spatially relate to each other when they are placed
    over one another is called overlay analysis. An overlay can be compared to a sheet
    of tracing paper. For example, you could overlay the tracing paper on top of your
    base map and see what areas overlap each other. This process is and was a game
    changer in spatial analysis and modeling. Computer-aided GIS computations can
    therefor automatically identify where two geometry sets spatially touch for example.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to give you a feel for the most common overlay analysis
    functions, such as unions, intersects, and symmetrical differences. These are
    based on the **Dimensionally Extended nine intersection model** (**DE-9IM**),
    which can be found at [http://en.wikipedia.org/wiki/DE-9IM](http://en.wikipedia.org/wiki/DE-9IM),
    and describes our list of possible overlays. All processes that we use or name
    here are derived using a combination of these nine predicates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/50790OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will explore these topology rules in depth in [Chapter 9](ch09.html "Chapter 9. Topology
    Checking and Data Validation"), *Topology Checking and Data Validation*.
  prefs: []
  type: TYPE_NORMAL
- en: Punching holes in polygons with a symmetric difference operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why, oh why would we want to punch holes in polygons and create a donut? Well,
    this is done for several reasons, for example, you may want to remove a lake polygon
    from a forest polygon that it overlaps since it sits in the middle of the forest
    and is, therefore, included in your area calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is where we have a set of polygons representing a golf course's
    fairways and a second set of polygons representing the greens that overlap these
    fairways. Our task is to calculate the correct number of square meters of fairways.
    The greens will create our donuts in a fairway's polygons.
  prefs: []
  type: TYPE_NORMAL
- en: This is translated into spatial operation terminology and means that we need
    to perform a `symmetric difference` operation or, in ESRI terminology, an "erase"
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Punching holes in polygons with a symmetric difference operation](img/50790OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we will create two sets of visualizations to see our results.
    Our output will generate **Well Known Text** (**WKT**) that is displayed in your
    browser using the **Openlayers 3** web mapping client.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, make sure you have all your code downloaded in your `/ch06`
    folder provided at GitHub and have this folder structure containing these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the folder structure in place, when you run the code, all inputs and outputs
    will find their correct home.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to run this code from the command line as usual, which runs in your
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following statement from your `/ch06/code` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code is where interesting operations take place with Shapely:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your output will be available in the `/ch06/code/ol3/html/` folder with the
    `ch06-01_sym_diff.html` filename. Simply open this file in your local web browser,
    such as Chrome, Firefox, or Safari. Our output web map was created by modifying
    the Openlayers 3 example code pages according to our needs. The resulting web
    map should display the following map in your local web browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You can now clearly see a hole inside our fairway.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin with, we use two **GeoJSON** datasets as our input, both with EPSG:
    3857 and stemming from the OSM EPSG: 4326\. The transformation process is not
    covered here; take a look at [Chapter 2](ch02.html "Chapter 2. Working with Projections"),
    *Working with Projections*, for further information on how to transform data between
    two coordinate systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to read in both the GeoJSON files into Python dictionaries
    objects using the standard Python `json` module. Next, we set up some empty lists
    that will store the Shapely geometry objects as a list used for our input to generate
    the needed `MultiPolygons` for our analysis. We use the Shapely built-in `asShape()`
    function to create the Shapely geometry objects so that we can perform the spatial
    operations. This is accomplished by accessing the dictionaries' `['geometry']`
    element. We then append each geometry to our empty list. This list is then inputted
    into the Shapely `MultiPolygon()` function that will create a MultiPolygon for
    us and is used as our inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The actual process of running our `symmetric_difference` happens when we input
    the `fairways_plys` MultiPolygon as input and the parameter passed is the `greens_ply`
    MultiPolygon. The output is stored in the `result` variable, which itself is also
    a MultiPolygon. Not to forget, a MultiPolygon is just a list of polygons that
    we can iterate over.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll take a look at a function called `write_wkt(filepath, features)`.
    This outputs our resulting MultiPolygon Shapely geometry to the `Well Known Text
    (WKT)` format. We do not simply output this `WKT` but instead, create a new JavaScript
    file, `ol3/data/ch06-01_results_sym_diff.js`, containing our `WKT` output. The
    code outputs a string that creates a JavaScript variable called `ply_data`. This
    `ply_data` variable is then used in our HTML file located at `/ch06/code/ol3/html/sym_diff.html`
    to draw our `WKT` vector layer using Openlayers 3\. We then call our function
    and it executes the write to the `WKT` JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: This example is the first that visualizes our results as a web map. In [Chapter
    11](ch11.html "Chapter 11. Web Analysis with GeoDjango"), *Web Analysis with GeoDjango*,
    we will explore a fully functional web mapping application; for those of you who
    cannot wait, you may want to jump ahead. Further examples will continue to use
    Openlayers 3 as our data viewer, moving away from using Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, our simple one-line symmetric difference execution needed a lot
    of helper code to deal with importing GeoJSON data and exporting the results in
    a format that could display a web map with Openlayers 3.
  prefs: []
  type: TYPE_NORMAL
- en: Union polygons without merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate what merging is all about, we will take an example from the **National
    Oceanic and Atmospheric Administration** (**NOAA**) weather data. It provides
    an awesome minute-by-minute update of Shapefiles for your desire to download data.
    We will look at a one-week collection of weather warnings, and combine these with
    state boundaries to see where exactly warnings occurred within a state boundary.
  prefs: []
  type: TYPE_NORMAL
- en: '![Union polygons without merging](img/50790OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows us the polygons before the union operation in
    QGIS.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure your virtual environment is, as always, fired up and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, switch to your `/ch06/code/` folder to find finished code examples or
    create your empty file in the `/ch06/`working folder and follow along with the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pyshp` and `shapely` libraries are our two workhorses for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simply run this file in the command prompt to see the results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Results can then be opened in the `/ch06/code/ol3/html/ch06-02_union.html`
    folder with a double-click to start them in your local web browser. You should
    see the following web map if everything''s gone smoothly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_06_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now let''s take a look at the code that makes it all happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A quick high-level run-through of what is going on here at the beginning should
    help clear the air. We have four functions and nine variables within our Python
    code to split the load of input and output data. The running of our code takes
    place in the `if __name__ == "main":` call that is found at the end of the code.
    We start defining two variables to deal with our inputs that we are going to **union**
    together. These two are our input Shapefiles and the other three outputs are GeoJSON
    and JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_shapes()`function converts our Shapefile into Shapely `MultiPolygon`
    geometry objects. Inside the Python class, the list comprehension is used to generate
    a new list of polygon objects, which are the input list of polygons used to create
    our output `MultiPolygon`. Next, we'll simply run this function passing in our
    input Shapefiles.
  prefs: []
  type: TYPE_NORMAL
- en: Our `create_union()` function is up next where we do the real union work. We
    begin by unioning the two geometry boundaries together that produces a union set
    of LineStrings and represents the outer bounds of our input polygons. The reason
    for this is that we do not want to lose the geometries of both polygons, which
    will, by default, dissolve into one big polygon when simply passed into the Shapely
    union function. Therefore, we need to rebuild the polygons with the `polygonize()`
    Shapely function.
  prefs: []
  type: TYPE_NORMAL
- en: The `polygonize` function creates a Python **generator** object, not a simple
    geometry. This is an *iterator* that's similar to a *list* that we need to loop
    over to get at the individual polygons it's created for us.
  prefs: []
  type: TYPE_NORMAL
- en: We do exactly this in the next code segment using the `enumerate()` Python function
    that automatically creates an ID for us for each feature that we use as the id
    field in the attribute results. After our loop, we use the standard Python `json.dump()`
    method to export our newly created GeoJSON file and write it to disk using the
    Python `open()` method in the write mode.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, in our `create_union()` function, we prepare to output our resulting
    **union** polygon as a Shapely MultiPolygon object. This is accomplished simply
    by looping through the `polygonize()` iterator and outputting a list that feeds
    into the Shapely `MultiPolygon()`function. Finally, we execute the union function,
    passing in our two input geometries and specifying the output GeoJSON file.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can view our results in our web map as we did in the previous exercise
    using a small function called `write_wkt()`. This little function takes the file
    path to the output JavaScript file that we want to create and the MultiPolygon
    result's geometry. Shapely then dumps the geometry into the Well Known Text format
    as we write it out to the JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, a small function called `output_geojson_fc()` is used to output
    another GeoJSON file, this time using the Python `geojson` library. This simply
    shows you another way to recreate a GeoJSON file. Since GeoJSON is a plain text
    file, it is possible to create it in many unique ways depending on your personal
    programming preference.
  prefs: []
  type: TYPE_NORMAL
- en: Union polygons with merging (dissolving)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate what merging is all about, we will take an example out of the
    NOAA weather data. It provides an awesome minute-by-minute update of Shapefiles
    to satisfy your desire to download data. We will look at a week's collection of
    weather warnings and union these warnings together, giving us the total warning
    area issued in this week.
  prefs: []
  type: TYPE_NORMAL
- en: 'A conceptual visualization of our desired results is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Union polygons with merging (dissolving)](img/50790OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of the data is located around Florida, but has some polygons near Hawaii
    and California. To see the original data or find new data, check out these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.nws.noaa.gov/geodata/catalog/wsom/html/pubzone.htm](http://www.nws.noaa.gov/geodata/catalog/wsom/html/pubzone.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nws.noaa.gov/regsci/gis/week.html](http://nws.noaa.gov/regsci/gis/week.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.nws.noaa.gov/geodata/index.html](http://www.nws.noaa.gov/geodata/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to see the state boundaries, you can find them at [https://www.census.gov/geo/maps-data/data/cbf/cbf_state.html](https://www.census.gov/geo/maps-data/data/cbf/cbf_state.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what a sample of the data looks like around Florida before the union,
    which is visualized with QGIS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Union polygons with merging (dissolving)](img/50790OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The usual order of business is needed to get going with this code. Fire up your
    virtual environment and check whether your data is all downloaded and located
    in your `/ch06/geodata/` folder. If all is ready, jump right in and start typing
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our data is a little messy to say the least, so please follow our steps outlining
    a solution to allow us to process and run the analysis function, `union`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Your resulting web map will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are starting to increasingly reuse more code that is now tucked away in our
    `/ch06/code/utils.py` module. As you see in the imports, we use three functions
    for the standard input and output of data. The main application starts with defining
    our NOAA input Shapefile and defining the output GeoJSON file. Then, if we run
    the code, it will crash due to data validity issues. So, we create a new function
    to check our input data for invalid geometries. This new function will catch these
    invalid geometries and convert them to valid polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Shapely has a geometry property called `is_valid`, which accesses the GEOS engine
    to check for geometry validity based on the simple features in the OGC specification.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for all the possible invalid data possibilities, you can
    find more information on the Open Geospatial Consortium website. Check out the
    Simple Features Standard on page *28*; you will find the examples of invalid polygons
    at [http://portal.opengeospatial.org/files/?artifact_id=25355](http://portal.opengeospatial.org/files/?artifact_id=25355).
  prefs: []
  type: TYPE_NORMAL
- en: The reason for these anomalies is that when data is overlaid and processed,
    geometries become combined or cut at angles that are not always optimal.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we have clean data to work with, making the rest of our journey very
    simple by running the Shapely `cascaded_union()` function, which will dissolve
    all our overlapping polygons. Our resulting MultiPolygons are pushed further into
    our `out_geoj()` function, which finally writes the new geometries to disk in
    our `/ch06/geodata` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Performing an identity function (difference + intersection)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ESRI geoprocessing terminology, there is an overlay function called `identity`.
    This is a very useful function to call when you want to keep all the original
    geometry boundaries of ONLY the input features combined with an intersection of
    input features.
  prefs: []
  type: TYPE_NORMAL
- en: '![Performing an identity function (difference + intersection)](img/50790OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This boils down to a formula that calls for both `difference` and `intersect`.
    We first find the difference (`input feature - intersection`), then add the intersection
    to create our results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For all you curious folks who want to learn how to do this, type out the following
    code; it will help your muscle memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting polygons can now be visualized in your browser. Now simply open
    the `/ch06/code/ol3/html/ch06-04_identity.html` file and you will see this map:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/50790OS_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have hidden away a couple of gems in our `util.py` utilities file called
    `shp2_geojson_obj` and `out_geoj`. The first one takes in our Shapefile and returns
    a Python dictionary object. Our function actually creates a valid GeoJSON in the
    form of a Python dictionary that could very easily be converted to a JSON string
    using the standard `json.dumps()`Python module.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this overhead out of the way, we can jump into creating Shapely geometries
    that can be used for our analysis. The `create_polys()`function does exactly this:
    it takes in our geometries, returning a `MultiPolygon`. This `MultiPolygon` is
    used to calculate our difference and intersection.'
  prefs: []
  type: TYPE_NORMAL
- en: So, at last, we can do the analysis calculation starting with the Shapely difference
    function using our `temp1-ply.shp` as our input feature and `temp2-poly.shp` as
    our identity feature. The difference function only returns the geometries of the
    input features that do not intersect the other feature. Next up, we execute the
    intersection function that only returns geometries that overlap between our two
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Our recipe is almost completed; we only need to combine these two new results
    to produce our new identity result's MultiPolygon. The `create_out()`function
    takes two arguments, the first being our input features and the second is our
    resulting intersection features. The order is very important; otherwise your results
    will be reversed. So make sure that you enter the correct order of input.
  prefs: []
  type: TYPE_NORMAL
- en: We run through each of the geometries and combine them into a fancy new `MultiPolygon`
    called `result_identity`. This is then pumped into our `out_geoj()` function,
    which writes out a new GeoJSON file to your `/ch06/geodata`/ folder.
  prefs: []
  type: TYPE_NORMAL
- en: Our `out_geoj()` function is located in the `utils.py` file and might need a
    quick explanation. The input is a list of geometries and the file path of the
    output GeoJSON file location on disk. We simply create a new dictionary, and then
    loop through each geometry, exporting the Shapely geometry to a GeoJSON file using
    the built-in Shapely `__geo_interface__`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to read up on the `__geo_interface__,` do so for yourself and find
    out what it is and why it's so cool at [https://gist.github.com/sgillies/2217756](https://gist.github.com/sgillies/2217756).
  prefs: []
  type: TYPE_NORMAL
- en: 'For those of you looking for the two utility functions, here they are for your
    reading pleasure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
