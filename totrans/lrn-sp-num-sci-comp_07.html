<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;SciPy for Computational Geometry"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. SciPy for Computational Geometry</h1></div></div></div><p>In this chapter, we will be covering the fundamentals of SciPy to develop programs in this <a id="id332" class="indexterm"/>very specialized topic: <span class="strong"><strong>Computational Geometry</strong></span>. Two examples will be used to illustrate the use of SciPy functions in this area. To be able to profit from the first example, you might want to have handy a copy of <span class="emphasis"><em>Computational Geometry: Algorithms and Applications Third Edition</em></span>, <span class="emphasis"><em>de Berg M.</em></span>, <span class="emphasis"><em>Cheong O.</em></span>, <span class="emphasis"><em>van Kreveld M.</em></span>, and <span class="emphasis"><em>Overmars M.</em></span>, <span class="emphasis"><em>Springer Publishing</em></span>. The second example, on which the <span class="strong"><strong>Finite Element Method</strong></span> is used to solve a two-dimensional problem <a id="id333" class="indexterm"/>involving the numerical solution of the Laplace Equation, could be followed without trouble with knowledge on the topic described in <span class="emphasis"><em>Introduction to the Finite Element Method</em></span>, <span class="emphasis"><em>Ottosen N. S.</em></span> and <span class="emphasis"><em>Petersson H.</em></span>, <span class="emphasis"><em>Prentice Hall</em></span>.</p><p>Let's start by covering the routines in the <code class="literal">scipy.spatial</code> module that deal with the construction of triangulations of points in spaces of any dimension, and the corresponding convex hulls. </p><p>The procedure is simple; given a set of <span class="emphasis"><em>m</em></span> points in the <span class="emphasis"><em>n</em></span>-dimensional space (which we represent as an <span class="emphasis"><em>m</em></span> x <span class="emphasis"><em>n</em></span> NumPy array), we create the <code class="literal">scipy.spatial</code> class <code class="literal">Delaunay</code>, containing a triangulation formed by those points:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import scipy.stats </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy.spatial </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; data = scipy.stats.randint.rvs(0.4,10,size=(10,2))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; triangulation = scipy.spatial.Delaunay(data)</strong></span>
</pre></div><p>Any <code class="literal">Delaunay</code> class has the basic search attributes such as <code class="literal">points</code> (to obtain the set of points in the triangulation), <code class="literal">vertices</code> (that offer the indices of vertices forming simplices in the triangulation), <code class="literal">neighbors</code> (for the indices of neighbor simplices of each simplex—with the convention that "-1" indicates no neighbor for simplices at the boundary).</p><p>More advanced attributes, for example, <code class="literal">convex_hull</code>, indicate the indices of the vertices that form the convex hull of the given points. If we desire to search for the simplices that share a given vertex, we may do so with the <code class="literal">vertex_to_simplex</code> method. If, instead, we desire to locate the simplices that contain any given point in the space, we do so with the <code class="literal">find_simplex</code> method.</p><p>At this stage we would like to point out the intimate relationship between triangulations and Voronoi diagrams, and offer a simple coding exercise. Let us start by first choosing a random set of points, and obtaining the corresponding triangulation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from numpy.random import RandomState</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; rv = RandomState(123456789)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; locations = rv.randint(0, 511, size=(2,8))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; triangulation=scipy.spatial.Delaunay(locations.T)</strong></span>
</pre></div><p>We may use the <code class="literal">matplotlib.pyplot</code> routine <code class="literal">triplot</code> to obtain a graphical representation of this triangulation. We first need to obtain the set of computed simplices. <code class="literal">Delaunay</code> offers us this set, but by means of the indices of the vertices instead of their coordinates. We, thus, need to map these indices to actual points before feeding the set of simplices to the <code class="literal">triplot</code> routine:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; assign_vertex = lambda index: triangulation.points[index]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; triangle_set = map(assign_vertex, triangulation.vertices)</strong></span>
</pre></div><p>We will now obtain the edge map of the Voronoi diagram in a similar fashion as we did before (this time using the <code class="literal">scipy.spatial.Voronoi</code> module), and plot it together with the triangulation. This is done by the following lines of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; voronoiSet=scipy.spatial.Voronoi(locations.T)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scipy.spatial.voronoi_plot_2d(voronoiSet)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fig = plt.figure()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; thefig = plt.subplot(1,1,1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; scipy.spatial.voronoi_plot_2d(voronoiSet, ax=thefig)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.triplot(locations[1], locations[0], triangles=triangle_set, color='r')</strong></span>
</pre></div><p>Let's take a look at the following <code class="literal">xlim()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.xlim((0,550))</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong> (0, 550)</strong></span>
</pre></div><p>Now, let's take a look at following <code class="literal">ylim()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.ylim((0,550))</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong> (0, 550)</strong></span>
</pre></div><p>We now plot the edge map of the Voronoi diagram together with triangulation in the following <code class="literal">plt.show()</code> command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>The output is shown as follows:</p><div class="mediaobject"><img src="graphics/7702OS_07_01.jpg" alt="SciPy for Computational Geometry"/></div><p>Note how the triangulation and the corresponding Voronoi diagrams are dual of each other; each edge in the triangulation (red) is perpendicular with an edge in the Voronoi diagram (white). How should we use this observation to code an actual Voronoi diagram for a cloud of points? The actual Voronoi diagram is the set of vertices and edges that composes it. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Interesting <a id="id334" class="indexterm"/>ways to find the Voronoi diagram can be found at <a class="ulink" href="http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d">http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d</a>.</p></div></div><p>Let us finish this chapter with two applications of scientific computing that use these techniques extensively, in combination with routines from other SciPy modules.</p><div class="section" title="The structural model of oxides"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec55"/>The structural model of oxides</h1></div></div></div><p>In this<a id="id335" class="indexterm"/> example, we will cover the extraction of the structural <a id="id336" class="indexterm"/>model of a molecule of a bronze-type <span class="strong"><strong>Niobium oxide</strong></span>, from <span class="strong"><strong>HAADF-STEM</strong></span>
<a id="id337" class="indexterm"/> micrographs (further background on this topic can be found in <span class="emphasis"><em>Chapter 5</em></span>, <span class="emphasis"><em>High-Quality Image Formation by Nonlocal Means Applied to High-Angle Annular Dark-Field Scanning Transmission Electron Microscopy (HAADF--STEM)</em></span> of the book <span class="emphasis"><em>Modeling Nanoscale Imaging in Electron Microscopy</em></span>, <span class="emphasis"><em>Vogt T.</em></span>, <span class="emphasis"><em>Dahmen W.</em></span>, and <span class="emphasis"><em>Binev P.</em></span>, <span class="emphasis"><em>Springer Publishing</em></span>.</p><p>The following <a id="id338" class="indexterm"/>diagram shows the HAADF-STEM micrograph of a bronze-type Niobium oxide (taken from <a class="ulink" href="http://www.microscopy.ethz.ch/BFDF-STEM.htm">http://www.microscopy.ethz.ch/BFDF-STEM.htm</a>):</p><div class="mediaobject"><img src="graphics/7702OS_07_02.jpg" alt="The structural model of oxides"/><div class="caption"><p>Courtesy: ETH Zurich</p></div></div><p>For pedagogical purposes, we took the following approach to solving this problem:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Segmentation of the atoms by thresholding and morphological operations.</li><li class="listitem" style="list-style-type: disc">Connected component labeling to extract each single atom for posterior examination.</li><li class="listitem" style="list-style-type: disc">Computation of the centers of mass of each label identified as an atom. This presents us with a lattice of points in the plane that shows a first insight in the structural model of the oxide.</li><li class="listitem" style="list-style-type: disc">Computation of the Voronoi diagram of the previous lattice of points. The combination of information with the output of the previous step will lead us to a decent (approximation of the actual) structural model of our sample.</li></ul></div><p>Let us proceed in this direction.</p><p>Once retrieved and saved in the current working directory, our HAADF-STEM images will be read in python and stored by default (depending on your computer architecture) as big matrices with <code class="literal">float32</code> or <code class="literal">float64</code> precision. For this project, it is enough to retrieve some tools from the <code class="literal">scipy.ndimage</code> module, and some procedures from the <code class="literal">matplotlib</code> library. The preamble then looks like the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.ndimage import *</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.misc import imfilter</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.cm as cm</strong></span>
</pre></div><p>The<a id="id339" class="indexterm"/> image is loaded with the <code class="literal">imread(filename)</code> command. This stores the image as a <code class="literal">numpy.array</code> with <code class="literal">dtype = float32</code>. Notice that the image is rescaled so that the maxima and minima are <code class="literal">1.0</code> and <code class="literal">0.0</code>, respectively. Other interesting information about the image can be retrieved as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; img=imread('./NbW-STEM.png')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; minVal = numpy.min(img) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; maxVal = numpy.max(img) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; img = (1.0/(maxVal-minVal))*(img - minVal) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(img, cmap = cm.Greys_r)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Image dtype: %s"%(img.dtype)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Image size: %6d"%(img.size)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Image shape: %3dx%3d"%(img.shape[0],img.shape[1])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Max value %1.2f at pixel %6d"%(img.max(),img.argmax())</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Min value %1.2f at pixel %6d"%(img.min(),img.argmin())</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; print "Variance: %1.5f\nStandard deviation: \ </strong></span>
<span class="strong"><strong>    %1.5f"%(img.var(),img.std())</strong></span>
</pre></div><p>This provides the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>Image dtype: float64</strong></span>
<span class="strong"><strong>Image size:  87025</strong></span>
<span class="strong"><strong>Image shape: 295x295</strong></span>
<span class="strong"><strong>Max value 1.00 at pixel  75440</strong></span>
<span class="strong"><strong>Min value 0.00 at pixel   5703</strong></span>
<span class="strong"><strong>Variance: 0.02580</strong></span>
<span class="strong"><strong>Standard deviation: 0.16062</strong></span>
</pre></div><p>We perform thresholding by imposing an inequality in the array holding the data. The output is a Boolean array where <code class="literal">True</code> (white) indicates that the inequality has been fulfilled, and <code class="literal">False</code> (black) otherwise. We may perform at this point several thresholding operations and visualize them to obtain the best threshold for segmentation purposes. The following images show several examples (different thresholdings applied to the oxide image):</p><div class="mediaobject"><img src="graphics/7702OS_07_03.jpg" alt="The structural model of oxides"/></div><p>The<a id="id340" class="indexterm"/> following lines of code generate that oxide image:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.subplot(1, 2, 1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(img &gt; 0.2, cmap = cm.Greys_r)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xlabel('img &gt; 0.2')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.subplot(1, 2, 2) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.imshow(img &gt; 0.7, cmap = cm.Greys_r)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.xlabel('img &gt; 0.7')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>By visual inspection of several different thresholds, we choose <code class="literal">0.62</code> as one that gives us a good map showing what we need for segmentation. We need to get rid of <span class="emphasis"><em>outliers</em></span>, though: small particles that might fulfill the given threshold but are small enough not to be considered as actual atoms. Therefore, in the next step we perform a morphological operation of opening to get rid of those small particles. We decided that anything smaller than a square of size 2 x 2 is to be eliminated from the output of thresholding:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; BWatoms = (img&gt; 0.62)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; BWatoms = binary_opening(BWatoms,structure=numpy.ones((2,2)))</strong></span>
</pre></div><p>We are ready for segmentation, which will be performed with the <code class="literal">label</code> routine from the <code class="literal">scipy.ndimage</code> module. It collects one slice per segmented atom and offers the number of slices computed. We need to indicate the connectivity type. For instance, in the following toy example, do we want to consider that situation as two atoms or one atom?</p><div class="mediaobject"><img src="graphics/7702OS_07_04.jpg" alt="The structural model of oxides"/></div><p>It <a id="id341" class="indexterm"/>depends; we would rather have it now as two different connected components, but for some other applications we might consider that they are one. The way we indicate the connectivity to the <code class="literal">label</code> routine is by means of a structuring element that defines feature connections. For example, if our criterion for connectivity between two pixels is that their edges are adjacent, then the structuring element looks like the image shown on the left-hand side from the images shown next. If our criterion for connectivity between two pixels is that they are also allowed to share a corner, then the structuring element looks like the image on the right-hand side. </p><p>For each pixel we impose the chosen structuring element and count the intersections; if there are no intersections, then the two pixels are not connected. Otherwise, they belong to the same connected component.</p><div class="mediaobject"><img src="graphics/7702OS_07_05.jpg" alt="The structural model of oxides"/></div><p>We need to make sure that atoms that are too close diagonally are counted as two, rather than one, so we chose the structuring element on the left. The script then reads as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; structuring_element = [[0,1,0],[1,1,1],[0,1,0]]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; segmentation,segments = label(BWatoms,structuring_element)</strong></span>
</pre></div><p>The <code class="literal">segmentation</code> object contains a list of slices, each with a Boolean matrix containing each of the found atoms of the oxide. We may obtain a great deal of useful information for each slice. For example, the coordinates of the center of mars (<code class="literal">centers_of_mass</code>) of each atom can be retrieved with the following commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; coords = center_of_mass(img, segmentation, range(1,segments+1))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; xcoords = numpy.array([x[1] for x in coords])</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ycoords = numpy.array([x[0] for x in coords])</strong></span>
</pre></div><p>Note that because of the way matrices are stored in memory, there is a transposition of the <code class="literal">x</code> and <code class="literal">y</code> coordinates of the locations of the pixels. We need to take this into account.</p><p>Notice the overlap of the computed lattice of points over the original image (the left-hand side image from the two images shown next). We may obtain it with the following commands:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.imshow(img, cmap = cm.Greys_r) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.axis('off') </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(xcoords,ycoords,'b.') </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show() </strong></span>
</pre></div><p>We have <a id="id342" class="indexterm"/>successfully found the centers of mass for most atoms, although there are still about a dozen regions where we are not too satisfied with the result. It is time to fine-tune by the simple method of changing the values of some variables; play with the threshold, with the structuring element, with different morphological operations, and so on. We can even add all the obtained information for a wide range of those variables, and filter out outliers. An example with optimized segmentation is shown, as follows (look at the right-hand side image):</p><div class="mediaobject"><img src="graphics/7702OS_07_06.jpg" alt="The structural model of oxides"/></div><p>For the purposes of this exposition, we are happy to keep it simple and continue working with the set of coordinates that we have already computed. We will be now offering an approximation to the lattice of the oxide, computed as the edge map of the Voronoi diagram of the lattice:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; L1,L2 = distance_transform_edt(segmentation==0, return_distances=False, return_indices=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Voronoi = segmentation[L1,L2]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Voronoi_edges= imfilter(Voronoi,'find_edges')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Voronoi_edges=(Voronoi_edges&gt;0)</strong></span>
</pre></div><p>Let us overlay the result of <code class="literal">Voronoi_edges</code> with the locations of the found atoms:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.imshow(Voronoi_edges); plt.axis('off'); plt.gray()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(xcoords,ycoords,'r.',markersize=2.0)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>This gives<a id="id343" class="indexterm"/> the following output, which represents the structural model we were searching for (recall that we started from an image where we wanted to find the structural model of a molecule):</p><div class="mediaobject"><img src="graphics/7702OS_07_07.jpg" alt="The structural model of oxides"/></div></div></div>
<div class="section" title="A finite element solver for Laplace's equation"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec56"/>A finite element solver for Laplace's equation</h1></div></div></div><p>We use<a id="id344" class="indexterm"/> finite elements when the size of the<a id="id345" class="indexterm"/> data is so large that its results prohibit dealing with finite differences. To illustrate this case, we would like to explore the numerical solution of the Laplace equation, subject to certain boundary conditions.</p><p>We will start by defining the computational domain and produce a mesh dividing this domain using triangles as local finite elements. This will be our starting point to solve this problem using finite elements, as we will be placing on the computational domain a piecewise continuous function, whose pieces are linear and supported on each of the triangles.</p><p>We start by calling the necessary modules to build the mesh (other modules will be called as they are required):</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import numpy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from numpy import linspace</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import scipy</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.spatial import Delaunay</strong></span>
</pre></div><p>First we define the region:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; xmin = 0 ; xmax = 1 ; nXpoints = 10</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ymin = 0 ; ymax = 1 ; nYpoints = 10</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; horizontal = linspace(xmin,xmax,nXpoints)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vertical = linspace(ymin,ymax,nYpoints)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; y, x = numpy.meshgrid(horizontal, vertical)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; vertices = numpy.array([x.flatten(),y.flatten()])</strong></span>
</pre></div><p>We <a id="id346" class="indexterm"/>may now <a id="id347" class="indexterm"/>create the triangulation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; triangulation = Delaunay(vertices.T)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; index2point = lambda index: triangulation.points[index]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; all_centers = index2point(triangulation.vertices).mean(axis=1)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; trngl_set=triangulation.vertices</strong></span>
</pre></div><p>We then have the following triangulation:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; plt.triplot(vertices[0],vertices[1],triangles=trngl_set)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show()</strong></span>
</pre></div><p>This produces the following graph:</p><div class="mediaobject"><img src="graphics/7702OS_07_08.jpg" alt="A finite element solver for Laplace's equation"/></div><p>In this<a id="id348" class="indexterm"/> case, the problem we have chosen is<a id="id349" class="indexterm"/> a standard one in mathematical methods in Physics and Engineering, consisting of solving the two-dimensional Laplace's equation on the unit square region, with zero <span class="strong"><strong>Dirichlet</strong></span> boundary conditions on three sides and, on the fourth side, a constant. Physically, this problem could represent diffusion of temperature on a two-dimensional plate. Mathematically, the problem is formulated in the following form:</p><div class="mediaobject"><img src="graphics/7702OS_07_09.jpg" alt="A finite element solver for Laplace's equation"/></div><p>The solution of this form can be given in terms of Fourier series as follows:</p><div class="mediaobject"><img src="graphics/7702OS_07_10.jpg" alt="A finite element solver for Laplace's equation"/></div><p>This is<a id="id350" class="indexterm"/> important as you can check the <a id="id351" class="indexterm"/>correctness of the obtained numerical solution before attempting to use your numerical scheme to tackle more complex problems in complex computational domains. It should be mentioned, however, that there are alternatives in Python that implement the finite element method to solve partial differential equations. In this regard, the reader could consult the <span class="strong"><strong>Fenics</strong></span> project (<a class="ulink" href="http://fenicsproject.org/book/">http://fenicsproject.org/book/</a>) and the <span class="strong"><strong>SfePy</strong></span> project (<a class="ulink" href="http://sfepy.org/doc-devel/index.html">http://sfepy.org/doc-devel/index.html</a>).</p><p>We code the solution in the usual fashion. We first compute the stiff matrix <span class="emphasis"><em>A</em></span> (which for obvious reasons is <code class="literal">sparse</code>). Then, the construction of the vector, <span class="emphasis"><em>R</em></span>, holding global boundary conditions is defined (the way we have constructed our mesh makes defining this vector straightforward). With them, the solution to the system comes from the solution <span class="emphasis"><em>X</em></span> obtained from solving a matrix equation of the form <span class="emphasis"><em>AX=R</em></span> using a subset of the matrices <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>R</em></span> corresponding to the nodes different from those on the boundaries. This should be no trouble for SciPy. Let us start with the stiff matrix:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from numpy import  cross </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from scipy.sparse import dok_matrix </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; points=triangulation.points.shape[0]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stiff_matrix=dok_matrix((points,points))</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; for triangle in triangulation.vertices:</strong></span>
<span class="strong"><strong>        helper_matrix=dok_matrix((points,points))</strong></span>
<span class="strong"><strong>        pt1,pt2,pt3=index2point(triangle)</strong></span>
<span class="strong"><strong>        area=abs(0.5*cross(pt2-pt1,pt3-pt1))</strong></span>
<span class="strong"><strong>        coeffs=0.5*numpy.vstack((pt2-pt3,pt3-pt1,pt1-pt2))/area</strong></span>
<span class="strong"><strong>        #helper_matrix[triangle,triangle] = \ </strong></span>
<span class="strong"><strong>        array(mat(coeffs)*mat(coeffs).T)</strong></span>
<span class="strong"><strong>        u=None </strong></span>
<span class="strong"><strong>        u=numpy.array(numpy.mat(coeffs)*numpy.mat(coeffs).T) </strong></span>
<span class="strong"><strong>        for i in range(len(triangle)):</strong></span>
<span class="strong"><strong>            for j in range(len(triangle)):</strong></span>
<span class="strong"><strong>                helper_matrix[triangle[i],triangle[j]] = u[i,j] </strong></span>
<span class="strong"><strong>        stiff_matrix=stiff_matrix+helper_matrix</strong></span>
</pre></div><p>Note that this is the cumbersome way to update the matrix <code class="literal">stiff_matrix</code>. This is due to the fact that the matrix is <code class="literal">sparse</code>, and the current choice of representation does not behave well with indexing.</p><p>To <a id="id352" class="indexterm"/>compute the global boundary vector we<a id="id353" class="indexterm"/> need to collect all edges on the boundary first and then assign to the nodes with <span class="emphasis"><em>x=1</em></span> that the function is one and to the others that the function is zero. Because of the way we set up the mesh this is easy as the nodes on which the function will take the value of one are always the last entries in the global boundary vector. This is accomplished by the following lines of code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; allNodes = numpy.unique(trngl_set) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; boundaryNodes = numpy.unique(triangulation.convex_hull) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; NonBoundaryNodes = numpy.array([]) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; for x in allNodes: </strong></span>
<span class="strong"><strong>        if x not in boundaryNodes: </strong></span>
<span class="strong"><strong>            NonBoundaryNodes = numpy.append(NonBoundaryNodes,x) </strong></span>
<span class="strong"><strong>    NonBoundaryNodes = NonBoundaryNodes.astype(int) </strong></span>
<span class="strong"><strong>    nbnodes = len(boundaryNodes) # number of boundary nodes </strong></span>
<span class="strong"><strong>    FbVals=numpy.zeros([nbnodes,1]) # Values on the boundary </strong></span>
<span class="strong"><strong>    FbVals[(nbnodes-nXpoints+1):-1]=numpy.ones([nXpoints-2, 1])</strong></span>
</pre></div><p>We are ready to find the numerical solution to the problem with the values obtained in our previous step:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; totalNodes = len(allNodes) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stiff_matrixDense = stiff_matrix.todense() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stiffNonb = \ </strong></span>
<span class="strong"><strong>    stiff_matrixDense[numpy.ix_(NonBoundaryNodes,NonBoundaryNodes)] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; stiffAtb = \ </strong></span>
<span class="strong"><strong>    stiff_matrixDense[numpy.ix_(NonBoundaryNodes,boundaryNodes)] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; U=numpy.zeros([totalNodes, 1]) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; U[NonBoundaryNodes] = numpy.linalg.solve( - stiffNonb , \</strong></span>
<span class="strong"><strong>    stiffAtb * FbVals ) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; U[boundaryNodes] = FbVals </strong></span>
</pre></div><p>This produces the following image depicting the diffusion of temperature inside the square:</p><div class="mediaobject"><img src="graphics/7702OS_07_11.jpg" alt="A finite element solver for Laplace's equation"/></div><p>This <a id="id354" class="indexterm"/>graph <a id="id355" class="indexterm"/>was obtained in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; X = vertices[0] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Y = vertices[1] </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Z = U.T.flatten() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; from mpl_toolkits.mplot3d import axes3d</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fig = plt.figure() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ax = fig.add_subplot(111, projection='3d') </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; surf = ax.plot_trisurf(X, Y, Z, cmap=cm.jet, linewidth=0) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fig.colorbar(surf) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; fig.tight_layout() </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ax.set_xlabel('X',fontsize=16)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ax.set_ylabel('Y',fontsize=16)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ax.set_zlabel(r"$\phi$",fontsize=36)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show() </strong></span>
</pre></div><p>An important point in numerical analysis is to evaluate the quality of the numerical solution obtained to any problem. In this case, we have chosen a problem whose analytical solution<a id="id356" class="indexterm"/> is<a id="id357" class="indexterm"/> available (see the preceding code), so one could check (not prove) the validity of the numerical algorithm implemented to solve our problem. In this case the analytical solution can be coded in the following manner:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from numpy import pi, sinh, sin, cos, sum</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; def f(x,y): </strong></span>
<span class="strong"><strong>        return sum( 2*(1.0/(n*pi) - \</strong></span>
<span class="strong"><strong>        cos(n*pi)/(n*pi))*(sinh(n*pi*x)/ \</strong></span>
<span class="strong"><strong>        sinh(n*pi))*sin(n*pi*y) </strong></span>
<span class="strong"><strong>                for n in range(1,200)) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; Ze = f(X,Y) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; ZdiffZe = Ze - Z </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.plot(ZdiffZe) </strong></span>
<span class="strong"><strong>&gt;&gt;&gt; plt.show() </strong></span>
</pre></div><p>This produces the following graph showing the difference between the exact solution (evaluated up to 200 terms) and the numerical solution of the problem (via the corresponding IPython notebook you could perform some further analysis on the numerical solution just to become more confident on the rightness of the obtained result): </p><div class="mediaobject"><img src="graphics/7702OS_07_12.jpg" alt="A finite element solver for Laplace's equation"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Summary</h1></div></div></div><p>In each one of the seven chapters of this book, we have covered at length all the different modules included in the SciPy libraries in a structured manner, derived from the logical division of the different branches of mathematics.</p><p>We have also witnessed the power of this system to accomplish with minimal coding and optimal resource use, state-of-the-art applications to research problems in different areas of science.</p><p>In <a class="link" href="ch08.html" title="Chapter 8. Interaction with Other Languages">Chapter 8</a>, <span class="emphasis"><em>Interaction with Other Languages</em></span>, we will introduce one of the main strengths of SciPy: the ability to interact with other languages.</p></div></body></html>