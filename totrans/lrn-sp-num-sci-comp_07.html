<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. SciPy for Computational Geometry</h1></div></div></div><p>In this chapter, we will be covering the fundamentals of SciPy to develop programs in this <a id="id332" class="indexterm"/>very specialized topic: <strong>Computational Geometry</strong>. Two examples will be used to illustrate the use of SciPy functions in this area. To be able to profit from the first example, you might want to have handy a copy of <em>Computational Geometry: Algorithms and Applications Third Edition</em>, <em>de Berg M.</em>, <em>Cheong O.</em>, <em>van Kreveld M.</em>, and <em>Overmars M.</em>, <em>Springer Publishing</em>. The second example, on which the <strong>Finite Element Method</strong> is used to solve a two-dimensional problem <a id="id333" class="indexterm"/>involving the numerical solution of the Laplace Equation, could be followed without trouble with knowledge on the topic described in <em>Introduction to the Finite Element Method</em>, <em>Ottosen N. S.</em> and <em>Petersson H.</em>, <em>Prentice Hall</em>.</p><p>Let's start by covering the routines in the <code class="literal">scipy.spatial</code> module that deal with the construction of triangulations of points in spaces of any dimension, and the corresponding convex hulls. </p><p>The procedure is simple; given a set of <em>m</em> points in the <em>n</em>-dimensional space (which we represent as an <em>m</em> x <em>n</em> NumPy array), we create the <code class="literal">scipy.spatial</code> class <code class="literal">Delaunay</code>, containing a triangulation formed by those points:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import scipy.stats </strong>
<strong>&gt;&gt;&gt; import scipy.spatial </strong>
<strong>&gt;&gt;&gt; data = scipy.stats.randint.rvs(0.4,10,size=(10,2))</strong>
<strong>&gt;&gt;&gt; triangulation = scipy.spatial.Delaunay(data)</strong>
</pre></div><p>Any <code class="literal">Delaunay</code> class has the basic search attributes such as <code class="literal">points</code> (to obtain the set of points in the triangulation), <code class="literal">vertices</code> (that offer the indices of vertices forming simplices in the triangulation), <code class="literal">neighbors</code> (for the indices of neighbor simplices of each simplex—with the convention that "-1" indicates no neighbor for simplices at the boundary).</p><p>More advanced attributes, for example, <code class="literal">convex_hull</code>, indicate the indices of the vertices that form the convex hull of the given points. If we desire to search for the simplices that share a given vertex, we may do so with the <code class="literal">vertex_to_simplex</code> method. If, instead, we desire to locate the simplices that contain any given point in the space, we do so with the <code class="literal">find_simplex</code> method.</p><p>At this stage we would like to point out the intimate relationship between triangulations and Voronoi diagrams, and offer a simple coding exercise. Let us start by first choosing a random set of points, and obtaining the corresponding triangulation:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from numpy.random import RandomState</strong>
<strong>&gt;&gt;&gt; rv = RandomState(123456789)</strong>
<strong>&gt;&gt;&gt; locations = rv.randint(0, 511, size=(2,8))</strong>
<strong>&gt;&gt;&gt; triangulation=scipy.spatial.Delaunay(locations.T)</strong>
</pre></div><p>We may use the <code class="literal">matplotlib.pyplot</code> routine <code class="literal">triplot</code> to obtain a graphical representation of this triangulation. We first need to obtain the set of computed simplices. <code class="literal">Delaunay</code> offers us this set, but by means of the indices of the vertices instead of their coordinates. We, thus, need to map these indices to actual points before feeding the set of simplices to the <code class="literal">triplot</code> routine:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import matplotlib.pyplot as plt </strong>
<strong>&gt;&gt;&gt; assign_vertex = lambda index: triangulation.points[index]</strong>
<strong>&gt;&gt;&gt; triangle_set = map(assign_vertex, triangulation.vertices)</strong>
</pre></div><p>We will now obtain the edge map of the Voronoi diagram in a similar fashion as we did before (this time using the <code class="literal">scipy.spatial.Voronoi</code> module), and plot it together with the triangulation. This is done by the following lines of code:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; voronoiSet=scipy.spatial.Voronoi(locations.T)</strong>
<strong>&gt;&gt;&gt; scipy.spatial.voronoi_plot_2d(voronoiSet)</strong>
<strong>&gt;&gt;&gt; fig = plt.figure()</strong>
<strong>&gt;&gt;&gt; thefig = plt.subplot(1,1,1)</strong>
<strong>&gt;&gt;&gt; scipy.spatial.voronoi_plot_2d(voronoiSet, ax=thefig)</strong>
<strong>&gt;&gt;&gt; plt.triplot(locations[1], locations[0], triangles=triangle_set, color='r')</strong>
</pre></div><p>Let's take a look at the following <code class="literal">xlim()</code> command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.xlim((0,550))</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong> (0, 550)</strong>
</pre></div><p>Now, let's take a look at following <code class="literal">ylim()</code> command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.ylim((0,550))</strong>
</pre></div><p>The output is shown as follows:</p><div><pre class="programlisting"><strong> (0, 550)</strong>
</pre></div><p>We now plot the edge map of the Voronoi diagram together with triangulation in the following <code class="literal">plt.show()</code> command:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.show()</strong>
</pre></div><p>The output is shown as follows:</p><div><img src="img/7702OS_07_01.jpg" alt="SciPy for Computational Geometry"/></div><p>Note how the triangulation and the corresponding Voronoi diagrams are dual of each other; each edge in the triangulation (red) is perpendicular with an edge in the Voronoi diagram (white). How should we use this observation to code an actual Voronoi diagram for a cloud of points? The actual Voronoi diagram is the set of vertices and edges that composes it. </p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>Interesting <a id="id334" class="indexterm"/>ways to find the Voronoi diagram can be found at <a class="ulink" href="http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d">http://stackoverflow.com/questions/10650645/python-calculate-voronoi-tesselation-from-scipys-delaunay-triangulation-in-3d</a>.</p></div></div><p>Let us finish this chapter with two applications of scientific computing that use these techniques extensively, in combination with routines from other SciPy modules.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>The structural model of oxides</h1></div></div></div><p>In this<a id="id335" class="indexterm"/> example, we will cover the extraction of the structural <a id="id336" class="indexterm"/>model of a molecule of a bronze-type <strong>Niobium oxide</strong>, from <strong>HAADF-STEM</strong>
<a id="id337" class="indexterm"/> micrographs (further background on this topic can be found in <em>Chapter 5</em>, <em>High-Quality Image Formation by Nonlocal Means Applied to High-Angle Annular Dark-Field Scanning Transmission Electron Microscopy (HAADF--STEM)</em> of the book <em>Modeling Nanoscale Imaging in Electron Microscopy</em>, <em>Vogt T.</em>, <em>Dahmen W.</em>, and <em>Binev P.</em>, <em>Springer Publishing</em>.</p><p>The following <a id="id338" class="indexterm"/>diagram shows the HAADF-STEM micrograph of a bronze-type Niobium oxide (taken from <a class="ulink" href="http://www.microscopy.ethz.ch/BFDF-STEM.htm">http://www.microscopy.ethz.ch/BFDF-STEM.htm</a>):</p><div><img src="img/7702OS_07_02.jpg" alt="The structural model of oxides"/><div><p>Courtesy: ETH Zurich</p></div></div><p>For pedagogical purposes, we took the following approach to solving this problem:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Segmentation of the atoms by thresholding and morphological operations.</li><li class="listitem" style="list-style-type: disc">Connected component labeling to extract each single atom for posterior examination.</li><li class="listitem" style="list-style-type: disc">Computation of the centers of mass of each label identified as an atom. This presents us with a lattice of points in the plane that shows a first insight in the structural model of the oxide.</li><li class="listitem" style="list-style-type: disc">Computation of the Voronoi diagram of the previous lattice of points. The combination of information with the output of the previous step will lead us to a decent (approximation of the actual) structural model of our sample.</li></ul></div><p>Let us proceed in this direction.</p><p>Once retrieved and saved in the current working directory, our HAADF-STEM images will be read in python and stored by default (depending on your computer architecture) as big matrices with <code class="literal">float32</code> or <code class="literal">float64</code> precision. For this project, it is enough to retrieve some tools from the <code class="literal">scipy.ndimage</code> module, and some procedures from the <code class="literal">matplotlib</code> library. The preamble then looks like the following code:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import numpy</strong>
<strong>&gt;&gt;&gt; import scipy</strong>
<strong>&gt;&gt;&gt; from scipy.ndimage import *</strong>
<strong>&gt;&gt;&gt; from scipy.misc import imfilter</strong>
<strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong>
<strong>&gt;&gt;&gt; import matplotlib.cm as cm</strong>
</pre></div><p>The<a id="id339" class="indexterm"/> image is loaded with the <code class="literal">imread(filename)</code> command. This stores the image as a <code class="literal">numpy.array</code> with <code class="literal">dtype = float32</code>. Notice that the image is rescaled so that the maxima and minima are <code class="literal">1.0</code> and <code class="literal">0.0</code>, respectively. Other interesting information about the image can be retrieved as follows:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; img=imread('./NbW-STEM.png')</strong>
<strong>&gt;&gt;&gt; minVal = numpy.min(img) </strong>
<strong>&gt;&gt;&gt; maxVal = numpy.max(img) </strong>
<strong>&gt;&gt;&gt; img = (1.0/(maxVal-minVal))*(img - minVal) </strong>
<strong>&gt;&gt;&gt; plt.imshow(img, cmap = cm.Greys_r)</strong>
<strong>&gt;&gt;&gt; plt.show()</strong>
<strong>&gt;&gt;&gt; print "Image dtype: %s"%(img.dtype)</strong>
<strong>&gt;&gt;&gt; print "Image size: %6d"%(img.size)</strong>
<strong>&gt;&gt;&gt; print "Image shape: %3dx%3d"%(img.shape[0],img.shape[1])</strong>
<strong>&gt;&gt;&gt; print "Max value %1.2f at pixel %6d"%(img.max(),img.argmax())</strong>
<strong>&gt;&gt;&gt; print "Min value %1.2f at pixel %6d"%(img.min(),img.argmin())</strong>
<strong>&gt;&gt;&gt; print "Variance: %1.5f\nStandard deviation: \ </strong>
<strong>    %1.5f"%(img.var(),img.std())</strong>
</pre></div><p>This provides the following output:</p><div><pre class="programlisting"><strong>Image dtype: float64</strong>
<strong>Image size:  87025</strong>
<strong>Image shape: 295x295</strong>
<strong>Max value 1.00 at pixel  75440</strong>
<strong>Min value 0.00 at pixel   5703</strong>
<strong>Variance: 0.02580</strong>
<strong>Standard deviation: 0.16062</strong>
</pre></div><p>We perform thresholding by imposing an inequality in the array holding the data. The output is a Boolean array where <code class="literal">True</code> (white) indicates that the inequality has been fulfilled, and <code class="literal">False</code> (black) otherwise. We may perform at this point several thresholding operations and visualize them to obtain the best threshold for segmentation purposes. The following images show several examples (different thresholdings applied to the oxide image):</p><div><img src="img/7702OS_07_03.jpg" alt="The structural model of oxides"/></div><p>The<a id="id340" class="indexterm"/> following lines of code generate that oxide image:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.subplot(1, 2, 1)</strong>
<strong>&gt;&gt;&gt; plt.imshow(img &gt; 0.2, cmap = cm.Greys_r)</strong>
<strong>&gt;&gt;&gt; plt.xlabel('img &gt; 0.2')</strong>
<strong>&gt;&gt;&gt; plt.subplot(1, 2, 2) </strong>
<strong>&gt;&gt;&gt; plt.imshow(img &gt; 0.7, cmap = cm.Greys_r)</strong>
<strong>&gt;&gt;&gt; plt.xlabel('img &gt; 0.7')</strong>
<strong>&gt;&gt;&gt; plt.show()</strong>
</pre></div><p>By visual inspection of several different thresholds, we choose <code class="literal">0.62</code> as one that gives us a good map showing what we need for segmentation. We need to get rid of <em>outliers</em>, though: small particles that might fulfill the given threshold but are small enough not to be considered as actual atoms. Therefore, in the next step we perform a morphological operation of opening to get rid of those small particles. We decided that anything smaller than a square of size 2 x 2 is to be eliminated from the output of thresholding:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; BWatoms = (img&gt; 0.62)</strong>
<strong>&gt;&gt;&gt; BWatoms = binary_opening(BWatoms,structure=numpy.ones((2,2)))</strong>
</pre></div><p>We are ready for segmentation, which will be performed with the <code class="literal">label</code> routine from the <code class="literal">scipy.ndimage</code> module. It collects one slice per segmented atom and offers the number of slices computed. We need to indicate the connectivity type. For instance, in the following toy example, do we want to consider that situation as two atoms or one atom?</p><div><img src="img/7702OS_07_04.jpg" alt="The structural model of oxides"/></div><p>It <a id="id341" class="indexterm"/>depends; we would rather have it now as two different connected components, but for some other applications we might consider that they are one. The way we indicate the connectivity to the <code class="literal">label</code> routine is by means of a structuring element that defines feature connections. For example, if our criterion for connectivity between two pixels is that their edges are adjacent, then the structuring element looks like the image shown on the left-hand side from the images shown next. If our criterion for connectivity between two pixels is that they are also allowed to share a corner, then the structuring element looks like the image on the right-hand side. </p><p>For each pixel we impose the chosen structuring element and count the intersections; if there are no intersections, then the two pixels are not connected. Otherwise, they belong to the same connected component.</p><div><img src="img/7702OS_07_05.jpg" alt="The structural model of oxides"/></div><p>We need to make sure that atoms that are too close diagonally are counted as two, rather than one, so we chose the structuring element on the left. The script then reads as follows:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; structuring_element = [[0,1,0],[1,1,1],[0,1,0]]</strong>
<strong>&gt;&gt;&gt; segmentation,segments = label(BWatoms,structuring_element)</strong>
</pre></div><p>The <code class="literal">segmentation</code> object contains a list of slices, each with a Boolean matrix containing each of the found atoms of the oxide. We may obtain a great deal of useful information for each slice. For example, the coordinates of the center of mars (<code class="literal">centers_of_mass</code>) of each atom can be retrieved with the following commands:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; coords = center_of_mass(img, segmentation, range(1,segments+1))</strong>
<strong>&gt;&gt;&gt; xcoords = numpy.array([x[1] for x in coords])</strong>
<strong>&gt;&gt;&gt; ycoords = numpy.array([x[0] for x in coords])</strong>
</pre></div><p>Note that because of the way matrices are stored in memory, there is a transposition of the <code class="literal">x</code> and <code class="literal">y</code> coordinates of the locations of the pixels. We need to take this into account.</p><p>Notice the overlap of the computed lattice of points over the original image (the left-hand side image from the two images shown next). We may obtain it with the following commands:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.imshow(img, cmap = cm.Greys_r) </strong>
<strong>&gt;&gt;&gt; plt.axis('off') </strong>
<strong>&gt;&gt;&gt; plt.plot(xcoords,ycoords,'b.') </strong>
<strong>&gt;&gt;&gt; plt.show() </strong>
</pre></div><p>We have <a id="id342" class="indexterm"/>successfully found the centers of mass for most atoms, although there are still about a dozen regions where we are not too satisfied with the result. It is time to fine-tune by the simple method of changing the values of some variables; play with the threshold, with the structuring element, with different morphological operations, and so on. We can even add all the obtained information for a wide range of those variables, and filter out outliers. An example with optimized segmentation is shown, as follows (look at the right-hand side image):</p><div><img src="img/7702OS_07_06.jpg" alt="The structural model of oxides"/></div><p>For the purposes of this exposition, we are happy to keep it simple and continue working with the set of coordinates that we have already computed. We will be now offering an approximation to the lattice of the oxide, computed as the edge map of the Voronoi diagram of the lattice:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; L1,L2 = distance_transform_edt(segmentation==0, return_distances=False, return_indices=True)</strong>
<strong>&gt;&gt;&gt; Voronoi = segmentation[L1,L2]</strong>
<strong>&gt;&gt;&gt; Voronoi_edges= imfilter(Voronoi,'find_edges')</strong>
<strong>&gt;&gt;&gt; Voronoi_edges=(Voronoi_edges&gt;0)</strong>
</pre></div><p>Let us overlay the result of <code class="literal">Voronoi_edges</code> with the locations of the found atoms:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.imshow(Voronoi_edges); plt.axis('off'); plt.gray()</strong>
<strong>&gt;&gt;&gt; plt.plot(xcoords,ycoords,'r.',markersize=2.0)</strong>
<strong>&gt;&gt;&gt; plt.show()</strong>
</pre></div><p>This gives<a id="id343" class="indexterm"/> the following output, which represents the structural model we were searching for (recall that we started from an image where we wanted to find the structural model of a molecule):</p><div><img src="img/7702OS_07_07.jpg" alt="The structural model of oxides"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>A finite element solver for Laplace's equation</h1></div></div></div><p>We use<a id="id344" class="indexterm"/> finite elements when the size of the<a id="id345" class="indexterm"/> data is so large that its results prohibit dealing with finite differences. To illustrate this case, we would like to explore the numerical solution of the Laplace equation, subject to certain boundary conditions.</p><p>We will start by defining the computational domain and produce a mesh dividing this domain using triangles as local finite elements. This will be our starting point to solve this problem using finite elements, as we will be placing on the computational domain a piecewise continuous function, whose pieces are linear and supported on each of the triangles.</p><p>We start by calling the necessary modules to build the mesh (other modules will be called as they are required):</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; import numpy</strong>
<strong>&gt;&gt;&gt; from numpy import linspace</strong>
<strong>&gt;&gt;&gt; import scipy</strong>
<strong>&gt;&gt;&gt; import matplotlib.pyplot as plt</strong>
<strong>&gt;&gt;&gt; from scipy.spatial import Delaunay</strong>
</pre></div><p>First we define the region:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; xmin = 0 ; xmax = 1 ; nXpoints = 10</strong>
<strong>&gt;&gt;&gt; ymin = 0 ; ymax = 1 ; nYpoints = 10</strong>
<strong>&gt;&gt;&gt; horizontal = linspace(xmin,xmax,nXpoints)</strong>
<strong>&gt;&gt;&gt; vertical = linspace(ymin,ymax,nYpoints)</strong>
<strong>&gt;&gt;&gt; y, x = numpy.meshgrid(horizontal, vertical)</strong>
<strong>&gt;&gt;&gt; vertices = numpy.array([x.flatten(),y.flatten()])</strong>
</pre></div><p>We <a id="id346" class="indexterm"/>may now <a id="id347" class="indexterm"/>create the triangulation:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; triangulation = Delaunay(vertices.T)</strong>
<strong>&gt;&gt;&gt; index2point = lambda index: triangulation.points[index]</strong>
<strong>&gt;&gt;&gt; all_centers = index2point(triangulation.vertices).mean(axis=1)</strong>
<strong>&gt;&gt;&gt; trngl_set=triangulation.vertices</strong>
</pre></div><p>We then have the following triangulation:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; plt.triplot(vertices[0],vertices[1],triangles=trngl_set)</strong>
<strong>&gt;&gt;&gt; plt.show()</strong>
</pre></div><p>This produces the following graph:</p><div><img src="img/7702OS_07_08.jpg" alt="A finite element solver for Laplace's equation"/></div><p>In this<a id="id348" class="indexterm"/> case, the problem we have chosen is<a id="id349" class="indexterm"/> a standard one in mathematical methods in Physics and Engineering, consisting of solving the two-dimensional Laplace's equation on the unit square region, with zero <strong>Dirichlet</strong> boundary conditions on three sides and, on the fourth side, a constant. Physically, this problem could represent diffusion of temperature on a two-dimensional plate. Mathematically, the problem is formulated in the following form:</p><div><img src="img/7702OS_07_09.jpg" alt="A finite element solver for Laplace's equation"/></div><p>The solution of this form can be given in terms of Fourier series as follows:</p><div><img src="img/7702OS_07_10.jpg" alt="A finite element solver for Laplace's equation"/></div><p>This is<a id="id350" class="indexterm"/> important as you can check the <a id="id351" class="indexterm"/>correctness of the obtained numerical solution before attempting to use your numerical scheme to tackle more complex problems in complex computational domains. It should be mentioned, however, that there are alternatives in Python that implement the finite element method to solve partial differential equations. In this regard, the reader could consult the <strong>Fenics</strong> project (<a class="ulink" href="http://fenicsproject.org/book/">http://fenicsproject.org/book/</a>) and the <strong>SfePy</strong> project (<a class="ulink" href="http://sfepy.org/doc-devel/index.html">http://sfepy.org/doc-devel/index.html</a>).</p><p>We code the solution in the usual fashion. We first compute the stiff matrix <em>A</em> (which for obvious reasons is <code class="literal">sparse</code>). Then, the construction of the vector, <em>R</em>, holding global boundary conditions is defined (the way we have constructed our mesh makes defining this vector straightforward). With them, the solution to the system comes from the solution <em>X</em> obtained from solving a matrix equation of the form <em>AX=R</em> using a subset of the matrices <em>A</em> and <em>R</em> corresponding to the nodes different from those on the boundaries. This should be no trouble for SciPy. Let us start with the stiff matrix:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from numpy import  cross </strong>
<strong>&gt;&gt;&gt; from scipy.sparse import dok_matrix </strong>
<strong>&gt;&gt;&gt; points=triangulation.points.shape[0]</strong>
<strong>&gt;&gt;&gt; stiff_matrix=dok_matrix((points,points))</strong>
<strong>&gt;&gt;&gt; for triangle in triangulation.vertices:</strong>
<strong>        helper_matrix=dok_matrix((points,points))</strong>
<strong>        pt1,pt2,pt3=index2point(triangle)</strong>
<strong>        area=abs(0.5*cross(pt2-pt1,pt3-pt1))</strong>
<strong>        coeffs=0.5*numpy.vstack((pt2-pt3,pt3-pt1,pt1-pt2))/area</strong>
<strong>        #helper_matrix[triangle,triangle] = \ </strong>
<strong>        array(mat(coeffs)*mat(coeffs).T)</strong>
<strong>        u=None </strong>
<strong>        u=numpy.array(numpy.mat(coeffs)*numpy.mat(coeffs).T) </strong>
<strong>        for i in range(len(triangle)):</strong>
<strong>            for j in range(len(triangle)):</strong>
<strong>                helper_matrix[triangle[i],triangle[j]] = u[i,j] </strong>
<strong>        stiff_matrix=stiff_matrix+helper_matrix</strong>
</pre></div><p>Note that this is the cumbersome way to update the matrix <code class="literal">stiff_matrix</code>. This is due to the fact that the matrix is <code class="literal">sparse</code>, and the current choice of representation does not behave well with indexing.</p><p>To <a id="id352" class="indexterm"/>compute the global boundary vector we<a id="id353" class="indexterm"/> need to collect all edges on the boundary first and then assign to the nodes with <em>x=1</em> that the function is one and to the others that the function is zero. Because of the way we set up the mesh this is easy as the nodes on which the function will take the value of one are always the last entries in the global boundary vector. This is accomplished by the following lines of code:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; allNodes = numpy.unique(trngl_set) </strong>
<strong>&gt;&gt;&gt; boundaryNodes = numpy.unique(triangulation.convex_hull) </strong>
<strong>&gt;&gt;&gt; NonBoundaryNodes = numpy.array([]) </strong>
<strong>&gt;&gt;&gt; for x in allNodes: </strong>
<strong>        if x not in boundaryNodes: </strong>
<strong>            NonBoundaryNodes = numpy.append(NonBoundaryNodes,x) </strong>
<strong>    NonBoundaryNodes = NonBoundaryNodes.astype(int) </strong>
<strong>    nbnodes = len(boundaryNodes) # number of boundary nodes </strong>
<strong>    FbVals=numpy.zeros([nbnodes,1]) # Values on the boundary </strong>
<strong>    FbVals[(nbnodes-nXpoints+1):-1]=numpy.ones([nXpoints-2, 1])</strong>
</pre></div><p>We are ready to find the numerical solution to the problem with the values obtained in our previous step:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; totalNodes = len(allNodes) </strong>
<strong>&gt;&gt;&gt; stiff_matrixDense = stiff_matrix.todense() </strong>
<strong>&gt;&gt;&gt; stiffNonb = \ </strong>
<strong>    stiff_matrixDense[numpy.ix_(NonBoundaryNodes,NonBoundaryNodes)] </strong>
<strong>&gt;&gt;&gt; stiffAtb = \ </strong>
<strong>    stiff_matrixDense[numpy.ix_(NonBoundaryNodes,boundaryNodes)] </strong>
<strong>&gt;&gt;&gt; U=numpy.zeros([totalNodes, 1]) </strong>
<strong>&gt;&gt;&gt; U[NonBoundaryNodes] = numpy.linalg.solve( - stiffNonb , \</strong>
<strong>    stiffAtb * FbVals ) </strong>
<strong>&gt;&gt;&gt; U[boundaryNodes] = FbVals </strong>
</pre></div><p>This produces the following image depicting the diffusion of temperature inside the square:</p><div><img src="img/7702OS_07_11.jpg" alt="A finite element solver for Laplace's equation"/></div><p>This <a id="id354" class="indexterm"/>graph <a id="id355" class="indexterm"/>was obtained in the following way:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; X = vertices[0] </strong>
<strong>&gt;&gt;&gt; Y = vertices[1] </strong>
<strong>&gt;&gt;&gt; Z = U.T.flatten() </strong>
<strong>&gt;&gt;&gt; from mpl_toolkits.mplot3d import axes3d</strong>
<strong>&gt;&gt;&gt; fig = plt.figure() </strong>
<strong>&gt;&gt;&gt; ax = fig.add_subplot(111, projection='3d') </strong>
<strong>&gt;&gt;&gt; surf = ax.plot_trisurf(X, Y, Z, cmap=cm.jet, linewidth=0) </strong>
<strong>&gt;&gt;&gt; fig.colorbar(surf) </strong>
<strong>&gt;&gt;&gt; fig.tight_layout() </strong>
<strong>&gt;&gt;&gt; ax.set_xlabel('X',fontsize=16)</strong>
<strong>&gt;&gt;&gt; ax.set_ylabel('Y',fontsize=16)</strong>
<strong>&gt;&gt;&gt; ax.set_zlabel(r"$\phi$",fontsize=36)</strong>
<strong>&gt;&gt;&gt; plt.show() </strong>
</pre></div><p>An important point in numerical analysis is to evaluate the quality of the numerical solution obtained to any problem. In this case, we have chosen a problem whose analytical solution<a id="id356" class="indexterm"/> is<a id="id357" class="indexterm"/> available (see the preceding code), so one could check (not prove) the validity of the numerical algorithm implemented to solve our problem. In this case the analytical solution can be coded in the following manner:</p><div><pre class="programlisting"><strong>&gt;&gt;&gt; from numpy import pi, sinh, sin, cos, sum</strong>
<strong>&gt;&gt;&gt; def f(x,y): </strong>
<strong>        return sum( 2*(1.0/(n*pi) - \</strong>
<strong>        cos(n*pi)/(n*pi))*(sinh(n*pi*x)/ \</strong>
<strong>        sinh(n*pi))*sin(n*pi*y) </strong>
<strong>                for n in range(1,200)) </strong>
<strong>&gt;&gt;&gt; Ze = f(X,Y) </strong>
<strong>&gt;&gt;&gt; ZdiffZe = Ze - Z </strong>
<strong>&gt;&gt;&gt; plt.plot(ZdiffZe) </strong>
<strong>&gt;&gt;&gt; plt.show() </strong>
</pre></div><p>This produces the following graph showing the difference between the exact solution (evaluated up to 200 terms) and the numerical solution of the problem (via the corresponding IPython notebook you could perform some further analysis on the numerical solution just to become more confident on the rightness of the obtained result): </p><div><img src="img/7702OS_07_12.jpg" alt="A finite element solver for Laplace's equation"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Summary</h1></div></div></div><p>In each one of the seven chapters of this book, we have covered at length all the different modules included in the SciPy libraries in a structured manner, derived from the logical division of the different branches of mathematics.</p><p>We have also witnessed the power of this system to accomplish with minimal coding and optimal resource use, state-of-the-art applications to research problems in different areas of science.</p><p>In <a class="link" href="ch08.html" title="Chapter 8. Interaction with Other Languages">Chapter 8</a>, <em>Interaction with Other Languages</em>, we will introduce one of the main strengths of SciPy: the ability to interact with other languages.</p></div></body></html>