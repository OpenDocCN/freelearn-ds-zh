<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 3. Moving Spatial Data from One Format to Another"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Moving Spatial Data from One Format to Another</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Converting a Shapefile to a PostGIS table using ogr2ogr</li><li class="listitem" style="list-style-type: disc">Batch importing a folder of Shapefiles into PostGIS using ogr2ogr</li><li class="listitem" style="list-style-type: disc">Batch exporting a list of tables from PostGIS to Shapefiles</li><li class="listitem" style="list-style-type: disc">Converting an OpenStreetMap (OSM) XML to a Shapefile</li><li class="listitem" style="list-style-type: disc">Converting a Shapefile (vector) to a GeoTiff (raster)</li><li class="listitem" style="list-style-type: disc">Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL</li><li class="listitem" style="list-style-type: disc">Creating a Shapefile from point data stored in Microsoft Excel</li><li class="listitem" style="list-style-type: disc">Converting an ESRI ASCII DEM to an image height map</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Introduction</h1></div></div></div><p>Geospatial data comes in hundreds of formats and massaging this data from one format to another is a simple task. The ability to convert between data types, such as rasters or vectors, belongs to data wrangling tasks and can be used for better geospatial analysis. Here is an example of a raster and vector dataset so that you can take a look at what I am talking about:</p><div class="mediaobject"><img src="images/B03543_03_01.jpg" alt="Introduction"/></div><p>The best practice methodology is to run analysis functions or models over data stored in a common format, such as a PostgreSQL PostGIS database, or a set of Shapefiles in a common coordinate system. For example, running an analysis on input data stored in multiple formats is also possible, but you can expect to find the devil in the detail if something goes wrong or your results are not as you expected them to be.</p><p>This chapter looks at some common data formats and demonstrates how to move these from one format to another with the help of the most common tools.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting a Shapefile to a PostGIS table using ogr2ogr"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Converting a Shapefile to a PostGIS table using ogr2ogr</h1></div></div></div><p>The simplest way to<a id="id110" class="indexterm"/> transform data from one format to another<a id="id111" class="indexterm"/> is to directly use the <span class="emphasis"><em>ogr2ogr</em></span> tool that <a id="id112" class="indexterm"/>comes with the installation of GDAL. This powerful tool can convert over 200 geospatial formats. In this solution, we will execute the <span class="emphasis"><em>ogr2ogr</em></span> utility from within a Python script to perform generic vector data conversions. The Python code is, therefore, used to execute this command-line tool and pass around variables so that you can create your own scripts for data imports or exports.</p><p>Using this tool is also recommended if you are not really interested in coding too much and simply want to get the job done to move your data. A pure Python solution is, of course, possible, but it's definitely more orientated to the needs of developers (or a Python purist). Since this book is aimed at developers, analysts, or researchers, this kind of a recipe is simple and yet extensible.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Getting ready</h2></div></div></div><p>To run this script, you <a id="id113" class="indexterm"/>will need the GDAL utilities application<a id="id114" class="indexterm"/> installed on your system. Windows users <a id="id115" class="indexterm"/>can visit <a id="id116" class="indexterm"/>OSGeo4W (<a class="ulink" href="http://trac.osgeo.org/osgeo4w">http://trac.osgeo.org/osgeo4w</a>) and download the 32-bit or 64-bit Windows installer. Simply double-click on the installer to start the script as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Navigate to the bottom option, <span class="strong"><strong>Advanced Installation</strong></span> | <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to download the GDAL utilities from the Internet (first default option).</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to accept the default location of the path or change it to your liking.</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to accept the location of local saved downloads (default).</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to accept a direct connection (default).</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to select the default download site.</li><li class="listitem">Now, you can finally see the menu. Click on <span class="strong"><strong>+</strong></span> to open the <span class="strong"><strong>Commandline_Utilities</strong></span> tab, and you should see what is shown in this screenshot:<div class="mediaobject"><img src="images/B03543_03_02.jpg" alt="Getting ready"/></div></li><li class="listitem">Now, select <span class="strong"><strong>gdal: The GDAL/OGR library and commandline tools</strong></span> to install it.</li><li class="listitem">Click on <span class="strong"><strong>Next</strong></span> to start downloading and install.</li></ol></div><p>Ubuntu/Linux users can use the following steps to install the GDAL utilities:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Execute this simple one-line command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install gdal-bin</strong></span>
</pre></div><p>This will get you up and running so that you can execute <code class="literal">ogr2ogr</code> directly from your terminal.</p><p>The Shapefile to be imported is located in your <code class="literal">/ch02/geodata/</code> folder if you've downloaded the entire source and code from GitHub at <a class="ulink" href="https://github.com/mdiener21/python-geospatial-analysis-cookbook/">https://github.com/mdiener21/python-geospatial-analysis-cookbook/</a>. The Vancouver open geodata portal<a id="id117" class="indexterm"/> (<a class="ulink" href="http://data.vancouver.ca/datacatalogue/index.htm">http://data.vancouver.ca/datacatalogue/index.htm</a>) is our source that provides a dataset of local bikeways.</p></li><li class="listitem">Next, let's set <a id="id118" class="indexterm"/>up our PostgreSQL database<a id="id119" class="indexterm"/> with the PostGIS <a id="id120" class="indexterm"/>extension. To do this, we'll first create a new user to manage our new database and tables as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Sudo su createuser  –U postgres –P pluto</strong></span>
</pre></div></li><li class="listitem">Enter a password for the new role.</li><li class="listitem">Enter the password again for the new role.</li><li class="listitem">Enter a password for the <code class="literal">postgres</code> user as you will create the user using this <code class="literal">postgres</code> user.</li><li class="listitem">The <code class="literal">–P</code> option prompts you to give the new user, called <code class="literal">pluto</code>, a password. For the following examples, our password is <code class="literal">stars</code>; I would recommend a much more secure password for your production database.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>Windows users can navigate to the <code class="literal">c:\Program Files\PostgreSQL\9.3\bin\</code> folder and execute the following command, and follow the on-screen instructions as you did earlier:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Createuser.exe –U postgres –P pluto</strong></span>
</pre></div></div></div></li><li class="listitem">To create the database, we will use the same command-line <code class="literal">createdb</code> command as the <code class="literal">postgres</code> user to create a database named <code class="literal">py_geoan_cb</code>, and assign the <code class="literal">pluto</code> user to be the database owner. Here is the command to do this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo su createdb –O pluto –U postgres py_geoan_cb</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Windows users can visit <code class="literal">c:\Program Files\PostgreSQL\9.3\bin\</code> and execute the <code class="literal">createdb.exe</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>createdb.exe –O pluto –U postgres py_geoan_cb</strong></span>
</pre></div><p>Next, we'll create the PostGIS extension for our newly created database:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql –U postgres -d py_geoan_cb -c "CREATE EXTENSION postgis;"</strong></span>
</pre></div><p>Windows users can also execute <code class="literal">psql</code> from within the <code class="literal">c:\Program Files\PostgreSQL\9.3\bin\</code> folder as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql.exe –U postgres –d py_geoan_cb –c "CREATE EXTENSION postgis;"</strong></span>
</pre></div></div></div></li><li class="listitem">Lastly, we'll create a schema called <span class="strong"><strong>geodata</strong></span><a id="id121" class="indexterm"/> to store our new spatial table. It is common to store spatial data in another schema outside the default <code class="literal">public</code> schema of PostgreSQL.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo -u postgres psql -d py_geoan_cb -c "CREATE SCHEMA geodata AUTHORIZATION pluto;"</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>Windows users can use the following command to do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>psql.exe –U postgres –d py_geoan_cb –c "CREATE SCHEMA geodata AUTHORIZATION pluto;"</strong></span>
</pre></div></div></div></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec54"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Now, let's get<a id="id122" class="indexterm"/> into the actual importing of our <a id="id123" class="indexterm"/>Shapefile into a PostGIS <a id="id124" class="indexterm"/>database that will automatically create a new table from our Shapefile:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import subprocess

# database options
db_schema = "SCHEMA=geodata"
overwrite_option = "OVERWRITE=YES"
geom_type = "MULTILINESTRING"
output_format = "PostgreSQL"

# database connection string
db_connection = """PG:host=localhost port=5432
  user=pluto dbname=py_test password=stars"""

# input shapefile
input_shp = "../geodata/bikeways.shp"

# call ogr2ogr from python
subprocess.call(["ogr2ogr","-lco", db_schema, "-lco", overwrite_option,
  "-nlt", geom_type, "-f", output_format, db_connection,  input_shp])</pre></div></li><li class="listitem">Next, we'll call our script from the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-01_shp2pg.py</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec55"/>How it works...</h2></div></div></div><p>We begin with importing <a id="id125" class="indexterm"/>the standard Python <code class="literal">subprocess</code> module <a id="id126" class="indexterm"/>that will call the <span class="emphasis"><em>ogr2ogr</em></span> command-line<a id="id127" class="indexterm"/> tool. Next, we'll set up a range of variables that are used as input arguments and provide various options for ogr2ogr to execute.</p><p>Starting with the PostgreSQL <code class="literal">SCHEMA=geodata</code> database, we set a nondefault database schema for the destination of our new table. It is a best practice to store your spatial data tables in a separate schema outside the public schema, which is the default. This practice will make backups and restores much easier and keeps your database better organized.</p><p>Next, we create a <code class="literal">overwrite_option</code> variable set to <code class="literal">yes</code> so that we can overwrite any table with the same name when it's created. This is helpful when you want to completely replace the table with new data; otherwise, it is recommended to use the <code class="literal">-append</code> option. We also specify the geometry type because, sometimes, ogr2ogr does not always guess the correct geometry type of our Shapefile so setting this value spares you that worry.</p><p>Now, we'll set our <code class="literal">output_format</code> variable with the <code class="literal">PostgreSQL</code> key word, telling ogr2ogr that we want to output data into a PostgreSQL database. This is then followed by the <code class="literal">db_connection</code> variable that specifies our database connection information. We must not forget that the database must already exist along with the <code class="literal">geodata</code> schema; otherwise, we will get an error.</p><p>The last <code class="literal">input_shp</code> variable is the full path to our Shapefile including the <code class="literal">.shp</code> file ending. We'll call the subprocess module and it will call the ogr2ogr command-line tool and pass along the variable options required to run the tool. We pass this function an array of arguments, starting with the first object in the array being the ogr2ogr command-line tool name. Following the name, we pass one option after another in the array to complete the call.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Subprocess can be used to call any command-line tool directly. Subprocess takes a list of parameters separated by spaces. This passing of parameters is quite fussy, so make sure you follow along closely and don't add any extra spaces or commas.</p></div></div><p>Last but not least, we <a id="id128" class="indexterm"/>need to execute our script from the command line <a id="id129" class="indexterm"/>to actually import our Shapefile by calling the <a id="id130" class="indexterm"/>Python interpreter and passing the script. Now head over to the <span class="strong"><strong>PgAdmin</strong></span>
<a id="id131" class="indexterm"/> PostgreSQL database viewer and see if it's worked. Or, even better, open up Quantum GIS<a id="id132" class="indexterm"/> (<a class="ulink" href="http://www.qgis.org">www.qgis.org</a>) and take a look at the newly created tables.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec56"/>See also</h2></div></div></div><p>If you would like to see the full list of options available with the ogr2ogr command, simply enter the following in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ogr2ogr –help</strong></span>
</pre></div><p>You will see the full <a id="id133" class="indexterm"/>list of options available. Also, visit <a class="ulink" href="http://gdal.org/ogr2ogr.html">http://gdal.org/ogr2ogr.html</a> to read the available documentation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>For those of you who are curious to see how this call would run without using Python, the call directly to <code class="literal">ogr2ogr</code> will be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ogr2ogr -lco SCHEMA=geodata -nlt MULTILINE -f "Postgresql" PG:"host=localhost port=5432 user=postgres dbname=py_geoan_cb password=secret" /home/mdiener/ch03/geodata/bikeways.shp</strong></span>
</pre></div></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Batch importing a folder of Shapefiles into PostGIS using ogr2ogr"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Batch importing a folder of Shapefiles into PostGIS using ogr2ogr</h1></div></div></div><p>We would like to<a id="id134" class="indexterm"/> extend our last script to loop over a<a id="id135" class="indexterm"/> folder full of Shapefiles and import<a id="id136" class="indexterm"/> them into PostGIS. Most importing tasks involve more than one file to import, so this makes it a very practical task.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec57"/>How to do it...</h2></div></div></div><p>Our script will reuse the previous code in the form of a function so that we can batch process a list of Shapefiles to import into the PostgreSQL PostGIS database.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We will create our list of Shapefiles from a single folder for the sake of simplicity:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import subprocess
import os
import ogr


def discover_geom_name(ogr_type):
    """
    
    :param ogr_type: ogr GetGeomType()
    :return: string geometry type name
    """
    return {ogr.wkbUnknown            : "UNKNOWN",
            ogr.wkbPoint              : "POINT",
            ogr.wkbLineString         : "LINESTRING",
            ogr.wkbPolygon            : "POLYGON",
            ogr.wkbMultiPoint         : "MULTIPOINT",
            ogr.wkbMultiLineString    : "MULTILINESTRING",
            ogr.wkbMultiPolygon       : "MULTIPOLYGON",
            ogr.wkbGeometryCollection : "GEOMETRYCOLLECTION",
            ogr.wkbNone               : "NONE",
            ogr.wkbLinearRing         : "LINEARRING"}.get(ogr_type)

def run_shp2pg(input_shp):
    """
    input_shp is full path to shapefile including file ending
    usage:  run_shp2pg('/home/geodata/myshape.shp')
    """

    db_schema = "SCHEMA=geodata"
    db_connection = """PG:host=localhost port=5432
                    user=pluto dbname=py_geoan_cb password=stars"""
    output_format = "PostgreSQL"
    overwrite_option = "OVERWRITE=YES"
    shp_dataset = shp_driver.Open(input_shp)
    layer = shp_dataset.GetLayer(0)
    geometry_type = layer.GetLayerDefn().GetGeomType()
    geometry_name = discover_geom_name(geometry_type)
    print (geometry_name)

    subprocess.call(["ogr2ogr", "-lco", db_schema, "-lco", overwrite_option,
                     "-nlt", geometry_name, "-skipfailures",
                     "-f", output_format, db_connection, input_shp])

# directory full of shapefiles
shapefile_dir = os.path.realpath('../geodata')

# define the ogr spatial driver type
shp_driver = ogr.GetDriverByName('ESRI Shapefile')

# empty list to hold names of all shapefils in directory
shapefile_list = []

for shp_file in os.listdir(shapefile_dir):
    if shp_file.endswith(".shp"):
        # apped join path to file name to outpout "../geodata/myshape.shp"
        full_shapefile_path = os.path.join(shapefile_dir, shp_file)
        shapefile_list.append(full_shapefile_path)

# loop over list of Shapefiles running our import function
for each_shapefile in shapefile_list:
    run_shp2pg(each_shapefile)
    print ("importing Shapefile: " + each_shapefile)</pre></div></li><li class="listitem">Now, we can simply run our new script from the command line once again as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-02_batch_shp2pg.py</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec58"/>How it works...</h2></div></div></div><p>Here, we are <a id="id137" class="indexterm"/>reusing our code from the previous<a id="id138" class="indexterm"/> script but have converted it into a<a id="id139" class="indexterm"/> Python function called <code class="literal">run_shp2pg (input_shp)</code> that takes exactly one argument and the complete path to the Shapefile that we want to import. The input argument must include the Shapefile ending, <code class="literal">.shp</code>.</p><p>We have a helper function that will get the geometry type as a string by reading in the Shapefile feature layer and outputting the geometry type so that the <code class="literal">ogr</code> commands know what to expect. This does not always work and some errors can occur. The <code class="literal">–skipfailures</code> option will plow over any errors that are thrown during insertion and will still populate our tables.</p><p>To begin with, we need to define the folder that contains all our Shapefiles to be imported. Next up, we can create an empty list object called <code class="literal">shapefile_list</code> that will hold the list of all our Shapefiles that we want to import.</p><p>The first <code class="literal">for</code> loop is used to get a list of all the Shapefiles in the directory specified using the standard Python <code class="literal">os.listdir()</code> function. We do not want all the files in this folder. We only want files with the file ending <code class="literal">.shp</code>; hence, the <code class="literal">if</code> statement that will evaluate to <code class="literal">True</code> if the file ends with <code class="literal">.shp</code>. Once the <code class="literal">.shp</code> file is found, we need to append the file path to the filename to create a single string that holds the path plus the Shapefile name and the <code class="literal">full_shapefile_path</code> variable. In the final part, we add each new file with its attached path to our <code class="literal">shapefile_list</code> list object so that we have our final list to loop through.</p><p>Now, it is time to loop through each Shapefile in our new list and run our <code class="literal">run_shp2pg(input_shp)</code> function for each Shapefile in the list, importing it into our PostgreSQL PostGIS database.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec59"/>There's more…</h2></div></div></div><p>If you have a lot of Shapefiles (and I mean a lot, as in 100 or more Shapefiles), performance will be one consideration and will, therefore, require a lot of machines with free resources.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Batch exporting a list of tables from PostGIS to Shapefiles"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Batch exporting a list of tables from PostGIS to Shapefiles</h1></div></div></div><p>We will now change <a id="id140" class="indexterm"/>direction and take a<a id="id141" class="indexterm"/> look at how we can batch export a list of tables from our PostGIS database into a folder of Shapefiles. We'll again use the ogr2ogr command-line tool from within a Python script so that you can include it in your application programming work flow. Near the end, you can also see how all this works in one single command line.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec60"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The following script will fire the <code class="literal">ogr2ogr</code> command and loop over a list of tables to export the Shapefile format into an existing folder. So, let's take a look at how to do this as follows:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
import subprocess
import os

# folder to hold output Shapefiles
destination_dir = os.path.realpath('../geodata/temp')

# list of postGIS tables
postgis_tables_list = ["bikeways", "highest_mountains"]

# database connection parameters
db_connection = """PG:host=localhost port=5432 user=pluto
        dbname=py_geoan_cb password=stars active_schema=geodata"""

output_format = "ESRI Shapefile"

# check if destination directory exists
if not os.path.isdir(destination_dir):
    os.mkdir(destination_dir)
    for table in postgis_tables_list:
        subprocess.call(["ogr2ogr", "-f", output_format, destination_dir,
                         db_connection, table])
        print("running ogr2ogr on table: " + table)
else:
    print("oh no your destination directory " + destination_dir +
          " already exist please remove it then run again")

# commandline call without using python will look like this
# ogr2ogr -f "ESRI Shapefile" mydatadump \
# PG:"host=myhost user=myloginname dbname=mydbname password=mypassword" neighborhood parcels</pre></div></li><li class="listitem">Now, we'll call our script from the command line as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-03_batch_postgis2shp.py</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How it works...</h2></div></div></div><p>Beginning with the simple<a id="id142" class="indexterm"/> import of our <code class="literal">subprocess</code> and <code class="literal">os</code> modules, we immediately define our destination directory where we want <a id="id143" class="indexterm"/>to store the exported Shapefiles. This variable is followed by the list of table names that we want to export. This list can only include files located in the same PostgreSQL schema. The schema is defined as the <code class="literal">active_schema</code> so that <code class="literal">ogr2ogr</code> knows where to find tables to export.</p><p>Once again, we define the output format as <a id="id144" class="indexterm"/>
<span class="strong"><strong>ESRI Shapefile</strong></span>. Now, we'll check whether the destination folder exists. If it does, we'll continue and call our loop. Then, we'll loop through the list of tables stored in our <code class="literal">postgis_tables_list</code> variable. If the destination folder does not exist, you will see an error printed on the screen.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec62"/>There's more...</h2></div></div></div><p>Programming an application and then executing the ogr2ogr command from inside your script is definitely quick and easy. On the other hand, for a one-off job, simply executing the command-line tool is what you want to do when exporting your list of Shapefiles. To do this in a one-liner, take a look at this information box.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>A one-line example of calling the ogr2ogr batch PostGIS table to Shapefiles is shown here if you simply want to execute this once and not in a scripting environment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ogr2ogr -f "ESRI Shapefile" /home/ch03/geodata/temp PG:"host=localhost user=pluto dbname=py_geoan_cb password=stars" bikeways highest_mountains</strong></span>
</pre></div><p>The list of tables you want to export is located at the end as a list separated by spaces. The destination location of the exported Shapefiles is <code class="literal">../geodata/temp</code>. Note that this <code class="literal">/temp</code> directory must exist.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting an OpenStreetMap (OSM) XML to a Shapefile"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Converting an OpenStreetMap (OSM) XML to a Shapefile</h1></div></div></div><p>OpenStreetMap (OSM) has <a id="id145" class="indexterm"/>a wealth of free data, but to <a id="id146" class="indexterm"/>use it with most other applications, we need to convert it to other formats, such as Shapefile or PostgreSQL PostGIS databases. This recipe will use the <span class="strong"><strong>ogr2ogr</strong></span>
<a id="id147" class="indexterm"/> tool to perform the conversion for us within a Python script. The benefit of this is, again, simplicity.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec63"/>Getting ready</h2></div></div></div><p>To get started, you will need to download the OSM data<a id="id148" class="indexterm"/> at <a class="ulink" href="http://www.openstreetmap.org/export#map=17/37.80721/-122.47305">http://www.openstreetmap.org/export#map=17/37.80721/-122.47305</a> and save the file (<code class="literal">.osm</code>) to your <code class="literal">/ch03/geodata</code> directory. The download button is located on the left-hand side bar and, when pressed, it should immediately start the download (refer to the following screenshot). The area we are testing is in San Francisco, just before the <span class="strong"><strong>Golden Gate Bridge</strong></span>.</p><div class="mediaobject"><img src="images/B03543_03_03.jpg" alt="Getting ready"/></div><p>If you choose to download <a id="id149" class="indexterm"/>another area from OSM, feel free but make sure you take a small area similar to my example. If you select a<a id="id150" class="indexterm"/> larger area, the OSM web tool will give you a warning and disable the download button. The reason for this is simple: if the dataset is very large, it is most likely better suited for another tool, such as<a id="id151" class="indexterm"/> <span class="strong"><strong>osm2pgsql</strong></span>, (<a class="ulink" href="http://wiki.openstreetmap.org/wiki/Osm2pgsql">http://wiki.openstreetmap.org/wiki/Osm2pgsql</a>) for your conversion. If you need to get OSM data for a large area and want to export it to Shapefile, it would be advisable to use another tool, such as<a id="id152" class="indexterm"/> <span class="strong"><strong>osm2pgsql</strong></span>, which will first import your data into a PostgreSQL database. Then, export the data from the PostGIS database to Shapefile using the <a id="id153" class="indexterm"/>
<span class="strong"><strong>pgsql2shp</strong></span> tool.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>A Python tool called <span class="strong"><strong>imposm</strong></span>
<a id="id154" class="indexterm"/> can be used to import the OSM data into a PostGIS database and is<a id="id155" class="indexterm"/> available at <a class="ulink" href="http://imposm.org/">http://imposm.org/</a>. Version 2 of it is written in Python and version 3 is written in the <span class="emphasis"><em>go</em></span> programming language, if you want to give this a try as well.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec64"/>How to do it...</h2></div></div></div><p>Use the following steps to convert an OpenStreetMap (OSM) XML into a Shapefile:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Using the<a id="id156" class="indexterm"/> subprocess module, we <a id="id157" class="indexterm"/>will execute <span class="strong"><strong>ogr2ogr</strong></span><a id="id158" class="indexterm"/> to convert our OSM data that we downloaded into a new Shapefile:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

# convert / import osm xml .osm file into a Shapefile
import subprocess
import os
import shutil

# specify output format
output_format = "ESRI Shapefile"

# complete path to input OSM xml file .osm
input_osm = '../geodata/OSM_san_francisco_westbluff.osm'

# Windows users can uncomment these two lines if needed
# ogr2ogr = r"c:/OSGeo4W/bin/ogr2ogr.exe"
# ogr_info = r"c:/OSGeo4W/bin/ogrinfo.exe"

# view what geometry types are available in our OSM file
subprocess.call([ogr_info, input_osm])

destination_dir = os.path.realpath('../geodata/temp')

if os.path.isdir(destination_dir):
    # remove output folder if it exists
    shutil.rmtree(destination_dir)
    print("removing existing directory : " + destination_dir)
    # create new output folder
    os.mkdir(destination_dir)
    print("creating new directory : " + destination_dir)

    # list of geometry types to convert to Shapefile
    geom_types = ["lines", "points", "multilinestrings", "multipolygons"]

    # create a new Shapefile for each geometry type
    for g_type in geom_types:

        subprocess.call([ogr2ogr,
               "-skipfailures", "-f", output_format,
                 destination_dir, input_osm,
                 "layer", g_type,
                 "--config","OSM_USE_CUSTOM_INDEXING", "NO"])
        print("done creating " + g_type)

# if you like to export to SPATIALITE from .osm
# subprocess.call([ogr2ogr, "-skipfailures", "-f",
#         "SQLITE", "-dsco", "SPATIALITE=YES",
#         "my2.sqlite", input_osm])</pre></div></li><li class="listitem">Now we can call our script from the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-04_osm2shp.py</strong></span>
</pre></div></li></ol></div><p>Go and have a look in your <code class="literal">../geodata</code> folder to see the newly created Shapefiles and try to open them up in Quantum GIS, which is a free <a id="id159" class="indexterm"/>GIS software (<a class="ulink" href="http://www.qgis.org">www.qgis.org</a>).</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How it works...</h2></div></div></div><p>This script should be <a id="id160" class="indexterm"/>clear as we are using the <a id="id161" class="indexterm"/>subprocess module call to fire our ogr2ogr command-line tool. We'll specify our OSM dataset as an input file, including the full path to the file. The Shapefile name is not supplied as ogr2ogr will output a set of Shapefiles, one for each geometry shape according to the geometry types it finds inside the OSM file. We only need to specify the name of the folder where we want ogr2ogr to export the Shapefiles to, automatically creating the folder if it does not exist.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Windows users: If you do not have your ogr2ogr tool mapped to your environment variables, you can simply uncomment the code at lines 16 and 17 and replace the path shown with the path on your machine to the Windows executables.</p></div></div><p>The first subprocess call prints out to the screen the geometry types found inside our OSM file. This is helpful in most cases to help identify what is available. Shapefiles can only support one geometry type per file, and this is why ogr2ogr outputs a folder full of Shapefiles, each one representing a separate geometry type.</p><p>Lastly, we call subprocess to execute ogr2ogr, passing in the output file type called ESRI Shapefile, the output folder, and the name of the OSM dataset.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting a Shapefile (vector) to a GeoTiff (raster)"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Converting a Shapefile (vector) to a GeoTiff (raster)</h1></div></div></div><p>Moving data from format to format<a id="id162" class="indexterm"/> also includes moving it from <a id="id163" class="indexterm"/>vector to raster or the other way round. In this recipe, we move data from a vector (Shapefile) to a raster (GeoTiff) with the Python <code class="literal">gdal</code> and <code class="literal">ogr</code> modules.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Getting ready</h2></div></div></div><p>We need to be inside our virtual environment again, so fire it up so that we can access the <code class="literal">gdal</code> and <code class="literal">ogr</code> Python modules that we installed in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python Environment</em></span>.</p><p>As usual, enter your Python virtual environment with the <code class="literal">workon pygeoan_cb</code> command or this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source venvs/pygeoan_cb/bin/activate</strong></span>
</pre></div><p>A Shapefile is also needed, so be sure to download the source and access the <code class="literal">/ch03/geodata</code> folder (<a class="ulink" href="https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip">https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip</a>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec67"/>How to do it...</h2></div></div></div><p>Let's dive in and convert our golf course polygon Shapefile into a GeoTif; here comes the code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the libraries <code class="literal">ogr</code> and <code class="literal">gdal</code>, and then define our output pixel size along with a value to assign to null:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

from osgeo import ogr
from osgeo import gdal

# set pixel size
pixel_size = 1
no_data_value = -9999</pre></div></li><li class="listitem">Set up the input Shapefile we want to convert alongside the new GeoTiff raster that will be created when the script is executed:<div class="informalexample"><pre class="programlisting"># Shapefile input name
# input projection must be in Cartesian system in meters
# input wgs 84 or EPSG: 4326 will NOT work!!!
input_shp = r'../geodata/ply_golfcourse-strasslach3857.shp'

# TIF Raster file to be created
output_raster = r'../geodata/ply_golfcourse-strasslach.tif'</pre></div></li><li class="listitem">Now we need to create the input Shapefile object, get the layer information, and finally set the extent values:<div class="informalexample"><pre class="programlisting"># Open the data source get the layer object
# assign extent coordinates
open_shp = ogr.Open(input_shp)
shp_layer = open_shp.GetLayer()
x_min, x_max, y_min, y_max = shp_layer.GetExtent()</pre></div></li><li class="listitem">Here, we need to calculate the resolution distance to pixel value:<div class="informalexample"><pre class="programlisting"># calculate raster resolution
x_res = int((x_max - x_min) / pixel_size)
y_res = int((y_max - y_min) / pixel_size)</pre></div></li><li class="listitem">Our new raster type is a GeoTiff, so we must explicitly tell GDAL to get this driver. The driver is then able to create a new GeoTiff by passing in the filename or the new raster that we want to create, called the <span class="emphasis"><em>x</em></span> direction resolution, followed by the <span class="emphasis"><em>y</em></span> direction resolution, and then the number of bands; in this case, it is 1. Lastly, we set a new type of <code class="literal">GDT_Byte</code> raster:<div class="informalexample"><pre class="programlisting"># set the image type for export
image_type = 'GTiff'
driver = gdal.GetDriverByName(image_type)

new_raster = driver.Create(output_raster, x_res, y_res, 1, gdal.GDT_Byte)
new_raster.SetGeoTransform((x_min, pixel_size, 0, y_max, 0, -pixel_size))</pre></div></li><li class="listitem">Now we can <a id="id164" class="indexterm"/>access the new <a id="id165" class="indexterm"/>raster band and assign the no data values and the inner data values for the new raster. All the inner values will receive a value of 255 similar to what we set in the <code class="literal">burn_values</code> variable:<div class="informalexample"><pre class="programlisting"># get the raster band we want to export too
raster_band = new_raster.GetRasterBand(1)

# assign the no data value to empty cells
raster_band.SetNoDataValue(no_data_value)

# run vector to raster on new raster with input Shapefile
gdal.RasterizeLayer(new_raster, [1], shp_layer, burn_values=[255])</pre></div></li><li class="listitem">Here we go; let's run this script to see what our new raster looks like:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-05_shp2raster.py</strong></span>
</pre></div></li></ol></div><p>Our resulting raster should look like what is shown in the following screenshot if you open it using<a id="id166" class="indexterm"/> <span class="strong"><strong>QGIS</strong></span> (<a class="ulink" href="http://www.qgis.org">http://www.qgis.org</a>):</p><div class="mediaobject"><img src="images/B03543_03_04.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec68"/>How it works...</h2></div></div></div><p>There are several <a id="id167" class="indexterm"/>steps involved in this code so <a id="id168" class="indexterm"/>follow along as some points could lead to trouble if you are not sure what values to input. We start with the import of the <span class="emphasis"><em>gdal</em></span> and <span class="emphasis"><em>ogr</em></span> modules, respectively, since they will do the work for us by inputting a Shapefile (vector) and outputting a GeoTiff (raster).</p><p>The <code class="literal">pixel_size</code> variable is very important since it will determine the size of the new raster that we will create. In this example, we only have two polygons, so we set <code class="literal">pixel_size = 1</code> to keep a fine border between them. If you have many polygons stretching across the globe in one Shapefile, it is wiser to set this value to 25 or more. Otherwise, you could end up with a 10 GB raster and your machine will run all night long! The <code class="literal">no_data_value</code> is needed to tell GDAL what values to set in the empty space around our input polygons and we set it to <code class="literal">-9999</code> for easy identification.</p><p>Next, we simply set the input Shapefile stored in EPSG:3857 Web Mercator and output GeoTiff. Check to make sure that you change the filenames accordingly if you want to use some other dataset. We start by working with the OGR module to open the Shapefile and retrieve its layer information and the extent information. The extent is important because it is used to calculate the size of the output raster width and height values that must be integers represented by the <code class="literal">x_res</code> and <code class="literal">y_res</code> variables.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note that the projection of your Shapefile must be in meters and not degrees. This is very important since this will NOT work in EPSG:4326, WGS 84, for example. The reason for this is that the coordinate units are LAT/LON. This means that WGS84 is not a flat plane projection and cannot be drawn as is. Our <code class="literal">x_res</code> and <code class="literal">y_res</code> values would evaluate to 0 since we cannot get a real ratio using degrees. This is a result of us not being able to simply subtract coordinate <span class="emphasis"><em>x</em></span> from coordinate <span class="emphasis"><em>y</em></span> because the units are in degrees and not in a flat plane meters projection.</p></div></div><p>Now, moving on<a id="id169" class="indexterm"/> to the raster setup, we define the<a id="id170" class="indexterm"/> type of raster we want to export as a <code class="literal">Gtiff</code>. Then, we'll get the correct GDAL driver by the raster type. Once the raster type is set, we can create a new empty raster dataset, passing in a raster filename, the width, the height of the raster in pixels, the number of raster bands, and finally, the type of rasters in GDAL terms, such as <code class="literal">gdal.GDT_Byte</code>. These five parameters are mandatory to create a new raster.</p><p>Next, we call <code class="literal">SetGeoTransform</code> that handles transforming between pixel/line raster space and projection coordinate space. We'll want to activate <code class="literal">band 1</code> as it is the only band we have in our raster. Then, we'll assign the no data value to all our empty space around a polygon.</p><p>The final step is to call the <code class="literal">gdal.RasterizeLayer()</code> function and pass in our new raster, band, Shapefile, and the value to assign to the inside of our raster. All the pixels inside the polygon will be assigned a value of 255.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec69"/>See also</h2></div></div></div><p>If you are interested, you can visit the <code class="literal">gdal_rasterize</code> command-line tool<a id="id171" class="indexterm"/> at <a class="ulink" href="http://www.gdal.org/gdal_rasterize.html">http://www.gdal.org/gdal_rasterize.html</a>. You can run this straight from the command line.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Converting a raster (GeoTiff) to a vector (Shapefile) using GDAL</h1></div></div></div><p>We have now looked at how we <a id="id172" class="indexterm"/>can go from a vector <a id="id173" class="indexterm"/>to a raster, so it is now <a id="id174" class="indexterm"/>time to go from a raster to a vector. This method is much more common because most of our vector data is derived from remotely sensed data, such as satellite images, orthophotos, or some other remote sensing dataset, such as <code class="literal">lidar</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec70"/>Getting ready</h2></div></div></div><p>As usual, enter the <code class="literal">workon pygeoan_cb</code> command in your Python virtual environment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ source venvs/pygeoan_cb/bin/activate</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How to do it...</h2></div></div></div><p>This recipe only requires four steps utilizing OGR and GDAL so please open up a new file for your code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">ogr</code> and <code class="literal">gdal</code> modules and go straight ahead and open the raster we want to convert by passing it the filename on disk and getting a raster band:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

from osgeo import ogr
from osgeo import gdal

#  get raster data source
open_image = gdal.Open( "../geodata/cadaster_borders-2tone-black-white.png" )
input_band = open_image.GetRasterBand(3)</pre></div></li><li class="listitem">Set up the output <a id="id175" class="indexterm"/>vector file <a id="id176" class="indexterm"/>as a<a id="id177" class="indexterm"/> Shapefile with output_shp, and then get a Shapefile driver. Now, we can create the output from our driver and create a layer as follows:<div class="informalexample"><pre class="programlisting">#  create output data source
output_shp = "../geodata/cadaster_raster"
shp_driver = ogr.GetDriverByName("ESRI Shapefile")

# create output file name
output_shapefile = shp_driver.CreateDataSource( output_shp + ".shp" )
new_shapefile = output_shapefile.CreateLayer(output_shp, srs = None )</pre></div></li><li class="listitem">The final step is to run the <code class="literal">gdal.Polygonize</code> function that does the heavy lifting by converting our raster to a vector as follows:<div class="informalexample"><pre class="programlisting">gdal.Polygonize(input_band, None, new_shapefile, -1, [], callback=None)
new_shapefile.SyncToDisk()</pre></div></li><li class="listitem">Execute the new script as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-06_raster2shp.py</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>How it works...</h2></div></div></div><p>Working with <code class="literal">ogr</code> and<a id="id178" class="indexterm"/> <code class="literal">gdal</code> is similar in all our <a id="id179" class="indexterm"/>recipes; we must define the<a id="id180" class="indexterm"/> inputs and get an appropriate file driver to open the files. The GDAL library is very powerful and in only one line of code we can convert a raster to a vector with the help of the <code class="literal">gdal.Polygonize</code> function. The preceding code is simply setup code to define which format we want to work with and then set up an appropriate driver to input and output our new file.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Creating a Shapefile from point data stored in Microsoft Excel"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Creating a Shapefile from point data stored in Microsoft Excel</h1></div></div></div><p>Excel files are so common these <a id="id181" class="indexterm"/>days that often an analyst or developer receives an Excel file that needs to be mapped out. Sure, we could save these to a <code class="literal">.csv</code> file and then use the great Python standard <span class="emphasis"><em>csv</em></span> module but this involves an extra manual step. We will take a look at how to read a very simple Excel file that contains a list of Europe's highest mountains. This data set is derived<a id="id182" class="indexterm"/> from <a class="ulink" href="http://www.geonames.org">http://www.geonames.org</a>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>Getting ready</h2></div></div></div><p>We are going to need one new Python library to read a Microsoft Excel file and this library is<a id="id183" class="indexterm"/> <span class="strong"><strong>xlrd</strong></span> (<a class="ulink" href="http://www.python-excel.org">http://www.python-excel.org</a>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>This library can only READ an Excel file; if you are looking to write out to an Excel file, download and install<a id="id184" class="indexterm"/> <span class="strong"><strong>xlwt</strong></span>.</p></div></div><p>First, fire up you virtual environment from your <code class="literal">workon pygeoan_cb</code> Linux machine, run <code class="literal">pip install xlrd</code>, and you are off to the races.</p><p>To write out to a new Shapefile, we will use the pyshp library we installed in <a class="link" href="ch01.html" title="Chapter 1. Setting Up Your Geospatial Python Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up Your Geospatial Python environment</em></span>, so that there is no need to do anything.</p><p>The data is located in your downloads in <code class="literal">/ch03/geodata</code> and the output Shapefile will also be written to this location after you go through this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>How to do it...</h2></div></div></div><p>So let's get started with some code:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with the import of <code class="literal">xlrd</code> and the pyshp module; note that the import name is <code class="literal">shapefile</code> and not pyshp as the module name would imply:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-

import xlrd
import shapefile</pre></div></li><li class="listitem">Open the Excel file <a id="id185" class="indexterm"/>using the xlrd module and create a variable to hold the Excel sheet. We reference the first sheet in the Excel file by an index number, always starting with (0) in the first sheet:<div class="informalexample"><pre class="programlisting">excel_file = xlrd.open_workbook("../geodata/highest-mountains-europe.xlsx")

# get the first sheet
sh = excel_file.sheet_by_index(0)</pre></div></li><li class="listitem">Create the Shapefile object as follows:<div class="informalexample"><pre class="programlisting">w = shapefile.Writer(shapefile.POINT)</pre></div></li><li class="listitem">Define the new Shapefile fields and their data types. <span class="emphasis"><em>F</em></span> stands for float and <span class="emphasis"><em>C</em></span> is for character:<div class="informalexample"><pre class="programlisting">w.field('GeoNameId','F')
w.field('Name', 'C')
w.field('Country', 'C')
w.field('Latitude', 'F')
w.field('Longitude', 'F')
w.field('Altitude', 'F')</pre></div></li><li class="listitem">Loop through each row in the Excel file and create the geometry values along with attributes:<div class="informalexample"><pre class="programlisting">for row_number in range(sh.nrows):
    # skips over the first row since it is the header row
    if row_number == 0:
        continue
    else:
        x_coord = sh.cell_value(rowx=row_number, colx=4)
        y_coord = sh.cell_value(rowx=row_number, colx=3)
        w.point(x_coord, y_coord)

        w.record(GeoNameId=sh.cell_value(rowx=row_number, colx=0), Name=sh.cell_value(rowx=row_number, colx=1),
                 Country=sh.cell_value(rowx=row_number, colx=2), Latitude=sh.cell_value(rowx=row_number, colx=3),
                 Longitude=sh.cell_value(rowx=row_number, colx=4),Altitude=sh.cell_value(rowx=row_number, colx=5))
        print "Adding row: " + str(row_number) + " creating mount: " + sh.cell_value(rowx=row_number, colx=1)</pre></div></li><li class="listitem">Lastly, we'll create the new Shapefile in the <code class="literal">/ch03/geodata</code> folder as follows:<div class="informalexample"><pre class="programlisting">w.save('../geodata/highest-mountains')</pre></div></li><li class="listitem">Go ahead and execute our new <code class="literal">ch03-07_excel2shp.py</code> script from the command line as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python ch03-07_excel2shp.py</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>How it works...</h2></div></div></div><p>The Python code reads <a id="id186" class="indexterm"/>similar to making a description of how code works and is almost all too easy to explain. We start with importing our new <span class="emphasis"><em>xlrd</em></span> module along with the Shapefile module needed to write out to a Shapefile. Taking a look at our Excel file, we see which fields are available and locate where the <span class="emphasis"><em>X</em></span> coordinate (longitude) and <span class="emphasis"><em>Y</em></span> coordinate (latitude) are positioned. This position index number remembers the starting point by counting from 0 for the first column.</p><p>Our Excel file also has a header row and this is, of course, not to be included in the new data attributes; this is why we check to see whether row numbers are equal to 0—that is, the first row—and then continue. The continue statements allow the code to continue without an error and enter the <code class="literal">else</code> statement where we define the index positions of our columns. Each column is referenced using the <code class="literal">pyshp</code> syntax, referencing the columns by name to make the code even easier to read.</p><p>We call the <code class="literal">w.point</code> pyshp function to create the point geometry passing in our x and y coordinates as floats. The <code class="literal">xlrd</code> module converts the values for us automatically into floats, which is nice. All we need to do in the end is use the pyshp save function to write out to our <code class="literal">/ch03/geodata</code> folder. There is no need to add the <code class="literal">.shp</code> extension; pyshp handles this for us and outputs <code class="literal">.shp</code>, <code class="literal">.dbf</code>, and <code class="literal">.shx</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Note that a <code class="literal">.prj</code> projection file is not automatically output. If you would like to have the projection information exported as well, you will need to manually create it like this:</p><div class="informalexample"><pre class="programlisting"># create the PRJ file
filename = 'highest-mountains'
prj = open("%s.prj" % filename, "w")
epsg = 'GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["degree",0.0174532925199433]]'
prj.write(epsg)
prj.close()</pre></div></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Converting an ESRI ASCII DEM to an image height map"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Converting an ESRI ASCII DEM to an image height map</h1></div></div></div><p>To end this chapter <a id="id187" class="indexterm"/>with a bang, here is the most <a id="id188" class="indexterm"/>complicated conversion we have seen so far and the most fun as well. Input is an elevation dataset that's stored in <span class="emphasis"><em>ASCII</em></span> format, more specifically, Arc/Info ASCII Grid, for short with the AAIGrid with the (<code class="literal">.asc</code>) file ending. Our output is a <span class="emphasis"><em>heightmap</em></span> image (<a class="ulink" href="http://en.wikipedia.org/wiki/Heightmap">http://en.wikipedia.org/wiki/Heightmap</a>). A<a id="id189" class="indexterm"/> heightmap image is an image that stores height elevation as a pixel value. A heightmap is also simply known as <a id="id190" class="indexterm"/>a <span class="strong"><strong>digital elevation model</strong></span> (<span class="strong"><strong>DEM</strong></span>). The benefit of using an image to store elevation data is that it is <span class="emphasis"><em>web compatible</em></span> and we can use this in a 3D visualization with <a id="id191" class="indexterm"/>
<span class="strong"><strong>threejs</strong></span>, for example, as shown in <a class="link" href="ch10.html" title="Chapter 10. Visualizing Your Analysis">Chapter 10</a>, <span class="emphasis"><em>Visualizing Your Analysis</em></span>.</p><p>We need to be careful with regard to the output image format because simply storing an 8-bit image limits us to only storing 0 to 255 height values, which is typically not enough. The output image should store a minimum of 16-bits, giving us a range from -32,767 to 32,767. If I am correct, the tallest mountain on earth is Mt. Everest at a height of 8,848 m, so a 16-bit image should be more than enough to hold our elevation data.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec76"/>Getting ready</h2></div></div></div><p>A DEM is needed to run this exercise so please make sure you have downloaded the code and geodata included at <a class="ulink" href="https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip">https://github.com/mdiener21/python-geospatial-analysis-cookbook/archive/master.zip</a> and download the sample DEM needed to process. You do not need to run your script from within your virtual environment because this script will be executing standard Python modules and several GDAL built-in tools installed with GDAL. This simply means that you need to make sure your GDAL utilities are properly installed and running on your machine. (Refer to <a class="link" href="ch02.html" title="Chapter 2. Working with Projections">Chapter 2</a>, <span class="emphasis"><em>Working with Projections</em></span>, for the reference installation.)</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How to do it...</h2></div></div></div><p>We will execute this<a id="id192" class="indexterm"/> script by calling several GDAL<a id="id193" class="indexterm"/> utility scripts installed by <code class="literal">gdal</code> from our Python script:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by importing the subprocess standard module; this will be used to execute our GDAL utility functions. Then, we'll set the base path to where we will store our geodata for input files, temporary files, and output files:<div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# -*- coding: utf-8 -*-
import subprocess
from osgeo import gdal

path_base = "../geodata/"</pre></div></li><li class="listitem">Windows users who have installed GDAL using the great OSGeo4w installer might want to specify the path directly to the GDAL utilities if it is not available in the Windows Environment variables as follows:<div class="informalexample"><pre class="programlisting"># gdal_translate converts raster data between different formats

command_gdal_translate = "c:/OSGeo4W/bin/gdal_translate.exe"
command_gdalinfo = "c:/OSGeo4W/bin/gdalinfo.exe"</pre></div></li><li class="listitem">Linux users can use these variables:<div class="informalexample"><pre class="programlisting">command_gdal_translate = "gdal_translate"
command_gdalinfo = "gdalinfo"
command_gdaldem = "gdaldem"</pre></div></li><li class="listitem">We'll create a set of variables to hold our input DEM, output files, temporary files, and our final output file. The variables concatenate the base path folder to the filename as follows:<div class="informalexample"><pre class="programlisting">orig_dem_asc = path_base + "original_dem.asc"

temp_tiff = path_base + "temp_image.tif"

output_envi = path_base + "final_envi.bin"</pre></div></li><li class="listitem">Then, we'll call the <code class="literal">gdal_translate</code> command to create our new temporary GeoTiff as follows:<div class="informalexample"><pre class="programlisting"># transform dem to tiff
dem2tiff = command_gdal_translate + " " + orig_dem_asc + " " + temp_tiff
print ("now executing this command: " + dem2tiff)
subprocess.call(dem2tiff.split(), shell=False)</pre></div></li><li class="listitem">Next, we'll open the temp GeoTiff and read the information about the tiff to find out the minimum and maximum height values stored in our data. This is not needed to complete the script but is very useful to identify your maximum and minimum height values:<div class="informalexample"><pre class="programlisting">ds = gdal.Open(temp_tiff, gdal.GA_ReadOnly)
band = ds.GetRasterBand(1)
print 'Band Type=', gdal.GetDataTypeName(band.DataType)
min = band.GetMinimum()
max = band.GetMaximum()
if min is None or max is None:
    (min, max) = band.ComputeRasterMinMax(1)
print 'Min=%.3f, Max=%.3f' % (min, max)
min_elevation = str(int(round(min)))
max_elevation = str(int(round(max)))</pre></div></li><li class="listitem">Then, call <a id="id194" class="indexterm"/>the gdal_translate <a id="id195" class="indexterm"/>utility with the following parameters, setting the scale range from its original min/max values to a new scale ranging from the 0 to 65,535 values. Specify the <code class="literal">-ot</code> output type to be in the vENVI format using our temporary GeoTiff as the input:<div class="informalexample"><pre class="programlisting">tif_2_envi = command_gdal_translate + " -scale -ot UInt16 -outsize 500 500 -of ENVI " \
             + temp_tiff + " " + output_envi</pre></div></li><li class="listitem">Let's run our new <code class="literal">ch03-08_dem2heightmap.py</code> script from the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>subprocess.call(tif_2_envi.split(),shell=False)</strong></span>
</pre></div></li><li class="listitem">Let's run our new <code class="literal">ch03-08_dem2heightmap.py</code> script from the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python ch03-08_dem2heightmap.py</strong></span>
</pre></div></li></ol></div><p>The result is that you have a new .bin file located in your /ch03/geodata/ folder that stores your new ENVI 16-bit image including all your elevation data. The image height map can now be used in your 3D software, such as Blender<a id="id196" class="indexterm"/> (<a class="ulink" href="http://www.blender.org">www.blender.org</a>), Unity (<a class="ulink" href="http://www.unity3d.com">www.unity3d.com</a>), or<a id="id197" class="indexterm"/> in an even cooler web application using a JavaScript library such as <code class="literal">threejs</code>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec78"/>How it works...</h2></div></div></div><p>Let's start with the imports, and then we'll specify the base path to where our inputs and outputs will be stored. After this, we'll see the actual commands we used to execute the <code class="literal">gdal_translate</code> transformation. The commands for Windows and Linux are for you to decide whether to use or not and this depends on how you have set up up your machine. We then set our variable to define the input DEM, temporary GeoTiff, and the output ENVI height map image.</p><p>At last, we can call the first transformation that converts our DEM ASCII file into a GeoTiff with the <code class="literal">gdal_translate</code> utility. Now to get a little information about our data, we print out the <code class="literal">min</code> and <code class="literal">max</code> height values to the screen. Sometimes, this is very useful when transforming, allowing you to check whether the output data actually contains the input height values and that nothing went astray during conversion.</p><p>In the end, we<a id="id198" class="indexterm"/> simply call the <code class="literal">gdal_translate</code> utility <a id="id199" class="indexterm"/>once again to convert our GeoTiff into an ENVI heightmap image. The -scale with no parameters automatically fills our 16-bit image with values ranging from 0 to 65,535. Our next parameter is <code class="literal">-ot</code>, which specifies the output type as 16-bit followed by <code class="literal">-outsize 500 500</code>, setting the output image size to 500 x 500 pixels. Lastly, <code class="literal">-of ENVI</code> is our output format followed by the name of the input GeoTiff and the name of the output height map.</p><p>A typical work flow when working with DEM's is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download a DEM that is usually a very large file and covers a large geographic region.</li><li class="listitem">Clip the DEM to a smaller region of interest.</li><li class="listitem">Convert the clipped region to another format.</li><li class="listitem">Export the DEM as a heightmap image.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>We introduce <code class="literal">.split()</code> that will return a Python list of words, separated by a character. In our case, the separator character is a <span class="emphasis"><em>single space</em></span> character but you could split based on any other <a id="id200" class="indexterm"/>character or a combination of characters (refer to the Python documentation at <a class="ulink" href="https://docs.python.org/2/library/string.html#string.split">https://docs.python.org/2/library/string.html#string.split</a>) This helps us reduce the amount of concatenating that we need to do in our code.</p></div></div></div></div></div>
</body></html>