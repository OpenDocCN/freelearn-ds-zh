- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Understanding Basic Quantum Computing Principles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本量子计算原理
- en: Quantum computing, particularly its algorithms, leverages three quantum computing
    principles, namely, **superposition**, **entanglement**, and **interference**.
    In this chapter, we’ll review each of these so that we can understand what each
    provides, the effect it has on each qubit, and how to represent them using the
    quantum gate sets provided to us. The quantum computers hosted on the **IBM Quantum
    Platform** leverage all these principles using the various quantum gates, some
    of which you used earlier in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算，尤其是其算法，利用了三个量子计算原理，即**叠加**、**纠缠**和**干涉**。在本章中，我们将回顾这些原理，以便我们了解它们各自提供的内容，它们对每个量子比特的影响，以及如何使用我们提供的量子门集来表示它们。在**IBM量子平台**上运行的量子计算机利用各种量子门，其中一些你在本书的前面部分已经使用过。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing quantum computing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍量子计算
- en: Understanding superposition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解叠加
- en: Understanding entanglement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解纠缠
- en: Understanding interference
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解干涉
- en: Exploring the Bell states
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索贝尔态
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, some general knowledge of physics is recommended; however,
    my goal is for the explanations to help you understand the quantum principles
    without the need for you to register for a physics course. Here is the full source
    code used throughout this book: [https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience](https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，建议你具备一些物理学的一般知识；然而，我的目标是让解释帮助你理解量子原理，而无需你注册物理课程。以下是本书中使用的完整源代码：[https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience](https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience)。
- en: Introducing quantum computing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍量子计算
- en: Quantum computing isn’t a subject that is as common as learning algebra or reading
    some of the literary classics. However, for most scientists and engineers or people
    in any other field that includes studying physics, quantum computing is part of
    the curriculum. Those of us who don’t quite recall our studies in physics, or
    have never studied it, need not worry, as this section aims to provide you with
    information that will either refresh your recollection of the topic or at least,
    perhaps, help you understand what each of the principles used in quantum computing
    means. Let’s start with a general definition of quantum mechanics.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算并不是像学习代数或阅读一些文学经典那样常见的主题。然而，对于大多数科学家和工程师，或者任何包括学习物理在内的其他领域的人来说，量子计算是课程的一部分。对于我们那些不太记得物理学习内容，或者从未学习过物理的人来说，不必担心，因为本节旨在提供信息，以刷新你对这个主题的记忆，或者至少，也许，帮助你理解量子计算中使用的每个原理的含义。让我们从量子力学的一般定义开始。
- en: '**Quantum mechanics**, as defined by most texts, is the study of nature at
    its smallest scale—in this case, the subatomic scale. The study of quantum mechanics
    is not new. Its growth began in the early 1900s thanks to the efforts of many
    physicists, whose names still chime in many of the current theories and experiments.
    The names of such physicists include Erwin Schrödinger, Max Planck, Werner Heisenberg,
    Max Born, Paul Dirac, and Albert Einstein, among others. As the years passed,
    many other scientists expanded on the foundations of quantum mechanics and began
    performing experiments that challenged many of the classical theories, theories
    such as the photoelectric effect as well as more modern approaches such as the
    wave function, which is used to provide various physical properties of a particle.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**量子力学**，如大多数文本所定义的，是研究自然在其最小尺度上的学问——在这种情况下，是亚原子尺度。量子力学的研究并非新鲜事物。它的增长始于20世纪初，得益于许多物理学家的努力，他们的名字至今仍在许多当前的理论和实验中回响。这些物理学家的名字包括埃尔温·薛定谔、马克斯·普朗克、维尔纳·海森堡、马克斯·玻恩、保罗·狄拉克和阿尔伯特·爱因斯坦等。随着时间的推移，许多其他科学家在量子力学的基础上进行了扩展，并开始进行实验，挑战了许多经典理论，如光电效应以及更现代的方法，如波函数，它被用来提供粒子的各种物理属性。'
- en: One of the more popular experiments that have come out of quantum mechanics
    is the **double-slit experiment**. Although this is found in classical mechanics,
    it is referenced in quantum computing to describe the behavior of a **quantum
    bit** (**qubit**). It is in this experiment that researchers were able to demonstrate
    that light (or photons) can be characterized as both waves and particles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从量子力学中涌现出的更受欢迎的实验之一是**双缝实验**。尽管这在经典力学中是存在的，但它被引用在量子计算中，用来描述**量子比特**（**qubit**）的行为。正是在这个实验中，研究人员能够证明光（或光子）可以同时被描述为波和粒子。
- en: 'Many distinct experiments have been conducted over the years that illustrate
    this phenomenon, one of which was to fire photon particles through a double slit
    one at a time, where at the other side of the double slit, there was a screen
    that captured, as a point, the location where each particle would hit. When only
    one slit was open, all the particles would appear as a stack of points directly
    behind the slit, as shown in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，许多不同的实验已经进行了，以说明这一现象，其中之一是将光子粒子一个接一个地通过双缝发射，在双缝的另一侧，有一个屏幕捕捉每个粒子击中的位置，作为一个点。当只有一个狭缝打开时，所有粒子都会以点堆的形式出现在狭缝后面，如下面的图所示：
- en: '![Diagram, schematic  Description automatically generated](img/B18420_04_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图，示意图 描述自动生成](img/B18420_04_01.png)'
- en: 'Figure 4.1: Single-slit experiment (image source: https://commons.wikimedia.org/wiki/File:SingleSlitDiffraction.GIF)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：单缝实验（图片来源：https://commons.wikimedia.org/wiki/File:SingleSlitDiffraction.GIF）
- en: From the previous diagram, you can see that all the particles are captured in
    an area directly across the slit. Here, the angle theta ![](img/_eqn_001.png)
    indicates the angle from the center of the slit (pattern) to the first minimum
    intensity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你可以看到所有粒子都被捕获在直接穿过狭缝的区域。在这里，角度θ![img/_eqn_001.png](img/_eqn_001.png)表示从狭缝（图案）中心到第一个最小强度的角度。
- en: 'However, when the second slit was open, it was imagined that there would be
    an identical stack of points on the screen, therefore two stacks. But this was
    not the case, as what was captured appeared to be a formation altogether different
    than what would be expected from a particle. In fact, it had the characteristics
    of a wave in that the points on the screen seemed to display a diffraction pattern,
    as shown in the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当第二个狭缝打开时，想象中屏幕上会有一个相同的点堆，因此有两个堆。但事实并非如此，因为捕捉到的图像似乎与从粒子那里预期的完全不同。实际上，它具有波的特性，因为屏幕上的点似乎显示出衍射图案，如下面的图所示：
- en: '![Diagram  Description automatically generated](img/B18420_04_02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 描述自动生成](img/B18420_04_02.png)'
- en: 'Figure 4.2: Double-slit experiment (image source: https://commons.wikimedia.org/wiki/File:Double-slit.PNG)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：双缝实验（图片来源：https://commons.wikimedia.org/wiki/File:Double-slit.PNG）
- en: From the previous diagram, you can see that all the particles are spread out
    from the center with interference gaps.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你可以看到所有粒子都从中心向外扩散，形成干涉条纹。
- en: This diffraction pattern is caused by the interference of the light waves passing
    through the slits. Here, there are more points at the center of the screen than
    there are toward the outer ends of the observing screen. This interference of
    individual particles is the basis for what is now known as **wave-particle duality**,
    which generally infers that photons of light can behave like both a wave and a
    particle. This property is used in quantum computing, particularly in algorithms
    such as Grover’s and Shor’s algorithms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种衍射图案是由通过狭缝的光波相互干涉造成的。在这里，屏幕中心比观察屏幕的外端有更多的点。这种单个粒子的干涉是现在所知的**波粒二象性**的基础，它通常推断光子可以同时表现出波和粒子的特性。这种特性被用于量子计算，特别是在Grover算法和Shor算法等算法中。
- en: This wave-particle phenomenon gave birth to lots of interesting research and
    development such as the **Copenhagen interpretation**, the **many-worlds interpretation**,
    and the **De Broglie-Bohm** theory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种波粒二象性现象催生了大量有趣的研究和开发，如**哥本哈根解释**、**多世界解释**和**德布罗意-波姆理论**。
- en: What this illustrates is that the light appeared as bands of light in certain
    areas of the board with some probability. By observing the preceding diagram,
    you can see that there is a higher probability that the electron fired from the
    gun will land in the center band of the screen as opposed to the outer bands as
    illustrated by the darker shades of gray. Also, note that due to interference,
    the spaces in between the bands that capture the electrons have less probability
    (blank areas between bands).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明光以一定的概率出现在板上的某些区域，形成光带。通过观察前面的图示，你可以看到电子从枪中发射后更有可能落在屏幕的中心带，而不是外带，如较深的灰色阴影所示。此外，由于干涉，捕获电子的带之间的空间概率较低（带之间的空白区域）。
- en: It is these effects of wave interference and probabilities that we will cover
    in this chapter, but first, we will start with the electron itself to understand
    superposition.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖这些波干涉和概率效应，但首先，我们将从电子本身开始，以理解叠加原理。
- en: Understanding superposition
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解叠加原理
- en: '**Superposition** is something we generally can’t see with the naked eye. It’s
    defined as a combination of two similar yet distinct phenomena occurring at once:
    for example, being able to whistle and hum at the same time. Both are the same
    in that they are audible waves but distinct in how they sound. You can whistle
    without humming, and vice versa; however, doing them both at the same time is
    placing them in a superposition as you are creating a combination of both distinct
    sounds at the same time.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**叠加**是我们通常无法用肉眼看到的。它被定义为同时发生的两种相似但不同的现象的组合：例如，同时吹口哨和哼歌。两者相同之处在于它们都是可听见的波，但不同之处在于它们的声音。你可以单独吹口哨而不哼歌，反之亦然；然而，同时做这两件事就是将它们置于叠加状态，因为你同时创造了两种不同的声音组合。'
- en: In quantum mechanics, we are typically discussing the superposition of an electron.
    Since an electron is very small and there are so many of them, it is hard to distinguish
    one with even a powerful microscope. It is commonly referred to as an elementary
    particle. There are, however, some analogies in the classical world that we can
    use to illustrate what superposition is. For example, a spinning coin is what
    most texts use to describe superposition.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在量子力学中，我们通常讨论的是电子的叠加。由于电子非常小，而且数量众多，即使使用高倍显微镜也难以区分它们。它们通常被称为基本粒子。然而，在经典世界中，有一些类比可以帮助我们说明叠加原理。例如，旋转的硬币是大多数文本用来描述叠加原理的例子。
- en: While it is spinning, we can say that it is in the state of both heads and tails.
    It isn’t until the coin collapses that we see what the final state of the coin
    is. This explains superposition from a probability perspective; however, the formal
    definition is commonly found in any classical physics book when describing the
    spin of an electron. I will leave this for you to search for as there are lots
    of references and resources available online that go into detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬币旋转时，我们可以认为它同时处于正面和反面的状态。直到硬币坍缩，我们才能看到硬币的最终状态。这从概率的角度解释了叠加；然而，正式的定义通常可以在任何经典物理书中找到，当描述电子的自旋时。我将留给你去搜索，因为网上有大量的参考资料和资源可以深入了解。
- en: In this chapter, we’re going to use this spinning coin analogy just to help
    you understand the general principle of superposition. However, once we start
    working on our quantum circuits, you will see some of the differences between
    superposition and its probabilistic behavior in the classical world versus its
    behavior in the quantum world.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用旋转硬币的类比，只是为了帮助你理解叠加原理的一般原理。然而，一旦我们开始构建量子电路，你将看到叠加及其在经典世界和量子世界中的概率行为之间的差异。
- en: Let’s start by reviewing the random effects we saw in the slit experiments in
    the classical world.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下在经典世界中狭缝实验中观察到的随机效应。
- en: Learning about classical randomness
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解经典随机性
- en: Previously, we discussed the randomness of a spinning coin as an example. However,
    the spinning coin and its results are not as random as we think. Just because
    we cannot guess the correct answer when a coin is spun on a table or flipped in
    the air does not make it random. What leads us to believe that it’s random is
    the fact that we don’t have all the information necessary to know or predict or,
    in fact, determine that the coin will land on either heads or tails.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们以旋转硬币的随机性为例进行了讨论。然而，旋转硬币及其结果并不像我们想象的那样随机。仅仅因为我们无法在桌子上旋转硬币或在空中抛掷硬币时猜出正确答案，并不意味着它是随机的。让我们相信它是随机的是这样一个事实：我们没有所有必要的信息来了解、预测或实际上确定硬币会落在正面还是反面。
- en: All the relevant information, such as the weight of the coin, its shape, the
    amount of force required to spin the coin, the air resistance, the friction of
    the platform the coin is rolling on, and so on, as well as the information of
    the environment itself, is not known to us in order for us to determine what the
    outcome would be after spinning a coin. It’s because of this lack of information
    that we assume the spinning of the coin is random. If we had some function that
    could calculate all this information, then we would always successfully determine
    the outcome of the spinning coin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关的信息，例如硬币的重量、其形状、旋转硬币所需的力、空气阻力、硬币滚动平台的摩擦力等等，以及环境本身的信息，我们都不了解，以便我们确定旋转硬币后的结果会是什么。正是因为这种信息不足，我们才假设硬币的旋转是随机的。如果我们有一个能够计算所有这些信息的函数，那么我们就可以始终成功地确定旋转硬币的结果。
- en: The same can be said about random number generators. As an example, when we
    trigger a computer to generate a random number, the computer uses a variety of
    information to calculate and generate a so-called random number. These parameters
    can include information such as the current daytime that the request was triggered,
    information about the user or the system itself, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于随机数生成器。例如，当我们触发计算机生成随机数时，计算机使用各种信息来计算和生成所谓的随机数。这些参数可以包括请求触发时的当前时间、关于用户或系统本身的信息等等。
- en: These types of random number generators are often referred to as **pseudorandom
    number** (**PSRN**) **generators** or **deterministic random bit (DRB) generators**.
    They are only as random as the calculation or seed values provided that are allowed.
    For example, if we knew the parameters used and how they were used to generate
    this random number, then we would be able to determine the generated random number
    every time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这类随机数生成器通常被称为**伪随机数生成器（PSRN**）或**确定性随机比特（DRB）生成器**。它们的随机性仅限于允许的计算或种子值。例如，如果我们知道用于生成这个随机数的参数以及它们是如何被使用的，那么我们就可以确定每次生成的随机数。
- en: Now I don’t want you to worry about anyone determining the calculations or cryptographic
    keys that you may have generated. We use these PSRN generators because of the
    precision and granularity that they encompass to generate this number, which is
    such that any deviation can drastically alter the results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我不想让你担心任何人确定你可能生成的计算或加密密钥。我们使用这些PSRN生成器是因为它们包含的精度和粒度可以生成这样的数字，任何偏差都会极大地改变结果。
- en: '*So, why bother reviewing the probabilistic and random nature of a spinning
    coin?* One, it’s to explain the difference between randomness, or what we believe
    is random, in the classical world versus randomness in the quantum world. Two,
    at some point we will need to leave any form of classical analogy and accept the
    fact that the quantum behavior is not obvious nor easily measured. If you wish
    to get a deeper understanding of these phenomena, which we cannot easily describe
    using classical physics or analogies, I recommend about reading the **Heisenberg
    uncertainty principle**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，为什么还要回顾旋转硬币的概率和随机性质呢？* 一，是为了解释经典世界中的随机性，或者说我们认为是随机性，与量子世界中的随机性之间的区别。二，在某个时候，我们将需要放弃任何形式的经典类比，并接受量子行为并不明显也不容易测量的这一事实。如果您希望更深入地了解这些现象，这些现象我们无法轻易用经典物理学或类比来描述，我建议阅读**海森堡不确定性原理**。'
- en: In the classic world, we learned that if we had all the information available,
    we can more than likely determine an outcome. However, in the previous section,
    where we described the double-slit experiment, we saw that we couldn’t determine
    where on the screen the electron was going to hit. We understood the probabilities
    of where it would land based on our experiment. But even then, we could not deterministically
    identify where precisely the electron was going to land on the screen. You’ll
    see an example of this when we create our superposition circuit in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典世界中，我们了解到如果我们拥有所有可用信息，我们很可能确定一个结果。然而，在上一节中，当我们描述双缝实验时，我们看到我们无法确定电子会在屏幕上的哪个位置击中。我们根据实验理解了它可能落下的概率。但即使如此，我们也不能确定地识别电子在屏幕上的确切位置。当我们在下一节创建我们的叠加电路时，你将看到这个例子。
- en: 'For those who wish to learn a little more about this photonic phenomenon, I
    would suggest reading the book by the famous physicist Richard Feynman titled
    *QED: The Strange Theory of Light and Matter*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '对于那些想了解更多关于这个光子现象的人来说，我建议阅读著名物理学家理查德·费曼所著的书籍 *QED: 光和物质的奇异理论*。'
- en: Preparing a qubit in a superposition state
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备一个处于叠加态的量子比特
- en: In this section, we are going to create a circuit with a single qubit and set
    an operator on the qubit to set it in a superposition state. But before we do
    that, let’s quickly define what a superposition state is.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个包含单个量子比特的电路，并在量子比特上设置一个操作员以将其置于叠加态。但在我们这样做之前，让我们快速定义什么是叠加态。
- en: We define the qubit as having two basis energy states, one of which is the ground
    (0) state and the second of which is the excited (1) state, as illustrated in
    *Figure 4.3*. The state value name of each basis state could be anything we choose,
    but since the results from our circuit will be fed back to a classic system, we
    will use binary values to define our states—in this case, the binary values 0
    and 1\. To say that the superposition of two states is *being in both 0 and 1
    at the same time* is incorrect. The proper way to state that a qubit is in a superposition
    state is to say that it is *in a complex linear combination of states where, in
    this case, the states are 0 and 1*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将量子比特定义为具有两个基态能量，其中一个基态是基态（0）状态，另一个基态是激发态（1）状态，如图 *4.3* 所示。每个基态的状态值名称可以是任何我们选择的，但由于我们的电路结果将反馈到经典系统中，我们将使用二进制值来定义我们的状态——在这种情况下，二进制值
    0 和 1。说两个状态的叠加是*同时处于 0 和 1*是不正确的。正确表述量子比特处于叠加态的方式是说它处于一个复杂线性组合的状态中，在这种情况下，状态是
    0 和 1。
- en: A simple analogy of this is to perhaps think of a bit as a standard light switch.
    In one position the light is on, in the other position the light is off. It’s
    either one or the other. This is analogous to a bit, either *0* or *1* (Off or
    On, respectively). Now consider a light dimmer switch (technically, a rheostat)
    where the switch can be rotated to the On position and then rotated all the way
    down to the Off position. What you can also do with a dimmer is slide the switch
    to anyplace in between off and on, this in turn adjusts the intensity, or amplitude,
    of the amount of light emitted. Now, when you have the dimmer in between the On
    and Off position, you don’t say the light is “On and Off at the same time” do
    you? Of course not. It is more of a combination of the two. Keep in mind of course,
    this is not the definition of a qubit, it’s just a simple example of why saying
    something is two things at once is not entirely correct.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类比可能就是将比特想象成一个标准的开关。在一个位置上，灯是亮的，在另一个位置上，灯是关的。它要么是其中一个，要么是另一个。这与比特类似，要么是*0*，要么是*1*（分别对应关和开）。现在考虑一个调光开关（技术上称为变阻器），其中开关可以旋转到开的位置，然后旋转到底部关的位置。你还可以用调光开关将开关滑动到开和关之间的任何位置，这反过来会调整发出的光的强度或振幅。现在，当你将调光开关置于开和关之间时，你不会说灯“同时开和关”吧？当然不会。这更多的是两种状态的结合。当然，记住，这并不是量子比特的定义，它只是说明说某物同时是两件事并不完全正确的一个简单例子。
- en: Visualizing the state of a qubit is generally difficult, particularly multi-qubit
    states, which involve more than one qubit and multiple quantum states. One of
    the earlier visualization models developed was the 2-state sphere that provided
    a geometrical representation of a 2-level quantum mechanical system called the
    **Bloch sphere**. The following figure is an example of a Bloch sphere, which
    represents a single qubit and its two orthogonal basis states, which are located
    on opposite poles. On the north pole, we have the basis state ![](img/B18420_04_006.png),
    while on the south pole, we have the basis state ![](img/B18420_04_007.png). The
    symbols surrounding the basis state values are the commonly used notations in
    most quantum computing text. This is called **Dirac notation**, which was named
    after the English theoretical physicist Paul Dirac, who first conceived the notation,
    which he called the **Bra-Ket notation**. Bra-Ket and Dirac notation are generally
    used interchangeably as they refer to the same thing, as we’ll see later. Each
    has its unique form as follows, **Bra** has the following form, ![](img/_eqn_004.png),
    and **Ket** has the following form, ![](img/B18420_04_006.png), where each denotes
    a mathematical *linear form* and *vector*, respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化量子比特的状态通常很困难，尤其是多量子比特状态，它们涉及多个量子比特和多个量子态。早期开发的一种可视化模型是2态球体，它提供了一个二维量子力学系统（称为**布洛赫球**）的几何表示。以下是一个布洛赫球的示例，它代表一个量子比特及其两个正交基态，这些基态位于相反的极点。在北极，我们有基态![img/B18420_04_006.png]，而在南极，我们有基态![img/B18420_04_007.png]。围绕基态值的符号是大多数量子计算文本中常用的符号。这被称为**狄拉克符号**，它是以英国理论物理学家保罗·狄拉克的名字命名的，他首先构想了这个符号，他称之为**括号符号**。括号和狄拉克符号通常可以互换使用，因为它们指的是同一件事，我们稍后会看到。每个都有其独特的形式，**括号**具有以下形式，![img/_eqn_004.png]，而**括号**具有以下形式，![img/B18420_04_006.png]，其中每个分别表示一个数学**线性形式**和**向量**。
- en: '![Figure 4.3 - Two basis states of a qubit on a Bloch sphere ](img/B18420_04_03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 - 布洛赫球上的量子比特的两个基态](img/B18420_04_03.png)'
- en: 'Figure 4.3: Two basis states of a qubit on a Bloch sphere'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：在布洛赫球上的一个量子比特的两个基态
- en: OK, so let’s stop talking, and let’s start coding. We’re going to create a quantum
    circuit with a single qubit. We will then execute the circuit so that we can obtain
    the same result we can see in the preceding screenshot, which is the initial state
    of the qubit, state ![](img/B18420_04_006.png).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们停止谈论，开始编码。我们将创建一个包含单个量子比特的量子电路。然后我们将执行该电路，以便我们可以获得与前面截图相同的结果，即量子比特的初始状态，状态![img/B18420_04_006.png]。
- en: Before we get started, let’s first import the helper file into your working
    directory. It contains a series of functions that will help us in two ways. First,
    it will provide a series of functions we can use to quickly get us started to
    execute circuits without having to cover any details just yet. But not to worry,
    you will learn the details as we progress throughout the book, and the dependency
    of the helper file will surely disappear. Second, this will also help keep the
    code base up to date as new features and changes happen, so that updates can be
    made to keep code running far beyond the current version. The location of the
    helper file is in the GitHub repo linked at the beginning of this chapter, titled
    `helper_file_1.0.ipynb`. Be aware that you may need to set up your account if
    you want to use a quantum system and not the local simulators on your device.
    If so, please open the `setup_save_account.ipynb` file and enter your API token
    in the specified attribute and run the file. Once you do, that will save your
    API on your local machine, so you won’t have to set up each time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，首先将辅助文件导入到你的工作目录中。它包含一系列函数，将帮助我们以两种方式。首先，它将提供一系列函数，我们可以快速使用它们来执行电路，而不必立即覆盖任何细节。但不用担心，随着我们继续阅读本书，你将学习到这些细节，辅助文件的依赖性肯定会消失。其次，这也有助于保持代码库的更新，因为新功能和更改发生时，可以更新代码以保持远超当前版本。辅助文件的位置在本章开头提到的GitHub仓库中，标题为`helper_file_1.0.ipynb`。请注意，如果你想使用量子系统而不是设备上的本地模拟器，你可能需要设置你的账户。如果是这样，请打开`setup_save_account.ipynb`文件，并在指定的属性中输入你的API令牌并运行该文件。一旦这样做，它将在你的本地机器上保存你的API，因此你不必每次都设置。
- en: 'Open a new Qiskit Notebook and enter the following code into the next empty
    cell:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Qiskit笔记本，并在下一个空单元格中输入以下代码：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line will load the helper file into the working notebook. The file
    contains functions that we will use to import the functions and libraries we need
    to get started, such as those needed for executing circuits on simulators and
    backend systems and returning the results of our circuits. The next line creates
    a quantum circuit that includes `1` qubit and 1 classical bit, and in the next
    line we will pass the quantum circuit to the `Statevector` object, which will
    generate the state vector of the quantum circuit. This will return the resulting
    object, which will contain the state vector results. Finally, we display the results
    on a Bloch sphere, which should display what you saw in *Figure 4.3*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将加载辅助文件到工作笔记本中。该文件包含我们将使用的函数，例如用于在模拟器和后端系统上执行电路并返回电路结果的函数。下一行创建一个包含1个量子比特和1个经典比特的量子电路，在下一行我们将量子电路传递给`Statevector`对象，这将生成量子电路的状态向量。这将返回结果对象，其中将包含状态向量结果。最后，我们在Bloch球体上显示结果，应该显示你在*图4.3*中看到的内容。
- en: 'Each qubit, as mentioned earlier, is made up of two basis states, which, in
    this example, reside on opposite poles of the Bloch sphere. These two basis states
    are what we would submit back to the classical system as our result—either one
    or the other. The vector representing these two points originates from the origin
    of the Bloch sphere, as you can see in the previous diagram or the result from
    your experiment. If we were to notate this as a vector, we would write the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个量子比特，如前所述，由两个基态组成，在这个例子中，它们位于Bloch球体的相反极点。这两个基态就是我们提交给经典系统的结果——要么是一个，要么是另一个。代表这两个点的向量起源于Bloch球体的原点，正如你可以在之前的图中或实验结果中看到的那样。如果我们将其表示为一个向量，我们将写成以下形式：
- en: '![](img/B18420_04_002.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_002.png]'
- en: 'Since the opposite would apply to the opposite pole, we would notate it as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相反的情况适用于相反的极点，我们将如下表示：
- en: '![](img/B18420_04_003.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_003.png]'
- en: 'From observing the vector values, you can see that flipping the values of the
    vector is like a classical bit flip. Now that we understand the vector representation
    of a qubit, let’s continue and set the qubit in a superposition state:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从观察向量值中，你可以看到翻转向量的值就像经典比特翻转一样。现在我们理解了量子比特的向量表示，让我们继续并设置量子比特处于叠加态：
- en: 'Insert a new cell at the bottom of the current notebook and enter the following
    code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前笔记本的底部插入一个新单元格，并输入以下代码：
- en: '[PRE1]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line places a **Hadamard (H)** gate onto the first qubit, identified
    by the qubit’s index value (`0`). It then calls the `draw()` function, which will
    draw the circuit diagram; note that the `output` parameter is added just to get
    a nicer output. If you would like to include these visualization features, be
    sure to install `qiskit[visualization]` from pip (`pip install qiskit[visualization]`).
    Otherwise, you can remove the parameter and get standard text visualization outputs.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将**Hadamard（H）**门放置在第一个量子比特上，该量子比特由量子比特的索引值（`0`）标识。然后它调用`draw()`函数，这将绘制电路图；请注意，添加了`output`参数只是为了获得更好的输出。如果你想要包括这些可视化功能，请确保从pip中安装`qiskit[visualization]`（`pip
    install qiskit[visualization]`）。否则，你可以删除该参数并获取标准的文本可视化输出。
- en: 'After running the previous cell, you should see the following circuit image,
    which represents adding the Hadamard gate to the qubit and the classical bit just
    below:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个单元格后，你应该看到以下电路图像，它表示将Hadamard门添加到量子比特和其下方的经典比特：
- en: '![A diagram of a square with a blue square and black text  Description automatically
    generated](img/B18420_04_04.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有蓝色方块和黑色文字的方形图，描述自动生成](img/B18420_04_04.png)'
- en: 'Figure 4.4: Circuit with a Hadamard (H) gate added to a qubit'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：添加了Hadamard（H）门的量子比特电路
- en: The **Hadamard gate** (H gate) is a quantum gate that places the qubit in a
    superposition state, or, more specifically, a complex linear combination of the
    basis states, which means that when we measure the qubit, it will have an equal
    probability result of measuring a 0 or 1\. Or in other words, it would collapse
    to one of the basis state values of ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hadamard门**（H门）是一个量子门，它将量子比特置于叠加态，或者更具体地说，是基态的复线性组合，这意味着当我们测量量子比特时，它将以相等的概率测量到0或1。或者换句话说，它将塌缩到基态值之一，如![img/B18420_04_006.png](img/B18420_04_006.png)或![img/B18420_02_003.png]。'
- en: 'Mathematically, the superposition state is obtained with the application of
    the Hadamard gate, and its results are represented in the following two superposition
    equations, which, as you can see, depends on which of the two basis states, ![](img/B18420_04_006.png)
    or ![](img/B18420_04_007.png), it was in prior to applying the Hadamard gate.
    The first superposition equation ![](img/B18420_04_008.png) is as follows and
    originates from the ![](img/B18420_04_006.png) state, which is often referred
    to as the positive ![](img/B18420_04_010.png) superposition state:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，叠加状态是通过应用Hadamard门获得的，其结果表示在以下两个叠加方程中，正如你所看到的，这取决于在应用Hadamard门之前它处于哪个基态，![](img/B18420_04_006.png)或![](img/B18420_04_007.png)。第一个叠加方程![](img/B18420_04_008.png)如下，起源于![](img/B18420_04_006.png)状态，通常被称为正![](img/B18420_04_010.png)叠加状态：
- en: '![](img/B18420_04_011.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_04_011.png)'
- en: 'The second superposition equation ![](img/B18420_04_012.png), originating from
    the ![](img/B18420_02_003.png) state, is as follows, which is often referred to
    as the negative ![](img/B18420_04_014.png) superposition state:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个叠加方程![](img/B18420_04_012.png)，起源于![](img/B18420_02_003.png)状态，如下所示，通常被称为负![](img/B18420_04_014.png)叠加状态：
- en: '![](img/B18420_04_015.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_04_015.png)'
- en: Visually, on the Bloch sphere, this is equal to a π⁄2 rotation about the *X*
    and *Z* axes of the Bloch sphere. These rotations are Cartesian rotations, which
    rotate counterclockwise around the specified axis, in this case, the *X* and *Z*
    axes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bloch球上，这等于对Bloch球的*X*和*Z*轴进行π⁄2旋转。这些旋转是笛卡尔旋转，围绕指定的轴逆时针旋转，在这种情况下，是*X*和*Z*轴。
- en: 'Now, let’s get the state vector of our circuit, and see what the resulting
    quantum state will look like, and where the state vector lands on the Bloch sphere.
    In the following code, you will call the `Statevector` object and pass the quantum
    circuit into the `constructor` argument, the result of which will change the state
    of the qubit to a superposition state from the initial state, which you will see
    in the resulting Bloch sphere’s output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取电路的状态向量，并查看结果量子状态将是什么样子，以及状态向量在Bloch球上的位置。在下面的代码中，你将调用`Statevector`对象并将量子电路传递给`constructor`参数，这将改变qubit的状态，从初始状态变为叠加状态，你将在结果Bloch球输出中看到：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should now see the results plotted on the Bloch sphere in a superposition
    of ![](img/B18420_04_006.png) and ![](img/B18420_02_003.png), as illustrated in
    the following figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到结果在Bloch球上以![](img/B18420_04_006.png)和![](img/B18420_02_003.png)的叠加形式绘制出来，如图所示：
- en: '![Figure 4.5 - Superposition of a qubit after 90° rotation around the X and
    Z axes  ](img/B18420_04_05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 - X和Z轴90°旋转后的qubit叠加](img/B18420_04_05.png)'
- en: 'Figure 4.5: Superposition of a qubit after 90° rotation of the ![](img/B18420_04_006.png)
    basis state'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：90°旋转后的qubit的叠加状态
- en: As you can see in the preceding screenshot, this has placed the vector on the
    positive *X* axis, as described previously when adding an H gate from the ![](img/B18420_04_006.png)
    basis state. One thing to note is that visually, this could also have been done
    by rotating the *Y* axis by 90 degrees.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，这已经将向量放置在正*X*轴上，正如之前在从![](img/B18420_04_006.png)基态添加H门时描述的那样。需要注意的是，从视觉上看，这也可以通过将*Y*轴旋转90度来完成。
- en: 'Now, let’s clear the circuit by recreating the `QuantumCircuit` object with
    the same name. This time, we will initialize the qubit to the ![](img/B18420_02_003.png)
    state first and then apply a Hadamard gate to see what happens to the vector.
    Initialize the `qubit` to the ![](img/B18420_04_006.png) state and place it in
    a superposition. Clear the circuit and initialize the qubit to `1` before applying
    a Hadamard gate:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过重新创建具有相同名称的`QuantumCircuit`对象来清除电路。这次，我们将首先将qubit初始化为![](img/B18420_02_003.png)状态，然后应用Hadamard门来观察向量会发生什么。将`qubit`初始化为![](img/B18420_04_006.png)状态并将其置于叠加状态。在应用Hadamard门之前，清除电路并将qubit初始化为`1`：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should now see the following circuit; in this case, we have omitted the
    classical bit when constructing our quantum circuit, which is why you do not see
    the classical bit in the following figure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下电路；在这种情况下，我们在构建量子电路时省略了经典比特，这就是为什么你不会在下面的图中看到经典比特：
- en: '![Figure 4.6 - Applying an H gate superposition from an opposite base state  ](img/B18420_04_06.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 - 从相反基态应用H门叠加](img/B18420_04_06.png)'
- en: 'Figure 4.6: Applying an H gate superposition to the base state ![](img/B18420_02_003.png)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：对基态 ![](img/B18420_02_003.png) 应用H门叠加
- en: 'Now, let’s execute the circuit and plot the result on the Bloch sphere using
    the same code you used to execute the previous circuit:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们执行电路，并使用与执行先前电路相同的代码在布洛赫球上绘制结果：
- en: '![Figure 4.7 - Superposition of a qubit after 90° rotation around the X and
    Z axes from the  state ](img/B18420_04_07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 - 从状态进行90°绕X和Z轴旋转后的量子比特叠加](img/B18420_04_07.png)'
- en: 'Figure 4.7: Superposition of a qubit after 90° rotation around the X and Z
    axes from the ![](img/B18420_02_003.png) state'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：从 ![](img/B18420_02_003.png) 状态进行90°绕X和Z轴旋转后的量子比特叠加
- en: '*Do you see the difference between adding an H gate to a qubit in the ![](img/B18420_04_006.png)*
    *state (Figure 4.5) and adding it to a qubit in the* ![](img/B18420_02_003.png)
    *state in the preceding figure?*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出在 ![](img/B18420_04_006.png) *状态（图4.5）中向一个量子比特添加一个H门与在先前的图中向 ![](img/B18420_02_003.png)
    *状态中的量子比特添加它之间的区别吗？
- en: Of course, the difference is where it lands on the *X* axis! Because the vector
    falls onto the positive *X* axis when applying a Hadamard gate to the ![](img/B18420_04_006.png)
    state, this is commonly notated as ![](img/B18420_04_008.png). This logically
    means that the vector falls onto the negative *X* axis when applying a Hadamard
    gate to the ![](img/B18420_02_003.png) state. This is commonly notated as ![](img/B18420_04_012.png).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，区别在于它落在 *X* 轴上的位置！因为当对 ![](img/B18420_04_006.png) 状态应用哈达玛门时，向量落在正 *X* 轴上，这通常表示为
    ![](img/B18420_04_008.png)。从逻辑上讲，这意味着当对 ![](img/B18420_02_003.png) 状态应用哈达玛门时，向量落在负
    *X* 轴上。这通常表示为 ![](img/B18420_04_012.png)。
- en: 'Now, look at the right side of the superposition equations and pay close attention
    to the signs in between:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看叠加方程的右侧，并注意其中的符号：
- en: '![](img/B18420_04_011.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_04_011.png)'
- en: '![](img/B18420_04_015.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_04_015.png)'
- en: Notice that the signs match the direction of where the vector lands after the
    Hadamard gate is applied. From the ![](img/B18420_04_006.png) state, it moves
    toward the positive (+) direction of the *X* axis, and from the ![](img/B18420_02_003.png)
    state, it moves toward the negative (-) direction of the *X* axis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，符号与哈达玛门应用后向量落点的方向相匹配。从 ![](img/B18420_04_006.png) 状态，它移动到 *X* 轴的正方向（+），而从
    ![](img/B18420_02_003.png) 状态，它移动到 *X* 轴的负方向（-）。
- en: This difference is referred to as a phase difference between the two results.
    This will be very important later in this and subsequent chapters, as phase difference
    plays an important role in many quantum algorithms and blends itself into the
    topic of interference, as we will learn shortly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异被称为两个结果之间的相位差。这在本书的后续章节中将会非常重要，因为相位差在许多量子算法中扮演着重要角色，并且它将自身融入到我们很快将要学习的干涉主题中。
- en: One last thing that we will discuss before moving on is to now look back to
    our earlier discussion on probabilities. Now that we’ve learned what superposition
    looks like in a circuit and on a Bloch sphere, let’s execute and see what the
    probabilities are when we measure the qubit after it is in superposition. As you
    may recall from our first analogy of flipping or spinning a coin, we said that
    once the coin is spinning, it is in a superposition of heads or tails, or in this
    example, 0 or 1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们最后要讨论的一件事是现在回顾一下我们之前关于概率的讨论。现在我们已经学会了电路和布洛赫球上叠加看起来是什么样子，让我们执行并看看当我们测量处于叠加状态的量子比特时的概率是什么。如您从我们的第一次类比——抛硬币或旋转硬币——中回忆的那样，我们说过，一旦硬币开始旋转，它就处于正面或反面（或在这个例子中，0或1）的叠加状态。
- en: Once we observe the outcome, the result of the coin will be one or the other.
    However, classically, this is pseudorandom, as we learned. But in quantum computing,
    electron detection is truly random as there is no way to determine its outcome
    without disturbing it due to the **Heisenberg uncertainty principle**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们观察到了结果，硬币的结果将是其中一个。然而，在经典计算中，这是伪随机的，正如我们所学的。但在量子计算中，电子检测是真正的随机，因为没有方法在不干扰它的前提下确定其结果，这是由于**海森堡不确定性原理**。
- en: The **Heisenberg uncertainty principle**, introduced by Werner Heisenberg in
    1927, describes how it is not possible to predict the *momentum* of a particle
    from its initial conditions if the *position* is more precisely determined. The
    same is said for the reverse, where it is not possible to predict the position
    of a particle from its initial conditions if the momentum is more precisely determined.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**海森堡不确定性原理**，由Werner Heisenberg于1927年提出，描述了当位置更精确地确定时，不可能从初始条件预测粒子的动量。同样，对于反向情况，如果动量更精确地确定，则不可能从初始条件预测粒子的位置。'
- en: This is the same as measuring a qubit; we are, in essence, measuring it, and
    therefore forcing it to collapse into one of two basis states.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这与测量量子比特相同；本质上，我们正在测量它，因此迫使它折叠到两个基态之一。
- en: 'Then, measure the qubit after it is in superposition and recreate the circuit.
    Let’s start from the ![](img/B18420_04_006.png) state and apply a Hadamard gate,
    as we did earlier:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在量子比特处于叠加态后进行测量，并重新创建电路。让我们从 ![](img/B18420_04_006.png) 状态开始，并应用一个Hadamard门，就像我们之前做的那样：
- en: '[PRE4]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, using our helper function, let’s create a circuit that includes a measurement
    operator so that we can measure the qubit, which will collapse into one of two
    states, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用我们的辅助函数，让我们创建一个包含测量算子的电路，这样我们就可以测量量子比特，它将折叠到两种状态之一，如下所示：
- en: '[PRE5]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous code, we created a measurement circuit that includes a measurement
    operation that basically collapses the qubit from its current state to that of
    either 0 or 1\. The second line of the code then concatenates the first circuit
    `qc` and this new `measurement_circuit` together, creating a new circuit called
    `full_circuit` which will be drawn as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个包含测量操作的测量电路，该操作基本上将量子比特从其当前状态折叠到0或1。代码的第二行然后将第一个电路 `qc` 和这个新的
    `measurement_circuit` 连接起来，创建了一个新的电路，称为 `full_circuit`，其绘制如下：
- en: '![Figure 4.8 - Full circuit with rotation and measurement from qubit (q) to
    classic bit (c) ](img/B18420_04_08.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 - 从量子比特（q）到经典比特（c）的完整电路，包括旋转和测量](img/B18420_04_08.png)'
- en: 'Figure 4.8: Full circuit with rotation and measurement from qubit (q) to classic
    bit (c)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：从量子比特（q）到经典比特（c）的完整电路，包括旋转和测量
- en: The previous diagram illustrates our full circuit, which you can see now includes
    two new components, the first of which is the classic register below the quantum
    register. The second component is the measurement operator, which will extract
    the result of the qubit and pass it onto the classical bit. The result will collapse
    the state of the qubit to either 1 or 0.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示说明了我们的完整电路，你现在可以看到它包括两个新的组件，第一个是量子寄存器下面的经典寄存器。第二个组件是测量算子，它将提取量子比特的结果并将其传递给经典比特。结果将使量子比特的状态折叠到1或0。
- en: 'Now, let’s run this circuit to see what results we get back. We will add a
    few `shots` and see the results. `Shots` refer to running through the experiment
    a few times and aggregating its results. We’ll use our helper file to help us
    run this circuit:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个电路，看看我们得到什么结果。我们将添加一些 `shots` 并查看结果。`Shots` 指的是多次运行实验并汇总其结果。我们将使用我们的辅助文件来帮助我们运行这个电路：
- en: '[PRE6]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code will now use a different backend from our helper file, the
    `BasicSimulator` rather than the `Statevector`, which will allow us to obtain
    the measured results of the circuit. In this case, we will extract `counts`, which
    stores the number of times the measurement resulted in either a 0 or 1 out of
    `1024` `shots`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码现在将使用我们辅助文件中的不同后端，即 `BasicSimulator` 而不是 `Statevector`，这将使我们能够获得电路的测量结果。在这种情况下，我们将提取
    `counts`，它存储了在 `1024` 次射击中测量结果为0或1的次数。
- en: 'The result of the previous code is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果如下：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the results are almost 50%, which illustrates that you can have
    an equal probability of landing on either the 0 or 1 state for each shot!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，结果几乎为50%，这说明了对于每次射击，落在0或1状态上的概率是相等的！
- en: Note that your actual value results might be different than what was shown previously,
    but the probability should be close to 50%. Retry running the code a few times
    and play around with the number of `shots` to see if you get any differences.
    The limitation for `shots` can be found in the `max_shots` value for each simulator
    and quantum system’s properties.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你实际的结果可能与之前显示的不同，但概率应该接近50%。尝试多次运行代码，并调整 `shots` 的数量，看看是否能得到任何差异。`shots`
    的限制可以在每个模拟器和量子系统的 `max_shots` 值中找到。
- en: The reason why we run so many shots of a circuit is to get enough measurements
    to obtain accurate statistics of a measurement operation on a superposition state
    that is probabilistic. The noise in the system contributes to the deviation from
    a perfect statistic of 50/50 in the counts, because the near-term quantum devices
    used these days are not fault-tolerant yet. Fault-tolerant devices are those that
    have logical qubits, which can comprise one or more physical qubits, and are used
    to minimize errors so that operations complete as specified by the quantum circuits.
    They exhibit very low error rates and large quantum volumes, which we will cover
    in *Chapter 9*, *Optimizing and Visualizing Circuits*. Current near-term devices
    need to run multiple shots to provide your quantum algorithm with good probabilistic
    results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行电路多次的原因是为了获得足够的测量值，从而获得对叠加态上测量操作的准确统计。系统中的噪声导致计数中50/50的完美统计出现偏差，因为目前使用的近端量子设备还不是容错的。容错设备是具有逻辑量子比特的设备，可以由一个或多个物理量子比特组成，用于最小化错误，以便操作按量子电路指定的方式完成。它们表现出非常低的错误率和大的量子体积，我们将在*第9章*，*优化和可视化电路*中介绍。当前的近端设备需要运行多次以提供良好的概率结果。
- en: Building a coin-flipping experiment
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建抛硬币实验
- en: If you’ve ever taken a course in probability and statistics, you might have
    seen the coin flip example. In this example, you are given an unbiased coin to
    flip multiple times and track the results of each flip (experiment) as either
    heads or tails. What this experiment illustrates is that with an unbiased coin
    and enough samples, you will see that the probability of either heads or tails
    starts to converge to about 50%.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经上过概率和统计学课程，你可能见过抛硬币的例子。在这个例子中，你被给了一个公正的硬币进行多次抛掷，并跟踪每次抛掷（实验）的结果，无论是正面还是反面。这个实验说明的是，使用公正的硬币和足够的样本，你会看到正面或反面的概率开始收敛到大约50%。
- en: This means that, after running enough experiments, the number of times the coin
    lands on heads becomes very closely equal to the number of times that it lands
    on tails.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在运行足够多的实验后，硬币落在正面和反面的次数变得非常接近。
- en: 'Let’s give this a try in the IBM Quantum Composer, to better visualize what’s
    happening (note, backend systems might not be available or the same, so use any
    backend you see available. Like most of the backends throughout this book, we’ll
    be using those that were available at the time of writing this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在IBM量子作曲家上试一试，以更好地可视化正在发生的事情（注意，后端系统可能不可用或不同，所以使用你看到的任何后端。像本书中的大多数后端一样，我们将使用撰写本文时可用的一些后端：
- en: Open the Composer Editor and create a new blank circuit.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开作曲家编辑器并创建一个新的空白电路。
- en: For simplicity, let’s remove all except one qubit. This will simplify our results.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们移除除了一个量子比特之外的所有量子比特。这将简化我们的结果。
- en: Click and drag the Hadamard gate onto the first qubit.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动Hadamard门到第一个量子比特上。
- en: 'Click and drag the measurement operation onto the first qubit after the H gate.
    This will indicate that you wish the value of this qubit to be measured, and assign
    its resulting value of either 1 or 0 to the corresponding classic bit; in this
    case, the bit at position 0, as shown in the following screenshot:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在H门之后点击并拖动测量操作到第一个量子比特上。这将表明你希望测量这个量子比特的值，并将它的结果值（1或0）分配给相应的经典比特；在这种情况下，位置为0的比特，如下面的截图所示：
- en: '![A picture containing schematic  Description automatically generated](img/B18420_04_09.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![包含电路图的图片 自动生成描述](img/B18420_04_09.png)'
- en: 'Figure 4.9: Coin flip experiment'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：抛硬币实验
- en: Name your circuit `Coin flip` and save it.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的电路命名为`Coin flip`并保存。
- en: Click **Setup and run** to expand the options.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置和运行**以展开选项。
- en: Select a backend device and set the run count to `1024`. This will run the experiment
    1,024 times. Note at the time of this writing there are some changes occurring
    which might change how to run a circuit using Composer. If so, please refer to
    the instructions on the platform for any changes.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个后端设备，并将运行次数设置为`1024`。这将运行实验1,024次。注意，在撰写本文时，有一些变化正在进行，可能会改变使用Composer运行电路的方式。如果发生这种情况，请参阅平台上的说明以了解任何更改。
- en: Click **Run on ‘device selected’**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**在‘所选设备’上运行**。
- en: Once completed, click on the completed experiment in the **Composer jobs** list.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**作曲家作业**列表中的完成实验。
- en: 'The measurement outcome results will now show two different states. Remember
    that the Computational basis states are represented along the *X* axis, which
    you can see is either a 0 or 1:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测量结果将现在显示两种不同的状态。记住，计算基态表示在 *X* 轴上，你可以看到它是0或1：
- en: '![Bar chart  Description automatically generated with medium confidence](img/B18420_04_10.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![条形图  描述自动生成，置信度中等](img/B18420_04_10.png)'
- en: 'Figure 4.10: Coin flip results'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：抛硬币结果
- en: Another thing to note is the `Frequency` (the *X* axis) of each of the two states.
    This will differ each time you run the experiment as it represents how many times
    the outcome was either 0 or 1 for each shot.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，每个状态的**频率**（*X* 轴）。每次运行实验时，这都会有所不同，因为它代表每次射击结果为0或1的次数。
- en: What you will notice from the preceding screenshot is that the results will
    fall close to 50% each time you run the experiment. Rerun the experiment a few
    more times and examine the results for yourself. The use of the Hadamard gate
    allows you to place a qubit on a circuit into a linear combination of the two
    basis states, 0 and 1\. As mentioned earlier, this helps to leverage superposition.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图你可以注意到，每次运行实验，结果都会接近50%。再运行几次实验，亲自检查结果。使用Hadamard门可以使你将一个量子位放置在电路中，使其处于两个基态0和1的线性组合中。如前所述，这有助于利用叠加。
- en: Understanding entanglement
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解纠缠
- en: The second quantum computing principle used by quantum computers is **entanglement**.
    By entangling two or more qubits, we are, in essence, linking the value of one
    qubit and synchronizing it with one or more other qubits. By synchronizing it,
    we mean that if we measure (observe) the value of one of the entangled qubits,
    then we can be sure that the other qubit will have the same value, whether we
    measure it at the same time or sometime later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机使用的第二个量子计算原理是**纠缠**。通过纠缠两个或更多量子位，我们本质上是在将一个量子位的值与一个或多个其他量子位同步。通过同步，我们指的是，如果我们测量（观察）纠缠量子位中的一个的值，那么我们可以确信另一个量子位将具有相同的值，无论我们是在同一时间测量还是稍后测量。
- en: '**Entanglement** is probably one of the most interesting of the three quantum
    computing principles. This is mainly because it still baffles physicists to this
    day, with many taking different philosophical sides in the discussion. I won’t
    bore you with the details, but I will aim to provide you with enough information
    for you to understand what entanglement is, but not to have a way to prove it
    to create quantum algorithms and applications. Yes, it sounds confusing, but believe
    me, the devil is in the detail and there just isn’t enough space for us to formulate
    a comprehensive answer to how entanglement works. But enough of that—let’s get
    to work!'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**纠缠**可能是三个量子计算原理中最有趣的一个。这主要是因为它至今仍然让物理学家感到困惑，许多人在讨论中采取了不同的哲学立场。我不会让你感到厌烦，但我会尽力提供足够的信息，让你理解纠缠是什么，但不会提供一种证明纠缠如何工作以创建量子算法和应用的方法。是的，听起来很复杂，但请相信我，魔鬼藏在细节中，我们根本没有足够的空间来制定一个全面的答案来解释纠缠是如何工作的。但这些都足够了——让我们开始工作吧！'
- en: Quantum entanglement, or just entanglement, is simply defined as a quantum mechanical
    phenomenon that occurs when two or more particles have correlated states. What
    this, in essence, means is that if you have two particles or, for our purposes,
    qubits, that are entangled, this means that when we measure one qubit, we can
    determine the result of the other qubit based on the measurement of the first
    qubit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 量子纠缠，或简称纠缠，简单定义为当两个或更多粒子具有相关状态时发生的量子力学现象。本质上，这意味着如果你有两个粒子，或者在我们的情况下，量子位，它们是纠缠的，这意味着当我们测量一个量子位时，我们可以根据第一个量子位的测量结果确定另一个量子位的测量结果。
- en: As you may recall from our previous example, if we put a qubit in a superposition
    and we measure that qubit, we have a 50/50 split as to whether that qubit would
    collapse to either of two states, ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，在我们的前一个例子中，如果我们把一个量子位放在叠加态，并测量这个量子位，那么这个量子位会以50/50的概率坍缩到两个状态之一，![](img/B18420_04_006.png)
    或 ![](img/B18420_02_003.png)。
- en: Now, if that same qubit were entangled with another qubit and we were to measure
    one of the qubits, that qubit will be either ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
    However, if we were to measure the second qubit, either at the exact same time
    or sometime later, it too will have the same value as the first qubit we measured!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果同样的量子比特与另一个量子比特纠缠在一起，并且我们测量其中一个量子比特，那么这个量子比特将会是 ![](img/B18420_04_006.png)
    或 ![](img/B18420_02_003.png)。然而，如果我们测量第二个量子比特，无论是精确地在同一时间还是稍后，它也将具有与第一个我们测量的量子比特相同的值！
- en: One thing to note is that this can also be the opposite if you so choose it
    to be. For example, let’s say you set the second qubit to the ![](img/B18420_04_039.png)
    state prior to entangling. You have now entangled opposite states. These combinations
    of entangled states will be covered in more detail when we discuss quantum algorithms
    in *Chapter 12, Applying Quantum Algorithms*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，如果你选择的话，这也可以是相反的情况。例如，假设你在纠缠之前将第二个量子比特设置为 ![](img/B18420_04_039.png)
    状态。你现在已经纠缠了相反的状态。这些纠缠状态的组合将在我们讨论第12章“应用量子算法”时更详细地介绍。
- en: You’re probably thinking, *how can this be?* If we take two qubits and place
    them in superposition and we measure them separately, we will correctly see that
    each qubit will collapse to a value of 1 or 0, where each time we measure the
    qubits individually, it may not collapse to the same value at the same time. This
    means that if we run the experiment one shot at a time, we would see that, sometimes,
    the first qubit will measure 0, while the second qubit could measure 0 or 1.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，“这怎么可能呢？”如果我们取两个量子比特并将它们置于叠加态，然后分别测量它们，我们会正确地看到每个量子比特都会塌缩到1或0的值，每次我们单独测量量子比特时，它们可能不会同时塌缩到相同的值。这意味着如果我们一次运行一个实验，我们有时会看到第一个量子比特测量为0，而第二个量子比特可能测量为0或1。
- en: Both are separate and do not know the value of each other either before, during,
    or after measurement. However, if we were to entangle the two qubits and repeat
    the same experiment, we would see that the qubits will measure the exact same
    values each time! Each will result in one of four different outcomes of either
    00, 11, 01, or 10\. Each of these four is based on what is known as the Bell states,
    which will be covered later in the chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都是独立的，并且在测量之前、测量过程中或测量之后都不知道彼此的值。然而，如果我们纠缠这两个量子比特并重复相同的实验，我们会看到量子比特每次都会测量出完全相同的值！每个结果都将导致四种不同的结果之一：00、11、01或10。这四种结果中的每一种都是基于所谓的贝尔态，这将在本章后面介绍。
- en: '*Impossible*, you say? Well, it’s a good thing for us that we now have a quantum
    computer that we can run and try this out!'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你会说，“这不可能？”好吧，对我们来说，现在有一个量子计算机可以运行并尝试这个实验是好事！
- en: Implementing the behavior of entangled qubits
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现纠缠量子比特的行为
- en: 'In the following code, we will see that when qubits are not entangled, their
    results are such that we cannot infer what the result of one qubit would be based
    on the result of the other qubit. Since we are measuring two qubits, our results
    will be listed as two-bit values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将看到当量子比特没有纠缠时，它们的结果是这样的，我们不能根据另一个量子比特的结果推断出一个量子比特的结果。由于我们正在测量两个量子比特，我们的结果将以两位值的形式列出：
- en: 'First, we’ll create a new circuit with two qubits, place them each in superposition,
    and measure them:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的电路，包含两个量子比特，将它们各自置于叠加态，并测量它们：
- en: '[PRE8]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we created a quantum circuit with two qubits, added an
    H gate to each of the qubits so that we can place each qubit into a superposition
    state, and finally, added a measurement from each qubit to its respective bit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个包含两个量子比特的量子电路，为每个量子比特添加了一个H门，以便我们可以将每个量子比特置于叠加态，最后，为每个量子比特添加了对其相应比特的测量。
- en: 'The result from the previous code should display the following circuit, where
    we can see that each qubit has an H gate that’s measured to its respective classical
    bit register; that is, qubit 0 to bit 0 and qubit 1 to bit 1:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果应该显示以下电路，其中我们可以看到每个量子比特都有一个与其相应的经典比特寄存器进行测量的H门；也就是说，量子比特0对应比特0，量子比特1对应比特1：
- en: '![Figure 4.9 - Two qubits in superposition and measured to their respective
    classic bits  ](img/B18420_04_11.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 - 两个叠加的量子比特及其相应的经典比特 ](img/B18420_04_11.png)'
- en: 'Figure 4.11: Two qubits in superposition and measured to their respective classic
    bits'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：两个叠加的量子比特及其相应的经典比特
- en: 'Then, we execute the circuit and display the results:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们执行电路并显示结果：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code, we created the backend to run on the simulator with `1000`
    `shots` and plot the results in a histogram to review them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们创建了一个后端，以`1000`次`射击`运行在模拟器上，并将结果绘制在直方图中以供审查。
- en: Note from the following results that the outcomes are very random from each
    qubit, which is what we expected. One thing I would also like to mention regarding
    notation is the ordering of the qubits. When written, the order of the qubits
    is a little different than the bit order. In quantum notation, the first qubit
    is also listed on the left-hand side, while subsequent qubits are added toward
    the right-hand side. In binary notation, however, the first bit is on the right-hand
    side, while subsequent bits are added toward the left-hand side.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下结果，每个量子位的输出都非常随机，这正是我们所期望的。我还想就符号顺序提一点，即量子位的顺序。在书写时，量子位的顺序与位顺序略有不同。在量子符号中，第一个量子位也列在左侧，而后续的量子位则添加到右侧。然而，在二进制表示法中，第一个位位于右侧，而后续的位则添加到左侧。
- en: For example, if we want to represent the 3-qubit value of the number 5, we would
    do so using ![](img/B18420_04_040.png), which is the same as the bit representation
    of the same number. However, the qubit order here is different as the first qubit
    is listed in the left position (q[0]), the second qubit (q[1]) is listed in the
    middle position, and the last qubit (q[2]) is listed in the right position.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想表示数字5的3量子位值，我们会使用![](img/B18420_04_040.png)来表示，这与相同数字的位表示相同。然而，这里的量子位顺序是不同的，因为第一个量子位位于左侧位置（q[0]），第二个量子位（q[1]）位于中间位置，最后一个量子位（q[2]）位于右侧位置。
- en: On the other hand, in binary notation, the first bit (b[0]) is in the right
    position and moves up in order to the left. When measuring, we link the results
    from the qubit to the bit (as shown in the preceding screenshot), which correctly
    maps the results of each qubit to its respective binary position so that our results
    are in the expected bit order.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在二进制表示法中，第一个位（b[0]）位于右侧，并按顺序向上移动到左侧。在测量时，我们将量子位的结果链接到位（如前一个截图所示），这正确地将每个量子位的结果映射到其相应的二进制位置，以便我们的结果按照预期的位顺序排列。
- en: 'The plotted histogram is shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制的直方图如下截图所示：
- en: '![Figure 4.10 - Random results of all combinations from both qubits ](img/B18420_04_12.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 - 两个量子位的所有组合的随机结果](img/B18420_04_12.png)'
- en: 'Figure 4.12: Random results of all combinations from both qubits'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：两个量子位的所有组合的随机结果
- en: In the previous screenshot, each qubit has collapsed to a state of either 0
    or 1, so since there are two qubits, we should expect to see all four random results,
    which are **00**, **01**, **10**, and **11**. Your probability results might differ
    a bit, but overall, they should all be close to 25% probability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图里，每个量子位都坍缩到了0或1的状态，因此既然有两个量子位，我们应该期望看到所有四种随机结果，即**00**、**01**、**10**和**11**。你的概率结果可能会有所不同，但总体上，它们都应该接近25%的概率。
- en: This is expected, so let’s entangle the two qubits and see what happens then.
    For this, we will entangle the two qubits and rerun the experiment.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是预期的，所以让我们纠缠这两个量子位，看看会发生什么。为此，我们将纠缠这两个量子位并重新运行实验。
- en: Let’s entangle the two qubits by adding a multi-qubit gate called a **Controlled**
    **NOT** (**CNOT**) gate. Let me explain what this gate is before we include it
    in our circuit.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个多量子位门，称为**控制** **非**（**CNOT**）门来纠缠这两个量子位。在我们将其包含到电路中之前，让我先解释一下这个门是什么。
- en: The CNOT gate is a multi-qubit gate that operates on one qubit based on the
    value of another. What this means is that the qubit gate has two connecting points—one
    called **control** and another called **target**. The target is generally an operator,
    such as a **NOT** (*X*) gate, which would flip the qubit from 0 to 1, or vice
    versa.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CNOT门是一个多量子位门，它根据另一个量子位的值来操作一个量子位。这意味着量子位门有两个连接点——一个称为**控制**，另一个称为**目标**。目标通常是一个算子，例如**非**（*X*）门，它会将量子位从0翻转到1，或者相反。
- en: However, the target operator can also be almost any operation, such as an H
    gate, a Y gate (which flips 180° around the *Y* axis), and so on. It could even
    be another control, but we will get into those fancy gates in *Chapter 6*, *Understanding
    Quantum Logic Gates*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目标算子也可以是几乎任何操作，例如H门、Y门（它在*Y*轴周围翻转180°）等等。甚至还可以是另一个控制，但我们将会在*第6章*，*理解量子逻辑门*中详细介绍这些花哨的门。
- en: The CNOT gate acts in such a manner that when the qubit tied to the control
    is set to 0, the value of the target qubit does not change, meaning the target
    operator will not be enabled. However, if the value of the control qubit is 1,
    this will trigger the target operator. This would, therefore, in the case of a
    CNOT gate, enable a NOT operation on the target qubit, causing it to flip 180°
    around the *X* axis from its current position. This is illustrated in *Figure
    4.13*, where qubit 0 is the control and qubit 1 is the target; in this case, the
    target is a NOT gate, hence making this a CNOT gate.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: CNOT门以这种方式起作用，当连接到控制的量子比特设置为0时，目标量子比特的值不会改变，这意味着目标操作将不会被启用。然而，如果控制量子比特的值为1，这将触发目标操作。因此，在CNOT门的情况下，这将启用目标量子比特上的NOT操作，使其围绕*X*轴从当前位置翻转180°。这如图*图4.13*所示，其中量子比特0是控制比特，量子比特1是目标比特；在这种情况下，目标是NOT门，因此这是一个CNOT门。
- en: 'The following logic table represents the control and target value updates based
    on the value of the control for a CNOT gate, as well as the states before and
    after the CNOT gate:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的逻辑表表示基于CNOT门控制比特的值，控制比特和目标比特值更新的状态，以及CNOT门前后状态：
- en: '![Table 4.1 - Two qubit CNOT logic table ](img/B18420_04_13.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![表4.1 - 两个量子比特CNOT逻辑表](img/B18420_04_13.png)'
- en: 'Table 4.1: Two-qubit CNOT logic table'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1：两个量子比特CNOT逻辑表
- en: 'Now that we can see how the CNOT gate works on two qubits, we will update our
    circuit so that we can entangle the qubits together. In the following code, we
    will create a circuit with 2 qubits where we will apply a Hadamard gate to the
    first qubit and then entangle the first qubit with the second qubit using a CNOT
    gate:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了CNOT门在两个量子比特上的工作方式，我们将更新我们的电路，以便我们可以将量子比特纠缠在一起。在下面的代码中，我们将创建一个包含2个量子比特的电路，我们将对第一个量子比特应用Hadamard门，然后使用CNOT门将第一个量子比特与第二个量子比特纠缠起来：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The resulting diagram of the circuit should look as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 电路的结果图应该看起来如下所示：
- en: '![Figure 4.11 - Entanglement of two qubits ](img/B18420_04_14.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 - 两个量子比特的纠缠](img/B18420_04_14.png)'
- en: 'Figure 4.13: Entanglement of two qubits'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：两个量子比特的纠缠
- en: The previous screenshot shows you that, this time, we are only placing a Hadamard
    gate on the first qubit and leaving the second qubit to be operated on only by
    the CNOT gate. Since qubit 1 (q[1]) is set as the target, it will be dependent
    on the control qubit, which, in this case, is qubit 0 (q[0]).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示，这次我们只在第一个量子比特上放置一个Hadamard门，而第二个量子比特只由CNOT门操作。由于量子比特1（q[1]）被设置为目标，它将依赖于控制量子比特，在这种情况下，是量子比特0（q[0]）。
- en: 'Now, we will run the experiment and plot the results. This is similar to the
    previous experiments we completed, where we will execute the circuit, extract
    the result counts, and plot them on a histogram to visualize the results:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将运行实验并绘制结果。这与我们之前完成的实验类似，我们将执行电路，提取结果计数，并将它们绘制在直方图上以可视化结果：
- en: '[PRE11]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The results shown in the following screenshot show two quantum computing principles—the
    superposition of the qubits, 0 and 1, and the entanglement—where both qubits’
    (control and target) results are strongly correlated as either **00** or **11**:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示的结果展示了两个量子计算原理——量子比特0和1的叠加，以及纠缠——其中两个量子比特（控制比特和目标比特）的结果强烈相关，要么是**00**，要么是**11**：
- en: '![Figure 4.12 - Results of two entangled qubits  ](img/B18420_04_15.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 - 两个纠缠量子比特的结果](img/B18420_04_15.png)'
- en: 'Figure 4.14: Results of two entangled qubits'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：两个纠缠量子比特的结果
- en: Let’s extend our coin-flipping example by adding another coin and entangling
    them together so that when we run our experiment, we can determine the value of
    one coin without having to measure the other.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加另一枚硬币并将它们纠缠在一起来扩展我们的抛硬币示例，这样当我们运行实验时，我们可以确定一枚硬币的值，而无需测量另一枚。
- en: Entangling two coins together
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将两个硬币纠缠在一起
- en: In the same way as our previous experiment, each qubit will represent a coin.
    In order to do this, we will use a CNOTgate, which connects two qubits where one
    is the source and the other the target.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的实验一样，每个量子比特将代表一枚硬币。为了做到这一点，我们将使用CNOT门，它连接两个量子比特，其中一个作为源，另一个作为目标。
- en: 'Let’s try entangling our coins (qubits) to see how this works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将我们的硬币（量子比特）纠缠起来，看看这是如何工作的：
- en: Open the Composer and create a new blank circuit with 2 qubits. As a reminder,
    you can increase or decrease the number of qubits by selecting a qubit and clicking
    on either the + or trash icon to add or remove a qubit from the circuit, respectively.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Composer 并创建一个新的空白电路，包含 2 个量子位。提醒一下，你可以通过选择量子位并点击 + 或垃圾桶图标来增加或减少量子位的数量，分别添加或删除量子位。
- en: Click and drag a Hadamard gate onto the first qubit, q[0].
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动一个 Hadamard 门到第一个量子位，q[0]。
- en: Click and drag the CNOT gate (*round white gate with crosshairs on blue background*)
    onto the first qubit, q[1]. This will assign the control qubit to the first qubit.
    When selecting the CNOT gate, the first qubit you drop it on will be set as the
    control. Visually, the source control of the CNOT gate is a solid dot on the qubit
    to which the gate was dragged on to (see *Figure 4.15*).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动 CNOT 门（*蓝色背景上的白色圆门，带有交叉线*）到第一个量子位，q[1]。这将控制量子位分配给第一个量子位。在选择 CNOT 门时，你放置它的第一个量子位将被设置为控制位。从视觉上看，CNOT
    门的源控制是一个实心点，位于被拖动门到的量子位上（参见 *图 4.15*）。
- en: By default, the target will set itself to the next qubit. In this case, it will
    drop to qubit 2\. Visually, the target for a CNOT is a large dot with a cross
    in the middle, made to resemble a target.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，目标会自动设置为下一个量子位。在这种情况下，它将降至量子位 2。从视觉上看，CNOT 的目标是中间带有十字的大型圆点，设计得像靶子。
- en: 'Click and drag a measurement operator onto each of the two first qubits as
    shown in the following screenshot:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动一个测量算子到两个第一个量子位，如下截图所示：
- en: '![Diagram  Description automatically generated with medium confidence](img/B18420_04_16.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成，置信度中等](img/B18420_04_16.png)'
- en: 'Figure 4.15: Entangled qubit circuit representing entangled coins'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：表示纠缠硬币的纠缠量子位电路
- en: Name and save your experiment as `Entangled coins`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的实验命名为 `Entangled coins` 并保存。
- en: Click **Setup and run** on the circuit to launch the **Setup and run** dialog.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在电路中点击 **Setup and run** 以启动 **Setup and run** 对话框。
- en: Select any device from the backend selection as the backend device and select
    the `shots` value to `1024`. This will run the experiment 1,024 times, which is
    the default value that you can change if need be.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从后端选择中选取任何设备作为后端设备，并将 `shots` 值设置为 `1024`。这将运行实验 1,024 次，这是默认值，如果需要可以更改。
- en: Click **Run on** and select whichever device you selected in the previous step.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Run on** 并选择你在上一步中选择的设备。
- en: Once completed, click the `Entangled coins` experiment from the `Completed jobs`
    list.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，从 `Completed jobs` 列表中点击 `Entangled coins` 实验项目。
- en: 'Now let’s review the results and see what happens when we entangle two qubits:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾一下结果，看看当我们纠缠两个量子位时会发生什么：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_04_17.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图表，柱状图 描述自动生成](img/B18420_04_17.png)'
- en: 'Figure 4.16: Entangled coins results'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：纠缠硬币的结果
- en: As you can see in the preceding screenshot, the results still have two states,
    as they did in the previous experiment. However, one thing to observe here is
    the results of the two qubits. Note that the state of both qubits is either 00
    or 11.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，结果仍然有两个状态，就像上一个实验中一样。然而，这里要注意的是两个量子位的结果。请注意，两个量子位的状态要么是 00，要么是 11。
- en: What makes this experiment interesting is when we flipped one coin in the previous
    experiment, you saw that the results were 50% (0 or 1). However, now we are running
    the same experiment, but we are entangling another coin. In effect, this results
    in both coins becoming entangled together and thus their states will always be
    the same as each other. This means that if we flip both coins and we observe one
    of the coin values, then we know that the other entangled coin will be the same
    value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个实验变得有趣的是，当我们翻转上一个实验中的一个硬币时，你看到结果是 50%（0 或 1）。然而，现在我们正在运行相同的实验，但我们正在纠缠另一个硬币。实际上，这导致两个硬币都纠缠在一起，因此它们的状态将始终相同。这意味着如果我们翻转两个硬币并观察其中一个硬币的值，那么我们知道另一个纠缠硬币的值将相同。
- en: Now that you are familiar with superposition and entanglement, let’s move on
    to the last quantum computing principle, which is interference.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了叠加和纠缠，让我们继续到最后一个量子计算原理，即干涉。
- en: Understanding interference
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解干涉
- en: One of the benefits of quantum computing is its ability to interleave these
    principles in such a way that usually, while explaining one, you can very easily
    describe the other. We did this earlier in this chapter with respect to interference.
    Let’s review and see where we have come across this phenomenon and its usage so
    far.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的一个好处是它能够以这种方式交织这些原理，通常在解释一个原理的同时，你能够非常容易地描述另一个原理。我们在本章 earlier 部分已经用关于干涉的例子做了这样的说明。现在让我们回顾一下，看看我们迄今为止在哪里遇到过这种现象及其应用。
- en: First, recall that, at the beginning of this chapter, we described the double-slit
    experiment. There, we discussed how an electron can act as both a wave and a particle.
    When acting like a wave, we saw that the experiment illustrated how the electrons
    traveled and landed at certain spots on the observation screen. The pattern that
    it displayed was generally one that we recognize from classic physics as wave
    interference.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回想一下，在本章的开头，我们描述了双缝实验。在那里，我们讨论了电子如何同时作为波和粒子存在。当它像波一样行动时，我们看到实验展示了电子如何移动并在观察屏幕上的特定位置着陆。它显示的图案通常是我们在经典物理学中认识到的波干涉图案。
- en: The pattern had probabilistic results along the backboard, as shown in the observing
    screen in *Figure 4.2*, where the center of the screen has the highest number
    of electrons and the blank areas along both sides had the least to none. This
    is due to the two types of interference of the particle waves, namely, **constructive**
    and **destructive**. Constructive interference occurs when the peaks of two waves
    are summed up where the resulting amplitude is equal to the total positive sum
    of the two individual waves.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模式在篮板上显示出概率性结果，如图 *图4.2* 中的观察屏幕所示，屏幕中心有最多的电子，而两侧的空白区域电子最少甚至没有。这是由于粒子波的两类干涉，即**建设性**和**破坏性**。当两个波的峰值相加时，结果振幅等于两个单独波的总体正和时，发生建设性干涉。
- en: Destructive interference occurs similarly to constructive interference except
    that the amplitudes of the waves are opposite in that when summing them together,
    the two waves cancel each other out.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性干涉与建设性干涉发生的方式相似，只是波的振幅是相反的，在将它们相加时，两个波会相互抵消。
- en: 'The following diagram illustrates the constructive and destructive wave interference
    of two waves when they are added together:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了当两个波叠加时，它们的建设性和破坏性波干涉：
- en: '![Chart  Description automatically generated](img/B18420_04_18.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B18420_04_18.png)'
- en: 'Figure 4.17: Constructive (left) and destructive (right) wave interferences
    (image source: https://commons.wikimedia.org/wiki/File:Interference_of_two_waves.svg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：建设性（左）和破坏性（右）的波干涉（图片来源：https://commons.wikimedia.org/wiki/File:Interference_of_two_waves.svg）
- en: The preceding diagram illustrates how two waves interfere with each other constructively
    and destructively. The two waves toward the bottom of the diagram represent the
    individual amplitudes of each wave, while the top line represents the added amplitude
    values, which represent the result of the interference between the two waves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示说明了两个波如何以建设性和破坏性的方式相互干涉。图示底部的两个波代表每个波的单独振幅，而顶部的一行代表叠加的振幅值，这些值代表了两个波之间干涉的结果。
- en: Now that you understand the difference between constructive and destructive
    interference, *how can we apply this to what we’ve learned so far?* Well, if you
    recall, earlier, when we placed a qubit in superposition, we had two distinct
    results.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了建设性和破坏性干涉之间的区别，*我们如何将这一知识应用到我们迄今为止所学的内容中呢？* 好吧，如果你还记得，之前当我们将量子比特置于叠加态时，我们得到了两个不同的结果。
- en: One was from the basis state ![](img/B18420_04_006.png), while the other was
    from the basis state ![](img/B18420_02_003.png). Do you remember when we started
    at either of these two qubit basis states, where on the *X* axis of the qubit
    the Hadamard landed? From ![](img/B18420_04_006.png), it would land on the positive
    side of the *X* axis, but if we placed the qubit into superposition starting from
    the ![](img/B18420_02_003.png) state, it would land on the negative *X* axis.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个是从基态 ![](img/B18420_04_006.png) 出发，而另一个是从基态 ![](img/B18420_02_003.png) 出发。你还记得我们最初是从这两个量子基态之一开始的吗？在量子比特的
    *X* 轴上，Hadamard 变换会落在哪个位置？从 ![](img/B18420_04_006.png) 出发，它会落在 *X* 轴的正侧，但如果我们从
    ![](img/B18420_02_003.png) 状态开始将量子比特置于叠加态，它就会落在负 *X* 轴上。
- en: Having the ability to place the qubit state vector on either the positive or
    negative *X* axis provides us with a way to place the qubit in either a positive
    or negative state. Very similar to the waves in the preceding diagram, which have
    positive (peaks) and negative (troughs) amplitudes, qubits can also represent
    similar states. Let’s simplify this by re-introducing the two Dirac notation values,
    ![](img/B18420_04_008.png), and ![](img/B18420_04_012.png), where the ![](img/B18420_04_008.png)
    state represents the state vector on the positive *X* axis, and the ![](img/B18420_04_012.png)
    state represents the state vector on the negative *X* axis.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将量子比特状态矢量放置在正或负 *X* 轴上，为我们提供了将量子比特放置在正或负状态的方法。这与前一个图中展示的波非常相似，这些波具有正（峰值）和负（谷值）振幅，量子比特也可以表示类似的状态。让我们通过重新引入两个狄拉克符号值，![](img/B18420_04_008.png)
    和 ![](img/B18420_04_012.png)，来简化这一点，其中 ![](img/B18420_04_008.png) 状态代表正 *X* 轴上的状态矢量，而
    ![](img/B18420_04_012.png) 状态代表负 *X* 轴上的状态矢量。
- en: These new vector definitions, which represent the vector state of a qubit in
    superposition, will be used by some of the algorithms as a technique to identify
    certain values and react to them using interference—techniques such as **amplitude
    estimation** and search algorithms such as **Grover’s** **algorithm**.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的矢量定义，代表叠加态中一个量子比特的矢量状态，将被某些算法用作识别特定值并使用干涉来对其做出反应的技术，例如**振幅估计**和搜索算法如**Grover算法**。
- en: In this section, we reviewed the quantum computing principle of interference.
    This, along with the other two principles, superposition and entanglement, will
    come in handy as you learn about how these principles are used in quantum algorithms
    in ways that provide potential speed up over classical algorithms. To do so, we
    will review an example that we will use throughout this book, to understand the
    very foundation of all quantum algorithms, the **Bell states**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了量子计算中的干涉原理。随着你了解这些原理如何在量子算法中提供潜在的速度提升，这些原理（叠加、纠缠和干涉）将非常有用。为了做到这一点，我们将回顾一个我们将贯穿整本书的例子，以了解所有量子算法的坚实基础，即**贝尔态**。
- en: Exploring the Bell states
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索贝尔态
- en: For most of the examples in this book, you will notice that we reuse a simple
    two-qubit quantum circuit to run many of our experiments. This circuit contains
    two gates, a single-qubit gate, and a multi-qubit gate, a Hadamard and CNOT, respectively.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大部分例子中，你会发现我们重复使用一个简单的双量子比特量子电路来运行许多实验。这个电路包含两个门，一个单量子比特门和一个多量子比特门，分别是Hadamard和CNOT。
- en: The reason for choosing this was not random. In fact, this circuit has a name,
    the Bell state. The Bell state, which was originally described in a theoretical
    paper by John Bell in 1964, describes how there are four maximally entangled quantum
    states between two qubits that are in a superposition state. These four states
    are commonly referred to as the **Bell states**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个的原因并非随机。事实上，这个电路有一个名字，贝尔态。贝尔态最初由约翰·贝尔在1964年发表的一篇理论论文中描述，描述了两个处于叠加态的量子比特之间存在四种最大纠缠量子状态。这四种状态通常被称为**贝尔态**。
- en: At this point, you may be wondering why this is so important. Well, if we can
    prepare qubits to a particular state, in this case, the maximally entangled state,
    this can help streamline the creation of various quantum circuits and algorithms.
    To learn more about this, let’s first prepare the four Bell states, and perhaps,
    along the way, you might see its importance and understand the significance to
    some use cases such as quantum teleportation or super dense coding.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道这为什么如此重要。好吧，如果我们能将量子比特准备到特定状态，在这种情况下，最大纠缠状态，这有助于简化各种量子电路和算法的创建。为了了解更多关于这方面的信息，让我们首先准备四个贝尔态，也许在这个过程中，你可能会看到其重要性，并理解其在量子隐形传态或超密集编码等用例中的重要性。
- en: Preparing the Bell states
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备贝尔态
- en: We’ll begin by first preparing the Bell state that we will use throughout this
    book.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先准备我们将贯穿整本书使用的贝尔态。
- en: 'We’ll label each of these states as we create them, this first one being labeled
    as ![](img/B18420_04_049.png). Preparing the Bell state entails three simple steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在创建每个状态时对其进行标记，这个第一个状态被标记为 ![](img/B18420_04_049.png)。准备贝尔态包括三个简单步骤：
- en: 'Prepare your two-qubit input values. For this first state, ![](img/B18420_04_050.png),
    we will use the initialized state of ![](img/B18420_04_051.png):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备你的双量子比特输入值。对于这个第一个状态，![](img/B18420_04_050.png)，我们将使用初始化状态 ![](img/B18420_04_051.png)：
- en: '![](img/B18420_04_052.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_052.png](img/B18420_04_052.png)'
- en: 'Next, add a Hadamard to the first qubit. This will place the first qubit in
    a superposition state:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向第一个量子比特添加一个哈达玛门。这将使第一个量子比特处于叠加态：
- en: '![](img/B18420_04_053.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_053.png](img/B18420_04_053.png)'
- en: 'Finally, add a CNOT gate, where the control is set to the qubit in superposition.
    In this case, the first qubit and the target are set to the second qubit. Doing
    so will ensure that when the first qubit is 1, this will trigger the target qubit
    to rotate about the *X* axis from the ![](img/B18420_04_006.png) state to the
    ![](img/B18420_04_055.png) state, or else it will remain in the ![](img/B18420_04_006.png)
    state. This gives us our final state:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个CNOT门，其中控制位设置为叠加态的量子比特。在这种情况下，第一个量子比特和目标位都设置为第二个量子比特。这样做将确保当第一个量子比特为1时，这将触发目标量子比特绕
    *X* 轴从 ![img/B18420_04_006.png](img/B18420_04_006.png) 状态旋转到 ![img/B18420_04_055.png](img/B18420_04_055.png)
    状态，否则它将保持在 ![img/B18420_04_006.png](img/B18420_04_006.png) 状态。这给我们带来了最终状态：
- en: '![](img/B18420_04_057.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_057.png](img/B18420_04_057.png)'
- en: This final state is the first Bell state, ![](img/B18420_04_049.png), which
    will result in an equal probability of either ![](img/B18420_04_051.png) or ![](img/B18420_04_060.png).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终状态是第一个贝尔态 ![img/B18420_04_049.png](img/B18420_04_049.png)，这将导致出现相等概率的 ![img/B18420_04_051.png](img/B18420_04_051.png)
    或 ![img/B18420_04_060.png](img/B18420_04_060.png)。
- en: 'The only difference between preparing the first Bell state and the others is
    just in *step 1*, where you need to prepare your inputs. *Step 2* and *step 3*
    are the same for all. What this means is that for a two-qubit circuit, the remaining
    input states in *step 1* to prepare are ![](img/B18420_04_061.png), ![](img/B18420_04_062.png),
    and ![](img/B18420_04_060.png). Luckily for us, the following formula can be used
    to help us identify the remaining Bell states:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 准备第一个贝尔态与其他态之间的唯一区别仅在于 *步骤1*，在那里你需要准备你的输入。*步骤2* 和 *步骤3* 对所有态都是相同的。这意味着对于双量子比特电路，*步骤1*
    中准备剩余的输入状态是 ![img/B18420_04_061.png](img/B18420_04_061.png)，![img/B18420_04_062.png](img/B18420_04_062.png)，和
    ![img/B18420_04_060.png](img/B18420_04_060.png)。幸运的是，以下公式可以帮助我们识别剩余的贝尔态：
- en: '![](img/B18420_04_064.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_064.png](img/B18420_04_064.png)'
- en: 'By using this formula, we can calculate that all four Bell states are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个公式，我们可以计算出所有四个贝尔态如下：
- en: 'For the input state ![](img/B18420_04_051.png), we get the following equation:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入状态 ![img/B18420_04_051.png](img/B18420_04_051.png)，我们得到以下方程：
- en: '![](img/B18420_04_066.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_066.png](img/B18420_04_066.png)'
- en: 'For the input state ![](img/B18420_04_061.png), we get the following equation:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入状态 ![img/B18420_04_061.png](img/B18420_04_061.png)，我们得到以下方程：
- en: '![](img/B18420_04_068.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_068.png](img/B18420_04_068.png)'
- en: 'For the input state ![](img/B18420_04_062.png), we get the following equation:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入状态 ![img/B18420_04_062.png](img/B18420_04_062.png)，我们得到以下方程：
- en: '![](img/B18420_04_070.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_070.png](img/B18420_04_070.png)'
- en: 'For the input state ![](img/B18420_04_060.png), we get the following equation:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入状态 ![img/B18420_04_060.png](img/B18420_04_060.png)，我们得到以下方程：
- en: '![](img/B18420_04_072.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_04_072.png](img/B18420_04_072.png)'
- en: Now, let’s create these circuits by executing all the Bell states on both a
    simulator and a quantum computer.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在模拟器和量子计算机上执行所有贝尔态来创建这些电路。
- en: Implementing the Bell states
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现贝尔态
- en: 'In this section, we will create the first two initial states, ![](img/B18420_04_051.png)
    and ![](img/B18420_04_062.png), and leave you to create the remaining input states:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建前两个初始状态 ![img/B18420_04_051.png](img/B18420_04_051.png) 和 ![img/B18420_04_062.png](img/B18420_04_062.png)，并留给你创建剩余的输入状态：
- en: 'We’ll begin by creating the first Bell state, ![](img/B18420_04_051.png). Let’s
    create a two-qubit `QuantumCircuit` circuit, and prepare the input state, ![](img/B18420_04_051.png).
    Since all quantum circuits are initialized to the state ![](img/B18420_04_051.png),
    we do not need to do anything to the circuit. We’ll add a barrier to indicate
    the separation between steps:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建第一个贝尔态 ![img/B18420_04_051.png](img/B18420_04_051.png) 开始。让我们创建一个双量子比特
    `QuantumCircuit` 电路，并准备输入状态 ![img/B18420_04_051.png](img/B18420_04_051.png)。由于所有量子电路都初始化为状态
    ![img/B18420_04_051.png](img/B18420_04_051.png)，我们不需要对电路进行任何操作。我们将添加一个屏障来指示步骤之间的分隔：
- en: '[PRE12]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, add a Hadamard gate to the first qubit:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向第一个量子比特添加一个哈达玛门：
- en: '[PRE13]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a CNOT gate where the control is the first qubit, and the target is the
    second qubit:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个CNOT门，其中控制位是第一个量子比特，目标位是第二个量子比特：
- en: '[PRE14]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add measurements to all qubits and draw the circuit:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向所有量子比特添加测量并绘制电路：
- en: '[PRE15]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will render the final circuit for our first Bell state, ![](img/B18420_04_051.png),
    as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成我们第一个贝尔态 ![img/B18420_04_051.png](img/B18420_04_051.png) 的最终电路，如下所示：
- en: '![Figure 13.1 – Prepared Bell state,  ](img/B18420_04_19.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 制备好的贝尔态](img/B18420_04_19.png)'
- en: 'Figure 4.18: Prepared Bell state,![](img/B18420_04_079.png)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：制备好的贝尔态 ![img/B18420_04_079.png](img/B18420_04_079.png)
- en: 'Now let’s execute this circuit with our helper function. Set the `simulator`
    argument to specify whether you want to execute it on a simulator or quantum system.
    To avoid any noise in our results, in this example, we will run the circuit on
    a quantum simulator to verify that our results are as expected:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的辅助函数执行这个电路。设置`simulator`参数来指定你想要在模拟器还是量子系统上执行它。为了避免结果中的任何噪声，在这个例子中，我们将电路在量子模拟器上运行以验证我们的结果是否符合预期：
- en: '[PRE16]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The results of this experiment render the following familiar output, which
    confirms the first Bell state, 00:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的结果产生了以下熟悉的输出，这证实了第一个贝尔态，00：
- en: '![Figure 13.2 – Results of the Bell state,  ](img/B18420_04_20.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 贝尔态的结果](img/B18420_04_20.png)'
- en: 'Figure 4.19: Results for the first state, ![](img/B18420_04_080.png)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：第一个状态的结果，![](img/B18420_04_080.png)
- en: We’ll now continue to represent the next state, ![](img/B18420_04_081.png),
    and confirm the results as we did previously.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将继续表示下一个状态，![](img/B18420_04_081.png)，并像之前一样确认结果。
- en: 'As mentioned earlier, the only difference between the four Bell states is in
    the first step, which is to prepare the input states. In this case, our input
    state is ![](img/B18420_04_062.png). We can follow the same steps as before after
    adding an *X* gate to the second qubit:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，四个贝尔态之间的唯一区别在于第一步，即准备输入状态。在这种情况下，我们的输入状态是![](img/B18420_04_062.png)。在给第二个量子比特添加一个*X*门之后，我们可以遵循之前的相同步骤：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in the following circuit, which is very similar to the first
    except for the added *X* gate in the preparation step:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下电路，它与第一个电路非常相似，只是在准备步骤中添加了一个*X*门：
- en: '![Figure 13.3 – Prepared Bell state](img/B18420_04_21.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 准备好的贝尔态](img/B18420_04_21.png)'
- en: 'Figure 4.20: Prepared Bell state, ![](img/B18420_04_083.png)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：准备好的贝尔态，![](img/B18420_04_083.png)
- en: 'As with the first Bell state, let’s execute this circuit and observe the results:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第一个贝尔态一样，让我们执行这个电路并观察结果：
- en: '[PRE18]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results from executing the preceding circuit are as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面电路的结果如下：
- en: '![Figure 13.4 – Results of the Bell state](img/B18420_04_22.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 贝尔态的结果](img/B18420_04_22.png)'
- en: 'Figure 4.21: Results of the Bell state, ![](img/B18420_04_081.png)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：贝尔态的结果，![](img/B18420_04_081.png)
- en: After reviewing both results, we should note a couple of things. The first is
    that we can see from the first Bell state that both qubits are equally entangled,
    in that if you were to measure one qubit, let’s say the first one, then you would
    know that the second qubit should be in the same state. Hence, if you measure
    the first qubit and the result is 0, then without measuring, you know the state
    of the second qubit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了这两项结果之后，我们应该注意以下几点。首先，我们可以从第一个贝尔态中看到，两个量子比特是同等纠缠的，也就是说，如果你要测量一个量子比特，比如说第一个，那么你就会知道第二个量子比特应该处于相同的状态。因此，如果你测量第一个量子比特，结果是0，那么你无需测量就能知道第二个量子比特的状态。
- en: Whether you measure the second qubit at the same time or at a later juncture,
    the same can be said about the second Bell state; the only difference, in that
    case, is that if you measure one qubit, then you know that the other will result
    in the opposite basis state value. Hence, if the first qubit results in 0, then
    the second qubit will result in 1, or vice versa.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在同一时间还是稍后测量第二个量子比特，对于第二个贝尔态，情况也是一样的；唯一的区别在于，如果你测量一个量子比特，那么你就知道另一个将导致相反的基态值。因此，如果第一个量子比特的结果是0，那么第二个量子比特的结果将是1，反之亦然。
- en: This correlation between two qubits is the basis for two famous quantum applications—**quantum
    teleportation** and **super dense coding**, where, in each, there are two qubits
    that are prepared in an entangled state. This preparation of the two qubits is
    represented by the Bell states, where the preparation can be in either of the
    four Bell states we have just described.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个量子比特之间的相关性是两个著名量子应用——**量子隐形传态**和**超密集编码**的基础，在这些应用中，每个应用都有两个处于纠缠态的量子比特。这两个量子比特的准备状态由贝尔态表示，这种准备可以是之前描述的四个贝尔态中的任何一个。
- en: 'When reading about use cases that describe quantum teleportation, you will
    hear a similar example to this: *Eve prepares a pair of entangled qubits and sends
    one to Alice and the other to Bob*; you’ll now know how Eve prepares the pair
    of entangled qubits.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读描述量子隐形传态用例的文章时，你会听到一个与此类似的例子：*爱娃准备了一对纠缠量子比特，并将其中一个发送给爱丽丝，另一个发送给鲍勃*；你现在将知道爱娃是如何准备这对纠缠量子比特的。
- en: Now that we understand the Bell states and how they can be applied in applications
    such as quantum teleportation and super dense coding, we’ll continue our journey
    in later chapters to illustrate how quantum algorithms offer computational advantages
    over classical systems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了贝尔态及其在量子隐形传态和超密集编码等应用中的应用，我们将在后面的章节中继续我们的旅程，以说明量子算法如何提供比经典系统更优越的计算优势。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the three quantum computing principles used
    in quantum computing. You created a quantum circuit and placed a qubit in superposition
    and an entangled state between two qubits in a quantum circuit.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了量子计算中使用的三个原理。你创建了一个量子电路，并在量子电路中将一个量子比特置于叠加态，并在两个量子比特之间处于纠缠态。
- en: You also understood the two types of interference, constructive and destructive,
    and learned how they are notated and represented individually as qubits by placing
    them in superposition to create ![](img/B18420_04_008.png) and ![](img/B18420_04_012.png)
    simulations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你还理解了两种类型的干涉，即建设性和破坏性，并学习了它们如何通过将它们放置在叠加中以创建 ![](img/B18420_04_008.png) 和 ![](img/B18420_04_012.png)
    模拟来表示和表示为量子比特。
- en: You also had a sneak peek at some Qiskit development skills by leveraging some
    quantum gates such as the Hadamard and CNOT gates, as well as operations such
    as measurements. This will prepare you for future chapters when you will create
    circuits where these gates and operations are commonly used in various algorithms.
    This makes sense as these gates and operations represent the core quantum computing
    principles that we have learned.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你还通过利用一些量子门，如 Hadamard 门和 CNOT 门，以及测量等操作，提前了解了一些 Qiskit 开发技能。这将为你准备未来章节，届时你将创建电路，在这些电路中，这些门和操作在各种算法中普遍使用。这很有意义，因为这些门和操作代表了我们所学的核心量子计算原理。
- en: 'You also ran a couple of experiments: the first one was an experiment that
    simulated a coin toss in which a circuit was created using the Hadamard gate,
    which leveraged superposition. The second experiment also simulated a coin toss,
    only we had entangled each of the two coins together. This is an expansion of
    the second circuit, which included your first multi-gate, a CNOT gate. These allowed
    you to examine how both superposition and entanglement results map from your quantum
    circuit to the classical bit outputs. We also learned about the Bell states, which
    illustrate a great example of the use and advantage we get with quantum entanglement.
    These four special states that represent a linear combination of superposition
    states will be used when learning about quantum algorithms in later chapters of
    this book.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你还进行了一些实验：第一个实验是模拟抛硬币的实验，其中使用 Hadamard 门创建了一个电路，利用了叠加原理。第二个实验也模拟了抛硬币，只是我们将两个硬币都纠缠在一起。这是第二个电路的扩展，其中包含了你的第一个多门，一个
    CNOT 门。这些使你能够检查叠加和纠缠的结果如何从你的量子电路映射到经典比特输出。我们还了解了贝尔态，它展示了量子纠缠的使用和优势。这四个特殊状态代表了叠加态的线性组合，将在本书后面的章节中学习量子算法时使用。
- en: In the next chapter, we will learn about all the other gates, both single and
    multi, to understand the operations they perform on each qubit.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习所有其他门，包括单门和多门，以了解它们在每个量子比特上执行的操作。
- en: Questions
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you create a circuit that entangles two qubits where each qubit is
    different (that is, 01, 10)?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将如何创建一个纠缠两个不同量子比特（即 01、10）的电路？
- en: Create a circuit with a multi-qubit gate, such as a Controlled-Hadamard gate.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含多量子比特门（如受控 Hadamard 门）的电路。
- en: Create all 4 Bell states in a circuit.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在电路中创建所有 4 个贝尔态。
- en: What are the three quantum computation principles?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子计算的三项原理是什么？
- en: Join us on Discord
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们 Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_4.xhtml)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_4.xhtml)'
- en: '![](img/QR_Code2617625996838265931.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2617625996838265931.png)'
