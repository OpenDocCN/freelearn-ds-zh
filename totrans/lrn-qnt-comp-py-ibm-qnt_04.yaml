- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Basic Quantum Computing Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum computing, particularly its algorithms, leverages three quantum computing
    principles, namely, **superposition**, **entanglement**, and **interference**.
    In this chapter, we’ll review each of these so that we can understand what each
    provides, the effect it has on each qubit, and how to represent them using the
    quantum gate sets provided to us. The quantum computers hosted on the **IBM Quantum
    Platform** leverage all these principles using the various quantum gates, some
    of which you used earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing quantum computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding superposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding entanglement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding interference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Bell states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, some general knowledge of physics is recommended; however,
    my goal is for the explanations to help you understand the quantum principles
    without the need for you to register for a physics course. Here is the full source
    code used throughout this book: [https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience](https://github.com/PacktPublishing/Learn-Quantum-Computing-with-Python-and-IBM-Quantum-Experience).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing quantum computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quantum computing isn’t a subject that is as common as learning algebra or reading
    some of the literary classics. However, for most scientists and engineers or people
    in any other field that includes studying physics, quantum computing is part of
    the curriculum. Those of us who don’t quite recall our studies in physics, or
    have never studied it, need not worry, as this section aims to provide you with
    information that will either refresh your recollection of the topic or at least,
    perhaps, help you understand what each of the principles used in quantum computing
    means. Let’s start with a general definition of quantum mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quantum mechanics**, as defined by most texts, is the study of nature at
    its smallest scale—in this case, the subatomic scale. The study of quantum mechanics
    is not new. Its growth began in the early 1900s thanks to the efforts of many
    physicists, whose names still chime in many of the current theories and experiments.
    The names of such physicists include Erwin Schrödinger, Max Planck, Werner Heisenberg,
    Max Born, Paul Dirac, and Albert Einstein, among others. As the years passed,
    many other scientists expanded on the foundations of quantum mechanics and began
    performing experiments that challenged many of the classical theories, theories
    such as the photoelectric effect as well as more modern approaches such as the
    wave function, which is used to provide various physical properties of a particle.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the more popular experiments that have come out of quantum mechanics
    is the **double-slit experiment**. Although this is found in classical mechanics,
    it is referenced in quantum computing to describe the behavior of a **quantum
    bit** (**qubit**). It is in this experiment that researchers were able to demonstrate
    that light (or photons) can be characterized as both waves and particles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many distinct experiments have been conducted over the years that illustrate
    this phenomenon, one of which was to fire photon particles through a double slit
    one at a time, where at the other side of the double slit, there was a screen
    that captured, as a point, the location where each particle would hit. When only
    one slit was open, all the particles would appear as a stack of points directly
    behind the slit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, schematic  Description automatically generated](img/B18420_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Single-slit experiment (image source: https://commons.wikimedia.org/wiki/File:SingleSlitDiffraction.GIF)'
  prefs: []
  type: TYPE_NORMAL
- en: From the previous diagram, you can see that all the particles are captured in
    an area directly across the slit. Here, the angle theta ![](img/_eqn_001.png)
    indicates the angle from the center of the slit (pattern) to the first minimum
    intensity.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when the second slit was open, it was imagined that there would be
    an identical stack of points on the screen, therefore two stacks. But this was
    not the case, as what was captured appeared to be a formation altogether different
    than what would be expected from a particle. In fact, it had the characteristics
    of a wave in that the points on the screen seemed to display a diffraction pattern,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18420_04_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Double-slit experiment (image source: https://commons.wikimedia.org/wiki/File:Double-slit.PNG)'
  prefs: []
  type: TYPE_NORMAL
- en: From the previous diagram, you can see that all the particles are spread out
    from the center with interference gaps.
  prefs: []
  type: TYPE_NORMAL
- en: This diffraction pattern is caused by the interference of the light waves passing
    through the slits. Here, there are more points at the center of the screen than
    there are toward the outer ends of the observing screen. This interference of
    individual particles is the basis for what is now known as **wave-particle duality**,
    which generally infers that photons of light can behave like both a wave and a
    particle. This property is used in quantum computing, particularly in algorithms
    such as Grover’s and Shor’s algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: This wave-particle phenomenon gave birth to lots of interesting research and
    development such as the **Copenhagen interpretation**, the **many-worlds interpretation**,
    and the **De Broglie-Bohm** theory.
  prefs: []
  type: TYPE_NORMAL
- en: What this illustrates is that the light appeared as bands of light in certain
    areas of the board with some probability. By observing the preceding diagram,
    you can see that there is a higher probability that the electron fired from the
    gun will land in the center band of the screen as opposed to the outer bands as
    illustrated by the darker shades of gray. Also, note that due to interference,
    the spaces in between the bands that capture the electrons have less probability
    (blank areas between bands).
  prefs: []
  type: TYPE_NORMAL
- en: It is these effects of wave interference and probabilities that we will cover
    in this chapter, but first, we will start with the electron itself to understand
    superposition.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding superposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Superposition** is something we generally can’t see with the naked eye. It’s
    defined as a combination of two similar yet distinct phenomena occurring at once:
    for example, being able to whistle and hum at the same time. Both are the same
    in that they are audible waves but distinct in how they sound. You can whistle
    without humming, and vice versa; however, doing them both at the same time is
    placing them in a superposition as you are creating a combination of both distinct
    sounds at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: In quantum mechanics, we are typically discussing the superposition of an electron.
    Since an electron is very small and there are so many of them, it is hard to distinguish
    one with even a powerful microscope. It is commonly referred to as an elementary
    particle. There are, however, some analogies in the classical world that we can
    use to illustrate what superposition is. For example, a spinning coin is what
    most texts use to describe superposition.
  prefs: []
  type: TYPE_NORMAL
- en: While it is spinning, we can say that it is in the state of both heads and tails.
    It isn’t until the coin collapses that we see what the final state of the coin
    is. This explains superposition from a probability perspective; however, the formal
    definition is commonly found in any classical physics book when describing the
    spin of an electron. I will leave this for you to search for as there are lots
    of references and resources available online that go into detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to use this spinning coin analogy just to help
    you understand the general principle of superposition. However, once we start
    working on our quantum circuits, you will see some of the differences between
    superposition and its probabilistic behavior in the classical world versus its
    behavior in the quantum world.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by reviewing the random effects we saw in the slit experiments in
    the classical world.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about classical randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we discussed the randomness of a spinning coin as an example. However,
    the spinning coin and its results are not as random as we think. Just because
    we cannot guess the correct answer when a coin is spun on a table or flipped in
    the air does not make it random. What leads us to believe that it’s random is
    the fact that we don’t have all the information necessary to know or predict or,
    in fact, determine that the coin will land on either heads or tails.
  prefs: []
  type: TYPE_NORMAL
- en: All the relevant information, such as the weight of the coin, its shape, the
    amount of force required to spin the coin, the air resistance, the friction of
    the platform the coin is rolling on, and so on, as well as the information of
    the environment itself, is not known to us in order for us to determine what the
    outcome would be after spinning a coin. It’s because of this lack of information
    that we assume the spinning of the coin is random. If we had some function that
    could calculate all this information, then we would always successfully determine
    the outcome of the spinning coin.
  prefs: []
  type: TYPE_NORMAL
- en: The same can be said about random number generators. As an example, when we
    trigger a computer to generate a random number, the computer uses a variety of
    information to calculate and generate a so-called random number. These parameters
    can include information such as the current daytime that the request was triggered,
    information about the user or the system itself, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These types of random number generators are often referred to as **pseudorandom
    number** (**PSRN**) **generators** or **deterministic random bit (DRB) generators**.
    They are only as random as the calculation or seed values provided that are allowed.
    For example, if we knew the parameters used and how they were used to generate
    this random number, then we would be able to determine the generated random number
    every time.
  prefs: []
  type: TYPE_NORMAL
- en: Now I don’t want you to worry about anyone determining the calculations or cryptographic
    keys that you may have generated. We use these PSRN generators because of the
    precision and granularity that they encompass to generate this number, which is
    such that any deviation can drastically alter the results.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, why bother reviewing the probabilistic and random nature of a spinning
    coin?* One, it’s to explain the difference between randomness, or what we believe
    is random, in the classical world versus randomness in the quantum world. Two,
    at some point we will need to leave any form of classical analogy and accept the
    fact that the quantum behavior is not obvious nor easily measured. If you wish
    to get a deeper understanding of these phenomena, which we cannot easily describe
    using classical physics or analogies, I recommend about reading the **Heisenberg
    uncertainty principle**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the classic world, we learned that if we had all the information available,
    we can more than likely determine an outcome. However, in the previous section,
    where we described the double-slit experiment, we saw that we couldn’t determine
    where on the screen the electron was going to hit. We understood the probabilities
    of where it would land based on our experiment. But even then, we could not deterministically
    identify where precisely the electron was going to land on the screen. You’ll
    see an example of this when we create our superposition circuit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who wish to learn a little more about this photonic phenomenon, I
    would suggest reading the book by the famous physicist Richard Feynman titled
    *QED: The Strange Theory of Light and Matter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a qubit in a superposition state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to create a circuit with a single qubit and set
    an operator on the qubit to set it in a superposition state. But before we do
    that, let’s quickly define what a superposition state is.
  prefs: []
  type: TYPE_NORMAL
- en: We define the qubit as having two basis energy states, one of which is the ground
    (0) state and the second of which is the excited (1) state, as illustrated in
    *Figure 4.3*. The state value name of each basis state could be anything we choose,
    but since the results from our circuit will be fed back to a classic system, we
    will use binary values to define our states—in this case, the binary values 0
    and 1\. To say that the superposition of two states is *being in both 0 and 1
    at the same time* is incorrect. The proper way to state that a qubit is in a superposition
    state is to say that it is *in a complex linear combination of states where, in
    this case, the states are 0 and 1*.
  prefs: []
  type: TYPE_NORMAL
- en: A simple analogy of this is to perhaps think of a bit as a standard light switch.
    In one position the light is on, in the other position the light is off. It’s
    either one or the other. This is analogous to a bit, either *0* or *1* (Off or
    On, respectively). Now consider a light dimmer switch (technically, a rheostat)
    where the switch can be rotated to the On position and then rotated all the way
    down to the Off position. What you can also do with a dimmer is slide the switch
    to anyplace in between off and on, this in turn adjusts the intensity, or amplitude,
    of the amount of light emitted. Now, when you have the dimmer in between the On
    and Off position, you don’t say the light is “On and Off at the same time” do
    you? Of course not. It is more of a combination of the two. Keep in mind of course,
    this is not the definition of a qubit, it’s just a simple example of why saying
    something is two things at once is not entirely correct.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the state of a qubit is generally difficult, particularly multi-qubit
    states, which involve more than one qubit and multiple quantum states. One of
    the earlier visualization models developed was the 2-state sphere that provided
    a geometrical representation of a 2-level quantum mechanical system called the
    **Bloch sphere**. The following figure is an example of a Bloch sphere, which
    represents a single qubit and its two orthogonal basis states, which are located
    on opposite poles. On the north pole, we have the basis state ![](img/B18420_04_006.png),
    while on the south pole, we have the basis state ![](img/B18420_04_007.png). The
    symbols surrounding the basis state values are the commonly used notations in
    most quantum computing text. This is called **Dirac notation**, which was named
    after the English theoretical physicist Paul Dirac, who first conceived the notation,
    which he called the **Bra-Ket notation**. Bra-Ket and Dirac notation are generally
    used interchangeably as they refer to the same thing, as we’ll see later. Each
    has its unique form as follows, **Bra** has the following form, ![](img/_eqn_004.png),
    and **Ket** has the following form, ![](img/B18420_04_006.png), where each denotes
    a mathematical *linear form* and *vector*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 - Two basis states of a qubit on a Bloch sphere ](img/B18420_04_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Two basis states of a qubit on a Bloch sphere'
  prefs: []
  type: TYPE_NORMAL
- en: OK, so let’s stop talking, and let’s start coding. We’re going to create a quantum
    circuit with a single qubit. We will then execute the circuit so that we can obtain
    the same result we can see in the preceding screenshot, which is the initial state
    of the qubit, state ![](img/B18420_04_006.png).
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, let’s first import the helper file into your working
    directory. It contains a series of functions that will help us in two ways. First,
    it will provide a series of functions we can use to quickly get us started to
    execute circuits without having to cover any details just yet. But not to worry,
    you will learn the details as we progress throughout the book, and the dependency
    of the helper file will surely disappear. Second, this will also help keep the
    code base up to date as new features and changes happen, so that updates can be
    made to keep code running far beyond the current version. The location of the
    helper file is in the GitHub repo linked at the beginning of this chapter, titled
    `helper_file_1.0.ipynb`. Be aware that you may need to set up your account if
    you want to use a quantum system and not the local simulators on your device.
    If so, please open the `setup_save_account.ipynb` file and enter your API token
    in the specified attribute and run the file. Once you do, that will save your
    API on your local machine, so you won’t have to set up each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Qiskit Notebook and enter the following code into the next empty
    cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line will load the helper file into the working notebook. The file
    contains functions that we will use to import the functions and libraries we need
    to get started, such as those needed for executing circuits on simulators and
    backend systems and returning the results of our circuits. The next line creates
    a quantum circuit that includes `1` qubit and 1 classical bit, and in the next
    line we will pass the quantum circuit to the `Statevector` object, which will
    generate the state vector of the quantum circuit. This will return the resulting
    object, which will contain the state vector results. Finally, we display the results
    on a Bloch sphere, which should display what you saw in *Figure 4.3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each qubit, as mentioned earlier, is made up of two basis states, which, in
    this example, reside on opposite poles of the Bloch sphere. These two basis states
    are what we would submit back to the classical system as our result—either one
    or the other. The vector representing these two points originates from the origin
    of the Bloch sphere, as you can see in the previous diagram or the result from
    your experiment. If we were to notate this as a vector, we would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the opposite would apply to the opposite pole, we would notate it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From observing the vector values, you can see that flipping the values of the
    vector is like a classical bit flip. Now that we understand the vector representation
    of a qubit, let’s continue and set the qubit in a superposition state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a new cell at the bottom of the current notebook and enter the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line places a **Hadamard (H)** gate onto the first qubit, identified
    by the qubit’s index value (`0`). It then calls the `draw()` function, which will
    draw the circuit diagram; note that the `output` parameter is added just to get
    a nicer output. If you would like to include these visualization features, be
    sure to install `qiskit[visualization]` from pip (`pip install qiskit[visualization]`).
    Otherwise, you can remove the parameter and get standard text visualization outputs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After running the previous cell, you should see the following circuit image,
    which represents adding the Hadamard gate to the qubit and the classical bit just
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a square with a blue square and black text  Description automatically
    generated](img/B18420_04_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Circuit with a Hadamard (H) gate added to a qubit'
  prefs: []
  type: TYPE_NORMAL
- en: The **Hadamard gate** (H gate) is a quantum gate that places the qubit in a
    superposition state, or, more specifically, a complex linear combination of the
    basis states, which means that when we measure the qubit, it will have an equal
    probability result of measuring a 0 or 1\. Or in other words, it would collapse
    to one of the basis state values of ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically, the superposition state is obtained with the application of
    the Hadamard gate, and its results are represented in the following two superposition
    equations, which, as you can see, depends on which of the two basis states, ![](img/B18420_04_006.png)
    or ![](img/B18420_04_007.png), it was in prior to applying the Hadamard gate.
    The first superposition equation ![](img/B18420_04_008.png) is as follows and
    originates from the ![](img/B18420_04_006.png) state, which is often referred
    to as the positive ![](img/B18420_04_010.png) superposition state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second superposition equation ![](img/B18420_04_012.png), originating from
    the ![](img/B18420_02_003.png) state, is as follows, which is often referred to
    as the negative ![](img/B18420_04_014.png) superposition state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_015.png)'
  prefs: []
  type: TYPE_IMG
- en: Visually, on the Bloch sphere, this is equal to a π⁄2 rotation about the *X*
    and *Z* axes of the Bloch sphere. These rotations are Cartesian rotations, which
    rotate counterclockwise around the specified axis, in this case, the *X* and *Z*
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get the state vector of our circuit, and see what the resulting
    quantum state will look like, and where the state vector lands on the Bloch sphere.
    In the following code, you will call the `Statevector` object and pass the quantum
    circuit into the `constructor` argument, the result of which will change the state
    of the qubit to a superposition state from the initial state, which you will see
    in the resulting Bloch sphere’s output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now see the results plotted on the Bloch sphere in a superposition
    of ![](img/B18420_04_006.png) and ![](img/B18420_02_003.png), as illustrated in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 - Superposition of a qubit after 90° rotation around the X and
    Z axes  ](img/B18420_04_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Superposition of a qubit after 90° rotation of the ![](img/B18420_04_006.png)
    basis state'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, this has placed the vector on the
    positive *X* axis, as described previously when adding an H gate from the ![](img/B18420_04_006.png)
    basis state. One thing to note is that visually, this could also have been done
    by rotating the *Y* axis by 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s clear the circuit by recreating the `QuantumCircuit` object with
    the same name. This time, we will initialize the qubit to the ![](img/B18420_02_003.png)
    state first and then apply a Hadamard gate to see what happens to the vector.
    Initialize the `qubit` to the ![](img/B18420_04_006.png) state and place it in
    a superposition. Clear the circuit and initialize the qubit to `1` before applying
    a Hadamard gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now see the following circuit; in this case, we have omitted the
    classical bit when constructing our quantum circuit, which is why you do not see
    the classical bit in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 - Applying an H gate superposition from an opposite base state  ](img/B18420_04_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Applying an H gate superposition to the base state ![](img/B18420_02_003.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute the circuit and plot the result on the Bloch sphere using
    the same code you used to execute the previous circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 - Superposition of a qubit after 90° rotation around the X and
    Z axes from the  state ](img/B18420_04_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Superposition of a qubit after 90° rotation around the X and Z
    axes from the ![](img/B18420_02_003.png) state'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you see the difference between adding an H gate to a qubit in the ![](img/B18420_04_006.png)*
    *state (Figure 4.5) and adding it to a qubit in the* ![](img/B18420_02_003.png)
    *state in the preceding figure?*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the difference is where it lands on the *X* axis! Because the vector
    falls onto the positive *X* axis when applying a Hadamard gate to the ![](img/B18420_04_006.png)
    state, this is commonly notated as ![](img/B18420_04_008.png). This logically
    means that the vector falls onto the negative *X* axis when applying a Hadamard
    gate to the ![](img/B18420_02_003.png) state. This is commonly notated as ![](img/B18420_04_012.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the right side of the superposition equations and pay close attention
    to the signs in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_011.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/B18420_04_015.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the signs match the direction of where the vector lands after the
    Hadamard gate is applied. From the ![](img/B18420_04_006.png) state, it moves
    toward the positive (+) direction of the *X* axis, and from the ![](img/B18420_02_003.png)
    state, it moves toward the negative (-) direction of the *X* axis.
  prefs: []
  type: TYPE_NORMAL
- en: This difference is referred to as a phase difference between the two results.
    This will be very important later in this and subsequent chapters, as phase difference
    plays an important role in many quantum algorithms and blends itself into the
    topic of interference, as we will learn shortly.
  prefs: []
  type: TYPE_NORMAL
- en: One last thing that we will discuss before moving on is to now look back to
    our earlier discussion on probabilities. Now that we’ve learned what superposition
    looks like in a circuit and on a Bloch sphere, let’s execute and see what the
    probabilities are when we measure the qubit after it is in superposition. As you
    may recall from our first analogy of flipping or spinning a coin, we said that
    once the coin is spinning, it is in a superposition of heads or tails, or in this
    example, 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Once we observe the outcome, the result of the coin will be one or the other.
    However, classically, this is pseudorandom, as we learned. But in quantum computing,
    electron detection is truly random as there is no way to determine its outcome
    without disturbing it due to the **Heisenberg uncertainty principle**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Heisenberg uncertainty principle**, introduced by Werner Heisenberg in
    1927, describes how it is not possible to predict the *momentum* of a particle
    from its initial conditions if the *position* is more precisely determined. The
    same is said for the reverse, where it is not possible to predict the position
    of a particle from its initial conditions if the momentum is more precisely determined.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as measuring a qubit; we are, in essence, measuring it, and
    therefore forcing it to collapse into one of two basis states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, measure the qubit after it is in superposition and recreate the circuit.
    Let’s start from the ![](img/B18420_04_006.png) state and apply a Hadamard gate,
    as we did earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, using our helper function, let’s create a circuit that includes a measurement
    operator so that we can measure the qubit, which will collapse into one of two
    states, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code, we created a measurement circuit that includes a measurement
    operation that basically collapses the qubit from its current state to that of
    either 0 or 1\. The second line of the code then concatenates the first circuit
    `qc` and this new `measurement_circuit` together, creating a new circuit called
    `full_circuit` which will be drawn as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 - Full circuit with rotation and measurement from qubit (q) to
    classic bit (c) ](img/B18420_04_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Full circuit with rotation and measurement from qubit (q) to classic
    bit (c)'
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram illustrates our full circuit, which you can see now includes
    two new components, the first of which is the classic register below the quantum
    register. The second component is the measurement operator, which will extract
    the result of the qubit and pass it onto the classical bit. The result will collapse
    the state of the qubit to either 1 or 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run this circuit to see what results we get back. We will add a
    few `shots` and see the results. `Shots` refer to running through the experiment
    a few times and aggregating its results. We’ll use our helper file to help us
    run this circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The previous code will now use a different backend from our helper file, the
    `BasicSimulator` rather than the `Statevector`, which will allow us to obtain
    the measured results of the circuit. In this case, we will extract `counts`, which
    stores the number of times the measurement resulted in either a 0 or 1 out of
    `1024` `shots`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the results are almost 50%, which illustrates that you can have
    an equal probability of landing on either the 0 or 1 state for each shot!
  prefs: []
  type: TYPE_NORMAL
- en: Note that your actual value results might be different than what was shown previously,
    but the probability should be close to 50%. Retry running the code a few times
    and play around with the number of `shots` to see if you get any differences.
    The limitation for `shots` can be found in the `max_shots` value for each simulator
    and quantum system’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we run so many shots of a circuit is to get enough measurements
    to obtain accurate statistics of a measurement operation on a superposition state
    that is probabilistic. The noise in the system contributes to the deviation from
    a perfect statistic of 50/50 in the counts, because the near-term quantum devices
    used these days are not fault-tolerant yet. Fault-tolerant devices are those that
    have logical qubits, which can comprise one or more physical qubits, and are used
    to minimize errors so that operations complete as specified by the quantum circuits.
    They exhibit very low error rates and large quantum volumes, which we will cover
    in *Chapter 9*, *Optimizing and Visualizing Circuits*. Current near-term devices
    need to run multiple shots to provide your quantum algorithm with good probabilistic
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Building a coin-flipping experiment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever taken a course in probability and statistics, you might have
    seen the coin flip example. In this example, you are given an unbiased coin to
    flip multiple times and track the results of each flip (experiment) as either
    heads or tails. What this experiment illustrates is that with an unbiased coin
    and enough samples, you will see that the probability of either heads or tails
    starts to converge to about 50%.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, after running enough experiments, the number of times the coin
    lands on heads becomes very closely equal to the number of times that it lands
    on tails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give this a try in the IBM Quantum Composer, to better visualize what’s
    happening (note, backend systems might not be available or the same, so use any
    backend you see available. Like most of the backends throughout this book, we’ll
    be using those that were available at the time of writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Composer Editor and create a new blank circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For simplicity, let’s remove all except one qubit. This will simplify our results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the Hadamard gate onto the first qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag the measurement operation onto the first qubit after the H gate.
    This will indicate that you wish the value of this qubit to be measured, and assign
    its resulting value of either 1 or 0 to the corresponding classic bit; in this
    case, the bit at position 0, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing schematic  Description automatically generated](img/B18420_04_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Coin flip experiment'
  prefs: []
  type: TYPE_NORMAL
- en: Name your circuit `Coin flip` and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Setup and run** to expand the options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a backend device and set the run count to `1024`. This will run the experiment
    1,024 times. Note at the time of this writing there are some changes occurring
    which might change how to run a circuit using Composer. If so, please refer to
    the instructions on the platform for any changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Run on ‘device selected’**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once completed, click on the completed experiment in the **Composer jobs** list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The measurement outcome results will now show two different states. Remember
    that the Computational basis states are represented along the *X* axis, which
    you can see is either a 0 or 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bar chart  Description automatically generated with medium confidence](img/B18420_04_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Coin flip results'
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is the `Frequency` (the *X* axis) of each of the two states.
    This will differ each time you run the experiment as it represents how many times
    the outcome was either 0 or 1 for each shot.
  prefs: []
  type: TYPE_NORMAL
- en: What you will notice from the preceding screenshot is that the results will
    fall close to 50% each time you run the experiment. Rerun the experiment a few
    more times and examine the results for yourself. The use of the Hadamard gate
    allows you to place a qubit on a circuit into a linear combination of the two
    basis states, 0 and 1\. As mentioned earlier, this helps to leverage superposition.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding entanglement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second quantum computing principle used by quantum computers is **entanglement**.
    By entangling two or more qubits, we are, in essence, linking the value of one
    qubit and synchronizing it with one or more other qubits. By synchronizing it,
    we mean that if we measure (observe) the value of one of the entangled qubits,
    then we can be sure that the other qubit will have the same value, whether we
    measure it at the same time or sometime later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Entanglement** is probably one of the most interesting of the three quantum
    computing principles. This is mainly because it still baffles physicists to this
    day, with many taking different philosophical sides in the discussion. I won’t
    bore you with the details, but I will aim to provide you with enough information
    for you to understand what entanglement is, but not to have a way to prove it
    to create quantum algorithms and applications. Yes, it sounds confusing, but believe
    me, the devil is in the detail and there just isn’t enough space for us to formulate
    a comprehensive answer to how entanglement works. But enough of that—let’s get
    to work!'
  prefs: []
  type: TYPE_NORMAL
- en: Quantum entanglement, or just entanglement, is simply defined as a quantum mechanical
    phenomenon that occurs when two or more particles have correlated states. What
    this, in essence, means is that if you have two particles or, for our purposes,
    qubits, that are entangled, this means that when we measure one qubit, we can
    determine the result of the other qubit based on the measurement of the first
    qubit.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from our previous example, if we put a qubit in a superposition
    and we measure that qubit, we have a 50/50 split as to whether that qubit would
    collapse to either of two states, ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
  prefs: []
  type: TYPE_NORMAL
- en: Now, if that same qubit were entangled with another qubit and we were to measure
    one of the qubits, that qubit will be either ![](img/B18420_04_006.png) or ![](img/B18420_02_003.png).
    However, if we were to measure the second qubit, either at the exact same time
    or sometime later, it too will have the same value as the first qubit we measured!
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is that this can also be the opposite if you so choose it
    to be. For example, let’s say you set the second qubit to the ![](img/B18420_04_039.png)
    state prior to entangling. You have now entangled opposite states. These combinations
    of entangled states will be covered in more detail when we discuss quantum algorithms
    in *Chapter 12, Applying Quantum Algorithms*.
  prefs: []
  type: TYPE_NORMAL
- en: You’re probably thinking, *how can this be?* If we take two qubits and place
    them in superposition and we measure them separately, we will correctly see that
    each qubit will collapse to a value of 1 or 0, where each time we measure the
    qubits individually, it may not collapse to the same value at the same time. This
    means that if we run the experiment one shot at a time, we would see that, sometimes,
    the first qubit will measure 0, while the second qubit could measure 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Both are separate and do not know the value of each other either before, during,
    or after measurement. However, if we were to entangle the two qubits and repeat
    the same experiment, we would see that the qubits will measure the exact same
    values each time! Each will result in one of four different outcomes of either
    00, 11, 01, or 10\. Each of these four is based on what is known as the Bell states,
    which will be covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*Impossible*, you say? Well, it’s a good thing for us that we now have a quantum
    computer that we can run and try this out!'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the behavior of entangled qubits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following code, we will see that when qubits are not entangled, their
    results are such that we cannot infer what the result of one qubit would be based
    on the result of the other qubit. Since we are measuring two qubits, our results
    will be listed as two-bit values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create a new circuit with two qubits, place them each in superposition,
    and measure them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we created a quantum circuit with two qubits, added an
    H gate to each of the qubits so that we can place each qubit into a superposition
    state, and finally, added a measurement from each qubit to its respective bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result from the previous code should display the following circuit, where
    we can see that each qubit has an H gate that’s measured to its respective classical
    bit register; that is, qubit 0 to bit 0 and qubit 1 to bit 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 - Two qubits in superposition and measured to their respective
    classic bits  ](img/B18420_04_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Two qubits in superposition and measured to their respective classic
    bits'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we execute the circuit and display the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous code, we created the backend to run on the simulator with `1000`
    `shots` and plot the results in a histogram to review them.
  prefs: []
  type: TYPE_NORMAL
- en: Note from the following results that the outcomes are very random from each
    qubit, which is what we expected. One thing I would also like to mention regarding
    notation is the ordering of the qubits. When written, the order of the qubits
    is a little different than the bit order. In quantum notation, the first qubit
    is also listed on the left-hand side, while subsequent qubits are added toward
    the right-hand side. In binary notation, however, the first bit is on the right-hand
    side, while subsequent bits are added toward the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to represent the 3-qubit value of the number 5, we would
    do so using ![](img/B18420_04_040.png), which is the same as the bit representation
    of the same number. However, the qubit order here is different as the first qubit
    is listed in the left position (q[0]), the second qubit (q[1]) is listed in the
    middle position, and the last qubit (q[2]) is listed in the right position.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in binary notation, the first bit (b[0]) is in the right
    position and moves up in order to the left. When measuring, we link the results
    from the qubit to the bit (as shown in the preceding screenshot), which correctly
    maps the results of each qubit to its respective binary position so that our results
    are in the expected bit order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plotted histogram is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 - Random results of all combinations from both qubits ](img/B18420_04_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Random results of all combinations from both qubits'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, each qubit has collapsed to a state of either 0
    or 1, so since there are two qubits, we should expect to see all four random results,
    which are **00**, **01**, **10**, and **11**. Your probability results might differ
    a bit, but overall, they should all be close to 25% probability.
  prefs: []
  type: TYPE_NORMAL
- en: This is expected, so let’s entangle the two qubits and see what happens then.
    For this, we will entangle the two qubits and rerun the experiment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s entangle the two qubits by adding a multi-qubit gate called a **Controlled**
    **NOT** (**CNOT**) gate. Let me explain what this gate is before we include it
    in our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: The CNOT gate is a multi-qubit gate that operates on one qubit based on the
    value of another. What this means is that the qubit gate has two connecting points—one
    called **control** and another called **target**. The target is generally an operator,
    such as a **NOT** (*X*) gate, which would flip the qubit from 0 to 1, or vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: However, the target operator can also be almost any operation, such as an H
    gate, a Y gate (which flips 180° around the *Y* axis), and so on. It could even
    be another control, but we will get into those fancy gates in *Chapter 6*, *Understanding
    Quantum Logic Gates*.
  prefs: []
  type: TYPE_NORMAL
- en: The CNOT gate acts in such a manner that when the qubit tied to the control
    is set to 0, the value of the target qubit does not change, meaning the target
    operator will not be enabled. However, if the value of the control qubit is 1,
    this will trigger the target operator. This would, therefore, in the case of a
    CNOT gate, enable a NOT operation on the target qubit, causing it to flip 180°
    around the *X* axis from its current position. This is illustrated in *Figure
    4.13*, where qubit 0 is the control and qubit 1 is the target; in this case, the
    target is a NOT gate, hence making this a CNOT gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic table represents the control and target value updates based
    on the value of the control for a CNOT gate, as well as the states before and
    after the CNOT gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 4.1 - Two qubit CNOT logic table ](img/B18420_04_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 4.1: Two-qubit CNOT logic table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can see how the CNOT gate works on two qubits, we will update our
    circuit so that we can entangle the qubits together. In the following code, we
    will create a circuit with 2 qubits where we will apply a Hadamard gate to the
    first qubit and then entangle the first qubit with the second qubit using a CNOT
    gate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting diagram of the circuit should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 - Entanglement of two qubits ](img/B18420_04_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Entanglement of two qubits'
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot shows you that, this time, we are only placing a Hadamard
    gate on the first qubit and leaving the second qubit to be operated on only by
    the CNOT gate. Since qubit 1 (q[1]) is set as the target, it will be dependent
    on the control qubit, which, in this case, is qubit 0 (q[0]).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will run the experiment and plot the results. This is similar to the
    previous experiments we completed, where we will execute the circuit, extract
    the result counts, and plot them on a histogram to visualize the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results shown in the following screenshot show two quantum computing principles—the
    superposition of the qubits, 0 and 1, and the entanglement—where both qubits’
    (control and target) results are strongly correlated as either **00** or **11**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 - Results of two entangled qubits  ](img/B18420_04_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Results of two entangled qubits'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend our coin-flipping example by adding another coin and entangling
    them together so that when we run our experiment, we can determine the value of
    one coin without having to measure the other.
  prefs: []
  type: TYPE_NORMAL
- en: Entangling two coins together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way as our previous experiment, each qubit will represent a coin.
    In order to do this, we will use a CNOTgate, which connects two qubits where one
    is the source and the other the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try entangling our coins (qubits) to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Composer and create a new blank circuit with 2 qubits. As a reminder,
    you can increase or decrease the number of qubits by selecting a qubit and clicking
    on either the + or trash icon to add or remove a qubit from the circuit, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag a Hadamard gate onto the first qubit, q[0].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the CNOT gate (*round white gate with crosshairs on blue background*)
    onto the first qubit, q[1]. This will assign the control qubit to the first qubit.
    When selecting the CNOT gate, the first qubit you drop it on will be set as the
    control. Visually, the source control of the CNOT gate is a solid dot on the qubit
    to which the gate was dragged on to (see *Figure 4.15*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, the target will set itself to the next qubit. In this case, it will
    drop to qubit 2\. Visually, the target for a CNOT is a large dot with a cross
    in the middle, made to resemble a target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click and drag a measurement operator onto each of the two first qubits as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B18420_04_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Entangled qubit circuit representing entangled coins'
  prefs: []
  type: TYPE_NORMAL
- en: Name and save your experiment as `Entangled coins`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Setup and run** on the circuit to launch the **Setup and run** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any device from the backend selection as the backend device and select
    the `shots` value to `1024`. This will run the experiment 1,024 times, which is
    the default value that you can change if need be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Run on** and select whichever device you selected in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once completed, click the `Entangled coins` experiment from the `Completed jobs`
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s review the results and see what happens when we entangle two qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_04_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Entangled coins results'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the results still have two states,
    as they did in the previous experiment. However, one thing to observe here is
    the results of the two qubits. Note that the state of both qubits is either 00
    or 11.
  prefs: []
  type: TYPE_NORMAL
- en: What makes this experiment interesting is when we flipped one coin in the previous
    experiment, you saw that the results were 50% (0 or 1). However, now we are running
    the same experiment, but we are entangling another coin. In effect, this results
    in both coins becoming entangled together and thus their states will always be
    the same as each other. This means that if we flip both coins and we observe one
    of the coin values, then we know that the other entangled coin will be the same
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with superposition and entanglement, let’s move on
    to the last quantum computing principle, which is interference.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding interference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of quantum computing is its ability to interleave these
    principles in such a way that usually, while explaining one, you can very easily
    describe the other. We did this earlier in this chapter with respect to interference.
    Let’s review and see where we have come across this phenomenon and its usage so
    far.
  prefs: []
  type: TYPE_NORMAL
- en: First, recall that, at the beginning of this chapter, we described the double-slit
    experiment. There, we discussed how an electron can act as both a wave and a particle.
    When acting like a wave, we saw that the experiment illustrated how the electrons
    traveled and landed at certain spots on the observation screen. The pattern that
    it displayed was generally one that we recognize from classic physics as wave
    interference.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern had probabilistic results along the backboard, as shown in the observing
    screen in *Figure 4.2*, where the center of the screen has the highest number
    of electrons and the blank areas along both sides had the least to none. This
    is due to the two types of interference of the particle waves, namely, **constructive**
    and **destructive**. Constructive interference occurs when the peaks of two waves
    are summed up where the resulting amplitude is equal to the total positive sum
    of the two individual waves.
  prefs: []
  type: TYPE_NORMAL
- en: Destructive interference occurs similarly to constructive interference except
    that the amplitudes of the waves are opposite in that when summing them together,
    the two waves cancel each other out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the constructive and destructive wave interference
    of two waves when they are added together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_04_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Constructive (left) and destructive (right) wave interferences
    (image source: https://commons.wikimedia.org/wiki/File:Interference_of_two_waves.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates how two waves interfere with each other constructively
    and destructively. The two waves toward the bottom of the diagram represent the
    individual amplitudes of each wave, while the top line represents the added amplitude
    values, which represent the result of the interference between the two waves.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the difference between constructive and destructive
    interference, *how can we apply this to what we’ve learned so far?* Well, if you
    recall, earlier, when we placed a qubit in superposition, we had two distinct
    results.
  prefs: []
  type: TYPE_NORMAL
- en: One was from the basis state ![](img/B18420_04_006.png), while the other was
    from the basis state ![](img/B18420_02_003.png). Do you remember when we started
    at either of these two qubit basis states, where on the *X* axis of the qubit
    the Hadamard landed? From ![](img/B18420_04_006.png), it would land on the positive
    side of the *X* axis, but if we placed the qubit into superposition starting from
    the ![](img/B18420_02_003.png) state, it would land on the negative *X* axis.
  prefs: []
  type: TYPE_NORMAL
- en: Having the ability to place the qubit state vector on either the positive or
    negative *X* axis provides us with a way to place the qubit in either a positive
    or negative state. Very similar to the waves in the preceding diagram, which have
    positive (peaks) and negative (troughs) amplitudes, qubits can also represent
    similar states. Let’s simplify this by re-introducing the two Dirac notation values,
    ![](img/B18420_04_008.png), and ![](img/B18420_04_012.png), where the ![](img/B18420_04_008.png)
    state represents the state vector on the positive *X* axis, and the ![](img/B18420_04_012.png)
    state represents the state vector on the negative *X* axis.
  prefs: []
  type: TYPE_NORMAL
- en: These new vector definitions, which represent the vector state of a qubit in
    superposition, will be used by some of the algorithms as a technique to identify
    certain values and react to them using interference—techniques such as **amplitude
    estimation** and search algorithms such as **Grover’s** **algorithm**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed the quantum computing principle of interference.
    This, along with the other two principles, superposition and entanglement, will
    come in handy as you learn about how these principles are used in quantum algorithms
    in ways that provide potential speed up over classical algorithms. To do so, we
    will review an example that we will use throughout this book, to understand the
    very foundation of all quantum algorithms, the **Bell states**.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Bell states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most of the examples in this book, you will notice that we reuse a simple
    two-qubit quantum circuit to run many of our experiments. This circuit contains
    two gates, a single-qubit gate, and a multi-qubit gate, a Hadamard and CNOT, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for choosing this was not random. In fact, this circuit has a name,
    the Bell state. The Bell state, which was originally described in a theoretical
    paper by John Bell in 1964, describes how there are four maximally entangled quantum
    states between two qubits that are in a superposition state. These four states
    are commonly referred to as the **Bell states**.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you may be wondering why this is so important. Well, if we can
    prepare qubits to a particular state, in this case, the maximally entangled state,
    this can help streamline the creation of various quantum circuits and algorithms.
    To learn more about this, let’s first prepare the four Bell states, and perhaps,
    along the way, you might see its importance and understand the significance to
    some use cases such as quantum teleportation or super dense coding.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Bell states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin by first preparing the Bell state that we will use throughout this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll label each of these states as we create them, this first one being labeled
    as ![](img/B18420_04_049.png). Preparing the Bell state entails three simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare your two-qubit input values. For this first state, ![](img/B18420_04_050.png),
    we will use the initialized state of ![](img/B18420_04_051.png):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_052.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, add a Hadamard to the first qubit. This will place the first qubit in
    a superposition state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_053.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, add a CNOT gate, where the control is set to the qubit in superposition.
    In this case, the first qubit and the target are set to the second qubit. Doing
    so will ensure that when the first qubit is 1, this will trigger the target qubit
    to rotate about the *X* axis from the ![](img/B18420_04_006.png) state to the
    ![](img/B18420_04_055.png) state, or else it will remain in the ![](img/B18420_04_006.png)
    state. This gives us our final state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_057.png)'
  prefs: []
  type: TYPE_IMG
- en: This final state is the first Bell state, ![](img/B18420_04_049.png), which
    will result in an equal probability of either ![](img/B18420_04_051.png) or ![](img/B18420_04_060.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'The only difference between preparing the first Bell state and the others is
    just in *step 1*, where you need to prepare your inputs. *Step 2* and *step 3*
    are the same for all. What this means is that for a two-qubit circuit, the remaining
    input states in *step 1* to prepare are ![](img/B18420_04_061.png), ![](img/B18420_04_062.png),
    and ![](img/B18420_04_060.png). Luckily for us, the following formula can be used
    to help us identify the remaining Bell states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_04_064.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using this formula, we can calculate that all four Bell states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the input state ![](img/B18420_04_051.png), we get the following equation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_066.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the input state ![](img/B18420_04_061.png), we get the following equation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the input state ![](img/B18420_04_062.png), we get the following equation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_070.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the input state ![](img/B18420_04_060.png), we get the following equation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/B18420_04_072.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let’s create these circuits by executing all the Bell states on both a
    simulator and a quantum computer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Bell states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will create the first two initial states, ![](img/B18420_04_051.png)
    and ![](img/B18420_04_062.png), and leave you to create the remaining input states:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by creating the first Bell state, ![](img/B18420_04_051.png). Let’s
    create a two-qubit `QuantumCircuit` circuit, and prepare the input state, ![](img/B18420_04_051.png).
    Since all quantum circuits are initialized to the state ![](img/B18420_04_051.png),
    we do not need to do anything to the circuit. We’ll add a barrier to indicate
    the separation between steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a Hadamard gate to the first qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a CNOT gate where the control is the first qubit, and the target is the
    second qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add measurements to all qubits and draw the circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will render the final circuit for our first Bell state, ![](img/B18420_04_051.png),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Prepared Bell state,  ](img/B18420_04_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Prepared Bell state,![](img/B18420_04_079.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s execute this circuit with our helper function. Set the `simulator`
    argument to specify whether you want to execute it on a simulator or quantum system.
    To avoid any noise in our results, in this example, we will run the circuit on
    a quantum simulator to verify that our results are as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results of this experiment render the following familiar output, which
    confirms the first Bell state, 00:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Results of the Bell state,  ](img/B18420_04_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Results for the first state, ![](img/B18420_04_080.png)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now continue to represent the next state, ![](img/B18420_04_081.png),
    and confirm the results as we did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the only difference between the four Bell states is in
    the first step, which is to prepare the input states. In this case, our input
    state is ![](img/B18420_04_062.png). We can follow the same steps as before after
    adding an *X* gate to the second qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following circuit, which is very similar to the first
    except for the added *X* gate in the preparation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Prepared Bell state](img/B18420_04_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Prepared Bell state, ![](img/B18420_04_083.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the first Bell state, let’s execute this circuit and observe the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results from executing the preceding circuit are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Results of the Bell state](img/B18420_04_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Results of the Bell state, ![](img/B18420_04_081.png)'
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing both results, we should note a couple of things. The first is
    that we can see from the first Bell state that both qubits are equally entangled,
    in that if you were to measure one qubit, let’s say the first one, then you would
    know that the second qubit should be in the same state. Hence, if you measure
    the first qubit and the result is 0, then without measuring, you know the state
    of the second qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you measure the second qubit at the same time or at a later juncture,
    the same can be said about the second Bell state; the only difference, in that
    case, is that if you measure one qubit, then you know that the other will result
    in the opposite basis state value. Hence, if the first qubit results in 0, then
    the second qubit will result in 1, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This correlation between two qubits is the basis for two famous quantum applications—**quantum
    teleportation** and **super dense coding**, where, in each, there are two qubits
    that are prepared in an entangled state. This preparation of the two qubits is
    represented by the Bell states, where the preparation can be in either of the
    four Bell states we have just described.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading about use cases that describe quantum teleportation, you will
    hear a similar example to this: *Eve prepares a pair of entangled qubits and sends
    one to Alice and the other to Bob*; you’ll now know how Eve prepares the pair
    of entangled qubits.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the Bell states and how they can be applied in applications
    such as quantum teleportation and super dense coding, we’ll continue our journey
    in later chapters to illustrate how quantum algorithms offer computational advantages
    over classical systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the three quantum computing principles used
    in quantum computing. You created a quantum circuit and placed a qubit in superposition
    and an entangled state between two qubits in a quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: You also understood the two types of interference, constructive and destructive,
    and learned how they are notated and represented individually as qubits by placing
    them in superposition to create ![](img/B18420_04_008.png) and ![](img/B18420_04_012.png)
    simulations.
  prefs: []
  type: TYPE_NORMAL
- en: You also had a sneak peek at some Qiskit development skills by leveraging some
    quantum gates such as the Hadamard and CNOT gates, as well as operations such
    as measurements. This will prepare you for future chapters when you will create
    circuits where these gates and operations are commonly used in various algorithms.
    This makes sense as these gates and operations represent the core quantum computing
    principles that we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also ran a couple of experiments: the first one was an experiment that
    simulated a coin toss in which a circuit was created using the Hadamard gate,
    which leveraged superposition. The second experiment also simulated a coin toss,
    only we had entangled each of the two coins together. This is an expansion of
    the second circuit, which included your first multi-gate, a CNOT gate. These allowed
    you to examine how both superposition and entanglement results map from your quantum
    circuit to the classical bit outputs. We also learned about the Bell states, which
    illustrate a great example of the use and advantage we get with quantum entanglement.
    These four special states that represent a linear combination of superposition
    states will be used when learning about quantum algorithms in later chapters of
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about all the other gates, both single and
    multi, to understand the operations they perform on each qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you create a circuit that entangles two qubits where each qubit is
    different (that is, 01, 10)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a circuit with a multi-qubit gate, such as a Controlled-Hadamard gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create all 4 Bell states in a circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three quantum computation principles?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_4.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265931.png)'
  prefs: []
  type: TYPE_IMG
