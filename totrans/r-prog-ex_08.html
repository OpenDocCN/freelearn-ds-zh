<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Object-Oriented System to Track Cryptocurrencies</h1>
                
            
            
                
<p class="calibre2">In this chapter, we will introduce a new way of programming that we have not explicitly used before in the book. It's called object-oriented programming, and it will be used throughout our third and final example in the book. Object-oriented programming is very popular among programmers, and it's mainly used to allow for complex abstraction relations to be modeled and implemented in such a way that the evolution of the system is not jeopardized.</p>
<p class="calibre2">When developing object-oriented systems, and in general when we program, we should strive for simplicity, but it doesn't come naturally. When dealing with a complex domain, it's easier to create complex rather than simple code. Programmers must make an active effort to produce simple code, since simplicity depends mostly on the programmer, not the language. In this chapter, we will show you how to efficiently work with object-oriented code by introducing the ideas and concepts that support it, and we will later illustrate how to implement it using three of R's most used object models.</p>
<p class="calibre2">R has various object models, or object-oriented systems, so it can be a bit intimidating at first. The goal of this chapter is not to make you an expert in object-oriented programming or in each of R's object models, but to help you understand how to implement the basic building blocks of object-oriented programs with R's different object models.</p>
<p class="calibre2">Some of the important topics covered in this chapter are:</p>
<ul class="calibre11">
<li class="calibre12">Fundamental object-oriented programming concepts</li>
<li class="calibre12">Design and architecture of object-oriented systems</li>
<li class="calibre12">R's parametric polymorphism through generic functions</li>
<li class="calibre12">The different object models available for R</li>
<li class="calibre12">Mixing functionality from R's different object models</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">This chapter's required packages</h1>
                
            
            
                
<p class="calibre2">This chapter will make use of the <kbd class="calibre9">methods</kbd> and <kbd class="calibre9">R6</kbd> packages to load the S4 and R6 object models functionality. You should know that interactive R sessions load the <kbd class="calibre9">methods</kbd> by default, but non-interactive sessions don't, so you need to explicitly load it in such cases. The <kbd class="calibre9">jsonlite</kbd> and <kbd class="calibre9">lubridate</kbd> packages are brought to simplify some common tasks like getting data from JSON APIs and transforming dates. For more information, take a look at <a href="part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730" class="calibre4">Appendix</a>, <em class="calibre19">Required Packages</em>.</p>
<table class="calibre5">
<tbody class="calibre6">
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Package</strong></p>
</td>
<td class="calibre8">
<p class="calibre2"><strong class="calibre1">Reason</strong></p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">R6</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">R6 object model</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">methods</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">S4 object model</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">lubridate</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Easily transform dates</p>
</td>
</tr>
<tr class="calibre7">
<td class="calibre8">
<p class="calibre2"><kbd class="calibre9">jsonlite</kbd></p>
</td>
<td class="calibre8">
<p class="calibre2">Retrieve data from JSON APIs</p>
</td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The cryptocurrencies example</h1>
                
            
            
                
<p class="calibre2">A <strong class="calibre1">cryptocurrency</strong> is a digital currency designed to work as a medium of exchange. Cryptocurrencies use cryptography to secure and verify transactions, as well as to control the creation of new units. Simply put, cryptocurrencies are entries in a public and distributed database that can only be changed by algorithmic consensus, and they remove the need for trusted third-parties for transaction handling and currency emission. The concept closely resembles peer-to-peer networks for file sharing, with an algorithmic monetary policy on top. If you want to learn more about cryptocurrencies, you should definitely look at videos starring Andreas Antonopoulos. He can make very complex concepts very easy to understand. You may also want to read his recollection of  conferences in his book, <em class="calibre19">The Internet of Money, by </em><em class="calibre19">Merkle Bloom LLC, 2016</em>.</p>
<p class="calibre2">Cryptocurrencies are being heavily developed nowadays to offer many innovative features that will have disruptive effects during upcoming years, but for now, they are mostly used for buying goods and investing. Every transaction consists of the amount of coins transferred, as well as the sender's and recipient’s public keys, also known as wallet addresses. We will use these public keys in the example for this chapter to keep track of how many coins we own, and we will also use CoinMarketCap API (<a href="https://coinmarketcap.com/" class="calibre4">https://coinmarketcap.com/</a>) to keep track of cryptocurrency prices.</p>
<p class="calibre2">Since this will be a complex system, we will use object-oriented programming to modularize it and build it part by part. At the end of the example, we will have a system that can be turned on to start tracking our cryptocurrency assets as well as their prices, and to save the real-time data to disk for later analysis. Later, in <a href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, I<em class="calibre19">mplementing an Efficient Simple Moving Average</em>, we will use this data, in simulated form, to develop various <strong class="calibre1">Simple Moving Average</strong> (<strong class="calibre1">SMA</strong>) implementations to showcase how R code can be improved to become faster, as well as more readable. Finally, in <a href="part0271.html#82E8E0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 10</a>, <em class="calibre19">Adding Interactivity with Dashboards,</em> we will see how to create a modern web application to show the SMAs developed, as well as the data collected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A brief introduction to object-oriented programming</h1>
                
            
            
                
<p class="calibre2">As statisticians and data scientists, we strive to build systems that produce valuable insights. To accomplish this, we normally use two tools—mathematics and computers. This book was developed for people who are comfortable with the mathematics side but feel that their R programming skills need improvement.</p>
<p class="calibre2">Normally, when people with mathematical backgrounds are introduced to programming, they are introduced through a <em class="calibre19">functional approach</em>, which means that they think in terms of algorithms with inputs and outputs, which are implemented as functions. This way of working is intuitive if you come from a mathematical background and are not dealing with high level abstractions, and it is the way we have been working throughout the book up to this point.</p>
<p class="calibre2">This chapter will show a different way of programming called <strong class="calibre1">object-oriented programming</strong>. Object-oriented programming and the object model are powerful and unifying ideas in many fields and can be found in most popular programming languages, R being no exception. In my experience, people who have not had conscious experience with object-oriented programming normally find it confusing at first and don't understand its potential. They see it as more of a hassle than an enabler, and think that it gets in their way when trying to write some code. In this chapter, we will try to distill the object-oriented paradigm in a way that is understandable to people who feel comfortable with a functional approach (not necessarily with functional programming), and we will show you how to implement a small object-oriented system that continuously retrieves live data from cryptocurrency markets and wallets.</p>
<p class="calibre2">Before we start implementing such a system, we need to introduce the concepts that will be used throughout the rest of the example, including the upcoming two chapters. In the following paragraphs, you will find very general descriptions of the concepts behind the object model, which is implemented with object-oriented programming, as well as explanations that will hopefully convince you that this way of programming can be very powerful for certain problems. For a more exhaustive and formal introduction, you should read the excellent book by Booch, Maksimchuck, Engle, Young, Conallen, and Houston, titled, <em class="calibre19">Object-Oriented Analysis and Design With Applications, by Addison-Wesley, 2007</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The purpose of object-oriented programming</h1>
                
            
            
                
<p class="calibre2">The main purpose of object-oriented programming is to efficiently manage complexity. It's a way of organizing code and data such that you can develop well-delimited abstractions with controlled dependencies to evolve a complex system in a controlled manner. These abstractions are called <strong class="calibre1">objects</strong> and they offer behavior in response to messages. The behavior they offer to other objects is cataloged in an interface which is implemented in this object's public methods. Objects request behavior from other objects, and when they do, they are said to depend on them. The messages sent between all these objects and the associated behavior are what make an object-oriented system useful.</p>
<p class="calibre2">Before we go any further, let's explain more about these concepts. An object is an entity in abstract form. For example, integers, cars, dogs, buildings, credit cards, and cryptocurrencies, could all be objects in an object-oriented system. An object is a well-defined idea of something, and we know that different kinds of objects have different kinds of behaviors associated with them, and some of those behaviors require some data, which is normally stored within the object.</p>
<p class="calibre2">For example, the idea of an integer is not associated with any specific number, just as the idea of a car is not associated with any specific model or brand. For those familiar with statistics, think of a random variable as an object, and a realization of that random variable as an instance.</p>
<p class="calibre2">Object-oriented programming is a way of thinking of programs as interactions among objects instead of steps through an algorithm. You can still understand an object-oriented system as a big algorithm with lots of functions calling each other, but for large enough systems this will not be a fruitful or enjoyable process. When dealing with object-oriented systems, you're better off just trying to understand a part of the system by itself and clearly defining how it should communicate with other parts. Trying to fully understand a complex object-oriented system can prove to be quite challenging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Important concepts behind object-oriented languages</h1>
                
            
            
                
<p class="calibre2">There are many ways to implement the object model in object-oriented languages, and the specific ways it is implemented imply different sets of properties for the language. Some of these properties are encapsulation, polymorphism, generics (parametric polymorphism), hierarchies (inheritance and composition), subtyping, and several others. They are powerful, high-level ideas with precise definitions that impose restrictions on how a language should behave. Don't worry too much about them for now; we will explain the necessary ones as we move forward.</p>
<p class="calibre2">An interesting exercise is to find languages that are considered to be object-oriented, yet don't use one or more of these properties. For example, the class concept is unnecessary, as seen with prototype-based languages like JavaScript. Subtyping is also unnecessary, since it doesn't make sense in dynamically typed languages like R or Python. We could go on and on, but you get the idea—a single language that has all of these properties does not exist. Furthermore, the only property that is found in all object-oriented languages is polymorphism. That's why people commonly say that polymorphism is the essence of object-oriented programming.</p>
<p class="calibre2">Any professional object-oriented programmer should understand these properties and have formal experience with languages that implement them. However, in the following paragraphs, we will give a high-level explanation of the most common ones in R's different object models—encapsulation, polymorphism (with and without generics), and hierarchies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encapsulation</h1>
                
            
            
                
<p class="calibre2">Encapsulation is about hiding an object's internals from other objects. As the designer of the C++ language, Bjarne Stroustrup, put it, <em class="calibre19">Encapsulation hides information not to faciliate fraud, but to prevent mistakes</em>. By giving other objects a minimal catalog of messages (public methods) that they can send to an object, we are helping them commit less mistakes and avoid getting their hands in tasks that do not pertain them. This, in turn, helps with decoupling objects from themselves and providing cohesiveness within objects.</p>
<p class="calibre2">A common way to think about encapsulation is like when you go to a restaurant—you message the waiter with what you want, and the waiter then delegates the cooking of what you requested to the restaurant's chef. You have no business in going into the restaurant's kitchen and telling the chef how to cook your meal, and if the chef wants to change the way he cooks a certain dish, she can do so without you having to know about it. It's the same with objects; they should not get inside another object and tell it how to do its job. This sounds simple enough, but in practice, it's very easy to violate this principle. We will talk more about this when we reach the <em class="calibre19">Law of Demeter</em> section later in this chapter. Technically, the process of separating the interface from the implementation is called <strong class="calibre1">encapsulation</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Polymorphism</h1>
                
            
            
                
<p class="calibre2">Polymorphism is perhaps the most powerful feature of object-oriented programming languages, next to their support for abstraction, and it is what distinguishes object-oriented programming from more traditional programming with abstract data types. <strong class="calibre1">Polymorphism</strong> literally means many forms, and that's exactly what it is used for in object-oriented programming. The same name will denote different meanings, depending on the context in which it is used, just as with our natural languages. This allows for much cleaner and understandable abstractions, as well as code.</p>
<p class="calibre2">Loosely speaking, polymorphism can be implemented in two different ways: from inside or from outside objects. When it's implemented from inside objects, each object must provide a definition of how it will deal with a given message. This is the most common method, and you can find it in Java or Python. R is very special in this manner and implements the outside approach, formally know as <strong class="calibre1">generics</strong>, or <strong class="calibre1">parametric polymorphism</strong>. This way of programming can be frustrating for people who have only used the inside approach, but it can be very flexible. The outside approach lets you define a generic method or function for types of objects that you have not yet defined, and may never do. Java and Python can also implement this type of polymorphism, but it's not their nature, just as R can also implement the inside, but it's not its nature, either.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Hierarchies</h1>
                
            
            
                
<p class="calibre2">Hierarchies can be formed in two ways—inheritance and composition. The idea of <strong class="calibre1">inheritance</strong> is to form new classes as specialized versions of old ones. The specialized classes are subclasses and the more general ones are superclasses. This type of relationship is often referred to as an <strong class="calibre1">is-a</strong> type of relationship, since <em class="calibre19">a subclass is a type of the superclass</em>. For example, a lion is a type of animal, so animal would be the superclass and lion the subclass. Another type of relationship is known as the <strong class="calibre1">has-a</strong> relation. This means that one class has instances of another class. For example, a car has wheels. We wouldn't say that wheels are a type of car, so there's no inheritance there, but we would say that they are part of a car, which implies <strong class="calibre1">composition</strong>.</p>
<p class="calibre2">There are cases where it's not so clear whether a relation should be modeled with inheritance or with composition, and in those cases, you should decide to move along with composition. In general, people agree that composition is a much more flexible way of designing a system, and that you should only use inheritance where you must model the specialization of a class. Note that when you design your systems with composition instead of inheritance, your objects take on different roles and they become more tool-like. That's a good thing, because you can easily plug them into each other and replace them as necessary, and you also usually end up with larger numbers of smaller classes.</p>
<p class="calibre2">Now that you understand some fundamental ideas behind object-oriented programming, you may realize the power that combining these ideas gives you. If you have a system that encapsulates behavior and only publicly offers what is needed by others to operate correctly, which can dynamically respond to abstract ideas with correct and concrete actions and allows for concept hierarchies to interact with other concept hierarchies, then you can rest assured that you can manage quite a bit of complexity.</p>
<p class="calibre2">In the following paragraphs, we will explain some more down-to-earth concepts which are basic building blocks in most object-oriented systems and that you need to understand to be able to follow the code we will develop for the example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Classes and constructors</h1>
                
            
            
                
<p class="calibre2">Objects must be defined in some way so that we can generate specific instances from them. The most common way to provide those definitions is through classes. A <strong class="calibre1">class</strong> is a piece of code that provides the definition for an object, including the behavior it offers in response to messages from other objects, as well as the internal data it needs to provide that behavior. The behavior for a class is implemented in its methods. More on this in the next section.</p>
<p class="calibre2">Classes must be created at some point, and that's where constructors come into play. The vast majority of the time, when you create an instance of a class, you will want it to contain some data about itself. That data is assigned to the class when it's created through its constructor. Specifically, a <strong class="calibre1">constructor</strong> is a function whose job is to create an instance of a class with a specific set of data. As you know, that data should be kept inside the object, and other objects should not interact with this data directly. Instead, the object should offer public methods that other objects may use to get the data or behavior they need.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Public and private methods</h1>
                
            
            
                
<p class="calibre2"><strong class="calibre1">Methods</strong> are functions contained within classes, and in general, they will be either public or private. In general, methods have access to classes' data (which should be encapsulated away from other objects), as well as their public and private methods.</p>
<p class="calibre2"><strong class="calibre1">Public methods</strong> are visible to other objects and should be as stable as possible since other objects may come to depend on them. If you change them, you may unexpectedly break another object's functionality. <strong class="calibre1">Private methods</strong> are visible only to the instance itself, which means that other objects cannot (or should not, as is the case with R) call these methods directly. Private methods are allowed to change as often as necessary.</p>
<p class="calibre2">Public methods make use of other methods, public or private, to further delegate behavior. This delegation breaks up a problem into very small pieces which are easily understandable, and the programmer reserves the right to modify private methods as she sees fit. Other objects should not depend on them.</p>
<p class="calibre2">Note that technically, only public methods exist in R. Under one of R's object models you can hide methods and under another you can put them in a different environment, but that does not make them inaccessible, as the case would be with private methods in other languages. Derived from that, we also don't touch on the concept of protected methods, which are methods that are visible to a class and its subclasses.</p>
<p>Even if there are technically no private methods in R, we will program as if there were. Not having some type of compiler or error-checking mechanism to tell you that you're accessing private methods when you shouldn't is not an excuse for doing so. You should always be producing high quality code, even if not explicitly enforced by language mechanisms.</p>
<p class="calibre2">What we said previously implies that you should make your objects as private as possible to keep them cohesive and decoupled, which are fancy terms for self-contained and independent. In other words, try to reduce the number of methods in your objects as much as possible. Of course, cohesiveness and decoupleness are far more general ideas than just reducing the number of private methods, but it's a good start.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Interfaces, factories, and patterns in general</h1>
                
            
            
                
<p class="calibre2">An <strong class="calibre1">interface </strong>is the part of a class that is made public for other objects to use. Specifically, it's a set of definitions for the public methods of a class. Of course, the more public methods an object has, the more responsibilities and the less flexibility it has towards the outside world. Note that the interface does not provide any details about implementation; it's just a contract which defines what inputs and what outputs are expected when a method is called.</p>
<p class="calibre2">Sometimes, you want to give yourself the flexibility of changing the object for a given task according to context. You know that as long as the interfaces for the objects you want to interchange are the same, everything should be fine (of course, this assumes that the programmers implement said interfaces correctly). If you don't plan for it in advance, switching these objects can be a difficult task. That's where factories come into play. A factory is a way to choose, at runtime and according to context, which object to use from a set of predefined options.</p>
<p class="calibre2"><strong class="calibre1">Factories</strong> basically work as <kbd class="calibre9">if</kbd> statements that choose which class to use for a task based on some condition. They are a way of investing a little more effort today so that you save yourself quite a bit of effort later, when you decide to use a different object for the same interface. They should be used where you anticipate you will be using different kinds of objects in the future.</p>
<p class="calibre2">Factories are one of many know <strong class="calibre1">patterns</strong> for object-oriented programming. These patterns are developed by people with a lot of experience on design decisions, and, as such, they know what solutions can be generally good for certain types of problems. Documenting these patterns is very useful and allows many people to save a lot of time and effort by not having to reinvent the wheel in their own context. A great source for some fundamental object-oriented patterns can be found in Gamma, Vlissides, Johnson, and Helmfamous's famous, <em class="calibre19">Design Patterns: Elements of Reusable Object-Oriented Software</em>, by Addison-Wesley, 1994. We encourage the reader to study these patterns, as they will surely prove useful at some point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Introducing three object models in R – S3, S4, and R6</h1>
                
            
            
                
<p class="calibre2">Now that you have a basic understanding of general object-oriented concepts, we will dig into R's own object models. There are two main sources of confusion when doing object-oriented programming in R. Before we start developing code, we will explain what these sources of confusion are. After we do, we will develop a small example to illustrate inheritance, composition, polymorphism, and encapsulation in R's S3, S4, and R6 object models. The same example will be used for all three models so that the reader can pinpoint precise differences. Specifically, we will model a <kbd class="calibre9">Square</kbd> inheriting from a <kbd class="calibre9">Rectangle</kbd>, which is in turn composed with a <kbd class="calibre9">Color</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The first source of confusion – various object models</h1>
                
            
            
                
<p class="calibre2">The way you work with object-oriented programming in R is different from what you may see in other languages, such as Python, Java, C++, and many others. For the most part, these languages have a single object model that all people use. In the case of R, note that we have been writing object models, in plural. That's because R is a very special language and it has various ways of implementing object-oriented systems. Specifically, R has the following object models as of this book's writing—S3, S4, Reference Classes, R6, and Base Types. In the upcoming sections, we will dig deeper into the S3, S4, and R6 models. Now, we will briefly touch on Reference Classes and Base Types.</p>
<p class="calibre2"><strong class="calibre1">Reference Classes</strong> (<strong class="calibre1">RC</strong>) is the object-model in R that does not require external libraries and is most similar to the well-known object model found in Python, Java, or C++. It implements message-passing as those languages do, meaning that methods belong to classes, not to functions, and objects are mutable, meaning that an instance's data may change in place instead of producing copies with the modified data. We will not dig deeper into this object model, since R6 seems to be a cleaner implementation of such a model. However, R6 does require an external package, as we will see later, which is not a problem, and it is therefore preferred.</p>
<p class="calibre2">Base types are not exactly an object model, per se. They are C implementations that work in R's background and are used to develop the other object models on top of them. Only R's core development team may add new classes to this model, and they very rarely do so (many years can pass before they do). Their usage is very advanced, and we will not dig deeper into them, either.</p>
<p class="calibre2">The decision of what object model to use is an important one, and we will touch more on this after we have shown how to work with them. In general, it will come down to a trade-off between flexibility, formality, and code cleanness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The second source of confusion – generic functions</h1>
                
            
            
                
<p class="calibre2">Another big difference with popular object-oriented languages like the ones mentioned before is that R implements parametric polymorphism, also known as generic functions, which implies that methods belong to functions, not classes. <strong class="calibre1">Generic functions</strong> allow the same name to be used for many different functions, with many different sets of arguments, from many different classes. This means that the syntax to call a class's method is different from the normally chained syntax you find in other languages (normally implemented with a "<kbd class="calibre9">.</kbd>" (dot) between a class and the method we want to call), which is called <strong class="calibre1">message-passing</strong>.</p>
<p class="calibre2">R's method calls look just like function calls, and R must know which names require simple function calls and which names require method calls. If you read the previous sections, you should understand why this is important. R must have a mechanism to distinguish what it's supposed to do. That mechanism is called <strong class="calibre1">generic functions</strong>. By using generic functions, we register certain names to be treated as methods in R, and they act as dispatchers. When we call registered generic functions, R will look into a chain of attributes in the object that is being passed in the call, and will look for functions that match the method call for that object's type; if it finds one, it will call it.</p>
<p class="calibre2">You may have noted that the <kbd class="calibre9">plot()</kbd> and <kbd class="calibre9">summary()</kbd> functions may return different results, depending on the objects that are being passed to them (for example, a data frame or a linear model instance). That's because those are generic functions that implement polymorphism. This way of working provides simple interfaces for users, which can make their tasks much simpler. For instance, if you are exploring a new package and you get some kind of result at some point derived from the package, try calling <kbd class="calibre9">plot(result)</kbd>, and you may be surprised to get some kind of plot that makes sense. This is not common in other languages.</p>
<p class="calibre2">When doing object-oriented programming with R's S3 and S4 models, keep in mind that you should not call methods directly, but should declare corresponding generic functions and call those instead. This may be a bit confusing at first, but it's just one of R's unique characteristics that you get used to with time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The S3 object model</h1>
                
            
            
                
<p class="calibre2">As you may recall, the R language is derived from the S language. S's object model evolved over time, and its third version introduced <strong class="calibre1">class attributes</strong>, which allowed for the S3 object model we find in R today. It is still the object model in R, and most of R's own built-in classes are of the S3 type. It's a valid and very flexible object model, but it's very different from what people who come from other object-oriented languages are used to.</p>
<p class="calibre2">S3 is the least formal object model, so it's lacking in some key respects. For example, S3 does not offer formal class definitions, which implies that there's no formal concept of inheritance or encapsulation, and polymorphism is achieved through generics. It's clear that its functionality is limited in some key respects, but the programmer has quite a bit of flexibility. However, as Hadley Wickham put it in <em class="calibre19">Advanced R, by Chapman and Hall, 2014:</em></p>
<p>"S3 has a certain elegance in its minimalism: you can't take away any part of it and still have a useful object-oriented system."</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Classes, constructors, and composition</h1>
                
            
            
                
<p class="calibre2">The idea of an object is really just to bundle data and corresponding methods together. Lists in R are well-suited to implement this, since they can contain different data types, even functions, which are first class objects that can be assigned or returned like any other. In fact, we can literally create objects of a new class in R by taking a list and simply setting the class attribute of the list to a new value, which is how we create classes in S3.</p>
<p class="calibre2">Instead of providing definitions for S3 classes, we provide constructors. These constructors have the responsibility of creating objects (a string which has the parameter passed in the case of <kbd class="calibre9">S3Color</kbd> and a list in the case of <kbd class="calibre9">S3Rectangle</kbd>) and assigning a string to their class attributes. These objects are then returned, and they represent the classes we will be using. In the case of the rectangle, our constructor receives the length, orthogonal sides, and the name of its color. The color constructor only receives the name of the color:</p>
<pre class="mce-root">color_constructor &lt;- function(color) {<br class="title-page-name"/>    class(color) &lt;- "S3Color"<br class="title-page-name"/>    return(color)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>rectangle_constructor &lt;- function(a, b, color) {<br class="title-page-name"/>    rectangle &lt;- list(a = a, b = b, color = color_constructor(color))<br class="title-page-name"/>    class(rectangle) &lt;- "S3Rectangle"<br class="title-page-name"/>    return(rectangle)<br class="title-page-name"/>}</pre>
<p class="calibre2">As you can see, instead of assigning the <kbd class="calibre9">color</kbd> string which is passed as a parameter to the <kbd class="calibre9">rectangle_constructor()</kbd> function directly in the <kbd class="calibre9">color</kbd> element of the <kbd class="calibre9">rectangle</kbd> list, we use the <kbd class="calibre9">color_constructor()</kbd> function to provide a <kbd class="calibre9">Color</kbd> class, not only a string. You should do this if you will add behavior to the color abstraction, as we will do.</p>
<p class="calibre2">Now, we can create an <kbd class="calibre9">S3_rectangle</kbd> by calling the <kbd class="calibre9">rectangle_constructor()</kbd>, and we can print its class, which is shown to be <kbd class="calibre9">S3Rectangle</kbd>, just as we expected. Also, if you print the <kbd class="calibre9">S3_rectangle</kbd> structure, you will see that it contains the two sides for the rectangle definition, the color class, and the attribute class names:</p>
<pre class="mce-root">S3_rectangle &lt;- rectangle_constructor(2, 3, "blue")<br class="title-page-name"/>class(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Rectangle"</strong><br class="title-page-name"/><br class="title-page-name"/>str(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; List of 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $ a : num 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $ b : num 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $ color:Class 'S3Color' chr "blue"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; - attr(*, "class")= chr "S3Rectangle"</strong></pre>
<p class="calibre2">Sometimes, you will see that we have added a prefix to an object with the name of the object model we're using (<kbd class="calibre9">S3</kbd> in this case). For example, <kbd class="calibre9">S3Color</kbd> and <kbd class="calibre9">S3Rectangle</kbd>. When you see that, it means that the particular name clashes with the corresponding object in another object model, and we need to differentiate them. If you don't do this, you may encounter quite confusing and difficult to diagnose bugs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Public methods and polymorphism</h1>
                
            
            
                
<p class="calibre2">To define a method for a class, we need to use the <kbd class="calibre9">UseMethod()</kbd> function to define a hierarchy of functions. It will tell R to look for a function whose prefix matches the current function and for a suffix in order from the vector of class names of the object being passed. The names of the methods have two parts, separated by a "<kbd class="calibre9">.</kbd>", where the prefix is the function name and the suffix is the name of a class. As you can see, S3 generic functions work by naming conventions, not by explicitly registering methods for different classes.</p>
<p class="calibre2">We start by creating an <kbd class="calibre9">S3area</kbd> method for the <kbd class="calibre9">S3Rectangle</kbd> class, and we do so by creating a function named <kbd class="calibre9">S3area.S3Rectangle</kbd>. The <kbd class="calibre9">UseMethod()</kbd> function will make sure that the <kbd class="calibre9">S3area.S3Rectangle</kbd> function receives an object of class <kbd class="calibre9">S4Rectangle</kbd>, so inside of such a function, we can make use of the class's internals. In this case, we will take the lengths <kbd class="calibre9">a</kbd> and <kbd class="calibre9">b</kbd> and multiply them together:</p>
<pre class="mce-root">S3area.S3Rectangle &lt;- function(rectangle) {<br class="title-page-name"/>    return(rectangle$a * rectangle$b)<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that we can access such objects within the <kbd class="calibre9">rectangle</kbd> object by using the <kbd class="calibre9">$</kbd> operator. This is not restricted to being done within a method, so really, any object can change an S3 object's internals, but just because you can doesn't mean that you should.</p>
<p class="calibre2">Now, we will call the <kbd class="calibre9">S3area</kbd> method as if it were a normal function call, to which we pass the rectangle object we created before, and we should see the area being printed to the console:</p>
<pre class="mce-root">S3area(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; Error in S3area(S3_rectangle): could not find function "S3area"</strong></pre>
<p class="calibre2">What happened? An error? Well, how can R tell that the <kbd class="calibre9">S3area</kbd> function call should actually trigger the <kbd class="calibre9">S3area.S3Rectangle</kbd> method call? For that to happen, we need to register the name with R, and we do so by calling the defining function, which actually uses the <kbd class="calibre9">S3area</kbd> name by itself. This <kbd class="calibre9">S3area</kbd> function receives an object of any type, not necessarily a <kbd class="calibre9">S3Rectangle</kbd>, and uses the <kbd class="calibre9">UseMethod()</kbd> function to tell it that it should look for the <kbd class="calibre9">"S3area"</kbd> method call for that object. In this case, we know that it will only be found for the <kbd class="calibre9">S3Rectangle</kbd> class:</p>
<pre class="mce-root">S3area &lt;- function(object) {<br class="title-page-name"/>    UseMethod("S3area")<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we can call the <kbd class="calibre9">S3area</kbd> method as we did before, but we will get the actual area in this case. This is how you normally create methods with S3:</p>
<pre class="mce-root">S3area(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong></pre>
<p class="calibre2">Now, we will create the <kbd class="calibre9">S3color</kbd> method to return the color object for the rectangle. Since the color object is just a character type, there's nothing more we need to do to somehow parse that object if we just want the characters:</p>
<pre class="mce-root">S3color.S3Rectangle &lt;- function(rectangle) {<br class="title-page-name"/>    return(rectangle$color)<br class="title-page-name"/>}<br class="title-page-name"/>S3color &lt;- function(object) {<br class="title-page-name"/>    UseMethod("S3color")<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we will print the rectangle. As you can see, the <kbd class="calibre9">print()</kbd> call simply shows us the internals of the object and objects contained within it:</p>
<pre class="mce-root">print(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; $a</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $b</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; $color</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"class")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Color"</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"class")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Rectangle"</strong></pre>
<p class="calibre2">We may want to overload this function to provide a different output. To do so, we create <kbd class="calibre9">print.S3Rectangle()</kbd> and simply print a string that will tell us the color of the rectangle, the fact that it's a rectangle, the length for each of its sides, and then its area. Note that both the color and the area are retrieved using the methods we defined before, <kbd class="calibre9">S3Color()</kbd> and <kbd class="calibre9">S3area()</kbd>:</p>
<pre class="mce-root">print.S3Rectangle &lt;- function(rectangle) {<br class="title-page-name"/>    print(paste(<br class="title-page-name"/>        S3color(rectangle), "rectangle:",<br class="title-page-name"/>        rectangle$a, "x", rectangle$b, "==", S3area(rectangle)<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, what should happen if we simply call the <kbd class="calibre9">print()</kbd> function, as we did before with the <kbd class="calibre9">S3area()</kbd> function? We should get an error, shouldn't we? Let's look at the following code:</p>
<pre class="mce-root">print(S3_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue rectangle: 2 x 3 == 6"</strong></pre>
<p class="calibre2">Well, as you can see, we don't. In this case, we actually get the output we hoped we would. The reason is that the <kbd class="calibre9">print()</kbd> function in R is an S3 function which already registered with the <kbd class="calibre9">UseMethod()</kbd> function. That means that our definition <kbd class="calibre9">print.S3Rectangle</kbd> does not need to be registered again, and we can simply use it. That's pretty neat, isn't it? That's one of the big advantages of using parametric polymorphism. We can register functions as method calls that we may or may not end up using at some point in the future in unexpected ways, but they still provide a homogeneous interface for the user.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encapsulation and mutability</h1>
                
            
            
                
<p class="calibre2">Now, we will see how S3 handles mutability and encapsulation. To do so, we will print the <kbd class="calibre9">a</kbd> value in the rectangle, modify it, and print it again. As you can see, we are able to modify it, and from that point on we get a different result, and we do so without any method calls. That's a very risky thing to do, and you should definitely wrap this type of behavior in method calls:</p>
<pre class="mce-root">print(S3_rectangle$a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><br class="title-page-name"/>S3_rectangle$a &lt;- 1<br class="title-page-name"/><br class="title-page-name"/>print(S3_rectangle$a)<strong class="calibre1"><br class="title-page-name"/>#&gt; [1] 1</strong></pre>
<p>Even if you can, never modify an object's internals directly.</p>
<p class="calibre2">The proper way of modifying an object would be through some type of setter function. The <kbd class="calibre9">set_color.S3Rectangle()</kbd> method will be used to modify the rectangle's color, by receiving a <kbd class="calibre9">S3Rectangle</kbd> and a <kbd class="calibre9">new_color</kbd> string, and saving that new string inside of a <kbd class="calibre9">color</kbd> attribute in the rectangle. When you use a method like this, you're being explicit about your intentions, which is a much better way of programming. Of course, we also need to register the method call with R, as shown previously:</p>
<pre class="mce-root">set_color.S3Rectangle &lt;- function(rectangle, new_color) {<br class="title-page-name"/>    rectangle$color &lt;- new_color<br class="title-page-name"/>    return(rectangle)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>set_color &lt;- function(object, new_color) {<br class="title-page-name"/>    UseMethod("set_color")<br class="title-page-name"/>}</pre>
<p class="calibre2">Did you notice our error? Probably not, but it's great if you did! We did this on purpose to show you how easy it is to harm yourself when programming in R. Since R has no type checking, we inadvertently assigned a string where we should have assigned a <kbd class="calibre9">Color</kbd>. This means that the <kbd class="calibre9">color</kbd> attribute in our rectangle will no longer be recognized as a <kbd class="calibre9">Color</kbd> class after we call the <kbd class="calibre9">set_color()</kbd> method; it will be recognized as a string. If your code depends on this object being of the <kbd class="calibre9">Color </kbd> type, it will probably fail in unexpected and confusing ways and will be hard to debug. Be careful when doing assignments. Instead, we should have put <kbd class="calibre9">rectangle$color &lt;- color_constructor(new_color)</kbd> to keep consistency.</p>
<p class="calibre2">While you can change the type of an object, you never should. As Hadley Wickham puts it, <em class="calibre19">R doesn't protect you from yourself: you can easily shoot yourself in the foot. As long as you don't aim the gun at your foot and pull the trigger, you won't have a problem</em>.</p>
<p class="calibre2">Now, we show how the <kbd class="calibre9">set_color()</kbd> method can be used. We will print the rectangle's color, attempt to change it to black, and print it again. As you can see, the change was not persisted in our object. That's because R passes objects by value and not by reference. This simply means that when we modify the rectangle, we are actually modifying a copy of the rectangle, not the rectangle we passed ourselves:</p>
<pre class="mce-root">print(S3color(S3_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"class")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Color"</strong><br class="title-page-name"/><br class="title-page-name"/>set_color(S3_rectangle, "black")<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "black rectangle: 1 x 3 == 3"</strong><br class="title-page-name"/><br class="title-page-name"/>print(S3color(S3_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"class")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Color"</strong></pre>
<p class="calibre2">Did you notice that at the end of the <kbd class="calibre9">set_color.S3Rectangle()</kbd> function, we returned the <kbd class="calibre9">rectangle</kbd>? In other languages that may not be necessary, but in R, we do so to get back the modified object. To persist the changes in our object, we need to actually assign that resulting object into our own <kbd class="calibre9">S3_rectangle</kbd>, and when we do, then we can see that the color change was persisted.</p>
<p class="calibre2">This property is what gives S3 its immutability property. This is very useful when working with functional programming, but can be a bit of a hassle to work with when doing object-oriented programming. Some confusing bugs may come from this property to get you used to working this way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inheritance</h1>
                
            
            
                
<p class="calibre2">S3 classes lack a lot of the structure normally found in other languages. Inheritance is implemented informally, and encapsulation is not enforced by the language, as we have seen before.</p>
<p class="calibre2">To implement inheritance, we will create a <kbd class="calibre9">square_constructor()</kbd> function that will receive the length of the sides in <kbd class="calibre9">a</kbd> and the name of the color. We will then use the <kbd class="calibre9">rectangle_construtor()</kbd> and send <kbd class="calibre9">a</kbd> for both lengths (making it a square), and will also send the color. Then, we will add the <kbd class="calibre9">S3Square</kbd> class, and finally, return the created object:</p>
<pre class="mce-root">square_constructor &lt;- function(a, color) {<br class="title-page-name"/>    square &lt;- rectangle_constructor(a, a, color)<br class="title-page-name"/>    class(square) &lt;- c("S3Square", class(square))<br class="title-page-name"/>    return(square)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we will create a square and print its classes. As you can see, it has the <kbd class="calibre9">S3Square</kbd> and <kbd class="calibre9">S3Rectangle</kbd> classes assigned, in order, and when we use the <kbd class="calibre9">print()</kbd> method on it, we actually get the print functionality from the <kbd class="calibre9">S3Rectangle</kbd> class, which is expected since we're signaling the inheritance:</p>
<pre class="mce-root">S3_square &lt;- square_constructor(4, "red")<br class="title-page-name"/><br class="title-page-name"/>class(S3_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S3Square" "S3Rectangle"</strong><br class="title-page-name"/><br class="title-page-name"/>print(S3_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "red rectangle: 4 x 4 == 16"</strong></pre>
<p class="calibre2">If we want to provide a specific print functionality for the square, we must overwrite the <kbd class="calibre9">print()</kbd> method with our own definition for <kbd class="calibre9">S3Square</kbd> classes, as we now do. The function is exactly the same as before, but we use the word <kbd class="calibre9">"square"</kbd> instead of <kbd class="calibre9">"rectangle"</kbd>.</p>
<pre class="mce-root">print.S3Square &lt;- function(square) {<br class="title-page-name"/>    print(paste(<br class="title-page-name"/>        S3color(square), "square:",<br class="title-page-name"/>        square$a, "x", square$b, "==", S3area(square)<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, when we print, we can see that the correct method is being used, because we see the word <kbd class="calibre9">"square"</kbd> in the output. Note that we did not have to re-register the <kbd class="calibre9">print()</kbd> method with the <kbd class="calibre9">UseMethod()</kbd> function, since we had already done so:</p>
<pre class="mce-root">print(S3_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "red square: 4 x 4 == 16"</strong></pre>
<p class="calibre2">Finally, remember that if the class attribute is a vector with more than one element, then the first element is interpreted as the class of the object, and the following elements are interpreted as classes that the object inherits from. That makes inheritance a property of objects, not classes, and order is important.</p>
<p class="calibre2">If we had instead written <kbd class="calibre9">class(square) &lt;- c(class(square), "S3Square")</kbd> in the <kbd class="calibre9">square_constructor()</kbd> function, then even after creating the <kbd class="calibre9">print.S3Square()</kbd> function, we would still see the <kbd class="calibre9">print()</kbd> method calling the <kbd class="calibre9">print.S3Rectangle()</kbd> function. Be careful with this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The S4 object model</h1>
                
            
            
                
<p class="calibre2">Some programmers feel that S3 does not provide the safety normally associated with object-oriented programming. In S3, it is very easy to create a class, but it can also lead to very confusing and hard to debug code when not used with great care. For example, you could easily misspell a name, and R would not complain. You could easily change the class to an object, and R would not complain, either.</p>
<p class="calibre2">S4 classes were developed after S3, with the goal of adding safety. S4 provides protection, but it also introduces a lot of verbosity to provide that safety. The S4 object model implements most features of modern object-oriented programming languages—formal class definitions, inheritance, polymorphism (parametric), and encapsulation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Classes, constructors, and composition</h1>
                
            
            
                
<p class="calibre2">An S4 class is created using the <kbd class="calibre9">setClass()</kbd> function. At a minimum, the name of the <kbd class="calibre9">Class</kbd> and its attributes, formally known as <strong class="calibre1">slots</strong> in S4, must be specified. The slots are specified in with the <kbd class="calibre9">representation()</kbd> function, and a neat feature is that you specify the type expected for such attributes. This helps a bit with type-checking.</p>
<p class="calibre2">There are other features built-in that we are not going to look at here. For example, you could provide a function that verifies the object is consistent (has not been manipulated in some unexpected way). You can also specify default values, in a parameter called the <kbd class="calibre9">prototype</kbd>. If you want these features in S3, you can also implement them yourself, but they don't come as built-in features. S4 is regarded as a powerful object model, and you should definitely study it more in depth by browsing its documentation.</p>
<p>All S4 related code is stored in the methods package. This package is always available when you're running R interactively, but may not be available when running R in batch mode. For this reason, it's a good idea to include an explicit <kbd class="calibre21">library(methods)</kbd> call whenever you're using S4.</p>
<p class="calibre2">As you can see, the conceptual difference from S3 classes is that here, we actually specify the type of object for each slot. Other changes are more syntactic than conceptual. Note that you may use the name of another S4 class for one of the slots, as we do in the case of <kbd class="calibre9">color</kbd> for the <kbd class="calibre9">S4Rectangle</kbd>. This is how you can achieve composition with S4:</p>
<pre class="mce-root">library(methods)<br class="title-page-name"/><br class="title-page-name"/>setClass(<br class="title-page-name"/>    Class = "S4Color",<br class="title-page-name"/>    representation = representation(<br class="title-page-name"/>        color = "character"<br class="title-page-name"/>    )<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>setClass(<br class="title-page-name"/>    Class = "S4Rectangle",<br class="title-page-name"/>    representation = representation(<br class="title-page-name"/>        a = "numeric",<br class="title-page-name"/>        b = "numeric",<br class="title-page-name"/>        color = "S4Color"<br class="title-page-name"/>     )<br class="title-page-name"/>)</pre>
<p class="calibre2">The constructor is built automatically for you with a call to the <kbd class="calibre9">new()</kbd> function. As you can see, you simply need to pass through the name of the class you're instantiating and the values that should be assigned to the slots:</p>
<pre class="mce-root">S4_rectangle &lt;- new(<br class="title-page-name"/>    "S4Rectangle",<br class="title-page-name"/>    a = 2,<br class="title-page-name"/>    b = 3,<br class="title-page-name"/>    color = new("S4Color", color = "blue")<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>class(S4_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4Rectangle"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"package")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] ".GlobalEnv"</strong><br class="title-page-name"/><br class="title-page-name"/>str(S4_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; Formal class 'S4Rectangle' [package ".GlobalEnv"] with 3 slots</strong><br class="title-page-name"/><strong class="calibre1">#&gt; ..@ a : num 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt; ..@ b : num 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt; ..@ color:Formal class 'S4Color' [package ".GlobalEnv"] with 1 slot</strong><br class="title-page-name"/><strong class="calibre1">#&gt; .. .. ..@ color: chr "blue"</strong></pre>
<p class="calibre2">As we did before, we retrieve the class for the object and print it. When we print it, we can see a structure that contains some <kbd class="calibre9">@</kbd> symbols. Those are the operators used to access the slots (instead of the <kbd class="calibre9">$</kbd> operator for S3). You can also see the nested slot for the <kbd class="calibre9">color</kbd> attribute of the <kbd class="calibre9">Color</kbd> class:</p>
<p>Some slot names are forbidden due to the fact that they are reserved keywords in R. Forbidden names include <kbd class="calibre21">class</kbd>, <kbd class="calibre21">comment</kbd>, <kbd class="calibre21">dim</kbd>, <kbd class="calibre21">dimnames</kbd>, <kbd class="calibre21">names</kbd>, <kbd class="calibre21">row.names</kbd>, and <kbd class="calibre21">tsp</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Public methods and polymorphism</h1>
                
            
            
                
<p class="calibre2">Since S4 also uses parametric polymorphism (methods belong to functions, not classes) and we have already explained it a couple of times before, we are going to just point out the differences with S3 at this point. First, instead of using the <kbd class="calibre9">UseMethod()</kbd> function to register methods with R, we use the <kbd class="calibre9">setGeneric()</kbd> function, with the name of the method, and a function that calls the <kbd class="calibre9">standardGeneric()</kbd> function inside. This will provide the dispatch mechanism for S4 objects.</p>
<p class="calibre2">To actually create a method, instead of using a naming convention as we do in S3, we actually pass the name of the class and the method to the <kbd class="calibre9">setMethod()</kbd> function, as well as the function that should be used as a method. Second, the order there matters. If you call the <kbd class="calibre9">setMethod()</kbd> function before you call the <kbd class="calibre9">setGeneric()</kbd> method, your dispatch mechanism won't work. We did that in S3, but here, we need to reverse the order. Finally, note that we access object attributes (slots) with the <kbd class="calibre9">@</kbd> symbol, as we mentioned before.</p>
<p class="calibre2">For completeness in the example so that the reader may compare the code for all three examples side by side, we now show how to implement the same code we showed for the S3 case:</p>
<pre class="mce-root">setGeneric("S4area", function(self) {<br class="title-page-name"/>    standardGeneric("S4area")<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4area"</strong><br class="title-page-name"/><br class="title-page-name"/>setMethod("S4area", "S4Rectangle", function(self) {<br class="title-page-name"/>    return(self@a * self@b)<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4area"</strong><br class="title-page-name"/><br class="title-page-name"/>S4area(S4_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong><br class="title-page-name"/><br class="title-page-name"/>setGeneric("S4color", function(self) {<br class="title-page-name"/>    standardGeneric("S4color")<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4color"</strong><br class="title-page-name"/><br class="title-page-name"/>setMethod("S4color", "S4Rectangle", function(self) {<br class="title-page-name"/>    return(self@color@color)<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4color"</strong></pre>
<p class="calibre2">If you use <kbd class="calibre9">print()</kbd> on <kbd class="calibre9">S4_rectangle</kbd>, you will see that it's recognized to be of a certain type, and it will show its slots:</p>
<pre class="mce-root">print(S4_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; An object of class "S4Rectangle"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Slot "a":</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Slot "b":</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] 3</strong><br class="title-page-name"/><strong class="calibre1">#&gt;</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Slot "color":</strong><br class="title-page-name"/><strong class="calibre1">#&gt; An object of class "S4Color"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; Slot "color":</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong></pre>
<p class="calibre2">If we want to change this output, we override this method with our own, as we did in the case of S3. However, if we do, we will have the <kbd class="calibre9">print()</kbd> function defined to work with S4 objects, and it will stop working for objects from other object models. We encourage you to try it yourself by changing the code below to use the <kbd class="calibre9">print</kbd> method call instead of the <kbd class="calibre9">S4print</kbd> name. As you can see, we are using the same overriding mechanism as before, so we will skip its explanation:</p>
<pre class="mce-root">setGeneric("S4print", function(self) {<br class="title-page-name"/>    standardGeneric("S4print")<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4print"</strong><br class="title-page-name"/><br class="title-page-name"/>setMethod("S4print", "S4Rectangle", function(self) {<br class="title-page-name"/>    print(paste(<br class="title-page-name"/>        S4color(self), "rectangle:",<br class="title-page-name"/>        self@a, "x", self@b, "==", S4area(self)<br class="title-page-name"/>    ))<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4print"</strong></pre>
<p class="calibre2">Now, we may use the <kbd class="calibre9">S4print()</kbd> method to print the desired output, as you can see in the following code:</p>
<pre class="mce-root">S4print(S4_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue rectangle: 2 x 3 == 6"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encapsulation and mutability</h1>
                
            
            
                
<p class="calibre2">Now, we will take a look at the encapsulation and mutability concepts in S4. First, note that we are using the <kbd class="calibre9">print()</kbd> and not the <kbd class="calibre9">S4print()</kbd> method, because we are printing specific slots from <kbd class="calibre9">S4_rectangle</kbd>. As you can see, if we're not careful, we can still assign values directly to the internals of the object. Again, you should not do this.</p>
<p class="calibre2">Also note that if we use the method <kbd class="calibre9">S4color()</kbd> that we created before to encapsulate the access to the <kbd class="calibre9">color</kbd> attribute, we get an error telling us that the <kbd class="calibre9">S4color&lt;-</kbd> function could not be found. That hints to us that we can create such a function, and we can:</p>
<pre class="mce-root">print(S4_rectangle@a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 2</strong><br class="title-page-name"/><br class="title-page-name"/>S4_rectangle@a &lt;- 1<br class="title-page-name"/><br class="title-page-name"/>print(S4_rectangle@a)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 1<br class="title-page-name"/></strong><br class="title-page-name"/>print(S4color(S4_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong><br class="title-page-name"/><br class="title-page-name"/>S4color(S4_rectangle) &lt;- "black"<br class="title-page-name"/><strong class="calibre1">#&gt; Error in S4color(S4_rectangle) &lt;- "black":</strong> <br class="title-page-name"/>      <strong class="calibre1"> could not find function "S4color&lt;-"</strong><br class="title-page-name"/><br class="title-page-name"/>print(S4color(S4_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong></pre>
<p class="calibre2">To create a function that will encapsulate access to an object's attribute, we can use the <kbd class="calibre9">setReplaceMethod()</kbd> function, just as we did with the <kbd class="calibre9">setMethod()</kbd> function before. Note that the name of the method we are passing to the <kbd class="calibre9">setGeneric()</kbd> function is the one that was hinted to us in R's error, which is the name of the slot followed by the normal assignment operator in R, <kbd class="calibre9">&lt;-</kbd>. Also note that there's no space between the name of the variable and symbols for the assignment operator.</p>
<p class="calibre2">Finally, note that we made sure to create an object of type <kbd class="calibre9">S4Color</kbd> when assigning a new value to the <kbd class="calibre9">color</kbd> slot. If you try to simply assign a string as we did with the S3 class, you will get an error letting you know you're trying to do something you shouldn't be doing. This is a big advantage when working with S4, as it can prevent you from committing some unexpected mistakes:</p>
<pre class="mce-root">setGeneric("S4color&lt;-", function(self, value) {<br class="title-page-name"/>    standardGeneric("S4color&lt;-")<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4color&lt;-"</strong><br class="title-page-name"/><br class="title-page-name"/>setReplaceMethod("S4color", "S4Rectangle", function(self, value) {<br class="title-page-name"/>    self@color &lt;- new("S4Color", color = value)<br class="title-page-name"/>    return(self)<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4color&lt;-"</strong></pre>
<p class="calibre2">Once we create such a method, we can use it to assign to the color object directly, in an encapsulated manner, which is much better than manipulating the slots directly. As you can see, the color change is persisted:</p>
<pre class="mce-root">print(S4color(S4_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong><br class="title-page-name"/><br class="title-page-name"/>S4color(S4_rectangle) &lt;- "black"<br class="title-page-name"/><br class="title-page-name"/>print(S4color(S4_rectangle))<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "black"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inheritance</h1>
                
            
            
                
<p class="calibre2">Creating a subclass is easy; we simply need to call the <kbd class="calibre9">setClass()</kbd> function as we did before, and send the <kbd class="calibre9">contains</kbd> parameter with the name of the class it will inherit from. S4 supports multiple inheritance, but it's not something we're going to look at. The interested reader is encouraged to look into the documentation.</p>
<p class="calibre2">An interesting feature of S4 classes is that if a class extends one of R's basic types, there will be a slot called <kbd class="calibre9">.Data</kbd> containing the data from the basic object type. Code that works on the basic object type will work directly on the <kbd class="calibre9">.Data</kbd> part of the object, so it makes our programming a bit easier:</p>
<pre class="mce-root">setClass("S4Square", contains = "S4Rectangle")</pre>
<p class="calibre2">Note that when we instantiate the <kbd class="calibre9">S4Square</kbd> class, we will need to pass both attributes for the length and make sure they are the same. As we can see, the class of the object is identified correctly, and the polymorphic <kbd class="calibre9">S4print()</kbd> method we defined previously works fine:</p>
<pre class="mce-root">S4_square &lt;- new ("S4Square", <br class="title-page-name"/>                  a = 4, b = 4, <br class="title-page-name"/>                  color = new("S4Color", color = "red"))<br class="title-page-name"/><br class="title-page-name"/>class(S4_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4Square"</strong><br class="title-page-name"/><strong class="calibre1">#&gt; attr(,"package")</strong><br class="title-page-name"/><strong class="calibre1">#&gt; [1] ".GlobalEnv"</strong><br class="title-page-name"/><br class="title-page-name"/>S4print(S4_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "red rectangle: 4 x 4 == 16"</strong></pre>
<p class="calibre2">Again, for completeness, we override the <kbd class="calibre9">S4print()</kbd> method with one that uses the <kbd class="calibre9">"square"</kbd> word instead, and we can see that it works as expected:</p>
<pre class="mce-root">setMethod("S4print", "S4Square", function(self) {<br class="title-page-name"/>    print(paste(<br class="title-page-name"/>        S4color(self), "square:",<br class="title-page-name"/>        self@a, "x", self@b, "==", S4area(self)<br class="title-page-name"/>    ))<br class="title-page-name"/>})<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "S4print"<br class="title-page-name"/></strong><br class="title-page-name"/>S4print(S4_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "red square: 4 x 4 == 16"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The R6 object model</h1>
                
            
            
                
<p class="calibre2">S3 and S4 are really just ways to implement polymorphism for static functions. The R6 package provides a type of class which is similar to R's Reference Classes, but it is more efficient and doesn't depend on S4 classes and the methods package as RCs do.</p>
<p class="calibre2">When RCs were introduced, some users, following the names of R's existing class systems S3 and S4, called the new class system R5. Although RCs are not actually called R5 nowadays, the name of this package and its classes follows that pattern.</p>
<p class="calibre2">Despite being first released over three years ago, R6 isn't widely known. However, it is widely used. For example, it's used within Shiny (the focus of the last chapter in this book) and to manage database connections in the dplyr package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Classes, constructors, and composition</h1>
                
            
            
                
<p class="calibre2">Classes in R6 are created with the <kbd class="calibre9">R6Class()</kbd> function, and we pass the name of the class and lists of public and private objects. These objects can be either attributes or methods. As you can see, building a class definition in R6 produces much cleaner code, which is put together in a single definition instead of the step-by-step process used in S3 and S4. This approach is more like what you can find in other popular languages.</p>
<p class="calibre2">You may specify how the constructor should behave by using the <kbd class="calibre9">initialize</kbd> method. This specific method will be called when an instance of the class is created.</p>
<p class="calibre2">There are two important differences between our names in the following definition and what we used for the S3 and S4 examples. In this case, we call the print method <kbd class="calibre9">own_print()</kbd> and the <kbd class="calibre9">color</kbd> property <kbd class="calibre9">own_color</kbd>. The reason for the former is that R would be confused between the <kbd class="calibre9">color()</kbd> method and the <kbd class="calibre9">color</kbd> attribute. To avoid errors, we can change the name for one of them, and to keep our public interface the same, we decide to change the private attribute in this case. The reason for <kbd class="calibre9">own_print()</kbd> will be explained ahead:</p>
<pre class="mce-root">library(R6)<br class="title-page-name"/>R6Rectangle &lt;- R6Class(<br class="title-page-name"/>    "R6Rectangle",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(a, b, color) {<br class="title-page-name"/>            private$a &lt;- a<br class="title-page-name"/>            private$b &lt;- b<br class="title-page-name"/>            private$own_color &lt;- color<br class="title-page-name"/>        },<br class="title-page-name"/>        area = function() {<br class="title-page-name"/>            private$a * private$b<br class="title-page-name"/>        },<br class="title-page-name"/>        color = function() {<br class="title-page-name"/>            private$own_color<br class="title-page-name"/>        },<br class="title-page-name"/>        set_color = function(new_color) {<br class="title-page-name"/>            private$own_color &lt;- new_color<br class="title-page-name"/>        },<br class="title-page-name"/>        own_print = function() {<br class="title-page-name"/>            print(paste(<br class="title-page-name"/>                self$color(), "rectangle:",<br class="title-page-name"/>                private$a, "x", private$b, " == ", self$area()<br class="title-page-name"/>            ))<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        a = NULL,<br class="title-page-name"/>        b = NULL,<br class="title-page-name"/>        own_color = NULL<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">To create an instance of a class, we call the <kbd class="calibre9">new()</kbd> method in the class object. We can pass some parameters, and if we do, they will be used by the <kbd class="calibre9">initialize</kbd> function defined for the class.</p>
<p class="calibre2">As you can see, if we use <kbd class="calibre9">print()</kbd> on the <kbd class="calibre9">R6_rectangle</kbd> object, we see a nice output letting us know what methods and attributes are public and private, as well as some extra information about them, like the fact that the default <kbd class="calibre9">clone()</kbd> method (used for making copies of an R6 object) is set to shallow copying instead of deep copying. We won't go into the details of what these concepts are, but the interested reader is encouraged to look into pass-by-reference versus pass-by-value mechanics.</p>
<p class="calibre2">If we had defined a <kbd class="calibre9">print()</kbd> method within our class, then the <kbd class="calibre9">print(R6_rectangle)</kbd> would have used that function by default. Note that this would be syntactically different from calling the method directly by executing a command like <kbd class="calibre9">R6_rectangle$print()</kbd>, but R is intelligent enough to know that if you define a <kbd class="calibre9">print()</kbd> method in your class, it's probably because you want to use it when using the <kbd class="calibre9">print()</kbd> function on the object. If that's not the case, then you should change the name of your custom print function, as we do in the case of the <kbd class="calibre9">own_print()</kbd> method name:</p>
<pre class="mce-root">R6_rectangle &lt;- R6Rectangle$new(2, 3, "blue")<br class="title-page-name"/><br class="title-page-name"/>class(R6_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "R6Rectangle" "R6"</strong><br class="title-page-name"/><br class="title-page-name"/>print(R6_rectangle)<br class="title-page-name"/><strong class="calibre1">#&gt; &lt;R6Rectangle&gt;<br class="title-page-name"/>#&gt; Public:<br class="title-page-name"/>#&gt;     area: function ()<br class="title-page-name"/>#&gt;     clone: function (deep = FALSE)<br class="title-page-name"/>#&gt;     color: function ()<br class="title-page-name"/>#&gt;     initialize: function (a, b, color)<br class="title-page-name"/>#&gt;     own_print: function ()<br class="title-page-name"/>#&gt;     set_color: function (new_color)<br class="title-page-name"/>#&gt; Private:<br class="title-page-name"/>#&gt;     a: 2<br class="title-page-name"/>#&gt;     b: 3<br class="title-page-name"/>#&gt;     own_color: blue<br class="title-page-name"/></strong></pre>
<p class="calibre2">As you can see from the output, in the case of R6 classes, we have two classes instead of one. We have the class we defined ourselves, and we also have the general <kbd class="calibre9">R6</kbd> class added for us for the object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Public methods and polymorphism</h1>
                
            
            
                
<p class="calibre2">We have already defined the methods we want in the previous piece of code, so for completeness, we will only show how to call these methods now. As you can see, you simply use the <kbd class="calibre9">$</kbd> operator to access a public attribute or a public method, and if it's a method, you add the parentheses at the end (surrounding any parameters you want to send as you normally would):</p>
<pre class="mce-root">R6_rectangle$own_print()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue rectangle: 2 x 3 == 6"</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$area()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] 6</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$color()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encapsulation and mutability</h1>
                
            
            
                
<p class="calibre2">Since we placed the <kbd class="calibre9">a</kbd>, <kbd class="calibre9">b</kbd>, and <kbd class="calibre9">own_color</kbd> in the <kbd class="calibre9">private</kbd> list in the class definition, they remain private, and this is how encapsulation is enforced in R6. As you can see, we were not allowed to assign directly to the <kbd class="calibre9">a</kbd> attribute as we expected, since it was placed in the <kbd class="calibre9">private</kbd> list. This makes sure that we can't have attributes or methods marked as private directly from outside the object, and prevents us from making bad decisions when coding. This is a great advantage of the R6 model.</p>
<p>Encapsulation in R6 is achieved through environments.</p>
<p class="calibre2">Mutability is achieved by using setters (methods used to change a class's attribute). Notice that in this case, we don't need to reassign the resulting object as we do with S3. State is actually saved within the object's environment, and it can be changed; thus, R6 has mutability:</p>
<pre class="mce-root">R6_rectangle$a<br class="title-page-name"/><strong class="calibre1">#&gt; NULL</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$own_print()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue rectangle: 2 x 3 == 6"</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$a &lt;- 1<br class="title-page-name"/><strong class="calibre1">#&gt; Error in R6_rectangle$a &lt;- 1: <br class="title-page-name"/>       cannot add bindings to a locked environment</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$own_print()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "blue rectangle: 2 x 3 == 6"</strong><br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$set_color("black")<br class="title-page-name"/><br class="title-page-name"/>R6_rectangle$own_print()<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "black rectangle: 2 x 3 == 6"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Inheritance</h1>
                
            
            
                
<p class="calibre2">Inheritance is also more familiar when working with the R6 object model. In this case, you can simply add the <kbd class="calibre9">inherit</kbd> parameter to the <kbd class="calibre9">R6Class()</kbd> function call, and you may call the <kbd class="calibre9">initialize</kbd> method for the superclass by using <kbd class="calibre9">super$initialize()</kbd>. In this case, we use that technique to provide a more intuitive constructor interface to the user: a single value for length in the case of a square, instead of having to repeat the same value twice, which can be prone to counter-intuitive behavior if not checked. We can also override the <kbd class="calibre9">print()</kbd> method, just as we would normally add another method:</p>
<pre class="mce-root">R6Square &lt;- R6Class(<br class="title-page-name"/>    "R6Square",<br class="title-page-name"/>    inherit = R6Rectangle,<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(a, color) {<br class="title-page-name"/>            super$initialize(a, a, color)<br class="title-page-name"/>        },<br class="title-page-name"/>        print = function() {<br class="title-page-name"/>            print(paste(<br class="title-page-name"/>                self$color(), "square:",<br class="title-page-name"/>                private$a, "x", private$b, " == ", self$area()<br class="title-page-name"/>            ))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">As you can see, in this case we get a list of classes that include the current class <kbd class="calibre9">R6Square</kbd>, as well as the classes this object inherits from, <kbd class="calibre9">R6Rectangle</kbd> and <kbd class="calibre9">R6</kbd>. Since we used an override for the <kbd class="calibre9">print()</kbd> method, we can use the common <kbd class="calibre9">print(object)</kbd> syntax instead of the ad-hoc <kbd class="calibre9">object$print()</kbd> syntax provided by R6:</p>
<pre class="mce-root">R6_square &lt;- R6Square$new(4, "red")<br class="title-page-name"/><br class="title-page-name"/>class(R6_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "R6Square" "R6Rectangle" "R6"</strong><br class="title-page-name"/><br class="title-page-name"/>print(R6_square)<br class="title-page-name"/><strong class="calibre1">#&gt; [1] "red square: 4 x 4 == 16"</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Active bindings</h1>
                
            
            
                
<p class="calibre2">Active bindings look like fields, but each time they are accessed, they call a function. They are always publicly visible and are similar to Python's properties. If we wanted to implement the <kbd class="calibre9">color()</kbd> method as an active binding, we could use the following code. As you can see, you can either get or set the <kbd class="calibre9">color</kbd> attribute, without using an explicit method call (note the missing parentheses):</p>
<pre class="mce-root">R6Rectangle &lt;- R6Class(
    "R6Rectangle",
    public = list(
        ...
    ),
    private = list(
        ...
    ),
    active = list(
        color = function(new_color) {
            if (missing(new_color)) {
                return(private$own_color)
            } else {
                private$own_color &lt;- new_color
            }
        }
    )
)

R6_rectangle &lt;- R6Rectangle$new(2, 3, "blue")
<br class="title-page-name"/>R6_rectangle$color
<strong class="calibre1">#&gt; [1] "blue"</strong>
<br class="title-page-name"/>R6_rectangle$color &lt;- "black"
<br class="title-page-name"/>R6_rectangle$color
<strong class="calibre1">#&gt; [1] "black"</strong></pre>
<p class="calibre2">As you can see, when an active binding is used as a <em class="calibre19">getter</em> (to retrieve a value), it calls the method without a value being passed. When it's accessed as a <em class="calibre19">setter</em> (to change an attribute), it calls the method passing the value to be assigned. It's not possible to use an active binding as a setter if the function takes no arguments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Finalizers</h1>
                
            
            
                
<p class="calibre2">Sometimes, it's useful to run a function when the object is garbage collected. If you're not familiar with garbage collection, you can think of it as a way to liberate unused memory when an object is no longer referenced by other objects in the environment.</p>
<p class="calibre2">A useful case for this feature is when you want to make sure a file or database connection gets closed before an object is garbage collected. To do this, you can define a <kbd class="calibre9">finalize()</kbd> method, which will be called with no arguments when the object is garbage collected. To test this functionality, you can simply add a <em class="calibre19">finalizer</em> as follows to some of your objects and see when you get the <kbd class="calibre9">"Finalizer called"</kbd> message in the console:</p>
<pre class="mce-root">A &lt;- R6Class("A", public = list(
    finalize = function() {
        print("Finalizer called.")
    }
))</pre>
<p>Finalizers will also be called when R exits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The architecture behind our cryptocurrencies system</h1>
                
            
            
                
<p class="calibre2">Now that the fundamentals for object-oriented programming with R have been illustrated, we will take those principles and apply them to the example we will work with for the rest of the book. We will build a system to track cryptocurrencies with object-oriented programming. If you're not familliar with cryptocurrencies, read the beginning of this chapter for a brief introduction.</p>
<p class="calibre2">The design and implemention you will see in this example evolved over various iterations and weeks. It's actually a part of the basic system I initially used in CVEST (<a href="https://www.cvest.tech/" target="_blank" class="calibre4">https://www.cvest.tech/</a>) to offer a single point of truth for users managing a diverse set of cryptocurrencies (although it was not implemented in R), so don't feel that you should be able to come up with a design like this right away (although many people certainly are able to, but most of the time, object-oriented systems are evolve in unpredicted ways). As Grady Booch puts it: <em class="calibre19">"A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and can not be patched up to make it work. You have to start over, beginning with a working simple system."</em></p>
<p class="calibre2">Let's get to it. As you may know, cryptocurrencies can be stored in exchange accounts and in wallets. Since keeping cryptocurrencies stored in exchange accounts is a very bad idea (it's risky, and a user could end up losing their assets, as has repeatedly happened), we will only focus on the cases where cryptocurrencies are stored in wallets.</p>
<p class="calibre2">Basically, what we are trying to do is to get a feed of real data about how many cryptocurrencies we posses and how much they are worth, both at a given point in time. To implement the system, the first thing we need to do is identify the primary abstractions, which are, in our case: users, assets, wallets, and exchanges. For simplicity, we will also include markets and databases in this list.</p>
<p>We will use the term asset instead of cryptocurrency due to the fact that some of them are not technically currencies, but you may interchange those terms freely without confusion.</p>
<p class="calibre2">For our case, suppose we have decided from the start that even though we will read data from a single source, we may want to write data to multiple databases as we get it. Some of these databases may be local, and others may be remote. However, we don't want every piece of the system to know that there are multiple databases in use, since they really don't need this information to operate. Therefore, we will introduce another abstraction, namely storage, which will contain this information inside, and which will look like a single database to other objects that need to read or write data, and it will handle the details for them.</p>
<p class="calibre2">We include this abstraction in our list of primary abstractions, and that list is complete at this point:</p>
<div><img src="img/00060.jpeg" class="calibre60"/></div>
<p>Cryptocurrency tracking architecture</p>
<p class="calibre2">Now, we need to define how this main abstraction will interact among themselves. We know that a user may have several wallets in her posession, and that in turn, these wallets have assets inside. Note that we separated the abstractions of assets and wallets because some wallets may contain more than on asset inside (for example, Ethereum wallets may contain various types of tokens). Since we anticipate this case, we will make sure we can deal with it accordingly by separating these concepts.</p>
<p class="calibre2">Users also want to be able to store their own information as well as their assets information. To do so, they will receive a storage object and they will call methods on this object, for which the public interface will be well defined.</p>
<p class="calibre2">The storage abstraction will in turn contain a single database for reading, but may contain several databases for writing, as we mentioned before. It will store these database objects inside and send them messages as necessary to accomplish the read and write operations on behalf of objects using it.</p>
<p class="calibre2">Finally, just as wallets contain assets, exchanges contain markets. The difference is that assets identify a single type of cryptocurrency, while markets use exactly two cryptocurrencies to be defined. That is why we may have a market to exchange USD for BTC (written as USD/BTC), meaning that people may use US Dollars to buy/sell Bitcoin. Other markets could be BTC/LTC or LTC/USD (where LTC stands for <strong class="calibre1">Litecoin</strong>).</p>
<p class="calibre2">The number we will be retrieving from wallets is a single number representing how much of a specific asset we posses. The number we will be retrieving from markets is a ratio representing the price, or how much of one asset is being asked for to receive one unit of the other. A BTC/USD ratio of 8,000 means that to receive one Bitcoin you're expected to give 8,000 US Dollars (which is the price as this paragraph is being written). Similarly, an LTC/BTC of 0.0086 means that you're expected to give 0.0086 Bitcoin to receive one Litecoin.</p>
<p class="calibre2">Now that these relations are more or less defined, we will need to bring more abstractions into play to write code that will make our system a reality. For example, we know that our wallet abstraction will use a similar mechanism to retrieve data from different blockchains. This can be encapsulated in a <em class="calibre19">wallet requester</em>. Furthermore, this wallet requester will be implemented in different ways and must be decided at runtime according to the specific wallet we're dealing with. Instead of creating a different wallet for each type of asset, and programming the mechanism to retrieve data from the blockchain inside each of them, we abstract that and create a wallet requester factory that will give our wallet abstraction the specific type of wallet requester it needs for the given asset at hand.</p>
<p class="calibre2">Similarly, our database abstraction may be implemented for various kinds of databases, so we separate the interface from the implementation and introduce a factory that will choose which specific implementation we will end up using. In our case, we will be saving the data to CSV files, but we could just as easily be using a MySQL database with what we learned in <a target="_blank" href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases</em>.</p>
<p class="calibre2">In much the same way, our code will retrieve data from <strong class="calibre1">CoinMarketCap</strong> (<a href="http://www.coinmarketcap.com" class="calibre4">www.coinmarketcap.com</a>) for now, but that may change later. CoinMarketCap is not an exchange, per se; rather, it is an aggregator of price data. However, since we may want to work with price data from different exchanges in the future (like <strong class="calibre1">Bittrex</strong> or <strong class="calibre1">Bitfinex),</strong> we will provide for such abstraction, and since there's no foreseen need to treat CoinMarketCap differently from an exchange, we will just include it in that abstraction.</p>
<p class="calibre2">As a sidenote, the architecture image is not meant to be a UML diagram. <strong class="calibre1">UML</strong> stands for <strong class="calibre1">Unified Modeling Language</strong>, a tool commonly used to communicate ideas behind object-oriented systems. It's a tool you should definitely learn to use if you're planning on doing serious object-oriented programming. Also note that we will not implement the objects shown in grey color, namely Bitfinex requester, Bittrex requester, MySQL, and Ether requester. Those are left as an exercise for the user. Our system will be fully functional without them.</p>
<p class="calibre2">At this point, it seems that we have a very good idea of the abstractions we want to build and the interactions that will occur among these abstractions, so it's time to start programming. While we go through the code for the system, we will not stop to explain the concepts we have covered before; we will only explain functionality that may not be evident.</p>
<p class="calibre2">Finally, you should know that each abstraction we implement will go into its own file. This is standard practice and helps you quickly find where you need to implement or modify some code. There's a clear and intuitive hierarchy among these files. The actual code is organized in the following structure (files end with the <kbd class="calibre9">.R</kbd> extensions and directories end with the <kbd class="calibre9">/</kbd> symbol):</p>
<pre class="mce-root">cryptocurrencies/
    assets/
        analysis-asset.R
        asset.R
        exchanges/
            exchange.R
            market.R
            requesters/
                coinmarketcap-requester.R
                exchange-requester-factory.R
                exchange-requester.R
        wallets/
            requesters/
                btc-requester.R
                ltc-requester.R
                wallet-requester-factory.R
                wallet-requester.R
            wallet.R
    batch/
        create-user-data.R
        update-assets.R
        update-markets.R
    settings.R
    storage/
        csv-files.R
        database-factory.R
        database.R
        storage.R
    users/
        admin.R
        user.R
    utilities/
        requester.R
        time-stamp.R</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Starting simple with timestamps using S3 classes</h1>
                
            
            
                
<p class="calibre2">We start by programming a class that has no external dependencies, the <kbd class="calibre9">TimeStamp</kbd>. We will use this class to indicate dates and times together in a single string in the format <kbd class="calibre9">YYYY-MM-DD-HH-mm</kbd>, where <kbd class="calibre9">MM</kbd> means month and <kbd class="calibre9">mm</kbd> means minutes. As you can see, with one of these strings you have the information time and date, and it will be stored with the data we retrieve from time-series for analysis in <a href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average</em>.</p>
<p class="calibre2">Our <kbd class="calibre9">TimeStamp</kbd> class will be implemented using S3. As you can see, we include the <kbd class="calibre9">lubridate</kbd> package to do some heavy lifting for us when transforming dates, and provide a constructor that checks whether or not the string being passed is a valid timestamp:</p>
<pre class="mce-root">library(lubridate)<br class="title-page-name"/>timestamp_constructor &lt;- function(timestamp = now.TimeStamp()) {<br class="title-page-name"/>    class(timestamp) &lt;- "TimeStamp"<br class="title-page-name"/>    if (valid(timestamp)) { return(timestamp) }<br class="title-page-name"/>    stop("Invalid timestamp (format should be: 'YYYY-MM-DD-HH-mm')")<br class="title-page-name"/>}</pre>
<p class="calibre2">The validation is done by the <kbd class="calibre9">valid.TimeStamp()</kbd> function, which makes sure that only dashes (<kbd class="calibre9">-</kbd>) and digits are in the string, that the number of numbers separated by those dashes is five (year, month, day, hour, and minutes), and that the string can be parsed by the <kbd class="calibre9">strptime()</kbd> function, which is used to create date objects from string objects (if it's not an <kbd class="calibre9">NA</kbd>, then it could be parsed):</p>
<pre class="mce-root">valid.TimeStamp &lt;- function(timestamp) {<br class="title-page-name"/>    if (gsub("-", "", gsub("[[:digit:]]", "", timestamp)) != "") {<br class="title-page-name"/>        return(FALSE)<br class="title-page-name"/>    }<br class="title-page-name"/>    if (length(strsplit(timestamp, "-")[[1]]) != 5) {<br class="title-page-name"/>        return(FALSE)<br class="title-page-name"/>    }<br class="title-page-name"/>    if (is.na(strptime(timestamp, "%Y-%m-%d-%H-%M"))) {<br class="title-page-name"/>        return(FALSE)<br class="title-page-name"/>    }<br class="title-page-name"/>    return(TRUE)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>valid &lt;- function (object) {<br class="title-page-name"/>    UseMethod("valid", object)<br class="title-page-name"/>}</pre>
<p class="calibre2">We also provide a <kbd class="calibre9">now.TimeStamp()</kbd> function whose responsibility is to create a timestamp for the current time and date. It does so by invoking the <kbd class="calibre9">Sys.time()</kbd> function and parsing the resulting object with the format we have specified previously:</p>
<pre class="mce-root">now.TimeStamp &lt;- function() {<br class="title-page-name"/>    timestamp &lt;- format(Sys.time(), "%Y-%m-%d-%H-%M")<br class="title-page-name"/>    class(timestamp) &lt;- "TimeStamp"<br class="title-page-name"/>    return(timestamp)<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, we introduce a way to transform native time objects into our own <kbd class="calibre9">TimeStamp</kbd> objects. We simply use the <kbd class="calibre9">format()</kbd> function as we did before. We also introduce a mechanism to transform our own <kbd class="calibre9">TimeStamp</kbd> objects into native time objects:</p>
<pre class="mce-root">time_to_timestamp.TimeStamp &lt;- function(time) {<br class="title-page-name"/>    timestamp &lt;- format(time, "%Y-%m-%d-%H-%M")<br class="title-page-name"/>    class(timestamp) &lt;- "TimeStamp"<br class="title-page-name"/>    return(timestamp)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>timestamp_to_time.TimeStamp &lt;- function(timestamp) {<br class="title-page-name"/>    return(strptime(timestamp, "%Y-%m-%d-%H-%M"))<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">subtract.TimeStamp()</kbd> function will be important when we retrieve data, as we may want all assets that contain a date starting from a previous point in time taken from a given <kbd class="calibre9">TimeStamp</kbd>. The function receives two parameters: the current <kbd class="calibre9">TimeStamp</kbd> and the interval of how much time back we want the resulting <kbd class="calibre9">TimeStamp</kbd> to indicate. Depending on the chosen interval, which can be one hour, one day, one week, one month, or one year, indicated by <kbd class="calibre9">1h</kbd>, <kbd class="calibre9">1d</kbd>, <kbd class="calibre9">1w</kbd>, <kbd class="calibre9">1m</kbd>, and <kbd class="calibre9">1y</kbd>, respectively, we will call different functions from the <kbd class="calibre9">lubridate</kbd> package (<kbd class="calibre9">hours()</kbd>, <kbd class="calibre9">days()</kbd>, <kbd class="calibre9">weeks()</kbd>, <kbd class="calibre9">months()</kbd>, <kbd class="calibre9">years()</kbd>), which receive how many units of the specified name should be used in the operation. These are easy ways to add or subtract time in R.</p>
<p class="calibre2">Note that if an unknown interval is passed, we will raise an error. Some people think that adding these <kbd class="calibre9">else</kbd> cases with some kind of error should be avoided, since it indicates insecure programming in the sense that you should know what options should be passed to the function, and you should never really end up in the else branch, and they would rather make sure that their code works by using unit-tests instead of checking internally with conditionals. However, we are using it to exemplify its usage and because we're not using unit-tests to prove correctness in our code. I'm also of the opinion that you can never be too careful with these types of situations, and I've found myself in situations where adding that simple else branch helped me diagnose a bug much easier:</p>
<pre class="mce-root">subtract.TimeStamp &lt;- function(timestamp, interval) {<br class="title-page-name"/>    time &lt;- timestamp_to_time.TimeStamp(timestamp)<br class="title-page-name"/>    if (interval == "1h") {<br class="title-page-name"/>        time &lt;- time - hours(1)<br class="title-page-name"/>    } else if (interval == "1d") {<br class="title-page-name"/>        time &lt;- time - days(1)<br class="title-page-name"/>    } else if (interval == "1w") {<br class="title-page-name"/>        time &lt;- time - weeks(1)<br class="title-page-name"/>    } else if (interval == "1m") {<br class="title-page-name"/>        time &lt;- time - months(1)<br class="title-page-name"/>    } else if (interval == "1y") {<br class="title-page-name"/>        time &lt;- time - years(1)<br class="title-page-name"/>    } else {<br class="title-page-name"/>        stop("Unknown interval")<br class="title-page-name"/>   }<br class="title-page-name"/>   timestamp &lt;- time_to_timestamp.TimeStamp(time)<br class="title-page-name"/>   return(timestamp)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>subtract &lt;- function (object, interval) {<br class="title-page-name"/>    UseMethod("subtract", object)<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, we add a convenient <kbd class="calibre9">one_year_ago.TimeStamp()</kbd> function, which will simply produce a current <kbd class="calibre9">TimeStamp</kbd> and subtract one year from it. This is one of those functions that simply evolves as the system is being developed, since I noticed I needed that functionality over and over again, so I could just make my life a little easier this way:</p>
<pre class="mce-root">one_year_ago.TimeStamp &lt;- function() {<br class="title-page-name"/>    return(subtract(now.TimeStamp(), "1y"))<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, the class is ready. Feel free to play with it to make sure it works as expected. With what you've seen so far in this chapter, you should be able to create instances and use the different methods we created. You should also try to break it to find its weak spots and possibly improve the implementation's robustness.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing cryptocurrency assets using S4 classes</h1>
                
            
            
                
<p class="calibre2">Now, we will implement our next abstraction with the least number of dependencies, <kbd class="calibre9">Asset</kbd>. We will implement it using S4, and it only depends on <kbd class="calibre9">TimeStamp</kbd>. We define its class using the standard methods shown before, and its attributes include <kbd class="calibre9">email</kbd> to identify what user an asset belongs to, a <kbd class="calibre9">timestamp</kbd> to identify the asset at a point in time, a <kbd class="calibre9">name</kbd> to know what asset we're dealing with, a <kbd class="calibre9">symbol</kbd> to identify the asset type within our system, a <kbd class="calibre9">total</kbd> to record how much of that asset a user has, and an <kbd class="calibre9">address</kbd> to identify what wallet the asset belongs to (a user may have several wallets for the same type of asset):</p>
<pre class="mce-root">setClass(<br class="title-page-name"/>    Class = "Asset",<br class="title-page-name"/>    representation = representation(<br class="title-page-name"/>        email = "character",<br class="title-page-name"/>        timestamp = "character",<br class="title-page-name"/>        name = "character",<br class="title-page-name"/>        symbol = "character",<br class="title-page-name"/>        total = "numeric",<br class="title-page-name"/>        address = "character"<br class="title-page-name"/>     )<br class="title-page-name"/>)</pre>
<p class="calibre2">Note that instead of using the S3 class for <kbd class="calibre9">TimeStamp</kbd> in the <kbd class="calibre9">timestamp</kbd> attribute, we decide to simply declare it as a <kbd class="calibre9">character</kbd> and manage the translation among types ourselves. This allows us to remain in control of this transformation process and avoid unexpected R behavior when mixing object models.</p>
<p class="calibre2">Next, we provide setter functions to change the <kbd class="calibre9">email</kbd> and <kbd class="calibre9">timestamp</kbd> attributes, since we will need them when we are retrieving asset data and saving it to disk. This is one of those design decisions that evolved as the system was developed, and we did not foresee that we would need these methods; they were added at a later point in time:</p>
<pre class="mce-root">setGeneric("email&lt;-", function(self, value) standardGeneric("email&lt;-"))<br class="title-page-name"/>setReplaceMethod("email", "Asset", function(self, value) {<br class="title-page-name"/>    self@email &lt;- value<br class="title-page-name"/>    return(self)<br class="title-page-name"/>})<br class="title-page-name"/><br class="title-page-name"/>setGeneric("timestamp&lt;-", function(self, value) standardGeneric("timestamp&lt;-"))<br class="title-page-name"/>setReplaceMethod("timestamp", "Asset", function(self, value) {<br class="title-page-name"/>    self@timestamp &lt;- value<br class="title-page-name"/>    return(self)<br class="title-page-name"/>})</pre>
<p class="calibre2">Now, we implement a <kbd class="calibre9">dataS4</kbd> method that will allow us to retrieve the data that needs saving from our S4 objects. Note that we used the same technique as was shown before to differentiate <kbd class="calibre9">dataS4</kbd> methods from <kbd class="calibre9">dataS3</kbd> methods, and avoid any pitfalls with R:</p>
<pre class="mce-root">setGeneric("dataS4", function(self) standardGeneric("dataS4"))<br class="title-page-name"/>setMethod("dataS4", "Asset", function(self) {<br class="title-page-name"/>    return(list(<br class="title-page-name"/>        email = self@email,<br class="title-page-name"/>        timestamp = self@timestamp,<br class="title-page-name"/>        name = self@name,<br class="title-page-name"/>        symbol = self@symbol,<br class="title-page-name"/>        total = self@total,<br class="title-page-name"/>        address = self@address<br class="title-page-name"/>     ))<br class="title-page-name"/>})</pre>
<p class="calibre2">The implementation of the <kbd class="calibre9">AnalysisAsset</kbd> will be left for the next chapter, where we introduce the types of analysis we're looking to perform with this data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing our storage layer with R6 classes</h1>
                
            
            
                
<p class="calibre2">Up to this point, our code's complexity was not much more than that shown in the examples for the colors, rectangles, and squares. At this point, the code will be a bit more complex, since we are dealing with more complex abstractions and interactions among them, but we are ready to tackle the challenge with what we know so far.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Communicating available behavior with a database interface</h1>
                
            
            
                
<p class="calibre2">We will start by defining the interface for databases in the <kbd class="calibre9">Database</kbd> class. This class is never intended to be instantiated itself. Its purpose is to simply provide an interface definition that must be respected by specific database implementations, like the <kbd class="calibre9">CSVFiles</kbd> implementation we will develop, and by the <kbd class="calibre9">Storage</kbd> implementation, to communicate with any database. The advantage of defining an interface such as this is that it provides a common language for these objects to talk to each other, and provides a reference for the programmer of what should be done and how methods should be named so that they work out of the box with the rest of the system. In Python, they would be called Abstract Base Classes. R has no formal usage for these abstract classes, but we can nevertheless implement them this way ourselves.</p>
<p class="calibre2">As you can see, our R6 <kbd class="calibre9">Database</kbd> interface specifies what methods should be publicly implemented and the fact that the table names used for the database should be kept private. We're adding this <kbd class="calibre9">table_names</kbd> list attribute instead of hardcoding the table names directly in our classes because we want to be able to easily change them in a settings file (more on this later) and we want to easily change them for the different environments we will be using this code under (mainly production and development environments).</p>
<p class="calibre2">The public methods are the getter and setter for the <kbd class="calibre9">table_names</kbd>, and the groups of methods used for reading and writing data, which contain a prefix stating what they are used for. It should be evident what they expect and what they return. Specifically, the <kbd class="calibre9">read_exchanges()</kbd> method does not receive any parameters and should return a list of <kbd class="calibre9">Exchange</kbd> objects (which will be defined later). The <kbd class="calibre9">read_users()</kbd> returns a list of <kbd class="calibre9">User</kbd> objects (which will also be defined later), and needs an instance of <kbd class="calibre9">Storage</kbd> that will be assigned to each user created so that they can read and write data. The <kbd class="calibre9">read_wallets()</kbd> method receives an email string and returns a list of <kbd class="calibre9">Wallet</kbd> objects (also to be defined later). The <kbd class="calibre9">read_all_wallets()</kbd> method is meant to be used only by <kbd class="calibre9">admins</kbd> of the system, and will return all the wallets in the system in a list, not only the wallets that belong to a specific user.</p>
<p class="calibre2">On the write side, the <kbd class="calibre9">write_user()</kbd> method receives a <kbd class="calibre9">User</kbd> object and writes it to disk, and as you can see by the <kbd class="calibre9">{}</kbd> symbols, it's not expected to return anything. Similarly, the other write methods receive an instance of a class and save it to disk. We need one write method for each type of class because they will need different treatments when being saved:</p>
<pre class="mce-root">Database &lt;- R6Class(<br class="title-page-name"/>    "Database",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        set_table_names = function(table_names) {<br class="title-page-name"/>            private$table_names &lt;- table_names<br class="title-page-name"/>        },<br class="title-page-name"/>        get_table_names = function() {<br class="title-page-name"/>            return(private$table_names)<br class="title-page-name"/>        },<br class="title-page-name"/>        read_exchanges = function() list(),<br class="title-page-name"/>        read_users = function(storage) list(),<br class="title-page-name"/>        read_wallets = function(email) list(),<br class="title-page-name"/>        read_all_wallets = function() list(),<br class="title-page-name"/>        read_analysis_assets = function(email) list(),<br class="title-page-name"/>        write_user = function(user) {},<br class="title-page-name"/>        write_wallet = function(wallet) {},<br class="title-page-name"/>        write_assets = function(assets) {},<br class="title-page-name"/>        write_markets = function(markets) {}<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(table_names = list())<br class="title-page-name"/>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing a database-like storage system with CSV files</h1>
                
            
            
                
<p class="calibre2">Now that we have our <kbd class="calibre9">Database</kbd> interface defined, we will implement a database-like system that uses CSV files to store the information instead of an actual database.</p>
<p class="calibre2">First, we make sure we bring the <kbd class="calibre9">CSVFiles</kbd> class dependencies by using the <kbd class="calibre9">source()</kbd> function to bring files that have the definitions we need. Specifically, we bring the <kbd class="calibre9">Exchange</kbd> and <kbd class="calibre9">User</kbd> classes (which will be defined later), as well as the <kbd class="calibre9">Database</kbd> interface. We also define the <kbd class="calibre9">DIR</kbd> constant with the directory that will contain the CSV files with our system's data.</p>
<p class="calibre2">The actual <kbd class="calibre9">CSVFiles</kbd> class is defined using the standard R6 methods shown before. Note that it inherits from the <kbd class="calibre9">Database</kbd> class and provides overrides for every method in the <kbd class="calibre9">Database</kbd> interface, as it should. Also note that inside the constructor, that is, the <kbd class="calibre9">initialize</kbd> function, we are calling the <kbd class="calibre9">initialize_csv_files()</kbd> function and sending it the <kbd class="calibre9">table_names</kbd> list we receive during initialization. More on this ahead.</p>
<p class="calibre2">Since we wanted the reader to get a look at the full class definition in a single piece of code instead of piece-by-piece, we include all of it here, and explain it in the following paragraphs. It's a bit long since it contains the logic for all the methods in the <kbd class="calibre9">Database</kbd> interface, but at a high level, it's nothing more than implementation for said interface:</p>
<pre class="mce-root">source("../assets/exchanges/exchange.R", chdir = TRUE)<br class="title-page-name"/>source("../users/user.R", chdir = TRUE)<br class="title-page-name"/>source("./database.R")<br class="title-page-name"/>DIR &lt;- "./csv-files/"<br class="title-page-name"/><br class="title-page-name"/>CSVFiles &lt;- R6Class(<br class="title-page-name"/>    "CSVFiles",<br class="title-page-name"/>    inherit = Database,<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(table_names) {<br class="title-page-name"/>            super$set_table_names(table_names)<br class="title-page-name"/>            initialize_csv_files(table_names)<br class="title-page-name"/>        },<br class="title-page-name"/>        read_exchanges = function() {<br class="title-page-name"/>            return(list(Exchange$new("CoinMarketCap")))<br class="title-page-name"/>        },<br class="title-page-name"/>        read_users = function(storage) {<br class="title-page-name"/>            data &lt;- private$read_csv("users")<br class="title-page-name"/>            return(lapply(data$email, user_constructor, storage))<br class="title-page-name"/>        },<br class="title-page-name"/>        read_wallets = function(email) {<br class="title-page-name"/>            data &lt;- private$read_csv("wallets")<br class="title-page-name"/>            wallets &lt;- NULL<br class="title-page-name"/>            if (nrow(data) &gt;= 1) {<br class="title-page-name"/>                for (i in 1:nrow(data)) {<br class="title-page-name"/>                    if (data[i, "email"] == email) {<br class="title-page-name"/>                        wallets &lt;- c(wallets, list(Wallet$new(<br class="title-page-name"/>                            data[i, "email"],                 <br class="title-page-name"/>                            data[i, "symbol"],<br class="title-page-name"/>                            data[i, "address"], <br class="title-page-name"/>                            data[i, "note"])<br class="title-page-name"/>                        ))<br class="title-page-name"/>                    }<br class="title-page-name"/>                }<br class="title-page-name"/>            } else { wallets &lt;- list() }<br class="title-page-name"/>            return(wallets)<br class="title-page-name"/>        },<br class="title-page-name"/>        read_all_wallets = function() {<br class="title-page-name"/>            data &lt;- private$read_csv("wallets")<br class="title-page-name"/>            wallets &lt;- NULL<br class="title-page-name"/>            if (nrow(data) &gt;= 1) {<br class="title-page-name"/>                for (i in 1:nrow(data)) {<br class="title-page-name"/>                    wallets &lt;- c(wallets, list(Wallet$new(<br class="title-page-name"/>                        data[i, "email"], <br class="title-page-name"/>                        data[i, "symbol"],<br class="title-page-name"/>                        data[i, "address"], <br class="title-page-name"/>                        data[i, "note"])<br class="title-page-name"/>                    ))<br class="title-page-name"/>                }<br class="title-page-name"/>            } else { wallets &lt;- list() }<br class="title-page-name"/>            return(wallets)<br class="title-page-name"/>        },<br class="title-page-name"/>        write_user = function(user) {<br class="title-page-name"/>            data &lt;- private$read_csv("users")<br class="title-page-name"/>            new_row &lt;- as.data.frame(dataS3(user))<br class="title-page-name"/>            print(new_row)<br class="title-page-name"/>            if (private$user_does_not_exist(user, data)) {<br class="title-page-name"/>                data &lt;- rbind(data, new_row)<br class="title-page-name"/>            }<br class="title-page-name"/>            private$write_csv("users", data)<br class="title-page-name"/>        },<br class="title-page-name"/>        write_wallets = function(wallets) {<br class="title-page-name"/>            data &lt;- private$read_csv("wallets")<br class="title-page-name"/>            for (wallet in wallets) {<br class="title-page-name"/>                new_row &lt;- as.data.frame(wallet$data())<br class="title-page-name"/>                print(new_row)<br class="title-page-name"/>                if (private$wallet_does_not_exist(wallet, data)) {<br class="title-page-name"/>                    data &lt;- rbind(data, new_row)<br class="title-page-name"/>                }<br class="title-page-name"/>            }<br class="title-page-name"/>            private$write_csv("wallets", data)<br class="title-page-name"/>        },<br class="title-page-name"/>        write_assets = function(assets) {<br class="title-page-name"/>            data &lt;- private$read_csv("assets")<br class="title-page-name"/>            for (asset in assets) {<br class="title-page-name"/>                new_row &lt;- as.data.frame(dataS4(asset))<br class="title-page-name"/>                print(new_row)<br class="title-page-name"/>                data &lt;- rbind(data, new_row)<br class="title-page-name"/>            }<br class="title-page-name"/>            private$write_csv("assets", data)<br class="title-page-name"/>        },<br class="title-page-name"/>        write_markets = function(markets) {<br class="title-page-name"/>            data &lt;- private$read_csv("markets")<br class="title-page-name"/>            for (market in markets) {<br class="title-page-name"/>                new_row &lt;- as.data.frame(market$data())<br class="title-page-name"/>                print(new_row)<br class="title-page-name"/>                data &lt;- rbind(data, new_row)<br class="title-page-name"/>            }<br class="title-page-name"/>            private$write_csv("markets", data)<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        read_csv = function(table_name) {<br class="title-page-name"/>            return(read.csv (<br class="title-page-name"/>                       private$file(table_name), <br class="title-page-name"/>                       stringsAsFactors = FALSE))<br class="title-page-name"/>        },<br class="title-page-name"/>        write_csv = function(table_name, data) {<br class="title-page-name"/>            write.csv(data, <br class="title-page-name"/>                      file = private$file(table_name), <br class="title-page-name"/>                      row.names = FALSE)<br class="title-page-name"/>        },<br class="title-page-name"/>        file = function(table_name) {<br class="title-page-name"/>            return(paste(<br class="title-page-name"/>                DIR, super$get_table_names()[[table_name]], <br class="title-page-name"/>                ".csv", sep = ""))<br class="title-page-name"/>        },<br class="title-page-name"/>        user_does_not_exist = function(user, data) {<br class="title-page-name"/>            if (dataS3(user)[["email"]] %in% data$email) {<br class="title-page-name"/>                return(FALSE)<br class="title-page-name"/>            }<br class="title-page-name"/>            return(TRUE)<br class="title-page-name"/>        },<br class="title-page-name"/>        wallet_does_not_exist = function(wallet, data) {<br class="title-page-name"/>            current_addresses &lt;- data[<br class="title-page-name"/>                data$email == wallet$get_email() &amp;<br class="title-page-name"/>                data$symbol == wallet$get_symbol(),<br class="title-page-name"/>                "address"<br class="title-page-name"/>            ]<br class="title-page-name"/>            if (wallet$get_address() %in% current_addresses) {<br class="title-page-name"/>                return(FALSE)<br class="title-page-name"/>            }<br class="title-page-name"/>            return(TRUE)<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Now, we will briefly explain the mechanics behind each method implementation. Let's start with <kbd class="calibre9">read_exchanges()</kbd>. In theory, this method should look inside the stored data and get a list of the exchanges registered in the system, create an instance for each of them, and send that back. In practice, however, it's not necessary, as just hardcoding the CoinMarketCap exchange is sufficient for our purposes. As you can see, that's all the method does: return a list with a single <kbd class="calibre9">Exchange</kbd> inside, which is the one for CoinMarketCap.</p>
<p class="calibre2">The <kbd class="calibre9">read_users()</kbd> method reads the data from the <kbd class="calibre9">"user"</kbd> file with the private method <kbd class="calibre9">read_csv()</kbd> defined below, and returns a list built with the <kbd class="calibre9">lapply()</kbd> function that takes every email in the data and sends it through the <kbd class="calibre9">user_constructor()</kbd>, along with a <kbd class="calibre9">storage</kbd> object received as a parameter to create <kbd class="calibre9">User</kbd> instances that are then sent back as a result of the method call. If you don't remember how the <kbd class="calibre9">lapply()</kbd> function works, take a look at <a href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R</em>.</p>
<p class="calibre2">The <kbd class="calibre9">read_wallets()</kbd> method is a bit more complex. It receives an <kbd class="calibre9">email</kbd> as a parameter, reads the <kbd class="calibre9">"wallets"</kbd> file, and creates a list of <kbd class="calibre9">Wallet</kbd> instances. Since we're doing a check to see whether a specific observation in the data contains an <kbd class="calibre9">email</kbd> equal the one requested, we can simply use the <kbd class="calibre9">lapply()</kbd> function (we could, if we create a separate function that contains this, check, but we decide not to go that route). Also note that the function will only try to iterate over the row in the dataframe if the dataframe contains at least one row. This check was introduced after we found that when not having it when we had empty files, we were getting an error, since the for loop was actually being executed even if there were no rows. If the <kbd class="calibre9">email</kbd> is found to be the same as the one requested, then we append a new <kbd class="calibre9">Wallet</kbd> instance to the <kbd class="calibre9">wallets</kbd> list and return it. If there are no wallets to be created, the <kbd class="calibre9">wallets</kbd> object is coerced into an empty list. The <kbd class="calibre9">read_all_wallets()</kbd> method works in the same way but omits the <kbd class="calibre9">email</kbd> check.</p>
<p class="calibre2">The <kbd class="calibre9">write_user()</kbd> method receives a <kbd class="calibre9">User</kbd> instance, reads the <kbd class="calibre9">data</kbd> for the <kbd class="calibre9">"users"</kbd> file, creates a dataframe with the data extracted with the <kbd class="calibre9">dataS3</kbd> method call from the <kbd class="calibre9">User</kbd> object, prints it to the console for informational purposes, and, if it's not found to already exist in the current data, it's added to it. Finally, the data is saved back into the <kbd class="calibre9">"users"</kbd> file. The actual check is performed by the private method <kbd class="calibre9">user_does_not_exist()</kbd>, which simply checks that the <kbd class="calibre9">User</kbd> email is not contained in the <kbd class="calibre9">email</kbd> column in the data, as you can see in its definition mentioned ahead.</p>
<p class="calibre2">The <kbd class="calibre9">write_wallets()</kbd> method receives a list of <kbd class="calibre9">Wallet</kbd> instances, reads the <kbd class="calibre9">"wallets"</kbd> file, and for each <kbd class="calibre9">wallet</kbd> not found to already exist in the data, adds it. It's conceptually similar to the <kbd class="calibre9">write_user()</kbd> method, and the check is performed by the private <kbd class="calibre9">wallet_does_not_exist()</kbd> method, which receives a <kbd class="calibre9">Wallet</kbd> instance and uses its contained <kbd class="calibre9">email</kbd> and <kbd class="calibre9">symbol</kbd> to get the <kbd class="calibre9">addresses</kbd> which are already associated to such combinations (recall that a single user may have multiple wallets for the same type of asset, and they would only be differentiated by their wallet addresses). If the <kbd class="calibre9">address</kbd> in the <kbd class="calibre9">Wallet</kbd> instance is found to already exist in such a subset, then it's not added.</p>
<p class="calibre2">The <kbd class="calibre9">write_assets()</kbd> and <kbd class="calibre9">write_markets()</kbd> methods are similar and should be easily understood. The difference is that they do not contain any checks for now, and that they are saving S4 and R6 objects, respectively. You can tell that by the fact that they call the <kbd class="calibre9">dataS4()</kbd> method and the syntax to get the <kbd class="calibre9">Market</kbd> data, being <kbd class="calibre9">market$data()</kbd>.</p>
<p class="calibre2">The private methods used to read and write the CSV files should be easy to understand. Just keep in mind that the actual filenames are coming from the <kbd class="calibre9">file()</kbd> private method, which uses the <kbd class="calibre9">table_names</kbd> contained in the superclass (<kbd class="calibre9">Database</kbd>) by calling the <kbd class="calibre9">super$get_table_names()</kbd> getter and retrieving the corresponding filename associated for a given <kbd class="calibre9">table_name</kbd>. The <kbd class="calibre9">table_name</kbd> list will later be defined in the centralized settings file, but is simply a list that contains a string for each table name (in the case of <kbd class="calibre9">CSVFiles</kbd>, a file name) associated to each type of object that needs to be stored.</p>
<p class="calibre2">Now, we proceed to discussing the <kbd class="calibre9">initialize_csv_files()</kbd> function. This function receives the <kbd class="calibre9">table_names</kbd> list and makes sure that the <kbd class="calibre9">DIR</kbd> directory exists with the <kbd class="calibre9">dir.create()</kbd> function. The <kbd class="calibre9">showWarnings = FALSE</kbd> parameter is to avoid warnings when the directory already exists in disk. Then, for each element in the <kbd class="calibre9">table_names</kbd> list, it will create the corresponding <kbd class="calibre9">filename</kbd> and see whether it exists on disk with the <kbd class="calibre9">file.exists()</kbd> function. If it does not, it will proceed to create an empty dataframe of the corresponding type and save it to disk:</p>
<pre class="mce-root">initialize_csv_files &lt;- function(table_names) {<br class="title-page-name"/>    dir.create(DIR, showWarnings = FALSE)<br class="title-page-name"/>    for (table in table_names) {<br class="title-page-name"/>        filename &lt;- paste(DIR, table, ".csv", sep = "")<br class="title-page-name"/>        if (!file.exists(filename)) {<br class="title-page-name"/>            data &lt;- empty_dataframe(table)<br class="title-page-name"/>            write.csv(data, file = filename, row.names = FALSE)<br class="title-page-name"/>         }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The different types of empty dataframes are chosen with the <kbd class="calibre9">empty_dataframe()</kbd> function, which receives a specific table name in the <kbd class="calibre9">table</kbd> parameter and returns the corresponding empty dataframe. Note that the checks assume that the words for the different objects that need to be saved are within the table names defined in the centralized settings file and that the names of two different abstractions do no appear together in a single table name:</p>
<pre class="mce-root">empty_dataframe &lt;- function(table) {<br class="title-page-name"/>    if (grepl("assets", table)) {<br class="title-page-name"/>        return(empty_assets())<br class="title-page-name"/>    } else if (grepl("markets", table)) {<br class="title-page-name"/>        return(empty_markets())<br class="title-page-name"/>    } else if (grepl("users", table)) {<br class="title-page-name"/>        return(empty_users())<br class="title-page-name"/>    } else if (grepl("wallets", table)) {<br class="title-page-name"/>        return(empty_wallets())<br class="title-page-name"/>    } else {<br class="title-page-name"/>        stop("Unknown table name")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">The actual empty dataframes are created by the <kbd class="calibre9">empty_assets()</kbd>, <kbd class="calibre9">empty_markets()</kbd>, <kbd class="calibre9">empty_users()</kbd>, and <kbd class="calibre9">empty_wallets()</kbd> functions. Each of these contains a specification for the data expected to be within such files. Specifically, each observation in the asset's data is expected to have an email, timestamp, name, symbol, total, and address. Each observation in the markets data is expected to have a timestamp, name, symbol, rank, price in BTC, and price in USD. The rank is a cryptocurrencies ordering based on the amount of volume transacted in the last 24 hours. The users data is only expected to contain emails. Finally, the wallets data is expected to have an email, symbol, address, and note. The note is a note that the user may specify to recognize different wallets from each other, specifically if they are being used for the same type of cryptocurrency. Maybe one Bitcoin wallet is for long-term and one for short-term; then that information could be specified in the note field. Note that you can identify the relations among these data schemes with the concepts introduced in <a href="part0091.html#2MP360-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 4</a>, <em class="calibre19">Simulating Sales Data and Working with Databases</em>. Let's look at the following code:</p>
<pre class="mce-root">empty_assets &lt;- function() {<br class="title-page-name"/>    return(data.frame(<br class="title-page-name"/>        email = character(),<br class="title-page-name"/>        timestamp = character(),<br class="title-page-name"/>        name = character(),<br class="title-page-name"/>        symbol = character(),<br class="title-page-name"/>        total = numeric(),<br class="title-page-name"/>        address = character()<br class="title-page-name"/>    ))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>empty_markets &lt;- function() {<br class="title-page-name"/>    return(data.frame(<br class="title-page-name"/>        timestamp = character(),<br class="title-page-name"/>        name = character(),<br class="title-page-name"/>        symbol = character(),<br class="title-page-name"/>        rank = numeric(),<br class="title-page-name"/>        price_btc = numeric(),<br class="title-page-name"/>        price_usd = numeric()<br class="title-page-name"/>    ))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>empty_users &lt;- function() {<br class="title-page-name"/>    return(data.frame(<br class="title-page-name"/>        email = character()<br class="title-page-name"/>    ))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>empty_wallets &lt;- function() {<br class="title-page-name"/>    return(data.frame(<br class="title-page-name"/>        email = character(),<br class="title-page-name"/>        symbol = character(),<br class="title-page-name"/>        address = character(),<br class="title-page-name"/>        note = character()<br class="title-page-name"/>    ))<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Easily allowing new database integration with a factory</h1>
                
            
            
                
<p class="calibre2">We know at this point that we will only use the <kbd class="calibre9">CSVFiles Database</kbd> implementation for this example, but we can easily imagine cases where new database implementations come into play. For example, the reader will create an implementation of the MySQL database, and will want it to substitute the <kbd class="calibre9">CSVFiles</kbd> implementation. Isn't that right? When you expect some change in the future where you will likely need to switch one interface implementation for another, factories is a great tool to facilitate that change for yourself in the future.</p>
<p class="calibre2">Our <kbd class="calibre9">database_factory()</kbd> function receives a <kbd class="calibre9">db_setup</kbd> and <kbd class="calibre9">table_names</kbd> objects, both of which will come from our centralized settings file. It then takes the appropriate set of table names, depending on the environment for the database, and looks into the <kbd class="calibre9">db_setup</kbd> provided to find what kind of <kbd class="calibre9">Database</kbd> implementation it needs to instantiate. Since we only have one at this point, the only possibility will be a <kbd class="calibre9">CSVFiles</kbd> implementation, and if we pass any other string, then an error should be raised, as it is. The <kbd class="calibre9">Database</kbd> implementation actually instantiated should receive a <kbd class="calibre9">table_names</kbd> object and configure itself accordingly:</p>
<pre class="mce-root">source("./csv-files.R")<br class="title-page-name"/><br class="title-page-name"/>database_factory &lt;- function(db_setup, table_names) {<br class="title-page-name"/>    table_names &lt;- table_names[[db_setup[["environment"]]]]<br class="title-page-name"/>    if (db_setup[["name"]] == "CSVFiles") {<br class="title-page-name"/>        return(CSVFiles$new(table_names))<br class="title-page-name"/>    } else {<br class="title-page-name"/>        stop("Unknown database name")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2">As you can see, a factory is nothing more than an <kbd class="calibre9">if</kbd> statement which decides what implementation should be instantiated and returned to the calling object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Encapsulating multiple databases with a storage layer</h1>
                
            
            
                
<p class="calibre2">Now that we have developed our <kbd class="calibre9">Database</kbd> interface and our <kbd class="calibre9">CSVFiles</kbd> implementation of such an interface, we are ready to develop the next layer of abstraction, our <kbd class="calibre9">Storage</kbd> class. It will be implemented with R6.</p>
<p class="calibre2">As you can see, the <kbd class="calibre9">Storage</kbd> constructor implemented in the <kbd class="calibre9">initialize</kbd> function receives a <kbd class="calibre9">settings</kbd> object which will be the full centralized settings file we have been mentioning and will use the <kbd class="calibre9">storage/read</kbd>, <kbd class="calibre9">storage/write</kbd>, and <kbd class="calibre9">storage/table_names</kbd> parts to create various database instances through the use of the <kbd class="calibre9">database_factory()</kbd> function we explained before. In the case of the <kbd class="calibre9">read_db</kbd> attribute, it will be a single <kbd class="calibre9">Database</kbd> implementation that will be used to read data. In the case of the <kbd class="calibre9">write_dbs</kbd> attribute, as the name implies, we will have a list of <kbd class="calibre9">Database</kbd> implementations where each data that is asked to be saved by other objects will be stored.</p>
<p class="calibre2">With this <kbd class="calibre9">Storage</kbd> abstraction, we can simply send it to objects looking for a database-like object to save and read data from, and it will take care of replicating data as necessary for us, as well as providing data to said objects. To accomplish this, you can ask that in the case of the read methods, it simply delegate the task to the <kbd class="calibre9">Database</kbd> implementation contained in its <kbd class="calibre9">read_db</kbd> attribute, and in the case of the write methods, it does the same thing for each <kbd class="calibre9">Database</kbd> implementation in its <kbd class="calibre9">write_dbs</kbd> attribute. It's as simple as that:</p>
<pre class="mce-root">source("./database-factory.R")<br class="title-page-name"/>Storage &lt;- R6Class(<br class="title-page-name"/>    "Storage",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(settings) {<br class="title-page-name"/>            private$read_db &lt;- database_factory(<br class="title-page-name"/>                settings[["storage"]][["read"]],<br class="title-page-name"/>                settings[["storage"]][["table_names"]]<br class="title-page-name"/>            )<br class="title-page-name"/>            private$write_dbs &lt;- lapply(<br class="title-page-name"/>                settings[["storage"]][["write"]],<br class="title-page-name"/>                database_factory,<br class="title-page-name"/>                settings[["storage"]][["table_names"]]<br class="title-page-name"/>            )<br class="title-page-name"/>        },<br class="title-page-name"/>        read_exchanges = function() {<br class="title-page-name"/>            return(private$read_db$read_exchanges())<br class="title-page-name"/>        },<br class="title-page-name"/>        read_users = function() {<br class="title-page-name"/>            return(private$read_db$read_users(self))<br class="title-page-name"/>        },<br class="title-page-name"/>        read_wallets = function(email) {<br class="title-page-name"/>            return(private$read_db$read_wallets(email))<br class="title-page-name"/>        },<br class="title-page-name"/>        read_all_wallets = function() {<br class="title-page-name"/>            return(private$read_db$read_all_wallets())<br class="title-page-name"/>        },<br class="title-page-name"/>        read_analysis_assets = function(email) {<br class="title-page-name"/>            return(private$read_db$read_analysis_assets(email))<br class="title-page-name"/>        },<br class="title-page-name"/>        write_user = function(user) {<br class="title-page-name"/>            for (db in private$write_dbs) { db$write_user(user) }<br class="title-page-name"/>        },<br class="title-page-name"/>        write_wallets = function(wallets) {<br class="title-page-name"/>            for (db in private$write_dbs) { db$write_wallets(wallets) }<br class="title-page-name"/>        },<br class="title-page-name"/>        write_assets = function(assets) {<br class="title-page-name"/>            for (db in private$write_dbs) { db$write_assets(assets) }<br class="title-page-name"/>        },<br class="title-page-name"/>        write_markets = function(markets) {<br class="title-page-name"/>            for (db in private$write_dbs) { db$write_markets(markets) }<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(read_db = NULL, write_dbs = list())<br class="title-page-name"/>)</pre>
<p class="calibre2">That's it for our storage abstractions. At this point, we have implemented a <kbd class="calibre9">Database</kbd> interface, a <kbd class="calibre9">CSVFiles</kbd> implementation of said interface, and a <kbd class="calibre9">Storage</kbd> layer that permits the use of multiple <kbd class="calibre9">Database</kbd> implementations simultaneously and decouples the read and write objects for us. We could choose to use one type of database for read operations and another one for write operations, and have some kind of external mechanism to sync them together outside of R. This could be handy for performance reasons, for example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Retrieving live data for markets and wallets with R6 classes</h1>
                
            
            
                
<p class="calibre2">This section will explain how to create a simple requester, which is an object that requests external information (from an API over the internet in this case). We will also develop our exchange and wallet infrastructure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating a very simple requester to isolate API calls</h1>
                
            
            
                
<p class="calibre2">Now, we will focus on how we actually retrieve live data. This functionality will also be implemented using R6 classes, as the interactions can be complex. First of all, we create a simple <kbd class="calibre9">Requester</kbd> class that contains the logic to retrieve data from JSON APIs found elsewhere in the internet and that will be used to get our live cryptocurrency data for wallets and markets. We don't want logic that interacts with external APIs spread all over our classes, so we centralize it here to manage it as more specialized needs come into play later.</p>
<p class="calibre2">As you can see, all this object does is offer the public <kbd class="calibre9">request()</kbd> method, and all it does is use the <kbd class="calibre9">formJSON()</kbd> function from the <kbd class="calibre9">jsonlite</kbd> package to call a <kbd class="calibre9">URL</kbd> that is being passed to it and send the data it got back to the user. Specifically, it sends it as a dataframe when the data received from the external API can be coerced into dataframe-form.</p>
<pre class="mce-root">library(jsonlite)<br class="title-page-name"/><br class="title-page-name"/>Requester &lt;- R6Class(<br class="title-page-name"/>    "Requester",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        request = function(URL) {<br class="title-page-name"/>            return(fromJSON(URL))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Developing our exchanges infrastructure</h1>
                
            
            
                
<p class="calibre2">Our exchanges have multiple markets inside, and that's the abstraction we will define now. A <kbd class="calibre9">Market</kbd> has various private attributes, as we saw before when we defined what data is expected from each file, and that's the same data we see in our constructor. It also offers a <kbd class="calibre9">data()</kbd> method to send back a list with the data that should be saved to a database. Finally, it provides setters and getters as required. Note that the setter for the price depends on what units are requested, which can be either <kbd class="calibre9">usd</kbd> or <kbd class="calibre9">btc</kbd>, to get a market's asset price in terms of US Dollars or Bitcoin, respectively:</p>
<pre class="mce-root">Market &lt;- R6Class(<br class="title-page-name"/>    "Market",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(timestamp, name, symbol, rank,<br class="title-page-name"/>                              price_btc, price_usd) {<br class="title-page-name"/>            private$timestamp &lt;- timestamp<br class="title-page-name"/>            private$name &lt;- name<br class="title-page-name"/>            private$symbol &lt;- symbol<br class="title-page-name"/>            private$rank &lt;- rank<br class="title-page-name"/>            private$price_btc &lt;- price_btc<br class="title-page-name"/>            private$price_usd &lt;- price_usd<br class="title-page-name"/>        },<br class="title-page-name"/>        data = function() {<br class="title-page-name"/>            return(list(<br class="title-page-name"/>                timestamp = private$timestamp,<br class="title-page-name"/>                name = private$name,<br class="title-page-name"/>                symbol = private$symbol,<br class="title-page-name"/>                rank = private$rank,<br class="title-page-name"/>                price_btc = private$price_btc,<br class="title-page-name"/>                price_usd = private$price_usd<br class="title-page-name"/>            ))<br class="title-page-name"/>        },<br class="title-page-name"/>        set_timestamp = function(timestamp) {<br class="title-page-name"/>            private$timestamp &lt;- timestamp<br class="title-page-name"/>        },<br class="title-page-name"/>        get_symbol = function() {<br class="title-page-name"/>            return(private$symbol)<br class="title-page-name"/>        },<br class="title-page-name"/>        get_rank = function() {<br class="title-page-name"/>            return(private$rank)<br class="title-page-name"/>        },<br class="title-page-name"/>        get_price = function(base) {<br class="title-page-name"/>            if (base == 'btc') {<br class="title-page-name"/>                return(private$price_btc)<br class="title-page-name"/>            } else if (base == 'usd') {<br class="title-page-name"/>                return(private$price_usd)<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        timestamp = NULL,<br class="title-page-name"/>        name = "",<br class="title-page-name"/>        symbol = "",<br class="title-page-name"/>        rank = NA,<br class="title-page-name"/>        price_btc = NA,<br class="title-page-name"/>        price_usd = NA<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Now that we have our <kbd class="calibre9">Market</kbd> definition, we proceed to create our <kbd class="calibre9">Exchange</kbd> definition. This class will receive an exchange name as <kbd class="calibre9">name</kbd> and will use the <kbd class="calibre9">exchange_requester_factory()</kbd> function to get an instance of the corresponding <kbd class="calibre9">ExchangeRequester</kbd>. It also offers an <kbd class="calibre9">update_markets()</kbd> method that will be used to retrieve market data with the private <kbd class="calibre9">markets()</kbd> method and store it to disk using the <kbd class="calibre9">timestamp</kbd> and <kbd class="calibre9">storage</kbd> objects being passed to it. Note that instead of passing the <kbd class="calibre9">timestamp</kbd> through the arguments for the private <kbd class="calibre9">markets()</kbd> method, it's saved as a class attribute and used within the private <kbd class="calibre9">insert_metadata()</kbd> method. This technique provides cleaner code, since the <kbd class="calibre9">timestamp</kbd> does not need to be passed through each function and can be retrieved when necessary.</p>
<p class="calibre2">The private <kbd class="calibre9">markets()</kbd> method calls the public <kbd class="calibre9">markets()</kbd> method in the <kbd class="calibre9">ExchangeRequester</kbd> instance saved in the private <kbd class="calibre9">requester</kbd> attribute (which was assigned to by the factory) and applies the private <kbd class="calibre9">insert_metadata()</kbd> method to update the <kbd class="calibre9">timestamp</kbd> for such objects with the one sent to the public <kbd class="calibre9">update_markets()</kbd> method call before sending them to be written to the database:</p>
<pre class="mce-root">source("./requesters/exchange-requester-factory.R", chdir = TRUE)<br class="title-page-name"/><br class="title-page-name"/>Exchange &lt;- R6Class(<br class="title-page-name"/>    "Exchange",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(name) {<br class="title-page-name"/>            private$requester &lt;- exchange_requester_factory(name)<br class="title-page-name"/>        },<br class="title-page-name"/>        update_markets = function(timestamp, storage) {<br class="title-page-name"/>            private$timestamp &lt;- unclass(timestamp)<br class="title-page-name"/>            storage$write_markets(private$markets())<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        requester = NULL,<br class="title-page-name"/>        timestamp = NULL,<br class="title-page-name"/>        markets = function() {<br class="title-page-name"/>            return(lapply(private$requester$markets(), private$insert_metadata))<br class="title-page-name"/>        },<br class="title-page-name"/>        insert_metadata = function(market) {<br class="title-page-name"/>            market$set_timestamp(private$timestamp)<br class="title-page-name"/>            return(market)<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Now, we need to provide a definition for our <kbd class="calibre9">ExchangeRequester</kbd> implementations. As in the case of the <kbd class="calibre9">Database</kbd>, this <kbd class="calibre9">ExchangeRequester</kbd> will act as an interface definition that will be implemented by the <kbd class="calibre9">CoinMarketCapRequester</kbd>. We see that the <kbd class="calibre9">ExchangeRequester</kbd> specifies that all exchange requester instances should provide a public <kbd class="calibre9">markets()</kbd> method, and that a list is expected from such a method. From context, we know that this list should contain <kbd class="calibre9">Market</kbd> instances. Also, each <kbd class="calibre9">ExchangeRequester</kbd> implementation will contain a <kbd class="calibre9">Requester</kbd> object by default, since it's being created and assigned to the <kbd class="calibre9">requester</kbd> private attribute upon class instantiation. Finally, each implementation will also have to provide a <kbd class="calibre9">create_market()</kbd> private method and will be able to use the <kbd class="calibre9">request()</kbd> private method to communicate to the <kbd class="calibre9">Requester</kbd> method <kbd class="calibre9">request()</kbd> we defined previously:</p>
<pre class="mce-root">source("../../../utilities/requester.R")<br class="title-page-name"/><br class="title-page-name"/>KNOWN_ASSETS = list(<br class="title-page-name"/>    "BTC" = "Bitcoin",<br class="title-page-name"/>    "LTC" = "Litecoin"<br class="title-page-name"/>)<br class="title-page-name"/>ExchangeRequester &lt;- R6Class(<br class="title-page-name"/>    "ExchangeRequester",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        markets = function() list()<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        requester = Requester$new(),<br class="title-page-name"/>        create_market = function(resp) NULL,<br class="title-page-name"/>        request = function(URL) {<br class="title-page-name"/>            return(private$requester$request(URL))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Now we proceed to provide an implementation for <kbd class="calibre9">CoinMarketCapRequester</kbd>. As you can see, it inherits from <kbd class="calibre9">ExchangeRequester</kbd>, and it provides the required method implementations. Specifically, the <kbd class="calibre9">markets()</kbd> public method calls the private <kbd class="calibre9">request()</kbd> method from <kbd class="calibre9">ExchangeRequester</kbd>, which in turn calls the <kbd class="calibre9">request()</kbd> method from <kbd class="calibre9">Requester</kbd>, as we have seen, to retrieve data from the private <kbd class="calibre9">URL</kbd> specified.</p>
<p class="calibre2">If you request data from CoinMarketCap's API by opening a web browser and navigating to the URL shown (<a href="https://api.coinmarketcap.com/v1/ticker" class="calibre4">https://api.coinmarketcap.com/v1/ticker</a>), you will get a list of market data. That is the data that will be received in our <kbd class="calibre9">CoinMarketCapRequester</kbd> instance in the form of a dataframe, thanks to the <kbd class="calibre9">Requester</kbd> object, and will be transformed into numeric data where appropriate using the private <kbd class="calibre9">clean()</kbd> method, so that it's later used to create <kbd class="calibre9">Market</kbd> instances with the <kbd class="calibre9">apply()</kbd> function call, which in turn calls the <kbd class="calibre9">create_market()</kbd> private method. Note that the <kbd class="calibre9">timestamp</kbd> is set to <kbd class="calibre9">NULL</kbd> for all markets created this way because, as you may remember from our <kbd class="calibre9">Exchange</kbd> class, it's set before writing it to the database. There's no need to send the <kbd class="calibre9">timestamp</kbd> information all the way down to the <kbd class="calibre9">CoinMarketCapRequester</kbd>, since we can simply write at the <kbd class="calibre9">Exchange</kbd> level right before we send the data to the database:</p>
<pre class="mce-root">source("./exchange-requester.R")<br class="title-page-name"/>source("../market.R")<br class="title-page-name"/><br class="title-page-name"/>CoinMarketCapRequester &lt;- R6Class(<br class="title-page-name"/>    "CoinMarketCapRequester",<br class="title-page-name"/>    inherit = ExchangeRequester,<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        markets = function() {<br class="title-page-name"/>            data &lt;- private$clean(private$request(private$URL))<br class="title-page-name"/>            return(apply(data, 1, private$create_market))<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        URL = "https://api.coinmarketcap.com/v1/ticker",<br class="title-page-name"/>        create_market = function(row) {<br class="title-page-name"/>            timestamp &lt;- NULL<br class="title-page-name"/>            return(Market$new(<br class="title-page-name"/>                timestamp,<br class="title-page-name"/>                row[["name"]],<br class="title-page-name"/>                row[["symbol"]],<br class="title-page-name"/>                row[["rank"]],<br class="title-page-name"/>                row[["price_btc"]],<br class="title-page-name"/>                row[["price_usd"]]<br class="title-page-name"/>            ))<br class="title-page-name"/>        },<br class="title-page-name"/>        clean = function(data) {<br class="title-page-name"/>            data$price_usd &lt;- as.numeric(data$price_usd)<br class="title-page-name"/>            data$price_btc &lt;- as.numeric(data$price_btc)<br class="title-page-name"/>            data$rank &lt;- as.numeric(data$rank)<br class="title-page-name"/>            return(data)<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Finally, here's the code for our <kbd class="calibre9">exchange_requester_factory().</kbd> As you can see, it's basically the same idea we have used for our other factories, and its purpose is to easily let us add more implementations for our <kbd class="calibre9">ExchangeRequeseter</kbd> by simply adding <em class="calibre19">else-if</em> statements in it:</p>
<pre class="mce-root">source("./coinmarketcap-requester.R")<br class="title-page-name"/><br class="title-page-name"/>exchange_requester_factory &lt;- function(name) {<br class="title-page-name"/>    if (name == "CoinMarketCap") {<br class="title-page-name"/>        return(CoinMarketCapRequester$new())<br class="title-page-name"/>    } else {<br class="title-page-name"/>        stop("Unknown exchange name")<br class="title-page-name"/>    }   <br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Developing our wallets infrastructure</h1>
                
            
            
                
<p class="calibre2">Now that we are able to retrieve live price data from exchanges, we turn to our <kbd class="calibre9">Wallet</kbd> definition. As you can see, it specifies the type of private attributes we expect for the data that it needs to handle, as well as the public <kbd class="calibre9">data()</kbd> method to create the list of data that needs to be saved to a database at some point.</p>
<p class="calibre2">It also provides getters for <kbd class="calibre9">email</kbd>, <kbd class="calibre9">symbol</kbd>, and <kbd class="calibre9">address</kbd>, and the public <kbd class="calibre9">pudate_assets()</kbd> method, which will be used to get and save assets into the database, just as we did in the case of <kbd class="calibre9">Exchange</kbd>. As a matter of fact, the techniques followed are exactly the same, so we won't explain them again:</p>
<pre class="mce-root">source("./requesters/wallet-requester-factory.R", chdir = TRUE)<br class="title-page-name"/><br class="title-page-name"/>Wallet &lt;- R6Class(<br class="title-page-name"/>    "Wallet",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(email, symbol, address, note) {<br class="title-page-name"/>            private$requester &lt;- wallet_requester_factory(symbol, address)<br class="title-page-name"/>            private$email &lt;- email<br class="title-page-name"/>            private$symbol &lt;- symbol<br class="title-page-name"/>            private$address &lt;- address<br class="title-page-name"/>            private$note &lt;- note<br class="title-page-name"/>        },<br class="title-page-name"/>        data = function() {<br class="title-page-name"/>            return(list(<br class="title-page-name"/>                email = private$email,<br class="title-page-name"/>                symbol = private$symbol,<br class="title-page-name"/>                address = private$address,<br class="title-page-name"/>                note = private$note<br class="title-page-name"/>            ))<br class="title-page-name"/>        },<br class="title-page-name"/>        get_email = function() {<br class="title-page-name"/>            return(as.character(private$email))<br class="title-page-name"/>        },<br class="title-page-name"/>        get_symbol = function() {<br class="title-page-name"/>            return(as.character(private$symbol))<br class="title-page-name"/>        },<br class="title-page-name"/>        get_address = function() {<br class="title-page-name"/>            return(as.character(private$address))<br class="title-page-name"/>        },<br class="title-page-name"/>        update_assets = function(timestamp, storage) {<br class="title-page-name"/>            private$timestamp &lt;- timestamp<br class="title-page-name"/>            storage$write_assets(private$assets())<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        timestamp = NULL,<br class="title-page-name"/>        requester = NULL,<br class="title-page-name"/>        email = NULL,<br class="title-page-name"/>        symbol = NULL,<br class="title-page-name"/>        address = NULL,<br class="title-page-name"/>        note = NULL,<br class="title-page-name"/>        assets = function() {<br class="title-page-name"/>            return (lapply (<br class="title-page-name"/>                    private$requester$assets(), <br class="title-page-name"/>                    private$insert_metadata))<br class="title-page-name"/>        },<br class="title-page-name"/>        insert_metadata = function(asset) {<br class="title-page-name"/>            timestamp(asset) &lt;- unclass(private$timestamp)<br class="title-page-name"/>            email(asset) &lt;- private$email<br class="title-page-name"/>            return(asset)<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Implementing our wallet requesters</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre9">WalletRequester</kbd> will be conceptually similar to the <kbd class="calibre9">ExchangeRequester</kbd>. It will be an interface, and will be implemented in our <kbd class="calibre9">BTCRequester</kbd> and <kbd class="calibre9">LTCRequester</kbd> interfaces. As you can see, it requires a public method called <kbd class="calibre9">assets()</kbd> to be implemented and to return a list of <kbd class="calibre9">Asset</kbd> instances. It also requires a private <kbd class="calibre9">create_asset()</kbd> method to be implemented, which should return individual <kbd class="calibre9">Asset</kbd> instances, and a private <kbd class="calibre9">url</kbd> method that will build the URL required for the API call. It offers a <kbd class="calibre9">request()</kbd> private method that will be used by implementations to retrieve data from external APIs:</p>
<pre class="mce-root">source("../../../utilities/requester.R")<br class="title-page-name"/><br class="title-page-name"/>WalletRequester &lt;- R6Class(<br class="title-page-name"/>    "WalletRequester",<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        assets = function() list()<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        requester = Requester$new(),<br class="title-page-name"/>        create_asset = function() NULL,<br class="title-page-name"/>        url = function(address) "",<br class="title-page-name"/>        request = function(URL) {<br class="title-page-name"/>            return(private$requester$request(URL))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">The <kbd class="calibre9">BTCRequester</kbd> and <kbd class="calibre9">LTCRequester</kbd> implementations are shown below for completeness, but will not be explained. If you have followed everything so far, they should be easy to understand:</p>
<pre class="mce-root">source("./wallet-requester.R")<br class="title-page-name"/>source("../../asset.R")<br class="title-page-name"/><br class="title-page-name"/>BTCRequester &lt;- R6Class(<br class="title-page-name"/>    "BTCRequester",<br class="title-page-name"/>    inherit = WalletRequester,<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(address) {<br class="title-page-name"/>            private$address &lt;- address<br class="title-page-name"/>        },<br class="title-page-name"/>        assets = function() {<br class="title-page-name"/>            total &lt;- as.numeric(private$request(private$url()))<br class="title-page-name"/>            if (total &gt; 0) { return(list(private$create_asset(total))) }<br class="title-page-name"/>            return(list())<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        address = "",<br class="title-page-name"/>        url = function(address) {<br class="title-page-name"/>            return(paste(<br class="title-page-name"/>                "https://chainz.cryptoid.info/btc/api.dws",<br class="title-page-name"/>                "?q=getbalance",<br class="title-page-name"/>                "&amp;a=",<br class="title-page-name"/>                private$address,<br class="title-page-name"/>                sep = ""<br class="title-page-name"/>            ))<br class="title-page-name"/>        },<br class="title-page-name"/>        create_asset = function(total) {<br class="title-page-name"/>            return(new(<br class="title-page-name"/>                "Asset",<br class="title-page-name"/>                email = "",<br class="title-page-name"/>                timestamp = "",<br class="title-page-name"/>                name = "Bitcoin",<br class="title-page-name"/>                symbol = "BTC",<br class="title-page-name"/>                total = total,<br class="title-page-name"/>                address = private$address<br class="title-page-name"/>            ))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/>source("./wallet-requester.R")<br class="title-page-name"/>source("../../asset.R")<br class="title-page-name"/><br class="title-page-name"/>LTCRequester &lt;- R6Class(<br class="title-page-name"/>    "LTCRequester",<br class="title-page-name"/>    inherit = WalletRequester,<br class="title-page-name"/>    public = list(<br class="title-page-name"/>        initialize = function(address) {<br class="title-page-name"/>            private$address &lt;- address<br class="title-page-name"/>        },<br class="title-page-name"/>        assets = function() {<br class="title-page-name"/>            total &lt;- as.numeric(private$request(private$url()))<br class="title-page-name"/>            if (total &gt; 0) { return(list(private$create_asset(total))) }<br class="title-page-name"/>            return(list())<br class="title-page-name"/>        }<br class="title-page-name"/>    ),<br class="title-page-name"/>    private = list(<br class="title-page-name"/>        address = "",<br class="title-page-name"/>        url = function(address) {<br class="title-page-name"/>            return(paste(<br class="title-page-name"/>                "https://chainz.cryptoid.info/ltc/api.dws",<br class="title-page-name"/>                "?q=getbalance",<br class="title-page-name"/>                "&amp;a=",<br class="title-page-name"/>                private$address,<br class="title-page-name"/>                sep = ""<br class="title-page-name"/>            ))<br class="title-page-name"/>        },<br class="title-page-name"/>        create_asset = function(total) {<br class="title-page-name"/>            return(new(<br class="title-page-name"/>                "Asset",<br class="title-page-name"/>                email = "",<br class="title-page-name"/>                timestamp = "",<br class="title-page-name"/>                name = "Litecoin",<br class="title-page-name"/>                symbol = "LTC",<br class="title-page-name"/>                total = total,<br class="title-page-name"/>                address = private$address<br class="title-page-name"/>            ))<br class="title-page-name"/>        }<br class="title-page-name"/>    )<br class="title-page-name"/>)<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The <kbd class="calibre9">wallet_requester_factory()</kbd> works just as the other factories; the only difference is that in this case, we have two possible implementations that can be returned, which can be seen in the <kbd class="calibre9">if</kbd> statement. If we decided to add a <kbd class="calibre9">WalletRequester</kbd> for another cryptocurrency, such as Ether, we could simply add the corresponding branch here, and it should work fine:</p>
<pre class="mce-root">source("./btc-requester.R")<br class="title-page-name"/>source("./ltc-requester.R")<br class="title-page-name"/><br class="title-page-name"/>wallet_requester_factory &lt;- function(symbol, address) {<br class="title-page-name"/>    if (symbol == "BTC") {<br class="title-page-name"/>        return(BTCRequester$new(address))<br class="title-page-name"/>    } else if (symbol == "LTC") {<br class="title-page-name"/>        return(LTCRequester$new(address))<br class="title-page-name"/>    } else {<br class="title-page-name"/>        stop("Unknown symbol")<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Finally introducing users with S3 classes</h1>
                
            
            
                
<p class="calibre2">Our object-oriented system is almost finalized. We're only missing the <kbd class="calibre9">User</kbd> definition. In this case, we will use S3 to define the <kbd class="calibre9">User</kbd> class. The <kbd class="calibre9">user_constructor()</kbd> function takes an <kbd class="calibre9">email</kbd> and a <kbd class="calibre9">Storage</kbd> instance in <kbd class="calibre9">storage</kbd> to create a <kbd class="calibre9">User</kbd> instance. However, before it does, it checks that the email is valid with the <kbd class="calibre9">valid_email()</kbd> function defined below. After the user has been created, the <kbd class="calibre9">get_wallets()</kbd> method is called upon it to get the wallets associated to the user before it's sent back.</p>
<p class="calibre2">The <kbd class="calibre9">valid_email()</kbd> function simply receives a string which is supposed to be an email address, and checks whether at least one <kbd class="calibre9">@</kbd> and one <kbd class="calibre9">.</kbd> symbol are contained within it. Of course, this is not a robust mechanism to check whether or not it's an email address, and it's put here just to illustrate how a checking mechanism could be implemented:</p>
<pre class="mce-root">source("../assets/wallets/wallet.R", chdir = TRUE)<br class="title-page-name"/><br class="title-page-name"/>user_constructor &lt;- function(email, storage) {<br class="title-page-name"/>    if (!valid_email(email)) { stop("Invalid email") }<br class="title-page-name"/>    user &lt;- list(storage = storage, email = email, wallets = list())<br class="title-page-name"/>    class(user) &lt;- "User"<br class="title-page-name"/>    user &lt;- get_wallets(user)<br class="title-page-name"/>    return(user)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>valid_email &lt;- function(string) {<br class="title-page-name"/>    if (grepl("@", string) &amp;&amp; grepl(".", string)) { return(TRUE) }<br class="title-page-name"/>    return(FALSE)<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">get_wallets.User()</kbd> function simply asks the <kbd class="calibre9">storage</kbd> attribute in the object to get the wallets associated to its own email address, assigns them to the <kbd class="calibre9">wallets</kbd> list attribute, and sends the <kbd class="calibre9">User</kbd> object back:</p>
<pre class="mce-root">get_wallets.User &lt;- function(user) {<br class="title-page-name"/>    user$wallets &lt;- user$storage$read_wallets(user$email)<br class="title-page-name"/>    return(user)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>get_wallets &lt;- function(object) {<br class="title-page-name"/>    UseMethod("get_wallets")<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">new_wallet.User()</kbd> function receives a <kbd class="calibre9">User</kbd> instance, a <kbd class="calibre9">symbol</kbd> string, an <kbd class="calibre9">address</kbd> string, and <kbd class="calibre9">note</kbd> string to create a new <kbd class="calibre9">Wallet</kbd> instance and append it to the <kbd class="calibre9">wallets</kbd> list attribute for the <kbd class="calibre9">User</kbd> instance passed to it. However, before it does, it checks in all previous registered wallets for the user. If it finds that a wallet is already registered, it simply ignores the addition and sends the same <kbd class="calibre9">User</kbd> instance back. This is another type of checking that you may implement in your own systems:</p>
<pre class="mce-root">new_wallet.User &lt;- function(user, symbol, address, note) {<br class="title-page-name"/>    if (length(user$wallets) &gt;= 1) {<br class="title-page-name"/>        for (wallet in user$wallets) {<br class="title-page-name"/>            if (wallet$get_symbol() == symbol &amp;<br class="title-page-name"/>                wallet$get_address() == address) {<br class="title-page-name"/>                return(user)<br class="title-page-name"/>            }<br class="title-page-name"/>       }<br class="title-page-name"/>   }<br class="title-page-name"/>   wallet &lt;- Wallet$new(user$email, symbol, address, note)<br class="title-page-name"/>   user$wallets &lt;- c(user$wallets, list(wallet))<br class="title-page-name"/>   return(user)<br class="title-page-name"/>}<br class="title-page-name"/>new_wallet &lt;- function(object, symbol, address, note) {<br class="title-page-name"/>    UseMethod("new_wallet")<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">update_assets.User()</kbd> function simply goes through each <kbd class="calibre9">Wallet</kbd> instance in the <kbd class="calibre9">wallets</kbd> list attribute and calls its public <kbd class="calibre9">update_assets()</kbd> method with the current <kbd class="calibre9">timestamps</kbd> that was passed to it and the <kbd class="calibre9">Storage</kbd> instance contained within the <kbd class="calibre9">User</kbd> instance. As we have seen before, this results in the assets being updated and saved to the database, and the <kbd class="calibre9">Wallet</kbd> object takes care of that on behalf of the <kbd class="calibre9">User</kbd> instance:</p>
<pre class="mce-root">update_assets.User &lt;- function(user, timestamp) {<br class="title-page-name"/>    for (wallet in user$wallets) {<br class="title-page-name"/>        wallet$update_assets(timestamp, user$storage)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>update_assets &lt;- function(object, timestamp) {<br class="title-page-name"/>    UseMethod("update_assets")<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre9">save.User()</kbd> function simply uses the <kbd class="calibre9">storage</kbd> attribute to save the <kbd class="calibre9">User</kbd> instance as well as its wallets data. As we have seen, if the wallets already exist in the saved data, they will not be duplicated, and the <kbd class="calibre9">CSVFiles</kbd> implementation takes care of that on behalf of the <kbd class="calibre9">User</kbd> instance:</p>
<pre class="mce-root">save.User &lt;- function(user) {<br class="title-page-name"/>    user$storage$write_user(user)<br class="title-page-name"/>    user$storage$write_wallets(user$wallets)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>save &lt;- function(object) {<br class="title-page-name"/>    UseMethod("save")<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, the user provides a <kbd class="calibre9">dataS3.User()</kbd> method to return a list with a user's email to be saved back to the database:</p>
<pre class="mce-root">dataS3.User &lt;- function(user) {<br class="title-page-name"/>    return(list(email = user$email))<br class="title-page-name"/>}<br class="title-page-name"/>dataS3 &lt;- function(object) {<br class="title-page-name"/>    UseMethod("dataS3")<br class="title-page-name"/>}</pre>
<p class="calibre2">As we have seen in this section, after some work has been put into place, we can develop nice and intuitive abstractions that leverage the functionality implemented in other objects to provide powerful mechanisms, like saving data into a database, with very simple calls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Helping ourselves with a centralized settings file</h1>
                
            
            
                
<p class="calibre2">Finally, we show the famous centralized settings file we have been mentioning throughout the example. As you can see, it is simply a list of lists that contains parameters for how our system should behave. Centralizing these options in a single file as we do here can often be very convenient. Instead of changing code when we want different behaviors from our system, we can simply change this file, and everything will be taken care of for us:</p>
<pre class="mce-root">SETTINGS &lt;- list(<br class="title-page-name"/>    "debug" = TRUE,<br class="title-page-name"/>    "storage" = list(<br class="title-page-name"/>        "read" = list(<br class="title-page-name"/>            "name" = "CSVFiles",<br class="title-page-name"/>            "environment" = "production"<br class="title-page-name"/>        ),<br class="title-page-name"/>        "write" = list(<br class="title-page-name"/>            list(<br class="title-page-name"/>                "name" = "CSVFiles",<br class="title-page-name"/>                "environment" = "production"<br class="title-page-name"/>            )<br class="title-page-name"/>        ),<br class="title-page-name"/>        "table_names" = list(<br class="title-page-name"/>            "production" = list(<br class="title-page-name"/>                "assets" = "production_assets",<br class="title-page-name"/>                "markets" = "production_markets",<br class="title-page-name"/>                "users" = "production_users",<br class="title-page-name"/>                "wallets" = "production_wallets"<br class="title-page-name"/>            ),<br class="title-page-name"/>            "development" = list(<br class="title-page-name"/>                "assets" = "development_assets",<br class="title-page-name"/>                "markets" = "development_markets",<br class="title-page-name"/>                "users" = "development_users",<br class="title-page-name"/>                "wallets" = "development_wallets"<br class="title-page-name"/>            )<br class="title-page-name"/>        )<br class="title-page-name"/>    ),<br class="title-page-name"/>    "batch_data_collection" = list(<br class="title-page-name"/>        "assets" = list(<br class="title-page-name"/>            "minutes" = 60<br class="title-page-name"/>       ),<br class="title-page-name"/>       "markets" = list(<br class="title-page-name"/>            "minutes" = 60<br class="title-page-name"/>       )<br class="title-page-name"/>    )<br class="title-page-name"/>)</pre>
<p class="calibre2">Specifically, note that there's a <kbd class="calibre9">debug</kbd> Boolean that we did not end up using, but which could be useful when debugging our system at some point. Also, note that there are two main parts to our settings file, the <kbd class="calibre9">storage</kbd> part and the <kbd class="calibre9">batch_data_collection</kbd> part. The <kbd class="calibre9">storage</kbd> part is the one we have used so far, and it contains the specification for which databases should be used to read and write data by providing the name of the implementation that should be used in the <kbd class="calibre9">name</kbd> elements, and the <kbd class="calibre9">environment</kbd> we're currently operating on, which can be either <kbd class="calibre9">production</kbd> or <kbd class="calibre9">development</kbd>. Both of these elements are used by the factories to set up the system appropriately before it starts operating. Also, note that the CSV files that will be created correspond to the strings found in the <kbd class="calibre9">table_names</kbd> element, and will be different, depending on the <kbd class="calibre9">environment</kbd> a database is indicated to operate under.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Saving our initial user data into the system</h1>
                
            
            
                
<p class="calibre2">Before we start using our system, we need to introduce some data into it that will be used to start retrieving data for us. Specifically, we need to create some users, add some wallets to them, and save them. To do so, we create a <kbd class="calibre9">create-user-data.R</kbd> file that contains the script that will accomplish this for us. The script loads the S4 and R6 object models (S3 does not need to be loaded explicitly), sources the files with the definitions we directly need, which are <kbd class="calibre9">Storage</kbd>, <kbd class="calibre9">User</kbd>, and <kbd class="calibre9">SETTINGS</kbd>, creates two users for us, and saves them:</p>
<pre class="mce-root">library(R6)<br class="title-page-name"/>library(methods)<br class="title-page-name"/><br class="title-page-name"/>source("../storage/storage.R", chdir = TRUE)<br class="title-page-name"/>source("../users/user.R")<br class="title-page-name"/>source("../settings.R")<br class="title-page-name"/><br class="title-page-name"/>storage = Storage$new(SETTINGS)<br class="title-page-name"/>user_1 &lt;- user_constructor("1@somewhere.com", storage)<br class="title-page-name"/><br class="title-page-name"/>user_1 &lt;- new_wallet(user_1, <br class="title-page-name"/>                     "BTC", <br class="title-page-name"/>                     "3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r", "")<br class="title-page-name"/><br class="title-page-name"/>user_1 &lt;- new_wallet(user_1, <br class="title-page-name"/>                     "LTC", <br class="title-page-name"/>                     "LdP8Qox1VAhCzLJNqrr74YovaWYyNBUWvL", "")<br class="title-page-name"/>save(user_1)<br class="title-page-name"/><br class="title-page-name"/>user_2 &lt;- user_constructor("2@somewhere.com", storage)<br class="title-page-name"/><br class="title-page-name"/>user_2 &lt;- new_wallet(user_2, <br class="title-page-name"/>                     "BTC", <br class="title-page-name"/>                     "16rCmCmbuWDhPjWTrpQGaU3EPdZF7MTdUk", "")<br class="title-page-name"/><br class="title-page-name"/>user_2 &lt;- new_wallet(user_2, <br class="title-page-name"/>                     "LTC", <br class="title-page-name"/>                     "LbGi4Ujj2dhcMdiS9vaCpWxtayBujBQYZw", "")<br class="title-page-name"/>save(user_2)</pre>
<p class="calibre2">After the script is executed, you can look into the <kbd class="calibre9">csv-files/</kbd> directory and find the corresponding data inside. In this case, we used wallets with the most Bitcoin and Litecoin, which can be found online (<a href="https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html" class="calibre4">https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html</a> and <a href="https://bitinfocharts.com/top-100-richest-litecoin-addresses.html" class="calibre4">https://bitinfocharts.com/top-100-richest-litecoin-addresses.html</a>). You may experiment using your own wallets, or any wallet whose contents you want to track. Of course, the <kbd class="calibre9">email</kbd> and <kbd class="calibre9">note</kbd> parameters don't need to be real; the only parameters that must be real are the asset symbols, which can only be <kbd class="calibre9">BTC</kbd> or <kbd class="calibre9">LTC</kbd> for the system we have implemented, and the wallets addresses for such symbols. You may leave the <kbd class="calibre9">note</kbd> field empty, as we do in the example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Activating our system with two simple functions</h1>
                
            
            
                
<p class="calibre2">After you have loaded some data into the system, you will be able to execute the <kbd class="calibre9">update-markets.R</kbd> and <kbd class="calibre9">update-assets.R</kbd> files, whose contents are shown below. The first one loads the required definitions, as we did previously when creating the user data, and provides the <kbd class="calibre9">update_markets_loop()</kbd> function, which receives a parameter that specifies the number of minutes between each time the live market data is retrieved. Every 60 minutes is a good option, and it's what we use below. The function simply creates a <kbd class="calibre9">Storage</kbd> instance using the <kbd class="calibre9">SETTINGS</kbd> specification shown before, gets the existing exchanges (which is only <kbd class="calibre9">CoinMarketCap</kbd> at this point), and calls the public <kbd class="calibre9">update_markets()</kbd> method on each of them, with the corresponding parameters:</p>
<pre class="mce-root">library(R6)<br class="title-page-name"/>library(methods)<br class="title-page-name"/><br class="title-page-name"/>source("../storage/storage.R", chdir = TRUE)<br class="title-page-name"/>source("../utilities/time-stamp.R")<br class="title-page-name"/>source("../settings.R")<br class="title-page-name"/><br class="title-page-name"/>update_markets_loop &lt;- function(minutes_interval) {<br class="title-page-name"/>    storage = Storage$new(SETTINGS)<br class="title-page-name"/>    exchanges &lt;- storage$read_exchanges()<br class="title-page-name"/>    repeat {<br class="title-page-name"/>        timestamp = now.TimeStamp()<br class="title-page-name"/>        for (exchange in exchanges) {<br class="title-page-name"/>            exchange$update_markets(timestamp, storage)<br class="title-page-name"/>        }<br class="title-page-name"/>        Sys.sleep(minutes_interval * 60)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>update_markets_loop(60)</pre>
<p class="calibre2">When you execute this file, you will see some data showing the progress in your console like the one shown below. Note that we start the script with the <kbd class="calibre9">Rscript</kbd> command we mentioned in <a target="_blank" href="part0022.html#KVCC0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 1</a>, <em class="calibre19">Introduction to R:</em></p>
<pre class="mce-root"><strong class="calibre1">$ Rscript update-markets.R
</strong>
...
         timestamp    name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Bitcoin    BTC    1 1.00000000 8.12675e+03
         timestamp     name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Ethereum    ETH    2 0.04440240 3.61538e+02
         timestamp         name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Bitcoin Cash    BCH    3 0.14527100 1.18284e+03
         timestamp   name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Ripple    XRP    4 0.00002866 2.33352e-01
         timestamp name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Dash   DASH    5 0.06127300 4.98903e+02
         timestamp     name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Litecoin    LTC    6 0.00863902 7.03415e+01
         timestamp name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 IOTA  MIOTA    7 0.00011163 9.08941e-01
         timestamp name symbol rank  price_btc   price_usd
1 2017-11-21-20-03  NEO    NEO    8 0.00427168 3.47813e+01
         timestamp   name symbol rank  price_btc   price_usd
1 2017-11-21-20-03 Monero    XMR    9 0.01752360 1.42683e+02
         timestamp name symbol rank  price_btc   price_usd
1 2017-11-21-20-03  NEM    XEM   10 0.00002513 2.04613e-01
...</pre>
<p class="calibre2">The <kbd class="calibre9">update_assets_loop()</kbd> function works similarly, but it retrieves the users in each iteration, which dynamically adapts to include any user additions or deletions that may have happened while the function was waiting for its next cycle, and calls the <kbd class="calibre9">update_assets()</kbd> public method for each <kbd class="calibre9">User</kbd> instance:</p>
<pre class="mce-root">library(R6)<br class="title-page-name"/>library(methods)<br class="title-page-name"/><br class="title-page-name"/>source("../storage/storage.R", chdir = TRUE)<br class="title-page-name"/>source("../utilities/time-stamp.R")<br class="title-page-name"/>source("../settings.R")<br class="title-page-name"/><br class="title-page-name"/>update_assets_loop &lt;- function(minutes_interval) {<br class="title-page-name"/>    storage = Storage$new(SETTINGS)<br class="title-page-name"/>    repeat {<br class="title-page-name"/>        users &lt;- storage$read_users()<br class="title-page-name"/>        timestamp = now.TimeStamp()<br class="title-page-name"/>        lapply(users, update_assets, timestamp)<br class="title-page-name"/>        Sys.sleep(minutes_interval * 60)<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/>update_assets_loop(60)</pre>
<p class="calibre2">An example of output for the <kbd class="calibre9">update-assets.R</kbd> file is shown here:</p>
<pre class="mce-root"><strong class="calibre1">$ Rscript update-markets.R</strong>
<br class="title-page-name"/>...
            email        timestamp    name symbol    total
1 1@somewhere.com 2017-11-21-20-02 Bitcoin    BTC 76031.29
                             address
1 3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r
            email        timestamp     name symbol   total
1 1@somewhere.com 2017-11-21-20-02 Litecoin    LTC 1420001
                             address
1 LdP8Qox1VAhCzLJNqrr74YovaWYyNBUWvL
            email        timestamp    name symbol total
1 2@somewhere.com 2017-11-21-20-02 Bitcoin    BTC 14001
                             address
1 16rCmCmbuWDhPjWTrpQGaU3EPdZF7MTdUk
            email        timestamp     name symbol   total
1 2@somewhere.com 2017-11-21-20-02 Litecoin    LTC 1397089
                             address
1 LbGi4Ujj2dhcMdiS9vaCpWxtayBujBQYZw
...</pre>
<p class="calibre2">When you execute these two files, the whole object-oriented system we developed will start working to retrieve live data periodically and save it in the corresponding CSV files. You may look directly into these files to see what data is being saved. Remember that if a wallet does not contain a positive number of an asset, it will not be shown.</p>
<p class="calibre2">When you implement your first object-oriented system, it almost feels magical. If this is the first object-oriented system you have built, I certainly hope you got that feeling, and I also hope this example was interesting and useful for you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Some advice when working with object-oriented systems</h1>
                
            
            
                
<p class="calibre2">Object-oriented programming allows for a lot of flexibility, but if it's used incorrectly, it can also cause a lot of confusion, since it's easy to develop very complex systems when much simpler solutions would suffice.</p>
<p class="calibre2">You should start a small working system before evolving it into more complex ones. Also, realize that most real-world designs are over-constrained, and you will not be able to please everyone, so you must decide on the priorities for your system.</p>
<p class="calibre2">Each part of your system should focus on a single thing, and doing that thing well. When in doubt, make shorter things. Make shorter classes and shorter methods. Doing so will force your objects to focus on a single responsibility, which will in turn improve your design and will allow you to reuse code more easily.</p>
<p class="calibre2">Make your objects as private as possible. Public classes should not have any public fields, that is, you should use encapsulation everywhere. Maximize information hiding and minimize coupling. Also, remember that names matter. Avoid cryptic abbreviations in your code, and be consistent. The same word should mean the same thing everywhere in your system.</p>
<p class="calibre2">Finally, try to keep your code as immutable as possible. This produces code that is easy to understand, is much more reusable, and is thread-safe, which can be very useful when parallelizing, as we will see in the next chapter. However, if you implement a mutable system, keep the state space as small as possible.</p>
<p class="calibre2">As general advice, your design should be easy to understand and difficult to misuse, even without documentation. Your code should be easily readable and easily maintainable, and the effort you invest in making code that is easy to change should be positively correlated with the likelihood of such change happening.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we have introduced the fundamentals behind object-oriented programming, and we have seen how to implement object-oriented systems within R with three different object models: S3, S4, and R6. We looked at the fundamental building blocks of object models, such as encapsulation, polymorphism, and hierarchies. We have shown you how to implement parametric polymorphism with S3 and S4, as well as regular polymorphism with R6, and we have shown how to use concepts like interfaces, even when there's no explicit support for them in R.</p>
<p class="calibre2">We have implemented a full object-oriented system to track cryptocurrencies information, and, while doing so, have looked at various patterns and techniques, as well as how the three different object models can be used together.</p>
<p class="calibre2">The type of object model to use is the subject of some controversy among R programmers, and the decision depends on how flexible, formal, or intuitive you want the code to be. In general, if you prefer more flexibility use S3, if you prefer more formality and robustness use S4, and if you prefer your code to be easily understandable and intuitive to people who come from other languages and are not familiar with S3 and S4, then use R6. However, controversy is still there.</p>
<p class="calibre2">John Chambers, the creator of the S language and one of the central developers of R, recommends S4 over S3 in his book, <em class="calibre19">Software for Data Analysis</em>, Springer, 2008. Google's <em class="calibre19">R Style Guide</em> (<a href="https://google.github.io/styleguide/Rguide.xml" class="calibre4">https://google.github.io/styleguide/Rguide.xml</a>) says that you should avoid S4 whenever possible, and should use S3 instead.</p>
<p class="calibre2">Hopefully, after having read this chapter, you will have a good idea of what system you'd prefer for your next project and why. In <a href="part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730" class="calibre4">Chapter 9</a>, <em class="calibre19">Implementing an Efficient Simple Moving Average</em>, we will continue to expand the system we created in this chapter to make it more performant when we start dealing with large amounts of data.</p>


            

            
        
    </body></html>