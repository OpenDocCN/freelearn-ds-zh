["```py\nimport pyspark.sql.types as typ\nlabels = [\n    ('INFANT_ALIVE_AT_REPORT', typ.StringType()),\n    ('BIRTH_YEAR', typ.IntegerType()),\n    ('BIRTH_MONTH', typ.IntegerType()),\n    ('BIRTH_PLACE', typ.StringType()),\n    ('MOTHER_AGE_YEARS', typ.IntegerType()),\n    ('MOTHER_RACE_6CODE', typ.StringType()),\n    ('MOTHER_EDUCATION', typ.StringType()),\n    ('FATHER_COMBINED_AGE', typ.IntegerType()),\n    ('FATHER_EDUCATION', typ.StringType()),\n    ('MONTH_PRECARE_RECODE', typ.StringType()),\n    ...\n    ('INFANT_BREASTFED', typ.StringType())\n]\nschema = typ.StructType([\n        typ.StructField(e[0], e[1], False) for e in labels\n    ])\n```", "```py\nbirths = spark.read.csv('births_train.csv.gz', \n                        header=True, \n                        schema=schema)\n```", "```py\nrecode_dictionary = {\n    'YNU': {\n        'Y': 1,\n        'N': 0,\n        'U': 0\n    }\n}\n```", "```py\nselected_features = [\n    'INFANT_ALIVE_AT_REPORT', \n    'BIRTH_PLACE', \n    'MOTHER_AGE_YEARS', \n    'FATHER_COMBINED_AGE', \n    'CIG_BEFORE', \n    'CIG_1_TRI', \n    'CIG_2_TRI', \n    'CIG_3_TRI', \n    'MOTHER_HEIGHT_IN', \n    'MOTHER_PRE_WEIGHT', \n    'MOTHER_DELIVERY_WEIGHT', \n    'MOTHER_WEIGHT_GAIN', \n    'DIABETES_PRE', \n    'DIABETES_GEST', \n    'HYP_TENS_PRE', \n    'HYP_TENS_GEST', \n    'PREV_BIRTH_PRETERM'\n]\nbirths_trimmed = births.select(selected_features)\n```", "```py\nimport pyspark.sql.functions as func\ndef recode(col, key):\n    return recode_dictionary[key][col] \ndef correct_cig(feat):\n    return func \\\n        .when(func.col(feat) != 99, func.col(feat))\\\n        .otherwise(0)\nrec_integer = func.udf(recode, typ.IntegerType())\n```", "```py\nbirths_transformed = births_trimmed \\\n    .withColumn('CIG_BEFORE', correct_cig('CIG_BEFORE'))\\\n    .withColumn('CIG_1_TRI', correct_cig('CIG_1_TRI'))\\\n    .withColumn('CIG_2_TRI', correct_cig('CIG_2_TRI'))\\\n    .withColumn('CIG_3_TRI', correct_cig('CIG_3_TRI'))\n```", "```py\ncols = [(col.name, col.dataType) for col in births_trimmed.schema]\nYNU_cols = []\nfor i, s in enumerate(cols):\n    if s[1] == typ.StringType():\n        dis = births.select(s[0]) \\\n            .distinct() \\\n            .rdd \\\n            .map(lambda row: row[0]) \\\n            .collect() \n        if 'Y' in dis:\n            YNU_cols.append(s[0])\n```", "```py\nbirths.select([\n        'INFANT_NICU_ADMISSION', \n        rec_integer(\n            'INFANT_NICU_ADMISSION', func.lit('YNU')\n        ) \\\n        .alias('INFANT_NICU_ADMISSION_RECODE')]\n     ).take(5)\n```", "```py\nexprs_YNU = [\n    rec_integer(x, func.lit('YNU')).alias(x) \n    if x in YNU_cols \n    else x \n    for x in births_transformed.columns\n]\nbirths_transformed = births_transformed.select(exprs_YNU)\n```", "```py\nbirths_transformed.select(YNU_cols[-5:]).show(5)\n```", "```py\nimport pyspark.mllib.stat as st\nimport numpy as np\nnumeric_cols = ['MOTHER_AGE_YEARS','FATHER_COMBINED_AGE',\n                'CIG_BEFORE','CIG_1_TRI','CIG_2_TRI','CIG_3_TRI',\n                'MOTHER_HEIGHT_IN','MOTHER_PRE_WEIGHT',\n                'MOTHER_DELIVERY_WEIGHT','MOTHER_WEIGHT_GAIN'\n               ]\nnumeric_rdd = births_transformed\\\n                       .select(numeric_cols)\\\n                       .rdd \\\n                       .map(lambda row: [e for e in row])\nmllib_stats = st.Statistics.colStats(numeric_rdd)\nfor col, m, v in zip(numeric_cols, \n                     mllib_stats.mean(), \n                     mllib_stats.variance()):\n    print('{0}: \\t{1:.2f} \\t {2:.2f}'.format(col, m, np.sqrt(v)))\n```", "```py\ncategorical_cols = [e for e in births_transformed.columns \n                    if e not in numeric_cols]\ncategorical_rdd = births_transformed\\\n                       .select(categorical_cols)\\\n                       .rdd \\\n                       .map(lambda row: [e for e in row])\nfor i, col in enumerate(categorical_cols):\n    agg = categorical_rdd \\\n        .groupBy(lambda row: row[i]) \\\n        .map(lambda row: (row[0], len(row[1])))\n    print(col, sorted(agg.collect(), \n                      key=lambda el: el[1], \n                      reverse=True))\n```", "```py\ncorrs = st.Statistics.corr(numeric_rdd)\nfor i, el in enumerate(corrs > 0.5):\n    correlated = [\n        (numeric_cols[j], corrs[i][j]) \n        for j, e in enumerate(el) \n        if e == 1.0 and j != i]\n    if len(correlated) > 0:\n        for e in correlated:\n            print('{0}-to-{1}: {2:.2f}' \\\n                  .format(numeric_cols[i], e[0], e[1]))\n```", "```py\nfeatures_to_keep = [\n    'INFANT_ALIVE_AT_REPORT', \n    'BIRTH_PLACE', \n    'MOTHER_AGE_YEARS', \n    'FATHER_COMBINED_AGE', \n    'CIG_1_TRI', \n    'MOTHER_HEIGHT_IN', \n    'MOTHER_PRE_WEIGHT', \n    'DIABETES_PRE', \n    'DIABETES_GEST', \n    'HYP_TENS_PRE', \n    'HYP_TENS_GEST', \n    'PREV_BIRTH_PRETERM'\n]\nbirths_transformed = births_transformed.select([e for e in features_to_keep])\n```", "```py\nimport pyspark.mllib.linalg as ln\nfor cat in categorical_cols[1:]:\n    agg = births_transformed \\\n        .groupby('INFANT_ALIVE_AT_REPORT') \\\n        .pivot(cat) \\\n        .count()    \n    agg_rdd = agg \\\n        .rdd \\\n        .map(lambda row: (row[1:])) \\\n        .flatMap(lambda row: \n                 [0 if e == None else e for e in row]) \\\n        .collect()\n    row_length = len(agg.collect()[0]) - 1\n    agg = ln.Matrices.dense(row_length, 2, agg_rdd)\n\n    test = st.Statistics.chiSqTest(agg)\n    print(cat, round(test.pValue, 4))\n```", "```py\nprint(ln.Matrices.dense(3,2, [1,2,3,4,5,6]))\n```", "```py\nimport pyspark.mllib.feature as ft\nimport pyspark.mllib.regression as reg\nhashing = ft.HashingTF(7)\nbirths_hashed = births_transformed \\\n    .rdd \\\n    .map(lambda row: [\n            list(hashing.transform(row[1]).toArray()) \n                if col == 'BIRTH_PLACE' \n                else row[i] \n            for i, col \n            in enumerate(features_to_keep)]) \\\n    .map(lambda row: [[e] if type(e) == int else e \n                      for e in row]) \\\n    .map(lambda row: [item for sublist in row \n                      for item in sublist]) \\\n    .map(lambda row: reg.LabeledPoint(\n            row[0], \n            ln.Vectors.dense(row[1:]))\n        )\n```", "```py\nbirths_train, births_test = births_hashed.randomSplit([0.6, 0.4])\n```", "```py\nfrom pyspark.mllib.classification \\\n    import LogisticRegressionWithLBFGS\nLR_Model = LogisticRegressionWithLBFGS \\\n    .train(births_train, iterations=10)\n```", "```py\nLR_results = (\n        births_test.map(lambda row: row.label) \\\n        .zip(LR_Model \\\n             .predict(births_test\\\n                      .map(lambda row: row.features)))\n    ).map(lambda row: (row[0], row[1] * 1.0))\n```", "```py\nimport pyspark.mllib.evaluation as ev\nLR_evaluation = ev.BinaryClassificationMetrics(LR_results)\nprint('Area under PR: {0:.2f}' \\\n      .format(LR_evaluation.areaUnderPR))\nprint('Area under ROC: {0:.2f}' \\\n      .format(LR_evaluation.areaUnderROC))\nLR_evaluation.unpersist()\n```", "```py\nselector = ft.ChiSqSelector(4).fit(births_train)\ntopFeatures_train = (\n        births_train.map(lambda row: row.label) \\\n        .zip(selector \\\n             .transform(births_train \\\n                        .map(lambda row: row.features)))\n    ).map(lambda row: reg.LabeledPoint(row[0], row[1]))\ntopFeatures_test = (\n        births_test.map(lambda row: row.label) \\\n        .zip(selector \\\n             .transform(births_test \\\n                        .map(lambda row: row.features)))\n    ).map(lambda row: reg.LabeledPoint(row[0], row[1]))\n```", "```py\nfrom pyspark.mllib.tree import RandomForest\nRF_model = RandomForest \\\n    .trainClassifier(data=topFeatures_train, \n                     numClasses=2, \n                     categoricalFeaturesInfo={}, \n                     numTrees=6,  \n                     featureSubsetStrategy='all',\n                     seed=666)\n```", "```py\nRF_results = (\n        topFeatures_test.map(lambda row: row.label) \\\n        .zip(RF_model \\\n             .predict(topFeatures_test \\\n                      .map(lambda row: row.features)))\n    )\nRF_evaluation = ev.BinaryClassificationMetrics(RF_results)\nprint('Area under PR: {0:.2f}' \\\n      .format(RF_evaluation.areaUnderPR))\nprint('Area under ROC: {0:.2f}' \\\n      .format(RF_evaluation.areaUnderROC))\nmodel_evaluation.unpersist()\n```", "```py\nLR_Model_2 = LogisticRegressionWithLBFGS \\\n    .train(topFeatures_train, iterations=10)\nLR_results_2 = (\n        topFeatures_test.map(lambda row: row.label) \\\n        .zip(LR_Model_2 \\\n             .predict(topFeatures_test \\\n                      .map(lambda row: row.features)))\n    ).map(lambda row: (row[0], row[1] * 1.0))\nLR_evaluation_2 = ev.BinaryClassificationMetrics(LR_results_2)\nprint('Area under PR: {0:.2f}' \\\n      .format(LR_evaluation_2.areaUnderPR))\nprint('Area under ROC: {0:.2f}' \\\n      .format(LR_evaluation_2.areaUnderROC))\nLR_evaluation_2.unpersist()\n```"]