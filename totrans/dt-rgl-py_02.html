<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer043" class="Content">
			<h1 id="_idParaDest-47"><em class="italics"><a id="_idTextAnchor058"/>Chapter 2</em></h1>
		</div>
		<div id="_idContainer044" class="Content">
			<h1 id="_idParaDest-48"><a id="_idTextAnchor059"/>Advanced Data Structures and File Handling</h1>
		</div>
		<div id="_idContainer045" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Compare Python’s advanced data structures</li>
				<li class="bullets">Utilize data structures to solve real-world problems </li>
				<li class="bullets">Make use of OS file-handling operations</li>
			</ul>
			<p>This chapter emphasizes the data structures in Python and the operating system functions that are the foundation of this book.</p>
		</div>
		<div id="_idContainer054" class="Content">
			<h2 id="_idParaDest-49"><a id="_idTextAnchor060"/>Introduction</h2>
			<p>We were introduced to the basic concepts of different fundamental data structures in the last chapter. We learned about the list, set, dict, tuple, and string. They are the building blocks of future chapters and are essential for data science.</p>
			<p>However, what we have covered so far were only basic operations on them. They have much more to offer once you learn how to utilize them effectively. In this chapter, we will venture further into the land of data structures. We will learn about advanced operations and manipulations and use these fundamental data structures to represent more complex and higher-level data structures; this is often handy while wrangling data in real life.</p>
			<p>In real life, we deal with data that comes from different sources and generally read data from a file or a database. We will be introduced to operations related to files. We will see how to open a file and how many ways there are to do it, how to read data from it, how to write data to it, and how to safely close it once we are done. The last part, which many people tend to ignore, is super important. We often run into very strange and hard-to-track-down bugs in a real-world system just because a process opened a file and did not close it properly. Without further ado, let's begin our journey.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor061"/>Advanced Data Structures</h2>
			<p>We will start this chapter by discussing advanced data structures. We will do that by revisiting lists. We will construct a stack and a queue, explore multiple element membership checking, and throw a bit of functional programming in for good measure. If all of this sounds intimidating, then do not worry. We will get to things step by step, like in the previous chapter, and you will feel confident once you have finished this chapter.</p>
			<p>To start this chapter, you have to open an empty notebook. To do that, you can simply input the following command in a shell. It is advised that you first navigate to an empty directory using <strong class="inline">cd</strong> before you enter the command:</p>
			<p class="snippet">docker run -p 8888:8888 -v 'pwd':/notebooks -it rcshubhadeep/packt-data-wrangling-base:latest</p>
			<p>Once the Docker container is running, point your browser to <a href="http://localhost:8888">http://localhost:8888</a> and use <strong class="inline">dw_4_all</strong> as the passcode to access the notebook interface.</p>
			<h3 id="_idParaDest-51"><a id="_idTextAnchor062"/>Iterator </h3>
			<p>We will start off this topic with lists. However, before we get into lists, we will introduce the concept of an iterator. An iterator is an object that implements the <strong class="inline">next</strong> method, meaning an iterator is an object that can iterate over a collection (lists, tuples, dicts, and so on). It is stateful, which means that each time we call the <strong class="inline">next</strong> method, it gives us the next element from the collection. And if there is no further element, then it raises a <strong class="inline">StopIteration</strong> exception.</p>
			<h4>Note</h4>
			<p class="callout">A <strong class="inline">StopIteration</strong> exception occurs with the iterator's next method when there are no further values to iterate.</p>
			<p>If you are familiar with a programming language like C, C++, Java, JavaScript, or PHP, you may have noticed the difference between the <strong class="inline">for</strong> <strong class="inline">loop</strong> implementation in those languages, which consists of three distinct parts, precisely the initiation, the increment, and the termination condition, and the <strong class="inline">for</strong> <strong class="inline">loop</strong> in Python. In Python, we do not use that kind of for loop. What we use in Python is more like a <strong class="inline">foreach</strong> loop: <strong class="inline">for</strong> <strong class="inline">i</strong> <strong class="inline">in</strong> <strong class="inline">list_1</strong>. This is because, under the hood, the for loop is using an iterator, and thus we do not need to do all the extra steps. The iterator does this for us.</p>
			<h3 id="_idParaDest-52"><a id="_idTextAnchor063"/>Exercise 15: Introduction to the Iterator</h3>
			<p>To generate lists of numbers, we can use different methods:</p>
			<ol>
				<li>Generate a list that will contain 10000000: ones:<p class="snippet">big_list_of_numbers = [1 for x in range(0, 10000000)]</p></li>
				<li>Check the size of this variable:<p class="snippet">from sys import getsizeof</p><p class="snippet">getsizeof(big_list_of_numbers)</p><p>The value it will show you will be something around <strong class="inline">81528056 </strong>(it is in bytes). This is a lot of memory! And the <strong class="inline">big_list_of_numbers</strong> variable is only available once the list comprehension is over. It can also overflow the available system memory if you try too big a number. </p></li>
				<li>Use an iterator to reduce memory utilization:<p class="snippet">from itertools import repeat</p><p class="snippet">small_list_of_numbers = repeat(1, times=10000000)</p><p class="snippet">getsizeof(small_list_of_numbers)</p><p>The last line shows that our <strong class="inline">small_list_of_numbers</strong> is only <strong class="inline">56</strong> bytes in size. Also, it is a lazy method, as it did not generate all the elements. It will generate them one by one when asked, thus saving us time. In fact, if you omit the <strong class="inline">times</strong> keyword argument, then you can practically generate an infinite number of 1s.</p></li>
				<li>Loop over the newly generated iterator:<p class="snippet">for i, x in enumerate(small_list_of_numbers): </p><p class="snippet">    print(x)</p><p class="snippet">    if i &gt; 10:</p><p class="snippet">        break</p><p>We use the <strong class="inline">enumerate</strong> function so that we get the loop counter, along with the values. This will help us break once we reach a certain number of the counter (10 for example).</p><p>The output will be a list of 10 ones.</p></li>
				<li>To look up the definition of any function, type the function name, followed by a <em class="italics">?</em> and press <em class="italics">Shift </em>+<span class="HTML-Code"> </span><em class="italics">Enter</em> in a Jupyter notebook. Run the following code to understand how we can use permutations and combinations with itertools:<p class="snippet">from itertools import (permutations, combinations, dropwhile, repeat,</p><p class="snippet">zip_longest)</p><p class="snippet">permutations?</p><p class="snippet">combinations?</p><p class="snippet">dropwhile?</p><p class="snippet">repeat?</p><p class="snippet">zip_longest?</p></li>
			</ol>
			<h3 id="_idParaDest-53"><a id="_idTextAnchor064"/>Stacks</h3>
			<p><a id="_idTextAnchor065"/>A stack is a very useful data structure. If you know a bit about CPU internals and how a program gets executed, then you have an idea that a stack is present in many such cases. It is simply a list with one restriction, Last In First Out (LIFO), meaning an element that comes in last goes out first when a value is read from a stack. The following illustration will make this a bit clearer:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="Images/Figure_2.1.jpg" alt="Figure 2.1: A stack with two insert and one pop operation" width="521" height="206"/>
				</div>
			</div>
			<h6>Figure 2.1: A stack with two insert elements and one pop operation</h6>
			<p>As you can see, we have a LIFO strategy to read values from a stack. We will implement a stack using a Python list. Python's lists have a method called <strong class="inline">pop</strong>, which does the exact same pop operation that you can see in the preceding illustration. We will use that to implement a stack.</p>
			<h3 id="_idParaDest-54"><a id="_idTextAnchor066"/>Exercise 16: Implementing a Stack in Python</h3>
			<ol>
				<li value="1">First, define an empty stack:<p class="snippet">stack = []</p></li>
				<li>Use the append method to add an element in the stack. Thanks to append, the element will be always appended at the end of the list:<p class="snippet">stack.append(25)</p><p class="snippet">stack</p><p>The output is as follows:</p><p class="snippet">[25]</p></li>
				<li>Append another value to the stack:<p class="snippet">stack.append(-12)</p><p class="snippet">stack</p><p>The output is as follows:</p><p class="snippet">[25, -12]</p></li>
				<li>Read a value from our stack using the <strong class="inline">pop</strong> method. This method reads at the current last index of the list and returns it to us. It also deletes the index once the read is done:<p class="snippet">tos = stack.pop()tos</p><p>The output is as follows:</p><p class="snippet">-12</p><p>After we execute the preceding code, we will have -12 in <strong class="inline">tos</strong> and the stack will have only one element in it, <strong class="inline">25</strong>. </p></li>
				<li>Append hello to the stack:<p class="snippet">stack.append("Hello")</p><p class="snippet">stack</p><p>The output is as follows:</p><p class="snippet">[25, 'Hello']</p></li>
			</ol>
			<p>Imagine you are scraping a web page and you want to follow each URL that is present there. If you insert (append) them one by one in a stack, while you read the web page, and then pop them one by one and follow the link, then you have a clean and extendable solution to the problem. We will examine part of this task in the next exercise. </p>
			<h3 id="_idParaDest-55">E<a id="_idTextAnchor067"/>xercise 17: Implementing a Stack Using User-Defined Methods</h3>
			<p>We will continue the topic of the stack from the last exercise. But this time, we will implement the <strong class="inline">append</strong> and <strong class="inline">pop</strong> functions by ourselves. The aim of this exercise is twofold. On one hand, we will implement the stack, and this time with a real-life example, which also involves knowledge of string methods and thus serves as a reminder of the last chapter and activity. On the other hand, it will show us a subtle feature of Python and how it handles passing list variables to functions, and will bring us to the next exercise, functional programming:</p>
			<ol>
				<li value="1">First, we will define two functions, <strong class="inline">stack_push</strong> and <strong class="inline">stack_pop</strong>. We renamed them so that we do not have a namespace conflict. Also, create a stack called <strong class="inline">url_stack</strong> for later use:<p class="snippet">def stack_push(s, value):</p><p class="snippet">    return s + [value]</p><p class="snippet">def stack_pop(s):</p><p class="snippet">    tos = s[-1]</p><p class="snippet">    del s[-1]</p><p class="snippet">    return tos</p><p class="snippet">url_stack = []</p></li>
				<li>The first function takes the already existing stack and adds the value at the end of it. <h4>Note</h4><p class="callout">Notice the square brackets around the value to convert it in to a one-element list for the sake of the + operation. </p></li>
				<li>The second one reads the value that's currently at the <strong class="inline">-1</strong> index of the stack and then uses the <strong class="inline">del</strong> operator to delete that index, and finally returns the value it read earlier. </li>
				<li>Now, we are going to have a string with a few URLs in it. Our job is to analyze the string so that we push the URLs in the stack one by one as we encounter them, and then finally use a for loop to pop them one by one. Let's take the first line from the Wikipedia article about data science:<p class="snippet">wikipedia_datascience = "Data science is an interdisciplinary field that uses scientific methods, processes, algorithms and systems to extract knowledge [https://en.wikipedia.org/wiki/Knowledge] and insights from data [https://en.wikipedia.org/wiki/Data] in various forms, both structured and unstructured,similar to data mining [https://en.wikipedia.org/wiki/Data_mining]"</p></li>
				<li>For the sake of the simplicity of this exercise, we have kept the links in square brackets beside the target words.</li>
				<li>Find the length of the string:<p class="snippet">len(wikipedia_datascience)</p><p>The output is as follows:</p><p class="snippet">347</p></li>
				<li>Convert this string into a list by using the <strong class="inline">split</strong> method from the string and then calculate its length:<p class="snippet">wd_list = wikipedia_datascience.split()</p><p class="snippet">len(wd_list)</p><p>The output is as follows:</p><p class="snippet">34</p></li>
				<li>Use a for loop to go over each word and check whether it is a URL. To do that, we will use the <strong class="inline">startswith</strong> method from the string, and if it is a URL, then we push it into the stack:<p class="snippet">for word in wd_list:</p><p class="snippet">    if word.startswith("[https://"):</p><p class="snippet">        url_stack = stack_push(url_stack, word[1:-1])  </p><p class="snippet"># Notice the clever use of string slicing</p></li>
				<li>Print the value in <strong class="inline">url_stack</strong>:<p class="snippet">url_stack</p><p>The output is as follows:</p><p class="snippet">['https://en.wikipedia.org/wiki/Knowledge',</p><p class="snippet"> 'https://en.wikipedia.org/wiki/Data',</p><p class="snippet"> 'https://en.wikipedia.org/wiki/Data_mining']</p></li>
				<li>Iterate over the list and print the URLs one by one by using the <strong class="inline">stack_pop</strong> function:<p class="snippet">for i in range(0, len(url_stack)):</p><p class="snippet">    print(stack_pop(url_stack))</p><p>The output is as follows:</p><div id="_idContainer047" class="IMG---Figure"><img src="Images/Figure_2.2.jpg" alt="Figure 2.2:  Output of the URLs printed using a stack" width="643" height="63"/></div><h6>Figure 2.2:  Output of the URLs that are printed using a stack</h6></li>
				<li>Print it again to make sure that the stack is empty after the final for loop:<p class="snippet">print(url_stack)</p><p>The output is as follows:</p><p class="snippet">[]</p></li>
			</ol>
			<p>We have noticed a strange phenomenon in the <strong class="inline">stack_pop</strong> method. We passed the list variable there, and we used the <strong class="inline">del</strong> operator inside the function, but it changed the original variable by deleting the last index each time we call the function. If you are coming from a language like C, C++, and Java, then this is a completely unexpected behavior, as in those languages this can only happen if we pass the variable by reference and it can lead to subtle bugs in Python code. So be careful. In general, it is not a good idea to change a variable's value in place, meaning inside a function. Any variable that's passed to the function should be considered and treated as immutable. This is close to the principles of functional programming. A lambda expression in Python is a way to construct one-line, nameless functions that are, by convention, side effect-free.</p>
			<h3 id="_idParaDest-56">Ex<a id="_idTextAnchor068"/>ercise 18: Lambda Expression </h3>
			<p>In this exercise, we will use a lambda expression to prove the famous trigonometric identity:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="Images/Figure_2.3.jpg" alt="" width="953" height="58"/>
				</div>
			</div>
			<h6>Figure 2.3 Trigonometric identity</h6>
			<ol>
				<li value="1">Import the <strong class="inline">math</strong> package:<p class="snippet">import math</p></li>
				<li>Define two functions, <strong class="inline">my_sine</strong> and <strong class="inline">my_cosine</strong>. The reason we are declaring these functions is because the original <strong class="inline">sin</strong> and <strong class="inline">cos</strong> functions from the math package take radians as input, but we are more familiar with degrees. So, we will use a lambda expression to define a nameless one-line function and use it. This lambda function will automatically convert our degree input to radians and then apply <strong class="inline">sin</strong> or <strong class="inline">cos</strong> on it and return the value: <p class="snippet">def my_sine():</p><p class="snippet">    return lambda x: math.sin(math.radians(x))</p><p class="snippet">def my_cosine():</p><p class="snippet">    return lambda x: math.cos(math.radians(x))</p></li>
				<li>Define <strong class="inline">sine</strong> and <strong class="inline">cosine</strong> for our purpose: <p class="snippet">sine = my_sine()</p><p class="snippet">cosine = my_cosine()</p><p class="snippet">math.pow(sine(30), 2) + math.pow(cosine(30), 2)</p><p>The output is as follows:</p><p class="snippet">1.0</p><p>Notice that we have assigned the return value from both <strong class="inline">my_sine</strong> and <strong class="inline">my_cosine</strong> to two variables, and then used them directly as the functions. It is a much cleaner approach than using them explicitly. Notice that we did not explicitly write a <strong class="inline">return</strong> statement inside the lambda function. It is assumed.</p></li>
			</ol>
			<h3 id="_idParaDest-57"><a id="_idTextAnchor069"/>Exercise 19: Lambda Expression for Sorting</h3>
			<p class="Basic-Paragraph">The lambda expression will take an input and sort it according to the values in tuples. A lambda can take one or more inputs. A lambda expression can also be used to reverse sort by using the parameter of <strong class="inline">reverse</strong> as <strong class="inline">True</strong>:</p>
			<ol>
				<li value="1">Imagine you're in a data wrangling job where you are confronted with the following list of tuples:<p class="snippet">capitals = [("USA", "Washington"), ("India", "Delhi"), ("France", "Paris"), ("UK", "London")]</p><p class="snippet">capitals</p><p>The output will be as follows:</p><p class="snippet">[('USA', 'Washington'),</p><p class="snippet"> ('India', 'Delhi'),</p><p class="snippet"> ('France', 'Paris'),</p><p class="snippet"> ('UK', 'London')]</p></li>
				<li>Sort this list by the name of the capitals of each country, using a simple lambda expression. Use the following code:<p class="snippet">capitals.sort(key=lambda item: item[1])</p><p class="snippet">capitals</p><p>The output will be as follows:</p><p class="snippet">[('India', 'Delhi'),</p><p class="snippet"> ('UK', 'London'),</p><p class="snippet"> ('France', 'Paris'),</p><p class="snippet"> ('USA', 'Washington')]</p></li>
			</ol>
			<p>As we can see, lambda expressions are powerful if we master them and use them in our data wrangling jobs. They are also side effect-free, meaning that they do not change the values of the variables that are passed to them in place. </p>
			<h3 id="_idParaDest-58">Exe<a id="_idTextAnchor070"/>rcise 20: Multi-Element Membership Checking</h3>
			<p>Here is an interesting problem. Let's imagine a list of a few words scraped from a text corpus you are working with:</p>
			<ol>
				<li value="1">Create a <strong class="inline">list_of_words</strong> list with words scraped from a text corpus:<p class="snippet">list_of_words = ["Hello", "there.", "How", "are", "you", "doing?"]</p></li>
				<li>Find out whether this list contains all the elements from another list:<p class="snippet">check_for = ["How", "are"]</p><p>There exists an elaborate solution, which involves a <strong class="inline">for loop</strong> and few if-else conditions (and you should try to write it!), but there also exists an elegant Pythonic solution to this problem, which takes one line and uses the <strong class="inline">all</strong> function. The <strong class="inline">all</strong> function returns <strong class="inline">True</strong> if all elements of the iterable are true.</p></li>
				<li>Using the <strong class="inline">in</strong> keyword to check membership in the list <strong class="inline">list_of_words</strong>:<p class="snippet">all(w in list_of_words for w in check_for)</p><p>The output is as follows:</p><p class="snippet">True</p><p>It is indeed elegant and simple to reason about, and this neat trick is very important when dealing with lists. </p></li>
			</ol>
			<h3 id="_idParaDest-59">Que<a id="_idTextAnchor071"/>ue</h3>
			<p>Apart from stacks, another high-level data structure that we are interested in is queue. A queue is like a stack, meaning that you continue adding elements one by one. With a queue, the reading of elements obeys a FIFO (First In First Out) strategy. Check out the following diagram to understand this better:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="Images/Figure_2.4.jpg" alt="Figure 2.4: Pictorial representation of a queue" width="499" height="219"/>
				</div>
			</div>
			<h6>Figure 2.4: Pictorial representation of a queue</h6>
			<p>We will accomplish this first using list methods and we will show you that for this purpose, it is inefficient. Then, we will learn about the <strong class="inline">dequeue</strong> data structure from the collection module of Python.</p>
			<h3 id="_idParaDest-60"><a id="_idTextAnchor072"/>Exercise 21: Implementing a Queue in Python</h3>
			<ol>
				<li value="1">Create a Python queue with the plain list methods:<p class="snippet">%%time</p><p class="snippet">queue = []</p><p class="snippet">for i in range(0, 100000):</p><p class="snippet">    queue.append(i)</p><p class="snippet">print("Queue created")</p><p>The output is as follows:</p><p class="snippet">Queue created</p><p class="snippet">Wall time: 11 ms</p></li>
				<li>Use the <strong class="inline">pop</strong> function to empty the queue and check items in it:<p class="snippet">for i in range(0, 100000):</p><p class="snippet">    queue.pop(0)</p><p class="snippet">print("Queue emptied")</p><p>The output is as follows:</p><p class="snippet">Queue emptied</p><p>If we use the <strong class="inline">%%time</strong> magic command while executing the preceding code, we will see that it takes a while to finish. In a modern MacBook, with a quad-core processor and 8 GB RAM, it took around 1.20 seconds to finish. This time is taken because of the <strong class="inline">pop(0)</strong> operation, which means every time we pop a value from the left of the list (which is the current 0 index), Python has to rearrange all the other elements of the list by shifting them one space left. Indeed, it is not a very optimized implementation. </p></li>
				<li>Implement the same queue using the <strong class="inline">deque</strong> data structure from Python's collection package:<p class="snippet">%%time</p><p class="snippet">from collections import deque</p><p class="snippet">queue2 = deque()</p><p class="snippet">for i in range(0, 100000):</p><p class="snippet">    queue2.append(i)</p><p class="snippet">print("Queue created")</p><p class="snippet">for i in range(0, 100000):</p><p class="snippet">    queue2.popleft()</p><p class="snippet">print("Queue emptied")</p><p>The output is as follows:</p><p class="snippet">Queue created</p><p class="snippet">Queue emptied</p><p class="snippet">Wall time: 23 ms</p></li>
				<li>With the specialized and optimized queue implementation from Python's standard library, the time that's taken for this operation is only in the range of 28 milliseconds! This is a huge improvement on the previous one. </li>
			</ol>
			<p>A queue is a very important data structure. To give one example from real life, we can think about a producer-consumer system design. While doing data wrangling, you will often come across a problem where you must process very big files. One of the ways to deal with this problem is to chunk the contents of the file in to smaller parts and then push them in to a queue while creating small, dedicated worker processes, which reads off the queue and processes one small chunk at a time. This is a very powerful design, and you can even use it efficiently to design huge multi-node data wrangling pipelines. </p>
			<p>We will end the discussion on data structures here. What we discussed here is just the tip of the iceberg. Data structures are a fascinating subject. There are many other data structures that we did not touch and which, when used efficiently, can offer enormous added value. We strongly encourage you to explore data structures more. Try to learn about linked lists, tree, graph, trie, and all the different variations of them as much as you can. Not only do they offer the joy of learning, but they are also the secret mega weapons in the arsenal of a data practitioner that you can bring out every time you are challenged with a difficult data wrangling job.</p>
			<h3 id="_idParaDest-61">Acti<a id="_idTextAnchor073"/>vity 3: Permutation, Iterator, Lambda, List</h3>
			<p>In this activity, we will be using <strong class="inline">permutations</strong> to generate all possible three-digit numbers that can be generated using 0, 1, and 2. Then, loop over this iterator, and also use <strong class="inline">isinstance</strong> and <strong class="inline">assert</strong> to make sure that the return types are tuples. Also, use a single line of code involving <strong class="inline">dropwhile</strong> and <strong class="inline">lambda</strong> expressions to convert all the tuples to lists while dropping any leading zeros (for example, (0, 1, 2) becomes [1, 2]). Finally, write a function that takes a list like before and returns the actual number contained in it. </p>
			<p>These steps will guide you to solve this activity:</p>
			<ol>
				<li value="1">Look up the definition of <strong class="inline">permutations</strong> and <strong class="inline">dropwhile</strong> from <strong class="inline">itertools</strong>.</li>
				<li>Write an expression to generate all the possible three-digit numbers using <strong class="inline">0</strong>, <strong class="inline">1</strong>, and <strong class="inline">2</strong>.</li>
				<li>Loop over the iterator expression you generated before. Print each element that's returned by the iterator. Use <strong class="inline">assert</strong> and <strong class="inline">isinstance</strong> to make sure that the elements are of the tuple type.</li>
				<li>Write the loop again using <strong class="inline">dropwhile</strong> with a lambda expression to drop any leading zeros from the tuples. As an example, <strong class="inline">(0, 1, 2)</strong> will become <strong class="inline">[0, 2]</strong>. Also, cast the output of <strong class="inline">dropwhile</strong> to a list.</li>
				<li>Check the actual type that <strong class="inline">dropwhile</strong><span class="Emphasis"> </span>returns.</li>
				<li>Combine the preceding code into one block, and this time write a separate function where you will pass the list generated from<span class="Emphasis"> </span><strong class="inline">dropwhile</strong>, and the function will return the whole number contained in the list. As an example, if you pass <strong class="inline">[1, 2]</strong> to the function, it will return <strong class="inline">12</strong>. Make sure that the return type is indeed a number and not a string. Although this task can be achieved using other tricks, we require that you treat the incoming list as a stack in the function and generate the number by reading the individual digits from the stack.</li>
			</ol>
			<p>With this activity, we have finished this topic and we will head over to the next topic, which involves basic file-level operations. But before we leave this topic, we encourage you to think about a solution to the preceding problem without using all the advanced operations and data structures we have used here. You will soon realize how complex the naive solution is, and how much value these data structures and operations bring.</p>
			<h4>Note</h4>
			<p class="callout">The solution for this activity can be found on page 289.</p>
			<h2 id="_idParaDest-62">Basi<a id="_idTextAnchor074"/>c File Operations in Python</h2>
			<p>In the previous topic, we investigated a few advanced data structures and also learned neat and useful functional programming methods to manipulate them without side effects. In this topic, we will learn about a few operating system (OS)-level functions in Python. We will concentrate mainly on file-related functions and learn how to open a file, read the data line by line or all at once, and finally how to cleanly close the file we opened. We will apply a few of the techniques we have learned about on a file that we will read to practice our data wrangling skills further. </p>
			<h3 id="_idParaDest-63">Exer<a id="_idTextAnchor075"/>cise 22: File Operations</h3>
			<p>In this exercise, we will learn about the OS module of Python, and we will also see two very useful ways to write and read environment variables. The power of writing and reading environment variables is often very important while designing and developing data wrangling pipelines. </p>
			<h4>Note</h4>
			<p class="callout">In fact, one of the factors of the famous 12-factor app design is the very idea of storing configuration in the environment. You can check it out at this URL:  https://12factor.net/config.</p>
			<p>The purpose of the OS module is to give you ways to interact with operating system-dependent functionalities. In general, it is pretty low-level and most of the functions from there are not useful on a day-to-day basis, however, some are worth learning. <strong class="inline">os.environ</strong> is the collection Python maintains with all the present environment variables in your OS. It gives you the power to create new ones. The <strong class="inline">os.getenv</strong> function gives you the ability to read an environment variable:</p>
			<ol>
				<li value="1">Import the <strong class="inline">os</strong> module.<p class="snippet">import os</p></li>
				<li>Set few environment variables:<p class="snippet">os.environ['MY_KEY'] = "MY_VAL"</p><p class="snippet">os.getenv('MY_KEY')</p><p>The output is as follows:</p><p class="snippet">'MY_VAL'</p><p>Print the environment variable when it is not set:</p><p class="snippet">print(os.getenv('MY_KEY_NOT_SET'))</p><p>The output is as follows:</p><p class="snippet">None</p></li>
				<li>Print the <strong class="inline">os</strong> environment:<p class="snippet">print(os.environ)</p><h4>Note</h4><p class="callout">The output has not been added for security reasons.</p><p>After executing the preceding code, you will be able to see that you have successfully printed the value of <strong class="inline">MY_KEY</strong>, and when you tried to print <strong class="inline">MY_KEY_NOT_SET</strong>, it printed None.</p></li>
			</ol>
			<h3 id="_idParaDest-64">File<a id="_idTextAnchor076"/> Handling</h3>
			<p>In this exercise, we will learn about how to open a file in Python. We will learn about the different modes that we can use and what they stand for. Python has a built-in <strong class="inline">open</strong> function that we will use to open a file. The <strong class="inline">open</strong> function takes few arguments as input. Among them, the first one, which stands for the name of the file you want to open, is the only one that's mandatory. Everything else has a default value. When you call <strong class="inline">open</strong>, Python uses underlying system-level calls to open a file handler and will return it to the caller. </p>
			<p>Usually, a file can be opened either for reading or for writing. If we open a file in one mode, the other operation is not supported. Whereas reading usually means we start to read from the beginning of an existing file, writing can mean either starting a new file and writing from the beginning or opening an existing file and appending to it. Here is a table showing you all the different modes Python supports for opening a file:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="Images/Figure_2.5.jpg" alt="Figure 2.5 Modes to read a file" width="1547" height="526"/>
				</div>
			</div>
			<h6>Figure 2.5 Modes to read a file</h6>
			<p>There also exists a deprecated mode, <strong class="inline">U</strong>, which in a Python3 environment does nothing. One thing we must remember here is that Python will always differentiate between <strong class="inline">t</strong> and <strong class="inline">b</strong> modes, even if the underlying OS doesn't. This is because in <strong class="inline">b</strong> mode, Python does not try to decode what it is reading and gives us back the bytes object instead, whereas in <strong class="inline">t</strong> mode, it does try to decode the stream and gives us back the string representation. </p>
			<p>You can open a file for reading like so:</p>
			<p class="snippet">fd = open("Alice’s Adventures in Wonderland, by Lewis Carroll")</p>
			<p>This is opened in <strong class="inline">rt</strong> mode. You can open the same file in binary mode if you want. To open the file in binary mode, use the <strong class="inline">rb</strong> mode:</p>
			<p class="snippet">fd = open("Alice’s Adventures in Wonderland, by Lewis Carroll",</p>
			<p class="snippet">          "rb")</p>
			<p class="snippet">fd</p>
			<p>The output is as follows:</p>
			<p class="snippet">&lt;_io.BufferedReader name='Alice's Adventures in Wonderland, by Lewis Carroll'&gt;</p>
			<p>This is how we open a file for writing:</p>
			<p class="snippet">fd = open("interesting_data.txt", "w")</p>
			<p class="snippet">fd</p>
			<p>The output is as follows:</p>
			<p class="snippet">&lt;_io.TextIOWrapper name='interesting_data.txt' mode='w' encoding='cp1252'&gt;</p>
			<h3 id="_idParaDest-65"><a id="_idTextAnchor077"/>Exercise 23: Opening and Closing a File</h3>
			<p>In this exercise, we will learn how to close an open file. It is very important that we close a file once we open it. A lot of system-level bugs can occur due to a dangling file handler. Once we close a file, no further operations can be performed on that file using that specific file handler:</p>
			<ol>
				<li value="1">Open a file in binary mode: <p class="snippet">fd = open("Alice's Adventures in Wonderland, by Lewis Carroll",</p><p class="snippet">          "rb")</p></li>
				<li>Close a file using <strong class="inline">close()</strong>: <p class="snippet">fd.close()</p></li>
				<li>Python also gives us a <strong class="inline">closed</strong> flag with the file handler. If we print it before closing, then we will see <strong class="inline">False</strong>, whereas if we print it after closing, then we will see <strong class="inline">True</strong>. If our logic checks whether a file is properly closed or not, then this is the flag we want to use.</li>
			</ol>
			<h3 id="_idParaDest-66">The <strong class="inline">w<a id="_idTextAnchor078"/>ith</strong> Statement</h3>
			<p>In this exercise, we will learn about the <strong class="inline">with</strong> statement in Python and how we can effectively use it in the context of opening and closing files. </p>
			<p>The <strong class="inline">with</strong> command is a compound statement in Python. Like any compound statement, <strong class="inline">with</strong> also affects the execution of the code enclosed by it. In the case of <strong class="inline">with</strong>, it is used to wrap a block of code in the scope of what we call a <strong class="inline">Context Manager</strong> in Python. A detailed discussion of the context manager is out of the scope of this exercise and this topic in general, but it is sufficient to say that thanks to a context manager implemented inside the <strong class="inline">open</strong> call for opening a file in Python, it is guaranteed that a close call will automatically happen if we wrap it inside a <strong class="inline">with</strong> statement. </p>
			<h4>Note</h4>
			<p class="callout">There is an entire PEP for with at <a href="https://www.python.org/dev/peps/pep-0343/">https://www.python.org/dev/peps/pep-0343/</a>. We encourage you to look into it.</p>
			<h3 id="_idParaDest-67"><a id="_idTextAnchor079"/>Opening a File Using the <strong class="inline">with</strong> Statement</h3>
			<p>Open a file using the with statement:</p>
			<p class="snippet">with open("Alice’s Adventures in Wonderland, by Lewis Carroll")as fd:</p>
			<p class="snippet">    print(fd.closed)</p>
			<p class="snippet">print(fd.closed)</p>
			<p>The output is as follows:</p>
			<p class="snippet">False</p>
			<p class="snippet">True</p>
			<p>If we execute the preceding code, we will see that the first print will end up printing <strong class="inline">False</strong>, whereas the second one will print <strong class="inline">True</strong>. This means that as soon as the control goes out of the <strong class="inline">with</strong> block, the file descriptor is automatically closed.</p>
			<h4>Note</h4>
			<p class="callout">This is by far the cleanest and most Pythonic way to open a file and obtain a file descriptor for it. We encourage you to use this pattern whenever you need to open a file by yourself. </p>
			<h3 id="_idParaDest-68">Exerc<a id="_idTextAnchor080"/><a id="_idTextAnchor081"/>ise 24: Reading a File Line by Line</h3>
			<ol>
				<li value="1">Open a file and then read the file line by line and print it as we read it:<p class="snippet">with open("Alice’s Adventures in Wonderland, by Lewis Carroll",</p><p class="snippet">          encoding="utf8") as fd:</p><p class="snippet">    for line in fd:</p><p class="snippet">            print(line)</p><p>The output is as follows:</p><div id="_idContainer051" class="IMG---Figure"><img src="Images/Figure_2.6.jpg" alt="Fig 2.6: Screenshot from the Jupyter notebook" width="1187" height="359"/></div><h6>Figure 2.6: Screenshot from the Jupyter notebook</h6></li>
				<li>Looking at the preceding code, we can really see why it is important. With this small snippet of code, you can even open and read files that are many GBs in size, line by line, and without flooding or overrunning the system memory!<p>There is another explicit method in the file descriptor object called <strong class="inline">readline</strong>, which reads one line at a time from a file.</p></li>
				<li>Duplicate the same for loop, just after the first one: <p class="snippet">with open("Alice’s Adventures in Wonderland, by Lewis Carroll",</p><p class="snippet">          encoding="utf8") as fd:</p><p class="snippet">    for line in fd:</p><p class="snippet">        print(line)</p><p class="snippet">    print("Ended first loop")</p><p class="snippet">    for line in fd:</p><p class="snippet">        print(line)</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="Images/Figure_2.6.jpg" alt="Figure 2.7: Section of file opened" width="1187" height="359"/>
				</div>
			</div>
			<h6>Figure 2.7: Section of the open file</h6>
			<h3 id="_idParaDest-69">Exercis<a id="_idTextAnchor082"/><a id="_idTextAnchor083"/>e 25: Write to a File</h3>
			<p>We will end this topic on file operations by showing you how to write to a file. We will write a few lines to a file and read the file:</p>
			<ol>
				<li value="1">Use the <strong class="inline">write</strong> function from the file descriptor object:<p class="snippet">data_dict = {"India": "Delhi", "France": "Paris", "UK": "London",</p><p class="snippet">             "USA": "Washington"}</p><p class="snippet">with open("data_temporary_files.txt", "w") as fd:</p><p class="snippet">    for country, capital in data_dict.items():</p><p class="snippet">        fd.write("The capital of {} is {}\n".format(</p><p class="snippet">            country, capital))</p></li>
				<li>Read the file using the following command:<p class="snippet">with open("data_temporary_files.txt", "r") as fd:</p><p class="snippet">    for line in fd:</p><p class="snippet">        print(line)</p><p>The output is as follows:</p><p class="snippet">The capital of India is Delhi</p><p class="snippet">The capital of France is Paris</p><p class="snippet">The capital of UK is London</p><p class="snippet">The capital of USA is Washington</p></li>
				<li>Use the print function to write to a file using the following command:<p class="snippet">data_dict_2 = {"China": "Beijing", "Japan": "Tokyo"}</p><p class="snippet">with open("data_temporary_files.txt", "a") as fd:</p><p class="snippet">    for country, capital in data_dict_2.items():</p><p class="snippet">        print("The capital of {} is {}".format(</p><p class="snippet">            country, capital), file=fd)</p></li>
				<li>Read the file using the following command:<p class="snippet">with open("data_temporary_files.txt", "r") as fd:</p><p class="snippet">    for line in fd:</p><p class="snippet">        print(line)</p><p>The output is as follows:</p><p class="snippet">The capital of India is Delhi</p><p class="snippet">The capital of France is Paris</p><p class="snippet">The capital of UK is London</p><p class="snippet">The capital of USA is Washington</p><p class="snippet">The capital of China is Beijing</p><p class="snippet">The capital of Japan is Tokyo</p><h4>Note:</h4><p class="callout">In the second case, we did not add an extra newline character, \n, at the end of the string to be written. The print function does that automatically for us.</p></li>
			</ol>
			<p>With this, we will end this topic. Just like the previous topics, we have designed an activity for you to practice your newly acquired skills.</p>
			<h3 id="_idParaDest-70">Activit<a id="_idTextAnchor084"/><a id="_idTextAnchor085"/>y 4: Design Your Own CSV Parser</h3>
			<p>A CSV file is something you will encounter a lot in your life as a data practitioner. A CSV is a comma-separated file where data from a tabular format is generally stored and separated using commas, although other characters can also be used. </p>
			<p>In this activity, we will be tasked with building our own CSV reader and parser. Although it is a big task if we try to cover all use cases and edge cases, along with escape characters and all, for the sake of this small activity, we will keep our requirements small. We will assume that there is no escape character, meaning that if you use a comma at any place in your row, it means you are starting a new column. We will also assume that the only function we are interested in is to be able to read a CSV file line by line where each read will generate a new dict with the column names as keys and row names as values.</p>
			<p>Here is an example:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="Images/Figure_2.8.jpg" alt="Figure 2.8 Table with sample data" width="1506" height="274"/>
				</div>
			</div>
			<h6>Figure 2.8 Table with sample data</h6>
			<p>We can convert the data in the preceding table into a Python dictionary, which would look as follows: <strong class="inline">{"Name": "Bob", "Age": "24", "Location": "California"}</strong>:</p>
			<ol>
				<li value="1">Import <strong class="inline">zip_longest</strong> from <strong class="inline">itertools</strong>. Create a function to zip <strong class="inline">header</strong>, <strong class="inline">line</strong> and <strong class="inline">fillvalue=None</strong>.</li>
				<li>Open the accompanying <strong class="inline">sales_record.csv</strong> file from the GitHub link by using <strong class="inline">r</strong> mode inside a with block and first check that it is opened.</li>
				<li>Read the first line and use string methods to generate a list of all the column names.</li>
				<li>Start reading the file. Read it line by line.</li>
				<li>Read each line and pass that line to a function, along with the list of the headers. The work of the function is to construct a dict out of these two and fill up the <strong class="inline">key:values</strong>. Keep in mind that a missing value should result in <strong class="inline">None</strong>.<h4>Note</h4><p class="callout">The<a id="_idTextAnchor086"/> solution for this activity can be found on page 291.</p></li>
			</ol>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor087"/>Summary</h2>
			<p>In this chapter, we learned about the workings of advanced data structures such as stacks and queues. We implemented and manipulated both stacks and queues. We then focused on different methods of functional programming, including iterators, and combined lists and functions together. After this, we looked at the <strong class="inline">OS</strong>-level functions and the management of environment variables and files. We also examined a clean way to deal with files, and we created our own CSV parser in the last activity.</p>
			<p>In the next chapter, we will be dealing with the three most important libraries, namely NumPy, pandas, and matplotlib.</p>
		</div>
		<div>
			<div id="_idContainer055" class="Content">
			</div>
		</div>
	</div>



  </body></html>