- en: Introduction to Location Privacy Protection Mechanisms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding noise to protect location data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating redundancy in geographical query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter includes a set of references to documents (news, laws, academic
    work, and so on) that will be cited along the text, using a *[#]* format.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to an emerging issue in the design and implementation
    of location-based information systems: LBISs. The increasing use of smartphones
    in all kinds of applications, and their ability to acquire and report users''
    locations, has been adopted as a core functionality of many service providers.
    Enabling access to users'' accurate locations throughout the day, which gives
    context to their requests and allows companies to better know their client and
    provide any relevant personalized services; however, this information can contain
    much more about the user than just the context of the service they want to access,
    such as their weekly routine, frequently visited places, groups of people gathered,
    and so on. These patterns can be obtained from the phone, and then analyzed and
    used to categorize or profile customers; this information in the wrong hands,
    however, could be used against individuals.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though there is very little *[1]* to no regulation on how to handle location
    information in a way that guarantees privacy for users, it is very important that
    the proper policies and implementation are included at the design stage.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, among geoprivacy researchers, there exists a wide variety of mechanisms
    that can be used to help mitigate the issue of privacy in LBISs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is somewhat different from the others because, in order to understand
    the background of each location privacy technique, we considered important to
    include the theoretical bases that support these recipes that to the best of our
    knowledge are only available through academic publications and not yet presented
    as a hands-on experience.
  prefs: []
  type: TYPE_NORMAL
- en: Definition of Location Privacy Protection Mechanisms – LPPMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Location privacy can be defined by *Duckham* and *Kulik* in *[2]* as follows:
    *A special type of information privacy which concerns the claim of individuals
    to determine for themselves when, how, and to what extent location information
    about them is communicated to others*. Based on this definition, users should
    have power over their location information; however, it is well known that this
    is not the reality in many cases. Often, a service provider requires full access
    to a user''s location in order for the service to become available.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, because there is no restriction on the quality of location information
    that service providers can record, it's common for the exact GPS coordinates to
    be acquired, even when it is not relevant to the service itself.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of LPPMs should be to allow users to hide or reduce the quality
    of this location information in such a way that users will still have an adequate
    service functionalities, and that the service provider can still benefit from
    insights product of spatial analysis .
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide geoprivacy, it is important to understand the components
    location information, these are: identity, location, and time. If an adversary
    is able to link those three aspects, location privacy is compromised. These components
    form an instance of location information; a sequence of such instances that gives
    historical location information, allowing others to establish behavior patterns
    and then making it possible for them to identify the user's home, work, and routine.
    Most LPPMs attack at least one of these components in order to protect privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose an attacker gains access to a user's identity and the time, but has
    no clear knowledge of what places the user has visited. As the location component
    has been obfuscated, the attacker would be able to infer very little, as the context
    is highly-altered and the data has lost its potential usability. (This specific
    scenario corresponds to location privacy.)
  prefs: []
  type: TYPE_NORMAL
- en: Another popular solution has been the implementation of identity privacy or
    anonymity, where users' traveled pathways can be accessed, but they provide no
    information on the identity of the subjects, or even if they are different users;
    however, this information alone could be enough to infer the identity of a person
    by matching records on a phonebook, as in the experiments conducted by *[3]*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when a user's location and identity are specified, but the time component
    is missing, the resulting information lacks context, and so pathways may not be
    reconstructed accurately; however, implementing a model in which this occurs is
    unlikely, as requests and LBS responses happen at a specific time and delaying
    queries can cause them to lose their relevance.
  prefs: []
  type: TYPE_NORMAL
- en: Classifying LPPMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Privacy in location-based services is often viewed as reaching a desirable trade-off
    between performance and a user's privacy; the more privacy provided, the less
    likely it is that the service can function as it would under a no-privacy scheme,
    or without suffering alterations in their architecture or application layer. As
    LBS offers a great variety of ever-changing features that keep up with users'
    needs while making use of the latest available technologies and adjusting to social
    behavior, they provide a similar scenario to LPPMs that aims to cover these services.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of **proactive location-based services** (**PLBS**), where users
    are constantly reporting their location *[4]*, the purpose of LPPMs is to alter
    the route as much as possible, while still providing a minimum level of accuracy
    that will allow the LBS to provide relevant information. This can be challenging
    because many PLBS, like traffic guidance apps, require the exact location of the
    user. So, unless the original data can be recovered or used in the altered format,
    it would be very complicated for these applications to implement an LPPM. Other
    services, like geomarketing or FriendFinder, may tolerate a larger alteration
    of the data, even if the change cannot be undone.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, mechanisms intended for **reactive location-based services**
    (**RLBS**) often do not require critical accuracy, and therefore it is tolerable
    to alter the subject's position in order to provide location privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Some LPPMs require special features alongside the usual client-server architecture,
    such as special database structures, extra data processing layers, third-party
    services, proxies, special electronics, a peer-to-peer approach between the LBS
    users' community, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, a proposed way to classify LPPMs is based on the application
    to PLBS and RLBS. Some of the techniques are general enough that they can be used
    in both worlds, but each has different implications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24c7c337-24c2-4fea-b3c9-ab4be51bfcd1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1\. Taxonomy of LPPMs
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, two examples of LPPM implementations will be shown: noise-based
    location obfuscation, and private-information retrieval. Each of these imply changes
    to the design of the LBIS and the geographical database.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding noise to protect location data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the mechanisms designed for location privacy protection are based on
    location obfuscation, which is explained in *[5]* as *the means of deliberately
    degrading the quality of information about an individual's location in order to
    protect that individual's location privacy*.
  prefs: []
  type: TYPE_NORMAL
- en: This is perhaps the simplest way to implement location privacy protection in
    LBISs because it has barely any impact on the server-side of the application,
    and is usually easy to implement on the client-side. Another way to implement
    it would be on the server-side, running periodically over the new data, or as
    a function applied to every new entry.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of these techniques is to add random noise to the original location
    obtained by the cellphone or any other location-aware device, so as to reduce
    the accuracy of the data. In this case, the user can usually define the maximum
    and/or minimum amount of noise that they want to add. The higher the noise added,
    the lower the quality of the service; so it is very important to reasonably set
    this parameter. For example, if a real-time tracking application receives data
    altered by 1 km, the information provided to the user may not be relevant to the
    real location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each noise-based location obfuscation technique presents a different way to
    generate noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c61c6588-9bd1-4932-826a-71a2c6b79574.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the noise is generated with polar coordinates, it is more uniformly distributed
    over a projection of the circular area because both angle and distance follow
    that distribution. In the case of Cartesian-based noise, points appear to be generated
    uniformly among the area as a whole, resulting in a lower density of points near
    the center. The following figure shows the differences in both circular and rectangular
    projections of 500 random points. In this book, we will work with polar-based
    random generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0849076d-054a-4574-9c6a-9ce37c494a08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following figure illustrates the way the **N-RAND ***[6]*, **θ-RAND ***[7]*,
    and **Pinwheel ***[8]* techniques work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c930fd02-e5c6-403d-ac57-bac0d1d7b360.png)'
  prefs: []
  type: TYPE_IMG
- en: '**N-RAND** generates *N* points in a given area, and selects the point furthest
    away from the center. **Θ-RAND** does the same, but in a specific sector of the
    circular area. There can be more than just one area to select from. Finally, the
    **Pinwheel** mechanism differs from **N-RAND** and **θ-RAND** because it does
    not generate random distances for the points, and instead defines a specific one
    for each angle in the circumference, making the selection of the radius a more
    deterministic process when generating random points. In this case, the only random
    variable in the generation process is the angle *α*. The formula to calculate
    the radius for a given angle, *α*, is presented in **(1)**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fadf42d-3da5-407e-9026-f2fb77a9f503.png)'
  prefs: []
  type: TYPE_IMG
- en: Where *φ* is a preset parameter defined by the user, it determines the amplitude
    of the wings of geometry, which resembles a pinwheel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower the value of *φ*, the more wings the pinwheel will have, but those
    wings will also be thinner; on the other hand, the higher the value, the fewer
    the number of *wider* wings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b84090a8-9263-4ce2-8261-53d2705baa98.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the locations have been altered, it is very unlikely that you will be able
    to recover the original information; however, filtering noise techniques are available
    in the literature that reduce the impact of alterations and allow a better estimation
    of the location data. One of these mechanisms for noise-filtering is based on
    an **exponential moving average** (**EMA**) called Tis-Bad *[9]*.
  prefs: []
  type: TYPE_NORMAL
- en: There is still an open discussion on how much degradation of the location information
    is sufficient to provide location privacy to users, and moreover, if the resulting
    obfuscated information remains useful when accessing a LBS. After all, obtaining
    relevant responses while performing geospatial analysis is one of the main issues
    regarding LBS and the study of geo-referenced data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will create PLPGSQL functions that implement three noise-based
    obfuscation mechanisms: Rand, N-Rand, and Pinwheel. Then we will create a trigger
    function for a table in order to alter all newly inserted points. For this chapter,
    we will reuse the `rk_track_points` dataset used in [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml),
    *Working with Vector Data – The Basics*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the `ST_Project` function to add noise to a single
    point. Then, we will compare the original data with obfuscated data in QGIS. Finally,
    we will show the impact of noise filtering on the obfuscated data.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to extract the `data/chp03/runkeeper-gpx.zip` file to `working/chp12/runkeeper_gpx`.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we will use some of the same steps as in [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml),
    *Working with Vector Data – The Basics*, but for a new schema.
  prefs: []
  type: TYPE_NORMAL
- en: First, be sure of the format of the `.gpx` files that you need to import to
    PostGIS. Open one of them and check the file structure—each file must be in the
    XML format, composed of one `<trk>` element, which contains just one `<trkseg>`
    element, which contains multiple `<trkpt>` elements (the points stored from the
    runner's GPS device).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new schema named `chp12` to store the data for all the recipes in
    this chapter using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `Rand` requires the creation of a PLPGSQL function that
    receives the `radius` parameter, which defines the maximum distance, and the geometry
    `the_geom` to be altered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `ST_Project` function will move the point to a given distance and angle
    from its original location. In order to simplify the expression, we will use polar
    noise generation. Execute the following SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of N-Rand requires the `n` parameter, the number of trials
    to look for the longest distance from the original point, and the `radius` parameter,
    which defines the maximum distance, and the geometry `the_geom` to be altered.
    Execute the following SQL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of Pinwheel requires the `n` parameter, the number of trials
    to look for the longest distance from the original point, and the `radius` parameter,
    which defines the maximum distance, and the geometry `the_geom` to be altered.
    Execute the following SQL command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will replicate part of the steps in [Chapter 3](68d3e400-24be-4757-ab79-5b395dd79f3c.xhtml), *Working
    with Vector Data – The Basics*, but for the schema `chp12`. Create the `chp12.rk_track_points`
    table in PostgreSQL by executing the following command lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As an example, let's use the `nrand` function to create a trigger for all the
    new points inserted in the `rk_track_points` table. In order to simulate this,
    we will create a new table that we will use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function will return a new geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create the following script to import all of the `.gpx` files in the `chp12.rk_track_points`
    table using the GDAL `ogr2ogr` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the Linux version (name it `working/chp03/import_gpx.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Windows version (name it `working/chp03/import_gpx.bat`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, don''t forget to assign an execution permission to it before running.
    Run the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, double-click on the `.bat` file, or run it from the command prompt
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the insertion command is invoked, the trigger call the `nrand` function,
    alter the incoming geometry in the row and store the new version of the data.
    If we compare the first 10 values of the original table `chp03.rk_track_points`
    with the `chp12.rk_track_points`, it can be seen that they are slightly different,
    due to the added noise. Execute the following query in order to see the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of the query are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82bb510f-fa36-4128-b867-2105e7206f39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to evaluate the impact of the noise in the data, we will create two
    tables to store the obfuscated data with different noise levels: 500 m and 1 km.
    We will use the previously defined function `rand`. Execute the following SQL
    commands to create the tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the tables in QGIS or your favorite Desktop GIS. The following figure
    shows the comparison of the original data and the obfuscated points by 500 m and
    1 km:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a771f031-cd82-444f-9dbe-da916fbc2118.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we applied three different mechanisms for noise-based location
    obfuscation: Rand, N-Rand, and Pinwheel, defining PostgreSQL functions in PLPGSQL
    for each method. We used one of the functions in a trigger in order to automatically
    alter the incoming data, so that no changes would need to be made on the application
    on the user''s side. In addition, we showed the impact of noise comparing two
    versions of the altered data, so we can better appreciate the impact of the configuration
    noise settings'
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipes, we will look at an implementation of a private information
    retrieval-based LPPM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating redundancy in geographical query results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Private information retrieval** (**PIR**) LPPMs provide location privacy
    by mapping the spatial context to provide a private way to query a service without
    releasing any location information that could be obtained by third parties.'
  prefs: []
  type: TYPE_NORMAL
- en: PIR-based methods can be classified as cryptography-based or hardware-based,
    according to [9]. Hardware-based methods use a special kind of **secure coprocessor** (**SC**)
    that acts as securely protected spaces in which the PIR query is processed in
    a non-decipherable way, as in *[10]*. Cryptography-based techniques only use logic
    resources, and do not require a special physical disposition on either the server
    or client-side.
  prefs: []
  type: TYPE_NORMAL
- en: In *[10]*, the authors present a hybrid technique that uses a cloaking method
    through various-size grid Hilbert curves to limit the search domain of a generic
    cryptography-based PIR algorithm; however, the PIR processing on the database
    is still expensive, as shown in their experiments, and it is not practical for
    a user-defined level of privacy. This is because the method does not allow the
    cloaking grid cell size to be specified by the user, nor can it be changed once
    the whole grid has been calculated; in other words, no new PoIs can be added to
    the system. Other techniques can be found in *[12]*.
  prefs: []
  type: TYPE_NORMAL
- en: PIR can also be combined with other techniques to increase the level of privacy.
    One type of compatible LPPM is the dummy query-based technique, where a set of
    random fake or dummy queries are generated for arbitrary locations within the
    greater search area (city, county, state, for example)  *[13]*, *[14]*. The purpose
    of this is to hide the one that the user actually wants to send.
  prefs: []
  type: TYPE_NORMAL
- en: The main disadvantage of the dummy query technique is the overall cost of sending
    and processing a large number of requests for both the user and the server sides.
    In addition, one of the queries will contain the original exact location and point
    of interest of the user, so the original trajectory could still be traced based
    on the query records from a user - especially if no intelligence is applied when
    generating the dummies. There are improvements to this method discussed in *[15]*,
    where rather than sending each point on a separate query, all the dummy and real
    locations are sent along with the location interest specified by the user. In
    *[16]*, the authors propose a method to avoid the random generation of points
    for each iteration, which should reduce the possibility of detecting the trend
    in real points; but this technique requires a lot of resources from the device
    when generating trajectories for each dummy path, generates separate queries per
    path, and still reveals the user's location.
  prefs: []
  type: TYPE_NORMAL
- en: The LPPM presented as an example in this book is MaPIR – a Map-based PIR *[17]*.
    This is a method that applies a mapping technique to provide a common language
    for the user and server, and that is also capable of providing redundant answers
    to single queries without overhead on the server-side, which, in turn, can improve
    response time due to a reduction in its use of geographical queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique creates a redundant geographical mapping of a certain area that
    uses the actual coordinate of the PoI to generate IDs on a different search scale.
    In the MaPIR paper, the decimal digit of the coordinate that will be used for
    the query. Near the Equator, each digit can be approximated to represent a certain
    distance, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85f74902-b81b-49a9-b1a8-f23e13834793.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be generalized by saying that nearby locations will appear close at
    larger scales (closer to the integer portion of the location), but not necessarily
    in smaller ones. It could also show relatively far away points as though they
    were closer, if they share the same set of digits (nth digit of latitude and nth
    digit of longitude).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the digits have been obtained, depending on the selected scale, a mapping
    technique is needed to reduce the number to a single ID. On paper, a simple pseudo-random
    function is applied to reduce the two-dimensional domain to a one-dimensional
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding equation, we can see that `p` is the next prime number to
    the maximum desired ID. Given that for the paper the maximum ID was **9**, the
    value of `p` is **11**. After applying this function, the final map looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f6a4051d-011a-4a32-b113-c4be8ba8039a.png)'
  prefs: []
  type: TYPE_IMG
- en: The following figure shows a sample **PoI ID** that represents a restaurant
    located at **10.964824,-74.804778**. The final mapping grid cells will be **2**,
    **6**, and **1**, using the scales k = 3, 2, and 1 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This information can be stored on a specific table in the database, or as the
    DBA determined best for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11b1eb59-2888-4f6d-82af-7c9a67c85bde.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on this structure, a query generated by a user will need to define the
    scale of search (within 100 m, 1 km, and so on), the type of business they are
    looking for, and the grid cell they are located. The server will receive the parameters
    and look for all restaurants in the same cell ID as the user. The results will
    return all restaurants located in the cells with the same ID, even if they are
    not close to the user. Given that cells are indistinguishable, an attacker that
    gains access to the server's log will only see that a user was in 1 of 10 cell
    IDs. Of course, some of the IDs may fall in inhabitable areas (such as in a forest
    or lake), but some level of redundancy will always be present.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will focus on the implementation of the MaPIR technique as
    an example of a PIR and dummy query-based LPPM. For this, a small dataset of supermarkets
    is loaded on the database as PoIs. These points will be processed and stored as
    explained in MaPIR, and then queried by a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset was obtained from the Colombian open data platform *Datos Abiertos* at
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.datos.gov.co/Comercio-Industria-y-Turismo/Mapa-supermercados-Guadalajara-de-Buga/26ma-3v68](https://www.datos.gov.co/Comercio-Industria-y-Turismo/Mapa-supermercados-Guadalajara-de-Buga/26ma-3v68)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The points in the dataset are presented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36415eb4-cb45-4023-be00-22cab43bd9e4.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding recipe, we created temporary tables to store original data,
    as well as tables containing MaPIR information to be queried later by users. The
    following steps allow other users to access those tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the table `supermarkets` to store the information extracted from
    the dataset, and the table `supermarkets_mapir` to store the MaPIR-related information
    for each supermarket register. Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a trigger function that will be applied to all the new registers
    inserted in the table `supermarkets`, so that the new registers will be inserted
    in the `supermarkets_mapir` table, calculating the `cellid` and `levelid` values.
    The following code will create the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the dataset is not properly organized, we extracted the location
    information of the supermarkets and built the following query. After the execution,
    both tables `supermarkets` and `supermarkets_mapir` should be populated. Execute
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all the supermarkets inserted in the `supermarket` table will have their
    MaPIR-related information in the `supermarkets_mapir` table. The following query
    will illustrate the information stored in the `supermarkets_mapir` table for a
    given register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the query is shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15a3f8b6-c2bc-4288-b790-db5f53e8f11b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the `supermarket` data is ready, assume that a user is at the coordinates
    `(-76.299017, 3.901726)`, which matches the location of one of the supermarkets,
    and that they want to use the scale 2 (the second decimal digit corresponding
    to a grid cell size of approximately 1 km² by the Equator).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The mobile app should generate a query asking for `levelid = 2` and a `cellid
    = 9`, calculated from the second decimal digit from `latitude = 0`, and `longitude
    = 9` on the second decimal digit. This calculation can be verified on the mapping
    table previously shown, with `Lat Nth +1 = 1` and `Long Nth + 1 = 10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is no need for any geographical information in the query anymore,
    because the mapping was done during the pre-processing stage. This reduces the
    query time, because it does not require the use of complex internal functions
    to determine distance; however, mapping cannot guarantee that all nearby results
    will be returned, as results in adjacent cells with different IDs may not appear.
    In the following figure, you can see that the supermarkets from the previous query
    (in black) do not include some of the supermarkets that are near the user''s location
    (in white near the arrow). Some possible counter-measures can be applied to tackle
    this, such as double-mapping some of the elements close to the edges of the grid
    cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8be935a-adae-4e3d-911b-aeff4a68874a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we implemented an LPPM that uses PIR and a dummy query called
    MaPIR. It created a mapping function for points of interest that allowed us to
    query using different scales. It also included redundancy in the answer, providing
    privacy protection, as it did not reveal the actual location of the user.
  prefs: []
  type: TYPE_NORMAL
- en: The process required for calculating the mapping of a dataset should be stored
    in a table that will be used for a user’s queries. In the MaPIR paper, it was
    shown that despite the multiple results, the execution time of the MaPIR queries
    took less than half the time, compared to the geopraphical queries based on distance.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: European Union Directive on Privacy and Electronic Communications, 2002.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*M. Duckham* and *L. Kulik*, *Location Privacy and Location-aware Computing*,
    Dyn. Mob. GIS Investig. Chang. Sp. time, vol. 3, pp. 35–51, 2006.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*J. Krumm*, *Inference Attacks on Location Tracks*, in Pervasive Computing.
    Springer, 2007, pp. 127-143.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*M. A. Labrador*, *A. J. Perez*, and *P. Wightman*. *Location-based Information
    Systems: Developing Real-time Tracking Applications*. Boca Raton: CRC Press, 2011.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*M. Duckham* and *L. Kulik*, *A Formal Model of Obfuscation and Negotiation
    for Location Privacy*, in *Pervasive Computing. Springer*, 2005, pp. 152-170.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*P. Wightman*, *W. Coronell*, *D. Jabba*, *M. Jimeno*, and *M. Labrador*, *Evaluation
    of Location Obfuscation Techniques for Privacy in Location-based Information Systems*,
    in Communications (LATINCOM), 2011 IEEE Latin-American Conference on, pp. 1-6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*P. Wightman*, *M. Zurbarán*, *E. Zurek*, *A. Salazar*, *D. Jabba*, and *M.
    Jimeno*, *θ-Rand: Random Noise-based Location Obfuscation Based on Circle Sectors*,
    in IEEE International Symposium on Industrial Electronics and Applications (ISIEA)
    on, 2013.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*P. Wightman*, *M. Zurbarán*, and *A. Santander*, *High Variability Geographical
    Obfuscation for Location Privacy*, 2013 47th International Carnahan Conference
    on Security Technology (ICCST), Medellin, 2013, pp. 1-6.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A. Labrador*, *P. Wightman*, *A. Santander*, *D. Jabba*, *M. Jimeno*, *Tis-Bad:
    A Time Series-Based Deobfuscation Algorithm*, in Investigación e Innovación en
    Ingenierías. Universidad Simón Bolívar. Vol. 3 (1), pp. 1 - 8\. 2015.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*A. Khoshgozaran*, *H. Shirani-Mehr*, and *C. Shahabi*, *SPIRAL: A Scalable
    Private Information Retrieval Approach to Location Privacy*, in Mobile Data Management
    Workshops, 2008\. MDMW 2008\. Ninth International Conference on, pp. 55-62.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*F. Olumofin*, *P. K. Tysowski*, *I. Goldberg*, and *U. Hengartner*, *Achieving
    Efficient Query Privacy for Location-based Services*, in Privacy Enhancing Technologies,
    2010, pp. 93-110.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*G. Ghinita*, *P. Kalnis*, *A. Khoshgozaran*, *C. Shahabi*, and *K. Tan*, *Private
    queries in location-based services: Anonymizers are not necessary*, in Proceedings
    of the 2008 ACM SIGMOD International Conference on Management of Data, pp. 121-132.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*D. Quercia*, *I. Leontiadis*, *L. McNamara*, *C. Mascolo*, and *J. Crowcroft*,
    *SpotME if you can: Randomized Responses for Location Obfuscation on Mobile Phones*,
    in *Distributed Computing Systems (ICDCS), 2011 31st International Conference
    on,* 2011, pp. 363-372.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*H. Kido*, *Y. Yanagisawa*, and *T. Satoh*, *An Anonymous Communication Technique
    using Dummies for Location-based Services*, in *Pervasive Services, 2005\. ICPS
    ''05\. Proceedings. International Conference on,* pp. 88-97.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*H. Lu*, *C. S. Jensen*, and *M. L. Yiu*, *Pad: Privacy-area aware, dummy-based
    location privacy in mobile services*, in *Proceedings of the Seventh ACM International
    Workshop on Data Engineering for Wireless and Mobile Access*, pp. 16-23.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*P. Shankar*, *V. Ganapathy*, and *L. Iftode* (2009, September), *Privately
    Querying Location-based Services with sybilquery*. In Proceedings of the 11th
    international conference on Ubiquitous computing, 2009, pp. 31-40.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*P. M. Wightman*, *M. Zurbarán*, *M. Rodríguez*, and *M. A. Labrador*, *MaPIR:
    Mapping-based Private Information Retrieval for Location Privacy in LBISs*, 38th
    Annual IEEE Conference on Local Computer Networks - Workshops, Sydney, NSW, 2013,
    pp. 964-971.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
