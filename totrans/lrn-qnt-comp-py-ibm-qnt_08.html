<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer619" class="Basic-Text-Frame">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-133" class="chapterTitle">Optimizing and Visualizing Quantum Circuits</h1>
    <p class="normal">In the previous chapter, you learned how to program with <strong class="keyWord">Qiskit</strong>, using both circuits and pulse schedules. We’ll continue with the topic of circuits in this chapter, specifically some new features that optimize and speed up the end-to-end process by reducing the overhead between the classical and quantum systems during heavy computation cycles.</p>
    <p class="normal">Luckily, Qiskit provides plenty of features to allow us to do this with ease. Additionally, Qiskit provides a set of classes and features to optimize and enhance the visualizations of your circuits. Learning about these features will help optimize your circuit results and allow you to render the circuits in various styles and representations, such as a <strong class="keyWord">directed acyclic graph</strong> (<strong class="keyWord">DAG</strong>).</p>
    <p class="normal">We will cover the following topics in this chapter:</p>
    <ul>
      <li class="bulletList">Optimizing circuits using Preset Passmanager</li>
      <li class="bulletList">Visualizing and enhancing circuit graphs</li>
    </ul>
    <p class="normal">After reading this chapter, you will be able to optimize your circuits by using various visual and programmatic representations of the backend systems and visualization tools. You’ll also have some insights into the various transpiler features available that help optimize the transpilation of your circuit for a given quantum backend system. You’ll have learned about <strong class="keyWord">Preset Passmanagers</strong> and how they can be leveraged to generate custom pass managers used to execute the circuit transformations inside the transpiler at varying optimization levels.</p>
    <h1 id="_idParaDest-134" class="heading-1">Technical requirements</h1>
    <p class="normal">In this chapter, it is expected that you are familiar with creating and executing quantum circuits on both a simulator and a quantum computer. Knowledge of quantum hardware, such as qubits and connectivity between qubits, is also recommended. You may also need to install <strong class="keyWord">Graphviz</strong>, <strong class="keyWord">LaTeX</strong>, and perhaps other dependencies in your Python development environment if indicated while running some cells.</p>
    <p class="normal">Here is the full source code used throughout this book: <a href="https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition"><span class="url">https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition</span></a>.</p>
    <h1 id="_idParaDest-135" class="heading-1">Optimizing circuits using Preset Passmanager</h1>
    <p class="normal">We need to ensure that when a quantum circuit is mapped to the quantum system (transpiled), it is done in the most<a id="_idIndexMarker883"/> efficient and effective way. This includes things such as mapping each qubit to those on the quantum system with the least<a id="_idIndexMarker884"/> amount of noise affected by decoherence or any other noise source that could introduce errors to your results. To accomplish this, we will learn about the <strong class="keyWord">Preset Passmanager</strong>, its usage, and the various features it makes available for us to create and execute optimal circuits. By optimizing the execution of the circuit to match the topology of the quantum device, we reduce the noise and its effect on our results.</p>
    <p class="normal">In this section, we will learn about transforming a quantum circuit so that it is best matched to the quantum device. We will also learn how to optimize the circuit by using the layout optimizer. We will then learn about the backend configuration and its optimization, along with the pass manager and passes.</p>
    <h2 id="_idParaDest-136" class="heading-2">Transpiling a quantum circuit</h2>
    <p class="normal">When you create a circuit and run it on<a id="_idIndexMarker885"/> a quantum device, there are many things that occur between the time you send the circuit to be executed on the quantum device and the time the results are returned. We looked at a few of those steps when we discussed Qiskit Runtime in <em class="chapterRef">Chapter 7</em>, <em class="italic">Programming with Qiskit</em>. In this chapter, we will look at the various features included in Qiskit Runtime, including those introduced in the latest version of Qiskit 1.0. First, let’s look at a basic overview of just a few of the processes that occur when transpiling a circuit.</p>
    <p class="normal">The following flowchart illustrates the general process in which the circuit is transpiled so that it can run on the specified backend and be optimized as per the provided settings:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_01.png" alt="Figure 9.2 – The transpiler process of a circuit from the initial circuit, with passes " width="784" height="756"/></figure>
    <p class="packt_figref">Figure 8.1: The transpiler process of a circuit from the initial circuit, with passes</p>
    <p class="normal">We’ll begin by introducing the<a id="_idIndexMarker886"/> general steps taken, as shown in the preceding flowchart, during the execution process:</p>
    <ol>
      <li class="numberedList" value="1">First, the transpiler will unroll the gates in the circuit down to the basis gates of the specified backend system.</li>
      <li class="numberedList">Next, it will set the layout of the circuit to the device. One example of a layout is the <em class="italic">trivial layout</em> in which the circuit maps the qubits on your circuit to the same physical qubits on the quantum device. For example, qubit 0 on your circuit is mapped to the same qubit index, in this case, qubit 0 on the physical device.</li>
      <li class="numberedList">Next, it will map the circuit to the hardware topology. This is to ensure that the logic of your circuit is mapped onto the quantum hardware. For example, let’s say you have a CNOT that connects the control qubit to the target qubit. However, if there is not a direct connection between the control and target qubits, then the transpiler will add some SWAP gates to ensure that the connection between the two qubits is made by swapping information between qubits in between the control and target qubits.</li>
      <li class="numberedList">Finally, the circuit mapping will be optimized to ensure that the circuit depth is contained to a minimum<a id="_idIndexMarker887"/> for the given quantum system. Steps 2 and 3 can be mapped to any combination of qubits on the physical device; as you can imagine, finding the right combination of qubits to use that reduces the depth of the circuit is very difficult. Thankfully, the transpiler handles this for us.</li>
    </ol>
    <p class="normal">The transpiler is made up of two primary components – that is, the <strong class="keyWord">pass</strong> and the <strong class="keyWord">pass manager</strong>:</p>
    <ul>
      <li class="bulletList">A transpiler <strong class="keyWord">pass</strong> is the component that transforms the circuit from its current state into a new state. For<a id="_idIndexMarker888"/> example, some passes mentioned in the previous steps are focused on layout selection, routing, optimizations, circuit analysis, and many others. To see an exhaustive list of available passes, you can run the following:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Load helper file</span>
%run helper_file_1.0.ipynb
<span class="hljs-comment"># Import the transpiler passes object</span>
<span class="hljs-keyword">from</span> qiskit.transpiler <span class="hljs-keyword">import</span> passes
<span class="hljs-comment"># List out all the passes available</span>
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(passes))
</code></pre>
        <div class="note-one">
          <p class="normal">The preceding code will list all the passes available. For a detailed description of Pass Manager, I recommend reviewing the API documentation under <code class="inlineCode">qiskit.transpiler.PassManager</code>. To ensure you have the latest code information, check the main API documentation page found here: <a href="https://docs.quantum.ibm.com/api/qiskit/transpiler"><span class="url">https://docs.quantum.ibm.com/api/qiskit/transpiler</span></a>.</p>
          <p class="normal">Additional examples can also be found in the guide here: <a href="https://docs.quantum.ibm.com/guides/transpile"><span class="url">https://docs.quantum.ibm.com/guides/transpile</span></a>.</p>
        </div>
      </li>
    </ul>
    <ul>
      <li class="bulletList">The <strong class="keyWord">pass manager</strong> is the <a id="_idIndexMarker889"/>component that is available to you to specify which passes you wish to use. The pass manager also allows the passes themselves to communicate with other passes. This is ideal for scenarios where one pass would provide or obtain information from other passes to ensure the final circuit adheres<a id="_idIndexMarker890"/> to any configuration or optimization requirements. The pass manager also has some preset passes that it makes available to simplify the optimization of a circuit.</li>
    </ul>
    <h3 id="_idParaDest-137" class="heading-3">Generating preset passmanagers</h3>
    <p class="normal">To ease the use of these passes and passmanagers, Qiskit comes with a few pre-built transpilation pipelines (four at the time of this writing). Each can be found in the <code class="inlineCode">qiskit.transpiler.preset_passmanagers</code> module. These pre-built preset pass managers are based on the optimization level selected. These four are currently numbered from 0 to 3. Generating <a id="_idIndexMarker891"/>these is also simplified by using the <code class="inlineCode">generate_preset_pass_manager()</code> function. The preset pass managers are the default pass managers used by the <code class="inlineCode">transpile()</code> function, which constructs a standalone passmanager that mirrors the <code class="inlineCode">transpile()</code> function.</p>
    <p class="normal">In the following section, we will create a simple circuit and transpile it by using the preset passmanager generator, which leverages existing preset pass manager pipelines. We’ll also run the same circuit with two different optimization levels to see how the resulting circuit differentiates between the two. Finally, we will create a custom topology to transpile the circuit and compare the results of that to a circuit created via the preset optimizer. This will illustrate the consequences of selecting a layout that has not been optimized.</p>
    <h3 id="_idParaDest-138" class="heading-3">Comparing circuit mappings on different backend devices</h3>
    <p class="normal">To visualize information on the backend, we learned earlier that we can call the configuration and properties functions to output all the information. That can be handy if we want to extract<a id="_idIndexMarker892"/> specific data from the results; however, it is quite difficult to read. This is where the visualization tool comes in very <a id="_idIndexMarker893"/>handy. Let’s first pick two backend systems to compare. In this example, I’ll choose <code class="inlineCode">ibm_brisbane</code>, and <code class="inlineCode">ibm_nazca</code>, but you can select whichever quantum device you have available by running the <code class="inlineCode">service.backends()</code> to get a list of available devices:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Get a list of all available backend devices</span>
service.backends()
<span class="hljs-comment"># From the list of backends, select two.</span>
<span class="hljs-comment"># Get the backend device: ibm_brisbane</span>
backend_brisbane = service.get_backend(<span class="hljs-string">'ibm_brisbane'</span>)
<span class="hljs-comment"># Get the backend device: ibm_nazca</span>
backend_nazca = service.get_backend(<span class="hljs-string">'ibm_nazca'</span>)
</code></pre>
    <p class="normal">Now that we have selected both backend views, let’s look at a visual representation of the gates and how they are physically connected using the coupling map. You can see the coupling map by calling the <code class="inlineCode">plot_gate_map</code> visualization function as illustrated in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Visualize the coupling directional map between the qubits</span>
plot_gate_map(backend_brisbane, plot_directed=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">This will print out the full connection map of all the qubits for the specified backend, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_02.png" alt="" width="679" height="271"/></figure>
    <p class="packt_figref">Figure 8.2: Cropped view of the ibm_brisbane connection map</p>
    <p class="normal">In <em class="italic">Figure 8.2</em>, with <code class="inlineCode">ibm_brisbane</code> (we’ll refer to this backend device as <code class="inlineCode">Brisbane</code> moving forward for simplicity), we can see that not only is it a 127-qubit device (cropped so it is easier to read), but also the qubits are connected in a heavy-hex formation. You can find details about this here: <a href="https://www.ibm.com/quantum/blog/heavy-hex-lattice"><span class="url">https://www.ibm.com/quantum/blog/heavy-hex-lattice</span></a>. Due to the size of the processor, some of the qubit numbers are not clear, so you may need to zoom in to view these up close. Also, note that signals can travel in both directions between each qubit via<a id="_idIndexMarker894"/> the connections.</p>
    <p class="normal">Let’s now visualize the coupling <a id="_idIndexMarker895"/> directional map of <code class="inlineCode">ibm_nazca</code>, hereafter referred to as just Nazca. Run the following cell:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Visualize the coupling directional map between the qubits</span>
plot_gate_map(backend_nazca, plot_directed=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">Now, we can see the gate map with the coupling directional mapping between each qubit, as illustrated here:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_03.png" alt="A grid of numbers and letters  Description automatically generated" width="570" height="229"/></figure>
    <p class="packt_figref">Figure 8.3: Qubit plot view with the coupling directional map enabled (ibm_nazca)</p>
    <p class="normal">You may notice that the coupling maps have some similarities between the two systems.</p>
    <p class="normal">Because of the different configurations of the qubits, the layout of the qubits from the quantum circuit we created might not be defined in the most optimal way when mapping the qubits on the quantum circuit to the qubits on the hardware device. Luckily for us, we have transpilation features, which include a parameter setting that allows us to set the level of optimization of the circuit layout. The next section will cover the various passes available, and the pass manager used to manage their usage.</p>
    <h2 id="_idParaDest-139" class="heading-2">Understanding passes and pass managers</h2>
    <p class="normal">Passes are generally used to transform circuits so that they are set up to perform as optimally as desired. There are five general types of passes that transform circuits:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Layout selection</strong> determines how<a id="_idIndexMarker896"/> the qubit layout mapping will align with the selected backend configuration.</li>
      <li class="bulletList"><strong class="keyWord">Routing</strong> maps the placement of SWAP gates onto the circuit based on the selected swap mapping type, which can be<a id="_idIndexMarker897"/> set by providing a coupling map or backend topology, or by using stochastic methods, where the system will not assume the input state to the circuit is the ground/zero state to simplify the circuit.</li>
      <li class="bulletList"><strong class="keyWord">Basis change</strong> offers various ways to decompose, or unroll, the gates down to the basis gates of the backend or using the circuit’s decomposition rules.</li>
      <li class="bulletList"><strong class="keyWord">Optimizations</strong> optimize the circuits themselves by removing redundant gates, such as having two of the same reversible gates, such as a Hadamard gate, back to back, which reverts the qubit to the original state.</li>
      <li class="bulletList"><strong class="keyWord">Circuit analysis</strong> provides circuit information, such as the depth, width, number of operations, and other details about the circuit.</li>
      <li class="bulletList"><strong class="keyWord">Additional passes</strong> are those that offer some other form of optimization, such as the various <strong class="keyWord">check maps</strong>, which<a id="_idIndexMarker898"/> check whether the layout of the CNOT gates is in the direction stated in the coupling maps and rearrange the directions if needed.</li>
    </ul>
    <p class="normal">We covered most of the <strong class="keyWord">circuit analysis</strong> information in <em class="chapterRef">Chapter 7</em>, <em class="italic">Programming with Qiskit</em>, to detect the size, width, and <a id="_idIndexMarker899"/>number of operations in a circuit. Let’s look at the first pass type, Layout Selection, to see how we can leverage the provided layouts and learn the difference between the various optimization levels.</p>
    <h3 id="_idParaDest-140" class="heading-3">Learning about the Layout Selection type</h3>
    <p class="normal">Let’s dig down into one of these types of passes to get a little more detail. Since we must map the qubits from the circuit to the <a id="_idIndexMarker900"/>specified hardware each time, and we want to execute our circuit on a quantum system, we’ll view the layout pass. There<a id="_idIndexMarker901"/> are various layout passes to choose from when you want to map the qubits to the physical device. Reasons for this could include wanting your qubits to be as close as possible to avoid having multiple SWAP gates, or if you are working on error correction or mitigation, then you may want to map your gates exactly to the physical qubits to ensure your experiments are consistent. Let’s look at a few of the basic layout options:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">TrivialLayout</code>: This layout assigns the circuit qubits to the physical device’s qubits in the same order as stated in the original quantum circuit. So, qubit 0 is mapped directly to qubit 0 on the physical device.</li>
      <li class="bulletList"><code class="inlineCode">DenseLayout</code>: This layout selects the layout that has the most connected subset of qubits. If there is <a id="_idIndexMarker902"/>a need for many entangled qubits, this layout will find a subset in which qubits are closely connected to each other so as to avoid long distances and swaps.</li>
      <li class="bulletList"><code class="inlineCode">Sabre</code>: This layout leverages a qubit mapping technique that looks at the reversibility of the quantum circuit where it will try to interpret the global circuit information to choose the optimal initial layout.</li>
    </ul>
    <p class="normal">For each of the passes described above, there is a different default setting for the optimization level of the transpiler. The optimization level is comprised of 4 levels that range from 0 to 3, which specifies whether to not optimize the circuit at all (level 0) up to full optimization (level 3). The higher the optimization level, the more optimized the resulting circuit will be; however, it will of course require a bit more time to run.</p>
    <p class="normal">In this section, you will learn how to apply and differentiate between each level.</p>
    <h4 class="heading-4">Applying default layouts</h4>
    <p class="normal">Let’s start with the default layouts. We’ll set the various optimization levels in the transpiler function parameter and apply it to the two backend devices, <code class="inlineCode">Brisbane</code> and <code class="inlineCode">Nazca</code>, in the following steps. One thing to keep in mind is that at the time of writing, all systems available have the same connectivity <a id="_idIndexMarker903"/>between qubits and very similar properties. However, by the time this book is published, there will be varying systems with varying properties, so even though the results here might look the same, the results you see (if the systems you are comparing are different) will vary:</p>
    <ol>
      <li class="numberedList" value="1">We’ll reuse the same four-qubit quantum circuit we created earlier. I’ll include it again here for your convenience:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Quantum circuit with a single and multi-qubit gates</span>
qc = QuantumCircuit(<span class="hljs-number">4</span>)
qc.h(<span class="hljs-number">0</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)
circuit_drawer(qc)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will result in our basic circuit where each of the 4 qubits is entangled via the CX gates to the first qubit, q<sub class="subscript">0</sub>.</p>
    <p class="normal-one">We’ll start with <code class="inlineCode">Brisbane</code> and set the optimization level to <code class="inlineCode">0</code>, which is to say we will not use any <a id="_idIndexMarker904"/>optimization techniques on the circuit. What this will result in is the qubit on our quantum circuit <code class="inlineCode">[0,1,2,3]</code>, which will map to the same qubit index values on the backend device, <code class="inlineCode">Brisbane [0,1,2,…,126]</code>.</p>
    <ol>
      <li class="numberedList" value="2">In the following code, we will leverage the <code class="inlineCode">qc</code> circuit and use it to test the various optimization levels. We’ll then print out the transpiled circuit depth and visualize the layout with the mapped qubits drawn as an overlay over the backend device. This will illustrate how the different methods are applied to the backend device:<div class="packt_tip-one">
          <p class="normal">Note that your results might be different due to the stochastic parts of the transpiler. So, whatever result you get is the optimal result at the time of execution. To ensure you get the same results, you will need to set the <code class="inlineCode">seed_transpiler</code> parameter of the <code class="inlineCode">transpiler()</code> function to a random integer value.</p>
        </div>
      </li>
    </ol>
    <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Generate a preset pass manager for Brisbane</span>
pass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level = 0)
<span class="hljs-comment"># Transpile the circuit with an optimization level = 0</span>
qc_brisbane_0 = pass_manager.run(qc)
<span class="hljs-comment"># Print out the depth of the circuit</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Depth:'</span>, qc_brisbane_0.depth())
<span class="hljs-comment"># Plot the resulting layout of the quantum circuit after # Layout</span>
plot_circuit_layout(qc_brisbane_0, backend_brisbane)
</code></pre>
    <p class="normal-one">The result, as follows, is as expected, where the qubits are mapped with no layout optimization at all, and there is the direct mapping of qubits from the quantum circuit to the hardware<a id="_idIndexMarker905"/> device. Note also that the depth is <code class="inlineCode">6464</code>:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_04.png" alt="A blue lines with black dots  Description automatically generated" width="759" height="403"/></figure>
    <p class="packt_figref">Figure 8.4: Transpiled quantum circuit on Brisbane with optimization = 0; direct qubit mapping with no changes</p>
    <ol>
      <li class="numberedList" value="3">Now, let’s draw the transpiled circuit on <code class="inlineCode">Brisbane</code>:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Draw the transpiled circuit pertaining to Brisbane</span>
circuit_drawer(qc_brisbane_0, idle_wires=False, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render the transpiled circuit using the basis gates available on <code class="inlineCode">Brisbane</code>; it has been truncated in the following figure to save space.</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_05.png" alt="A diagram of a mathematical equation  Description automatically generated with medium confidence" width="758" height="193"/></figure>
    <p class="packt_figref">Figure 8.5: Transpiled circuit of basis gates on Brisbane</p>
    <p class="normal-one">Please note that the unused qubits are not visible due to our use of the <code class="inlineCode">idle_wires=False</code> parameter when calling the <code class="inlineCode">circuit_drawer()</code> function. If we remove this parameter, you will see all qubits, even those that are not in use. Also note that the qubit mappings are depicted on the left side of the circuit diagram where the circuit <a id="_idIndexMarker906"/>mapping is pointing to the physical device’s qubit. In the previous figure, we can see that from the circuit, q<sub class="subscript">0</sub> maps to the 0<sup class="superscript">th</sup> qubit on the physical device (as shown by the indicator q<sub class="subscript">0</sub> -&gt; 0).</p>
    <ol>
      <li class="numberedList" value="4">Now, let’s run the same thing on <code class="inlineCode">Nazca</code> with the same level of optimization set to <code class="inlineCode">0</code>. We should see the same results, in that the transpiled circuit is mapped to the same qubits as our quantum circuit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Generate a preset pass manager for Brisbane</span>
pass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level = 0)
<span class="hljs-comment"># Transpile the circuit with an optimization level = 0</span>
qc_brisbane_0 = pass_manager.run(qc)
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Depth:'</span>, qc_nazca_0.depth())
plot_circuit_layout(qc_nazca_0, backend_nazca)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will result in the following depth information:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Depth: <span class="hljs-number">4040</span>
</code></pre>
    <p class="normal-one">The resulting layout mapping, as follows, is also displayed:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_06.png" alt="A blue lines with black dots  Description automatically generated" width="757" height="403"/></figure>
    <p class="packt_figref">Figure 8.6: Transpiled circuit on Nazca</p>
    <p class="normal-one">Let’s now look at the transpiled circuit for the <code class="inlineCode">Nazca</code> quantum device.</p>
    <ol>
      <li class="numberedList" value="5">We’ll now draw the transpiled <a id="_idIndexMarker907"/>circuit using the following code:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Draw the transpiled circuit pertaining to Nazca</span>
circuit_drawer(qc_nazca_0, idle_wires=False, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will display the following circuit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_07.png" alt="A line of blue squares with black lines  Description automatically generated" width="759" height="147"/></figure>
    <p class="packt_figref">Figure 8.7: Transpiled circuit on Nazca</p>
    <p class="normal-one">One thing to note is the set of multi-qubit gates between q<sub class="subscript">0</sub> and q<sub class="subscript">1</sub> after the first set of single-qubit gates. These multi-qubit gates can be used to create a CNOT, SWAP, or ROTX gate, represented by the red block labeled <strong class="keyWord">Ecr</strong>. This routing of information between qubits is the result of the routing pass, which looks for the most optimal <a id="_idIndexMarker908"/>connection between qubits. The following figure shows the decomposed SWAP gate.</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_08.png" alt="A picture containing text, clock  Description automatically generated" width="287" height="131"/></figure>
    <p class="packt_figref">Figure 8.8: SWAP gate decomposed</p>
    <ol>
      <li class="numberedList" value="6">Let’s now maximize the optimization level to <code class="inlineCode">3</code>, which performs the highest optimization of the quantum circuit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Generate a preset pass manager for Brisbane:</span>
pass_manager = generate_preset_pass_manager(backend=backend_brisbane, optimization_level=<span class="hljs-number">3)</span>
<span class="hljs-comment"># Transpile the circuit with the optimization level = 3</span>
qc_transpiled_brisbane= pass_manager.run(qc)
<span class="hljs-comment"># Print the depth of the transpiled circuit</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Depth:'</span>, qc_transpiled_brisbane.depth())
<span class="hljs-comment"># Print the number of operations of the transpiled # circuit</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Ops count: '</span>, qc_transpiled_brisbane.count_ops())
<span class="hljs-comment"># Plot the layout mapping of the transpiled circuit</span>
plot_circuit_layout(qc_transpiled_brisbane, backend_brisbane)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will print out the total circuit depth and the total number of operators (<code class="inlineCode">Ops count</code>) in the transpiled circuit, along with the rendering of the transpiled mapping of the qubits onto <code class="inlineCode">Brisbane</code>.</p>
    <pre class="programlisting code-one"><code class="hljs-code">Depth: <span class="hljs-number">133</span>
Ops count:  OrderedDict([(<span class="hljs-string">'rz'</span>,<span class="hljs-number">14</span>), (<span class="hljs-string">'sx'</span>, <span class="hljs-number">7</span>), (<span class="hljs-string">'ecr'</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">'x', 1)])</span>
</code></pre>
    <p class="normal-one">Here, you’ll notice some gates you might not have seen before; you can find details about each gate in the circuit library on the Qiskit API documentation page here: <a href="https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library"><span class="url">https://docs.quantum-computing.ibm.com/api/qiskit/circuit_library</span></a>.</p>
    <p class="normal-one">The following diagram<a id="_idIndexMarker909"/> shows the rendering of the transpiled mapping of the qubits, as mentioned earlier:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_08_09.png" alt="A diagram of a network  Description automatically generated" width="754" height="423"/></figure>
    <p class="packt_figref">Figure 8.9: Transpiled circuit with the optimization level set to 3 for Brisbane</p>
    <p class="normal-one">As you can see in the preceding diagram, to optimize the quantum circuit, the qubit order is adjusted from the previous example on <code class="inlineCode">Brisbane</code>. This is due to the <code class="inlineCode">optimization_level</code> parameter being set to 3 (highest), which includes mapping to the most optimal qubits. This also highlights the difference in circuit depth between the two.</p>
    <ol>
      <li class="numberedList" value="7">Let’s now draw the transpiled circuit to review the circuit layout to the backend:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Redraw the transpiled circuit at new level</span>
circuit_drawer(qc_transpiled_brisbane, idle_wires=<span class="hljs-literal">False</span>, output=<span class="hljs-string">'mpl'</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result, as follows, is the same circuit that is now mapped to different qubits compared to the circuit in <em class="italic">Figure 8.6</em>. The difference between this circuit and the previous one is simply that the transpiler has the maximum optimization level set, so it will <a id="_idIndexMarker910"/>map the qubit operators to the most optimal qubits. For example, here we see qubit 0 is mapped to qubit 4, as follows:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_08_10.png" alt="A diagram of a circuit  Description automatically generated" width="753" height="235"/></figure>
    <p class="packt_figref">Figure 8.10: Transpiled circuit with the optimization level set to 3</p>
    <ol>
      <li class="numberedList" value="8">We’ll set the same optimization level on <code class="inlineCode">Nazca</code> to <code class="inlineCode">3</code> and then transpile the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Generate a preset pass manager for Nazca:</span>
pass_manager = generate_preset_pass_manager(backend=backend_nazca, optimization_level=<span class="hljs-number">3)</span>
<span class="hljs-comment"># Transpile the circuit with the optimization level = 3</span>
qc_transpiled_nazca= pass_manager.run(qc)
<span class="hljs-comment"># Get the depth and operation count of the transpiled</span>
<span class="hljs-comment"># circuit.</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Depth:'</span>, qc_transpiled_nazca.depth())
<span class="hljs-built_in">print</span>(<span class="hljs-string">'Ops count: '</span>, qc_transpiled_nazca.count_ops())
<span class="hljs-comment"># Print the circuit layout</span>
plot_circuit_layout(qc_transpiled_nazca, backend_nazca)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Here, the total depth is the same, as is the number and type of operators:</p>
    <pre class="programlisting code-one"><code class="hljs-code">Depth: <span class="hljs-number">1919</span>
Ops count:  OrderedDict([(<span class="hljs-string">'rz'</span>, <span class="hljs-number">23</span>), (<span class="hljs-string">'sx'</span>, <span class="hljs-number">13</span>), (<span class="hljs-string">'ecr'</span>, <span class="hljs-number">3</span>)])
</code></pre>
    <p class="normal-one">However, note that the layout is <a id="_idIndexMarker911"/>not necessarily linear; it seems <em class="italic">T-shaped</em>, where qubit 0 is connected to 3 qubits, like that of <code class="inlineCode">Brisbane</code>:</p>
    <figure class="mediaobject"> <img src="../Images/B18420_08_11.png" alt="A grid with dots and lines  Description automatically generated" width="760" height="478"/></figure>
    <p class="packt_figref">Figure 8.11: Transpiled circuit with the optimization level set to 3</p>
    <p class="normal-one">As you can see, to optimize the circuit depth and reduce noise, the qubit order is reversed from the previous example run on <code class="inlineCode">Nazca</code>.</p>
    <ol>
      <li class="numberedList" value="9">Let’s draw the circuit using the transpiled circuit and see how this mapping looks compared to the <a id="_idIndexMarker912"/>previous circuit mapping:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Draw the transpiled circuit</span>
circuit_drawer(qc_transpiled_nazca, idle_wires=<span class="hljs-literal">False</span>, output=<span class="hljs-string">'mpl'</span>)
</code></pre>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18420_08_12.png" alt="A diagram of a mathematical equation  Description automatically generated with medium confidence" width="758" height="239"/></figure>
    <p class="packt_figref">Figure 8.12: Transpiled circuit with the optimization level set to 3</p>
    <p class="normal-one">Note the use of qubit <strong class="screenText">0</strong>, now qubit <strong class="screenText">44</strong> on the hardware, which was mapped as the qubit on which to base the connections to the other qubits, <strong class="screenText">0</strong>, <strong class="screenText">3</strong>, and <strong class="screenText">2</strong> in the ECR at the end of the circuit. This is a good example, where the optimizer mapped the ECR gates to the physical qubits, for example, qubit <strong class="screenText">45</strong> to qubits <strong class="screenText">44</strong>, <strong class="screenText">46</strong>, and <strong class="screenText">54</strong> on the device, to optimize based on other passes used besides the routing pass. One reason for this case could be that one of the passes considered the coherence time (relaxation time, T1) of the qubits, which is the time a qubit can maintain its quantum state, where the qubit with the longest coherence time, at the time the circuit was transpiled, is qubit <code class="inlineCode">1</code>.</p>
    <h4 class="heading-4">Applying custom layouts</h4>
    <p class="normal">Finally, let’s now create our own <a id="_idIndexMarker913"/>custom mapping, or <strong class="keyWord">topology</strong>, as it is often referred to:</p>
    <ol>
      <li class="numberedList" value="1">Let’s begin by reviewing the <a id="_idIndexMarker914"/>coupling map of an existing device; in this case, let’s continue using <code class="inlineCode">brisbane</code>, which has 127 qubits. We’ll review the configuration of the backend first:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Set the ibm_brisbane backend device to obtain #configuration</span>
backend = service.get_backend(<span class="hljs-string">'ibm_brisbane'</span>)
backend
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code sets the backend so we can obtain the configuration and property values of the quantum device.</p>
    <ol>
      <li class="numberedList" value="2">Let’s examine the coupling map for <code class="inlineCode">ibm_brisbane</code> by calling the backend configuration’s <code class="inlineCode">coupling_map</code> field:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># View the backend coupling map, displayed as CNOTs</span>
<span class="hljs-comment"># (Control-Target)</span>
<span class="hljs-comment"># Extract the coupling map from the backend</span>
ibm_brisbane_coupling_map = backend.configuration().coupling_map
<span class="hljs-comment"># List out the extracted coupling map</span>
ibm_brisbane_coupling_map
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code will result in displaying an array of the coupling layout of <code class="inlineCode">ibm_brisbane</code>. You can verify this by comparing it to the backend view:</p>
    <pre class="programlisting code-one"><code class="hljs-code">[[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],
[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>],
[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>],
…
[<span class="hljs-number">125.126</span>]]
</code></pre>
    <ol>
      <li class="numberedList" value="3">Next, we will draw<a id="_idIndexMarker915"/> the coupling map to see how efficient our circuit is with the default map:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Generate a preset pass manager for Brisbane</span>
<span class="hljs-comment"># Set the backend to None so it will force using the coupling map provided:</span>
pass_manager = generate_preset_pass_manager(backend=<span class="hljs-literal">None</span>,
optimization_level=<span class="hljs-number">3</span>,
coupling_map=ibm_brisbane_coupling_map)
<span class="hljs-comment"># Transpile the circuit with the pass manager</span>
qc_custom = pass_manager.run(qc)
<span class="hljs-comment"># Draw the resulting custom topology circuit.</span>
circuit_drawer(qc_custom, idle_wires=<span class="hljs-literal">False</span>, output=<span class="hljs-string">'mpl'</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">Our circuit, using this topology, is now different from what we saw in <code class="inlineCode">brisbane</code> in <em class="italic">Figure 8.10</em>. Here, we see that the same circuit is now transpiled based on earlier results of the <code class="inlineCode">brisbane</code> topology, as follows (note that this can vary depending on the calibration of the system):</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_13.png" alt="A diagram of a circuit  Description automatically generated" width="575" height="252"/></figure>
    <p class="packt_figref">Figure 8.13: The custom circuit using the topology provided by the ibm_brisbane coupling map</p>
    <ol>
      <li class="numberedList" value="4">Up to now, you have<a id="_idIndexMarker916"/> extracted the coupling map from existing backend systems, in this case, <code class="inlineCode">ibm_brisbane</code>.</li>
      <li class="numberedList">Now, let’s create our own custom topology. For simplicity, we will create a simple linear topology, where the qubits are joined together in a line, as follows:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Create our own coupling map (custom topology)</span>
custom_linear_topology = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]
 
<span class="hljs-comment"># Generate a preset pass manager</span>
<span class="hljs-comment"># Set the backend to None so it will force using the coupling map provided:</span>
pass_manager = generate_preset_pass_manager(backend=None,
optimization_level=<span class="hljs-number">3</span>,
coupling_map=custom_linear_topology)
<span class="hljs-comment"># Transpile the circuit with the pass manager</span>
qc_custom = pass_manager.run(qc)
<span class="hljs-comment"># Draw the resulting custom topology circuit.</span>
circuit_drawer(qc_custom, idle_wires=False, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The result from the preceding circuit code is clearly not ideal:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_14.png" alt="A diagram of a diagram  Description automatically generated" width="682" height="237"/></figure>
    <p class="packt_figref">Figure 8.14: Custom linear topology of our circuit</p>
    <p class="normal">The circuit requires many gates<a id="_idIndexMarker917"/> and is quite deep, which increases the risk of having noisy results. This is a good illustration of the importance of optimizers, which handle many of these potential issues. It’s no surprise that there is so much research in identifying better ways to optimize circuits to avoid inefficient and noisy circuits. However, having the ability to customize your own topology allows you to create optimal passes that could find unique and effective ways to optimize the mapping of circuits for testing and experimental purposes.</p>
    <p class="normal">There are many passes that optimize the circuit (we’ve just covered the layouts as it is easy to see the differences). If you were to look at the full list of passes, you would see that if you change the order of the passes, it will change the results of the circuit when mapped to the physical device. To account for this, we need to look at the pass manager.</p>
    <h3 id="_idParaDest-141" class="heading-3">Leveraging the pass manager</h3>
    <p class="normal">The pass manager is what allows the passes to communicate with each other, schedules which passes should execute first, and <a id="_idIndexMarker918"/>allows for custom passes to be included in the list of passes. This is not as simple as it sounds, as there may be a significant difference if one pass is used before another or perhaps is unable to communicate with another pass. We’ll conclude this section with a simple example of the pass manager, using the following steps to create it:</p>
    <ol>
      <li class="numberedList" value="1">We’ll first append <code class="inlineCode">TrivialLayout</code> to <code class="inlineCode">PassManager</code> and execute the circuit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Import the PassManager and a few Passes</span>
<span class="hljs-keyword">from</span> qiskit.transpiler <span class="hljs-keyword">import</span> PassManager, CouplingMap
<span class="hljs-keyword">from</span> qiskit.transpiler.passes <span class="hljs-keyword">import</span> TrivialLayout, BasicSwap
pm = PassManager()
<span class="hljs-comment"># Create a TrivialLayout based on the ibm_brisbane coupling map</span>
trivial = TrivialLayout(CouplingMap(ibm_brisbane_coupling_map))
<span class="hljs-comment"># Append the TrivialLayout to the PassManager</span>
pm.append(trivial)
<span class="hljs-comment"># Run the PassManager and draw the resulting circuit</span>
tv_qc = pm.run(qc)
circuit_drawer(tv_qc, idle_wires=False, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The resulting circuit is as follows. Note the specifics of this circuit as we will be comparing the differences between the layouts of this circuit and the upcoming circuit (in <em class="italic">Figure 8.16</em>):</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_15.png" alt="Figure 9.22 – PassManager with the appended TrivialLayout Pass circuit " width="405" height="234"/></figure>
    <p class="packt_figref">Figure 8.15: PassManager with the appended TrivialLayout Pass circuit</p>
    <ol>
      <li class="numberedList" value="2">Soon we will explore the functionality of the pass manager using the routing pass type. We saw a little bit of this when the SWAP gates were added to connect qubits when<a id="_idIndexMarker919"/> they are not directly connected on the physical device. In the following steps, we will look at passes that optimize the routing of these SWAP gates.</li>
      <li class="numberedList">In the following code, we will create a <code class="inlineCode">BasicSwap</code> pass, rerun <code class="inlineCode">PassManager</code> on the circuit, and compare the results to the previous circuit:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Create a BasicSwap based on the ibm_brisbane coupling</span>
<span class="hljs-comment"># map we used earlier</span>
basic_swap = BasicSwap(CouplingMap(ibm_brisbane_coupling_map))
<span class="hljs-comment">#Add the BasicSwap to the PassManager</span>
pm = PassManager(basic_swap)
<span class="hljs-comment"># Run the PassManager and draw the results</span>
new_qc = pm.run(qc)
circuit_drawer(new_qc, idle_wires=False, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The previous code will create a <code class="inlineCode">BasicSwap</code> router and add it to <code class="inlineCode">PassManager</code> upon construction. The executed circuit result is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_16.png" alt="A diagram of a circuit  Description automatically generated" width="482" height="264"/></figure>
    <p class="packt_figref">Figure 8.16: PassManager with a BasicSwap router pass circuit</p>
    <p class="normal">As you can see, the circuit will adapt to each of the passes called from <code class="inlineCode">PassManager</code> – in this case, we added the <code class="inlineCode">BasicSwap</code> pass to the PassManager in the code, which then rendered the circuit mapping in one form, whereas the <code class="inlineCode">TrivialLayout</code> pass rendered in a different form. Doing this gives<a id="_idIndexMarker920"/> you the ability to order how the various passes are run during the optimization process of the PassManager. Having this ability provides you with options to test out, should you be researching ways to optimize how your circuit is mapped and run on a backend device.</p>
    <p class="normal">Let’s take a moment to digest what we’ve learned so far. When using the <code class="inlineCode">optimization_level</code> option to execute our circuit on a backend, the PassManager uses the preset passes based on the specific level selected (i.e., 0, 1, 2, or 3). What we managed to do here is customize which passes to use and in what order, as we did when we added the BasicSwap pass to the previous code. Having this ability not only provides you with the flexibility to experiment with various sequences of passes, but you can also create your own pass and compare it with those existing passes.</p>
    <p class="normal">Now that you are familiar with pass managers, you can see that they can be very helpful if you want to use a combination of passes in a way that, when leveraged one after the other, improves the optimization of the circuit as it is modified along the way.</p>
    <p class="normal">In this section, we also learned about the transpiler and how it provides ways to optimize circuits. We also learned about transforming and optimizing the circuit using the layout optimizer.</p>
    <p class="normal">The next section of this chapter is a bit more visual, by rendering the circuits in different styles and operational flows such as <strong class="keyWord">DAGs</strong>. These features provide a way to view the circuits and their functionality in<a id="_idIndexMarker921"/> a different form rather than the default view of the circuits, which is how we have seen them so far.</p>
    <h1 id="_idParaDest-142" class="heading-1">Visualizing and enhancing circuit graphs</h1>
    <p class="normal">This section will focus on the various visualizations available in Qiskit. The graphs we have been using so far were from the default visualization library in Qiskit. However, we can specify other drawing tools that may be better suited for your documentation purposes. Say, for example, that you<a id="_idIndexMarker922"/> are authoring a research paper <a id="_idIndexMarker923"/>with <strong class="keyWord">LaTeX</strong> and you want to use the LaTeX content.</p>
    <p class="normal">By simply adding style <a id="_idIndexMarker924"/>parameters from the Qiskit visualization library, you can then leverage the many features included with the visualization library. We’ll cover a few of those now to get you started.</p>
    <h2 id="_idParaDest-143" class="heading-2">Learning about customized visual circuits</h2>
    <p class="normal">When rendering a circuit, it is often <a id="_idIndexMarker925"/>necessary or convenient to have the results<a id="_idIndexMarker926"/> in a format that suits the format of your document. It’s here where the Qiskit <code class="inlineCode">circuit_drawer</code> comes in handy with various features. Let’s begin with a simple quantum circuit to illustrate the various visual rendering examples:</p>
    <ol>
      <li class="numberedList" value="1">First, let’s create a quantum circuit with various operators to get a good representation of all the<a id="_idIndexMarker927"/> visual components in the various formats:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Sample quantum circuit</span>
qc = QuantumCircuit(<span class="hljs-number">4</span>)
qc.h(<span class="hljs-number">0</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
qc.barrier()
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)
qc.cx(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)
qc.barrier()
qc.cz(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>)
qc.h(<span class="hljs-number">0</span>)
qc.measure_all()
<span class="hljs-comment"># Draw the circuit using the default renderer</span>
circuit_drawer(qc, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render the following circuit drawing, which is just a random representation of gates. This circuit does not do anything special; it’s just used to represent various <a id="_idIndexMarker928"/>components. As an option, you can use the <code class="inlineCode">random_circuit</code> method to create a random circuit:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_17.png" alt="Chart, line chart  Description automatically generated" width="759" height="255"/></figure>
    <p class="packt_figref">Figure 8.17: Circuit rendering using the default library</p>
    <ol>
      <li class="numberedList" value="2">Next, we will render the preceding circuit using <code class="inlineCode">latex</code>:
        <pre class="programlisting code-one"><code class="hljs-code">circuit_drawer(qc, output=<span class="hljs-string">'latex'</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal-one">This will render the <code class="inlineCode">latex</code> version of the circuit:</p>
    <div class="packt_tip-one">
      <p class="normal">If you’re running this on your local machine and not on the platform, you may have some warnings or errors indicating<a id="_idIndexMarker929"/> you need to install some file dependencies, such as installing <code class="inlineCode">pylatexenc</code>. To install this library<a id="_idIndexMarker930"/> you will need to run <code class="inlineCode">pip install pylatexenc</code> in a cell first, and then restart the kernel.</p>
    </div>
    <figure class="mediaobject"><img src="../Images/B18420_08_18.png" alt="Diagram  Description automatically generated" width="759" height="212"/></figure>
    <p class="packt_figref">Figure 8.18: Circuit rendering using the latex library</p>
    <ol>
      <li class="numberedList" value="3">If you are planning to post your circuit onto a website, blog, or social media and would like to include some styles on the image, you can do that as well by passing in the style <a id="_idIndexMarker931"/>contents as a parameter, such as <code class="inlineCode">backgroundcolor</code>, <code class="inlineCode">gatetextcolor</code>, and <code class="inlineCode">fontsize</code>, just to name a few:
        <pre class="programlisting code-one"><code class="hljs-code"><span class="hljs-comment"># Define the style to render the circuit and components</span>
style = {<span class="hljs-string">'backgroundcolor'</span>: <span class="hljs-string">'lightblue'</span>,<span class="hljs-string">'</span><span class="hljs-string">gatefacecolor'</span>:     <span class="hljs-string">'white'</span>, <span class="hljs-string">'gatetextcolor'</span>: <span class="hljs-string">'black'</span>, <span class="hljs-string">'fontsize'</span>: <span class="hljs-number">9</span>}
<span class="hljs-comment"># Draw the mpl with the specified style</span>
circuit_drawer(qc, style=style, output='mpl')
</code></pre>
      </li>
    </ol>
    <p class="normal-one">The preceding code results in <a id="_idIndexMarker932"/>adjusting the background, gate color schemes, and font size, as illustrated here:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_19.png" alt="Chart  Description automatically generated" width="759" height="263"/></figure>
    <p class="packt_figref">Figure 8.19: Rendered circuit with the custom style dictionary on matplotlib</p>
    <p class="normal">To use the style setting, you must <a id="_idIndexMarker933"/>use the output <code class="inlineCode">matplotlib</code> as this is<a id="_idIndexMarker934"/> the only library that supports the styles.</p>
    <div class="note">
      <p class="normal">Details on the available list of styles can be found in the <em class="italic">Style Dict Details</em> section of the Qiskit API<a id="_idIndexMarker935"/> documentation (<a href="https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer"><span class="url">https://docs.quantum-computing.ibm.com/api/qiskit/qiskit.visualization.circuit_drawer</span></a>).</p>
    </div>
    <p class="normal">Finally, we will cover a full view of the circuit as a DAG, which will be helpful to see the circuit as a graph to understand how it flows.</p>
    <h2 id="_idParaDest-144" class="heading-2">Drawing the directed acyclic graph of a circuit</h2>
    <p class="normal">As circuits get larger, they <a id="_idIndexMarker936"/>will naturally get more complex, and even<a id="_idIndexMarker937"/> visualizing a circuit can get complicated. Imagine a circuit with thousands of qubits and with a depth of over 1,000. This would be difficult to render and almost impossible to read. This is where DAGs may help. Let’s create one based on the circuit that we previously created to illustrate rendering and see how the DAG of that circuit looks.</p>
    <p class="normal">In the following code, you will need two components; the first is the circuit-to-DAG converter. This will convert the circuit into a DAG. The second component is the DAG drawer, which will draw out the DAG where the nodes are represented as quantum registers, classical registers, quantum gates, barriers, and measurement operators. The edges are directional, which<a id="_idIndexMarker938"/> illustrates the flow of the circuit:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># Import the Circuit to DAG converter</span>
<span class="hljs-keyword">from</span> qiskit.converters <span class="hljs-keyword">import</span> circuit_to_dag
<span class="hljs-comment"># Import the DAG drawer</span>
<span class="hljs-keyword">from</span> qiskit.visualization <span class="hljs-keyword">import</span> dag_drawer
<span class="hljs-comment"># Convert the circuit into a DAG</span>
dag = circuit_to_dag(qc)
<span class="hljs-comment"># Draw the DAG of the circuit</span>
dag_drawer(dag)
</code></pre>
    <p class="normal">This results in the following<a id="_idIndexMarker939"/> rendering of the DAG:</p>
    <figure class="mediaobject"><img src="../Images/B18420_08_20.png" alt="Figure 9.28 – The DAG rendering of a quantum circuit " width="737" height="1071"/></figure>
    <p class="packt_figref">Figure 8.20: The DAG rendering of a quantum circuit</p>
    <p class="normal">The DAG can help illustrate the flow and expected paths of the circuit in order from top to bottom, where the top level is the first operation, and each operation is appended as you traverse down the graph. For example, the preceding graph starts at the top with the qubits in green, then following the graph, we see that each qubit (represented by the edge labels between the nodes) is operated upon by a specified operation (represented by the nodes). The graph terminates at the end in red, where the measurement applied on<a id="_idIndexMarker940"/> the qubit is mapped to the specified <a id="_idIndexMarker941"/>classical bit, represented by the parameter values.</p>
    <p class="normal">In this section, we learned about visualizing circuit graphs with the help of customized visual circuits. We also learned how to use DAGs to enhance our circuit graphs and visualize the path of our circuit.</p>
    <h1 id="_idParaDest-145" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, you learned various ways to optimize your circuits when they are running on one of the many quantum computers that currently exist. You also learned about the different passes available to optimize the execution of your circuit on a specified quantum device. This includes generating a pass manager, which allows you to customize which passes to leverage based on the selected optimization level and allows you to choose their order.</p>
    <p class="normal">We then covered topology and coupling maps, which helped you understand the importance of knowing the device configurations should you want to create your own passes. By visualizing the circuits in various formats, you now have the skills to customize the rendering of images, particularly if you are documenting your work and would like to keep a certain look and feel. Finally, we covered alternative rendering of the circuit operation flow by using DAGs.</p>
    <p class="normal">In the next chapter, we will learn about various noises associated with quantum systems to understand how we can create noise models that we can use to simulate and identify ways to mitigate and run more efficient algorithms.</p>
    <h1 id="_idParaDest-146" class="heading-1">Questions</h1>
    <ol>
      <li class="numberedList" value="1">Can you name the two components of the transpiler?</li>
      <li class="numberedList">Which component allows you to specify the passes to use?</li>
      <li class="numberedList">What is the default <code class="inlineCode">optimization_level</code> value when running the transpile() function?</li>
      <li class="numberedList">Name the three Layout Selection Passes.</li>
    </ol>
    <h1 id="_idParaDest-147" class="heading-1">Join us on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="Chapter_8.xhtml"><span class="url">https://packt.link/3FyN1</span></a></p>
    <p class="normal"><img src="../Images/QR_Code261762599683826593.png" alt="" width="165" height="165"/></p>
  </div>
</div></div></body></html>