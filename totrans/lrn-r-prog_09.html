<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0; Metaprogramming"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9.  Metaprogramming</h1></div></div></div><p>In the previous chapter, you learned about the structure and features of an environment and also learned how to create and access an environment. Environment plays an important role in lazy evaluation, copy-on-modify, and lexical scoping, which are enabled by the environments associated with a function when it is created and called.</p><p>Now that we have a solid understanding of how functions work, we will go further in this chapter by learning to work with functions in more advanced forms. You will learn the metaprogramming facilities that make R flexible in interactive analysis. More specifically, we will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Functional programming: closures and higher-order functions</li><li class="listitem" style="list-style-type: disc">Computing on language with language objects</li><li class="listitem" style="list-style-type: disc">Understanding non-standard evaluation</li></ul></div><div class="section" title="Understanding functional programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Understanding functional programming</h1></div></div></div><p>In the previous chapter, you learned the behavior of a function in detail, including when an argument is evaluated (lazy evaluation), what happens when we try to modify an argument (copy-on-modify), and where to look for variables not defined within the function (lexical scoping). These technical terms that describe the behaviors may look more difficult than they actually are. In the following sections, you will learn about two types of functions: functions that are defined in functions and functions that work with other functions.</p><div class="section" title="Creating and using closures"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Creating and using closures</h2></div></div></div><p>A function defined in a function is called a <span class="strong"><strong>closure_</strong></span>. It is special because in the function body of the closure, not only the local arguments but also the variables created in the parent function are also available.</p><p>For example, suppose we have the following function:</p><pre class="programlisting">add &lt;- function(x, y) {
  x + y
} 
</pre><p>This function has two arguments. Each time we call <code class="literal">add()</code>, we should supply two arguments. If we use closure, we can generate special versions of this function with a pre-specified argument. In the following section, we will create a simple closure to accomplish this.</p><div class="section" title="Creating a simple closure"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec47"/>Creating a simple closure</h3></div></div></div><p>Here, we will create a function called <code class="literal">addn</code>, which has one argument <code class="literal">y</code>. This function does not do the actual plus calculation but creates a child function that adds <code class="literal">y</code> to whatever number <code class="literal">x</code> supplied:</p><pre class="programlisting">addn &lt;- function(y) {
  function(x) {
    x + y
  }
} 
</pre><p>It may take extra efforts to realize that <code class="literal">addn</code> does not return a number like a typical function, but returns a closure: that is, a function defined in a function. The closure calculates <code class="literal">x + y</code>, where <code class="literal">x</code> refers to a local argument and <code class="literal">y</code> refers to an argument in its enclosing environment. In other words, <code class="literal">addn()</code> is no longer a calculator, but a calculator factory that manufactures calculators.</p><p>The factory function enables us to create specialized versions of calculators. For example, we can create two functions that add <code class="literal">1</code> and <code class="literal">2</code> to a numeric vector, respectively:</p><pre class="programlisting">add1 &lt;- <span class="strong"><strong>addn</strong></span>(1)
add2 &lt;- <span class="strong"><strong>addn</strong></span>(2) 
</pre><p>The two functions work as if the second argument of <code class="literal">add(x, y)</code> was fixed. The following code validates the calculators made by <code class="literal">addn()</code>:</p><pre class="programlisting">
<span class="strong"><strong>add1</strong></span>(10)
## [1] 11
<span class="strong"><strong>add2</strong></span>(10)
## [1] 12 
</pre><p>Take <code class="literal">add1</code> as an example. The <code class="literal">add1 &lt;- addn(1)</code> code evaluates <code class="literal">addn(1)</code>, which results in a function assigned to <code class="literal">add1</code>:</p><pre class="programlisting">add1
## function(x) {
## x + y
## }
## &lt;environment: 0x00000000139b0e58&gt; 
</pre><p>When we print <code class="literal">add1</code>, it is a bit different because the environment of <code class="literal">add1</code> is also attached. The environment of a function will be printed if it is not the current environment-in this case, the global environment. In the environment of <code class="literal">add1</code>, <code class="literal">y</code> is specified in <code class="literal">addn(1)</code>, which can be verified by running the following code:</p><pre class="programlisting">
<span class="strong"><strong>environment</strong></span>(add1)$y
## [1] 1 
</pre><p>We can call <code class="literal">environment()</code> with <code class="literal">add1</code> to access its enclosing environment, which captures <code class="literal">y</code>. That's exactly how closure works. We can do the same thing to <code class="literal">add2</code> and see the value of <code class="literal">y</code> we specified with <code class="literal">addn(2)</code>:</p><pre class="programlisting">
<span class="strong"><strong>environment</strong></span>(add2)$y
## [1] 2 
</pre></div><div class="section" title="Making specialized functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec48"/>Making specialized functions</h3></div></div></div><p>Closures are useful to make specialized functions. For example, due to the flexibility of the production of graphics, plot functions often provide a large number of arguments. If we frequently use only a particular subset of all arguments, we can make specialized versions that make the code easier to write and read.</p><p>The following <code class="literal">color_line</code> function is a version of <code class="literal">plot</code> specialized in color picking, but with plot type and line type being fixed. It is comparable to a factory that makes pens of all colors:</p><pre class="programlisting">color_line&lt;- function(col) {
  function(...) {
<span class="strong"><strong>    plot</strong></span>(..., type = "l", lty = 1, col = col)
  }
} 
</pre><p>If we want a red pen, we call <code class="literal">color_line</code> and get a specialized function that draws red lines. The resulted function is also open to other arguments such as title and font:</p><pre class="programlisting">red_line&lt;- <span class="strong"><strong>color_line</strong></span>("red")
red_line(rnorm(30), main = "Red line plot") 
</pre><p>This function produces the following line plot:</p><div class="mediaobject"><img src="graphics/image_09_001.jpg" alt="Making specialized functions"/></div><p>The preceding code looks more readable than the original version that does not employ such a specialized function:</p><pre class="programlisting">
<span class="strong"><strong>plot</strong></span>(<span class="strong"><strong>rnorm</strong></span>(30), type = "l", lty = 1, col = "red",
  main = "Red line plot") 
</pre></div><div class="section" title="Fitting normal distribution with maximal likelihood estimation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec49"/>Fitting normal distribution with maximal likelihood estimation</h3></div></div></div><p>Closures are useful when we work with an algorithm with some given data. Optimization, for example, is a problem to find a set of parameters that maximizes or minimizes a pre-defined objective function subject to certain constraints and data. In statistics, many parameter estimation problems are, in essence, optimization problems. One good example that demonstrates the use of closures is <span class="strong"><strong>MLE</strong></span> (<span class="strong"><strong>maximum likelihood estimation</strong></span>). When we estimate the parameters of a statistical model with data, we often use the method of maximal likelihood estimation (MLE, see <a class="ulink" href="https://en.wikipedia.org/wiki/Maximum_likelihood">https://en.wikipedia.org/wiki/Maximum_likelihood</a>). The idea behind MLE is simple: the estimated values of parameters should make the observed data the most probable, given the model.</p><p>To perform MLE, we need a function that measures how probable it is to observe a given set of data under a specific model. Then, we apply optimization techniques to find out the values of parameters that maximizes the probability.</p><p>For example, we know that a set of observed data is generated by normal distribution, but the problem is, we don't know the parameters: mean and standard deviation. Then, we can use MLE to estimate them, given the observed data.</p><p>First, we know that the probability density function of a normal distribution with mean <span class="emphasis"><em>Âµ<sub>0</sub></em></span> and standard deviation <span class="emphasis"><em>Ï<sub>0</sub></em></span> is:</p><div class="mediaobject"><img src="graphics/image_09_002.jpg" alt="Fitting normal distribution with maximal likelihood estimation"/></div><p>Therefore, the likelihood function given the observed data <span class="emphasis"><em>x</em></span> is:</p><div class="mediaobject"><img src="graphics/image_09_003.jpg" alt="Fitting normal distribution with maximal likelihood estimation"/></div><p>To make the optimization easier, we will take a natural log and negate on both sides and get the negative log-likelihood function:</p><div class="mediaobject"><img src="graphics/image_09_004.jpg" alt="Fitting normal distribution with maximal likelihood estimation"/></div><p>The negative log-likelihood function has the same monotonicity as the original function. The optimization solution of this function is the same as the original function but can be much easier to solve. That's why we use this function in the estimation.</p><p>The following <code class="literal">nloglik</code> R function returns a closure of the two parameters of normal distribution given the observed data <code class="literal">x</code>:</p><pre class="programlisting">nloglik&lt;- function(x) {
  n &lt;- <span class="strong"><strong>length</strong></span>(x)
  function(mean, sd) {
<span class="strong"><strong>    log</strong></span>(2 * pi) * n / 2 + <span class="strong"><strong>log</strong></span>(sd ^ 2) * n / 2 + <span class="strong"><strong>sum</strong></span>((x - mean) ^ 2) / (2 * sd ^ 2)
  }
} 
</pre><p>In this way, for any given set of observations, we call <code class="literal">nloglike</code> to get a negative log-likelihood function with respect to mean and standard deviation. It tells us how unlikely it is for us to observe the given data <code class="literal">x</code> assuming that the true model takes the values of <code class="literal">mean</code> and <code class="literal">sd</code> we specify.</p><p>For example, we use <code class="literal">rnorm()</code> to generate 10,000 random numbers that are normally distributed with mean <code class="literal">1</code> and standard deviation <code class="literal">2</code>. Therefore, <code class="literal">mean = 1</code> and <code class="literal">sd = 2</code> are the true values of the distribution parameters:</p><pre class="programlisting">data &lt;- rnorm(10000, 1, 2) 
</pre><p>Then, we turn to the <code class="literal">mle()</code> function in the <code class="literal">stats4</code> package. This function implements a number of numeric methods to find the minimum value of a given negative log-likelihood function with certain parameters. It takes a starting point of the numeric search, and a lower bound and a upper bound of the solution:</p><pre class="programlisting">fit &lt;- stats4::mle(nloglik(data),
  start = list(mean = 0, sd = 1), method = "L-BFGS-B",
  lower =c(-5, 0.01), upper = c(5, 10)) 
</pre><p>After some iterations, it finds an MLE solution and returns an S4 object, which includes the related data of the solution. To see how close the estimates are to the true value, we will extract the <code class="literal">coef</code> slot from the object:</p><pre class="programlisting">fit@coef
## mean sd
## 1.007548 1.990121 
</pre><p>It is obvious that the estimates are very close to the true values. Relatively speaking, both estimates have an error lower than 1 percent, as can be verified here:</p><pre class="programlisting">(fit@coef - <span class="strong"><strong>c</strong></span>(1, 2)) / <span class="strong"><strong>c</strong></span>(1, 2)
## mean sd
##  0.007547752 -0.004939595 
</pre><p>The following function is a composition of the histogram of <code class="literal">data</code> and the density functions of the normal distribution with both true parameters (red curve) and estimated parameters (blue curve):</p><pre class="programlisting">hist(data, freq =FALSE, ylim =c(0, 0.25))
curve(dnorm(x, 1, 2), add =TRUE, col =rgb(1, 0, 0, 0.5), lwd =6)
curve(dnorm(x, fit@coef[["mean"]], fit@coef[["sd"]]),
    add =TRUE, col ="blue", lwd =2) 
</pre><p>This produces the following histogram, plus a fitted normal density curve:</p><div class="mediaobject"><img src="graphics/image_09_005.jpg" alt="Fitting normal distribution with maximal likelihood estimation"/></div><p>We can see that the density function produced by the estimated parameters is very close to the true model.</p></div></div><div class="section" title="Using higher-order functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Using higher-order functions</h2></div></div></div><p>In the previous section, we discussed closures, functions defined in parent functions. In this section, we will discuss higher-order functions, that is, functions that accept another function as an argument.</p><p>Before walking into this topic, we need more knowledge of how functions behave when they are passed around either as variables or as function arguments.</p><div class="section" title="Creating aliases for functions"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec50"/>Creating aliases for functions</h3></div></div></div><p>The first question is: if we assign an existing function to another variable, will it affect the enclosing environment of the function? If this is so, then the search paths of symbols that are not locally defined will be different.</p><p>The following code demonstrates why the enclosing environment of a function is not changed when it is assigned to another symbol. We define a simple function <code class="literal">f1</code> that prints the executing environment, the enclosing environment, and the calling environment when it is called. Then, we define <code class="literal">f2</code> that also prints the three environments, but in addition, it assigns the function of <code class="literal">f1</code> to a local variable <code class="literal">p</code> and call <code class="literal">p</code> inside <code class="literal">f2</code>.</p><p>If <code class="literal">p &lt;- f1</code> defines the function locally, the enclosing environment of <code class="literal">p</code> will be the executing environment of <code class="literal">f2</code>. Otherwise, the enclosing environment will remain the global environment in which <code class="literal">f1</code> is defined:</p><pre class="programlisting">f1 &lt;- function() {
  cat("[f1] executing in ")
  print(environment())
  cat("[f1] enclosed by ")
  print(parent.env(environment()))
  cat("[f1] calling from ")
  print(parent.frame())
}
f2 &lt;- function() {
  cat("[f2] executing in ")
  print(environment())
  cat("[f2] enclosed by ")
  print(parent.env(environment()))
  cat("[f2] calling from ")
  print(parent.frame())
  p &lt;- f1
  p()
}
f1()
## [f1] executing in &lt;environment: 0x000000001435d700&gt;
## [f1] enclosed by &lt;environment: R_GlobalEnv&gt;
## [f1] calling from &lt;environment: R_GlobalEnv&gt;
f2()
## [f2] executing in &lt;environment: 0x0000000014eb2200&gt;
## [f2] enclosed by &lt;environment: R_GlobalEnv&gt;
## [f2] calling from &lt;environment: R_GlobalEnv&gt;
## [f1] executing in &lt;environment: 0x0000000014eaedf0&gt;
## [f1] enclosed by &lt;environment: R_GlobalEnv&gt;
## [f1] calling from &lt;environment: 0x0000000014eb2200&gt; 
</pre><p>We called the two functions in turn and found that <code class="literal">p</code> is called from the executing environment of <code class="literal">f2</code>, but the enclosing environment is unchanged. In other words, the search path of <code class="literal">p</code> and <code class="literal">f1</code> are exactly the same. In fact, <code class="literal">p &lt;- f1</code> assigns exactly the same function <code class="literal">f1</code> represents to <code class="literal">p</code>, and then, they both point to the same function.</p></div><div class="section" title="Using functions as variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec51"/>Using functions as variables</h3></div></div></div><p>Functions in R are not as special as they are in other programming languages. Everything is an object. Functions are objects too and can be referred to by variables.</p><p>Suppose we have a function like this:</p><pre class="programlisting">f1 &lt;- function(x, y) {
  if (x &gt; y) {
    x + y
  } else {
    x - y
  }
} 
</pre><p>In the preceding function, two conditional branches lead to different expressions that may result in different values. To achieve the same goal, we can also let the conditional branches result in different functions, store the result in a variable, and, finally, call the function the variable represents to get the result:</p><pre class="programlisting">f2 &lt;- function(x, y) {
  op &lt;- if (x &gt; y) `+` else `-`
<span class="strong"><strong>  op</strong></span>(x, y)
} 
</pre><p>Note that in R, everything we do is done by a function. The most basic operators <code class="literal">+</code> and <code class="literal">-</code> are functions too. They can be assigned to the variable <code class="literal">op</code>, and we can call <code class="literal">op</code> if it is indeed a function.</p></div><div class="section" title="Passing functions as arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec52"/>Passing functions as arguments</h3></div></div></div><p>The previous examples demonstrate that we can easily pass functions around just like everything else, including passing functions in arguments.</p><p>In the following example, we will define two functions called <code class="literal">add</code> and <code class="literal">product</code>, respectively:</p><pre class="programlisting">add &lt;- function(x, y, z) {
  x + y + z
}
product &lt;- function(x, y, z) {
  x * y * z
} 
</pre><p>Then, we will define another function, <code class="literal">combine</code>, that tries to combine <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> in some way specified by the argument <code class="literal">f</code>. Here,<code class="literal">f</code> is assumed to be a function that takes three arguments as we call it. In this way, <code class="literal">combine</code> is more flexible. It is not limited to a particular way of combining the inputs, but allows the user to specify:</p><pre class="programlisting">combine &lt;- function(f, x, y, z) {
<span class="strong"><strong>  f</strong></span>(x, y, z)
} 
</pre><p>We can pass <code class="literal">add</code> and <code class="literal">product</code>, we just defined in turn, to see if it works:</p><pre class="programlisting">
<span class="strong"><strong>combine</strong></span>(add, 3, 4, 5)
## [1] 12
<span class="strong"><strong>combine</strong></span>(product, 3, 4, 5)
## [1] 60 
</pre><p>It is natural that when we call <code class="literal">combine(add, 3, 4, 5)</code>, the function body has <code class="literal">f = add</code> and <code class="literal">f(x, y, z)</code>, which result in <code class="literal">add(x, y, z)</code>. The same logic also applies to calling <code class="literal">combine</code> with <code class="literal">product</code>. Since <code class="literal">combine</code> accepts a function in its first argument, it is indeed a higher-order function.</p><p>Another reason we need higher-order functions is that the code is easier to read and write at a higher level of abstraction. In many cases, using higher-order functions make the code shorter yet more expressive. For example, for-loop is an ordinary flow-control device that iterates along a vector or list.</p><p>Suppose we need to apply a function named <code class="literal">f</code> to each element of vector <code class="literal">x</code>. If the function itself is vectorized, it is better to call <code class="literal">f(x)</code> directly. However, not every function supports vectorized operations, nor does every function need to be vectorized. If we want to do so, a for-loop,like the following one, solves the problem:</p><pre class="programlisting">result&lt;-list()
for (i in seq_along(x)) {
    result[[i]] &lt;-f(x[[i]])
}
result 
</pre><p>In the previous loop, <code class="literal">seq_along(x)</code> produces a sequence from <code class="literal">1</code> to the length of <code class="literal">x</code>, which is equivalent to <code class="literal">1:length(x)</code>. The code looks simple and easy to implement, but if we use it all the time, the drawback becomes significant.</p><p>Suppose the operation in each iteration gets more complicated: it would be hard to read. If you think about it, you will find that the code tells R <span class="emphasis"><em>how</em></span> to finish the task instead of <span class="emphasis"><em>what</em></span> the task is about. When you take a look at very long, sometimes nested loops, you would have a hard time to figure out what it is actually doing.</p><p>Instead, we can apply a function (<code class="literal">f</code>) to each element of a vector or list (<code class="literal">x</code>) by calling <code class="literal">lapply</code>, which we introduced in the previous chapters:</p><pre class="programlisting">lapply(x, f) 
</pre><p>In fact, <code class="literal">lapply</code> is essentially the same as the following code, although it is implemented in C:</p><pre class="programlisting">lapply &lt;- function(x, f, ...) {
  result &lt;- list()
  for (i in seq_along(x)) {
      result[[i]] &lt;-f(x[i], ...)
  }
} 
</pre><p>This function is a higher-order function, because it works at a higher level of abstraction. Although it still uses a for-loop inside, it separates the work into two levels of abstraction so that each level looks simple.</p><p>In fact, <code class="literal">lapply</code> also supports extending <code class="literal">f</code> with additional arguments. For example, <code class="literal">+</code> has two arguments, as shown in the following code:</p><pre class="programlisting">lapply(1:3, `+`, 3)
## [[1]]
## [1] 4
##
## [[2]]
## [1] 5
##
## [[3]]
## [1] 6 
</pre><p>The preceding lines of code are equivalent to:</p><pre class="programlisting">list(1 +3, 2 +3, 3 +3) 
</pre><p>The preceding line of code is also equivalent to the case where we use a closure to produce the <code class="literal">x+3</code> function:</p><pre class="programlisting">lapply(1:3, addn(3))
## [[1]]
## [1] 4
##
## [[2]]
## [1] 5
##
## [[3]]
## [1] 6 
</pre><p>As we mentioned in the previous chapters, <code class="literal">lapply</code> only returns a list. If we want a vector instead, we should use <code class="literal">sapply</code> in the interactive mode:</p><pre class="programlisting">sapply(1:3, addn(3))
## [1] 4 5 6 
</pre><p>Alternatively, we should use <code class="literal">vapply</code> in the programming code with type checking:</p><pre class="programlisting">vapply(1:3, addn(3), numeric(1))
## [1] 4 5 6 
</pre><p>In addition to these functions, R also offers several other apply-family functions, as we mentioned in the previous chapters, as well as <code class="literal">Filter</code>, <code class="literal">Map</code>, <code class="literal">Reduce</code>, <code class="literal">Find</code>, <code class="literal">Position</code>, and <code class="literal">Negate</code>. For more details, refer to <code class="literal">?Filter</code> in the documentation.</p><p>Moreover, the use of higher-order functions not only makes the code easier to read and more expressive, but these functions also separate the implementation of each level of abstraction so that they are independent from each other. It is much easier to improve simpler components than a whole bundle of logic coupled together.</p><p>For example, we can use apply-family functions to perform vector mapping, given a function. If each iteration is independent from the others, we can parallelize the mapping using multiple CPU cores so that more tasks can be done simultaneously. However, if we didn't use higher-order functions at the first place but a for-loop instead, it would take a while to convert it to parallel code.</p><p>For example, let's assume we use a for-loop to get the results. In each iteration, we perform a heavy computing task. Even if we find each iteration independently from the others, it is not always straightforward to convert it to parallel code:</p><pre class="programlisting">result &lt;- list()
for (i in seq_along(x)) {
  # heavy computing task
  result[[i]] &lt;- f(x[[i]])
}
result 
</pre><p>However, if we use the higher-order function <code class="literal">lapply()</code>, things will be much easier:</p><pre class="programlisting">result &lt;- lapply(x, f) 
</pre><p>It would just take one small change to transform the code into a parallel version. Using <code class="literal">parallel::mclapply()</code>, we can apply <code class="literal">f</code> to each element of <code class="literal">x</code> with multiple cores:</p><pre class="programlisting">result &lt;- parallel::mclapply(x, f) 
</pre><p>Unfortunately, <code class="literal">mclapply()</code> does not support Windows. More code is needed to perform parallel apply functions in Windows. We will cover this topic in the chapter on high-performance computing.</p></div></div></div></div>
<div class="section" title="Computing on language"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Computing on language</h1></div></div></div><p>In the previous section, we introduced the functional programming facilities in R. You learned that functions are just another type of object we can pass around. When we create a new function, say <code class="literal">fun</code>, the environment we create will be associated with the function. This environment is called the enclosing environment of the function, which can be accessed via <code class="literal">environment(fun)</code>. Each time we call the function, a new executing environment that contains the unevaluated arguments (promises) will be created to host the execution of the function, which enables lazy evaluation. The parent of the executing environment is the enclosing environment of the function, which enables lexical scoping.</p><p>Functional programming allows us to write code in higher level of abstraction. Metaprogramming goes even further. It allows us to tweak the language itself and make certain language constructs easier to use in a certain scenario. Some popular R packages use metaprogramming in their functions to make things easier. In this section, I will show you the power of metaprogramming as well as its pros and cons, so that you can understand how related packages and functions work.</p><p>Before digging into the knowledge of how things work, we may look at a few built-in functions that use metaprogramming to make things easier.</p><p>Suppose we want to filter the built-in dataset <code class="literal">iris</code> for records with each numeric column being greater than 80 percent of all records.</p><p>The standard method is to subset the rows of the data frame by composing a logical vector:</p><pre class="programlisting">iris[iris$Sepal.Length &gt; quantile(iris$Sepal.Length, 0.8) &amp;
    iris$Sepal.Width &gt; quantile(iris$Sepal.Width, 0.8) &amp;
    iris$Petal.Length &gt; quantile(iris$Petal.Length, 0.8) &amp;
    iris$Petal.Width &gt; quantile(iris$Petal.Width, 0.8), ]
##     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width
## 110     7.2           3.6          6.1           2.5
## 118     7.7           3.8          6.7           2.2
## 132     7.9           3.8          6.4           2.0
## Species
## 110 virginica
## 118 virginica
## 132 virginica 
</pre><p>In the preceding code, each call of <code class="literal">quantile()</code> yields an 80 percent threshold for a column. Although the code works, it is quite redundant, because each time we use a column, we have to begin with <code class="literal">iris$</code>. In total, <code class="literal">iris$</code> appears nine times.</p><p>The built-in function <code class="literal">subset</code> is useful to make things easier:</p><pre class="programlisting">subset(iris,
    Sepal.Length &gt; quantile(Sepal.Length, 0.8) &amp;
    Sepal.Width &gt; quantile(Sepal.Width, 0.8) &amp;
    Petal.Length &gt; quantile(Petal.Length, 0.8) &amp;
    Petal.Width &gt; quantile(Petal.Width, 0.8))
##      Sepal.Length Sepal.Width Petal.Length Petal.Width
## 110      7.2          3.6         6.1          2.5
## 118      7.7          3.8         6.7          2.2
## 132      7.9          3.8         6.4          2.0
## Species
## 110 virginica 
## 118 virginica
## 132 virginica 
</pre><p>The preceding code returns exactly the same results, but with cleaner code. But why does it work while omitting <code class="literal">iris$</code> in the previous example does not work?</p><pre class="programlisting">iris[Sepal.Length &gt; quantile(Sepal.Length, 0.8) &amp;
    Sepal.Width &gt; quantile(Sepal.Width, 0.8) &amp;
    Petal.Length &gt; quantile(Petal.Length, 0.8) &amp;
    Petal.Width &gt; quantile(Petal.Width, 0.8), ]
## Error in `[.data.frame`(iris, Sepal.Length &gt; quantile(Sepal.Length, 0.8) &amp; : object 'Sepal.Length' not found 
</pre><p>The preceding code does not work, because <code class="literal">Sepal.Length</code> and other columns are not defined in the scope (or environment) where we evaluate the subsetting expression. The magic function, <code class="literal">subset</code>, uses metaprogramming techniques to tweak the evaluation environment of its arguments so that <code class="literal">Sepal.Length&gt;quantile(Sepal.Length, 0.8)</code> is evaluated in the environment with the columns of <code class="literal">iris</code>.</p><p>Moreover, <code class="literal">subset</code> not only works with rows, but is also useful in selecting columns. For example, we can also specify the <code class="literal">select</code> argument by directly using the column names as variables instead of using a character vector to select columns:</p><pre class="programlisting">subset(iris,
    Sepal.Length &gt; quantile(Sepal.Length, 0.8) &amp;
    Sepal.Width &gt; quantile(Sepal.Width, 0.8) &amp;
    Petal.Length &gt; quantile(Petal.Length, 0.8) &amp;
    Petal.Width &gt; quantile(Petal.Width, 0.8),
select = c(Sepal.Length, Petal.Length, Species))
##     Sepal.Length Petal.Length  Species
## 110     7.2          6.1      virginica
## 118     7.7          6.7      virginica
## 132     7.9          6.4      virginica 
</pre><p>See, <code class="literal">subset</code> tweaks how its second argument (<code class="literal">subset</code>) and third argument (<code class="literal">select</code>) are evaluated. The result is we can write simpler code with less redundancy.</p><p>In the next few sections, you will learn what happens behind the scene and how it is designed to work.</p><div class="section" title="Capturing and modifying expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Capturing and modifying expressions</h2></div></div></div><p>When we type an expression and hit the <span class="emphasis"><em>Enter</em></span> (or return) key, R will evaluate the expression and show the output. Here is an example:</p><pre class="programlisting">rnorm(5)
## [1] 0.54744813 1.15202065 0.74930997 -0.02514251
## [5]  0.99714852 
</pre><p>It shows the five random numbers generated. The magic of <code class="literal">subset</code> is that it tweaks the environment where the argument is evaluated. This happens in two steps: first, capture the expression and then, interfere the evaluation of the expression.</p><div class="section" title="Capturing expressions as language objects"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec53"/>Capturing expressions as language objects</h3></div></div></div><p>Capturing an expression means preventing the expression from being evaluated, but storing the expression itself as a variable. The function that does this is <code class="literal">quote()</code>; we can call <code class="literal">quote()</code> to capture the expression between the parenthesis:</p><pre class="programlisting">call1 &lt;- quote(rnorm(5))
call1
## rnorm(5) 
</pre><p>The preceding code does not result in five random numbers, but the function call itself. We can use <code class="literal">typeof()</code> and <code class="literal">class()</code> to see the type and class of the resulted object, <code class="literal">call1</code>:</p><pre class="programlisting">typeof(call1)
## [1] "language"
class(call1)
## [1] "call" 
</pre><p>We can see that <code class="literal">call1</code> is essentially a language object and it is a call. We can also write a function name in <code class="literal">quote()</code>:</p><pre class="programlisting">name1 &lt;- quote(rnorm)
name1
## rnorm
typeof(name1)
## [1] "symbol"
class(name1)
## [1] "name" 
</pre><p>In this case, we don't get a call but a symbol (or name) instead.</p><p>In fact, <code class="literal">quote()</code> will return a call if a function call is captured and return a symbol if a variable name is captured. The only requirement is the validity of the code to capture; that is, as long as the code is syntactically correct, <code class="literal">quote()</code> will return the language object that represents the captured expression itself.</p><p>Even if the function does not exist or the variable as yet is undefined, the expression can be captured on its own:</p><pre class="programlisting">quote(pvar)
## pvar
quote(xfun(a = 1:n))
## xfun(a = 1:n) 
</pre><p>Of the preceding language objects, maybe <code class="literal">pvar</code>, <code class="literal">xfun</code>, and <code class="literal">n</code> are all as yet undefined, but we can <code class="literal">quote()</code> them anyway.</p><p>It is important to understand the difference between a variable and a symbol object, and between a function and a call object. A variable is a name of an object, and a symbol object is the name itself. A function is an object that is callable, and a call object is a language object that represents such a function call, which is as yet unevaluated. In this case, <code class="literal">rnorm</code> is a function and it is callable (for example, <code class="literal">rnorm(5)</code> returns five random numbers), but <code class="literal">quote(rnorm)</code> returns a symbol object and <code class="literal">quote(rnorm(5))</code> returns a call object, both of which are only the representations of the language itself.</p><p>We can convert the call object to a list so that we can see its internal structure:</p><pre class="programlisting">as.list(call1)
## [[1]]
## rnorm
##
## [[2]]
## [1] 5 
</pre><p>This shows that the call consists of two components: the symbol of the function and one argument. We can extract objects from a call object:</p><pre class="programlisting">call1[[1]]
## rnorm
typeof(call1[[1]])
## [1] "symbol"
class(call1[[1]])
## [1] "name" 
</pre><p>The first element of <code class="literal">call1</code> is a symbol:</p><pre class="programlisting">call1[[2]]
## [1] 5
typeof(call1[[2]])
## [1] "double"
class(call1[[2]])
## [1] "numeric" 
</pre><p>The second element of <code class="literal">call1</code> is a numeric value. From the previous examples, we know that <code class="literal">quote()</code> captures a variable name as a symbol object and a function call as a call object. Both of them are language objects. Like typical data structures, we can use <code class="literal">is.symbol()</code>/<code class="literal">is.name()</code> and <code class="literal">is.call()</code> to detect whether an object is a symbol or a call, respectively. More generally, we can also use <code class="literal">is.language()</code> to detect both the symbol and the call.</p><p>Another question is, "What if we call <code class="literal">quote()</code> on a literal value? What about a number or a string?" The following code creates a numeric value <code class="literal">num1</code> and a quoted numeric value <code class="literal">num2</code>:</p><pre class="programlisting">num1 &lt;- 100
num2 &lt;- quote(100) 
</pre><p>They have exactly the same representation:</p><pre class="programlisting">num1
## [1] 100
num2
## [1] 100 
</pre><p>In fact, they have exactly the same value:</p><pre class="programlisting">identical(num1, num2) 
## [1] TRUE 
</pre><p>Therefore, <code class="literal">quote()</code> does not transform a literal value (such as a number, logical value, string, and so on) to a language object, but it leaves it as it is. However, an expression that combines several literal values into a vector will still be transformed into a call object. Here is an example:</p><pre class="programlisting">call2 &lt;- quote(c("a", "b")) 
call2 
## c("a", "b") 
</pre><p>It is consistent because <code class="literal">c()</code> is indeed a function that combines values and vectors. Moreover, if you look at the list representation of the call using <code class="literal">as.list()</code>, we can see the structure of the call:</p><pre class="programlisting">as.list(call2) 
## [[1]] 
## c 
##  
## [[2]] 
## [1] "a" 
##  
## [[3]] 
## [1] "b" 
</pre><p>The types of elements in the call can be revealed by <code class="literal">str()</code>:</p><pre class="programlisting">str(as.list(call2)) 
## List of 3 
##  $ : symbol c 
##  $ : chr "a" 
##  $ : chr "b" 
</pre><p>Another noteworthy fact here is that simple arithmetic calculations are captured as calls too because they are surely function calls to arithmetic operators such as <code class="literal">+</code> and <code class="literal">*</code>, which are essentially built-in functions. For example, we can use the <code class="literal">quote()</code> function to the simplest arithmetic calculation, perform <code class="literal">1 + 1</code>:</p><pre class="programlisting">call3 &lt;- quote(1 + 1) 
call3 
## 1 + 1 
</pre><p>The arithmetic representation is preserved, but it is a call and has exactly the same structure as of a call:</p><pre class="programlisting">is.call(call3) 
## [1] TRUE 
str(as.list(call3)) 
## List of 3 
##  $ : symbol + 
##  $ : num 1 
##  $ : num 1 
</pre><p>Given all the preceding knowledge about capturing an expression, we can now capture a nested call; that is, a call that contains more calls:</p><pre class="programlisting">call4 &lt;- quote(sqrt(1 + x ^ 2)) 
call4 
## sqrt(1 + x ^ 2) 
</pre><p>We can use a function in the <code class="literal">pryr</code> package to view the recursive structure of the call. To install the package, run <code class="literal">install.package("pryr")</code>. Once the package is ready, we can call <code class="literal">pryr::call_tree</code> to do that:</p><pre class="programlisting">pryr::call_tree(call4) 
## \- () 
## \- `sqrt 
## \- () 
## \- `+ 
## \-  1 
## \- () 
## \- `^ 
## \- `x 
## \-  2 
</pre><p>For <code class="literal">call4</code>, the recursive structure is printed in a tree structure. The <code class="literal">\- ()</code> operator means a call, then <code class="literal">`var</code> represents a symbol object <code class="literal">var</code>, and others are literal values. In the preceding output, we can see that symbols and calls are captured and literal values are preserved.</p><p>If you are curious about the call tree of an expression, you can always use this function because it precisely reflects the way R processes the expression.</p></div><div class="section" title="Modifying expressions"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec54"/>Modifying expressions</h3></div></div></div><p>When we capture an expression as a call object, the call can be modified as if it were a list. For example, we can change the function to call by replacing the first element of the call with another symbol:</p><pre class="programlisting">call1 
## rnorm(5) 
call1[[1]] &lt;- quote(runif) 
call1 
## runif(5) 
</pre><p>So, <code class="literal">rnorm(5)</code> is changed to <code class="literal">runif(5)</code>.</p><p>We can also add new argument to the call:</p><pre class="programlisting">call1[[3]] &lt;- -1 
names(call1)[[3]] &lt;- "min" 
call1 
## runif(5, min = -1) 
</pre><p>Then, the call now has another parameter: <code class="literal">min = -1</code>.</p></div><div class="section" title="Capturing expressions of function arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec55"/>Capturing expressions of function arguments</h3></div></div></div><p>In the previous examples, you learned how to use <code class="literal">quote()</code> to capture a known expression, but <code class="literal">subset</code> works with arbitrary user-input expressions. Suppose we want to capture the expression of argument <code class="literal">x</code>.</p><p>The first implementation uses <code class="literal">quote()</code>:</p><pre class="programlisting">fun1 &lt;- function(x) { 
  quote(x) 
} 
</pre><p>Let's see if <code class="literal">fun1</code> can capture the input expression when we call the function with <code class="literal">rnorm(5)</code>:</p><pre class="programlisting">fun1(rnorm(5)) 
## x 
</pre><p>Obviously, <code class="literal">quote(x)</code> only captures <code class="literal">x</code> and has nothing to do with the input expression <code class="literal">rnorm(5)</code>. To correctly capture it, we need to use <code class="literal">substitute()</code>. The function captures an expression and substitutes existing symbols with their expressions. The simplest usage of this function is to capture the expression of a function argument:</p><pre class="programlisting">fun2 &lt;- function(x) { 
  substitute(x) 
} 
fun2(rnorm(5)) 
## rnorm(5) 
</pre><p>With this implementation, <code class="literal">fun2</code> returns the input expression rather than <code class="literal">x</code> because <code class="literal">x</code> is replaced with the input expression, in this case, <code class="literal">rnorm(5)</code>.</p><p>The following examples demonstrate the behavior of <code class="literal">substitute</code> when we supply a list of language objects or literal values. In the first example, we substitute each symbol <code class="literal">x</code> in the given expression with <code class="literal">1</code>:</p><pre class="programlisting">substitute(x + y + x ^ 2, list(x = 1)) 
## 1 + y + 1 ^ 2 
</pre><p>In the second example, we substitute each symbol <code class="literal">f</code> that is supposed to be a function name with another quoted function name <code class="literal">sin</code>:</p><pre class="programlisting">substitute(f(x + f(y)), list(f = quote(sin))) 
## sin(x + sin(y)) 
</pre><p>Now, we are able to capture a certain expression with <code class="literal">quote()</code> and user-input expression with <code class="literal">substitute()</code>.</p></div><div class="section" title="Constructing function calls"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec56"/>Constructing function calls</h3></div></div></div><p>In addition to capturing expressions, we can directly build language objects with built-in functions. For example, <code class="literal">call1</code> is a captured call using <code class="literal">quote()</code>:</p><pre class="programlisting">call1 &lt;- quote(rnorm(5, mean = 3)) 
call1 
## rnorm(5, mean = 3) 
</pre><p>We can use <code class="literal">call()</code> to create a call of the same function with the same arguments:</p><pre class="programlisting">call2 &lt;- call("rnorm", 5,  mean = 3) 
call2 
## rnorm(5, mean = 3) 
</pre><p>Alternatively, we can convert a list of call components to a call using <code class="literal">as.call()</code>:</p><pre class="programlisting">call3 &lt;- as.call(list(quote(rnorm), 5, mean = 3)) 
call3 
## rnorm(5, mean = 3) 
</pre><p>The three methods create identical calls; that is, they call a function of the same name and with the same arguments, which can be confirmed by calling <code class="literal">identical()</code> with the three resulted call objects:</p><pre class="programlisting">identical(call1, call2) 
## [1] TRUE 
identical(call2, call3) 
## [1] TRUE 
</pre></div></div><div class="section" title="Evaluating expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Evaluating expressions</h2></div></div></div><p>After capturing an expression, the next step is evaluating it. This can be done with <code class="literal">eval()</code>.</p><p>For example, if we type <code class="literal">sin(1)</code> and enter, the value will appear immediately:</p><pre class="programlisting">sin(1) 
## [1] 0.841471 
</pre><p>To control the evaluation of <code class="literal">sin(1)</code>, We can use <code class="literal">quote()</code> to capture the expression and then <code class="literal">eval()</code> to evaluate the function call:</p><pre class="programlisting">call1 &lt;- quote(sin(1)) 
call1 
## sin(1) 
eval(call1) 
## [1] 0.841471 
</pre><p>We can capture any expression that is syntactically correct, which allows us to <code class="literal">quote()</code> an expression that uses undefined variables:</p><pre class="programlisting">call2 &lt;- quote(sin(x)) 
call2 
## sin(x) 
</pre><p>In <code class="literal">call2</code>, <code class="literal">sin(x)</code> uses an undefined variable <code class="literal">x</code>. If we directly evaluate it, an error occurs:</p><pre class="programlisting">eval(call2) 
## Error in eval(expr, envir, enclos): object 'x' not found 
</pre><p>This error is similar to what happens when we directly run <code class="literal">sin(x)</code> without <code class="literal">x</code> being defined:</p><pre class="programlisting">sin(x) 
## Error in eval(expr, envir, enclos): object 'x' not found 
</pre><p>The difference between directly running in console and using <code class="literal">eval()</code> is that <code class="literal">eval()</code> allows us to provide a list to evaluate the given expression. In this case, we don't have to create a variable <code class="literal">x</code> but supply a temporary list that contains <code class="literal">x</code> so that the expression will look up symbols in the list:</p><pre class="programlisting">eval(call2, list(x = 1)) 
## [1] 0.841471 
</pre><p>Alternatively, <code class="literal">eval()</code> also accepts an environment for symbol lookup. Here, we will create a new environment <code class="literal">e1</code> in which we create a variable <code class="literal">x</code> with value <code class="literal">1</code>, and then we use <code class="literal">eval()</code> in the call in <code class="literal">e1</code>:</p><pre class="programlisting">e1 &lt;- new.env() 
e1$x &lt;- 1 
eval(call2, e1) 
## [1] 0.841471 
</pre><p>The same logic also applies when the captured expression has more undefined variables:</p><pre class="programlisting">call3 &lt;- quote(x ^ 2 + y ^ 2) 
call3 
## x ^ 2 + y ^ 2 
</pre><p>Directly evaluating the expression without a complete specification of the undefined symbols will result in an error:</p><pre class="programlisting">eval(call3) 
## Error in eval(expr, envir, enclos): object 'x' not found 
</pre><p>So does a partial specification, as follows:</p><pre class="programlisting">eval(call3, list(x = 2)) 
## Error in eval(expr, envir, enclos): object 'y' not found 
</pre><p>Only when we fully specify the values of the symbols in the expression can the evaluation result in a value:</p><pre class="programlisting">eval(call3, list(x = 2, y = 3)) 
## [1] 13 
</pre><p>The evaluation model of <code class="literal">eval(expr, envir, enclos)</code> is the same as calling a function. The function body is <code class="literal">expr</code>, and the executing environment is <code class="literal">envir</code>. If <code class="literal">envir</code> is given as a list, then the enclosing environment is <code class="literal">enclos</code>, or otherwise the enclosing environment is the parent environment of <code class="literal">envir</code>.</p><p>This model implies the exact behavior of symbol lookup. Suppose we use an environment instead to evaluate <code class="literal">call3</code>. Since <code class="literal">e1</code> only contains variable <code class="literal">x</code>, the evaluation does not proceed:</p><pre class="programlisting">e1 &lt;- new.env() 
e1$x &lt;- 2 
eval(call3, e1) 
## Error in eval(expr, envir, enclos): object 'y' not found 
</pre><p>Then, we create a new environment whose parent is <code class="literal">e1</code> and contains variable <code class="literal">y</code>. If we now evaluate <code class="literal">call3</code> in <code class="literal">e2</code>, both <code class="literal">x</code> and <code class="literal">y</code> are found and the evaluation works:</p><pre class="programlisting">e2 &lt;- new.env(parent = e1) 
e2$y &lt;- 3 
eval(call3, e2) 
## [1] 13 
</pre><p>In the preceding code, <code class="literal">eval(call3, e2)</code> tries to evaluate <code class="literal">call3</code>, with <code class="literal">e2</code> being the executing environment. Now, we can go through the evaluating process to get a better understanding of how it works. The evaluation process is reflected by travelling recursively along the call tree produced by <code class="literal">pryr::call_tree()</code>:</p><pre class="programlisting">pryr::call_tree(call3) 
## \- () 
## \- `+ 
## \- () 
## \- `^ 
## \- `x 
## \-  2 
## \- () 
## \- `^ 
## \- `y 
## \-  2 
</pre><p>First, it tries to find a function called <code class="literal">+</code>. It goes through <code class="literal">e2</code> and <code class="literal">e1</code>, and does not find <code class="literal">+</code> until it reaches the base environment (<code class="literal">baseenv()</code>), where all the basic arithmetic operators are defined. Then, <code class="literal">+</code> needs to evaluate its arguments, so it looks for another function called <code class="literal">^</code> and finds it by going through the same flow. Then, again <code class="literal">^</code> needs to evaluate its arguments, so it looks for symbol <code class="literal">x</code> in <code class="literal">e2</code>. Environment <code class="literal">e2</code> does not contain variable <code class="literal">x</code>, so it continues searching in <code class="literal">e2</code> class's parent environment, <code class="literal">e1</code>, and finds <code class="literal">x</code> there. Finally, it looks for symbol <code class="literal">y</code> in <code class="literal">e2</code> and finds it immediately. When the arguments a call needs are ready, the call can be evaluated to a result.</p><p>An alternative approach is to supply a list to <code class="literal">envir</code> and an enclosing environment:</p><pre class="programlisting">e3 &lt;- new.env() 
e3$y &lt;- 3 
eval(call3, list(x = 2), e3) 
## [1] 13 
</pre><p>The evaluating process begins with an executing environment generated from the list whose parent environment is <code class="literal">e3</code>, as specified. Then, the process is exactly the same as the previous example.</p><p>Since everything we do is essentially calling functions, <code class="literal">quote()</code> and <code class="literal">substitute()</code> can capture everything, including assignment and other operations that do not look like calling functions. In fact, for example, <code class="literal">x &lt;- 1</code> is essentially calling <code class="literal">&lt;-</code> with <code class="literal">(x, 1)</code>, and <code class="literal">length(x) &lt;- 10</code> is essentially calling <code class="literal">length&lt;-</code> with <code class="literal">(x, 10)</code>.</p><p>To demonstrate the point, we may construct another example in which we create a new variable.</p><p>In the following example, we supply a list to generate the executing environment and <code class="literal">e3</code> as the enclosing environment:</p><pre class="programlisting">eval(quote(z &lt;- x + y + 1), list(x = 1), e3) 
e3$z 
## NULL 
</pre><p>As a result, <code class="literal">z</code> is not created in <code class="literal">e3</code> but in a temporary executing environment created from the list. If we, instead, specify <code class="literal">e3</code> as the executing environment, the variable will be created in it:</p><pre class="programlisting">eval(quote(z &lt;- y + 1), e3) 
e3$z 
## [1] 4 
</pre><p>In conclusion, <code class="literal">eval()</code> works in a way extremely close to the behavior of function calling, but <code class="literal">eval()</code> allows us to customize the evaluation of an expression by tweaking its executing and enclosing environment, which allows us to do good things such as <code class="literal">subset</code> as well as bad things such as follows:</p><pre class="programlisting">eval(quote(1 + 1), list(`+` = `-`)) 
## [1] 0 
</pre></div><div class="section" title="Understanding non-standard evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Understanding non-standard evaluation</h2></div></div></div><p>In the previous sections, you learned how to use <code class="literal">quote()</code> and <code class="literal">substitute()</code> to capture an expression as a language object, and you learned how to use <code class="literal">eval()</code> to evaluate it within a given list or environment. These functions constitute the facility of metaprogramming in R and allow us to tweak standard evaluation. The main application of metaprogramming is to perform non-standard evaluation to make certain usage easier. In the following sections, we will discuss a few examples to gain a better understanding of how it works.</p><div class="section" title="Implementing quick subsetting using non-standard evaluation"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec57"/>Implementing quick subsetting using non-standard evaluation</h3></div></div></div><p>Often, we need to take out a certain subset from a vector. The range of the subset may be the first few elements, last few elements, or some elements in the middle.</p><p>The first two cases can be easily handled by <code class="literal">head(x, n)</code> and <code class="literal">tail(x, n)</code>. The third case requires an input of the length of the vector.</p><p>For example, suppose we have an integer vector and want to take out elements from the third to the fifth last:</p><pre class="programlisting">x &lt;- 1:10 
x[3:(length(x) -5)] 
## [1] 3 4 5 
</pre><p>The preceding subsetting expression uses <code class="literal">x</code> twice and looks a bit redundant. We can define a quick subsetting function that uses metaprogramming facilities to provide a special symbol to refer to the length of the input vector The following function, <code class="literal">qs</code>, is a simple implementation of this idea that allows us to use dot (<code class="literal">.</code>) to represent the length of the input vector <code class="literal">x</code>:</p><pre class="programlisting">qs &lt;- function(x, range) { 
 range &lt;- substitute(range) 
  selector &lt;- eval(range, list(. =length(x))) 
  x[selector] 
} 
</pre><p>Using this function, we can use <code class="literal">3:(. - 5)</code> to represent the same range as the motivating example:</p><pre class="programlisting">qs(x, 3:(. -5)) 
## [1] 3 4 5 
</pre><p>We can also easily pick out a number by counting from the last element:</p><pre class="programlisting">qs(x, . -1) 
## [1] 9 
</pre><p>Based on <code class="literal">qs()</code>, the following function is designed to trim both margins of <code class="literal">n</code> elements from the input vector <code class="literal">x</code>; that is, it returns a vector without the first <code class="literal">n</code> and last <code class="literal">n</code> elements of <code class="literal">x</code>:</p><pre class="programlisting">trim_margin &lt;- function(x, n) { 
  qs(x, (n + 1):(. -n -1)) 
} 
</pre><p>The function looks alright, but when we call it with an ordinary input, an error occurs:</p><pre class="programlisting">trim_margin(x, 3) 
## Error in eval(expr, envir, enclos): object 'n' not found 
</pre><p>How come it couldn't find <code class="literal">n</code>? To understand why this happens, we need to analyze the path of symbol lookup when <code class="literal">trim_margin</code> is called. In the next section, we will go into this in detail and introduce the concept of dynamic scoping to resolve the problem.</p></div><div class="section" title="Understanding dynamic scoping"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec58"/>Understanding dynamic scoping</h3></div></div></div><p>Before trying to tackle the problem, let's use what you have learned to analyze what went wrong. When we call <code class="literal">trim_margin(x, 3)</code>, we call <code class="literal">qs(x, (n + 1):(. - n - 1))</code> in a fresh executing environment with <code class="literal">x</code>, and <code class="literal">n</code>. <code class="literal">qs()</code> is special because it uses non-standard evaluation. More specifically, it first captures <code class="literal">range</code> as a language object and then evaluates it with a list of additional symbols to provide, which, at the moment, only contains <code class="literal">. = length(x)</code>.</p><p>The error just happens at <code class="literal">eval(range, list(. = length(x)))</code>. The number of margin elements to trim, <code class="literal">n</code>, cannot be found here. There must be something wrong with the enclosing environment of evaluation. Now, we will take a closer look at the default value of the <code class="literal">enclos</code> argument of <code class="literal">eval()</code>:</p><pre class="programlisting">eval 
## function (expr, envir = parent.frame(), enclos = if (is.list(envir) ||  
## is.pairlist(envir)) parent.frame() else baseenv())  
## .Internal(eval(expr, envir, enclos)) 
## &lt;bytecode: 0x00000000106722c0&gt; 
## &lt;environment: namespace:base&gt; 
</pre><p>The definition of <code class="literal">eval()</code> says that if we supply a list to <code class="literal">envir</code>, which is exactly what we have done, <code class="literal">enclos</code> will take <code class="literal">parent.frame()</code> by default, which is the calling environment of <code class="literal">eval()</code>; that is, the executing environment when we call <code class="literal">qs()</code>. Certainly, there is no <code class="literal">n</code> in any executing environment of <code class="literal">qs</code>.</p><p>Here, we exposed a shortcoming of using <code class="literal">substitute()</code> in <code class="literal">trim_margin()</code> because the expression is only fully meaningful in the correct context, that is, the executing environment of <code class="literal">trim_margin()</code>, which is also the calling environment of <code class="literal">qs()</code>. Unfortunately, <code class="literal">substitute()</code> only captures the expression; it does not capture the environment in which the expression is meaningful. Therefore, we have to do it ourselves.</p><p>Now, we know where the problem comes from. The solution is simple: always use the correct enclosing environment in which the captured expression is defined. In this case, we specify <code class="literal">enclos = parent.frame()</code> so that <code class="literal">eval()</code> looks for all symbols other than <code class="literal">.</code> in the calling environment of <code class="literal">qs()</code>, that is, the executing environment of <code class="literal">trim_margin()</code> where <code class="literal">n</code> is supplied.</p><p>The following lines of code are the fixed version of <code class="literal">qs()</code>:</p><pre class="programlisting">qs &lt;- function(x, range) { 
 range &lt;- substitute(range) 
  selector &lt;- eval(range, list(. =length(x)), parent.frame()) 
  x[selector] 
} 
</pre><p>We can test the function with the same code that went wrong previously:</p><pre class="programlisting">trim_margin(x, 3) 
## [1] 4 5 6 
</pre><p>Now, the function works in the correct manner. In fact, this mechanism is the so-called <span class="strong"><strong>dynamic scoping</strong></span>. Recall what you learned in the previous chapter. Each time a function is called, an executing environment is created. If a symbol cannot be found in the executing environment, it will search the enclosing environment.</p><p>With lexical scoping used in standard evaluation, the enclosing environment of a function is determined when the function is defined and so is the environment where it is defined.</p><p>However, with dynamic scoping used in non-standard evaluation, by contrast, the enclosing environment should be the calling environment in which the captured expression is defined so that symbols can be found either in the customized executing environment or in the enclosing environment, along with its parents.</p><p>In conclusion, when a function uses non-standard evaluation, it is important to ensure that dynamic scoping is correctly implemented.</p></div><div class="section" title="Using formulas to capture expression and environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec59"/>Using formulas to capture expression and environment</h3></div></div></div><p>To correctly implement dynamic scoping, we use <code class="literal">parent.frame()</code> to track the expression captured by <code class="literal">substitute()</code>. An easier way is to use a formula to capture the expression and environment at the same time.</p><p>In the chapter of working the data, we saw that a formula is often used to represent the relationship between variables. Most model functions (such as <code class="literal">lm()</code>) accept a formula to specify the relationship between a response variable and explanatory variables.</p><p>In fact, a formula object is much simpler than that. It automatically captures the expressions beside <code class="literal">~</code> and the environment where it is created. For example, we can directly create a formula and store it in a variable:</p><pre class="programlisting">formula1 &lt;- z ~ x ^ 2 + y ^ 2 
</pre><p>We can see that the formula is essentially a language object with the <code class="literal">formula</code> class:</p><pre class="programlisting">typeof(formula1) 
## [1] "language" 
class(formula1) 
## [1] "formula" 
</pre><p>If we convert the formula to a list, we can have a closer look at its structure:</p><pre class="programlisting">str(as.list(formula1)) 
## List of 3 
##  $ : symbol ~ 
##  $ : symbol z 
##  $ : language x^2 + y^2 
##  - attr(*, "class")= chr "formula" 
##  - attr(*, ".Environment") =&lt; environment: R_GlobalEnv&gt; 
</pre><p>We can see that <code class="literal">formula1</code> captured not only the expressions as language objects on both sides of <code class="literal">~</code>, but also the environment where it was created. In fact, a formula is merely a call of function <code class="literal">~</code> with the arguments and calling environment captured. If both sides of <code class="literal">~</code> are specified, the length of the call is <code class="literal">3</code>:</p><pre class="programlisting">is.call(formula1) 
## [1] TRUE 
length(formula1) 
## [1] 3 
</pre><p>To access the language objects it captured, we can extract the second and the third elements:</p><pre class="programlisting">formula1[[2]] 
## z 
formula1[[3]] 
## x^2 + y^2 
</pre><p>To access the environment where it was created, we can call <code class="literal">environment()</code>:</p><pre class="programlisting">environment(formula1) 
## &lt;environment: R_GlobalEnv&gt; 
</pre><p>A formula can also be right-sided, that is, only the right side of <code class="literal">~</code> is specified. Here is an example:</p><pre class="programlisting">formula2 &lt;- ~x + y 
str(as.list(formula2)) 
## List of 2 
##  $ : symbol ~ 
##  $ : language x + y 
##  - attr(*, "class")= chr "formula" 
##  - attr(*, ".Environment")=&lt;environment: R_GlobalEnv&gt; 
</pre><p>In this case, only one argument of <code class="literal">~</code> is supplied and captured so that we have a call of two language objects and we can access the expression it captured by extracting its second element:</p><pre class="programlisting">length(formula2) 
## [1] 2 
formula2[[2]] 
## x + y 
</pre><p>With the knowledge of how the formula works, we can implement another version of <code class="literal">qs()</code> and <code class="literal">trim_margin()</code> using the formula.</p><p>The following function, <code class="literal">qs2</code>, behaves consistently with <code class="literal">qs</code> when <code class="literal">range</code> is a formula, or otherwise, it directly uses <code class="literal">range</code> to subset <code class="literal">x</code>:</p><pre class="programlisting">qs2 &lt;- function(x, range) { 
 selector &lt;- if (inherits(range, "formula")) { 
eval(range[[2]], list(. = length(x)), environment(range)) 
  } else range 
  x[selector] 
} 
</pre><p>Note that we use <code class="literal">inherits(range, "formula")</code> to check whether <code class="literal">range</code> is a formula and use <code class="literal">environment(range)</code> to implement dynamic scoping. Then, we can use a right-sided formula to activate non-standard evaluation:</p><pre class="programlisting">qs2(1:10, ~3:(. -2)) 
## [1] 3 4 5 6 7 8 
</pre><p>Otherwise, we can use standard evaluation:</p><pre class="programlisting">qs2(1:10, 3) 
## [1] 3 
</pre><p>Now, we can re-implement <code class="literal">trim_margin</code> with <code class="literal">qs2</code> using a formula:</p><pre class="programlisting">trim_margin2 &lt;- function(x, n) { 
  qs2(x, ~ (n + 1):(. -n -1)) 
} 
</pre><p>As can be verified, dynamic scoping works correctly because the formula used in <code class="literal">trim_margin2</code> automatically captures the executing environment, which is also the environment where the formula and <code class="literal">n</code> are defined:</p><pre class="programlisting">trim_margin2(x, 3) 
## [1] 4 5 6 
</pre></div><div class="section" title="Implementing subset with metaprogramming"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec60"/>Implementing subset with metaprogramming</h3></div></div></div><p>With the knowledge of language objects, evaluation functions, and dynamic scoping, now we have the capability to implement a version of <code class="literal">subset</code>.</p><p>The underlying idea of the implementation is simple:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Capture the row subsetting expression and evaluate it within the data frame which is, in essence, a list</li><li class="listitem" style="list-style-type: disc">Capture the column-selecting expression and evaluate it in a named list of integer indices</li><li class="listitem" style="list-style-type: disc">Use the resulting row selector (logical vector) and column selector (integer vector) to subset the data frame</li></ul></div><p>Here is an implementation of the preceding logic:</p><pre class="programlisting">subset2 &lt;- function(x, subset = TRUE, select = TRUE) { 
  enclos &lt;- parent.frame() 
  subset &lt;- substitute(subset) 
  select &lt;- substitute(select) 
  row_selector &lt;- eval(subset, x, enclos) 
  col_envir &lt;- as.list(seq_along(x)) 
  names(col_envir) &lt;- colnames(x) 
  col_selector &lt;- eval(select, col_envir, enclos) 
  x[row_selector, col_selector] 
} 
</pre><p>The feature of row subsetting is easier to implement than the column selecting part. To perform row subsetting, we only need to capture <code class="literal">subset</code> and evaluate it within the data frame.</p><p>The column subsetting is trickier here. We will create a list of integer indices for the columns and give them the corresponding names. For example, a data frame with three columns (say, <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>) needs a list of indices such as <code class="literal">list(a = 1, b = 2, c = 3)</code>, which allows us to select rows in the form of <code class="literal">select = c(x, y)</code> because <code class="literal">c(x, y)</code> is evaluated within the list.</p><p>Now, the behavior of <code class="literal">subset2</code> is very close to the built-in function <code class="literal">subset</code>:</p><pre class="programlisting">subset2(mtcars, mpg &gt;= quantile(mpg, 0.9), c(mpg, cyl, qsec)) 
##                 mpg  cyl  qsec 
## Fiat 128       32.4   4  19.47 
## Honda Civic    30.4   4  18.52 
## Toyota Corolla 33.9   4  19.90 
## Lotus Europa   30.4   4  16.90 
</pre><p>Both implementations allow us to use <code class="literal">a:b</code> to select all columns between <code class="literal">a</code> and <code class="literal">b</code>, including both sides:</p><pre class="programlisting">subset2(mtcars, mpg &gt;= quantile(mpg, 0.9), mpg:drat) 
##                 mpg   cyl disp  hp  drat 
## Fiat 128       32.4   4   78.7  66  4.08 
## Honda Civic    30.4   4   75.7  52  4.93 
## Toyota Corolla 33.9   4   71.1  65  4.22 
## Lotus Europa   30.4   4   95.1  113 3.77 
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, you learned about the idea and usage of functional programming, including closures and higher order functions. We went further by digging into the metaprogramming facilities, including language objects, evaluation functions, formula, and the implementation of dynamic scoping to ensure user-input expressions are correctly handled when we customize the evaluation behavior. Since a number of popular packages use metaprogramming and non-standard evaluation to make interactive analysis easier, it is important to understand how it works so that we can be more confident to predict and debug the code.</p><p>In the next chapter, we will walk into another infrastructure of R: the object-oriented programming systems. You will learn the basic idea of object-oriented programming, how this idea is implemented in R, and how it can be useful. More specifically, we will begin with the looser S3 system, cover the stricter system S4 which offers a richer set of features, and introduce the reference class and newly implemented R5 system.</p></div></body></html>