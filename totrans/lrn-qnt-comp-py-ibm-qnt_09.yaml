- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simulating Quantum Systems and Noise Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Qiskit** is a provider of high-performance backends that can be used to execute
    quantum circuits. The various backend simulators available can be used in unique
    ways where each can provide different information pertaining to your circuit.
    Qiskit also provides a variety of tools that can be leveraged to construct noise
    models to simulate various errors that occur on real quantum devices. These tools
    are very helpful should you need to compare the difference between your results
    from an ideal simulator and that which replicates the effects of noise from a
    quantum device.'
  prefs: []
  type: TYPE_NORMAL
- en: Both the simulators and tools such as the **noise model** will help you understand
    the reasons for some of the effects on your results, as well as provide insights
    should you later want to mitigate those errors yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating noise models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own noise model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing quantum circuits with custom noise models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will review the Qiskit simulators and understand the differences
    between each of them and what unique functionality each one provides. We will
    also delve into the Qiskit noise models that we can generate based on the specified
    backend devices to allow us to simulate noise on our ideal Qiskit simulators.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will be able to reproduce similar noise effects
    on the simulator. This will allow you to observe how the noise affects our results,
    which would allow us to simulate a real quantum device. Finally, we will cover
    how you can create your own noise models and apply them to your circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, it is expected that you are familiar with the basics of quantum
    circuits described in previous chapters, such as creating and executing quantum
    circuits, obtaining backend properties and configurations, and customizing and
    visualizing circuit diagrams, and you should have knowledge of qubit logic gate
    operators and states. Also, some familiarity with noise effects such as decoherence
    time would be ideal; however, we will cover some of the basics in this chapter
    as a refresher. You will need to install the latest version of **qiskit-aer**
    to run the notebooks in this chapter; details can be found in the Qiskit documentation:
    [https://qiskit.github.io/qiskit-aer/getting_started.html](https://qiskit.github.io/qiskit-aer/getting_started.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between simulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about the various simulator backends that are
    included in Qiskit Aer, including the differences between them and their distinct
    features. Note that you will need to install **qiskit-aer** separately as it is
    not part of the base Qiskit install.
  prefs: []
  type: TYPE_NORMAL
- en: These features include generating noise models and configuring the simulator
    backends that allow you to take advantage of modifying their behavior and characteristics
    to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following simulators and their key features:'
  prefs: []
  type: TYPE_NORMAL
- en: The Aer simulator, which executes a quantum circuit with multiple shots to simulate
    a noisy backend quantum system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Statevector simulator, which provides the state vector of the quantum circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Unitary simulator, which provides the unitary matrix of the quantum circuit
    being executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s move on and look at the quantum systems, herein referred to as simply
    backends.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing all available backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have read the previous chapters of this book, then you are aware of some
    of the simulators we have used. Let’s start off by displaying every simulator
    available from the various sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new **notebook** on IQP and run the autogenerated cell to
    ensure you have loaded some base classes and methods and loaded your account information
    so we can access IQP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by importing some useful classes and functions including, those
    in the helper file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll display all the available simulators in the Qiskit Aer library
    by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display a list of all the available simulators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following code will list out the simulators that are part of the `Qiskit-Aer`
    library. These are also available as Python built-in simulators, should you not
    want to install Aer and just use Qiskit. For simplicity and performance considerations,
    we will be using the Qiskit simulators throughout this book. However, you can
    certainly interchange the Aer simulators with those actual quantum systems listed
    in `service` as needed. But since we want to conserve usage time, let’s stick
    with the simulator for these basic circuits and learning concepts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, we can list all the quantum systems available from the Qiskit
    Runtime Service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will not only list the simulator but also list the real quantum devices
    available to you based on your account. Those listed will vary based on available
    devices and upgrades since this writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As this chapter is focused on simulators, we will learn about the local simulators
    that are installed from the Qiskit library going forward. We’ll start with the
    Aer simulators, which we can use to execute small circuits.
  prefs: []
  type: TYPE_NORMAL
- en: Running circuits on the Aer simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Aer simulator** is not only used to execute quantum circuits but is also
    very versatile because of its ability to apply various simulation methods and
    configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few of the available simulation methods are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`statevector`: This is a statevector simulation within the Aer library that
    allows ideal circuit measurements at the end of the quantum circuit. In addition,
    each shot that executes the circuit can sample random noise from noise models
    to provide noisy simulations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`density_matrix`: This method provides a density matrix simulation that like
    the statevector, samples the quantum circuits with measurements given at the end
    of each circuit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix_product_state`: This is a tensor-network statevector simulator that
    leverages a Matrix Product State as the representation of the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`automatic`: If no method is set, then this method will select one automatically
    based on the number of qubits, the quantum circuit, and the noise model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many backend options available; below is a subset of the available
    `backend_options`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`device`: This sets the simulation device where `CPU` is set by default. However,
    the `statevector`, `unitary`, and `density_matrix` simulators can also run on
    systems equipped with an Nvidia **Graphical Processing Unit** (**GPU**). To configure
    the simulator to a GPU, simply set the options parameter, `device=''GPU''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision`: This sets the floating point to either single or double precision;
    the default is `double`. Setting the precision to `single` will halve the required
    memory of the backend, which could provide some performance improvement on certain
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zero_threshold`: This truncates small values to 0 and will truncate very small
    values. The default truncation value is set to 1e-10, but this can be adjusted
    to suit the needs of the developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validation_threshold`: This threshold is used to verify if the initial statevector
    of the quantum circuit is valid, with the default value set to 1x10^(-8).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_parallel_threads`: Setting this parameter to (the default value) `0` enables
    the simulator to run on all available cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_parallel_experiments`: The maximum number of **qobj** (**QASM object**),
    which rep­resents a single payload of a Qiskit provider to run circuits in parallel.
    The max value cannot exceed the `max_parallel_threads` value. If the max is set
    to `0`, it will be set to the `max_parallel_threads` value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_parallel_threads`: This sets the maximum number of CPU cores for parallelization.
    The default value is set to `0`, which means it will set it to the maximum number
    of CPU cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_memory_mb`: Setting this parameter to `0` enables the simulators to maximize
    the size of system memory to store a state vector; the default value is set to
    `0`. If more memory is needed, an error will be thrown. As a reference, a state
    vector of n-qubits uses 2^n complex values of approximately 16 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have knowledge of the simulation methods and backend options,
    we’ll create a simple circuit and execute it using Aer’s `QasmSimulator` class.
    For this example, we will create the same circuit example we have been using so
    far, consisting of Hadamard and CX gates, which places the quantum circuit in
    a superposition and entangles both qubits together:'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are creating a 2-qubit and 2-bit circuit; when using the `measure_all()`
    function, we will need to set the `add_bits` parameter to `False` so that it does
    not add the classical bits since we have already added them in the `QuantumCircuit`
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the Aer simulator using the `get_backend()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the results from executing the quantum circuit on the Aer
    simulator, with the method set to a state vector, obtaining the result counts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this runs the same results as if you ran `aer_simulator` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both forms execute the circuit in the same manner, with varying values in the
    results, of course. Here, you can see the results, which both ran a total, 1024
    shots, as this is set by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ll continue by extending the backend options to include other parameters
    that we might find useful, such as shots and memory, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters to the backend options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We may already be familiar with the `shots` parameter, which specifies how many
    times to execute the circuit on the backend. However, as illustrated in the previous
    example, the counts returned are the total values of all the shots, but not in
    the order in which each result was returned. There may be situations when you
    would like to examine the results of each shot in chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine the measured results that are stored in the individual memory slots,
    you will need to set the `memory` parameter in the backend options. Let’s rerun
    the previous circuit; however, this time we will set the `memory` flag to `True`
    and display the results. We’ll run just 10 shots this time to avoid a very large
    output string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the 10 memory slot entry results from the execution of the
    circuit. Notice that the results are varying combinations of `00` and `11`, as
    expected for the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Having the memory feature built into the Aer simulator gives you the ability
    to visualize each result of your circuit count. The next section will illustrate
    how to initialize and set up all, or just a subset, of the qubits.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the qubits on a circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned early on, each qubit is initialized to the ground state, or the
    ![](img/B18420_05_004.png) state. However, there may be times when we would like
    to set a different initial state. Luckily for us, the Aer simulator allows us
    to initialize the state of the circuit to some other state, ![](img/B18420_09_002.png)
    , in lieu of all ![](img/B18420_05_004.png)states.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will follow the next steps to initialize the qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we created a circuit that contained a Hadamard and
    Control-Not gate to obtain the entangled state results of ![](img/B18420_09_004.png)
    or ![](img/B18420_09_005.png). In this example, we will initialize our circuit
    so that the results are the same without needing to add any gates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B18420_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Initialized qubits to an initial state other than the zero state'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the qubits are collectively initialized into the state of ![](img/B18420_09_006.png).
    This circuit now has an initialized state that can be applied to any circuit should
    you wish a circuit to begin in a state other than the ground/zero state. Initializing
    a state can be needed when using a variational quantum algorithm that needs to
    be updated each time it is run to optimize its results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute this circuit and observe each result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This prints out the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe from the results, we get only the two initialized state results
    of either ![](img/B18420_09_004.png) or ![](img/B18420_09_005.png), as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you don’t have to initialize all qubits in a circuit; you can also specify
    a group of qubits to initialize, as illustrated in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following circuit, which initializes the state of the `q_1`
    to `q_3` qubits, while all the other qubits that are initialized remain in the
    ground/zero state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, schematic  Description automatically generated](img/B18420_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Initialization of the last three qubits'
  prefs: []
  type: TYPE_NORMAL
- en: Here, our 3-qubit initialized state is set to ![](img/B18420_09_009.png) However,
    since we are executing a 4-qubit circuit, and we have initialized the last 3 qubits,
    our results should include the fourth qubit (q[0]), which would append a 0 to
    the least significant bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the experiment and see whether the initial state of the partial qubits
    is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, our results are as follows (note that due to the randomness of
    the circuit, actual results could vary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also get the following output graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Results of initialized quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the results are exactly as we expected them to be. Notice that
    the least significant bit (the bit on the far right) is always set to 0 as it
    was not one of the initialized qubits. The other thing to take note of is that
    the other bits are exactly as we expected, ![](img/B18420_09_010.png), where the
    bold indicates the initialized bits, and if you combine them all together, they
    will provide the results displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have initialized a circuit, we can apply any gate as needed. The
    only difference is that the gates applied to the circuit after initialization
    will then be applied to the initialized state of each qubit, rather than the default
    initialized state ![](img/B18420_05_004.png). Let’s test this out by adding a
    NOT (X) gate to all the qubits. This should result in all the values being flipped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, schematic  Description automatically generated](img/B18420_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Initialized quantum circuit with X gates applied to all qubits
    before measuring'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the initialized qubits are as before, only after the X gates on all qubits
    that we have added just before measuring. This should result in all bits flipping
    from 0 to 1, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s execute the circuit and display the results using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results exactly as expected; the results are based on the initialized
    state, followed by the NOT gates being applied on all qubits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We also get to see the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Results of the initialized circuit with X gate applied to all qubits'
  prefs: []
  type: TYPE_NORMAL
- en: The Aer simulator’s ability to be very flexible and configurable means that
    creating custom circuits with the ability to initialize qubit states is quite
    an advantage. We will see this in more detail in *Chapter 12*, *Understanding
    Quantum Algorithms*, where we will see how this is applied to variational or other
    hybrid quantum algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the Aer simulator, let’s move on to the statevector
    simulator and see what unique features we have available.
  prefs: []
  type: TYPE_NORMAL
- en: Running circuits on the statevector simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **statevector simulator**, like the Aer simulator, allows you to initialize
    and execute a quantum circuit. There are of course some distinct differences,
    one of which is that it returns the state vector of the quantum circuit by executing
    a single shot. This allows you to capture a snapshot of the state vector so you
    can, in some sense, calculate or observe the expected results on the qubits. Because
    the statevector simulator simulates the ideal execution of a quantum circuit and
    results in the final quantum state vector of the device at the end of a simulation,
    this result can then be used for debugging or educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also leverage some of the Aer visualization tools to help display the
    state information of the qubits and the quantum circuit. We will follow the next
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s create a simple 1-qubit circuit and add a Hadamard gate to
    it so we have a qubit in a superposition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this is as follows, where we have a single qubit in a superposition,
    that is, a complex linear combination of ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Single qubit circuit with a Hadamard gate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to see the state vector representation of the circuit. Before
    coding it, let’s review the mathematics around it. We know that each basis state
    is represented by state vectors, such as the following for the ![](img/B18420_05_004.png)
    state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_05_007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the ![](img/B18420_05_005.png) state can be represented by a state
    vector as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The initial state of a qubit is ![](img/B18420_05_004.png). The Hadamard gate
    generally applies the Hadamard matrix to the current state of the qubit, which
    places the qubit into a superposition state. Therefore, if a Hadamard gate is
    applied to a qubit in the state ![](img/B18420_05_004.png) the operation would
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_09_020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Multiplying the matrix by the vector results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s execute our circuit using the state vector simulator and output
    the state vector values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the results, we can obtain the state vector of the quantum circuit by simply
    extracting it from the `Job` object, in this case, `result.get_statevector()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should result in the following output that correctly matches our expected
    results, which include the state vector matrix dimension information, and where
    the amplitude values in the results are exactly ![](img/B18420_09_022.png). Furthermore,
    if we square the amplitudes, the results will provide us with the probability
    of obtaining a 0 or a 1\. The statevector results represent the expected results
    when applying a Hadamard to an initial state vector ![](img/_eqn_023.png) as we
    described in step 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s extend this by adding another qubit in superposition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this circuit is similar to the previous, just with an addition
    of an added qubit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Two qubits in superposition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this circuit using the state vector simulator and print out the results
    of our state vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This results in the following output, which represents equal amplitudes for
    all 4 possible states, ![](img/B18420_09_023.png), and ![](img/B18420_09_005.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, if we square each of the values to obtain the probability measurements,
    we will see that each has a 25% probability of being correct. Recall that all
    probabilities must add up to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s entangle the qubits and see what the state vector results would
    be when applying a Hadamard gate to the first qubit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The state vector results are as expected, with equal amplitude values of ![](img/B18420_09_025.png)
    for 00 and 11, and no values ![](img/B18420_09_026.png) for the states 01 and
    10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also seek the aid of the visualization tools to help illustrate the
    state vector results for the circuit we just executed. We will add the `plot_state_city`
    vector function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are the same values we saw earlier, only here we can see the amplitudes
    of both the real (left) and imaginary (right) components. When we square the amplitudes
    of our result, we will get a 50% probability for the 00 and 11 states, which is
    what we see in the following state vector plot. A state city plot is a term used
    to describe a view of a 3D bar graph (typically two-dimensional). The term is
    taken as the bar graphs on the 2D plot look like buildings in a city. In this
    case, we have two: one to represent the real values and another to represent the
    imaginary values of our state vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in our results, we did not have any value in any of the imaginary
    components of our state vector `1.`+`0.j`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – State vector plot with real (left) and imaginary (right) components
    ](img/B18420_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: State vector plot with real (left) and imaginary (right) components'
  prefs: []
  type: TYPE_NORMAL
- en: The state vector plot helps visualize the density matrix of 2-qubits, which
    itself has 16 complex qubit amplitudes. The topic of density matrices is outside
    the scope of this book but in short, it is generally an alternative to express
    all the quantum states such as ![](img/_eqn_028.png) and ![](img/_eqn_029.png),
    where this is the same with respect to the expected measurement outcome but allows
    us to describe these mathematically using the density matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Details describing the density matrix and how it is used can be found in the
    documentation here: [https://docs.quantum.ibm.com/api/qiskit /qiskit.quantum_info.DensityMatrix](https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.DensityMatrix).'
  prefs: []
  type: TYPE_NORMAL
- en: The state vector plot isn’t the only visualization tool we have available. Another
    great tool available is the **Qiskit qsphere**. This plots the state vector onto
    a two-dimensional graph and includes unique visualization features that allow
    you to see the probabilistic results and the phase when squaring the amplitudes
    of the state vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot the probabilistic results from the same state vector on a qsphere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s review the results and how they are displayed in the qsphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Qsphere representation of the results after squaring the state
    vector results'
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the vectors point to the north ![](img/B18420_05_004.png) state
    and south ![](img/B18420_05_005.png) state with the spheres at the end of each
    vector having equal diameters. This is to illustrate that there is an equal probability
    that the result will either be a 0 or 1, hence they are in superposition, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the color of each sphere matches the color corresponding to the phase
    of the state as described in the phase wheel located at the bottom right of the
    qsphere. This indicates that each vector is in phase (0°), which corresponds to
    a blue color. The results here match the expected equation we derived earlier,
    where we are placing the qubit in a superposition state; however, we have not
    applied any phase rotations, which are rotations around the *Z*-axis in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s do something interesting by introducing a phase shift. As we saw in the
    preceding screenshot, the vector moves from |0⟩ to |+⟩ in phase (0°) when we apply
    the Hadamard gate. We’ll now include a Z gate, also known as a phase gate, which
    rotates the vector by an angle of ![](img/B18420_09_030.png) around the *z* axis.
    As before, we’ll review the mathematics first to confirm what we should expect
    to see. Recall earlier how we described the effects of applying the Hadamard gate
    when the state vector originates from |0ñ. The following applies the Hadamard
    gate to the |1ñ state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Multiplying the matrix with the vector results produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will create a circuit originating from the ![](img/B18420_05_005.png) state
    and apply the H gate to it to confirm the preceding vector results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting qsphere now has the same probability as before; however, since
    the rotation originated from the ![](img/B18420_09_034.png) state, it is now at
    the ![](img/B18420_09_035.png) side, therefore out of phase by ![](img/B18420_09_030.png),
    which we can confirm by observing the following phase color chart (note that the
    color representations might change over time. Just compare the color to the color
    phase wheel for value to color mapping):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, radar chart  Description automatically generated](img/B18420_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: A superposition state that is also out of phase by an angle of
    ![](img/B18420_09_030.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try the same thing, this time originating from the ![](img/B18420_09_039.png)state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results, as we can see, are the same – there is a relative phase difference
    of ![](img/B18420_09_030.png) between the two states, ![](img/B18420_09_039.png)
    and ![](img/B18420_09_034.png) :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, radar chart  Description automatically generated](img/B18420_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: A state vector in superposition and out of phase by ![](img/B18420_09_030.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the state vector representation illustrates what we see mathematically,
    which is the following in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_042.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding equation, the negative value represents the out-of-phase
    component. We will see later on how various quantum algorithms leverage this in
    order to take advantage of the effects of interference in *Chapter 12*, *Understanding
    Quantum Algorithms*.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen that we can obtain and visualize the quantum state information
    from our quantum circuits using the state vector simulator. This allows us to
    determine whether the state of our circuit is what we are expecting, which helps
    when we are trying to debug the results of our circuit. We can also visually inspect
    our quantum circuits using various graphs to review information such as the density
    matrix and the probabilistic results based on the results from our state vector.
    Next, we will look at how we can obtain the unitary matrix of our circuit by leveraging
    the unitary simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Running circuits on the unitary simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **unitary simulator** provides the construction of the unitary matrix,
    **U**, of the circuit. The unitary matrix is the operator representation of your
    quantum circuit, which allows you to determine whether the circuit represents
    an operator you are either trying to replicate or create. The unitary simulator
    builds out the unitary matrix by stepping through the circuit and applying each
    gate to the initial state of the circuit. As described in the API documentation
    ([https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html)),
    the semantic validations will verify the constraints of the **qobj** and backend
    options, which are as described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of shots is set to 1, so only a single shot will be run to calculate
    the unitary matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit cannot contain any resets or measurements. Since the unitary simulator’s
    job is to just calculate the unitary matrix, there is no need to determine the
    measurement of the circuit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No noise models can be applied as it would require working with non-unitaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the circuit goes beyond any of the preceding constraints, it will raise an
    `AerError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will leverage the same circuit we created earlier for the state vector example
    to run through our unitary simulator so we can compare and contrast the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s validate what we should expect to see mathematically. As we will
    be applying a single Hadamard gate, it should be fairly simple to determine the
    unitary matrix. Starting from the initial state, we will apply an H gate to the
    circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_09_043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will run our circuit on the unitary simulator, where we will create
    a quantum circuit and add a Hadamard gate, then set the simulator to the unitary
    simulator provided by Aer. We should expect to see the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your unitary results should match the results we calculated mathematically;
    you can ignore the significantly small numbers in the imaginary component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create another circuit, only this time, let’s apply a phase shift
    after placing our circuit into a superposition. Let’s do this by adding a Z phase
    gate after the H gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will produce the following unitary matrix representation of the quantum
    circuit we created. Note the difference in the signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also give us the following circuit diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: 2-gate circuit applying an H gate followed by a Z gate'
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm this using a bit of linear algebra. One thing to note is that
    when we apply gates on a circuit and visualize them, we generally apply them from
    left to right, as illustrated in the preceding circuit diagram, where we see the
    **H** gate first, followed by the **Z** gate.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when calculating the unitary matrix, we place the unitary matrices
    of each gate we add from right to left. This is the order for the writing convention
    used to describe the order of applying operations onto an initial state. For example,
    in this circuit, we calculated the unitary matrix in the following order: first
    applying the H gate, then the Z gate, so from right to left this results in **ZH
    = U**, where **U** is the unitary matrix solution. Let’s calculate this matrix
    now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18420_09_044.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding equation, we have now confirmed that it is
    the same result we received from the unitary simulator for this circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous simulators, we can also initialize the unitary simulator
    with a given unitary matrix. Let’s use the results from the previous example as
    our initial unitary matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from the initialized circuit are now the same as the previous circuit,
    without the need to add any of the gates used to generate this unitary matrix.
    The output result is represented as a unitary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen how the unitary simulator is an exceptional component to use should
    you wish to experiment using a predefined unitary matrix. Using the unitary simulator,
    we learned how to calculate the unitary operator from a given quantum circuit,
    and how to create a circuit from a unitary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the various simulators and the differences
    between them, we’ll use them to simulate some of the noise we get when running
    a circuit on a real quantum device. You’ve also learned about the various options
    and parameters each simulator has available to you so you can leverage each one
    in multiple ways to obtain various results, such as count and state vector information,
    from the provided quantum circuit. This will help simulate the results from circuits
    where noise models affect the outcome, as opposed to the results from running
    on an ideal, noiseless simulator. So, let’s generate the noise models in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Accounting for noise in quantum circuits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Noise models are used to represent various noise effects that cause errors in
    quantum circuits. The origin of the noise stems from many sources within the quantum
    system. Based on the currently available devices and those coming in the near
    future, the number of errors on a device could be significant, depending on the
    quantum circuit executed on them.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will review the various types of errors that can affect
    a qubit, gates, and readouts. We will also learn how to generate noise models
    either based on the configuration information from the real devices, or noise
    models created by ourselves, with which we can simulate the real devices using
    the Aer simulators.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an Aer noise model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll begin by demonstrating how to implement the various types of noise models
    that are prebuilt in the Aer noise libraries that will help make our experiments
    seem more realistic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create the same simple circuit we have used in most of our examples,
    the Bell state, which includes a Hadamard and CNOT gate, followed by a set of
    measurement operators, and execute it on an ideal simulator, with no errors. This
    should result in the expected values of 00 and 11:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results from this circuit on an ideal simulator are as follows. Notice
    we only obtain two values, 00 and 11, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Results from an ideal simulator with no effects of noise ](img/B18420_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Results from an ideal simulator with no effects of noise'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will execute the same circuit on an actual device instead of a simulator.
    To save time, let’s find the least busy device that has enough qubits to run our
    experiment as well. Keep in mind the time to complete this on a quantum system
    may vary depending on your position in the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The results are very similar to that of the earlier execution on the simulator,
    only this time, notice there are some errors in the results. Rather than only
    obtaining results of **0** and **3**, we see a few instances of **1** and **2**.
    These are the effects of backend noise on the results of the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s do something interesting. Let’s make use of a noise model based on
    the properties of a specific backend device. Aer’s `NoiseModel` provides the ability
    to do this with a simple method call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following plot of the results of the preceding code, as you can see, is
    not as ideal as before. We can observe a few errors here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Results from a simulator with noise effects based on a specified
    backend ](img/B18420_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Results from a simulator with noise effects based on a specified
    backend'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can simulate the effects of noise from a backend system onto a simulator,
    let’s develop an understanding of what the cause is of some of these noise effects.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the source of noise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When executing quantum circuits on a real device, there are various effects
    that can cause errors in our computations. In this section, we will review some
    of those effects so that when you’re generating or building your noise models,
    you will have a better understanding of how they affect each qubit.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding decoherence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Decoherence** is defined as the loss of quantum coherence due to a quantum
    system’s physical interaction with its environment. Decoherence affects each qubit
    in many ways, one of which is when each qubit starts in a ![](img/B18420_05_004.png)
    ground state, and we operate on the qubit to move it from the ![](img/B18420_05_004.png)
    state to the ![](img/B18420_05_004.png) state. For example, we say the qubit has
    transitioned from the ground state, ![](img/B18420_05_004.png), to the excited
    state, ![](img/B18420_05_004.png). An analogy for this is to think of yourself
    sitting peacefully and perfectly at rest. This peaceful relaxed moment is you
    in the ground state.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, imagine someone jumping out of nowhere and screaming at you! You’re immediately
    startled as your heart rate jumps up and your adrenaline kicks in. This is you
    now in the excited state. Now, after telling the person who startled you to never
    do that again, you manage to catch your breath and get your heart rate down. You
    begin to relax and get your body back down to the grounded state it was in before.
    The time required to change from the excited state to the grounded state is, coincidentally,
    called the style **relaxation time**. Of course, one very important thing to note
    is that while it is ideal for us as humans to quickly get back to our relaxed
    state, for a quantum system, it is ideal for this time to stay in the set state
    for as long as possible. This will ensure that whichever state we place a qubit
    in, it maintains that state as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The relaxation time, denoted as **T**[1], is the time constant of the longitudinal
    loss (oriented along the *z* axis) of the signal intensity. Another decoherence
    effect is **dephasing**, denoted as **T**[2], where the phase information spreads
    out widely so that the phase information is lost. We will cover details on how
    the information is lost in the next chapter. An example of this is if we set the
    qubit to the ![](img/B18420_09_050.png) state. The dephasing time is a decay constant
    time where the initial state decays down to a mixed state of ![](img/B18420_09_050.png)
    and ![](img/B18420_09_052.png), where it is difficult to predict the state of
    the system and is not perfectly in a superposition state and tends to collapse.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to measure T[1] and T[2] decoherence times:'
  prefs: []
  type: TYPE_NORMAL
- en: To measure T[1], you would apply a series of pulses separated by a fixed time
    delay and capture the statistical results of the state as it moves from ![](img/B18420_05_004.png)to
    ![](img/B18420_05_005.png). The oscillations that show up in the measurements
    after applying pulses of varying lengths or amplitudes are called **Rabi oscillations**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To measure T[2], you would set the state of the qubit to ![](img/B18420_09_050.png)
    or ![](img/B18420_09_052.png), and then apply ![](img/B18420_06_041.png) pulses
    at sequences to apply a phase rotation. After applying a particular sequence of
    pulses over time, the state should return to its original position, that is, ![](img/B18420_09_050.png)
    or ![](img/B18420_09_052.png). If dephasing occurs, then the result will have
    a lower probability of returning to its original starting position. This technique
    of measuring T[2] is called a **spin echo**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we are a bit more familiar with the sources of noise, let’s shift
    our discussion to the contributors to decoherence and how they vary based on their
    sources. There are generally two source types – **intrinsic** and **extrinsic**:'
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsic noise, often regarded as generic in nature, originates from sources
    within the system, such as temperature, or defects within the system, so essentially,
    materials or defects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extrinsic noise originates from environmentally coupled systems such as wave
    interference, vibrations, and electromagnetic fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s run a quick example of thermal relaxation on a pair of qubits as this
    is generally intrinsic to a qubit. In the following example, we will define our
    T[1] and T[2] values in seconds and apply them to a set of basis gates for all
    qubits. These values can be set to whatever time constant you wish; the time value
    provided in the backend properties is stated as an average so it is not likely
    your results would be the same each time. One thing to note is that the parameters
    you set must be true for the following, ![](img/B18420_09_060.png), otherwise
    an error will be thrown. We’ll then run a sample circuit with these thermal relaxation
    errors to see the difference. The circuit that we will create and execute will
    be the same Bell state circuit we created earlier and ran on a simulator, so we
    can compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NoiseModel` output provides a description of the noise model by indicating
    which basis gates are available, which gate instructions would be affected by
    the noise, and which basis gates errors are applied to the qubits. Keep in mind,
    that the results may vary based on available backend systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will see, the results after executing this circuit on the simulator
    with the generated noise are not quite the same as before. In the earlier case,
    without errors, we had a very close 50/50 split between **00** and **11**. However,
    as you can see in the following screenshot, the result is more of a 75/25 split
    between **00** and **11**. This, of course, is due to the thermal relaxation error
    we added to the simulator, thus causing much of the results to encounter a relaxation
    from the excited state to the ground state, as illustrated in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Results on a simulator with thermal relaxation errors ](img/B18420_09_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Results on a simulator with thermal relaxation errors'
  prefs: []
  type: TYPE_NORMAL
- en: Both T[1] and T[2] are environmental effects that act upon the qubits and their
    ability to maintain their states. Other effects that contribute to the overall
    noise of a system are contributed by the gates that manipulate the qubits. Let’s
    look at a few of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding single-gate, multi-gate, and readout errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Single-gate errors** and **multi-gate errors** are generally introduced when
    a qubit is operated upon by the various gates on the system. These errors are
    based on probabilities that the gate applied to the qubit may not operate exactly
    as expected. For example, if we apply a 5% gate error probability to a single-qubit
    gate such as a NOT gate, then the result of the operation has a 5% probability
    of not resulting in the expected value. The single-gate error could be from poor
    gate fidelity, whereas the multi-gate error could be from crosstalk or spectator
    noise from neighboring qubits, or from the physical connection between the qubits.
    The Aer library has a list of noise model methods to choose from, including **Pauli
    error**, **depolarizing error**, **amplitude damping error**, and many more for
    us to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Single-gate and multi-gate errors can be applied to all qubits at once using
    the `add_all_qubit_quantum_error()` method contained in the `NoiseModel` class.
    This method applies a quantum error object to the noise model for the specified
    basis gates, which is then applied to all qubits. The first argument is the quantum
    error, and the second is the list of basis gates to apply the error to.
  prefs: []
  type: TYPE_NORMAL
- en: '**Readout errors** are those that occur when a measurement and acquisition
    are triggered to read out the value of the qubit. During the operations of measuring
    and acquiring the signal from the qubit, errors can exist that may interfere with
    the results of the qubit measurement. The `NoiseModel` class also has methods
    available to add readout errors to the noise model.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build our own noise model with single-qubit, multi-qubit, and readout
    errors on a circuit to observe the effects of these errors on our quantum circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own noise model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be times when you wish to build your own custom noise models. Whether
    it’s to generate specific errors to test your error-mitigation methods or to create
    something resembling a specific device, having the ability to customize your own
    noise model is a handy feature to have available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we will set the single- and multi-qubit errors and
    view the results. We will then set the readout errors and run them on the same
    circuit just to visualize the difference in the results when measurement errors
    are introduced to an ideal system. The single-qubit error will have an amplitude
    dampening error, the multi-qubit error will have a depolarizing error, and the
    readout error will be applied to both qubits in the circuit:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by defining our quantum circuit and transpiling it with the simulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll begin by defining the single- and multi-qubit probability error
    values, followed by initializing and setting the depolarizing errors, first to
    the single qubit, and then to the multi-qubit error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create our `NoiseModel` object and add both the single- and multi-qubit
    errors. The single qubit error will be assigned to the basis gate `u2`, and the
    multi-qubit error will be assigned to the CNOT (`cx`) gate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now print out the `NoiseModel` to confirm out noise model entries are
    set. As we can see from the output of the noise model, we have a list of all basis
    gates available, a list of instructions that have been assigned noise, and a list
    of all the basis states that will affect all of the qubits in our circuit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s add this to our simulator and run it with both the single and multi-qubit
    noise model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will result in the following histogram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Results on a simulator with single and multi-qubit errors'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the errors we introduced had an effect on our results and we
    now get some unexpected values, 01 and 10, which we didn’t expect or see in our
    ideal case when running on a system with no noise. However, even with the noise,
    we can see that our results are correct in that we still have a high probability
    of the states 00 and 11\. So here, the noise is minimal so that we can get some
    good results. Let’s try a different error next and increase the noise to see what
    we get when we have very noisy readout errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s include some readout errors. Readout errors are defined in the
    Aer API documentation as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Classical readout errors are specified by a list of assignment probabilities
    vectors P(A|B), where A is the recorded classical bit value, and B is the true
    bit value returned from the measurement.*'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the probabilities of the expected values will be recorded and
    used to apply readout errors based on the probability values we pass in as arguments
    to the noise model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation for a single-qubit readout probability vector is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18420_09_061.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When constructing the `ReadoutError` class, P(A|B) is provided as the argument.
    For our example, we will provide the probability of 0 given 1 as `0.7`, and the
    probability of 1 given 0 as `0.2`. We will also add our readout error to the noise
    model and print out the results, as illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Note, of course, that these values we are setting are very high and do not necessarily
    need to add up to 1\. I’m using them to highlight the impact noise has, in this
    case, in a very exaggerated yet visually recognizable way to see that the errors
    are actually pulling the results away from the expected values into the biased
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the addition of some instructions and listings of qubits in the
    result. The first line specifies `Basis gates`, and the following line is the
    list of `Instructions with noise` added to them. Notice that it now only includes
    the `measure` instruction. Next, we see the qubits that have been specified for
    a particular noise – in this case, we added the readout error to all qubit measurement
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our readout noise model complete, we’ll add our custom noise
    model and run it on the Aer simulator to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the previous example, where we included a thermal relaxation noise
    model, we will provide the readout noise model in the same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The results, as you can see in the following plot, are now not as ideal as
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Result with effects from our custom noise model on a quantum circuit'
  prefs: []
  type: TYPE_NORMAL
- en: We can observe various errors here, caused by the readout noise. First and foremost,
    our expected results of **00** and **11** are no longer easily visible from our
    results. In this sense, we see that the readout of each qubit has a higher probability
    of 0 given 1, which therefore causes the probability results to be higher for
    the values **00**, **01**, and **10**. This is caused by the readout errors that
    are applied to all the qubits, which greatly reduces the probability of 1.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of all this noise is that you have an insight as to the cause
    of this noise based on the type of noise we included, and the amount of noise
    applied to a specified qubit(s). This allows you to simulate certain noise effects
    should you wish to work on some noise-mitigating techniques.
  prefs: []
  type: TYPE_NORMAL
- en: By applying noise and understanding its effects, you can create noise-mitigating
    techniques and verify the results on a simulator. By doing this, you can test
    various combinations of noise effects, which can help minimize the error rate
    on some algorithms, and therefore increase the performance of the quantum computer.
    We will look at noise-mitigating techniques in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered various simulators. You now have the skills to leverage
    various simulators to simulate running circuits on a quantum computer and obtain
    specific content from the circuits, such as state vectors and unitary matrices.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered various visualization techniques. The skills that you have gained
    will help you visualize the various pieces of information from the simulator,
    such as visualizing the state and phase information of a qubit using the qsphere
    and plotting state vector graphs.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we looked into the noise models that Qiskit provides by either
    extracting the noise from an existing quantum computer or creating our own noise
    models and applying them to the simulators.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to characterize and mitigate noise. This
    will allow us to optimize the performance of the quantum computer and increase
    its computational power.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you list all the simulators found in the Qiskit Aer module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a qsphere representation of a qubit on the negative *y* axis, creating
    the state ![](img/B18420_09_062.png), using only a single Hadamard gate along
    with the phase gates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When initializing a set of qubits in a circuit, what must the total probability
    across all states be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use the qsphere to visualize both the phase and probability information
    of a qubit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would happen if you set the depolarization error values close to 1?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you applied a readout error equally to all qubits, what results would you
    expect, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join us on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/3FyN1](Chapter_9.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2617625996838265931.png)'
  prefs: []
  type: TYPE_IMG
