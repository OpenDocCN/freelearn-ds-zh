- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Simulating Quantum Systems and Noise Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟量子系统和噪声模型
- en: '**Qiskit** is a provider of high-performance backends that can be used to execute
    quantum circuits. The various backend simulators available can be used in unique
    ways where each can provide different information pertaining to your circuit.
    Qiskit also provides a variety of tools that can be leveraged to construct noise
    models to simulate various errors that occur on real quantum devices. These tools
    are very helpful should you need to compare the difference between your results
    from an ideal simulator and that which replicates the effects of noise from a
    quantum device.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qiskit**是高性能后端提供商，可用于执行量子电路。可用的各种后端模拟器可以以独特的方式使用，每个都可以提供有关你的电路的不同信息。Qiskit还提供各种工具，可以用来构建噪声模型以模拟真实量子设备上发生的各种错误。如果你需要比较理想模拟器和复制量子设备噪声效应的模拟器之间的结果差异，这些工具非常有帮助。'
- en: Both the simulators and tools such as the **noise model** will help you understand
    the reasons for some of the effects on your results, as well as provide insights
    should you later want to mitigate those errors yourself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器和如**噪声模型**之类的工具将帮助你理解一些结果上的原因，以及如果你以后想自己减轻这些错误，它们将提供见解。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the differences between simulators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模拟器之间的差异
- en: Generating noise models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成噪声模型
- en: Building your own noise model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你自己的噪声模型
- en: Executing quantum circuits with custom noise models
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义噪声模型执行量子电路
- en: In this chapter, we will review the Qiskit simulators and understand the differences
    between each of them and what unique functionality each one provides. We will
    also delve into the Qiskit noise models that we can generate based on the specified
    backend devices to allow us to simulate noise on our ideal Qiskit simulators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾Qiskit模拟器，并理解它们之间的差异以及每个模拟器提供的独特功能。我们还将深入研究基于指定后端设备可以生成的Qiskit噪声模型，以便我们能够在理想的Qiskit模拟器上模拟噪声。
- en: After reading this chapter, you will be able to reproduce similar noise effects
    on the simulator. This will allow you to observe how the noise affects our results,
    which would allow us to simulate a real quantum device. Finally, we will cover
    how you can create your own noise models and apply them to your circuits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，你将能够在模拟器上重现类似的噪声效应。这将使你能够观察噪声如何影响我们的结果，这将使我们能够模拟真实的量子设备。最后，我们将介绍如何创建你自己的噪声模型并将它们应用于你的电路。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, it is expected that you are familiar with the basics of quantum
    circuits described in previous chapters, such as creating and executing quantum
    circuits, obtaining backend properties and configurations, and customizing and
    visualizing circuit diagrams, and you should have knowledge of qubit logic gate
    operators and states. Also, some familiarity with noise effects such as decoherence
    time would be ideal; however, we will cover some of the basics in this chapter
    as a refresher. You will need to install the latest version of **qiskit-aer**
    to run the notebooks in this chapter; details can be found in the Qiskit documentation:
    [https://qiskit.github.io/qiskit-aer/getting_started.html](https://qiskit.github.io/qiskit-aer/getting_started.html).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设你已经熟悉了前几章中描述的量子电路的基本知识，例如创建和执行量子电路、获取后端属性和配置、定制和可视化电路图，并且你应该了解量子比特逻辑门操作符和状态。此外，对噪声效应（如退相时间）有一定的了解将非常理想；然而，我们将在本章中涵盖一些基础知识作为复习。你需要安装**qiskit-aer**的最新版本来运行本章中的笔记本；详细信息可以在Qiskit文档中找到：[https://qiskit.github.io/qiskit-aer/getting_started.html](https://qiskit.github.io/qiskit-aer/getting_started.html).
- en: 'Here is the full source code used throughout this book: [https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的完整源代码如下：[https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition](https://github.com/PacktPublishing/Learning-Quantum-Computing-with-Python-and-IBM-Quantum-Second-Edition).
- en: Understanding the differences between simulators
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模拟器之间的差异
- en: In this section, you will learn about the various simulator backends that are
    included in Qiskit Aer, including the differences between them and their distinct
    features. Note that you will need to install **qiskit-aer** separately as it is
    not part of the base Qiskit install.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解Qiskit Aer中包含的各种模拟器后端，包括它们之间的差异和独特的特性。请注意，您需要单独安装**qiskit-aer**，因为它不是Qiskit基础安装的一部分。
- en: These features include generating noise models and configuring the simulator
    backends that allow you to take advantage of modifying their behavior and characteristics
    to suit your needs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性包括生成噪声模型和配置模拟器后端，允许您利用修改其行为和特性以满足您的需求。
- en: 'We will learn about the following simulators and their key features:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解以下模拟器和它们的关键特性：
- en: The Aer simulator, which executes a quantum circuit with multiple shots to simulate
    a noisy backend quantum system
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Aer模拟器**，通过多次射击执行量子电路以模拟有噪声的后端量子系统'
- en: The Statevector simulator, which provides the state vector of the quantum circuit
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Statevector模拟器**，提供量子电路的状态向量'
- en: The Unitary simulator, which provides the unitary matrix of the quantum circuit
    being executed
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unitary模拟器**，提供正在执行的量子电路的单位矩阵'
- en: Let’s move on and look at the quantum systems, herein referred to as simply
    backends.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看量子系统，在此处简称为后端。
- en: Viewing all available backends
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看所有可用的后端
- en: If you have read the previous chapters of this book, then you are aware of some
    of the simulators we have used. Let’s start off by displaying every simulator
    available from the various sources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了本书的前几章，那么您应该已经了解我们使用的一些模拟器。让我们从显示来自各种来源的每个可用模拟器开始。
- en: 'We will create a new **notebook** on IQP and run the autogenerated cell to
    ensure you have loaded some base classes and methods and loaded your account information
    so we can access IQP:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在IQP上创建一个新的**笔记本**，并运行自动生成的单元格，以确保您已加载一些基础类和方法，并加载您的账户信息，以便我们可以访问IQP：
- en: 'We’ll begin by importing some useful classes and functions including, those
    in the helper file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先导入一些有用的类和函数，包括辅助文件中的那些：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll display all the available simulators in the Qiskit Aer library
    by using the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下代码显示Qiskit Aer库中所有可用的模拟器：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will display a list of all the available simulators:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有可用的模拟器列表：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following code will list out the simulators that are part of the `Qiskit-Aer`
    library. These are also available as Python built-in simulators, should you not
    want to install Aer and just use Qiskit. For simplicity and performance considerations,
    we will be using the Qiskit simulators throughout this book. However, you can
    certainly interchange the Aer simulators with those actual quantum systems listed
    in `service` as needed. But since we want to conserve usage time, let’s stick
    with the simulator for these basic circuits and learning concepts.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将列出`Qiskit-Aer`库中的模拟器。如果您不想安装Aer而只想使用Qiskit，这些模拟器也作为Python内置模拟器可用。为了简单性和性能考虑，我们将在这本书中使用Qiskit模拟器。然而，您当然可以根据需要将Aer模拟器与`service`中列出的实际量子系统进行交换。但由于我们想要节省使用时间，让我们继续使用这些基本电路和学习概念。
- en: 'And finally, we can list all the quantum systems available from the Qiskit
    Runtime Service:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以列出从Qiskit Runtime Service可用的所有量子系统：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will not only list the simulator but also list the real quantum devices
    available to you based on your account. Those listed will vary based on available
    devices and upgrades since this writing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅会列出模拟器，还会根据您的账户列出您可用的真实量子设备。所列出的设备将根据可用设备和升级而变化，自本写作以来：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As this chapter is focused on simulators, we will learn about the local simulators
    that are installed from the Qiskit library going forward. We’ll start with the
    Aer simulators, which we can use to execute small circuits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章专注于模拟器，我们将从Qiskit库中安装的本地模拟器开始学习。我们将从Aer模拟器开始，我们可以使用它来执行小型电路。
- en: Running circuits on the Aer simulator
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Aer模拟器上运行电路
- en: The **Aer simulator** is not only used to execute quantum circuits but is also
    very versatile because of its ability to apply various simulation methods and
    configuration options.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Aer模拟器**不仅用于执行量子电路，而且由于其能够应用各种模拟方法和配置选项，因此非常灵活。'
- en: 'A few of the available simulation methods are described as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用的模拟方法如下所述：
- en: '`statevector`: This is a statevector simulation within the Aer library that
    allows ideal circuit measurements at the end of the quantum circuit. In addition,
    each shot that executes the circuit can sample random noise from noise models
    to provide noisy simulations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statevector`: 这是Aer库中的状态向量模拟，允许在量子电路末尾进行理想测量。此外，每个执行电路的射击都可以从噪声模型中采样随机噪声，以提供有噪声的模拟。'
- en: '`density_matrix`: This method provides a density matrix simulation that like
    the statevector, samples the quantum circuits with measurements given at the end
    of each circuit.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`density_matrix`: 此方法提供密度矩阵模拟，类似于状态向量，在每个电路末尾给出测量值来采样量子电路。'
- en: '`matrix_product_state`: This is a tensor-network statevector simulator that
    leverages a Matrix Product State as the representation of the state.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix_product_state`: 这是一个张量网络状态向量模拟器，它利用矩阵乘积状态作为状态的表示。'
- en: '`automatic`: If no method is set, then this method will select one automatically
    based on the number of qubits, the quantum circuit, and the noise model.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`automatic`: 如果没有设置方法，则此方法将根据量子比特数、量子电路和噪声模型自动选择一个。'
- en: 'There are many backend options available; below is a subset of the available
    `backend_options`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的后端选项有很多；下面是`backend_options`可用选项的一个子集：
- en: '`device`: This sets the simulation device where `CPU` is set by default. However,
    the `statevector`, `unitary`, and `density_matrix` simulators can also run on
    systems equipped with an Nvidia **Graphical Processing Unit** (**GPU**). To configure
    the simulator to a GPU, simply set the options parameter, `device=''GPU''`.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device`: 此选项设置模拟设备，默认设置为`CPU`。然而，`statevector`、`unitary`和`density_matrix`模拟器也可以在配备Nvidia
    **图形处理单元**（**GPU**）的系统上运行。要将模拟器配置为GPU，只需设置选项参数`device=''GPU''`。'
- en: '`precision`: This sets the floating point to either single or double precision;
    the default is `double`. Setting the precision to `single` will halve the required
    memory of the backend, which could provide some performance improvement on certain
    systems.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precision`: 此选项将浮点数设置为单精度或双精度；默认为`double`。将精度设置为`single`将减半后端所需的内存，这可能在某些系统上提供一些性能提升。'
- en: '`zero_threshold`: This truncates small values to 0 and will truncate very small
    values. The default truncation value is set to 1e-10, but this can be adjusted
    to suit the needs of the developer.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zero_threshold`: 此选项将小值截断为0，并将非常小的值截断。默认截断值设置为1e-10，但可以根据开发者的需求进行调整。'
- en: '`validation_threshold`: This threshold is used to verify if the initial statevector
    of the quantum circuit is valid, with the default value set to 1x10^(-8).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validation_threshold`: 此阈值用于验证量子电路的初始状态向量是否有效，默认值设置为1x10^(-8)。'
- en: '`max_parallel_threads`: Setting this parameter to (the default value) `0` enables
    the simulator to run on all available cores.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_parallel_threads`: 将此参数设置为（默认值）`0`将使模拟器能够在所有可用核心上运行。'
- en: '`max_parallel_experiments`: The maximum number of **qobj** (**QASM object**),
    which rep­resents a single payload of a Qiskit provider to run circuits in parallel.
    The max value cannot exceed the `max_parallel_threads` value. If the max is set
    to `0`, it will be set to the `max_parallel_threads` value.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_parallel_experiments`: 这是**qobj**（**QASM对象**）的最大数量，它代表Qiskit提供程序并行运行电路的单个有效负载。最大值不能超过`max_parallel_threads`值。如果最大值设置为`0`，则将其设置为`max_parallel_threads`值。'
- en: '`max_parallel_threads`: This sets the maximum number of CPU cores for parallelization.
    The default value is set to `0`, which means it will set it to the maximum number
    of CPU cores.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_parallel_threads`: 此选项设置并行化的最大CPU核心数。默认值设置为`0`，这意味着它将设置为CPU核心的最大数量。'
- en: '`max_memory_mb`: Setting this parameter to `0` enables the simulators to maximize
    the size of system memory to store a state vector; the default value is set to
    `0`. If more memory is needed, an error will be thrown. As a reference, a state
    vector of n-qubits uses 2^n complex values of approximately 16 bytes.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_memory_mb`: 将此参数设置为`0`将使模拟器最大化系统内存的大小以存储状态向量；默认值设置为`0`。如果需要更多内存，将抛出错误。作为参考，n个量子比特的状态向量使用2^n个大约16字节的复数值。'
- en: 'Now that you have knowledge of the simulation methods and backend options,
    we’ll create a simple circuit and execute it using Aer’s `QasmSimulator` class.
    For this example, we will create the same circuit example we have been using so
    far, consisting of Hadamard and CX gates, which places the quantum circuit in
    a superposition and entangles both qubits together:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了模拟方法和后端选项，我们将创建一个简单的电路，并使用Aer的`QasmSimulator`类执行它。对于这个例子，我们将创建我们迄今为止一直在使用的相同电路示例，由Hadamard和CX门组成，这使量子电路处于叠加态并将两个量子比特纠缠在一起：
- en: Here, we are creating a 2-qubit and 2-bit circuit; when using the `measure_all()`
    function, we will need to set the `add_bits` parameter to `False` so that it does
    not add the classical bits since we have already added them in the `QuantumCircuit`
    constructor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个2量子比特和2位电路；当使用`measure_all()`函数时，我们需要将`add_bits`参数设置为`False`，这样它就不会添加经典比特，因为我们已经在`QuantumCircuit`构造函数中添加了它们。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s create the Aer simulator using the `get_backend()` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`get_backend()`函数创建Aer模拟器：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will print out the results from executing the quantum circuit on the Aer
    simulator, with the method set to a state vector, obtaining the result counts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出在Aer模拟器上执行量子电路的结果，方法设置为状态向量，获得结果计数。
- en: 'As you can see, this runs the same results as if you ran `aer_simulator` as
    follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这运行的结果与您运行`aer_simulator`如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both forms execute the circuit in the same manner, with varying values in the
    results, of course. Here, you can see the results, which both ran a total, 1024
    shots, as this is set by default:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式都以相同的方式执行电路，当然结果中的值会有所不同。在这里，您可以查看结果，它们总共运行了1024次射击，这是默认设置的：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll continue by extending the backend options to include other parameters
    that we might find useful, such as shots and memory, in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节继续扩展后端选项，包括我们可能发现有用的其他参数，例如射击和内存。
- en: Adding parameters to the backend options
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后端选项添加参数
- en: We may already be familiar with the `shots` parameter, which specifies how many
    times to execute the circuit on the backend. However, as illustrated in the previous
    example, the counts returned are the total values of all the shots, but not in
    the order in which each result was returned. There may be situations when you
    would like to examine the results of each shot in chronological order.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经熟悉了`shots`参数，它指定了在后端上执行电路的次数。然而，如前一个示例所示，返回的计数是所有射击的总值，而不是每个结果返回的顺序。可能存在您希望按时间顺序检查每个射击结果的情况。
- en: 'To examine the measured results that are stored in the individual memory slots,
    you will need to set the `memory` parameter in the backend options. Let’s rerun
    the previous circuit; however, this time we will set the `memory` flag to `True`
    and display the results. We’ll run just 10 shots this time to avoid a very large
    output string:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查存储在各个内存槽中的测量结果，您需要在后端选项中设置`memory`参数。让我们重新运行之前的电路；然而，这次我们将`memory`标志设置为`True`并显示结果。这次我们将只运行10次以避免输出一个非常长的字符串：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will output the 10 memory slot entry results from the execution of the
    circuit. Notice that the results are varying combinations of `00` and `11`, as
    expected for the circuit:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出电路执行的10个内存槽条目结果。请注意，结果为`00`和`11`的变体组合，正如电路所预期的：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Having the memory feature built into the Aer simulator gives you the ability
    to visualize each result of your circuit count. The next section will illustrate
    how to initialize and set up all, or just a subset, of the qubits.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存功能集成到Aer模拟器中，您将能够可视化电路计数的每个结果。下一节将说明如何初始化和设置所有或仅部分量子比特。
- en: Initializing the qubits on a circuit
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在电路中初始化量子比特
- en: As we learned early on, each qubit is initialized to the ground state, or the
    ![](img/B18420_05_004.png) state. However, there may be times when we would like
    to set a different initial state. Luckily for us, the Aer simulator allows us
    to initialize the state of the circuit to some other state, ![](img/B18420_09_002.png)
    , in lieu of all ![](img/B18420_05_004.png)states.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们早期所学的，每个量子比特被初始化为基态，或称为![img/B18420_05_004.png](img/B18420_05_004.png)状态。然而，有时我们可能希望设置一个不同的初始状态。幸运的是，Aer模拟器允许我们将电路的状态初始化为除所有![img/B18420_05_004.png](img/B18420_05_004.png)状态之外的某个状态，![img/B18420_09_002.png](img/B18420_09_002.png)。
- en: 'We will follow the next steps to initialize the qubits:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤初始化量子比特：
- en: 'In the previous example, we created a circuit that contained a Hadamard and
    Control-Not gate to obtain the entangled state results of ![](img/B18420_09_004.png)
    or ![](img/B18420_09_005.png). In this example, we will initialize our circuit
    so that the results are the same without needing to add any gates:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个包含Hadamard门和控制非门的电路，以获得 ![](img/B18420_09_004.png) 或 ![](img/B18420_09_005.png)
    的纠缠态结果。在这个示例中，我们将初始化我们的电路，以便结果相同，而无需添加任何门：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following circuit diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下电路图：
- en: '![Diagram  Description automatically generated](img/B18420_09_01.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成的描述](img/B18420_09_01.png)'
- en: 'Figure 9.1: Initialized qubits to an initial state other than the zero state'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：初始化量子位到非零初始状态
- en: Notice that the qubits are collectively initialized into the state of ![](img/B18420_09_006.png).
    This circuit now has an initialized state that can be applied to any circuit should
    you wish a circuit to begin in a state other than the ground/zero state. Initializing
    a state can be needed when using a variational quantum algorithm that needs to
    be updated each time it is run to optimize its results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，量子位被集体初始化到 ![](img/B18420_09_006.png) 的状态。现在，这个电路有一个初始化状态，如果您希望电路从非基态/零态开始，可以应用于任何电路。在需要每次运行时更新以优化其结果的变分量子算法中，初始化状态可能是必要的。
- en: 'Now, let’s execute this circuit and observe each result:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们执行这个电路并观察每个结果：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This prints out the following results:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下结果：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can observe from the results, we get only the two initialized state results
    of either ![](img/B18420_09_004.png) or ![](img/B18420_09_005.png), as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从结果中观察到的，我们只得到了预期的两种初始化状态结果，即 ![](img/B18420_09_004.png) 或 ![](img/B18420_09_005.png)。
- en: 'Now, you don’t have to initialize all qubits in a circuit; you can also specify
    a group of qubits to initialize, as illustrated in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您不必初始化电路中的所有量子位；您也可以指定要初始化的一组量子位，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following circuit, which initializes the state of the `q_1`
    to `q_3` qubits, while all the other qubits that are initialized remain in the
    ground/zero state:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下电路，它初始化了 `q_1` 到 `q_3` 量子位的状态，而所有其他初始化的量子位仍然处于基态/零态：
- en: '![Diagram, schematic  Description automatically generated](img/B18420_09_02.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图示，示意图  自动生成的描述](img/B18420_09_02.png)'
- en: 'Figure 9.2: Initialization of the last three qubits'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：最后三个量子位的初始化
- en: Here, our 3-qubit initialized state is set to ![](img/B18420_09_009.png) However,
    since we are executing a 4-qubit circuit, and we have initialized the last 3 qubits,
    our results should include the fourth qubit (q[0]), which would append a 0 to
    the least significant bit.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的3量子位初始化状态设置为 ![](img/B18420_09_009.png)。然而，由于我们正在执行一个4量子位电路，并且我们已经初始化了最后3个量子位，我们的结果应该包括第四个量子位（q[0]），这将向最低有效位添加一个0。
- en: 'Let’s run the experiment and see whether the initial state of the partial qubits
    is successful:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行实验，看看部分量子位的初始状态是否成功：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As expected, our results are as follows (note that due to the randomness of
    the circuit, actual results could vary):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的结果如下（请注意，由于电路的随机性，实际结果可能会有所不同）：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also get the following output graph:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了以下输出图：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_03.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图表，柱状图  自动生成的描述](img/B18420_09_03.png)'
- en: 'Figure 9.3: Results of initialized quantum circuit'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：初始化量子电路的结果
- en: As you can see, the results are exactly as we expected them to be. Notice that
    the least significant bit (the bit on the far right) is always set to 0 as it
    was not one of the initialized qubits. The other thing to take note of is that
    the other bits are exactly as we expected, ![](img/B18420_09_010.png), where the
    bold indicates the initialized bits, and if you combine them all together, they
    will provide the results displayed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果与我们预期的完全一致。请注意，最低有效位（最右边的位）始终设置为0，因为它不是初始化的量子位之一。其他需要注意的事情是其他位正好如我们预期的那样，![](img/B18420_09_010.png)，其中粗体表示初始化的位，如果您将它们全部组合起来，它们将提供显示的结果。
- en: 'Now that we have initialized a circuit, we can apply any gate as needed. The
    only difference is that the gates applied to the circuit after initialization
    will then be applied to the initialized state of each qubit, rather than the default
    initialized state ![](img/B18420_05_004.png). Let’s test this out by adding a
    NOT (X) gate to all the qubits. This should result in all the values being flipped:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了一个电路，我们可以根据需要应用任何门。唯一的区别是，初始化后应用到电路上的门将应用于每个量子比特的初始化状态，而不是默认的初始化状态
    ![img/B18420_05_004.png](img/B18420_05_004.png)。让我们通过向所有量子比特添加一个NOT（X）门来测试这一点。这应该会导致所有值翻转：
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This results in the following circuit:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下电路：
- en: '![Diagram, schematic  Description automatically generated](img/B18420_09_04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![示意图，原理图  自动生成的描述](img/B18420_09_04.png)'
- en: 'Figure 9.4: Initialized quantum circuit with X gates applied to all qubits
    before measuring'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：在测量之前对所有量子比特应用X门的初始化量子电路
- en: Notice the initialized qubits are as before, only after the X gates on all qubits
    that we have added just before measuring. This should result in all bits flipping
    from 0 to 1, and vice versa.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意初始化的量子比特与之前相同，只是在测量之前我们添加了所有量子比特的X门。这应该会导致所有位从0翻转到1，反之亦然。
- en: 'Let’s execute the circuit and display the results using the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下代码执行电路并显示结果：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results exactly as expected; the results are based on the initialized
    state, followed by the NOT gates being applied on all qubits:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果完全符合预期；结果是基于初始化状态，然后是所有量子比特上应用的NOT门：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also get to see the following graph:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到以下图表：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_05.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图表，柱状图  自动生成的描述](img/B18420_09_05.png)'
- en: 'Figure 9.5: Results of the initialized circuit with X gate applied to all qubits'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：对所有量子比特应用X门后的初始化电路的结果
- en: The Aer simulator’s ability to be very flexible and configurable means that
    creating custom circuits with the ability to initialize qubit states is quite
    an advantage. We will see this in more detail in *Chapter 12*, *Understanding
    Quantum Algorithms*, where we will see how this is applied to variational or other
    hybrid quantum algorithms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Aer模拟器的灵活性和可配置性意味着能够创建具有初始化量子比特状态能力的自定义电路是一个很大的优势。我们将在第12章“理解量子算法”中更详细地看到这一点，我们将看到这是如何应用于变分或其他混合量子算法的。
- en: Now that we are familiar with the Aer simulator, let’s move on to the statevector
    simulator and see what unique features we have available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了Aer模拟器，让我们继续介绍状态向量模拟器，看看我们有哪些独特的功能可用。
- en: Running circuits on the statevector simulator
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在状态向量模拟器上运行电路
- en: The **statevector simulator**, like the Aer simulator, allows you to initialize
    and execute a quantum circuit. There are of course some distinct differences,
    one of which is that it returns the state vector of the quantum circuit by executing
    a single shot. This allows you to capture a snapshot of the state vector so you
    can, in some sense, calculate or observe the expected results on the qubits. Because
    the statevector simulator simulates the ideal execution of a quantum circuit and
    results in the final quantum state vector of the device at the end of a simulation,
    this result can then be used for debugging or educational purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态向量模拟器**，就像Aer模拟器一样，允许您初始化和执行量子电路。当然，有一些明显的区别，其中之一是它通过单次执行返回量子电路的状态向量。这允许您捕获状态向量的快照，以便您可以在某种程度上计算或观察量子比特上的预期结果。因为状态向量模拟器模拟了量子电路的理想执行，并在模拟结束时产生设备的最终量子状态向量，所以这个结果可以用于调试或教育目的。'
- en: 'We will also leverage some of the Aer visualization tools to help display the
    state information of the qubits and the quantum circuit. We will follow the next
    steps to do so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用一些Aer可视化工具来帮助显示量子比特和量子电路的状态信息。我们将按照以下步骤进行：
- en: 'To begin, let’s create a simple 1-qubit circuit and add a Hadamard gate to
    it so we have a qubit in a superposition:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个简单的1量子比特电路，并向其中添加一个Hadamard门，以便我们有一个处于叠加态的量子比特：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result of this is as follows, where we have a single qubit in a superposition,
    that is, a complex linear combination of ![](img/B18420_05_004.png) and ![](img/B18420_05_005.png):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下，我们有一个处于叠加态的单个量子比特，即 ![img/B18420_05_004.png](img/B18420_05_004.png) 和 ![img/B18420_05_005.png]
    的复数线性组合：
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_06.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，时钟  自动生成的描述](img/B18420_09_06.png)'
- en: 'Figure 9.6: Single qubit circuit with a Hadamard gate'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：具有Hadamard门的单个量子比特电路
- en: 'Next, we want to see the state vector representation of the circuit. Before
    coding it, let’s review the mathematics around it. We know that each basis state
    is represented by state vectors, such as the following for the ![](img/B18420_05_004.png)
    state:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想查看电路的状态向量表示。在编码之前，让我们回顾一下相关的数学知识。我们知道每个基态都由状态向量表示，例如以下为![](img/B18420_05_004.png)状态的状态向量：
- en: '![](img/B18420_05_007.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_05_007.png)'
- en: 'Similarly, the ![](img/B18420_05_005.png) state can be represented by a state
    vector as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，![](img/B18420_05_005.png)状态可以用以下状态向量表示：
- en: '![](img/B18420_09_017.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_09_017.png)'
- en: 'The initial state of a qubit is ![](img/B18420_05_004.png). The Hadamard gate
    generally applies the Hadamard matrix to the current state of the qubit, which
    places the qubit into a superposition state. Therefore, if a Hadamard gate is
    applied to a qubit in the state ![](img/B18420_05_004.png) the operation would
    be as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子比特的初始状态为 ![](img/B18420_05_004.png)。Hadamard门通常将Hadamard矩阵应用于量子比特的当前状态，从而使量子比特处于叠加态。因此，如果将Hadamard门应用于处于![](img/B18420_05_004.png)状态的量子比特，操作如下：
- en: '![](img/B18420_09_020.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_09_020.png)'
- en: 'Multiplying the matrix by the vector results in the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵乘以向量得到以下结果：
- en: '![](img/B18420_09_021.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_09_021.png)'
- en: 'Now, let’s execute our circuit using the state vector simulator and output
    the state vector values:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用状态向量模拟器执行我们的电路，并输出状态向量值：
- en: '[PRE21]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the results, we can obtain the state vector of the quantum circuit by simply
    extracting it from the `Job` object, in this case, `result.get_statevector()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以通过简单地从`Job`对象中提取它来获得量子电路的状态向量，在这种情况下，`result.get_statevector()`。
- en: 'This should result in the following output that correctly matches our expected
    results, which include the state vector matrix dimension information, and where
    the amplitude values in the results are exactly ![](img/B18420_09_022.png). Furthermore,
    if we square the amplitudes, the results will provide us with the probability
    of obtaining a 0 or a 1\. The statevector results represent the expected results
    when applying a Hadamard to an initial state vector ![](img/_eqn_023.png) as we
    described in step 3:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下输出，正确匹配我们的预期结果，包括状态向量矩阵维度信息，并且结果中的振幅值正好是![](img/B18420_09_022.png)。此外，如果我们平方振幅，结果将为我们提供获得0或1的概率。状态向量结果表示当我们按照第3步中描述的将Hadamard应用于初始状态向量![](img/_eqn_023.png)时预期的结果：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s extend this by adding another qubit in superposition:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个叠加量子比特来扩展这个例子：
- en: '[PRE23]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result of this circuit is similar to the previous, just with an addition
    of an added qubit:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路的结果与之前类似，只是增加了一个额外的量子比特：
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_07.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，时钟  描述自动生成](img/B18420_09_07.png)'
- en: 'Figure 9.7: Two qubits in superposition'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：两个叠加的量子比特
- en: 'Let’s run this circuit using the state vector simulator and print out the results
    of our state vector:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用状态向量模拟器运行这个电路，并打印出我们状态向量的结果：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following output, which represents equal amplitudes for
    all 4 possible states, ![](img/B18420_09_023.png), and ![](img/B18420_09_005.png):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下输出，表示所有4种可能状态具有相等的振幅，![](img/B18420_09_023.png)，和![](img/B18420_09_005.png)：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, if we square each of the values to obtain the probability measurements,
    we will see that each has a 25% probability of being correct. Recall that all
    probabilities must add up to 1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们对每个值进行平方以获得概率测量，我们会看到每个都有25%的正确概率。回想一下，所有概率的总和必须为1。
- en: 'Finally, let’s entangle the qubits and see what the state vector results would
    be when applying a Hadamard gate to the first qubit:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将量子比特纠缠起来，看看当我们对第一个量子比特应用Hadamard门时，状态向量结果会是什么：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The state vector results are as expected, with equal amplitude values of ![](img/B18420_09_025.png)
    for 00 and 11, and no values ![](img/B18420_09_026.png) for the states 01 and
    10:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 状态向量结果符合预期，00和11的振幅值相等，01和10状态没有值![](img/B18420_09_026.png)：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also seek the aid of the visualization tools to help illustrate the
    state vector results for the circuit we just executed. We will add the `plot_state_city`
    vector function:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以寻求可视化工具的帮助，以帮助我们说明我们刚刚执行的电路的状态向量结果。我们将添加`plot_state_city`向量函数：
- en: '[PRE28]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The results are the same values we saw earlier, only here we can see the amplitudes
    of both the real (left) and imaginary (right) components. When we square the amplitudes
    of our result, we will get a 50% probability for the 00 and 11 states, which is
    what we see in the following state vector plot. A state city plot is a term used
    to describe a view of a 3D bar graph (typically two-dimensional). The term is
    taken as the bar graphs on the 2D plot look like buildings in a city. In this
    case, we have two: one to represent the real values and another to represent the
    imaginary values of our state vectors.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in our results, we did not have any value in any of the imaginary
    components of our state vector `1.`+`0.j`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – State vector plot with real (left) and imaginary (right) components
    ](img/B18420_09_08.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: State vector plot with real (left) and imaginary (right) components'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The state vector plot helps visualize the density matrix of 2-qubits, which
    itself has 16 complex qubit amplitudes. The topic of density matrices is outside
    the scope of this book but in short, it is generally an alternative to express
    all the quantum states such as ![](img/_eqn_028.png) and ![](img/_eqn_029.png),
    where this is the same with respect to the expected measurement outcome but allows
    us to describe these mathematically using the density matrix.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Details describing the density matrix and how it is used can be found in the
    documentation here: [https://docs.quantum.ibm.com/api/qiskit /qiskit.quantum_info.DensityMatrix](https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.DensityMatrix).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The state vector plot isn’t the only visualization tool we have available. Another
    great tool available is the **Qiskit qsphere**. This plots the state vector onto
    a two-dimensional graph and includes unique visualization features that allow
    you to see the probabilistic results and the phase when squaring the amplitudes
    of the state vector.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot the probabilistic results from the same state vector on a qsphere:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s review the results and how they are displayed in the qsphere:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart  Description automatically generated](img/B18420_09_09.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Qsphere representation of the results after squaring the state
    vector results'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: First, notice the vectors point to the north ![](img/B18420_05_004.png) state
    and south ![](img/B18420_05_005.png) state with the spheres at the end of each
    vector having equal diameters. This is to illustrate that there is an equal probability
    that the result will either be a 0 or 1, hence they are in superposition, as expected.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the color of each sphere matches the color corresponding to the phase
    of the state as described in the phase wheel located at the bottom right of the
    qsphere. This indicates that each vector is in phase (0°), which corresponds to
    a blue color. The results here match the expected equation we derived earlier,
    where we are placing the qubit in a superposition state; however, we have not
    applied any phase rotations, which are rotations around the *Z*-axis in this case:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，每个球体的颜色与状态轮中描述的状态对应的颜色相匹配，该状态轮位于qsphere的右下角。这表明每个向量处于相位（0°），对应蓝色。这里的结果与我们之前推导出的预期方程相符，其中我们将量子比特置于叠加态；然而，我们尚未应用任何相位旋转，在这种情况下是围绕*Z*轴的旋转：
- en: '![](img/B18420_09_029.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_09_029.png](img/B18420_09_029.png)'
- en: 'Let’s do something interesting by introducing a phase shift. As we saw in the
    preceding screenshot, the vector moves from |0⟩ to |+⟩ in phase (0°) when we apply
    the Hadamard gate. We’ll now include a Z gate, also known as a phase gate, which
    rotates the vector by an angle of ![](img/B18420_09_030.png) around the *z* axis.
    As before, we’ll review the mathematics first to confirm what we should expect
    to see. Recall earlier how we described the effects of applying the Hadamard gate
    when the state vector originates from |0ñ. The following applies the Hadamard
    gate to the |1ñ state:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过引入相位偏移来做些有趣的事情。正如我们在前面的屏幕截图中所见，当我们应用H门时，向量从|0⟩移动到|+⟩，相位为（0°）。现在我们将包括一个Z门，也称为相位门，它将向量绕*z*轴旋转![img/B18420_09_030.png](img/B18420_09_030.png)的角度。和之前一样，我们首先回顾一下数学，以确认我们应该期待看到什么。回想一下，当状态向量起源于|0ñ时，我们如何描述应用H门的效果。以下是将H门应用于|1ñ状态的情况：
- en: '![](img/B18420_09_031.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_09_031.png](img/B18420_09_031.png)'
- en: 'Multiplying the matrix with the vector results produces the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵与向量相乘的结果如下：
- en: '![](img/B18420_09_032.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_09_032.png](img/B18420_09_032.png)'
- en: 'We will create a circuit originating from the ![](img/B18420_05_005.png) state
    and apply the H gate to it to confirm the preceding vector results:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个起源于![img/B18420_05_005.png](img/B18420_05_005.png)状态的电路，并对其应用H门以确认前面的向量结果：
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The resulting qsphere now has the same probability as before; however, since
    the rotation originated from the ![](img/B18420_09_034.png) state, it is now at
    the ![](img/B18420_09_035.png) side, therefore out of phase by ![](img/B18420_09_030.png),
    which we can confirm by observing the following phase color chart (note that the
    color representations might change over time. Just compare the color to the color
    phase wheel for value to color mapping):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果qsphere现在与之前相同的概率；然而，由于旋转起源于![img/B18420_09_034.png](img/B18420_09_034.png)状态，它现在位于![img/B18420_09_035.png](img/B18420_09_035.png)侧，因此相位差为![img/B18420_09_030.png](img/B18420_09_030.png)，我们可以通过观察以下相位颜色图来确认（请注意，颜色表示可能会随时间变化。只需将颜色与颜色相位轮进行比较，以确定颜色到颜色的映射）：
- en: '![Chart, radar chart  Description automatically generated](img/B18420_09_10.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图表，雷达图  自动生成的描述](img/B18420_09_10.png)'
- en: 'Figure 9.10: A superposition state that is also out of phase by an angle of
    ![](img/B18420_09_030.png)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：一个相位差为![img/B18420_09_030.png](img/B18420_09_030.png)的叠加态
- en: 'Now, let’s try the same thing, this time originating from the ![](img/B18420_09_039.png)state:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试相同的事情，这次起源于![img/B18420_09_039.png](img/B18420_09_039.png)状态：
- en: '[PRE31]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The results, as we can see, are the same – there is a relative phase difference
    of ![](img/B18420_09_030.png) between the two states, ![](img/B18420_09_039.png)
    and ![](img/B18420_09_034.png) :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，正如我们所看到的，是相同的——两个状态![img/B18420_09_039.png](img/B18420_09_039.png)和![img/B18420_09_034.png](img/B18420_09_034.png)之间存在![img/B18420_09_030.png](img/B18420_09_030.png)的相对相位差。
- en: '![Chart, radar chart  Description automatically generated](img/B18420_09_11.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图表，雷达图  自动生成的描述](img/B18420_09_11.png)'
- en: 'Figure 9.11: A state vector in superposition and out of phase by ![](img/B18420_09_030.png)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：一个叠加态且相位差为![img/B18420_09_030.png](img/B18420_09_030.png)的状态向量
- en: 'We can see that the state vector representation illustrates what we see mathematically,
    which is the following in this case:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，状态向量表示说明了我们在数学上看到的内容，在这种情况下如下所示：
- en: '![](img/B18420_09_042.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![img/B18420_09_042.png](img/B18420_09_042.png)'
- en: From the preceding equation, the negative value represents the out-of-phase
    component. We will see later on how various quantum algorithms leverage this in
    order to take advantage of the effects of interference in *Chapter 12*, *Understanding
    Quantum Algorithms*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的方程中，负值表示相位差分量。我们将在第12章“理解量子算法”中看到，各种量子算法如何利用这一点来利用干涉效应。
- en: So far, we have seen that we can obtain and visualize the quantum state information
    from our quantum circuits using the state vector simulator. This allows us to
    determine whether the state of our circuit is what we are expecting, which helps
    when we are trying to debug the results of our circuit. We can also visually inspect
    our quantum circuits using various graphs to review information such as the density
    matrix and the probabilistic results based on the results from our state vector.
    Next, we will look at how we can obtain the unitary matrix of our circuit by leveraging
    the unitary simulator.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以使用状态向量模拟器从我们的量子电路中获取和可视化量子状态信息。这使我们能够确定我们的电路状态是否是我们所期望的，这在尝试调试电路的结果时很有帮助。我们还可以使用各种图表来检查我们的量子电路，以审查如密度矩阵和基于状态向量结果的概率结果等信息。接下来，我们将探讨如何通过单元模拟器获取我们电路的单元矩阵。
- en: Running circuits on the unitary simulator
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单元模拟器上运行电路
- en: 'The **unitary simulator** provides the construction of the unitary matrix,
    **U**, of the circuit. The unitary matrix is the operator representation of your
    quantum circuit, which allows you to determine whether the circuit represents
    an operator you are either trying to replicate or create. The unitary simulator
    builds out the unitary matrix by stepping through the circuit and applying each
    gate to the initial state of the circuit. As described in the API documentation
    ([https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html)),
    the semantic validations will verify the constraints of the **qobj** and backend
    options, which are as described as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元模拟器**提供了构建电路的单元矩阵**U**。单元矩阵是量子电路的操作符表示，它允许你确定电路是否代表你试图复制或创建的操作符。单元模拟器通过遍历电路并应用每个门到电路的初始状态来构建单元矩阵。如API文档([https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html](https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.UnitarySimulator.html))所述，语义验证将验证**qobj**和后端选项的约束，具体如下：'
- en: The number of shots is set to 1, so only a single shot will be run to calculate
    the unitary matrix.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击次数设置为1，因此将只运行一次以计算单元矩阵。
- en: The circuit cannot contain any resets or measurements. Since the unitary simulator’s
    job is to just calculate the unitary matrix, there is no need to determine the
    measurement of the circuit.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路不能包含任何重置或测量。由于单元模拟器的任务只是计算单元矩阵，因此没有必要确定电路的测量。
- en: No noise models can be applied as it would require working with non-unitaries.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能应用任何噪声模型，因为这需要与非单元一起工作。
- en: If the circuit goes beyond any of the preceding constraints, it will raise an
    `AerError`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果电路超出任何先前的约束，它将引发一个`AerError`。
- en: 'We will leverage the same circuit we created earlier for the state vector example
    to run through our unitary simulator so we can compare and contrast the results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用之前为状态向量示例创建的相同电路来运行单元模拟器，以便我们可以比较和对比结果：
- en: 'First, let’s validate what we should expect to see mathematically. As we will
    be applying a single Hadamard gate, it should be fairly simple to determine the
    unitary matrix. Starting from the initial state, we will apply an H gate to the
    circuit:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们验证我们应该在数学上期望看到什么。由于我们将应用单个Hadamard门，因此确定单元矩阵应该相当简单。从初始状态开始，我们将对电路应用一个H门：
- en: '![](img/B18420_09_043.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_09_043.png)'
- en: 'Now, we will run our circuit on the unitary simulator, where we will create
    a quantum circuit and add a Hadamard gate, then set the simulator to the unitary
    simulator provided by Aer. We should expect to see the same result:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将我们的电路运行在单元模拟器上，我们将创建一个量子电路并添加一个Hadamard门，然后将模拟器设置为Aer提供的单元模拟器。我们应该看到相同的结果：
- en: '[PRE32]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Your unitary results should match the results we calculated mathematically;
    you can ignore the significantly small numbers in the imaginary component:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的单元结果应该与我们通过数学计算得到的结果相匹配；你可以忽略虚部中的显著小的数字：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s create another circuit, only this time, let’s apply a phase shift
    after placing our circuit into a superposition. Let’s do this by adding a Z phase
    gate after the H gate:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个电路，但这次，在我们将电路放入叠加态之后，让我们应用一个相移。让我们通过在H门之后添加一个Z相移门来实现这一点：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will produce the following unitary matrix representation of the quantum
    circuit we created. Note the difference in the signs:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生我们创建的量子电路的以下单元矩阵表示。注意符号的差异：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will also give us the following circuit diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将给我们以下电路图：
- en: '![A picture containing text, clock  Description automatically generated](img/B18420_09_12.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、时钟的图片，描述自动生成](img/B18420_09_12.png)'
- en: 'Figure 9.12: 2-gate circuit applying an H gate followed by a Z gate'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：应用H门后跟Z门的2门电路
- en: We can confirm this using a bit of linear algebra. One thing to note is that
    when we apply gates on a circuit and visualize them, we generally apply them from
    left to right, as illustrated in the preceding circuit diagram, where we see the
    **H** gate first, followed by the **Z** gate.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些线性代数来确认这一点。需要注意的是，当我们对电路上的门进行操作并可视化它们时，我们通常从左到右应用它们，如前一个电路图所示，其中我们首先看到**H**门，然后是**Z**门。
- en: 'However, when calculating the unitary matrix, we place the unitary matrices
    of each gate we add from right to left. This is the order for the writing convention
    used to describe the order of applying operations onto an initial state. For example,
    in this circuit, we calculated the unitary matrix in the following order: first
    applying the H gate, then the Z gate, so from right to left this results in **ZH
    = U**, where **U** is the unitary matrix solution. Let’s calculate this matrix
    now:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在计算幺正矩阵时，我们将每个添加的门从右到左放置幺正矩阵。这是描述将操作应用于初始状态顺序的书写惯例的顺序。例如，在这个电路中，我们按照以下顺序计算了幺正矩阵：首先应用H门，然后是Z门，因此从右到左结果是**ZH
    = U**，其中**U**是幺正矩阵解。现在让我们计算这个矩阵：
- en: '![](img/B18420_09_044.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18420_09_044.png)'
- en: As you can see from the preceding equation, we have now confirmed that it is
    the same result we received from the unitary simulator for this circuit.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个方程所示，我们现在已经确认了这是我们从该电路的幺正模拟器获得的相同结果。
- en: 'As with the previous simulators, we can also initialize the unitary simulator
    with a given unitary matrix. Let’s use the results from the previous example as
    our initial unitary matrix:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的模拟器一样，我们也可以使用给定的幺正矩阵初始化幺正模拟器。让我们使用之前示例的结果作为我们的初始幺正矩阵：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The results from the initialized circuit are now the same as the previous circuit,
    without the need to add any of the gates used to generate this unitary matrix.
    The output result is represented as a unitary operator:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化电路的结果现在与之前的电路相同，无需添加任何用于生成该幺正矩阵的门。输出结果表示为一个幺正算子：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We’ve seen how the unitary simulator is an exceptional component to use should
    you wish to experiment using a predefined unitary matrix. Using the unitary simulator,
    we learned how to calculate the unitary operator from a given quantum circuit,
    and how to create a circuit from a unitary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了幺正模拟器是一个在你想使用预定义的幺正矩阵进行实验时非常出色的组件。使用幺正模拟器，我们学习了如何从给定的量子电路中计算幺正算子，以及如何从幺正矩阵创建电路。
- en: Now that we have a better understanding of the various simulators and the differences
    between them, we’ll use them to simulate some of the noise we get when running
    a circuit on a real quantum device. You’ve also learned about the various options
    and parameters each simulator has available to you so you can leverage each one
    in multiple ways to obtain various results, such as count and state vector information,
    from the provided quantum circuit. This will help simulate the results from circuits
    where noise models affect the outcome, as opposed to the results from running
    on an ideal, noiseless simulator. So, let’s generate the noise models in the next
    section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对各种模拟器和它们之间的差异有了更好的理解，我们将使用它们来模拟在真实量子设备上运行电路时获得的噪声。你还了解了每个模拟器提供的各种选项和参数，这样你就可以以多种方式利用每个模拟器来获得各种结果，例如计数和状态向量信息，从提供的量子电路中获取。这将有助于模拟噪声模型影响结果的电路结果，而不是在理想、无噪声模拟器上运行的结果。因此，让我们在下一节中生成噪声模型。
- en: Accounting for noise in quantum circuits
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑量子电路中的噪声
- en: Noise models are used to represent various noise effects that cause errors in
    quantum circuits. The origin of the noise stems from many sources within the quantum
    system. Based on the currently available devices and those coming in the near
    future, the number of errors on a device could be significant, depending on the
    quantum circuit executed on them.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 噪声模型用于表示导致量子电路中错误的多种噪声效应。噪声的来源来自量子系统内的许多来源。根据目前可用的设备和即将到来的设备，设备上的错误数量可能会很大，这取决于在它们上执行的量子电路。
- en: In this section, we will review the various types of errors that can affect
    a qubit, gates, and readouts. We will also learn how to generate noise models
    either based on the configuration information from the real devices, or noise
    models created by ourselves, with which we can simulate the real devices using
    the Aer simulators.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾可能影响量子比特、门和读出的各种错误类型。我们还将学习如何根据真实设备的配置信息生成噪声模型，或者创建我们自己生成的噪声模型，以便使用Aer模拟器模拟真实设备。
- en: Implementing an Aer noise model
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Aer噪声模型
- en: 'We’ll begin by demonstrating how to implement the various types of noise models
    that are prebuilt in the Aer noise libraries that will help make our experiments
    seem more realistic:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示如何实现Aer噪声库中预构建的各种类型的噪声模型，这将有助于使我们的实验看起来更加真实：
- en: 'We’ll create the same simple circuit we have used in most of our examples,
    the Bell state, which includes a Hadamard and CNOT gate, followed by a set of
    measurement operators, and execute it on an ideal simulator, with no errors. This
    should result in the expected values of 00 and 11:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建我们在大多数示例中使用的相同简单电路，即贝尔态，它包括一个Hadamard门和一个CNOT门，随后是一组测量算子，并在理想模拟器上执行，没有错误。这应该会产生预期的值00和11：
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The results from this circuit on an ideal simulator are as follows. Notice
    we only obtain two values, 00 and 11, as expected:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想模拟器上运行此电路的结果如下。请注意，我们只获得了预期的两个值，00和11：
- en: '![Figure 10.14 – Results from an ideal simulator with no effects of noise ](img/B18420_09_13.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 无噪声效果的理想模拟器结果](img/B18420_09_13.png)'
- en: 'Figure 9.13: Results from an ideal simulator with no effects of noise'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：无噪声效果的理想模拟器结果
- en: 'Now we will execute the same circuit on an actual device instead of a simulator.
    To save time, let’s find the least busy device that has enough qubits to run our
    experiment as well. Keep in mind the time to complete this on a quantum system
    may vary depending on your position in the queue:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在一个实际设备上而不是模拟器上执行相同的电路。为了节省时间，让我们找到最不繁忙且拥有足够量子比特来运行我们的实验的设备。请注意，在量子系统上完成此操作的时间可能会根据您在队列中的位置而有所不同：
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The results are very similar to that of the earlier execution on the simulator,
    only this time, notice there are some errors in the results. Rather than only
    obtaining results of **0** and **3**, we see a few instances of **1** and **2**.
    These are the effects of backend noise on the results of the circuit:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与之前在模拟器上的执行结果非常相似，但这次，请注意结果中存在一些错误。我们不仅获得了**0**和**3**的结果，还看到了一些**1**和**2**的实例。这是后端噪声对电路结果的影响：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let’s do something interesting. Let’s make use of a noise model based on
    the properties of a specific backend device. Aer’s `NoiseModel` provides the ability
    to do this with a simple method call.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们做一些有趣的事情。让我们利用基于特定后端设备特性的噪声模型。Aer的`NoiseModel`提供了通过简单方法调用来实现这一点的功能。
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following plot of the results of the preceding code, as you can see, is
    not as ideal as before. We can observe a few errors here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面代码结果的以下图表并不像之前那样理想。我们可以在这里观察到一些错误：
- en: '![Figure 10.16 – Results from a simulator with noise effects based on a specified
    backend ](img/B18420_09_14.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 基于指定后端噪声效果的模拟器结果](img/B18420_09_14.png)'
- en: 'Figure 9.14: Results from a simulator with noise effects based on a specified
    backend'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：基于指定后端噪声效果的模拟器结果
- en: Now that we can simulate the effects of noise from a backend system onto a simulator,
    let’s develop an understanding of what the cause is of some of these noise effects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够模拟后端系统对模拟器产生的噪声效果，让我们来了解这些噪声效应的成因。
- en: Tracing the source of noise
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪噪声来源
- en: When executing quantum circuits on a real device, there are various effects
    that can cause errors in our computations. In this section, we will review some
    of those effects so that when you’re generating or building your noise models,
    you will have a better understanding of how they affect each qubit.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际设备上执行量子电路时，会有各种效应导致我们的计算出现错误。在本节中，我们将回顾这些效应中的一些，以便在您生成或构建噪声模型时，您将更好地理解它们如何影响每个量子比特。
- en: Understanding decoherence
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解退相干
- en: '**Decoherence** is defined as the loss of quantum coherence due to a quantum
    system’s physical interaction with its environment. Decoherence affects each qubit
    in many ways, one of which is when each qubit starts in a ![](img/B18420_05_004.png)
    ground state, and we operate on the qubit to move it from the ![](img/B18420_05_004.png)
    state to the ![](img/B18420_05_004.png) state. For example, we say the qubit has
    transitioned from the ground state, ![](img/B18420_05_004.png), to the excited
    state, ![](img/B18420_05_004.png). An analogy for this is to think of yourself
    sitting peacefully and perfectly at rest. This peaceful relaxed moment is you
    in the ground state.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**退相干**是指由于量子系统与其环境的物理相互作用而导致的量子相干性的丧失。退相干以多种方式影响每个量子位，其中之一是当每个量子位从 ![img/B18420_05_004.png](img/B18420_05_004.png)
    基态开始时，我们对量子位进行操作，将其从 ![img/B18420_05_004.png](img/B18420_05_004.png) 状态移动到 ![img/B18420_05_004.png](img/B18420_05_004.png)
    状态。例如，我们说量子位已经从基态 ![img/B18420_05_004.png](img/B18420_05_004.png) 转变到激发态 ![img/B18420_05_004.png](img/B18420_05_004.png)。对此的一个类比是想象你自己安静地、完美地静止坐着。这个平静的放松时刻就是你处于基态时的状态。'
- en: Then, imagine someone jumping out of nowhere and screaming at you! You’re immediately
    startled as your heart rate jumps up and your adrenaline kicks in. This is you
    now in the excited state. Now, after telling the person who startled you to never
    do that again, you manage to catch your breath and get your heart rate down. You
    begin to relax and get your body back down to the grounded state it was in before.
    The time required to change from the excited state to the grounded state is, coincidentally,
    called the style **relaxation time**. Of course, one very important thing to note
    is that while it is ideal for us as humans to quickly get back to our relaxed
    state, for a quantum system, it is ideal for this time to stay in the set state
    for as long as possible. This will ensure that whichever state we place a qubit
    in, it maintains that state as long as possible.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，想象一下有人突然从某个地方跳出来对你大喊！你的心率立刻上升，肾上腺素激增，你立刻感到震惊。这就是你现在处于兴奋状态的你。现在，在告诉那个吓到你的人不要再这样做之后，你设法喘过气来，将心率降下来。你开始放松，让你的身体回到之前那种稳定的地面状态。从兴奋状态到稳定状态所需的时间，巧合地被称为**弛豫时间**。当然，对我们人类来说，快速回到放松状态是理想的，但对于量子系统来说，理想的情况是尽可能长时间地保持设定的状态。这将确保我们放置在任意状态的量子位尽可能长时间地保持该状态。
- en: The relaxation time, denoted as **T**[1], is the time constant of the longitudinal
    loss (oriented along the *z* axis) of the signal intensity. Another decoherence
    effect is **dephasing**, denoted as **T**[2], where the phase information spreads
    out widely so that the phase information is lost. We will cover details on how
    the information is lost in the next chapter. An example of this is if we set the
    qubit to the ![](img/B18420_09_050.png) state. The dephasing time is a decay constant
    time where the initial state decays down to a mixed state of ![](img/B18420_09_050.png)
    and ![](img/B18420_09_052.png), where it is difficult to predict the state of
    the system and is not perfectly in a superposition state and tends to collapse.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 弛豫时间，表示为 **T**[1]，是信号强度纵向损失（沿 *z* 轴方向）的时间常数。另一种退相干效应是**去相位**，表示为 **T**[2]，其中相位信息广泛扩散，以至于相位信息丢失。我们将在下一章中详细介绍信息丢失的细节。一个例子是，如果我们将量子位设置为
    ![img/B18420_09_050.png](img/B18420_09_050.png) 状态。去相位时间是一个衰减常数时间，其中初始状态衰减到 ![img/B18420_09_050.png](img/B18420_09_050.png)
    和 ![img/B18420_09_052.png](img/B18420_09_052.png) 的混合状态，在这种情况下，很难预测系统的状态，并且系统并不完全处于叠加态，而是倾向于坍缩。
- en: 'There are two ways to measure T[1] and T[2] decoherence times:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 测量 T[1] 和 T[2] 的退相干时间有两种方法：
- en: To measure T[1], you would apply a series of pulses separated by a fixed time
    delay and capture the statistical results of the state as it moves from ![](img/B18420_05_004.png)to
    ![](img/B18420_05_005.png). The oscillations that show up in the measurements
    after applying pulses of varying lengths or amplitudes are called **Rabi oscillations**.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测量 T[1]，你需要施加一系列间隔固定时间延迟的脉冲，并捕捉状态从 ![img/B18420_05_004.png](img/B18420_05_004.png)
    到 ![img/B18420_05_005.png](img/B18420_05_005.png) 变化时的统计结果。在施加不同长度或幅度的脉冲后，测量中出现的振荡被称为**拉比振荡**。
- en: To measure T[2], you would set the state of the qubit to ![](img/B18420_09_050.png)
    or ![](img/B18420_09_052.png), and then apply ![](img/B18420_06_041.png) pulses
    at sequences to apply a phase rotation. After applying a particular sequence of
    pulses over time, the state should return to its original position, that is, ![](img/B18420_09_050.png)
    or ![](img/B18420_09_052.png). If dephasing occurs, then the result will have
    a lower probability of returning to its original starting position. This technique
    of measuring T[2] is called a **spin echo**.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测量 T[2]，你需要将量子比特的状态设置为 ![](img/B18420_09_050.png) 或 ![](img/B18420_09_052.png)，然后按照序列应用
    ![](img/B18420_06_041.png) 脉冲以施加相位旋转。在经过一段时间应用特定的脉冲序列后，状态应该返回到其原始位置，即 ![](img/B18420_09_050.png)
    或 ![](img/B18420_09_052.png)。如果发生去相位，那么结果返回其原始起始位置的概率将降低。这种测量 T[2] 的技术被称为**自旋回波**。
- en: 'Now that we are a bit more familiar with the sources of noise, let’s shift
    our discussion to the contributors to decoherence and how they vary based on their
    sources. There are generally two source types – **intrinsic** and **extrinsic**:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对噪声的来源有了一些了解，让我们将讨论转向导致退相干的因素以及它们如何根据其来源而变化。通常有两种来源类型 – **内部**和**外部**：
- en: Intrinsic noise, often regarded as generic in nature, originates from sources
    within the system, such as temperature, or defects within the system, so essentially,
    materials or defects.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部噪声通常被认为具有固有的性质，来源于系统内部，如温度或系统中的缺陷，因此基本上是材料或缺陷。
- en: Extrinsic noise originates from environmentally coupled systems such as wave
    interference, vibrations, and electromagnetic fields.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部噪声来源于环境耦合系统，如波干涉、振动和电磁场。
- en: 'Let’s run a quick example of thermal relaxation on a pair of qubits as this
    is generally intrinsic to a qubit. In the following example, we will define our
    T[1] and T[2] values in seconds and apply them to a set of basis gates for all
    qubits. These values can be set to whatever time constant you wish; the time value
    provided in the backend properties is stated as an average so it is not likely
    your results would be the same each time. One thing to note is that the parameters
    you set must be true for the following, ![](img/B18420_09_060.png), otherwise
    an error will be thrown. We’ll then run a sample circuit with these thermal relaxation
    errors to see the difference. The circuit that we will create and execute will
    be the same Bell state circuit we created earlier and ran on a simulator, so we
    can compare the results:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行一个关于一对量子比特的热弛豫的例子，因为这通常与量子比特的本质相关。在下面的例子中，我们将以秒为单位定义我们的 T[1] 和 T[2] 值，并将它们应用于所有量子比特的基门集合。这些值可以设置为任何你希望的时间常数；后端属性中提供的时间值被声明为平均值，因此你的结果可能不会每次都相同。需要注意的是，你设置的参数必须对以下内容为真，![](img/B18420_09_060.png)，否则将抛出错误。然后我们将运行一个包含这些热弛豫误差的示例电路，以查看差异。我们将创建并执行的电路将与我们之前创建并在模拟器上运行的贝尔态电路相同，因此我们可以比较结果：
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `NoiseModel` output provides a description of the noise model by indicating
    which basis gates are available, which gate instructions would be affected by
    the noise, and which basis gates errors are applied to the qubits. Keep in mind,
    that the results may vary based on available backend systems:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoiseModel` 输出通过指示哪些基门可用、哪些门指令会受到噪声的影响以及哪些基门错误应用于量子比特来描述噪声模型。请记住，结果可能会根据可用的后端系统而变化：'
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you will see, the results after executing this circuit on the simulator
    with the generated noise are not quite the same as before. In the earlier case,
    without errors, we had a very close 50/50 split between **00** and **11**. However,
    as you can see in the following screenshot, the result is more of a 75/25 split
    between **00** and **11**. This, of course, is due to the thermal relaxation error
    we added to the simulator, thus causing much of the results to encounter a relaxation
    from the excited state to the ground state, as illustrated in the following plot:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在模拟器上执行此电路并生成噪声后的结果与之前并不完全相同。在早期的情况下，没有错误，我们在 **00** 和 **11** 之间有一个非常接近的
    50/50 分割。然而，正如你在下面的屏幕截图中所看到的，结果是 **00** 和 **11** 之间大约是 75/25 的分割。这当然是由于我们添加到模拟器中的热弛豫误差，导致许多结果从激发态弛豫到基态，如下面的图表所示：
- en: '![Figure 10.17 – Results on a simulator with thermal relaxation errors ](img/B18420_09_15.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 具有热弛豫误差的模拟器结果](img/B18420_09_15.png)'
- en: 'Figure 9.15: Results on a simulator with thermal relaxation errors'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15：具有热弛豫误差的模拟器结果
- en: Both T[1] and T[2] are environmental effects that act upon the qubits and their
    ability to maintain their states. Other effects that contribute to the overall
    noise of a system are contributed by the gates that manipulate the qubits. Let’s
    look at a few of them now.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: T[1]和T[2]都是作用于量子比特及其保持状态能力的环境效应。其他对系统整体噪声有贡献的效应是由操作量子比特的门引起的。现在让我们看看其中的一些。
- en: Understanding single-gate, multi-gate, and readout errors
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解单门、多门和读出错误
- en: '**Single-gate errors** and **multi-gate errors** are generally introduced when
    a qubit is operated upon by the various gates on the system. These errors are
    based on probabilities that the gate applied to the qubit may not operate exactly
    as expected. For example, if we apply a 5% gate error probability to a single-qubit
    gate such as a NOT gate, then the result of the operation has a 5% probability
    of not resulting in the expected value. The single-gate error could be from poor
    gate fidelity, whereas the multi-gate error could be from crosstalk or spectator
    noise from neighboring qubits, or from the physical connection between the qubits.
    The Aer library has a list of noise model methods to choose from, including **Pauli
    error**, **depolarizing error**, **amplitude damping error**, and many more for
    us to use.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**单门错误**和**多门错误**通常是在量子比特被系统上的各种门操作时引入的。这些错误基于门应用于量子比特可能不会按预期精确操作的几率。例如，如果我们将5%的门错误概率应用于单个量子比特门，如NOT门，那么操作的最终结果有5%的概率不会得到预期的值。单门错误可能来自门保真度差，而多门错误可能来自相邻量子比特的串扰或旁观者噪声，或者来自量子比特之间的物理连接。Aer库提供了一系列噪声模型方法供我们选择，包括**Pauli错误**、**去极化错误**、**幅度衰减错误**等等。'
- en: Single-gate and multi-gate errors can be applied to all qubits at once using
    the `add_all_qubit_quantum_error()` method contained in the `NoiseModel` class.
    This method applies a quantum error object to the noise model for the specified
    basis gates, which is then applied to all qubits. The first argument is the quantum
    error, and the second is the list of basis gates to apply the error to.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 单门和多门错误可以使用`NoiseModel`类中的`add_all_qubit_quantum_error()`方法一次性应用于所有量子比特。此方法将量子错误对象应用于指定基门的噪声模型，然后应用于所有量子比特。第一个参数是量子错误，第二个是应用错误的基门列表。
- en: '**Readout errors** are those that occur when a measurement and acquisition
    are triggered to read out the value of the qubit. During the operations of measuring
    and acquiring the signal from the qubit, errors can exist that may interfere with
    the results of the qubit measurement. The `NoiseModel` class also has methods
    available to add readout errors to the noise model.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**读出错误**是在触发测量和获取以读取量子比特的值时发生的。在测量和获取量子比特信号的运算过程中，可能存在可能干扰量子比特测量结果的错误。《NoiseModel》类也提供了将读出错误添加到噪声模型的方法。'
- en: Let’s build our own noise model with single-qubit, multi-qubit, and readout
    errors on a circuit to observe the effects of these errors on our quantum circuit.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在电路中构建自己的噪声模型，包括单量子比特、多量子比特和读出错误，以观察这些错误对我们量子电路的影响。
- en: Building your own noise model
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自己的噪声模型
- en: There may be times when you wish to build your own custom noise models. Whether
    it’s to generate specific errors to test your error-mitigation methods or to create
    something resembling a specific device, having the ability to customize your own
    noise model is a handy feature to have available.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望构建自己的自定义噪声模型。无论是为了生成特定的错误来测试你的错误缓解方法，还是为了创建类似特定设备的东西，能够自定义自己的噪声模型是一个非常有用的功能。
- en: 'In the following steps, we will set the single- and multi-qubit errors and
    view the results. We will then set the readout errors and run them on the same
    circuit just to visualize the difference in the results when measurement errors
    are introduced to an ideal system. The single-qubit error will have an amplitude
    dampening error, the multi-qubit error will have a depolarizing error, and the
    readout error will be applied to both qubits in the circuit:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将设置单量子比特和多量子比特错误并查看结果。然后我们将设置读出错误，并在同一电路中运行它们，只是为了可视化当将测量错误引入理想系统时结果之间的差异。单量子比特错误将有一个幅度衰减错误，多量子比特错误将有一个去极化错误，读出错误将应用于电路中的两个量子比特：
- en: 'We’ll begin by defining our quantum circuit and transpiling it with the simulator:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的量子电路，并用模拟器进行编译：
- en: '[PRE45]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we’ll begin by defining the single- and multi-qubit probability error
    values, followed by initializing and setting the depolarizing errors, first to
    the single qubit, and then to the multi-qubit error:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将首先定义单比特和多比特概率错误值，然后初始化并设置去极化错误，首先是对单比特，然后是对多比特错误：
- en: '[PRE46]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will create our `NoiseModel` object and add both the single- and multi-qubit
    errors. The single qubit error will be assigned to the basis gate `u2`, and the
    multi-qubit error will be assigned to the CNOT (`cx`) gate:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的`NoiseModel`对象，并添加单比特和多比特错误。单比特错误将被分配给基门`u2`，多比特错误将被分配给CNOT（`cx`）门：
- en: '[PRE47]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We’ll now print out the `NoiseModel` to confirm out noise model entries are
    set. As we can see from the output of the noise model, we have a list of all basis
    gates available, a list of instructions that have been assigned noise, and a list
    of all the basis states that will affect all of the qubits in our circuit:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将打印出`NoiseModel`以确认我们的噪声模型条目已设置。从噪声模型的输出中我们可以看到，我们有所有可用基门的列表，有分配了噪声的指令列表，以及将影响我们电路中所有量子比特的所有基态列表：
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let’s add this to our simulator and run it with both the single and multi-qubit
    noise model:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这个错误添加到我们的模拟器中，并使用单比特和多比特噪声模型运行它：
- en: '[PRE49]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will result in the following histogram:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将导致以下直方图：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_16.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图表，条形图  自动生成的描述](img/B18420_09_16.png)'
- en: 'Figure 9.16: Results on a simulator with single and multi-qubit errors'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：具有单比特和多比特错误的模拟器结果
- en: As you can see, the errors we introduced had an effect on our results and we
    now get some unexpected values, 01 and 10, which we didn’t expect or see in our
    ideal case when running on a system with no noise. However, even with the noise,
    we can see that our results are correct in that we still have a high probability
    of the states 00 and 11\. So here, the noise is minimal so that we can get some
    good results. Let’s try a different error next and increase the noise to see what
    we get when we have very noisy readout errors.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们引入的错误对我们的结果产生了影响，我们现在得到了一些意想不到的值，01和10，这是我们之前在没有噪声的系统上运行理想情况时没有预期或看到的。然而，即使有噪声，我们也可以看到我们的结果是正确的，因为我们仍然有高概率的状态00和11。所以在这里，噪声是最小的，这样我们就可以得到一些好的结果。让我们尝试不同的错误并增加噪声，看看当我们有非常嘈杂的读出错误时我们会得到什么。
- en: 'Next, let’s include some readout errors. Readout errors are defined in the
    Aer API documentation as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们包括一些读出错误。读出错误在Aer API文档中的定义如下：
- en: '*Classical readout errors are specified by a list of assignment probabilities
    vectors P(A|B), where A is the recorded classical bit value, and B is the true
    bit value returned from the measurement.*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*经典读出错误由一个赋值概率向量列表P(A|B)指定，其中A是记录的经典比特值，B是从测量中返回的真实比特值。*'
- en: This means that the probabilities of the expected values will be recorded and
    used to apply readout errors based on the probability values we pass in as arguments
    to the noise model.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着预期值的概率将被记录并用于根据我们传递给噪声模型的概率值应用读出错误。
- en: 'The equation for a single-qubit readout probability vector is defined as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 单比特读出概率向量的方程定义如下：
- en: '![](img/B18420_09_061.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18420_09_061.png)'
- en: 'When constructing the `ReadoutError` class, P(A|B) is provided as the argument.
    For our example, we will provide the probability of 0 given 1 as `0.7`, and the
    probability of 1 given 0 as `0.2`. We will also add our readout error to the noise
    model and print out the results, as illustrated in the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建`ReadoutError`类时，P(A|B)作为参数提供。对于我们的示例，我们将提供给定1的概率为`0.7`，给定0的概率为`0.2`。我们还将把我们的读出错误添加到噪声模型中，并打印出结果，如下面的代码所示：
- en: Note, of course, that these values we are setting are very high and do not necessarily
    need to add up to 1\. I’m using them to highlight the impact noise has, in this
    case, in a very exaggerated yet visually recognizable way to see that the errors
    are actually pulling the results away from the expected values into the biased
    values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当然，我们设置的这些值非常高，并不一定需要加起来等于1。我正在使用它们来强调噪声在这种情况下对结果的影响，以一种非常夸张但视觉上可识别的方式，以证明错误实际上是将结果从预期值拉向偏差值。
- en: '[PRE50]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We will see the addition of some instructions and listings of qubits in the
    result. The first line specifies `Basis gates`, and the following line is the
    list of `Instructions with noise` added to them. Notice that it now only includes
    the `measure` instruction. Next, we see the qubits that have been specified for
    a particular noise – in this case, we added the readout error to all qubit measurement
    operators:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在结果中看到一些指令和量子比特的列表。第一行指定了`基本门`，下一行是添加了`带噪声的指令`的列表。请注意，现在它只包括`测量`指令。接下来，我们看到指定了特定噪声的量子比特——在这种情况下，我们向所有量子比特的测量算子添加了读出错误：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that we have our readout noise model complete, we’ll add our custom noise
    model and run it on the Aer simulator to see the results.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了读出噪声模型，我们将添加我们的自定义噪声模型，并在Aer模拟器上运行它以查看结果。
- en: 'Similar to the previous example, where we included a thermal relaxation noise
    model, we will provide the readout noise model in the same manner:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前包含热弛豫噪声模型的示例类似，我们将以同样的方式提供读出噪声模型：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The results, as you can see in the following plot, are now not as ideal as
    before:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下图表中可以看到的结果，现在并不像以前那样理想：
- en: '![Chart, bar chart  Description automatically generated](img/B18420_09_17.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图表，条形图  自动生成的描述](img/B18420_09_17.png)'
- en: 'Figure 9.17: Result with effects from our custom noise model on a quantum circuit'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：量子电路中自定义噪声模型的效果结果
- en: We can observe various errors here, caused by the readout noise. First and foremost,
    our expected results of **00** and **11** are no longer easily visible from our
    results. In this sense, we see that the readout of each qubit has a higher probability
    of 0 given 1, which therefore causes the probability results to be higher for
    the values **00**, **01**, and **10**. This is caused by the readout errors that
    are applied to all the qubits, which greatly reduces the probability of 1.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到各种由读出噪声引起的错误。首先，我们的预期结果**00**和**11**不再容易从我们的结果中看出。从这个意义上说，我们看到每个量子比特的读出在给定1的情况下有更高的0的概率，因此导致**00**、**01**和**10**的概率结果更高。这是由于应用于所有量子比特的读出错误造成的，这大大降低了1的概率。
- en: The advantage of all this noise is that you have an insight as to the cause
    of this noise based on the type of noise we included, and the amount of noise
    applied to a specified qubit(s). This allows you to simulate certain noise effects
    should you wish to work on some noise-mitigating techniques.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些噪声的优势在于，你可以根据我们包含的噪声类型以及应用于指定量子比特（s）的噪声量，对噪声的成因有一个洞察。这允许你在希望研究一些噪声缓解技术时模拟某些噪声效果。
- en: By applying noise and understanding its effects, you can create noise-mitigating
    techniques and verify the results on a simulator. By doing this, you can test
    various combinations of noise effects, which can help minimize the error rate
    on some algorithms, and therefore increase the performance of the quantum computer.
    We will look at noise-mitigating techniques in the next chapter.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用噪声并理解其影响，你可以创建噪声缓解技术，并在模拟器上验证结果。通过这样做，你可以测试各种噪声效果的组合，这有助于降低某些算法的错误率，从而提高量子计算机的性能。我们将在下一章中探讨噪声缓解技术。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered various simulators. You now have the skills to leverage
    various simulators to simulate running circuits on a quantum computer and obtain
    specific content from the circuits, such as state vectors and unitary matrices.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种模拟器。你现在拥有了利用各种模拟器在量子计算机上模拟运行电路并从电路中获取特定内容（如状态向量和幺正矩阵）的技能。
- en: We also covered various visualization techniques. The skills that you have gained
    will help you visualize the various pieces of information from the simulator,
    such as visualizing the state and phase information of a qubit using the qsphere
    and plotting state vector graphs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了各种可视化技术。你获得的能力将帮助你可视化来自模拟器的各种信息，例如使用qsphere可视化量子比特的状态和相位信息，以及绘制状态向量图。
- en: And finally, we looked into the noise models that Qiskit provides by either
    extracting the noise from an existing quantum computer or creating our own noise
    models and applying them to the simulators.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了Qiskit提供的噪声模型，无论是从现有的量子计算机中提取噪声，还是创建我们自己的噪声模型并将其应用于模拟器。
- en: In the next chapter, we will learn how to characterize and mitigate noise. This
    will allow us to optimize the performance of the quantum computer and increase
    its computational power.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何表征和减轻噪声。这将使我们能够优化量子计算机的性能并提高其计算能力。
- en: Questions
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you list all the simulators found in the Qiskit Aer module?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能列出 Qiskit Aer 模块中找到的所有模拟器吗？
- en: Create a qsphere representation of a qubit on the negative *y* axis, creating
    the state ![](img/B18420_09_062.png), using only a single Hadamard gate along
    with the phase gates.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在负 *y* 轴上创建一个量子比特的 qsphere 表示，创建状态 ![](img/B18420_09_062.png)，仅使用一个哈达德门和相位门。
- en: When initializing a set of qubits in a circuit, what must the total probability
    across all states be?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在一个电路中初始化一组量子比特时，所有状态的总概率必须是多少？
- en: Can you use the qsphere to visualize both the phase and probability information
    of a qubit?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能使用 qsphere 可视化量子比特的相位和概率信息吗？
- en: What would happen if you set the depolarization error values close to 1?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将去极化错误值设置得接近 1，会发生什么？
- en: If you applied a readout error equally to all qubits, what results would you
    expect, and why?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将读出错误均匀地应用于所有量子比特，你期望得到什么结果，为什么？
- en: Join us on Discord
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/3FyN1](Chapter_9.xhtml)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/3FyN1](Chapter_9.xhtml)'
- en: '![](img/QR_Code2617625996838265931.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2617625996838265931.png)'
