- en: The CUDA Device Function Libraries and Thrust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA设备函数库和Thrust
- en: In the last chapter, looking at a fairly broad overview of the libraries that
    are available in CUDA through the Scikit-CUDA wrapper module. We will now look
    at a few other libraries that we will have to use directly from within CUDA C
    proper, without the assistance of wrappers like those in Scikit-CUDA. We will
    start by looking at two standard libraries that consist of device functions that
    we may invoke from any CUDA C kernel cuRAND and the CUDA Math API. By the end
    of learning how to use these libraries, we will know how to use these libraries
    in the context of Monte Carlo integration. Monte Carlo integration is a well-known
    randomized method that provides estimates for the values of definite integrals
    from calculus. We will first look at a basic example of how to implement a simple
    Monte Carlo method with cuRAND to do a basic estimate of the value of Pi (as in
    the well-known constant, π=3.14159...), and then we'll embark on a more ambitious
    project where we will construct a Python class that can perform definite integration
    on any arbitrary mathematical function, and use the Math API for creating such
    functions. We'll also look at how to effectively use some ideas from metaprogramming
    in our design of this class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过Scikit-CUDA包装模块对CUDA中可用的库进行了相当广泛的概述。现在我们将探讨一些其他库，这些库我们将直接从CUDA C本身使用，而不需要像Scikit-CUDA中的那些包装器帮助。我们将从查看两个标准库开始，这些库包含可以从任何CUDA
    C内核中调用的设备函数cuRAND和CUDA Math API。通过学习如何使用这些库，我们将了解如何在蒙特卡洛积分的上下文中使用这些库。蒙特卡洛积分是一种已知的随机方法，它提供了从微积分中确定积分值的估计。我们将首先查看一个基本示例，说明如何使用cuRAND实现一个简单的蒙特卡洛方法来对π（如众所周知的常数π=3.14159...）的值进行基本估计，然后我们将开始一个更雄心勃勃的项目，在这个项目中我们将构建一个Python类，该类可以对任何任意数学函数进行确定积分，并使用Math
    API创建这样的函数。我们还将探讨如何在设计此类时有效地使用元编程的一些想法。
- en: We will then take another look at writing some pure CUDA programs with the help
    of the Thrust C++ library. Thrust is a library that provides C++ template containers,
    similar to those in the C++ Standard Template Library (STL). This will enable
    us to manipulate CUDA C arrays from C++ in a more natural way that is closer to
    PyCUDA's `gpuarray` and the STL's vector container. This will save us from having
    to constantly use pointers, such as *mallocs* and *frees*, that plagued us before
    in CUDA C.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将再次使用Thrust C++库来编写一些纯CUDA程序。Thrust是一个提供C++模板容器的库，类似于C++标准模板库（STL）。这将使我们能够以更自然的方式操作CUDA
    C数组，这种方式更接近PyCUDA的`gpuarray`和STL的vector容器。这将使我们免于不断使用指针，如*mallocs*和*frees*，这些在之前的CUDA
    C中困扰了我们。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Understanding the purpose that a seed has in generating lists of pseudo-random
    numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解种子在生成伪随机数列表中的作用
- en: Using cuRAND device functions for generating random numbers in a CUDA kernel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CUDA内核中使用cuRAND设备函数生成随机数
- en: Understanding the concept of Monte Carlo integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解蒙特卡洛积分的概念
- en: Using dictionary-based string formatting in Python for metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用基于字典的字符串格式化进行元编程
- en: Using the CUDA Math API device function library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CUDA Math API设备函数库
- en: Understanding what a functor is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解什么是函子
- en: Using the Thrust vector container when programming in pure CUDA C
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在纯CUDA C编程中使用Thrust向量容器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A Linux or Windows 10 PC with a modern NVIDIA GPU (2016—onward) is required
    for this chapter, with all of the necessary GPU drivers and the CUDA Toolkit (9.0–onward)
    installed. A suitable Python 2.7 installation (such as Anaconda Python 2.7) with
    the PyCUDA module is also required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章内容，需要一个配备现代NVIDIA GPU（2016年及以后）的Linux或Windows 10 PC，并安装所有必要的GPU驱动程序和CUDA
    Toolkit（9.0及以后版本）。还需要一个合适的Python 2.7安装（例如Anaconda Python 2.7），并包含PyCUDA模块。
- en: This chapter's code is also available on GitHub, and can be found at [https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA.](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也托管在GitHub上，可以在[https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)找到。
- en: For more information about the prerequisites for this chapter, check the preface
    of this book. For the software and hardware requirements, check out the README
    at [https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章的先决条件，请查看本书的序言。有关软件和硬件要求，请查看[https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)中的README。
- en: The cuRAND device function library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cuRAND设备函数库
- en: Let's start with cuRAND. This is a standard CUDA library that is used for generating
    pseudo-random values within a CUDA kernel on a thread-by-thread basis, which is
    initialized and invoked by calling device functions from each individual thread
    within a kernel. Let's emphasize again that this is a **pseudo-random** sequence
    of values—since the digital hardware is always deterministic and never random
    or arbitrary, we use algorithms to generate a sequence of apparently random values
    from an initial **seed value**. Usually, we can set the seed value to a truly
    random value (such as the clock time in milliseconds), which will yield us with
    a nicely arbitrary sequence of *random* values. These generated random values
    have no correlation with prior or future values in the sequence generated by the
    same seed, although there can be correlations and repeats when you combine values
    generated from different seeds. For this reason, you have to be careful that the
    values you wish to be mutually *random* are generated by the same seed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从cuRAND开始。这是一个标准的CUDA库，用于在CUDA内核中按线程逐线程生成伪随机值，它通过在内核中的每个单独线程中调用设备函数来初始化和调用。我们再次强调，这是一个**伪随机**值序列——因为数字硬件总是确定性的，永远不会随机或任意，所以我们使用算法从一个初始的**种子值**生成一系列看似随机的值。通常，我们可以将种子值设置为真正的随机值（例如毫秒级的时钟时间），这将为我们提供一个很好的任意序列的*随机*值。这些生成的随机值与由相同种子生成的序列中的先前或未来值没有相关性，尽管当您将来自不同种子的值组合在一起时，可能会有相关性或重复。因此，您必须小心，确保您希望相互*随机*的值是由相同的种子生成的。
- en: 'Let''s start by looking at the function prototype for `curand_init`, which
    we will initialize with an appropriate seed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`curand_init`函数的原型，我们将使用适当的种子来初始化它：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, all of the inputs are unsigned long, which in C is an unsigned (non-negative
    valued) 64-bit integer. First, we can see the `seed`, which is, of course, the
    seed value. Generally speaking, you'll set this with the clock value or some variation.
    We then see a value called `sequence` and as we stated previously, values generated
    by cuRAND will only be truly mathematically mutually random if they are generated
    by the same seed value. So, if we have multiple threads using the same seed value,
    we use `sequence` to indicate which sub-sequence of random numbers of length 2^(190)
    for the current thread to use, while we use `offset` to indicate at which point
    to start within this sub-sequence; this will generate values in each thread that
    are all mathematically mutually random with no correlation. Finally, the last
    parameter is for a pointer to a `curandState_t` object; this keeps track of where
    we are in the sequence of pseudo-random numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有输入都是无符号长整型，在C语言中是无符号（非负值）的64位整数。首先，我们可以看到`seed`，当然，这是种子值。一般来说，您会使用时钟值或其变体来设置它。然后我们看到一个名为`sequence`的值，正如我们之前所述，cuRAND生成的值只有在它们由相同的种子值生成时才会真正地在数学上相互随机。因此，如果我们有多个线程使用相同的种子值，我们使用`sequence`来指示当前线程要使用的长度为2^190的随机数子序列，而使用`offset`来指示在这个子序列中的起始点；这将生成在各个线程中都是数学上相互随机且无相关性的值。最后，最后一个参数是一个指向`curandState_t`对象的指针；这跟踪我们在伪随机数序列中的位置。
- en: 'After you initialize a class object, you will then generate random values from
    the appropriate random distribution by calling the appropriate device function.
    The two most common distributions are uniform and normal (Gaussian). A uniform
    distribution (`curand_uniform`, in cuRAND) is a function that outputs values that
    are all equally probable over a given range: that is to say, for a uniform distribution
    over 0 to 1, there is a 10% chance that a value will fall between 0 and 0.1, or
    between 0.9 to 1, or between any two points that are spaced .1 away from each
    other. The normal distribution (`curand_normal`, in cuRAND) has values that are
    centered at a particular mean, which will be distributed according to the well-known
    bell-shaped curve that is defined by the distribution''s standard deviation. (The
    default mean of `curand_normal` is `0` and the standard deviation is 1 in cuRAND,
    so this will have to be shifted and scaled manually for other values.) Another
    well-known distribution supported by cuRAND is the Poisson distribution (`curand_poisson`),
    which is used for modeling the occurrences of random events over time.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化类对象之后，您将通过调用适当的设备函数来生成适当的随机分布的随机值。最常用的两种分布是均匀分布和正态分布（高斯分布）。均匀分布（在 cuRAND
    中为 `curand_uniform`）是一个在给定范围内所有值等可能输出的函数：也就是说，对于 0 到 1 的均匀分布，有 10% 的概率值将落在 0 和
    0.1 之间，或者落在 0.9 到 1 之间，或者落在彼此之间相隔 0.1 的任意两点之间。正态分布（在 cuRAND 中为 `curand_normal`）的值以特定的均值为中心，将根据分布的标准差分布，形成著名的钟形曲线。（在
    cuRAND 中，`curand_normal` 的默认均值为 `0`，标准差为 `1`，因此对于其他值需要手动进行平移和缩放。）cuRAND 还支持另一个著名的分布，即泊松分布（`curand_poisson`），用于对随机事件随时间发生的情况进行建模。
- en: We will be primarily looking at how to use cuRAND in the context of uniform
    distributions in the next section, due to their applicability to Monte Carlo integration.
    Readers interested in learning how to use more features in cuRAND are encouraged
    to look at the official documentation from NVIDIA.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将主要探讨如何在均匀分布的上下文中使用 cuRAND，因为它们适用于蒙特卡洛积分。对学习如何使用 cuRAND 的更多功能感兴趣的读者应查阅
    NVIDIA 的官方文档。
- en: Estimating π with Monte Carlo
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛估计 π
- en: First, we will apply our new knowledge of cuRAND to perform an estimate of the
    well-known mathematical constant π, or Pi, which is, of course, the never-ending
    irrational number 3.14159265358979...
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将应用我们对 cuRAND 的新知识来估计著名的数学常数 π，也就是 Pi，它当然是一个无限不循环的无理数 3.14159265358979...
- en: 'To get an estimate, though, we need to take a moment to think about what this
    means. Let''s think about a circle. Remember that the radius of a circle is the
    length from the center of the circle to any point in the circle; usually, this
    is designated with *R*. The diameter is defined as *D = 2R*, and the circumference
    *C* is the length around the circle. Pi is then defined as *π = C / D* . We can
    use Euclidean geometry to find a formula for the area of the circle, which turns
    out being *A = πR²* . Now, let''s think about a circle with radius *R* being circumscribed
    in a square with all sides of length *2R*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了得到一个估计值，我们需要花一点时间来思考这意味着什么。让我们考虑一个圆。记住，圆的半径是从圆心到圆上任何一点的长度；通常，这用 *R* 表示。直径定义为
    *D = 2R*，周长 *C* 是围绕圆的长度。π 定义为 *π = C / D*。我们可以使用欧几里得几何来找到圆面积的公式，结果为 *A = πR²*。现在，让我们考虑一个半径为
    *R* 的圆，它被一个边长为 *2R* 的正方形所包围：
- en: '![](img/310fec25-8742-4878-a6e6-e5d917ef29bc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/310fec25-8742-4878-a6e6-e5d917ef29bc.png)'
- en: 'So, of course, we know that the area of the square is *(2R)² = 4R²*. Let''s
    consider *R=1*, so that we have known that the area of the circle is exactly π,
    while the area of the square is exactly 4\. Let''s make a further assumption and
    state that both the circle and square are centered at (0,0) in the Cartesian plane.
    Now, let''s take a completely random value within the square, (*x,y*), and see
    if it falls within the circle. How can we do this? By applying the Pythagorean
    formula: we do this by checking whether *x² + y²* is less than or equal to 1\.
    Let''s designate the total number of random points we choose with *iters*, and
    the number of hits with *hits*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们知道正方形的面积是 *(2R)² = 4R²*。让我们假设 *R=1*，这样我们就知道圆的面积正好是 π，而正方形的面积正好是 4。让我们进一步假设，圆和正方形都位于笛卡尔平面上原点
    (0,0) 位置。现在，让我们在正方形内随机取一个完全随机的值 (*x,y*)，看看它是否落在圆内。我们如何做到这一点呢？通过应用勾股定理：我们通过检查 *x²
    + y²* 是否小于或等于 1 来做到这一点。让我们用 *iters* 表示我们选择的随机点的总数，用 *hits* 表示击中的数量。
- en: 'Let''s do a little bit more thinking about this: the probability of picking
    a point within the circle should be proportionate to the area of the circle divided
    by the area of the rectangle; here, this is π / 4\. However, if we choose a very
    large value of random points, notice that we will get the following approximation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对这个问题进行更多的思考：在圆内选择一个点的概率应该与圆的面积除以矩形的面积成比例；这里，这是 π / 4。然而，如果我们选择一个非常大的随机点值，请注意，我们将得到以下近似值：
- en: '![](img/36f08e8a-fac6-413e-9276-a44a18fba9a1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36f08e8a-fac6-413e-9276-a44a18fba9a1.png)'
- en: 'This is exactly how we will estimate π! The number of iterations we will have
    to do will be very high before we can come up with a decent estimate of Pi, but
    notice how nicely parallelizable this is: we can check the "hits" in different
    threads, splitting the total number of iterations among different threads. At
    the end of the day, we can just sum up the total number of hits among all of the
    threads to get our estimate.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将如何估计 π！在我们能够得到 Pi 的合理估计之前，我们必须进行非常高的迭代次数，但请注意，这非常易于并行化：我们可以在不同的线程中检查“命中”，将总迭代次数分配给不同的线程。最终，我们只需将所有线程中的总“命中”数相加，以得到我们的估计。
- en: 'We can now begin to write a program to make our Monte Carlo estimate. Let''s
    first import the usual Python modules that we will need for a PyCUDA program,
    with one addition from SymPy:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始编写一个程序来制作我们的蒙特卡洛估计。让我们首先导入我们将需要的常规 Python 模块，对于 PyCUDA 程序有一个来自 SymPy
    的附加项：
- en: SymPy is used for perfect *symbolic* computations that are to be made in Python
    so that when we have very large integers, we can use the `Rational` function to
    make a much more accurate floating-point estimate of a division.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 用于在 Python 中进行完美的 *符号* 计算，这样当我们处理非常大的整数时，我们可以使用 `Rational` 函数来对除法进行更精确的浮点估计。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we have to do something a little different than normal when we build our
    kernel: we need to set the option `no_extern_c=True` in `SourceModule`. This modifies
    how the code is compiled so that our code can properly link with C++ code, as
    required by the cuRAND library. We then begin writing our kernel and include the
    appropriate header:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建我们的内核时，我们必须做一些与正常情况略有不同的事情：我们需要在 `SourceModule` 中设置选项 `no_extern_c=True`。这修改了代码的编译方式，以便我们的代码可以正确地与
    C++ 代码链接，这是 cuRAND 库所要求的。然后我们开始编写我们的内核并包含适当的头文件：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s include a macro for the Pythagorean distance. Since we are just
    checking if this value is equal to or below `1`, we can, therefore, omit the square
    root. We will be using a lot of unsigned 64-bit integers, so let''s make another
    macro to save us from typing `unsigned long long` over and over:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们包含一个用于勾股定理距离的宏。由于我们只是检查这个值是否等于或小于 `1`，因此我们可以省略平方根。我们将使用很多无符号 64 位整数，所以让我们再定义一个宏来节省我们反复输入
    `unsigned long long`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now set up our kernel. By the nature of PyCUDA, this will have to be
    compiled to the interface as a bonafide C function rather than as a C++ function.
    We do this with an `extern "C"` block:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置我们的内核。根据 PyCUDA 的性质，这将必须编译为真正的 C 函数接口，而不是 C++ 函数。我们使用 `extern "C"` 块来完成这个操作：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now define our kernel. We will have two parameters: one for `iters`,
    which is the total number of iterations for each thread, and another for an array
    that will hold the total number of hits for each thread. We will need a `curandState`
    object for this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以定义我们的内核。我们将有两个参数：一个用于 `iters`，这是每个线程的总迭代次数，另一个用于存储每个线程的总“命中”数的数组。我们将需要一个
    `curandState` 对象来完成这个任务：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s hold the global thread ID in an integer called `tid`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将全局线程 ID 存储在一个名为 `tid` 的整数中：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`clock()` is a device function that outputs the current time down to the millisecond.
    We can add `tid` to the output of `clock()` to get a unique seed for each thread.
    We don''t need to use different subsequences or offsets, so let''s set them both
    to 0\. We will also carefully typecast everything here to 64-bit unsigned integers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock()` 是一个设备函数，它输出当前时间，精确到毫秒。我们可以将 `tid` 添加到 `clock()` 的输出中，以获得每个线程的唯一种子。我们不需要使用不同的子序列或偏移量，所以让我们将它们都设置为
    0。我们还将仔细地将所有内容类型转换为 64 位无符号整数：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s set up the `x` and `y` values to hold a random point in the rectangle:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 `x` 和 `y` 的值以保持矩形中的一个随机点：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will then iterate `iters` times to see how many hits in the circle we get.
    We generate these with `curand_uniform(&cr_state)`. Notice that we can generate
    them over 0 to 1, rather than from -1 to 1, since the squaring of these in the
    `_PYTHAG` macro will remove any negative values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将迭代`iters`次，看看我们在圆中得到了多少次击中。我们使用`curand_uniform(&cr_state)`生成这些击中。注意，我们可以从0到1生成它们，而不是从-1到1，因为这些在`_PYTHAG`宏中的平方将消除任何负值：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now end and close off our kernel, as well as the `extern "C"` block
    with another final `}` bracket:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以结束并关闭我们的内核，以及`extern "C"`块，使用另一个最终的`}`括号：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s get the Python wrapper function to our kernel with `get_function`.
    We will also set up the block and grid sizes: 32 threads per block, and 512 blocks
    per grid. Let''s calculate the total number of threads and set up an array on
    the GPU to hold all of the hits (initialized to 0s, of course):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`get_function`获取我们的内核的Python包装函数。我们还将设置块和网格的大小：每个块32个线程，每个网格512个块。让我们计算总的线程数，并在GPU上设置一个数组来存储所有的击中（当然，初始化为0）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s set up the total number of iterations per thread to 2^(24):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置每个线程的迭代总数为2^(24)：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now launch the kernel as usual:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样启动内核：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s sum over the number of hits in the array, which gives us the total
    number of hits. Let''s also calculate the total number of iterations among all
    of the threads in the array:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对数组中的击中次数进行求和，这给出了总的击中次数。我们还将计算数组中所有线程的总迭代次数：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now make our estimate with `Rational`, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用`Rational`来做出我们的估计，如下所示：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now convert this into a floating point value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个值转换为浮点数：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s check our estimate against NumPy''s constant value, `numpy.pi`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的估计与NumPy的常量值`numpy.pi`进行对比：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are now done. Let''s run this from IPython and check it out (This program
    is also available as the `monte_carlo_pi.py` file under `Chapter08` in this book''s
    repository.):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了。让我们从IPython运行这个程序并检查它（此程序也作为`monte_carlo_pi.py`文件包含在此书存储库的`Chapter08`中）：
- en: '![](img/5d4875e3-6231-4fc4-a2e2-3004f3933636.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d4875e3-6231-4fc4-a2e2-3004f3933636.png)'
- en: The CUDA Math API
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA Math API
- en: Now, we will take a look at the **CUDA Math API**. This is a library that consists
    of device functions similar to those in the standard C `math.h` library that can
    be called from individual threads in a kernel. One difference here is that single
    and double valued floating-point operations are overloaded, so if we use `sin(x)`
    where `x` is a float, the sin function will yield a 32-bit float as the output,
    while if `x` were a 64-bit double, then the output of `sin` would also be a 64-bit
    value (Usually, this is the proper name for a 32-bit function, but it has an `f`
    at the end, such as `sinf`). There are also additional **instrinsic** functions.
    Intrinsic functions are less accurate but faster math functions that are built
    into the NVIDIA CUDA hardware; generally, they have similar names to the original
    function, except that they are preceded with two underscores—therefore, the intrinsic,
    32-bit sin function is `__sinf`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看**CUDA Math API**。这是一个由与标准C `math.h`库中类似的设备函数组成的库，可以从内核中的单个线程中调用。这里的一个区别是单精度和双精度浮点运算被重载，所以如果我们使用`sin(x)`，其中`x`是一个浮点数，那么正弦函数将输出一个32位浮点数，而如果`x`是一个64位双精度数，那么`sin`的输出也将是一个64位值（通常，这是32位函数的正确名称，但它在末尾有一个`f`，例如`sinf`）。还有额外的**内建**函数。内建函数不如原始函数精确，但速度更快，是集成在NVIDIA
    CUDA硬件中的；通常，它们的名称与原始函数相似，但前面有两个下划线——因此，内建、32位正弦函数是`__sinf`。
- en: A brief review of definite integration
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定积分的简要回顾
- en: 'Now, we''re going to use some object-oriented programming in Python to set
    up a class that we can use to evaluate definite integrals of functions using a
    Monte Carlo method. Let''s stop for a moment and talk about what we mean: suppose
    we have a mathematical function (as in the type you might see in a calculus class)
    that we call *f(x)*. When we graph this out on the Cartesian plane between points
    *a* and *b*, it may look something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Python中的面向对象编程来设置一个类，我们可以使用它来评估函数的定积分，使用蒙特卡洛方法。让我们停下来谈谈我们的意思：假设我们有一个数学函数（就像你在微积分课程中可能看到的那种），我们称之为*f(x)*。当我们在这两点*a*和*b*之间的笛卡尔平面上绘制这个函数时，它可能看起来像这样：
- en: '![](img/35cc22f9-0a21-45ae-89b9-367edd83aa59.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35cc22f9-0a21-45ae-89b9-367edd83aa59.png)'
- en: Now, let's review exactly what definite integration means—let's denote the first
    gray area in this graph as *I*, the second gray area as *II*, and the third gray
    area as *III*. Notice that the second gray area here is below zero. The definite
    integral of *f* here, from *a* to *b,* will be the value *I - II + III*, and we
    will denote this mathematically as ![](img/6fbf2855-0340-4589-9e3e-a007a7276e06.png).
    In general, the definite integral from *a* to *b* is just the sum of all of the
    total "positive" area bounded by the *f* function and x-axis with y > 0 between
    *a* and *b*, minus all of the "negative" area bounded by the *f* function and
    the x-axis with y < 0 between *a* and *b*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来回顾一下定积分的确切含义——让我们将此图中第一个灰色区域表示为 *I*，第二个灰色区域表示为 *II*，第三个灰色区域表示为 *III*。注意，这里的第二个灰色区域位于零以下。*f*
    在这里的定积分，从 *a* 到 *b*，将是 *I - II + III* 的值，我们将这个数学上表示为 ![图片](img/6fbf2855-0340-4589-9e3e-a007a7276e06.png)。一般来说，从
    *a* 到 *b* 的定积分就是所有由 *f* 函数和 x 轴以及 y > 0 在 *a* 和 *b* 之间的“正”面积的总和，减去所有由 *f* 函数和
    x 轴以及 y < 0 在 *a* 和 *b* 之间的“负”面积。
- en: 'There are many ways to calculate or estimate the definite integral of a function
    between two points. One that you may have seen in a calculus class is to find
    a closed-form solution: find the anti-derivative of *f*, *F*, and calculate *F(b)
    - F(a)*. In many areas, though, we won''t be able to find an exact anti-derivative,
    and we will have to determine the definite integral numerically. This is exactly
    the idea behind Monte Carlo integration: we evaluate *f* at many, many random
    points between *a* and *b*, and then use those to make an estimate of the definite
    integral.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以计算或估计两个点之间函数的定积分。你可能在一个微积分课程中见过的一种方法是找到一个闭合形式的解：找到 *f* 的反导数 *F*，并计算 *F(b)
    - F(a)*。然而，在许多领域，我们可能无法找到精确的反导数，而必须通过数值方法来确定定积分。这正是蒙特卡洛积分背后的想法：我们在 *a* 和 *b* 之间许多许多随机点处评估
    *f*，然后使用这些点来估计定积分。
- en: Computing definite integrals with the Monte Carlo method
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡洛方法计算定积分
- en: 'We are now going to use the CUDA Math API for representing an arbitrary mathematical
    function, *f*, while using the cuRAND library to implement the Monte Carlo integral.
    We will do this with **metaprogramming**: we will use Python to generate the code
    for a device function from a code template, which will plug into an appropriate
    Monte Carlo kernel for integration.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 CUDA Math API 来表示任意数学函数 *f*，同时使用 cuRAND 库来实现蒙特卡洛积分。我们将通过 **元编程** 来做这件事：我们将使用
    Python 从代码模板生成设备函数的代码，该代码将插入到适当的蒙特卡洛内核中进行积分。
- en: The idea here is that it will look and act similarly to some of the metaprogramming
    tools we've seen with PyCUDA, such as `ElementwiseKernel`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是它看起来和表现方式将与我们在 PyCUDA 中看到的一些元编程工具类似，例如 `ElementwiseKernel`。
- en: 'Let''s start by importing the appropriate modules into our new project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将适当的模块导入到我们的新项目中开始：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''re going to use a trick in Python called **dictionary based string formatting**.
    Let''s go over this for a minute before we continue. Suppose we are writing a
    chunk of CUDA C code, and we are unsure of whether we want a particular collection
    of variables to be float or double; perhaps it looks like this: `code_string="float
    x, y; float * z;"`. We might actually want to format the code so that we can switch
    between floats and doubles on the fly. Let''s change all references from `float`
    in the string to `%(precision)s`—`code_string="%(precision)s x, y; %(precision)s
    * z;"`. We can now set up an appropriate dictionary that will swap `%(presision)s`
    with `double`, which is, `code_dict = {''precision'' : ''double''}`, and get the
    new double string with `code_double = code_string % code_dict`. Let''s take a
    look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将在 Python 中使用一种名为 **基于字典的字符串格式化** 的技巧。在我们继续之前，让我们花几分钟时间来了解一下这个技巧。假设我们正在编写一段
    CUDA C 代码，并且我们不确定是否希望特定的变量集合是 float 还是 double；可能看起来像这样：`code_string="float x,
    y; float * z;"`。我们可能实际上想要格式化代码，以便可以随时在 float 和 double 之间切换。让我们将字符串中的所有 `float`
    引用更改为 `%(precision)s`——`code_string="%(precision)s x, y; %(precision)s * z;"`。现在我们可以设置一个合适的字典，将
    `%(presision)s` 与 `double` 交换，即 `code_dict = {''precision'' : ''double''}`，然后使用
    `code_double = code_string % code_dict` 获取新的 double 字符串。让我们看一下：'
- en: '![](img/508d1ba2-6545-46ad-b443-f494ecbeba3f.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/508d1ba2-6545-46ad-b443-f494ecbeba3f.png)'
- en: Now, let's think for a moment about how we want our new Monte Carlo integrator
    to work. We will also have it take a string that is a math equation that is written
    using the CUDA Math API to define the function we want to integrate. We can then
    fit this string into the code using the dictionary trick we just learned, and
    use this to integrate arbitrary functions. We will also use the template to switch
    between `float` and `double` precision, as per the user's discretion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时思考一下我们希望我们的新蒙特卡洛积分器如何工作。我们还将让它接受一个字符串，该字符串是一个使用CUDA Math API编写的数学方程，用于定义我们想要积分的函数。然后我们可以使用我们刚刚学到的字典技巧将这个字符串放入代码中，并使用它来积分任意函数。我们还将使用模板在用户的选择下在`float`和`double`精度之间切换。
- en: 'We can now begin our CUDA C code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始我们的CUDA C代码：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will keep the unsigned 64-bit integer macro from before, `ULL`. Let''s define
    some new macros for a reciprocal of x (`_R`), and for squaring (`_P2`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留之前使用的无符号64位整数宏`ULL`。让我们定义一些新的宏，用于x的倒数（`_R`）和平方（`_P2`）：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s define a device function that our equation string will plug into.
    We will use the `math_function` value when we have to swap the text from a dictionary.
    We will have another value called `p`, for precision (which will either be a `float`
    or `double`). We''ll call this device function `f`. We''ll put an `inline` in
    the declaration of the function, which will save us a little time from branching
    when this is called from the kernel:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个设备函数，我们的方程字符串将插入其中。当我们需要从字典中交换文本时，我们将使用`math_function`值。我们将有一个名为`p`的另一个值，用于精度（它可以是`float`或`double`）。我们将把这个设备函数称为`f`。我们将在函数声明中放置一个`inline`，这样当从内核调用时可以节省一点时间：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let's think about how this will work— We declare a 32 or 64-bit floating
    point value called `y`, call `math_function`, and then return `y`. `math_function`,
    which will only make sense if it's some code that acts on the input parameter
    `x` and sets some value to `y`, such as `y = sin(x)`. Let's keep this in mind
    and continue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下这将如何工作——我们声明一个32或64位的浮点值`y`，调用`math_function`，然后返回`y`。`math_function`只有在它是某种作用于输入参数`x`并设置某些值到`y`的代码时才有意义，例如`y
    = sin(x)`。让我们记住这一点并继续。
- en: We will now begin writing our Monte Carlo integration kernel. Let's remember
    that we have to make our CUDA kernel visible from plain C with the `extern "C"`
    keyword. We will then set up our kernel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始编写我们的蒙特卡洛积分内核。让我们记住，我们必须使用`extern "C"`关键字使我们的CUDA内核对纯C可见。然后我们将设置我们的内核。
- en: 'First, we will indicate how many random samples each thread in the kernel should
    take with `iters`; we then indicate the lower bound of integration (*b*) with
    `lo` and the upper bound (*a*) with `hi`, and pass in an array, `ys_out`, to store
    the collection of partial integrals for each thread (we will later sum over `ys_out`
    to get the value of the complete definite integral from `lo` to `hi` on the host
    side). Again, notice how we are referring to the precision as `p`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`iters`指示内核中每个线程应该取多少个随机样本；然后我们使用`lo`指示积分的下限（*b*）和`hi`指示上限（*a*），并将一个数组`ys_out`传递进去，用于存储每个线程的积分部分集合（我们将在主机端对`ys_out`求和以获得从`lo`到`hi`的完整定积分的值）。再次注意，我们是如何将精度称为`p`：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will need a `curandState` object for generating random values. We will also
    need to find the global thread ID and the total number of threads. Since we are
    working with a one-dimensional mathematical function, it makes sense to set up
    our block and grid parameters in one dimension, `x`, as well:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`curandState`对象来生成随机值。我们还需要找到全局线程ID和线程总数。由于我们正在处理一维数学函数，因此在一维`x`上设置我们的块和网格参数是有意义的：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now calculate the amount of area there is between `lo` and `hi` that
    a single thread will process. We''ll do this by dividing up the entire length
    of the integration (which will be `hi - lo`) by the total number of threads.:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将计算单个线程将处理的`lo`和`hi`之间的面积。我们将通过将整个积分长度（将是`hi - lo`）除以线程总数来完成此操作：
- en: Again, note how we are using templating tricks so that this value can be multi-precision.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们是如何使用模板技巧，使得这个值可以具有多精度。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Recall that we have a parameter called `iters`; this indicates how many random
    values each thread will sample. We need to know what the density of the samples
    is in a little bit; that is, the average number of samples per unit distance.
    We calculate it like so, remembering to typecast the integer `iters` into a floating-point
    value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们有一个名为 `iters` 的参数；这表示每个线程将采样多少随机值。我们需要知道样本的密度；也就是说，每单位距离的平均样本数。我们这样计算，记得将整数
    `iters` 转换为浮点值：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Recall that we are dividing the area we are integrating over by the number
    of threads. This means that each thread will have its own start and end point.
    Since we are dividing up the lengths fairly for each thread, we calculate this
    like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们正在将我们积分的面积除以线程数。这意味着每个线程将有自己的起始点和结束点。由于我们正在为每个线程公平地划分长度，我们这样计算：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now initialize cuRAND like we did previously, making sure that each
    thread is generating random values from its own individual seed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像之前一样初始化 cuRAND，确保每个线程都从它自己的独立种子生成随机值：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before we start sampling, we will need to set up some additional floating point
    values. `y` will hold the final value for the integral estimate from `t_lo` to
    `t_hi`, and `y_sum` will hold the sum of all of the sampled values. We will also
    use the `rand_val` variable to hold the raw random value we generate, and `x`
    to store the scaled random value from the area that we will be sampling from:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始采样之前，我们需要设置一些额外的浮点值。`y` 将保存从 `t_lo` 到 `t_hi` 的积分估计的最终值，而 `y_sum` 将保存所有采样值的总和。我们还将使用
    `rand_val` 变量来保存我们生成的原始随机值，以及 `x` 来存储从我们将从中采样的区域缩放后的随机值：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s loop to the sample values from our function, adding the values
    into `y_sum`. The one salient thing to notice is the `%(p_curand)`s at the end
    of `curand_uniform—`the 32-bit floating point version of this function is `curand_uniform`,
    while the 64-bit version is `curand_uniform_double`. We will have to swap this
    with either `_double` or an empty string later, depending on what level of precision
    we go with here. Also, notice how we scale `rand_val` so that `x` falls between
    `t_lo` and `t_hi`, remembering that random uniform distributions in cuRAND only
    yields values between 0 and 1:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们循环到函数的采样值，将这些值添加到 `y_sum` 中。值得注意的是 `curand_uniform—` 结尾的 `%(p_curand)`s。这个函数的
    32 位浮点版本是 `curand_uniform`，而 64 位版本是 `curand_uniform_double`。我们稍后必须根据我们选择的精度级别将其与
    `_double` 或空字符串进行交换。注意我们如何缩放 `rand_val`，以便 `x` 落在 `t_lo` 和 `t_hi` 之间，记住 cuRAND
    中的随机均匀分布只产生介于 0 和 1 之间的值：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now calculate the value of the subintegral from `t_lo` to `t_hi` by
    dividing `y_sum` by density:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过将 `y_sum` 除以密度来计算从 `t_lo` 到 `t_hi` 的子积分值：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We output this value into the array and close off our CUDA kernel, as well
    as the `extern "C"`, with the final closing bracket. We''re done writing CUDA
    C, so we will close off this section with a triple-quote:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个值输出到数组中，关闭 CUDA 内核，以及 `extern "C"`，使用最后的闭合括号。我们已完成 CUDA C 的编写，因此我们将使用三个引号关闭这一部分：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now do something a little different—we're going to set up a class to
    handle our definite integrals. Let's call it `MonteCarloIntegrator`. We will start,
    of course, by writing the constructor, that is, the `__init__` function. This
    is where we will input the object reference, `self`. Let's set up the default
    value for `math_function` to be `'y = sin(x)'`, with the default precision as
    `'d'`, for double. We'll also set the default value for `lo` as 0 and `hi` as
    the NumPy approximation of π . Finally, we'll have values for the number of random
    samples each thread will take (`samples_per_thread`), and the grid size that we
    will launch our kernel over (`num_blocks`).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将做一些不同的事情——我们将设置一个类来处理我们的定积分。让我们称它为 `MonteCarloIntegrator`。当然，我们将从编写构造函数开始，即
    `__init__` 函数。这就是我们将输入对象引用 `self` 的地方。让我们将 `math_function` 的默认值设置为 `'y = sin(x)'`，默认精度为
    `'d'`，即双精度。我们还将 `lo` 的默认值设置为 0，`hi` 设置为 NumPy 对 π 的近似值。最后，我们将有每个线程将取的随机样本数（`samples_per_thread`）和我们将启动内核的网格大小（`num_blocks`）的值。
- en: 'Let''s start this function by storing the text string `math_function` within
    the `self` object for later use:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将文本字符串 `math_function` 存储在 `self` 对象中以备后用开始这个函数：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s set up the values related to our choice of floating-point precision
    that we will need for later, particularly for setting up our template dictionary.
    We will also store the `lo` and `hi` values within the object. Let''s also be
    sure to raise exception errors if the user inputs an invalid datatype, or if `hi`
    is actually smaller than `lo`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置与我们将需要的浮点精度相关的值，这些值将在以后使用，特别是用于设置我们的模板字典。我们还将存储对象中的 `lo` 和 `hi` 值。让我们还要确保在用户输入无效数据类型或
    `hi` 实际上小于 `lo` 时抛出异常错误：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now set up our code template dictionary:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置我们的代码模板字典：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now generate the actual final code using dictionary-based string formatting,
    and compile. Let''s also turn off warnings from the `nvcc` compiler by setting
    `options=[''-w'']` in `SourceModule`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用基于字典的字符串格式化生成实际的最终代码，并编译。让我们还通过在 `SourceModule` 中设置 `options=['-w']`
    来关闭 `nvcc` 编译器的警告：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will now set up a function reference in our object to our compiled kernel
    with `get_function`. Let''s save the remaining two parameters within our object
    before we continue:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 `get_function` 在我们的对象中设置一个函数引用到我们的编译内核。在我们继续之前，让我们在对象中保存剩下的两个参数：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, while we will need different instantiations of `MonteCarloIntegrator` objects
    to evaluate definite integrals of different mathematical functions or floating
    point precision, we might want to evaluate the same integral over different `lo`
    and `hi` bounds, change the number of threads/grid size, or alter the number of
    samples we take at each thread. Thankfully, these are easy alterations to make,
    and can all be made at runtime.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我们需要不同的 `MonteCarloIntegrator` 对象实例来评估不同数学函数或浮点精度的定积分，但我们可能想要在不同的 `lo`
    和 `hi` 范围内评估相同的积分，改变线程数/网格大小，或者改变每个线程中取样的数量。幸运的是，这些更改很容易实现，并且都可以在运行时进行。
- en: 'We''ll set up a specific function for evaluating the integral of a given object.
    We will set the default values of these parameters to be those that we stored
    during the call to the constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为评估给定对象的积分设置一个特定的函数。我们将这些参数的默认值设置为在构造函数调用期间存储的值：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can finish this function off by setting up an empty array to store the partial
    sub-integrals and launching the kernel. We then need to sum over the sub-integrals
    to get the final value, which we return:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置一个空数组来存储部分子积分并启动内核来完成这个函数。然后我们需要对子积分进行求和以得到最终值，然后返回：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are ready to try this out. Let''s just set up a class with the default values—this
    will integrate `y = sin(x)` from 0 to π. If you remember calculus, the anti-derivative
    of *sin(x)* is *-cos(x)*, so we can evaluate the definite integral like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备尝试一下。让我们只设置一个具有默认值的类——这将把 `y = sin(x)` 从 0 到 π 进行积分。如果你记得微积分，*sin(x)*
    的反导数是 *-cos(x)*，因此我们可以这样评估定积分：
- en: '![](img/0f237e46-f4f9-459c-a1db-29766ce488b7.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f237e46-f4f9-459c-a1db-29766ce488b7.png)'
- en: 'Therefore, we should get a numerical value close to 2\. Let''s see what we
    get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该得到一个接近 2 的数值。让我们看看我们得到的是什么：
- en: '![](img/49e7d08f-4958-4e3e-96f6-2168b71e628a.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49e7d08f-4958-4e3e-96f6-2168b71e628a.png)'
- en: Writing some test cases
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一些测试用例
- en: Now, we will finally get to see how to use the CUDA Math API to write some test
    cases for our class by way of the `math_function` parameter. These will be fairly
    straightforward if you have any experience with the C/C++ standard math library.
    Again, these functions are overloaded so that we don't have to change the names
    of anything when we switch between single and double precision.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将最终看到如何通过 `math_function` 参数使用 CUDA Math API 为我们的类编写一些测试用例。如果你有任何 C/C++
    标准数学库的经验，这些将相当直接。同样，这些函数是重载的，这样我们就不必在单精度和双精度之间切换时更改任何名称。
- en: 'We''ve already seen one example, namely *y = sin(x)*. Let''s try something
    a little more ambitious:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个例子，即 *y = sin(x)*。让我们尝试一个稍微更有雄心的例子：
- en: '![](img/94a6e5b9-688f-4fee-9cde-34949e6f0386.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94a6e5b9-688f-4fee-9cde-34949e6f0386.png)'
- en: We will integrate this function from *a=*11.733 to *b=*18.472, and then check
    the output of our Monte Carlo integrator against the known value of this integral
    from another source. Here, Mathematica indicates that the value of this definite
    integral is 8.9999, so we will check against that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个函数的 *a=11.733* 到 *b=18.472* 进行积分，然后检查我们的蒙特卡洛积分器的输出与另一个来源已知此积分值的比较。在这里，Mathematica
    指出，这个定积分的值是 8.9999，因此我们将对此进行检查。
- en: 'Now, let''s think of how to represent this function: here, *log* refers to
    the base-*e* logarithm (also known as *ln*), and this is just `log(x)` in the
    Math API. We already set up a macro for squaring, so we can represent *sin²(x)*
    as `_P2(sin(x))`. We can now represent the entire function with `y = log(x)*_P2(sin(x))`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何表示这个函数：在这里，`*log*`指的是自然对数（也称为`*ln*`），在 Math API 中这仅仅是`log(x)`。我们已为平方设置了一个宏，因此我们可以将`*sin²(x)*`表示为`_P2(sin(x))`。现在我们可以用`y
    = log(x)*_P2(sin(x))`来表示整个函数。
- en: 'Let''s use the following equation, integrating from *a=.9* to *b=4*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下方程，从`*a=.9*`到`*b=4*`进行积分：
- en: '![](img/41e43277-2c80-488e-b8ab-78355f6c0c53.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41e43277-2c80-488e-b8ab-78355f6c0c53.png)'
- en: 'Remembering that `_R` is the macro we set up for a reciprocal, we can write
    the function with the Math API like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`_R`是我们为倒数设置的宏，我们可以使用 Math API 这样编写函数：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before we move on, let's note that Mathematica tells us that the value of this
    definite integral is .584977.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们注意 Mathematica 告诉我们这个定积分的值是 .584977。
- en: 'Let''s check on one more function. Let''s be a little ambitious and say that
    it''s this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查另一个函数。让我们有点雄心壮志，比如说它是这个：
- en: '![](img/b33f7b41-e613-4e37-96ac-9b12a223a7e0.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b33f7b41-e613-4e37-96ac-9b12a223a7e0.png)'
- en: We can represent this as `'y = (cosh(x)*sin(x))/ sqrt( pow(x,3) + _P2(sin(x)))'`;
    naturally `sqrt` is the square root in the denominator, and `pow` allows us to
    take a value of arbitrary power. Of course, `sin(x)` is *sin(x)* and `cosh(x)`
    is *cosh(x)*. We integrate this from *a*=1.85 to *b*=4.81; Mathematica tells us
    that the true value of this integral is -3.34553.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其表示为`'y = (cosh(x)*sin(x))/ sqrt( pow(x,3) + _P2(sin(x)))'`；自然地，`sqrt`是分母中的平方根，`pow`允许我们取任意幂的值。当然，`sin(x)`是`*sin(x)*`，`cosh(x)`是`*cosh(x)*`。我们从这个积分从`*a*=1.85`到`*b*=4.81`；Mathematica告诉我们这个积分的真实值是-3.34553。
- en: 'We are now ready to check some test cases and verify that our Monte Carlo integral
    is working! Let''s iterate over a list, whose first value is a string indicating
    the function (using the Math API), the second value indicates the lower bound
    of integration, the third indicates the upper bound of integration, and the last
    value indicates the expected value that was calculated with Mathematica:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好检查一些测试用例，并验证我们的蒙特卡洛积分是否正常工作！让我们遍历一个列表，列表的第一个值是一个字符串，表示函数（使用 Math API），第二个值表示积分的下限，第三个值表示积分的上限，最后一个值表示使用
    Mathematica 计算的预期值：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now iterate over this list and see how well our algorithm works compared
    to Mathematica:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以遍历这个列表，看看我们的算法与 Mathematica 相比表现如何：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s run this right now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行这个：
- en: '![](img/b788faff-a6b9-4c86-ad21-26edd0e614e6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b788faff-a6b9-4c86-ad21-26edd0e614e6.png)'
- en: This is also available as the `monte_carlo_integrator.py` file under the `Chapter08`
    directory in this book's repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在本书仓库的`Chapter08`目录下的`monte_carlo_integrator.py`文件中找到。
- en: The CUDA Thrust library
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA Thrust 库
- en: We will now look at the CUDA Thrust Library. This library's central feature
    is a high-level vector container that is similar C++'s own vector container. While
    this may sound trivial, this will allow us to program in CUDA C with less reliance
    on pointers, mallocs, and frees. Like the C++ vector container, Thrust's vector
    container handles the resizing and concatenation of elements automatically, and
    with the magic of C++ destructors, *freeing* is also handled automatically when
    a Thrust vector object goes out of scope.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看 CUDA Thrust 库。这个库的核心特性是一个高级向量容器，类似于 C++ 自身的向量容器。虽然这听起来可能微不足道，但这将使我们能够在
    CUDA C 中以更少的指针、mallocs 和 frees 依赖性进行编程。与 C++ 向量容器一样，Thrust 的向量容器自动处理元素的调整大小和连接，并且利用
    C++ 析构函数的魔力，当 Thrust 向量对象超出作用域时，`*freeing*`也会自动处理。
- en: 'Thrust actually provides two vector containers: one for the host-side, and
    one for the device-side. The host-side Thrust vector is more or less identical
    to the STL vector, with the main difference being that it can interact more easily
    with the GPU. Let''s write a little bit of code in proper CUDA C to get a feel
    for how this works.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Thrust 实际上提供了两个向量容器：一个用于主机端，一个用于设备端。主机端的 Thrust 向量与 STL 向量大致相同，主要区别在于它可以更容易地与
    GPU 交互。让我们用一些正确的 CUDA C 代码来写一点，以了解这是如何工作的。
- en: 'Let''s start with the include statements. We''ll be using the headers for both
    the host and device side vectors, and we''ll also include the C++ `iostream` library,
    which will allow us to perform basic I/O operations on the Terminal:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包含语句开始。我们将使用主机和设备端向量的标题，并且我们还将包含 C++ 的 `iostream` 库，这将允许我们在终端上执行基本的 I/O
    操作：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s just use the standard C++ namespace (this is so that we don''t have
    to type in the `std::` resolution operator when checking the output):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只使用标准的 C++ 命名空间（这样我们就不必在检查输出时输入 `std::` 解析运算符）：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now make our main function and set up an empty Thrust vector on the
    host side. Again, these are C++ templates, so we have to choose the datatype upon
    declaration with the `< >` brackets. We will set this up to be an array of integers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建主函数并在主机端设置一个空的 Thrust 向量。同样，这些都是 C++ 模板，所以我们必须在声明时用 `< >` 括号选择数据类型。我们将将其设置为整数数组：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s append some integers to the end of `v` by using `push_back`, exactly
    how we would do so with a regular STL vector:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用 `push_back` 将一些整数追加到 `v` 的末尾，就像我们使用常规 STL 向量那样：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will now iterate through all of the values in the vector, and output each
    value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将遍历向量的所有值，并输出每个值：
- en: The output here should be `v[0] == 1` through `v[3] == 4`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出应该是 `v[0] == 1` 通过 `v[3] == 4`。
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This may have seemed trivial so far. Let''s set up a Thrust vector on the GPU
    and then copy the contents from `v`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能看起来很 trivial。让我们在 GPU 上设置一个 Thrust 向量，然后从 `v` 中复制内容：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Yes, that's all—only one line, and we're done. All of the content of `v` on
    the host will now be copied to `v_gpu` on the device! (If this doesn't amaze you,
    please take another look at [Chapter 6](6d1c808f-1dc2-4454-b0b8-d0a36bc3c908.xhtml),
    *Debugging and Profiling Your CUDA Code*, and think about how many lines this
    would have taken us before.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就是这样——只有一行，我们就完成了。现在主机上的 `v` 的所有内容都将复制到设备上的 `v_gpu`！（如果这没有让你感到惊讶，请再次查看[第
    6 章](6d1c808f-1dc2-4454-b0b8-d0a36bc3c908.xhtml)，*调试和性能分析您的 CUDA 代码*，并思考在没有 Thrust
    的情况下这需要多少行代码。）
- en: 'Let''s try using `push_back` on our new GPU vector, and see if we can concatenate
    another value to it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在我们的新 GPU 向量上使用 `push_back`，看看我们能否将其与另一个值连接起来：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will now check the contents of `v_gpu`, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查 `v_gpu` 的内容，如下所示：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This part should output `v_gpu[0] == 1` through `v_gpu[4] == 5`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分应该输出 `v_gpu[0] == 1` 通过 `v_gpu[4] == 5`。
- en: 'Again, thanks to the destructors of these objects, we don''t have to do any
    cleanup in the form of freeing any chunks of allocated memory. We can now just
    return from the program, and we are done:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，多亏了这些对象的析构函数，我们不需要进行任何清理，例如释放分配的内存块。现在我们可以直接从程序中返回，我们就完成了：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using functors in Thrust
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Thrust 中使用函数对象
- en: Let's see how we can use a concept known as **functors** in Thrust. In C++,
    a **functor** is a class or struct object that looks and acts like a function;
    this lets us use something that looks and acts like a function, but can hold some
    parameters that don't have to be set every time it is used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在 Thrust 中使用一个称为 **functors** 的概念。在 C++ 中，**functor** 是一个看起来和表现像函数的类或结构体对象；这让我们可以使用看起来和表现像函数的东西，但可以持有一些不需要每次使用时都设置的参数。
- en: 'Let''s start a new Thrust program with the appropriate include statements,
    and use the standard namespace:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从适当的包含语句开始一个新的 Thrust 程序，并使用标准命名空间：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s set up a basic functor. We will use a `struct` to represent this,
    rather than `class`. This will be a weighted multiplication function, and we will
    store the weight in a float called `w`. We will make a constructor that sets up
    the weight with a default value of `1`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一个基本的函数对象。我们将使用 `struct` 来表示它，而不是 `class`。这将是一个加权乘法函数，我们将权重存储在一个名为 `w`
    的浮点数中。我们将创建一个构造函数，它使用默认值 `1` 设置权重：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will now set up our functor with the `operator()` keyword; this will indicate
    to the compiler to treat the following block of code as the `default` function
    for objects of this type. Remember that this will be running on the GPU as a device
    function, so we precede the whole thing with `__device__`. We indicate the inputs
    with parentheses and output the appropriate value, which is just a scaled multiple.
    Now, we can close off the definition of our struct with `};`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 `operator()` 关键字设置我们的函数对象；这将指示编译器将以下代码块视为此类对象的 `default` 函数。记住，这将作为一个设备函数在
    GPU 上运行，所以我们用 `__device__` 前缀整个代码块。我们用括号表示输入，并输出适当的值，这只是一个缩放后的倍数。现在，我们可以用 `};`
    关闭我们结构的定义：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s use this to make a basic dot product function; recall that this
    requires a pointwise multiplication between two arrays, followed by a `reduce`
    type sum. Let''s start by declaring our function and creating a new vector, `z`,
    that will hold the values of the point-wise multiplication:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用这个来创建一个基本的点积函数；回想一下，这需要在两个数组之间进行逐点乘法，然后是一个`reduce`类型的求和。让我们首先声明我们的函数并创建一个新的向量`z`，它将保存逐点乘法的值：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will now use Thrust''s `transform` operation, which will act on the inputs
    of `v` and `w` point-wise, and output into `z`. Notice how we input the functor
    into the last slot of transform; by using the plain closed parentheses like so,
    it will use the default value of the constructor (w = 1) so that this will act
    as a normal, non-weighted/scaled dot product:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Thrust的`transform`操作，它将对`v`和`w`的输入逐点操作，并将输出到`z`。注意我们如何将函数对象输入到`transform`的最后一个槽位；通过使用这样的普通闭合括号，它将使用构造函数的默认值（w
    = 1），这样它将作为一个正常的、非加权/缩放的点积：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can now sum over `z` with Thrust''s reduce function. Let''s just return
    the value:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Thrust的`reduce`函数对`z`进行求和。让我们只返回这个值：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We're done. Now, let's write some test code—we'll just take the dot product
    of the vectors `[1,2,3]` and `[1,1,1]`, which will be easy for us to check. (This
    will be 6.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。现在，让我们编写一些测试代码——我们将计算向量`[1,2,3]`和`[1,1,1]`的点积，这对我们来说很容易检查。（这将等于6。）
- en: 'Let''s just set up the first vector, `v`, using `push_back`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只设置第一个向量`v`，使用`push_back`：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can now declare a vector, `w`, to be of size `3`, and we can set its default
    values to `1` using Thrust''s fill function, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以声明一个大小为`3`的向量`w`，并使用Thrust的`fill`函数将其默认值设置为`1`，如下所示：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s do a check to make sure that our values are set correctly by outputting
    their values to `cout`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的值是否设置正确，通过将它们的值输出到`cout`：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we can check the output of our dot product, and then return from the program:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查我们的点积输出，然后从程序中返回：
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s compile this (from the command line in both Linux or Windows by using
    `nvcc thrust_dot_product.cu -o thrust_dot_product`) and run it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这个（在Linux或Windows的命令行中使用`nvcc thrust_dot_product.cu -o thrust_dot_product`）并运行它：
- en: '![](img/03884f6c-d05f-4127-a8b1-3f66dd0cbbf9.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03884f6c-d05f-4127-a8b1-3f66dd0cbbf9.png)'
- en: The code for this is also available in the `thrust_dot_product.cu` file in the
    `Chapter08` directory in this book's repository.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码也包含在这本书的仓库中`Chapter08`目录下的`thrust_dot_product.cu`文件中。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to initialize a stream of random numbers in
    cuRAND by choosing the appropriate seed. Since computers are deterministic devices,
    they can only generate lists of pseudo-random numbers, so our seed should be something
    truly random; generally, adding a thread ID to the clock time in milliseconds
    will work well enough for most purposes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在cuRAND中通过选择合适的种子来初始化随机数流。由于计算机是确定性设备，它们只能生成伪随机数的列表，因此我们的种子应该是真正随机的；通常，将线程ID添加到毫秒级的时钟时间中对于大多数目的来说已经足够好了。
- en: We then looked at how we can use the uniform distribution from cuRAND to do
    a basic estimate of Pi. Then we took on a more ambitious project of creating a
    Python class that can compute definite integrals of arbitrary functions; we used
    some ideas from metaprogramming coupled with the CUDA Math API to define these
    `arbitrary` functions. Finally, we had a brief overview of the CUDA Thrust library,
    which is generally used for writing pure CUDA C programs outside of Python. Thrust
    most notably provides a `device_vector` container that is similar to the standard
    C++ `vector`. This reduces some of the cognitive overhead from using pointers
    in CUDA C.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了如何使用cuRAND的均匀分布来进行Pi的基本估计。然后我们承担了一个更雄心勃勃的项目，创建了一个Python类，可以计算任意函数的定积分；我们使用了一些元编程的思想，结合CUDA
    Math API来定义这些`任意`函数。最后，我们对CUDA Thrust库进行了简要概述，它通常用于在Python之外编写纯CUDA C程序。Thrust最显著地提供了一个类似于标准C++
    `vector`的`device_vector`容器。这减少了在CUDA C中使用指针的一些认知开销。
- en: Finally, we looked at a brief example of how to use Thrust with an appropriate
    functor to do simple `point-wise` and `reduce` operations, in the form of the
    implementation of a simple dot product function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要地看了一个如何使用Thrust和一个适当的函数对象来进行简单的`point-wise`和`reduce`操作的例子，形式上是实现一个简单的点积函数。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Try rewriting the Monte Carlo integration examples (in the `__main__` function
    in `monte_carlo_integrator.py`) to use the CUDA `instrinsic` functions. How does
    the accuracy compare to before?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试重写 Monte Carlo 积分示例（位于 `monte_carlo_integrator.py` 文件中的 `__main__` 函数），使用
    CUDA 的 `instrinsic` 函数。与之前相比，精度如何？
- en: We only used the uniform distribution in all of our cuRAND examples. Can you
    name one possible use or application of using the normal (Gaussian) random distribution
    in GPU programming?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在所有的 cuRAND 示例中都只使用了均匀分布。你能列举一个在 GPU 编程中使用正态（高斯）随机分布的可能用途或应用吗？
- en: Suppose that we use two different seeds to generate a list of 100 pseudo-random
    numbers. Should we ever concatenate these into a list of 200 numbers?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们使用两个不同的种子生成一个包含 100 个伪随机数的列表。我们是否应该将这些数拼接成一个包含 200 个数字的列表？
- en: In the last example, try adding `__host__` before `__device__` in the definition
    of our `operator()` function in the `multiply_functor` struct. Now, see if you
    can directly implement a host-side dot-product function using this functor without
    any further modifications.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个示例中，尝试在 `multiply_functor` 结构体中 `operator()` 函数的定义前添加 `__host__`。现在，看看你是否可以直接使用这个函数实现一个主机端的点积函数，而不需要做任何进一步的修改。
- en: Take a look at the `strided_range.cu` file in the Thrust `examples` directory.
    Can you think of how to use this to implement a general matrix-matrix multiplication
    using Thrust?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看位于 Thrust `examples` 目录下的 `strided_range.cu` 文件。你能想到如何使用这个文件通过 Thrust 实现一个通用的矩阵-矩阵乘法吗？
- en: What is the importance of the `operator()` function when defining a functor?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义函数时，`operator()` 函数的重要性是什么？
