<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Maps</h1></div></div></div><p>In this chapter, we will look at how Python programs can create great-looking maps using the Mapnik library. You will install Mapnik onto your computer, learn the basics of the Mapnik library, and see how you can use it to generate simple maps. We will then explore some of the more advanced aspects of Mapnik, and see how it can be used to produce a wide range of complex visual effects. Finally, we will create a useful program that displays the contents of any shapefile as a map.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Introducing Mapnik</h1></div></div></div><p>It is very difficult to make sense of geospatial data without being able to visualize it. The usual way in which spatial data is made visible is by drawing a map—indeed, a map is nothing more than an image created out of spatial data. <strong>Mapnik</strong><a id="id260" class="indexterm"/> (<a class="ulink" href="http://mapnik.org">http://mapnik.org</a>) is a<a id="id261" class="indexterm"/> powerful tool for transforming raw geospatial data into a map image.</p><p>Mapnik itself is written in C++ but comes with bindings that allow you to access it from Python. Using Python code, you can define the various layers that make up a map, specify the datasources containing the data to be displayed, and then set up the styles which control how the various features are to be drawn.</p><p>Mapnik can be a little intimidating when you first start working with it, so let's jump in and get our hands dirty right away. Let's start by installing Mapnik onto your computer and use it to generate a simple map, before delving a bit deeper into how to build and style maps using the Mapnik library.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Installing Mapnik</h2></div></div></div><p>To install Mapnik, go<a id="id262" class="indexterm"/> to the<a id="id263" class="indexterm"/> downloads page on the <a id="id264" class="indexterm"/>main Mapnik website (<a class="ulink" href="http://mapnik.org/pages/downloads.html">http://mapnik.org/pages/downloads.html</a>), and choose the installer for your operating system. Pre-built packages are available for both Mac OS X and MS Windows. For Linux machines, you will need to either compile the program from source, or use a package manager to download, compile, and install Mapnik and its various dependencies; full instructions on how to do this are provided on the Mapnik download page.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>A taste of Mapnik</h2></div></div></div><p>We will start our exploration of <a id="id265" class="indexterm"/>Mapnik by writing a simple program that generates a map using the World Borders Dataset we downloaded earlier. Copy the contents of the <code class="literal">TM_WORLD_BORDERS-0.3</code> directory into a convenient place, and then create a new Python program in the same directory. Name your new program <code class="literal">mapnik_example.py</code>. This program will generate a PNG-format image file based on the contents of the World Borders Dataset shapefile.</p><p>Type the following into your <code class="literal">mapnik_example.py</code> file:</p><div><pre class="programlisting">import mapnik

map = mapnik.Map(1200, 600)
map.background = mapnik.Color("#e0e0ff")

layer = mapnik.Layer("countries")
layer.datasource = mapnik.Shapefile(file="TM_WORLD_BORDERS-0.3.shp")
layer.styles.append("country_style")
map.layers.append(layer)

fill_symbol = mapnik.PolygonSymbolizer(mapnik.Color("#60a060"))
line_symbol = mapnik.LineSymbolizer(mapnik.Color("black"), 0.5)

rule = mapnik.Rule()
rule.symbols.append(fill_symbol)
rule.symbols.append(line_symbol)

style = mapnik.Style()
style.rules.append(rule)

map.append_style("country_style", style)

map.zoom_all()
mapnik.render_to_file(map, "map.png", "png")</pre></div><p>When you run this program, a new file named <code class="literal">map.png</code> should be created in the same directory. Opening this file will display the generated map:</p><div><img src="img/4102_04_01.jpg" alt="A taste of Mapnik"/></div><p>Now that we've seen what our<a id="id266" class="indexterm"/> example program does, let's take a closer look at it and examine each part in turn. Let's start with the very beginning of our program:</p><div><pre class="programlisting">import mapnik

map = mapnik.Map(1200, 600)
map.background = mapnik.Color("#e0e0ff")</pre></div><p>Here we simply import the Mapnik library, and then create and initialize a new<a id="id267" class="indexterm"/> <strong>map</strong> object. The map image will be 1,200 pixels wide and 600 pixels high, and the map will have a pale blue background defined by the hexadecimal color value <code class="literal">#e0e0ff</code>.</p><p>A map consists of one or more<a id="id268" class="indexterm"/> <strong>map layers</strong>. In our program, we only have one map layer, which we set up to access the <code class="literal">TM_WORLD_BORDERS</code> shapefile:</p><div><pre class="programlisting">layer = mapnik.Layer("countries")
layer.datasource = mapnik.Shapefile(file="TM_WORLD_BORDERS-0.3.shp")
layer.styles.append("country_style")
map.layers.append(layer)</pre></div><p>There are a few things to notice about this layer definition:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each map layer is given a <strong>name</strong> which uniquely identifies the layer within the map; in our program, we've called our map layer <code class="literal">countries</code>.</li><li class="listitem" style="list-style-type: disc">Each layer has a <strong>datasource</strong> which tells Mapnik where the data should come from. In this case, we're using the <code class="literal">mapnik.Shapefile</code> class to load the data from a shapefile, though there are many different types of datasources that can be used. For example, you can load data directly from a spatial database, or even use a Python datasource to create and display features programmatically.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">layer.styles.append("country_style")</code> line tells Mapnik which <strong>style</strong> to use to draw the layer's data. Mapnik styles are referred to by name, and you can have any number of styles associated with each layer.<div><div><h3 class="title"><a id="note26"/>Note</h3><p>Mapnik layers can also have a spatial reference system associated with them. If you don't specify a spatial reference system, Mapnik will assume that the data is in the standard EPSG 4326 spatial reference system.</p></div></div></li></ul></div><p>We next want to define<a id="id269" class="indexterm"/> the <code class="literal">country_style</code> style which will draw the contents of our map layer. A style consists of any number of <strong>rules</strong>, where each rule has an optional <strong>filter</strong><a id="id270" class="indexterm"/> identifying which of the features in the datasource should be drawn using this rule, and a list of <strong>symbolizers</strong><a id="id271" class="indexterm"/> which will be used to draw the matching features onto the map.</p><p>We start by creating two symbolizers: one to fill the interior of each polygon with a faded green color, and another to draw the outline of each polygon using a thin black line:</p><div><pre class="programlisting">fill_symbol = mapnik.PolygonSymbolizer(mapnik.Color("#60a060"))
line_symbol = mapnik.LineSymbolizer(mapnik.Color("black"), 0.5)</pre></div><p>For the fill symbol, we are once again using a hexadecimal color code to define the color to use to draw the interior of the polygon, while for the line symbol we make use of a named color. Note that the <code class="literal">0.5</code> value defines the width, in pixels, to use to draw the outline of each polygon.</p><p>Now that we have our two symbolizers, we next define a rule which uses them to draw the contents of the shapefile:</p><div><pre class="programlisting">rule = mapnik.Rule()
rule.symbols.append(fill_symbol)
rule.symbols.append(line_symbol)</pre></div><p>Notice that this rule has no filter; the absence of a filter tells Mapnik that every feature in the layer's datasource should be drawn using these two symbolizers.</p><p>To finish defining our <code class="literal">country_style</code> style, we initialize the <code class="literal">Style</code> object itself, add our one-and-only rule to the style, and then add the style object to our map:</p><div><pre class="programlisting">style = mapnik.Style()
style.rules.append(rule)

map.append_style("country_style", style)</pre></div><p>Notice that we give the style a name when we add it to the map object; because this name is used to identify the styles used by the map layer, it is important that we use exactly the same name both when adding the style to the map and when referring to the style in the map layer.</p><p>Our final task is to tell the map which area of the world to display, and how to <strong>render</strong> the visible portion of the map into an image file:</p><div><pre class="programlisting">map.zoom_all()
mapnik.render_to_file(map, "map.png", "png")</pre></div><p>In our example, we are<a id="id272" class="indexterm"/> zooming out to show all the data in the map layer, and saving the results to a PNG format image file named <code class="literal">map.png</code>.</p><p>This completes our example Python program to generate a map image using Mapnik. There are lots of more sophisticated things you can do using Mapnik, but this will give you an idea of how it works and what you can do with it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Building a map</h2></div></div></div><p>Now that we've seen an <a id="id273" class="indexterm"/>example of how Mapnik works, let's look more closely at <a id="id274" class="indexterm"/>some of the ideas behind the Mapnik library. Consider, for example, the following map of the west coast of the United States:</p><p> </p><div><img src="img/4102_04_02.jpg" alt="Building a map"/></div><p>
</p><p>This map is actually made up of four different map layers:</p><div><img src="img/4102_04_03.jpg" alt="Building a map"/></div><p>As you can see, the map layers<a id="id275" class="indexterm"/> are drawn one on top of the other, as indicated by the arrow on <a id="id276" class="indexterm"/>the right-hand side of the diagram. In order to achieve the right visual effect, the layers need to be added in <em>reverse</em> order, so that each layer added will appear in front of the layers already in the map. That is, the base layer should be added first, then the urban area layer, and so on. The order in which the layers are added to the map is very important; if you get the order wrong, some of your layers will be obscured.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Styling a map</h2></div></div></div><p>As we saw earlier, the map's<a id="id277" class="indexterm"/> styles are defined by creating <code class="literal">mapnik.Style</code> objects and adding <a id="id278" class="indexterm"/>them to the map, giving each one a unique name:</p><div><pre class="programlisting">style = mapnik.Style()
# ...setup style
map.append_style("style_name", style)</pre></div><p>We then tell each map layer which styles we want that layer to use by adding the style name to the layer's <code class="literal">styles</code> list:</p><div><pre class="programlisting">layer.styles.append("style_name")</pre></div><p>You might think that it would be easier to simply add the style definition directly to the map layer, but this process of referring to styles by name is deliberate: it separates <em>what</em> will be displayed from <em>how</em> it is displayed. This approach lets you use the same set of styles across multiple map <a id="id279" class="indexterm"/>layers, or completely alter the appearance of your map just by <a id="id280" class="indexterm"/>swapping style names.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>There is an alternative way of defining your map styles. Rather than creating your own <code class="literal">mapnik.Style</code> objects and adding them to the map one at a time, you can define all your styles at once using an XML-format stylesheet. While this is very powerful, XML stylesheets are rather hard to read and very un-Pythonic. For these reasons, we won't be using XML stylesheets in this book.</p></div></div><p>In our example program, we created a single <code class="literal">mapnik.Style</code> object that consisted of just one rule. This rule had two symbolizers associated with it, telling Mapnik how to draw the interior and exterior of each country's polygon. Rules can be more sophisticated, however, including various <em>conditions</em> which must be met before the rule is used. For example, consider the following Python code snippet:</p><div><pre class="programlisting">symbol1 = ...
symbol2 = ...
symbol3 = ...

rule1 = mapnik.Rule()
rule1.filter = mapnik.Filter("[POPULATION] &lt; 500000")
rule1.symbols.append(symbol1)

rule2 = mapnik.Rule()
rule.filter = mapnik.Filter("[POPULATION] &lt; 1000000")
rule2.symbols.append(symbol2)

rule3 = mapnik.Rule()
rule3.set_else(True)
rule3.symbols.append(symbol3)

style.rules.append(rule1)
style.rules.append(rule2)
style.rules.append(rule3)</pre></div><p>Because the style's rules are evaluated one after the other, this style will draw the feature using <code class="literal">symbol1</code> if the feature's <code class="literal">POPULATION</code> attribute has a value of less than 500,000; it will draw the feature using <code class="literal">symbol2</code> if the feature's <code class="literal">POPULATION</code> attribute has a value between 500,000 and 1,000,000; and it will draw the feature using <code class="literal">symbol3</code> if the feature's <code class="literal">POPULATION</code> attribute is 1,000,000 or more.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>As well as having filters, rules can also have a minimum and maximum scale factor at which the rule will apply. This can be used, for example, to hide smaller features when the map is zoomed right out.</p></div></div><p>Because you can have <a id="id281" class="indexterm"/>multiple symbols within a rule, the way that features are drawn<a id="id282" class="indexterm"/> can also get quite sophisticated. For example, you could define a single rule which uses three separate symbolizers to draw a LineString geometry as a street:</p><div><img src="img/4102_04_04.jpg" alt="Styling a map"/></div><p>As you can imagine, combining symbolizers, rules, filters, and styles will give you tremendous flexibility in choosing which features should appear within a map, and how those features will be drawn.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Learning Mapnik</h1></div></div></div><p>Now that you've seen what <a id="id283" class="indexterm"/>Mapnik can do and have some idea of how Mapnik works, let's look more deeply at some of the other aspects of the Mapnik library. We will be covering datasources, symbolizers, and map rendering in this section of the chapter.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Datasources</h2></div></div></div><p>Each map layer is associated with a <a id="id284" class="indexterm"/>
<strong>datasource</strong> (a subclass of <code class="literal">mapnik.Datasource</code>) that provides the data to be displayed on the map. The various types of datasources are made available through C++ plugins, which are enabled or disabled when Mapnik is compiled. To see if a given type of datasource is available, you check to see if the associated plugin has been installed into your copy of Mapnik. You can see a list of the installed plugins (and therefore, the supported datasources) by typing the following into the Python command prompt:</p><div><pre class="programlisting">
<strong>import mapnik</strong>
<strong>print list(mapnik.DatasourceCache.plugin_names())</strong>
</pre></div><p>The following datasource plugins are currently supported by Mapnik:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>csv</strong>: This<a id="id285" class="indexterm"/> plugin provides the <code class="literal">mapnik.CSV</code> datasource, which <a id="id286" class="indexterm"/>reads tabular data from either a text file or a string. By default, the data is in <strong>CSV</strong> (<strong>comma-separated value</strong>) format, though other similar formats are also supported.<p>The CSV datasource will automatically identify point geometries based on columns with headers containing names like "lat", "latitude", "lon", "long", and "longitude". The datasource will also detect GeoJSON and WKT formatted geometries if the column header is named "geojson" or "wkt". Documentation <a id="id287" class="indexterm"/>for the <code class="literal">csv</code> plugin can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/CSV-Plugin">https://github.com/mapnik/mapnik/wiki/CSV-Plugin</a>.</p></li><li class="listitem" style="list-style-type: disc"><strong>gdal</strong>: This <a id="id288" class="indexterm"/>plugin provides the <code class="literal">mapnik.Gdal</code> datasource. This datasource <a id="id289" class="indexterm"/>uses the GDAL library to read raster-format data and make it available to the map layer. To use this datasource in a map layer, you need to add a style to the map layer which includes a <code class="literal">mapnik.RasterSymbolizer</code> to draw the raster data onto the map. Documentation for the <code class="literal">gdal</code> plugin<a id="id290" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/GDAL">https://github.com/mapnik/mapnik/wiki/GDAL</a>.</li><li class="listitem" style="list-style-type: disc"><strong>ogr</strong>: This <a id="id291" class="indexterm"/>plugin implements the <code class="literal">mapnik.Ogr</code> datasource. This datasource uses the OGR library to read vector-format data. Documentation for<a id="id292" class="indexterm"/> the <code class="literal">ogr</code> plugin<a id="id293" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/OGR">https://github.com/mapnik/mapnik/wiki/OGR</a>.</li><li class="listitem" style="list-style-type: disc"><strong>osm</strong>: The <code class="literal">osm</code> plugin<a id="id294" class="indexterm"/> provides the <code class="literal">mapnik.Osm</code> datasource. This datasource <a id="id295" class="indexterm"/>reads data in OpenStreetMap XML format. Documentation for the <code class="literal">osm</code> plugin<a id="id296" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/OsmPlugin">https://github.com/mapnik/mapnik/wiki/OsmPlugin</a>.</li><li class="listitem" style="list-style-type: disc"><strong>postgis</strong>: This plugin <a id="id297" class="indexterm"/>provides the <code class="literal">mapnik.PostGIS</code> datasource. This <a id="id298" class="indexterm"/>datasource connects to a PostGIS database and reads spatial data from a specified database table. You use the <code class="literal">host</code>, <code class="literal">dbname</code>, <code class="literal">user</code>, and <code class="literal">password</code> parameters when creating a PostGIS datasource to tell Mapnik how to connect to a given PostGIS database, while the <code class="literal">table</code> parameter specifies which table in the database to read the data from.<p>Additional parameters are available for special purposes, for example to limit the extent of the data to display, or to use an SQL subquery to include only some of the records in the database table. Complete documentation for the postgis plugin<a id="id299" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/PostGIS">https://github.com/mapnik/mapnik/wiki/PostGIS</a>.</p></li><li class="listitem" style="list-style-type: disc"><strong>python</strong>: This plugin <a id="id300" class="indexterm"/>provides the <code class="literal">mapnik.Python</code> datasource. This allows you to implement your own datasource by writing a custom Python class that provides access to the data to be displayed. To write a custom Python datasource, you would typically create a subclass of <code class="literal">mapnik.PythonDatasource</code> and then use the name of your custom class as the <code class="literal">factory</code> parameter when calling the mapnik.Python() function to instantiate your datasource. You then implement the necessary methods within your class to provide access to the data. Documentation for the python plugin<a id="id301" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/Python-Plugin">https://github.com/mapnik/mapnik/wiki/Python-Plugin</a>.</li><li class="listitem" style="list-style-type: disc"><strong>raster</strong>: This <a id="id302" class="indexterm"/>plugin implements the <code class="literal">mapnik.Raster</code> datasource, which <a id="id303" class="indexterm"/>displays the contents of a raster image file in either TIFF or GeoTIFF format. While you can also read raster-format data using the <code class="literal">gdal</code> plugin, the <code class="literal">raster</code> plugin is faster when reading these types of files. To use this datasource in a map layer, you need to add a style to the map layer which includes a <code class="literal">RasterSymbolizer</code> to draw the contents of the image file onto the map. Documentation for <a id="id304" class="indexterm"/>the <code class="literal">raster</code> plugin can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/Raster">https://github.com/mapnik/mapnik/wiki/Raster</a>.</li><li class="listitem" style="list-style-type: disc"><strong>shape</strong>: This <a id="id305" class="indexterm"/>plugin provides the <code class="literal">mapnik.Shapefile</code> <a id="id306" class="indexterm"/>datasource, which allows you to read shapefiles. While the <code class="literal">ogr</code> datasource is also able to read shapefiles, it is often more convenient to use the <code class="literal">mapnik.Shapefile</code> datasource. Documentation <a id="id307" class="indexterm"/>for the <code class="literal">shape</code> plugin can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/ShapeFile">https://github.com/mapnik/mapnik/wiki/ShapeFile</a>.</li><li class="listitem" style="list-style-type: disc"><strong>sqlite</strong>: This <a id="id308" class="indexterm"/>plugin provides the <code class="literal">mapnik.SQLite</code> datasource. This datasource reads spatial <a id="id309" class="indexterm"/>data from an SQLite database. The database can either be an ordinary SQLite database holding geometry data in WKB format, or a spatially-enabled database using the Spatialite database extension. Documentation for the <code class="literal">sqlite</code> plugin<a id="id310" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/SQLite">https://github.com/mapnik/mapnik/wiki/SQLite</a>.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Symbolizers</h2></div></div></div><p>Symbolizers do the actual work of <a id="id311" class="indexterm"/>drawing a feature onto the map. Multiple symbolizers are often used to draw a single feature—we saw this earlier when we used a <code class="literal">PolygonSymbolizer</code> to draw the interior of a polygon together with a <code class="literal">LineSymbolizer</code> to draw the polygon's outline.</p><p>There are many different types of symbolizers available within Mapnik, and many of the symbolizers have complex options associated with them. Rather than exhaustively listing all the symbolizers and their various options, we will instead just look at some of the more common types of symbolizers and how they can be used.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>PointSymbolizer</h3></div></div></div><p>The <code class="literal">PointSymbolizer</code> class<a id="id312" class="indexterm"/> is used to draw an image centered over a Point geometry. By <a id="id313" class="indexterm"/>default, each point is displayed as a 4 x 4 pixel black square:</p><div><img src="img/4102_04_05.jpg" alt="PointSymbolizer"/></div><p>To use a different image, you have to create a <code class="literal">mapnik.PathExpression</code> object to represent the path to the desired image file, and then pass that to the <code class="literal">PointSymbolizer</code> object when you instantiate it:</p><div><pre class="programlisting">path = mapnik.PathExpression("/path/to/image.png")
point_symbol = PointSymbolizer(path)</pre></div><div><img src="img/4102_04_06.jpg" alt="PointSymbolizer"/></div><p>Note that <code class="literal">PointSymbolizer</code> draws the <a id="id314" class="indexterm"/>image centered on the desired point. To use a drop-pin image as shown in the preceding example, you will need to add extra transparent whitespace so that the tip of the pin is in the middle of the image, like this:</p><div><img src="img/4102_04_07.jpg" alt="PointSymbolizer"/></div><p>You can control the opacity of the drawn image by setting the symbolizer's <code class="literal">opacity</code> attribute. You can also control whether labels will be drawn on top of the image by setting the <code class="literal">allow_overlap</code> attribute to <code class="literal">True</code>. Finally, you can apply an SVG transformation to the image by setting the <code class="literal">transform</code> attribute to a string containing a standard SVG transformation expression, for example <code class="literal">point_symbol.transform = "rotate(45)"</code>.</p><p>Documentation for the <a id="id315" class="indexterm"/>PointSymbolizer can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/PointSymbolizer">https://github.com/mapnik/mapnik/wiki/PointSymbolizer</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>LineSymbolizer</h3></div></div></div><p>A <code class="literal">mapnik.LineSymbolizer</code> is used<a id="id316" class="indexterm"/> to draw LineString geometries and the outlines of <a id="id317" class="indexterm"/>Polygon geometries. When you create a new LineSymbolizer, you would typically configure it using two parameters: the color to use to draw the line as a <code class="literal">mapnik.Color</code> object, and the width of the line, measured in pixels. For example:</p><div><pre class="programlisting">line_symbol = mapnik.LineSymbolizer(mapnik.Color("black"), 0.5)</pre></div><p>Notice that you can use fractional line widths; because Mapnik uses anti-aliasing, a line narrower than 1 pixel will often look better than a line with an integer width if you are drawing many lines close together.</p><p>In addition to the color and the width, you can also make the line semi-transparent by setting the <code class="literal">opacity</code> attribute. This should be set to a number between 0.0 and 1.0, where 0.0 means the line will be completely transparent and 1.0 means the line will be completely opaque.</p><p>You can also use the <code class="literal">stroke</code> attribute to get access to (or replace) the stroke object used by the line symbolizer. The stroke object, an instance of <code class="literal">mapnik.Stroke</code>, can be used for more complicated visual effects. For example, you can create a dashed line effect by calling the stroke's <code class="literal">add_dash()</code> method:</p><div><pre class="programlisting">line_symbol.stroke.add_dash(5, 7)</pre></div><p>Both numbers are <a id="id318" class="indexterm"/>measured in pixels; the first number is the length of the dash segment, while the second is the length of the gap between dashes.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Note that you can create alternating dash patterns by calling <code class="literal">add_dash()</code> more than once.</p></div></div><p>You can also set the stroke's <code class="literal">line_cap</code> attribute to control how the ends of the line should be drawn, and the stroke's <code class="literal">line_join</code> attribute to control how the joins between the individual line segments are drawn whenever the LineString changes direction. The <code class="literal">line_cap</code> attribute can be set to one of the following values:</p><div><pre class="programlisting">
<strong>mapnik.line_cap.BUTT_CAP</strong>
<strong>mapnik.line_cap.ROUND_CAP</strong>
<strong>mapnik.line_cap.SQUARE_CAP</strong>
</pre></div><p>The <code class="literal">line_join</code> attribute can be set to one of the following:</p><div><pre class="programlisting">
<strong>mapnik.line_join.MITER_JOIN</strong>
<strong>mapnik.line_join.ROUND_JOIN</strong>
<strong>mapnik.line_join.BEVEL_JOIN</strong>
</pre></div><p>Documentation for <a id="id319" class="indexterm"/>the <code class="literal">LineSymbolizer</code> class can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/LineSymbolizer">https://github.com/mapnik/mapnik/wiki/LineSymbolizer</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>PolygonSymbolizer</h3></div></div></div><p>The<a id="id320" class="indexterm"/> <code class="literal">mapnik.PolygonSymbolizer</code> class<a id="id321" class="indexterm"/> is used to fill the interior of a Polygon geometry with a given color. When you create a new PolygonSymbolizer, you would typically pass it a single parameter: the <code class="literal">mapnik.Color</code> object to use to fill the polygon. You can also change the opacity of the symbolizer by setting the <code class="literal">fill_opacity</code> attribute, for example:</p><div><pre class="programlisting">fill_symbol.fill_opacity = 0.8</pre></div><p>Once again, the opacity is measured from 0.0 (completely transparent) to 1.0 (completely opaque).</p><p>There is one other PolygonSymbolizer attribute which you might find useful: <code class="literal">gamma</code>. The <code class="literal">gamma</code> value can be <a id="id322" class="indexterm"/>set to a number between 0.0 and 1.0. The <code class="literal">gamma</code> value controls the amount of anti-aliasing used to draw the edge of the polygon; with the default <code class="literal">gamma</code> value of <code class="literal">1.0</code>, the edges of the polygon will be fully anti-aliased. While this is usually a good thing, if you try to draw adjacent polygons with the same color, the antialiasing will cause the edges of the polygons to be visible rather than combining them into a single larger area. By turning down the gamma slightly (for example, <code class="literal">fill_symbol.gamma = 0.6</code>), the edges between adjacent polygons will disappear.</p><p>Documentation for<a id="id323" class="indexterm"/> the <code class="literal">PolygonSymbolizer</code> class can be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/PolygonSymbolizer">https://github.com/mapnik/mapnik/wiki/PolygonSymbolizer</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>TextSymbolizer</h3></div></div></div><p>The <code class="literal">TextSymbolizer</code> class<a id="id324" class="indexterm"/> is used to draw<a id="id325" class="indexterm"/> textual labels onto a map. This type of symbolizer can be used for point, LineString, and Polygon geometries. The following example shows how a TextSymbolizer can be used:</p><div><pre class="programlisting">text_symbol = mapnik.TextSymbolizer(mapnik.Expresion("[label]"), "DejaVu Sans Book", 10, mapnik.Color("black"))</pre></div><p>As you can see, four parameters are typically passed to the TextSymbolizer's initializer:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">mapnik.Expression</code> object defining the text to be displayed. In this case, the text to be displayed will come from the <code class="literal">label</code> attribute in the datasource.</li><li class="listitem" style="list-style-type: disc">The name of the font to use for drawing the text. To see what fonts are available, type the following into the Python command line:<div><pre class="programlisting">import mapnik
for font in mapnik.FontEngine.face_names():
    print font</pre></div></li><li class="listitem" style="list-style-type: disc">The font size, measured in pixels.</li><li class="listitem" style="list-style-type: disc">The color to use to draw the text.</li></ul></div><p>By default, the text will be drawn in the center of the geometry; for example:</p><p> </p><div><img src="img/4102_04_08.jpg" alt="TextSymbolizer"/></div><p>
</p><p>This positioning of the label is called <a id="id326" class="indexterm"/>
<strong>point</strong> <strong>placement</strong>. The TextSymbolizer allows <a id="id327" class="indexterm"/>you to change this to use what is called<a id="id328" class="indexterm"/> <strong>line</strong> <strong>placement</strong>, where the label will be drawn along the lines:</p><div><pre class="programlisting">text_symbol.label_placement = mapnik.label_placement.LINE_PLACEMENT</pre></div><div><img src="img/4102_04_09.jpg" alt="TextSymbolizer"/></div><p>As you can see, this causes the label to be drawn along the length of a LineString geometry, or along the perimeter of a Polygon. The text won't be drawn at all for a Point geometry, since there are no lines within a point.</p><p>The TextSymbolizer will normally just draw the label once, but you can tell the symbolizer to repeat the label if you wish by specifying a pixel gap to use between each label:</p><div><pre class="programlisting">text_symbol.label_spacing = 30</pre></div><div><img src="img/4102_04_10.jpg" alt="TextSymbolizer"/></div><p>By default, Mapnik is<a id="id329" class="indexterm"/> smart enough to stop labels from overlapping each other. If possible, it moves the label slightly to avoid an overlap, and then hides the label completely if it would still overlap. For example:</p><div><img src="img/4102_04_11.jpg" alt="TextSymbolizer"/></div><p>You can change this by setting the <code class="literal">allow_overlap</code> attribute:</p><div><pre class="programlisting">text_symbol.allow_overlap = True</pre></div><div><img src="img/4102_04_12.jpg" alt="TextSymbolizer"/></div><p>Finally, you can set a halo effect to draw a lighter-colored border around the text so that it is visible even against a dark background. For example,</p><div><pre class="programlisting">text_symbol.halo_fill = mapnik.Color("white")
text_symbol.halo_radius = 1</pre></div><div><img src="img/4102_04_13.jpg" alt="TextSymbolizer"/></div><p>There are many more <a id="id330" class="indexterm"/>labeling options, all of which are described at length in the documentation for the <code class="literal">TextSymbolizer</code> class. This can<a id="id331" class="indexterm"/> be found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/TextSymbolizer">https://github.com/mapnik/mapnik/wiki/TextSymbolizer</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>RasterSymbolizer</h3></div></div></div><p>The <code class="literal">RasterSymbolizer</code> class is<a id="id332" class="indexterm"/> used to draw raster-format data onto a map. This type of symbolizer<a id="id333" class="indexterm"/> is typically used in conjunction with a Raster or GDAL datasource. To create a new raster symbolizer, you instantiate a new <code class="literal">mapnik.RasterSymbolizer</code> object:</p><div><pre class="programlisting">raster_symbol = mapnik.RasterSymbolizer()</pre></div><p>The raster symbolizer will automatically draw any raster-format data provided by the map layer's datasource. This is often used to draw a basemap onto which the vector data is to be displayed; for example:</p><div><img src="img/4102_04_14.jpg" alt="RasterSymbolizer"/></div><p>While there are some advanced options to control the way the raster data is displayed, in most cases, the only option you might be interested in is the <code class="literal">opacity</code> attribute. As usual, this sets the opacity for the displayed image, allowing you to layer semi-transparent raster images one on top of the other.</p><p>Documentation for <a id="id334" class="indexterm"/>the <code class="literal">RasterSymbolizer</code> can be <a id="id335" class="indexterm"/>found at <a class="ulink" href="https://github.com/mapnik/mapnik/wiki/RasterSymbolizer">https://github.com/mapnik/mapnik/wiki/RasterSymbolizer</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Map rendering</h2></div></div></div><p>We have now examined in detail <a id="id336" class="indexterm"/>many of the building blocks for generating maps: layers, datasources, styles, rules, filters, and symbolizers. Using what you have learned, you should be able to build and style your own maps. But what can you do with a <code class="literal">mapnik.Map</code> object once you have set one up?</p><p>In the example program we examined at the start of this chapter, we used the <code class="literal">mapnik.render_to_file()</code> function to save the generated map into an image file. When rendering the map, you first have to set the map's<a id="id337" class="indexterm"/> <strong>extent</strong>—that is, the rectangle that defines the visible portion of the map:</p><div><img src="img/4102_04_15.jpg" alt="Map rendering"/></div><p>Only the visible extent of the map will be included in the generated image; everything else will be ignored.</p><p>In our example program, we used <code class="literal">map.zoom_all()</code> to set the visible extent of the map to include all the features in all the map layers. Of course, there are times when you only want to display part of the overall map. To do this, you can use the <code class="literal">map.zoomToBox()</code> method to set the visible extent of the map. For example:</p><div><pre class="programlisting">map.zoomToBox(mapnik.Box2d(-124.5, 32.0, -114.0, 43.0))</pre></div><p>The four numbers represent the minimum longitude, the minimum latitude, the maximum longitude, and the maximum latitude, respectively. If you execute this statement using these latitude and longitude values, the visible extent of the map will cover approximately the American state of California.</p><p>Note that you aren't limited to<a id="id338" class="indexterm"/> only rendering a map once. If you want, you can create multiple images from a single <code class="literal">mapnik.Map</code> object, changing the visible extent and then calling <code class="literal">mapnik.render_to_file()</code> to save the newly-visible portion of the map to a different file each time.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>A working example</h1></div></div></div><p>Let's put together everything that we<a id="id339" class="indexterm"/> have learned to write a program that can display the contents of a shapefile. This is quite a useful program to have, as you can manipulate or generate some spatial data, save the results into a shapefile, and then run this program to display the shapefile's contents as a generated map image.</p><p>We'll call our program <code class="literal">shapeToMap.py</code>. Create this file, and start entering the following Python code into it:</p><div><pre class="programlisting">import mapnik

LAYERS = [
    {'shapefile'  : "TM_WORLD_BORDERS-0.3.shp",
     'lineColor'  : "black",
     'lineWidth'  : 0.4,
     'fillColor'  : "#709070",
     'labelField' : "NAME",
     'labelSize'  : 12,
     'labelColor' : "black"
    }
]

BACKGROUND_COLOR = "#a0c0ff"

BOUNDS_MIN_LAT  = 35.26
BOUNDS_MAX_LAT  = 71.39
BOUNDS_MIN_LONG = -10.90
BOUNDS_MAX_LONG = 41.13

MAX_WIDTH  = 1600
MAX_HEIGHT = 800</pre></div><p>Note that the various constants we have defined here will be used to configure the map that we are going to generate:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LAYERS</code>: This is a<a id="id340" class="indexterm"/> list of the map layers to display on the map. Each item in this list should be a dictionary with all or some of following entries:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">shapefile</code>: The name and path of the desired shapefile</li><li class="listitem" style="list-style-type: disc"><code class="literal">lineColor</code>: The hexadecimal color code to use to draw the feature's exterior, if any</li><li class="listitem" style="list-style-type: disc"><code class="literal">lineWidth</code>: The width of the line to use to draw the feature's exterior, measured in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">fillColor</code>: The hexadecimal color code to use to draw the feature's interior, if any</li><li class="listitem" style="list-style-type: disc"><code class="literal">labelField</code>: The name of the attribute in the source file to use to label each feature, if any</li><li class="listitem" style="list-style-type: disc"><code class="literal">labelSize</code>: The font size to use when labeling the features, measured in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">labelColor</code>: The hexadecimal color code to use to draw the label</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">BACKGROUND_COLOR</code>: This is the hexadecimal color code to use to draw the background of the map.</li><li class="listitem" style="list-style-type: disc"><code class="literal">BOUNDS_MIN_LAT</code>, <code class="literal">BOUNDS_MIN_LONG</code>, <code class="literal">BOUNDS_MAX_LAT</code>, and <code class="literal">BOUNDS_MAX_LONG</code>: These define the visible extent of the map you want to generate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">MAX_WIDTH</code> and <code class="literal">MAX_HEIGHT</code>: These specify the maximum size of the generated map image. Note that the generated image may actually be smaller than these values, depending on the aspect ratio of the bounding rectangle.</li></ul></div><p>Whenever you want to generate a map using this program, you will need to edit these constants to suit your requirements.</p><p>We next need to calculate the height and width to use for our map. Because the visible extent can be any shape, we calculate the actual width and height to be as large as possible while matching the aspect ratio of the visible extent. We do this by first calculating the map's width and height so that the width is the maximum allowable width, and the height is whatever is needed to match the aspect ratio of the visible extent. To do this, add the following code to the end of your program:</p><div><pre class="programlisting">extent = mapnik.Envelope(BOUNDS_MIN_LONG, BOUNDS_MIN_LAT,  BOUNDS_MAX_LONG, BOUNDS_MAX_LAT)
aspectRatio = extent.width() / extent.height()

mapWidth = MAX_WIDTH
mapHeight = int(mapWidth / aspectRatio)</pre></div><p>We next see if the<a id="id341" class="indexterm"/> calculated height is too big, and if so, scale down the map so that the height is no bigger than the allowable maximum:</p><div><pre class="programlisting">if mapHeight &gt; MAX_HEIGHT:
    scaleFactor = float(MAX_HEIGHT) / float(mapHeight)
    mapWidth = int(mapWidth * scaleFactor)
    mapHeight = int(mapHeight * scaleFactor)</pre></div><p>This ensures that the generated map is as large as possible, while ensuring the map has the same aspect ratio as the visible extent.</p><p>Now that we know how big our map will be, we can create and initialize our <code class="literal">mapnik.Map</code> object:</p><div><pre class="programlisting">map = mapnik.Map(mapWidth, mapHeight)
map.background = mapnik.Color(BACKGROUND_COLOR)</pre></div><p>We next need to define our various map styles, using a single style and rule for each of our map layers. Note that we use the various dictionary entries from our <code class="literal">LAYERS</code> list to define a map style for each layer:</p><div><pre class="programlisting">for i,src in enumerate(LAYERS):
    style = mapnik.Style()
    rule = mapnik.Rule()

    if src['fillColor'] != None:
        symbol = mapnik.PolygonSymbolizer(
                    mapnik.Color(src['fillColor']))
        rule.symbols.append(symbol)
    if src['lineColor'] != None:
        symbol = mapnik.LineSymbolizer(
                    mapnik.Color(src['lineColor']),
                    src['lineWidth'])
        rule.symbols.append(symbol)
    if src['labelField'] != None:
        symbol = mapnik.TextSymbolizer(
                     mapnik.Expression(
                            "[" + src['labelField'] + "]"),
                            "DejaVu Sans Bold",
                            src['labelSize'],
                            mapnik.Color(src['labelColor']))
        symbol.allow_overlap = True
        rule.symbols.append(symbol)

    style.rules.append(rule)

    map.append_style("style-"+str(i+1), style)</pre></div><p>We now need to<a id="id342" class="indexterm"/> define the various layers for our map:</p><div><pre class="programlisting">for i,src in enumerate(LAYERS):
    layer = mapnik.Layer("layer-"+str(i+1))
    layer.datasource = mapnik.Shapefile(file=src['shapefile'])
    layer.styles.append("style-"+str(i+1))
    map.layers.append(layer)</pre></div><p>Finally, we render the map image:</p><div><pre class="programlisting">map.zoom_to_box(extent)
mapnik.render_to_file(map, "map.png", "png")</pre></div><p>Since you have studied the various classes and methods in the <em>Learning Mapnik</em> section of this chapter, you should hopefully be able to understand what all this code does. If anything is unclear, please go back and review the relevant part of that section. A complete copy of this program can be downloaded as part of the source code available for this chapter.</p><p>Using the various constants we defined earlier, you should be able to use this program to draw the contents of the World Borders Dataset. Simply place the <code class="literal">TM_WORLD_BORDERS-0.3</code> directory into the same folder as the <code class="literal">shapeToMap.py</code> program, and try running the program. All going well, the program should generate a <code class="literal">map.png</code> image, which displays the contents of the World Borders Dataset for Western and Central Europe:</p><div><img src="img/4102_04_16.jpg" alt="A working example"/></div><p>If you look closely at<a id="id343" class="indexterm"/> this image, you'll notice that some of the labels are hidden behind other polygons. This is because we have told our program to draw the polygons and their labels in the same map layer. To fix this, replace your <code class="literal">LAYERS</code> definition with the following:</p><div><pre class="programlisting">LAYERS = [
    {'shapeFile'  : "TM_WORLD_BORDERS-0.3/TM_WORLD_BORDERS-0.3.shp",
     'lineColor'  : "black",
     'lineWidth'  : 0.4,
     'fillColor'  : "#709070",
     'labelField' : None,
     'labelSize'  : None,
     'labelColor' : None,
    },	
    {'shapeFile'  : "TM_WORLD_BORDERS-0.3/TM_WORLD_BORDERS-0.3.shp",
     'lineColor'  : None,
     'lineWidth'  : None,
     'fillColor'  : None,
     'labelField' : "NAME",
     'labelSize'  : 12,
     'labelColor' : "black"
    }
]</pre></div><p>As you can see, we're now displaying the shapefile in two separate map layers, one to draw the country polygons, and a second map layer to draw all the labels in front of the polygons. If you run your program again, you'll see that the labeling problem has been fixed.</p><p>This should give you an idea of how useful the <code class="literal">shapeToMap.py</code> program can be. Simply by changing the constants at the top of the program, you can quickly view the contents of any shapefile. In fact, many of the illustrations in this book were generated using a modified version of this program.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Next steps</h1></div></div></div><p>While the <code class="literal">shapeToMap.py</code> program has <a id="id344" class="indexterm"/>been kept deliberately simple to make it easier to understand, there is a lot that can be done to improve this program and make it more useful. You might like to try challenging yourself by implementing the following new features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add an optional <code class="literal">labelHalo</code> entry to each map layer, which is used to draw a halo around the label text.</li><li class="listitem" style="list-style-type: disc">Add a <code class="literal">labelPlacement</code> entry to the map layer, to make it easy to control the label placement options.</li><li class="listitem" style="list-style-type: disc">Add a <code class="literal">labelAllowOverlap</code> entry to the map layer, which controls whether or not the labels are allowed to overlap.</li><li class="listitem" style="list-style-type: disc">Add a <code class="literal">filter</code> entry to the map layer, which is used to build a <code class="literal">mapnik.Filter()</code> expression to limit the set of features displayed within the map layer.</li><li class="listitem" style="list-style-type: disc">Add an option to dynamically calculate the visible extent of the map based on the bounding box for each feature. This would allow you to generate the map without having to calculate the bounds beforehand.</li><li class="listitem" style="list-style-type: disc">Add a call to <code class="literal">os.system("open map.png")</code> (for Mac OS X) or <code class="literal">os.startfile("map.png")</code> (for MS Windows) to automatically display the image once it has been generated.</li><li class="listitem" style="list-style-type: disc">Add support for shapefiles which use a projection other than the default EPSG 4326.</li><li class="listitem" style="list-style-type: disc">Load the configuration constants from a separate module, so you don't have to edit the Python source file every time you want to change the data to be displayed.</li></ul></div><p>A more sophisticated <a id="id345" class="indexterm"/>version of <code class="literal">shapeToMap.py</code> called <code class="literal">generateMap.py</code> has been provided as part of the source code for this chapter. The <code class="literal">generateMap.py</code> program implements all of the preceding suggestions.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we covered the Mapnik map-generation library and how to use it within a Python program to create great-looking maps. You installed Mapnik, looked at a simple example of how it could be used, and then began to learn more about the process of constructing and styling a map.</p><p>We then examined Mapnik in more detail, looking at the various types of datasources which you can use to load spatial data into a map layer. We also examined the various symbolizers which can be used to display spatial features, how the visible extent is used to control the portion of the map to be displayed, and how to render a map as an image file. We then created a useful Python program called <code class="literal">shapeToMap.py</code>, which can be used to generate a map out of any spatial data stored in shapefiles, and finally looked at some of the ways in which <code class="literal">shapeToMap.py</code> could be improved to make it even more useful.</p><p>In the next chapter, we will look at various tools and techniques for analyzing spatial data, including how to use Python to solve a variety of interesting geospatial problems.</p></div></div>
</body></html>