- en: Object-Oriented System to Track Cryptocurrencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce a new way of programming that we have not
    explicitly used before in the book. It's called object-oriented programming, and
    it will be used throughout our third and final example in the book. Object-oriented
    programming is very popular among programmers, and it's mainly used to allow for
    complex abstraction relations to be modeled and implemented in such a way that
    the evolution of the system is not jeopardized.
  prefs: []
  type: TYPE_NORMAL
- en: When developing object-oriented systems, and in general when we program, we
    should strive for simplicity, but it doesn't come naturally. When dealing with
    a complex domain, it's easier to create complex rather than simple code. Programmers
    must make an active effort to produce simple code, since simplicity depends mostly
    on the programmer, not the language. In this chapter, we will show you how to
    efficiently work with object-oriented code by introducing the ideas and concepts
    that support it, and we will later illustrate how to implement it using three
    of R's most used object models.
  prefs: []
  type: TYPE_NORMAL
- en: R has various object models, or object-oriented systems, so it can be a bit
    intimidating at first. The goal of this chapter is not to make you an expert in
    object-oriented programming or in each of R's object models, but to help you understand
    how to implement the basic building blocks of object-oriented programs with R's
    different object models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important topics covered in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental object-oriented programming concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design and architecture of object-oriented systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: R's parametric polymorphism through generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different object models available for R
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing functionality from R's different object models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's required packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will make use of the `methods` and `R6` packages to load the S4
    and R6 object models functionality. You should know that interactive R sessions
    load the `methods` by default, but non-interactive sessions don't, so you need
    to explicitly load it in such cases. The `jsonlite` and `lubridate` packages are
    brought to simplify some common tasks like getting data from JSON APIs and transforming
    dates. For more information, take a look at [Appendix](part0296.html#8Q96G0-f494c932c729429fb734ce52cafce730),
    *Required Packages*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `R6` | R6 object model |'
  prefs: []
  type: TYPE_TB
- en: '| `methods` | S4 object model |'
  prefs: []
  type: TYPE_TB
- en: '| `lubridate` | Easily transform dates |'
  prefs: []
  type: TYPE_TB
- en: '| `jsonlite` | Retrieve data from JSON APIs |'
  prefs: []
  type: TYPE_TB
- en: The cryptocurrencies example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **cryptocurrency** is a digital currency designed to work as a medium of exchange.
    Cryptocurrencies use cryptography to secure and verify transactions, as well as
    to control the creation of new units. Simply put, cryptocurrencies are entries
    in a public and distributed database that can only be changed by algorithmic consensus,
    and they remove the need for trusted third-parties for transaction handling and
    currency emission. The concept closely resembles peer-to-peer networks for file
    sharing, with an algorithmic monetary policy on top. If you want to learn more
    about cryptocurrencies, you should definitely look at videos starring Andreas
    Antonopoulos. He can make very complex concepts very easy to understand. You may
    also want to read his recollection of  conferences in his book, *The Internet
    of Money, by **Merkle Bloom LLC, 2016*.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptocurrencies are being heavily developed nowadays to offer many innovative
    features that will have disruptive effects during upcoming years, but for now,
    they are mostly used for buying goods and investing. Every transaction consists
    of the amount of coins transferred, as well as the sender's and recipient’s public
    keys, also known as wallet addresses. We will use these public keys in the example
    for this chapter to keep track of how many coins we own, and we will also use
    CoinMarketCap API ([https://coinmarketcap.com/](https://coinmarketcap.com/)) to
    keep track of cryptocurrency prices.
  prefs: []
  type: TYPE_NORMAL
- en: Since this will be a complex system, we will use object-oriented programming
    to modularize it and build it part by part. At the end of the example, we will
    have a system that can be turned on to start tracking our cryptocurrency assets
    as well as their prices, and to save the real-time data to disk for later analysis.
    Later, in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    I*mplementing an Efficient Simple Moving Average*, we will use this data, in simulated
    form, to develop various **Simple Moving Average** (**SMA**) implementations to
    showcase how R code can be improved to become faster, as well as more readable.
    Finally, in [Chapter 10](part0271.html#82E8E0-f494c932c729429fb734ce52cafce730),
    *Adding Interactivity with Dashboards,* we will see how to create a modern web
    application to show the SMAs developed, as well as the data collected.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As statisticians and data scientists, we strive to build systems that produce
    valuable insights. To accomplish this, we normally use two tools—mathematics and
    computers. This book was developed for people who are comfortable with the mathematics
    side but feel that their R programming skills need improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when people with mathematical backgrounds are introduced to programming,
    they are introduced through a *functional approach*, which means that they think
    in terms of algorithms with inputs and outputs, which are implemented as functions.
    This way of working is intuitive if you come from a mathematical background and
    are not dealing with high level abstractions, and it is the way we have been working
    throughout the book up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show a different way of programming called **object-oriented
    programming**. Object-oriented programming and the object model are powerful and
    unifying ideas in many fields and can be found in most popular programming languages,
    R being no exception. In my experience, people who have not had conscious experience
    with object-oriented programming normally find it confusing at first and don't
    understand its potential. They see it as more of a hassle than an enabler, and
    think that it gets in their way when trying to write some code. In this chapter,
    we will try to distill the object-oriented paradigm in a way that is understandable
    to people who feel comfortable with a functional approach (not necessarily with
    functional programming), and we will show you how to implement a small object-oriented
    system that continuously retrieves live data from cryptocurrency markets and wallets.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start implementing such a system, we need to introduce the concepts
    that will be used throughout the rest of the example, including the upcoming two
    chapters. In the following paragraphs, you will find very general descriptions
    of the concepts behind the object model, which is implemented with object-oriented
    programming, as well as explanations that will hopefully convince you that this
    way of programming can be very powerful for certain problems. For a more exhaustive
    and formal introduction, you should read the excellent book by Booch, Maksimchuck,
    Engle, Young, Conallen, and Houston, titled, *Object-Oriented Analysis and Design
    With Applications, by Addison-Wesley, 2007*.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main purpose of object-oriented programming is to efficiently manage complexity.
    It's a way of organizing code and data such that you can develop well-delimited
    abstractions with controlled dependencies to evolve a complex system in a controlled
    manner. These abstractions are called **objects** and they offer behavior in response
    to messages. The behavior they offer to other objects is cataloged in an interface
    which is implemented in this object's public methods. Objects request behavior
    from other objects, and when they do, they are said to depend on them. The messages
    sent between all these objects and the associated behavior are what make an object-oriented
    system useful.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let's explain more about these concepts. An object
    is an entity in abstract form. For example, integers, cars, dogs, buildings, credit
    cards, and cryptocurrencies, could all be objects in an object-oriented system.
    An object is a well-defined idea of something, and we know that different kinds
    of objects have different kinds of behaviors associated with them, and some of
    those behaviors require some data, which is normally stored within the object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the idea of an integer is not associated with any specific number,
    just as the idea of a car is not associated with any specific model or brand.
    For those familiar with statistics, think of a random variable as an object, and
    a realization of that random variable as an instance.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming is a way of thinking of programs as interactions
    among objects instead of steps through an algorithm. You can still understand
    an object-oriented system as a big algorithm with lots of functions calling each
    other, but for large enough systems this will not be a fruitful or enjoyable process.
    When dealing with object-oriented systems, you're better off just trying to understand
    a part of the system by itself and clearly defining how it should communicate
    with other parts. Trying to fully understand a complex object-oriented system
    can prove to be quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Important concepts behind object-oriented languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to implement the object model in object-oriented languages,
    and the specific ways it is implemented imply different sets of properties for
    the language. Some of these properties are encapsulation, polymorphism, generics
    (parametric polymorphism), hierarchies (inheritance and composition), subtyping,
    and several others. They are powerful, high-level ideas with precise definitions
    that impose restrictions on how a language should behave. Don't worry too much
    about them for now; we will explain the necessary ones as we move forward.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting exercise is to find languages that are considered to be object-oriented,
    yet don't use one or more of these properties. For example, the class concept
    is unnecessary, as seen with prototype-based languages like JavaScript. Subtyping
    is also unnecessary, since it doesn't make sense in dynamically typed languages
    like R or Python. We could go on and on, but you get the idea—a single language
    that has all of these properties does not exist. Furthermore, the only property
    that is found in all object-oriented languages is polymorphism. That's why people
    commonly say that polymorphism is the essence of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Any professional object-oriented programmer should understand these properties
    and have formal experience with languages that implement them. However, in the
    following paragraphs, we will give a high-level explanation of the most common
    ones in R's different object models—encapsulation, polymorphism (with and without
    generics), and hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation is about hiding an object's internals from other objects. As the
    designer of the C++ language, Bjarne Stroustrup, put it, *Encapsulation hides
    information not to faciliate fraud, but to prevent mistakes*. By giving other
    objects a minimal catalog of messages (public methods) that they can send to an
    object, we are helping them commit less mistakes and avoid getting their hands
    in tasks that do not pertain them. This, in turn, helps with decoupling objects
    from themselves and providing cohesiveness within objects.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to think about encapsulation is like when you go to a restaurant—you
    message the waiter with what you want, and the waiter then delegates the cooking
    of what you requested to the restaurant's chef. You have no business in going
    into the restaurant's kitchen and telling the chef how to cook your meal, and
    if the chef wants to change the way he cooks a certain dish, she can do so without
    you having to know about it. It's the same with objects; they should not get inside
    another object and tell it how to do its job. This sounds simple enough, but in
    practice, it's very easy to violate this principle. We will talk more about this
    when we reach the *Law of Demeter* section later in this chapter. Technically,
    the process of separating the interface from the implementation is called **encapsulation**.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is perhaps the most powerful feature of object-oriented programming
    languages, next to their support for abstraction, and it is what distinguishes
    object-oriented programming from more traditional programming with abstract data
    types. **Polymorphism** literally means many forms, and that's exactly what it
    is used for in object-oriented programming. The same name will denote different
    meanings, depending on the context in which it is used, just as with our natural
    languages. This allows for much cleaner and understandable abstractions, as well
    as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loosely speaking, polymorphism can be implemented in two different ways: from
    inside or from outside objects. When it''s implemented from inside objects, each
    object must provide a definition of how it will deal with a given message. This
    is the most common method, and you can find it in Java or Python. R is very special
    in this manner and implements the outside approach, formally know as **generics**,
    or **parametric polymorphism**. This way of programming can be frustrating for
    people who have only used the inside approach, but it can be very flexible. The
    outside approach lets you define a generic method or function for types of objects
    that you have not yet defined, and may never do. Java and Python can also implement
    this type of polymorphism, but it''s not their nature, just as R can also implement
    the inside, but it''s not its nature, either.'
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hierarchies can be formed in two ways—inheritance and composition. The idea
    of **inheritance** is to form new classes as specialized versions of old ones.
    The specialized classes are subclasses and the more general ones are superclasses.
    This type of relationship is often referred to as an **is-a** type of relationship,
    since *a subclass is a type of the superclass*. For example, a lion is a type
    of animal, so animal would be the superclass and lion the subclass. Another type
    of relationship is known as the **has-a** relation. This means that one class
    has instances of another class. For example, a car has wheels. We wouldn't say
    that wheels are a type of car, so there's no inheritance there, but we would say
    that they are part of a car, which implies **composition**.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where it's not so clear whether a relation should be modeled
    with inheritance or with composition, and in those cases, you should decide to
    move along with composition. In general, people agree that composition is a much
    more flexible way of designing a system, and that you should only use inheritance
    where you must model the specialization of a class. Note that when you design
    your systems with composition instead of inheritance, your objects take on different
    roles and they become more tool-like. That's a good thing, because you can easily
    plug them into each other and replace them as necessary, and you also usually
    end up with larger numbers of smaller classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand some fundamental ideas behind object-oriented programming,
    you may realize the power that combining these ideas gives you. If you have a
    system that encapsulates behavior and only publicly offers what is needed by others
    to operate correctly, which can dynamically respond to abstract ideas with correct
    and concrete actions and allows for concept hierarchies to interact with other
    concept hierarchies, then you can rest assured that you can manage quite a bit
    of complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the following paragraphs, we will explain some more down-to-earth concepts
    which are basic building blocks in most object-oriented systems and that you need
    to understand to be able to follow the code we will develop for the example.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects must be defined in some way so that we can generate specific instances
    from them. The most common way to provide those definitions is through classes.
    A **class** is a piece of code that provides the definition for an object, including
    the behavior it offers in response to messages from other objects, as well as
    the internal data it needs to provide that behavior. The behavior for a class
    is implemented in its methods. More on this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Classes must be created at some point, and that's where constructors come into
    play. The vast majority of the time, when you create an instance of a class, you
    will want it to contain some data about itself. That data is assigned to the class
    when it's created through its constructor. Specifically, a **constructor** is
    a function whose job is to create an instance of a class with a specific set of
    data. As you know, that data should be kept inside the object, and other objects
    should not interact with this data directly. Instead, the object should offer
    public methods that other objects may use to get the data or behavior they need.
  prefs: []
  type: TYPE_NORMAL
- en: Public and private methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are functions contained within classes, and in general, they will
    be either public or private. In general, methods have access to classes'' data
    (which should be encapsulated away from other objects), as well as their public
    and private methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public methods** are visible to other objects and should be as stable as
    possible since other objects may come to depend on them. If you change them, you
    may unexpectedly break another object''s functionality. **Private methods** are
    visible only to the instance itself, which means that other objects cannot (or
    should not, as is the case with R) call these methods directly. Private methods
    are allowed to change as often as necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Public methods make use of other methods, public or private, to further delegate
    behavior. This delegation breaks up a problem into very small pieces which are
    easily understandable, and the programmer reserves the right to modify private
    methods as she sees fit. Other objects should not depend on them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that technically, only public methods exist in R. Under one of R's object
    models you can hide methods and under another you can put them in a different
    environment, but that does not make them inaccessible, as the case would be with
    private methods in other languages. Derived from that, we also don't touch on
    the concept of protected methods, which are methods that are visible to a class
    and its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Even if there are technically no private methods in R, we will program as if
    there were. Not having some type of compiler or error-checking mechanism to tell
    you that you're accessing private methods when you shouldn't is not an excuse
    for doing so. You should always be producing high quality code, even if not explicitly
    enforced by language mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: What we said previously implies that you should make your objects as private
    as possible to keep them cohesive and decoupled, which are fancy terms for self-contained
    and independent. In other words, try to reduce the number of methods in your objects
    as much as possible. Of course, cohesiveness and decoupleness are far more general
    ideas than just reducing the number of private methods, but it's a good start.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces, factories, and patterns in general
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **interface **is the part of a class that is made public for other objects
    to use. Specifically, it's a set of definitions for the public methods of a class.
    Of course, the more public methods an object has, the more responsibilities and
    the less flexibility it has towards the outside world. Note that the interface
    does not provide any details about implementation; it's just a contract which
    defines what inputs and what outputs are expected when a method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to give yourself the flexibility of changing the object
    for a given task according to context. You know that as long as the interfaces
    for the objects you want to interchange are the same, everything should be fine
    (of course, this assumes that the programmers implement said interfaces correctly).
    If you don't plan for it in advance, switching these objects can be a difficult
    task. That's where factories come into play. A factory is a way to choose, at
    runtime and according to context, which object to use from a set of predefined
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '**Factories** basically work as `if` statements that choose which class to
    use for a task based on some condition. They are a way of investing a little more
    effort today so that you save yourself quite a bit of effort later, when you decide
    to use a different object for the same interface. They should be used where you
    anticipate you will be using different kinds of objects in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factories are one of many know **patterns** for object-oriented programming.
    These patterns are developed by people with a lot of experience on design decisions,
    and, as such, they know what solutions can be generally good for certain types
    of problems. Documenting these patterns is very useful and allows many people
    to save a lot of time and effort by not having to reinvent the wheel in their
    own context. A great source for some fundamental object-oriented patterns can
    be found in Gamma, Vlissides, Johnson, and Helmfamous''s famous, *Design Patterns:
    Elements of Reusable Object-Oriented Software*, by Addison-Wesley, 1994. We encourage
    the reader to study these patterns, as they will surely prove useful at some point.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing three object models in R – S3, S4, and R6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of general object-oriented concepts,
    we will dig into R's own object models. There are two main sources of confusion
    when doing object-oriented programming in R. Before we start developing code, we
    will explain what these sources of confusion are. After we do, we will develop
    a small example to illustrate inheritance, composition, polymorphism, and encapsulation
    in R's S3, S4, and R6 object models. The same example will be used for all three
    models so that the reader can pinpoint precise differences. Specifically, we will
    model a `Square` inheriting from a `Rectangle`, which is in turn composed with
    a `Color`.
  prefs: []
  type: TYPE_NORMAL
- en: The first source of confusion – various object models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way you work with object-oriented programming in R is different from what
    you may see in other languages, such as Python, Java, C++, and many others. For
    the most part, these languages have a single object model that all people use.
    In the case of R, note that we have been writing object models, in plural. That's
    because R is a very special language and it has various ways of implementing object-oriented
    systems. Specifically, R has the following object models as of this book's writing—S3,
    S4, Reference Classes, R6, and Base Types. In the upcoming sections, we will dig
    deeper into the S3, S4, and R6 models. Now, we will briefly touch on Reference
    Classes and Base Types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference Classes** (**RC**) is the object-model in R that does not require
    external libraries and is most similar to the well-known object model found in
    Python, Java, or C++. It implements message-passing as those languages do, meaning
    that methods belong to classes, not to functions, and objects are mutable, meaning
    that an instance''s data may change in place instead of producing copies with
    the modified data. We will not dig deeper into this object model, since R6 seems
    to be a cleaner implementation of such a model. However, R6 does require an external
    package, as we will see later, which is not a problem, and it is therefore preferred.'
  prefs: []
  type: TYPE_NORMAL
- en: Base types are not exactly an object model, per se. They are C implementations
    that work in R's background and are used to develop the other object models on
    top of them. Only R's core development team may add new classes to this model,
    and they very rarely do so (many years can pass before they do). Their usage is
    very advanced, and we will not dig deeper into them, either.
  prefs: []
  type: TYPE_NORMAL
- en: The decision of what object model to use is an important one, and we will touch
    more on this after we have shown how to work with them. In general, it will come
    down to a trade-off between flexibility, formality, and code cleanness.
  prefs: []
  type: TYPE_NORMAL
- en: The second source of confusion – generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another big difference with popular object-oriented languages like the ones
    mentioned before is that R implements parametric polymorphism, also known as generic
    functions, which implies that methods belong to functions, not classes. **Generic
    functions** allow the same name to be used for many different functions, with
    many different sets of arguments, from many different classes. This means that
    the syntax to call a class's method is different from the normally chained syntax
    you find in other languages (normally implemented with a "`.`" (dot) between a
    class and the method we want to call), which is called **message-passing**.
  prefs: []
  type: TYPE_NORMAL
- en: R's method calls look just like function calls, and R must know which names
    require simple function calls and which names require method calls. If you read
    the previous sections, you should understand why this is important. R must have
    a mechanism to distinguish what it's supposed to do. That mechanism is called
    **generic functions**. By using generic functions, we register certain names to
    be treated as methods in R, and they act as dispatchers. When we call registered
    generic functions, R will look into a chain of attributes in the object that is
    being passed in the call, and will look for functions that match the method call
    for that object's type; if it finds one, it will call it.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noted that the `plot()` and `summary()` functions may return different
    results, depending on the objects that are being passed to them (for example,
    a data frame or a linear model instance). That's because those are generic functions
    that implement polymorphism. This way of working provides simple interfaces for
    users, which can make their tasks much simpler. For instance, if you are exploring
    a new package and you get some kind of result at some point derived from the package,
    try calling `plot(result)`, and you may be surprised to get some kind of plot
    that makes sense. This is not common in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: When doing object-oriented programming with R's S3 and S4 models, keep in mind
    that you should not call methods directly, but should declare corresponding generic
    functions and call those instead. This may be a bit confusing at first, but it's
    just one of R's unique characteristics that you get used to with time.
  prefs: []
  type: TYPE_NORMAL
- en: The S3 object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, the R language is derived from the S language. S's object
    model evolved over time, and its third version introduced **class attributes**,
    which allowed for the S3 object model we find in R today. It is still the object
    model in R, and most of R's own built-in classes are of the S3 type. It's a valid
    and very flexible object model, but it's very different from what people who come
    from other object-oriented languages are used to.
  prefs: []
  type: TYPE_NORMAL
- en: S3 is the least formal object model, so it's lacking in some key respects. For
    example, S3 does not offer formal class definitions, which implies that there's
    no formal concept of inheritance or encapsulation, and polymorphism is achieved
    through generics. It's clear that its functionality is limited in some key respects,
    but the programmer has quite a bit of flexibility. However, as Hadley Wickham
    put it in *Advanced R, by Chapman and Hall, 2014:*
  prefs: []
  type: TYPE_NORMAL
- en: '"S3 has a certain elegance in its minimalism: you can''t take away any part
    of it and still have a useful object-oriented system."'
  prefs: []
  type: TYPE_NORMAL
- en: Classes, constructors, and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of an object is really just to bundle data and corresponding methods
    together. Lists in R are well-suited to implement this, since they can contain
    different data types, even functions, which are first class objects that can be
    assigned or returned like any other. In fact, we can literally create objects
    of a new class in R by taking a list and simply setting the class attribute of
    the list to a new value, which is how we create classes in S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of providing definitions for S3 classes, we provide constructors. These
    constructors have the responsibility of creating objects (a string which has the
    parameter passed in the case of `S3Color` and a list in the case of `S3Rectangle`)
    and assigning a string to their class attributes. These objects are then returned,
    and they represent the classes we will be using. In the case of the rectangle,
    our constructor receives the length, orthogonal sides, and the name of its color.
    The color constructor only receives the name of the color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, instead of assigning the `color` string which is passed as a
    parameter to the `rectangle_constructor()` function directly in the `color` element
    of the `rectangle` list, we use the `color_constructor()` function to provide
    a `Color` class, not only a string. You should do this if you will add behavior
    to the color abstraction, as we will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create an `S3_rectangle` by calling the `rectangle_constructor()`,
    and we can print its class, which is shown to be `S3Rectangle`, just as we expected.
    Also, if you print the `S3_rectangle` structure, you will see that it contains
    the two sides for the rectangle definition, the color class, and the attribute
    class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you will see that we have added a prefix to an object with the name
    of the object model we're using (`S3` in this case). For example, `S3Color` and
    `S3Rectangle`. When you see that, it means that the particular name clashes with
    the corresponding object in another object model, and we need to differentiate
    them. If you don't do this, you may encounter quite confusing and difficult to
    diagnose bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Public methods and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To define a method for a class, we need to use the `UseMethod()` function to
    define a hierarchy of functions. It will tell R to look for a function whose prefix
    matches the current function and for a suffix in order from the vector of class
    names of the object being passed. The names of the methods have two parts, separated
    by a "`.`", where the prefix is the function name and the suffix is the name of
    a class. As you can see, S3 generic functions work by naming conventions, not
    by explicitly registering methods for different classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating an `S3area` method for the `S3Rectangle` class, and we
    do so by creating a function named `S3area.S3Rectangle`. The `UseMethod()` function
    will make sure that the `S3area.S3Rectangle` function receives an object of class
    `S4Rectangle`, so inside of such a function, we can make use of the class''s internals.
    In this case, we will take the lengths `a` and `b` and multiply them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can access such objects within the `rectangle` object by using
    the `$` operator. This is not restricted to being done within a method, so really,
    any object can change an S3 object's internals, but just because you can doesn't
    mean that you should.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will call the `S3area` method as if it were a normal function call,
    to which we pass the rectangle object we created before, and we should see the
    area being printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened? An error? Well, how can R tell that the `S3area` function call
    should actually trigger the `S3area.S3Rectangle` method call? For that to happen,
    we need to register the name with R, and we do so by calling the defining function,
    which actually uses the `S3area` name by itself. This `S3area` function receives
    an object of any type, not necessarily a `S3Rectangle`, and uses the `UseMethod()` function
    to tell it that it should look for the `"S3area"` method call for that object.
    In this case, we know that it will only be found for the `S3Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the `S3area` method as we did before, but we will get the
    actual area in this case. This is how you normally create methods with S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the `S3color` method to return the color object for the
    rectangle. Since the color object is just a character type, there''s nothing more
    we need to do to somehow parse that object if we just want the characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will print the rectangle. As you can see, the `print()` call simply
    shows us the internals of the object and objects contained within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We may want to overload this function to provide a different output. To do
    so, we create `print.S3Rectangle()` and simply print a string that will tell us
    the color of the rectangle, the fact that it''s a rectangle, the length for each
    of its sides, and then its area. Note that both the color and the area are retrieved
    using the methods we defined before, `S3Color()` and `S3area()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what should happen if we simply call the `print()` function, as we did
    before with the `S3area()` function? We should get an error, shouldn''t we? Let''s
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Well, as you can see, we don't. In this case, we actually get the output we
    hoped we would. The reason is that the `print()` function in R is an S3 function
    which already registered with the `UseMethod()` function. That means that our
    definition `print.S3Rectangle` does not need to be registered again, and we can
    simply use it. That's pretty neat, isn't it? That's one of the big advantages
    of using parametric polymorphism. We can register functions as method calls that
    we may or may not end up using at some point in the future in unexpected ways,
    but they still provide a homogeneous interface for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will see how S3 handles mutability and encapsulation. To do so, we
    will print the `a` value in the rectangle, modify it, and print it again. As you
    can see, we are able to modify it, and from that point on we get a different result,
    and we do so without any method calls. That''s a very risky thing to do, and you
    should definitely wrap this type of behavior in method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Even if you can, never modify an object's internals directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proper way of modifying an object would be through some type of setter
    function. The `set_color.S3Rectangle()` method will be used to modify the rectangle''s
    color, by receiving a `S3Rectangle` and a `new_color` string, and saving that
    new string inside of a `color` attribute in the rectangle. When you use a method
    like this, you''re being explicit about your intentions, which is a much better
    way of programming. Of course, we also need to register the method call with R,
    as shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice our error? Probably not, but it's great if you did! We did this
    on purpose to show you how easy it is to harm yourself when programming in R.
    Since R has no type checking, we inadvertently assigned a string where we should
    have assigned a `Color`. This means that the `color` attribute in our rectangle
    will no longer be recognized as a `Color` class after we call the `set_color()`
    method; it will be recognized as a string. If your code depends on this object
    being of the `Color ` type, it will probably fail in unexpected and confusing
    ways and will be hard to debug. Be careful when doing assignments. Instead, we
    should have put `rectangle$color <- color_constructor(new_color)` to keep consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can change the type of an object, you never should. As Hadley Wickham
    puts it, *R doesn''t protect you from yourself: you can easily shoot yourself
    in the foot. As long as you don''t aim the gun at your foot and pull the trigger,
    you won''t have a problem*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we show how the `set_color()` method can be used. We will print the rectangle''s
    color, attempt to change it to black, and print it again. As you can see, the
    change was not persisted in our object. That''s because R passes objects by value
    and not by reference. This simply means that when we modify the rectangle, we
    are actually modifying a copy of the rectangle, not the rectangle we passed ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Did you notice that at the end of the `set_color.S3Rectangle()` function, we
    returned the `rectangle`? In other languages that may not be necessary, but in
    R, we do so to get back the modified object. To persist the changes in our object,
    we need to actually assign that resulting object into our own `S3_rectangle`,
    and when we do, then we can see that the color change was persisted.
  prefs: []
  type: TYPE_NORMAL
- en: This property is what gives S3 its immutability property. This is very useful
    when working with functional programming, but can be a bit of a hassle to work
    with when doing object-oriented programming. Some confusing bugs may come from
    this property to get you used to working this way.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: S3 classes lack a lot of the structure normally found in other languages. Inheritance
    is implemented informally, and encapsulation is not enforced by the language,
    as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement inheritance, we will create a `square_constructor()` function
    that will receive the length of the sides in `a` and the name of the color. We
    will then use the `rectangle_construtor()` and send `a` for both lengths (making
    it a square), and will also send the color. Then, we will add the `S3Square` class,
    and finally, return the created object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a square and print its classes. As you can see, it has
    the `S3Square` and `S3Rectangle` classes assigned, in order, and when we use the
    `print()` method on it, we actually get the print functionality from the `S3Rectangle`
    class, which is expected since we''re signaling the inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we want to provide a specific print functionality for the square, we must
    overwrite the `print()` method with our own definition for `S3Square` classes,
    as we now do. The function is exactly the same as before, but we use the word
    `"square"` instead of `"rectangle"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we print, we can see that the correct method is being used, because
    we see the word `"square"` in the output. Note that we did not have to re-register
    the `print()` method with the `UseMethod()` function, since we had already done
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, remember that if the class attribute is a vector with more than one
    element, then the first element is interpreted as the class of the object, and
    the following elements are interpreted as classes that the object inherits from.
    That makes inheritance a property of objects, not classes, and order is important.
  prefs: []
  type: TYPE_NORMAL
- en: If we had instead written `class(square) <- c(class(square), "S3Square")` in
    the `square_constructor()` function, then even after creating the `print.S3Square()`
    function, we would still see the `print()` method calling the `print.S3Rectangle()`
    function. Be careful with this.
  prefs: []
  type: TYPE_NORMAL
- en: The S4 object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some programmers feel that S3 does not provide the safety normally associated
    with object-oriented programming. In S3, it is very easy to create a class, but
    it can also lead to very confusing and hard to debug code when not used with great
    care. For example, you could easily misspell a name, and R would not complain.
    You could easily change the class to an object, and R would not complain, either.
  prefs: []
  type: TYPE_NORMAL
- en: S4 classes were developed after S3, with the goal of adding safety. S4 provides
    protection, but it also introduces a lot of verbosity to provide that safety.
    The S4 object model implements most features of modern object-oriented programming
    languages—formal class definitions, inheritance, polymorphism (parametric), and
    encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, constructors, and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An S4 class is created using the `setClass()` function. At a minimum, the name
    of the `Class` and its attributes, formally known as **slots** in S4, must be
    specified. The slots are specified in with the `representation()` function, and
    a neat feature is that you specify the type expected for such attributes. This
    helps a bit with type-checking.
  prefs: []
  type: TYPE_NORMAL
- en: There are other features built-in that we are not going to look at here. For
    example, you could provide a function that verifies the object is consistent (has
    not been manipulated in some unexpected way). You can also specify default values,
    in a parameter called the `prototype`. If you want these features in S3, you can
    also implement them yourself, but they don't come as built-in features. S4 is
    regarded as a powerful object model, and you should definitely study it more in
    depth by browsing its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: All S4 related code is stored in the methods package. This package is always
    available when you're running R interactively, but may not be available when running
    R in batch mode. For this reason, it's a good idea to include an explicit `library(methods)`
    call whenever you're using S4.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the conceptual difference from S3 classes is that here, we
    actually specify the type of object for each slot. Other changes are more syntactic
    than conceptual. Note that you may use the name of another S4 class for one of
    the slots, as we do in the case of `color` for the `S4Rectangle`. This is how
    you can achieve composition with S4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is built automatically for you with a call to the `new()` function.
    As you can see, you simply need to pass through the name of the class you''re
    instantiating and the values that should be assigned to the slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did before, we retrieve the class for the object and print it. When we
    print it, we can see a structure that contains some `@` symbols. Those are the
    operators used to access the slots (instead of the `$` operator for S3). You can
    also see the nested slot for the `color` attribute of the `Color` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Some slot names are forbidden due to the fact that they are reserved keywords
    in R. Forbidden names include `class`, `comment`, `dim`, `dimnames`, `names`,
    `row.names`, and `tsp`.
  prefs: []
  type: TYPE_NORMAL
- en: Public methods and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since S4 also uses parametric polymorphism (methods belong to functions, not
    classes) and we have already explained it a couple of times before, we are going
    to just point out the differences with S3 at this point. First, instead of using
    the `UseMethod()` function to register methods with R, we use the `setGeneric()` function,
    with the name of the method, and a function that calls the `standardGeneric()` function
    inside. This will provide the dispatch mechanism for S4 objects.
  prefs: []
  type: TYPE_NORMAL
- en: To actually create a method, instead of using a naming convention as we do in
    S3, we actually pass the name of the class and the method to the `setMethod()` function,
    as well as the function that should be used as a method. Second, the order there
    matters. If you call the `setMethod()` function before you call the `setGeneric()`
    method, your dispatch mechanism won't work. We did that in S3, but here, we need
    to reverse the order. Finally, note that we access object attributes (slots) with
    the `@` symbol, as we mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness in the example so that the reader may compare the code for
    all three examples side by side, we now show how to implement the same code we
    showed for the S3 case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `print()` on `S4_rectangle`, you will see that it''s recognized
    to be of a certain type, and it will show its slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to change this output, we override this method with our own, as
    we did in the case of S3\. However, if we do, we will have the `print()` function
    defined to work with S4 objects, and it will stop working for objects from other
    object models. We encourage you to try it yourself by changing the code below
    to use the `print` method call instead of the `S4print` name. As you can see,
    we are using the same overriding mechanism as before, so we will skip its explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we may use the `S4print()` method to print the desired output, as you
    can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take a look at the encapsulation and mutability concepts in S4\.
    First, note that we are using the `print()` and not the `S4print()` method, because
    we are printing specific slots from `S4_rectangle`. As you can see, if we're not
    careful, we can still assign values directly to the internals of the object. Again,
    you should not do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that if we use the method `S4color()` that we created before to encapsulate
    the access to the `color` attribute, we get an error telling us that the `S4color<-`
    function could not be found. That hints to us that we can create such a function,
    and we can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To create a function that will encapsulate access to an object's attribute,
    we can use the `setReplaceMethod()` function, just as we did with the `setMethod()`
    function before. Note that the name of the method we are passing to the `setGeneric()`
    function is the one that was hinted to us in R's error, which is the name of the
    slot followed by the normal assignment operator in R, `<-`. Also note that there's
    no space between the name of the variable and symbols for the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, note that we made sure to create an object of type `S4Color` when
    assigning a new value to the `color` slot. If you try to simply assign a string
    as we did with the S3 class, you will get an error letting you know you''re trying
    to do something you shouldn''t be doing. This is a big advantage when working
    with S4, as it can prevent you from committing some unexpected mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we create such a method, we can use it to assign to the color object directly,
    in an encapsulated manner, which is much better than manipulating the slots directly.
    As you can see, the color change is persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a subclass is easy; we simply need to call the `setClass()` function
    as we did before, and send the `contains` parameter with the name of the class
    it will inherit from. S4 supports multiple inheritance, but it's not something
    we're going to look at. The interested reader is encouraged to look into the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting feature of S4 classes is that if a class extends one of R''s
    basic types, there will be a slot called `.Data` containing the data from the
    basic object type. Code that works on the basic object type will work directly
    on the `.Data` part of the object, so it makes our programming a bit easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when we instantiate the `S4Square` class, we will need to pass both
    attributes for the length and make sure they are the same. As we can see, the
    class of the object is identified correctly, and the polymorphic `S4print()` method
    we defined previously works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, for completeness, we override the `S4print()` method with one that uses
    the `"square"` word instead, and we can see that it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The R6 object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: S3 and S4 are really just ways to implement polymorphism for static functions.
    The R6 package provides a type of class which is similar to R's Reference Classes,
    but it is more efficient and doesn't depend on S4 classes and the methods package
    as RCs do.
  prefs: []
  type: TYPE_NORMAL
- en: When RCs were introduced, some users, following the names of R's existing class
    systems S3 and S4, called the new class system R5\. Although RCs are not actually
    called R5 nowadays, the name of this package and its classes follows that pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being first released over three years ago, R6 isn't widely known. However,
    it is widely used. For example, it's used within Shiny (the focus of the last
    chapter in this book) and to manage database connections in the dplyr package.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, constructors, and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes in R6 are created with the `R6Class()` function, and we pass the name
    of the class and lists of public and private objects. These objects can be either
    attributes or methods. As you can see, building a class definition in R6 produces
    much cleaner code, which is put together in a single definition instead of the
    step-by-step process used in S3 and S4\. This approach is more like what you can
    find in other popular languages.
  prefs: []
  type: TYPE_NORMAL
- en: You may specify how the constructor should behave by using the `initialize`
    method. This specific method will be called when an instance of the class is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important differences between our names in the following definition
    and what we used for the S3 and S4 examples. In this case, we call the print method
    `own_print()` and the `color` property `own_color`. The reason for the former
    is that R would be confused between the `color()` method and the `color` attribute.
    To avoid errors, we can change the name for one of them, and to keep our public
    interface the same, we decide to change the private attribute in this case. The
    reason for `own_print()` will be explained ahead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To create an instance of a class, we call the `new()` method in the class object.
    We can pass some parameters, and if we do, they will be used by the `initialize`
    function defined for the class.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, if we use `print()` on the `R6_rectangle` object, we see a nice
    output letting us know what methods and attributes are public and private, as
    well as some extra information about them, like the fact that the default `clone()`
    method (used for making copies of an R6 object) is set to shallow copying instead
    of deep copying. We won't go into the details of what these concepts are, but
    the interested reader is encouraged to look into pass-by-reference versus pass-by-value
    mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had defined a `print()` method within our class, then the `print(R6_rectangle)`
    would have used that function by default. Note that this would be syntactically
    different from calling the method directly by executing a command like `R6_rectangle$print()`,
    but R is intelligent enough to know that if you define a `print()` method in your
    class, it''s probably because you want to use it when using the `print()` function
    on the object. If that''s not the case, then you should change the name of your
    custom print function, as we do in the case of the `own_print()` method name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, in the case of R6 classes, we have two classes
    instead of one. We have the class we defined ourselves, and we also have the general
    `R6` class added for us for the object.
  prefs: []
  type: TYPE_NORMAL
- en: Public methods and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already defined the methods we want in the previous piece of code,
    so for completeness, we will only show how to call these methods now. As you can
    see, you simply use the `$` operator to access a public attribute or a public
    method, and if it''s a method, you add the parentheses at the end (surrounding
    any parameters you want to send as you normally would):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Encapsulation and mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we placed the `a`, `b`, and `own_color` in the `private` list in the class
    definition, they remain private, and this is how encapsulation is enforced in
    R6\. As you can see, we were not allowed to assign directly to the `a` attribute
    as we expected, since it was placed in the `private` list. This makes sure that
    we can't have attributes or methods marked as private directly from outside the
    object, and prevents us from making bad decisions when coding. This is a great
    advantage of the R6 model.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation in R6 is achieved through environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutability is achieved by using setters (methods used to change a class''s
    attribute). Notice that in this case, we don''t need to reassign the resulting
    object as we do with S3\. State is actually saved within the object''s environment,
    and it can be changed; thus, R6 has mutability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is also more familiar when working with the R6 object model. In
    this case, you can simply add the `inherit` parameter to the `R6Class()` function
    call, and you may call the `initialize` method for the superclass by using `super$initialize()`.
    In this case, we use that technique to provide a more intuitive constructor interface
    to the user: a single value for length in the case of a square, instead of having
    to repeat the same value twice, which can be prone to counter-intuitive behavior
    if not checked. We can also override the `print()` method, just as we would normally
    add another method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in this case we get a list of classes that include the current
    class `R6Square`, as well as the classes this object inherits from, `R6Rectangle`
    and `R6`. Since we used an override for the `print()` method, we can use the common
    `print(object)` syntax instead of the ad-hoc `object$print()` syntax provided
    by R6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Active bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Active bindings look like fields, but each time they are accessed, they call
    a function. They are always publicly visible and are similar to Python''s properties.
    If we wanted to implement the `color()` method as an active binding, we could
    use the following code. As you can see, you can either get or set the `color`
    attribute, without using an explicit method call (note the missing parentheses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when an active binding is used as a *getter* (to retrieve a
    value), it calls the method without a value being passed. When it's accessed as
    a *setter* (to change an attribute), it calls the method passing the value to
    be assigned. It's not possible to use an active binding as a setter if the function
    takes no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's useful to run a function when the object is garbage collected.
    If you're not familiar with garbage collection, you can think of it as a way to
    liberate unused memory when an object is no longer referenced by other objects
    in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful case for this feature is when you want to make sure a file or database
    connection gets closed before an object is garbage collected. To do this, you
    can define a `finalize()` method, which will be called with no arguments when
    the object is garbage collected. To test this functionality, you can simply add
    a *finalizer* as follows to some of your objects and see when you get the `"Finalizer
    called"` message in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finalizers will also be called when R exits.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture behind our cryptocurrencies system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the fundamentals for object-oriented programming with R have been illustrated,
    we will take those principles and apply them to the example we will work with
    for the rest of the book. We will build a system to track cryptocurrencies with
    object-oriented programming. If you're not familliar with cryptocurrencies, read
    the beginning of this chapter for a brief introduction.
  prefs: []
  type: TYPE_NORMAL
- en: The design and implemention you will see in this example evolved over various
    iterations and weeks. It's actually a part of the basic system I initially used
    in CVEST ([https://www.cvest.tech/](https://www.cvest.tech/)) to offer a single
    point of truth for users managing a diverse set of cryptocurrencies (although
    it was not implemented in R), so don't feel that you should be able to come up
    with a design like this right away (although many people certainly are able to,
    but most of the time, object-oriented systems are evolve in unpredicted ways).
    As Grady Booch puts it: *"A complex system that works is invariably found to have
    evolved from a simple system that worked. A complex system designed from scratch
    never works and can not be patched up to make it work. You have to start over,
    beginning with a working simple system."*
  prefs: []
  type: TYPE_NORMAL
- en: Let's get to it. As you may know, cryptocurrencies can be stored in exchange
    accounts and in wallets. Since keeping cryptocurrencies stored in exchange accounts
    is a very bad idea (it's risky, and a user could end up losing their assets, as
    has repeatedly happened), we will only focus on the cases where cryptocurrencies
    are stored in wallets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, what we are trying to do is to get a feed of real data about how
    many cryptocurrencies we posses and how much they are worth, both at a given point
    in time. To implement the system, the first thing we need to do is identify the
    primary abstractions, which are, in our case: users, assets, wallets, and exchanges.
    For simplicity, we will also include markets and databases in this list.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the term asset instead of cryptocurrency due to the fact that some
    of them are not technically currencies, but you may interchange those terms freely
    without confusion.
  prefs: []
  type: TYPE_NORMAL
- en: For our case, suppose we have decided from the start that even though we will
    read data from a single source, we may want to write data to multiple databases
    as we get it. Some of these databases may be local, and others may be remote.
    However, we don't want every piece of the system to know that there are multiple
    databases in use, since they really don't need this information to operate. Therefore,
    we will introduce another abstraction, namely storage, which will contain this
    information inside, and which will look like a single database to other objects
    that need to read or write data, and it will handle the details for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We include this abstraction in our list of primary abstractions, and that list
    is complete at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Cryptocurrency tracking architecture
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to define how this main abstraction will interact among themselves.
    We know that a user may have several wallets in her posession, and that in turn,
    these wallets have assets inside. Note that we separated the abstractions of assets
    and wallets because some wallets may contain more than on asset inside (for example,
    Ethereum wallets may contain various types of tokens). Since we anticipate this
    case, we will make sure we can deal with it accordingly by separating these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Users also want to be able to store their own information as well as their assets
    information. To do so, they will receive a storage object and they will call methods
    on this object, for which the public interface will be well defined.
  prefs: []
  type: TYPE_NORMAL
- en: The storage abstraction will in turn contain a single database for reading,
    but may contain several databases for writing, as we mentioned before. It will
    store these database objects inside and send them messages as necessary to accomplish
    the read and write operations on behalf of objects using it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, just as wallets contain assets, exchanges contain markets. The difference
    is that assets identify a single type of cryptocurrency, while markets use exactly
    two cryptocurrencies to be defined. That is why we may have a market to exchange
    USD for BTC (written as USD/BTC), meaning that people may use US Dollars to buy/sell
    Bitcoin. Other markets could be BTC/LTC or LTC/USD (where LTC stands for **Litecoin**).
  prefs: []
  type: TYPE_NORMAL
- en: The number we will be retrieving from wallets is a single number representing
    how much of a specific asset we posses. The number we will be retrieving from
    markets is a ratio representing the price, or how much of one asset is being asked
    for to receive one unit of the other. A BTC/USD ratio of 8,000 means that to receive
    one Bitcoin you're expected to give 8,000 US Dollars (which is the price as this
    paragraph is being written). Similarly, an LTC/BTC of 0.0086 means that you're
    expected to give 0.0086 Bitcoin to receive one Litecoin.
  prefs: []
  type: TYPE_NORMAL
- en: Now that these relations are more or less defined, we will need to bring more
    abstractions into play to write code that will make our system a reality. For
    example, we know that our wallet abstraction will use a similar mechanism to retrieve
    data from different blockchains. This can be encapsulated in a *wallet requester*.
    Furthermore, this wallet requester will be implemented in different ways and must
    be decided at runtime according to the specific wallet we're dealing with. Instead
    of creating a different wallet for each type of asset, and programming the mechanism
    to retrieve data from the blockchain inside each of them, we abstract that and
    create a wallet requester factory that will give our wallet abstraction the specific
    type of wallet requester it needs for the given asset at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, our database abstraction may be implemented for various kinds of
    databases, so we separate the interface from the implementation and introduce
    a factory that will choose which specific implementation we will end up using.
    In our case, we will be saving the data to CSV files, but we could just as easily
    be using a MySQL database with what we learned in [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: In much the same way, our code will retrieve data from **CoinMarketCap** ([www.coinmarketcap.com](http://www.coinmarketcap.com))
    for now, but that may change later. CoinMarketCap is not an exchange, per se;
    rather, it is an aggregator of price data. However, since we may want to work
    with price data from different exchanges in the future (like **Bittrex** or **Bitfinex),**
    we will provide for such abstraction, and since there's no foreseen need to treat
    CoinMarketCap differently from an exchange, we will just include it in that abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: As a sidenote, the architecture image is not meant to be a UML diagram. **UML**
    stands for **Unified Modeling Language**, a tool commonly used to communicate
    ideas behind object-oriented systems. It's a tool you should definitely learn
    to use if you're planning on doing serious object-oriented programming. Also note
    that we will not implement the objects shown in grey color, namely Bitfinex requester,
    Bittrex requester, MySQL, and Ether requester. Those are left as an exercise for
    the user. Our system will be fully functional without them.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it seems that we have a very good idea of the abstractions we
    want to build and the interactions that will occur among these abstractions, so
    it's time to start programming. While we go through the code for the system, we
    will not stop to explain the concepts we have covered before; we will only explain
    functionality that may not be evident.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you should know that each abstraction we implement will go into its
    own file. This is standard practice and helps you quickly find where you need
    to implement or modify some code. There''s a clear and intuitive hierarchy among
    these files. The actual code is organized in the following structure (files end
    with the `.R` extensions and directories end with the `/` symbol):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Starting simple with timestamps using S3 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by programming a class that has no external dependencies, the `TimeStamp`.
    We will use this class to indicate dates and times together in a single string
    in the format `YYYY-MM-DD-HH-mm`, where `MM` means month and `mm` means minutes.
    As you can see, with one of these strings you have the information time and date,
    and it will be stored with the data we retrieve from time-series for analysis
    in [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730), *Implementing
    an Efficient Simple Moving Average*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `TimeStamp` class will be implemented using S3\. As you can see, we include
    the `lubridate` package to do some heavy lifting for us when transforming dates,
    and provide a constructor that checks whether or not the string being passed is
    a valid timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation is done by the `valid.TimeStamp()` function, which makes sure
    that only dashes (`-`) and digits are in the string, that the number of numbers
    separated by those dashes is five (year, month, day, hour, and minutes), and that
    the string can be parsed by the `strptime()` function, which is used to create
    date objects from string objects (if it''s not an `NA`, then it could be parsed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We also provide a `now.TimeStamp()` function whose responsibility is to create
    a timestamp for the current time and date. It does so by invoking the `Sys.time()`
    function and parsing the resulting object with the format we have specified previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we introduce a way to transform native time objects into our own `TimeStamp`
    objects. We simply use the `format()` function as we did before. We also introduce
    a mechanism to transform our own `TimeStamp` objects into native time objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `subtract.TimeStamp()` function will be important when we retrieve data,
    as we may want all assets that contain a date starting from a previous point in
    time taken from a given `TimeStamp`. The function receives two parameters: the
    current `TimeStamp` and the interval of how much time back we want the resulting
    `TimeStamp` to indicate. Depending on the chosen interval, which can be one hour,
    one day, one week, one month, or one year, indicated by `1h`, `1d`, `1w`, `1m`,
    and `1y`, respectively, we will call different functions from the `lubridate`
    package (`hours()`, `days()`, `weeks()`, `months()`, `years()`), which receive
    how many units of the specified name should be used in the operation. These are
    easy ways to add or subtract time in R.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if an unknown interval is passed, we will raise an error. Some people
    think that adding these `else` cases with some kind of error should be avoided,
    since it indicates insecure programming in the sense that you should know what
    options should be passed to the function, and you should never really end up in
    the else branch, and they would rather make sure that their code works by using
    unit-tests instead of checking internally with conditionals. However, we are using
    it to exemplify its usage and because we''re not using unit-tests to prove correctness
    in our code. I''m also of the opinion that you can never be too careful with these
    types of situations, and I''ve found myself in situations where adding that simple
    else branch helped me diagnose a bug much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a convenient `one_year_ago.TimeStamp()` function, which will
    simply produce a current `TimeStamp` and subtract one year from it. This is one
    of those functions that simply evolves as the system is being developed, since
    I noticed I needed that functionality over and over again, so I could just make
    my life a little easier this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, the class is ready. Feel free to play with it to make sure it works as
    expected. With what you've seen so far in this chapter, you should be able to
    create instances and use the different methods we created. You should also try
    to break it to find its weak spots and possibly improve the implementation's robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cryptocurrency assets using S4 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will implement our next abstraction with the least number of dependencies,
    `Asset`. We will implement it using S4, and it only depends on `TimeStamp`. We
    define its class using the standard methods shown before, and its attributes include
    `email` to identify what user an asset belongs to, a `timestamp` to identify the
    asset at a point in time, a `name` to know what asset we''re dealing with, a `symbol`
    to identify the asset type within our system, a `total` to record how much of
    that asset a user has, and an `address` to identify what wallet the asset belongs
    to (a user may have several wallets for the same type of asset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that instead of using the S3 class for `TimeStamp` in the `timestamp` attribute,
    we decide to simply declare it as a `character` and manage the translation among
    types ourselves. This allows us to remain in control of this transformation process
    and avoid unexpected R behavior when mixing object models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we provide setter functions to change the `email` and `timestamp` attributes,
    since we will need them when we are retrieving asset data and saving it to disk.
    This is one of those design decisions that evolved as the system was developed,
    and we did not foresee that we would need these methods; they were added at a
    later point in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we implement a `dataS4` method that will allow us to retrieve the data
    that needs saving from our S4 objects. Note that we used the same technique as
    was shown before to differentiate `dataS4` methods from `dataS3` methods, and
    avoid any pitfalls with R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `AnalysisAsset` will be left for the next chapter,
    where we introduce the types of analysis we're looking to perform with this data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our storage layer with R6 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, our code's complexity was not much more than that shown in
    the examples for the colors, rectangles, and squares. At this point, the code
    will be a bit more complex, since we are dealing with more complex abstractions
    and interactions among them, but we are ready to tackle the challenge with what
    we know so far.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating available behavior with a database interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by defining the interface for databases in the `Database` class.
    This class is never intended to be instantiated itself. Its purpose is to simply
    provide an interface definition that must be respected by specific database implementations,
    like the `CSVFiles` implementation we will develop, and by the `Storage` implementation,
    to communicate with any database. The advantage of defining an interface such
    as this is that it provides a common language for these objects to talk to each
    other, and provides a reference for the programmer of what should be done and
    how methods should be named so that they work out of the box with the rest of
    the system. In Python, they would be called Abstract Base Classes. R has no formal
    usage for these abstract classes, but we can nevertheless implement them this
    way ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our R6 `Database` interface specifies what methods should be
    publicly implemented and the fact that the table names used for the database should
    be kept private. We're adding this `table_names` list attribute instead of hardcoding
    the table names directly in our classes because we want to be able to easily change
    them in a settings file (more on this later) and we want to easily change them
    for the different environments we will be using this code under (mainly production
    and development environments).
  prefs: []
  type: TYPE_NORMAL
- en: The public methods are the getter and setter for the `table_names`, and the
    groups of methods used for reading and writing data, which contain a prefix stating
    what they are used for. It should be evident what they expect and what they return.
    Specifically, the `read_exchanges()` method does not receive any parameters and
    should return a list of `Exchange` objects (which will be defined later). The
    `read_users()` returns a list of `User` objects (which will also be defined later),
    and needs an instance of `Storage` that will be assigned to each user created
    so that they can read and write data. The `read_wallets()` method receives an
    email string and returns a list of `Wallet` objects (also to be defined later).
    The `read_all_wallets()` method is meant to be used only by `admins` of the system,
    and will return all the wallets in the system in a list, not only the wallets
    that belong to a specific user.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the write side, the `write_user()` method receives a `User` object and writes
    it to disk, and as you can see by the `{}` symbols, it''s not expected to return
    anything. Similarly, the other write methods receive an instance of a class and
    save it to disk. We need one write method for each type of class because they
    will need different treatments when being saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a database-like storage system with CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our `Database` interface defined, we will implement a database-like
    system that uses CSV files to store the information instead of an actual database.
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure we bring the `CSVFiles` class dependencies by using the
    `source()` function to bring files that have the definitions we need. Specifically,
    we bring the `Exchange` and `User` classes (which will be defined later), as well
    as the `Database` interface. We also define the `DIR` constant with the directory
    that will contain the CSV files with our system's data.
  prefs: []
  type: TYPE_NORMAL
- en: The actual `CSVFiles` class is defined using the standard R6 methods shown before.
    Note that it inherits from the `Database` class and provides overrides for every
    method in the `Database` interface, as it should. Also note that inside the constructor,
    that is, the `initialize` function, we are calling the `initialize_csv_files()`
    function and sending it the `table_names` list we receive during initialization.
    More on this ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we wanted the reader to get a look at the full class definition in a
    single piece of code instead of piece-by-piece, we include all of it here, and
    explain it in the following paragraphs. It''s a bit long since it contains the
    logic for all the methods in the `Database` interface, but at a high level, it''s
    nothing more than implementation for said interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will briefly explain the mechanics behind each method implementation.
    Let''s start with `read_exchanges()`. In theory, this method should look inside
    the stored data and get a list of the exchanges registered in the system, create
    an instance for each of them, and send that back. In practice, however, it''s
    not necessary, as just hardcoding the CoinMarketCap exchange is sufficient for
    our purposes. As you can see, that''s all the method does: return a list with
    a single `Exchange` inside, which is the one for CoinMarketCap.'
  prefs: []
  type: TYPE_NORMAL
- en: The `read_users()` method reads the data from the `"user"` file with the private
    method `read_csv()` defined below, and returns a list built with the `lapply()`
    function that takes every email in the data and sends it through the `user_constructor()`,
    along with a `storage` object received as a parameter to create `User` instances
    that are then sent back as a result of the method call. If you don't remember
    how the `lapply()` function works, take a look at [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R*.
  prefs: []
  type: TYPE_NORMAL
- en: The `read_wallets()` method is a bit more complex. It receives an `email` as
    a parameter, reads the `"wallets"` file, and creates a list of `Wallet` instances.
    Since we're doing a check to see whether a specific observation in the data contains
    an `email` equal the one requested, we can simply use the `lapply()` function
    (we could, if we create a separate function that contains this, check, but we
    decide not to go that route). Also note that the function will only try to iterate
    over the row in the dataframe if the dataframe contains at least one row. This
    check was introduced after we found that when not having it when we had empty
    files, we were getting an error, since the for loop was actually being executed
    even if there were no rows. If the `email` is found to be the same as the one
    requested, then we append a new `Wallet` instance to the `wallets` list and return
    it. If there are no wallets to be created, the `wallets` object is coerced into
    an empty list. The `read_all_wallets()` method works in the same way but omits
    the `email` check.
  prefs: []
  type: TYPE_NORMAL
- en: The `write_user()` method receives a `User` instance, reads the `data` for the
    `"users"` file, creates a dataframe with the data extracted with the `dataS3`
    method call from the `User` object, prints it to the console for informational
    purposes, and, if it's not found to already exist in the current data, it's added
    to it. Finally, the data is saved back into the `"users"` file. The actual check
    is performed by the private method `user_does_not_exist()`, which simply checks
    that the `User` email is not contained in the `email` column in the data, as you
    can see in its definition mentioned ahead.
  prefs: []
  type: TYPE_NORMAL
- en: The `write_wallets()` method receives a list of `Wallet` instances, reads the
    `"wallets"` file, and for each `wallet` not found to already exist in the data,
    adds it. It's conceptually similar to the `write_user()` method, and the check
    is performed by the private `wallet_does_not_exist()` method, which receives a
    `Wallet` instance and uses its contained `email` and `symbol` to get the `addresses`
    which are already associated to such combinations (recall that a single user may
    have multiple wallets for the same type of asset, and they would only be differentiated
    by their wallet addresses). If the `address` in the `Wallet` instance is found
    to already exist in such a subset, then it's not added.
  prefs: []
  type: TYPE_NORMAL
- en: The `write_assets()` and `write_markets()` methods are similar and should be
    easily understood. The difference is that they do not contain any checks for now,
    and that they are saving S4 and R6 objects, respectively. You can tell that by
    the fact that they call the `dataS4()` method and the syntax to get the `Market`
    data, being `market$data()`.
  prefs: []
  type: TYPE_NORMAL
- en: The private methods used to read and write the CSV files should be easy to understand.
    Just keep in mind that the actual filenames are coming from the `file()` private
    method, which uses the `table_names` contained in the superclass (`Database`)
    by calling the `super$get_table_names()` getter and retrieving the corresponding
    filename associated for a given `table_name`. The `table_name` list will later
    be defined in the centralized settings file, but is simply a list that contains
    a string for each table name (in the case of `CSVFiles`, a file name) associated
    to each type of object that needs to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we proceed to discussing the `initialize_csv_files()` function. This function
    receives the `table_names` list and makes sure that the `DIR` directory exists
    with the `dir.create()` function. The `showWarnings = FALSE` parameter is to avoid
    warnings when the directory already exists in disk. Then, for each element in
    the `table_names` list, it will create the corresponding `filename` and see whether
    it exists on disk with the `file.exists()` function. If it does not, it will proceed
    to create an empty dataframe of the corresponding type and save it to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The different types of empty dataframes are chosen with the `empty_dataframe()`
    function, which receives a specific table name in the `table` parameter and returns
    the corresponding empty dataframe. Note that the checks assume that the words
    for the different objects that need to be saved are within the table names defined
    in the centralized settings file and that the names of two different abstractions
    do no appear together in a single table name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual empty dataframes are created by the `empty_assets()`, `empty_markets()`,
    `empty_users()`, and `empty_wallets()` functions. Each of these contains a specification
    for the data expected to be within such files. Specifically, each observation
    in the asset''s data is expected to have an email, timestamp, name, symbol, total,
    and address. Each observation in the markets data is expected to have a timestamp,
    name, symbol, rank, price in BTC, and price in USD. The rank is a cryptocurrencies
    ordering based on the amount of volume transacted in the last 24 hours. The users
    data is only expected to contain emails. Finally, the wallets data is expected
    to have an email, symbol, address, and note. The note is a note that the user
    may specify to recognize different wallets from each other, specifically if they
    are being used for the same type of cryptocurrency. Maybe one Bitcoin wallet is
    for long-term and one for short-term; then that information could be specified
    in the note field. Note that you can identify the relations among these data schemes
    with the concepts introduced in [Chapter 4](part0091.html#2MP360-f494c932c729429fb734ce52cafce730),
    *Simulating Sales Data and Working with Databases*. Let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Easily allowing new database integration with a factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know at this point that we will only use the `CSVFiles Database` implementation
    for this example, but we can easily imagine cases where new database implementations
    come into play. For example, the reader will create an implementation of the MySQL
    database, and will want it to substitute the `CSVFiles` implementation. Isn't
    that right? When you expect some change in the future where you will likely need
    to switch one interface implementation for another, factories is a great tool
    to facilitate that change for yourself in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `database_factory()` function receives a `db_setup` and `table_names` objects,
    both of which will come from our centralized settings file. It then takes the
    appropriate set of table names, depending on the environment for the database,
    and looks into the `db_setup` provided to find what kind of `Database` implementation
    it needs to instantiate. Since we only have one at this point, the only possibility
    will be a `CSVFiles` implementation, and if we pass any other string, then an
    error should be raised, as it is. The `Database` implementation actually instantiated
    should receive a `table_names` object and configure itself accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a factory is nothing more than an `if` statement which decides
    what implementation should be instantiated and returned to the calling object.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating multiple databases with a storage layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have developed our `Database` interface and our `CSVFiles` implementation
    of such an interface, we are ready to develop the next layer of abstraction, our
    `Storage` class. It will be implemented with R6.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `Storage` constructor implemented in the `initialize` function
    receives a `settings` object which will be the full centralized settings file
    we have been mentioning and will use the `storage/read`, `storage/write`, and
    `storage/table_names` parts to create various database instances through the use
    of the `database_factory()` function we explained before. In the case of the `read_db`
    attribute, it will be a single `Database` implementation that will be used to
    read data. In the case of the `write_dbs` attribute, as the name implies, we will
    have a list of `Database` implementations where each data that is asked to be
    saved by other objects will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this `Storage` abstraction, we can simply send it to objects looking for
    a database-like object to save and read data from, and it will take care of replicating
    data as necessary for us, as well as providing data to said objects. To accomplish
    this, you can ask that in the case of the read methods, it simply delegate the
    task to the `Database` implementation contained in its `read_db` attribute, and
    in the case of the write methods, it does the same thing for each `Database` implementation
    in its `write_dbs` attribute. It''s as simple as that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That's it for our storage abstractions. At this point, we have implemented a
    `Database` interface, a `CSVFiles` implementation of said interface, and a `Storage`
    layer that permits the use of multiple `Database` implementations simultaneously
    and decouples the read and write objects for us. We could choose to use one type
    of database for read operations and another one for write operations, and have
    some kind of external mechanism to sync them together outside of R. This could
    be handy for performance reasons, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving live data for markets and wallets with R6 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will explain how to create a simple requester, which is an object
    that requests external information (from an API over the internet in this case). We
    will also develop our exchange and wallet infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a very simple requester to isolate API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will focus on how we actually retrieve live data. This functionality
    will also be implemented using R6 classes, as the interactions can be complex.
    First of all, we create a simple `Requester` class that contains the logic to
    retrieve data from JSON APIs found elsewhere in the internet and that will be
    used to get our live cryptocurrency data for wallets and markets. We don't want
    logic that interacts with external APIs spread all over our classes, so we centralize
    it here to manage it as more specialized needs come into play later.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all this object does is offer the public `request()` method,
    and all it does is use the `formJSON()` function from the `jsonlite` package to
    call a `URL` that is being passed to it and send the data it got back to the user.
    Specifically, it sends it as a dataframe when the data received from the external
    API can be coerced into dataframe-form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Developing our exchanges infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our exchanges have multiple markets inside, and that''s the abstraction we
    will define now. A `Market` has various private attributes, as we saw before when
    we defined what data is expected from each file, and that''s the same data we
    see in our constructor. It also offers a `data()` method to send back a list with
    the data that should be saved to a database. Finally, it provides setters and
    getters as required. Note that the setter for the price depends on what units
    are requested, which can be either `usd` or `btc`, to get a market''s asset price
    in terms of US Dollars or Bitcoin, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `Market` definition, we proceed to create our `Exchange`
    definition. This class will receive an exchange name as `name` and will use the
    `exchange_requester_factory()` function to get an instance of the corresponding
    `ExchangeRequester`. It also offers an `update_markets()` method that will be
    used to retrieve market data with the private `markets()` method and store it
    to disk using the `timestamp` and `storage` objects being passed to it. Note that
    instead of passing the `timestamp` through the arguments for the private `markets()`
    method, it's saved as a class attribute and used within the private `insert_metadata()`
    method. This technique provides cleaner code, since the `timestamp` does not need
    to be passed through each function and can be retrieved when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private `markets()` method calls the public `markets()` method in the `ExchangeRequester`
    instance saved in the private `requester` attribute (which was assigned to by
    the factory) and applies the private `insert_metadata()` method to update the
    `timestamp` for such objects with the one sent to the public `update_markets()`
    method call before sending them to be written to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to provide a definition for our `ExchangeRequester` implementations.
    As in the case of the `Database`, this `ExchangeRequester` will act as an interface
    definition that will be implemented by the `CoinMarketCapRequester`. We see that
    the `ExchangeRequester` specifies that all exchange requester instances should
    provide a public `markets()` method, and that a list is expected from such a method.
    From context, we know that this list should contain `Market` instances. Also,
    each `ExchangeRequester` implementation will contain a `Requester` object by default,
    since it''s being created and assigned to the `requester` private attribute upon
    class instantiation. Finally, each implementation will also have to provide a
    `create_market()` private method and will be able to use the `request()` private
    method to communicate to the `Requester` method `request()` we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now we proceed to provide an implementation for `CoinMarketCapRequester`. As
    you can see, it inherits from `ExchangeRequester`, and it provides the required
    method implementations. Specifically, the `markets()` public method calls the
    private `request()` method from `ExchangeRequester`, which in turn calls the `request()`
    method from `Requester`, as we have seen, to retrieve data from the private `URL`
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you request data from CoinMarketCap''s API by opening a web browser and
    navigating to the URL shown ([https://api.coinmarketcap.com/v1/ticker](https://api.coinmarketcap.com/v1/ticker)),
    you will get a list of market data. That is the data that will be received in
    our `CoinMarketCapRequester` instance in the form of a dataframe, thanks to the
    `Requester` object, and will be transformed into numeric data where appropriate
    using the private `clean()` method, so that it''s later used to create `Market`
    instances with the `apply()` function call, which in turn calls the `create_market()`
    private method. Note that the `timestamp` is set to `NULL` for all markets created
    this way because, as you may remember from our `Exchange` class, it''s set before
    writing it to the database. There''s no need to send the `timestamp` information
    all the way down to the `CoinMarketCapRequester`, since we can simply write at
    the `Exchange` level right before we send the data to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s the code for our `exchange_requester_factory().` As you can
    see, it''s basically the same idea we have used for our other factories, and its
    purpose is to easily let us add more implementations for our `ExchangeRequeseter`
    by simply adding *else-if* statements in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Developing our wallets infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to retrieve live price data from exchanges, we turn to
    our `Wallet` definition. As you can see, it specifies the type of private attributes
    we expect for the data that it needs to handle, as well as the public `data()`
    method to create the list of data that needs to be saved to a database at some
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also provides getters for `email`, `symbol`, and `address`, and the public
    `pudate_assets()` method, which will be used to get and save assets into the database,
    just as we did in the case of `Exchange`. As a matter of fact, the techniques
    followed are exactly the same, so we won''t explain them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Implementing our wallet requesters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WalletRequester` will be conceptually similar to the `ExchangeRequester`.
    It will be an interface, and will be implemented in our `BTCRequester` and `LTCRequester`
    interfaces. As you can see, it requires a public method called `assets()` to be
    implemented and to return a list of `Asset` instances. It also requires a private
    `create_asset()` method to be implemented, which should return individual `Asset`
    instances, and a private `url` method that will build the URL required for the
    API call. It offers a `request()` private method that will be used by implementations
    to retrieve data from external APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BTCRequester` and `LTCRequester` implementations are shown below for completeness,
    but will not be explained. If you have followed everything so far, they should
    be easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wallet_requester_factory()` works just as the other factories; the only
    difference is that in this case, we have two possible implementations that can
    be returned, which can be seen in the `if` statement. If we decided to add a `WalletRequester`
    for another cryptocurrency, such as Ether, we could simply add the corresponding
    branch here, and it should work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Finally introducing users with S3 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our object-oriented system is almost finalized. We're only missing the `User`
    definition. In this case, we will use S3 to define the `User` class. The `user_constructor()`
    function takes an `email` and a `Storage` instance in `storage` to create a `User`
    instance. However, before it does, it checks that the email is valid with the
    `valid_email()` function defined below. After the user has been created, the `get_wallets()`
    method is called upon it to get the wallets associated to the user before it's
    sent back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `valid_email()` function simply receives a string which is supposed to
    be an email address, and checks whether at least one `@` and one `.` symbol are
    contained within it. Of course, this is not a robust mechanism to check whether
    or not it''s an email address, and it''s put here just to illustrate how a checking
    mechanism could be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_wallets.User()` function simply asks the `storage` attribute in the
    object to get the wallets associated to its own email address, assigns them to
    the `wallets` list attribute, and sends the `User` object back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new_wallet.User()` function receives a `User` instance, a `symbol` string,
    an `address` string, and `note` string to create a new `Wallet` instance and append
    it to the `wallets` list attribute for the `User` instance passed to it. However,
    before it does, it checks in all previous registered wallets for the user. If
    it finds that a wallet is already registered, it simply ignores the addition and
    sends the same `User` instance back. This is another type of checking that you
    may implement in your own systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update_assets.User()` function simply goes through each `Wallet` instance
    in the `wallets` list attribute and calls its public `update_assets()` method
    with the current `timestamps` that was passed to it and the `Storage` instance
    contained within the `User` instance. As we have seen before, this results in
    the assets being updated and saved to the database, and the `Wallet` object takes
    care of that on behalf of the `User` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `save.User()` function simply uses the `storage` attribute to save the
    `User` instance as well as its wallets data. As we have seen, if the wallets already
    exist in the saved data, they will not be duplicated, and the `CSVFiles` implementation
    takes care of that on behalf of the `User` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the user provides a `dataS3.User()` method to return a list with a
    user''s email to be saved back to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen in this section, after some work has been put into place, we
    can develop nice and intuitive abstractions that leverage the functionality implemented
    in other objects to provide powerful mechanisms, like saving data into a database,
    with very simple calls.
  prefs: []
  type: TYPE_NORMAL
- en: Helping ourselves with a centralized settings file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we show the famous centralized settings file we have been mentioning
    throughout the example. As you can see, it is simply a list of lists that contains
    parameters for how our system should behave. Centralizing these options in a single
    file as we do here can often be very convenient. Instead of changing code when
    we want different behaviors from our system, we can simply change this file, and
    everything will be taken care of for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, note that there's a `debug` Boolean that we did not end up using,
    but which could be useful when debugging our system at some point. Also, note
    that there are two main parts to our settings file, the `storage` part and the
    `batch_data_collection` part. The `storage` part is the one we have used so far,
    and it contains the specification for which databases should be used to read and
    write data by providing the name of the implementation that should be used in
    the `name` elements, and the `environment` we're currently operating on, which
    can be either `production` or `development`. Both of these elements are used by
    the factories to set up the system appropriately before it starts operating. Also,
    note that the CSV files that will be created correspond to the strings found in
    the `table_names` element, and will be different, depending on the `environment`
    a database is indicated to operate under.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our initial user data into the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start using our system, we need to introduce some data into it that
    will be used to start retrieving data for us. Specifically, we need to create
    some users, add some wallets to them, and save them. To do so, we create a `create-user-data.R`
    file that contains the script that will accomplish this for us. The script loads
    the S4 and R6 object models (S3 does not need to be loaded explicitly), sources
    the files with the definitions we directly need, which are `Storage`, `User`,
    and `SETTINGS`, creates two users for us, and saves them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: After the script is executed, you can look into the `csv-files/` directory and
    find the corresponding data inside. In this case, we used wallets with the most
    Bitcoin and Litecoin, which can be found online ([https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html](https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html)
    and [https://bitinfocharts.com/top-100-richest-litecoin-addresses.html](https://bitinfocharts.com/top-100-richest-litecoin-addresses.html)).
    You may experiment using your own wallets, or any wallet whose contents you want
    to track. Of course, the `email` and `note` parameters don't need to be real;
    the only parameters that must be real are the asset symbols, which can only be
    `BTC` or `LTC` for the system we have implemented, and the wallets addresses for
    such symbols. You may leave the `note` field empty, as we do in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Activating our system with two simple functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have loaded some data into the system, you will be able to execute
    the `update-markets.R` and `update-assets.R` files, whose contents are shown below.
    The first one loads the required definitions, as we did previously when creating
    the user data, and provides the `update_markets_loop()` function, which receives
    a parameter that specifies the number of minutes between each time the live market
    data is retrieved. Every 60 minutes is a good option, and it''s what we use below.
    The function simply creates a `Storage` instance using the `SETTINGS` specification
    shown before, gets the existing exchanges (which is only `CoinMarketCap` at this
    point), and calls the public `update_markets()` method on each of them, with the
    corresponding parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When you execute this file, you will see some data showing the progress in your
    console like the one shown below. Note that we start the script with the `Rscript` command
    we mentioned in [Chapter 1](part0022.html#KVCC0-f494c932c729429fb734ce52cafce730),
    *Introduction to R:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update_assets_loop()` function works similarly, but it retrieves the users
    in each iteration, which dynamically adapts to include any user additions or deletions
    that may have happened while the function was waiting for its next cycle, and
    calls the `update_assets()` public method for each `User` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of output for the `update-assets.R` file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: When you execute these two files, the whole object-oriented system we developed
    will start working to retrieve live data periodically and save it in the corresponding
    CSV files. You may look directly into these files to see what data is being saved.
    Remember that if a wallet does not contain a positive number of an asset, it will
    not be shown.
  prefs: []
  type: TYPE_NORMAL
- en: When you implement your first object-oriented system, it almost feels magical.
    If this is the first object-oriented system you have built, I certainly hope you
    got that feeling, and I also hope this example was interesting and useful for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Some advice when working with object-oriented systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming allows for a lot of flexibility, but if it's used
    incorrectly, it can also cause a lot of confusion, since it's easy to develop
    very complex systems when much simpler solutions would suffice.
  prefs: []
  type: TYPE_NORMAL
- en: You should start a small working system before evolving it into more complex
    ones. Also, realize that most real-world designs are over-constrained, and you
    will not be able to please everyone, so you must decide on the priorities for
    your system.
  prefs: []
  type: TYPE_NORMAL
- en: Each part of your system should focus on a single thing, and doing that thing
    well. When in doubt, make shorter things. Make shorter classes and shorter methods.
    Doing so will force your objects to focus on a single responsibility, which will
    in turn improve your design and will allow you to reuse code more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Make your objects as private as possible. Public classes should not have any
    public fields, that is, you should use encapsulation everywhere. Maximize information
    hiding and minimize coupling. Also, remember that names matter. Avoid cryptic
    abbreviations in your code, and be consistent. The same word should mean the same
    thing everywhere in your system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try to keep your code as immutable as possible. This produces code
    that is easy to understand, is much more reusable, and is thread-safe, which can
    be very useful when parallelizing, as we will see in the next chapter. However,
    if you implement a mutable system, keep the state space as small as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As general advice, your design should be easy to understand and difficult to
    misuse, even without documentation. Your code should be easily readable and easily
    maintainable, and the effort you invest in making code that is easy to change
    should be positively correlated with the likelihood of such change happening.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have introduced the fundamentals behind object-oriented
    programming, and we have seen how to implement object-oriented systems within
    R with three different object models: S3, S4, and R6\. We looked at the fundamental
    building blocks of object models, such as encapsulation, polymorphism, and hierarchies.
    We have shown you how to implement parametric polymorphism with S3 and S4, as
    well as regular polymorphism with R6, and we have shown how to use concepts like
    interfaces, even when there''s no explicit support for them in R.'
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented a full object-oriented system to track cryptocurrencies
    information, and, while doing so, have looked at various patterns and techniques,
    as well as how the three different object models can be used together.
  prefs: []
  type: TYPE_NORMAL
- en: The type of object model to use is the subject of some controversy among R programmers,
    and the decision depends on how flexible, formal, or intuitive you want the code
    to be. In general, if you prefer more flexibility use S3, if you prefer more formality
    and robustness use S4, and if you prefer your code to be easily understandable
    and intuitive to people who come from other languages and are not familiar with
    S3 and S4, then use R6\. However, controversy is still there.
  prefs: []
  type: TYPE_NORMAL
- en: John Chambers, the creator of the S language and one of the central developers
    of R, recommends S4 over S3 in his book, *Software for Data Analysis*, Springer,
    2008\. Google's *R Style Guide* ([https://google.github.io/styleguide/Rguide.xml](https://google.github.io/styleguide/Rguide.xml))
    says that you should avoid S4 whenever possible, and should use S3 instead.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, after having read this chapter, you will have a good idea of what
    system you'd prefer for your next project and why. In [Chapter 9](part0229.html#6QCGQ0-f494c932c729429fb734ce52cafce730),
    *Implementing an Efficient Simple Moving Average*, we will continue to expand
    the system we created in this chapter to make it more performant when we start
    dealing with large amounts of data.
  prefs: []
  type: TYPE_NORMAL
